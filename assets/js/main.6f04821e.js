(self["webpackChunkdocs_fintesk_com"] = self["webpackChunkdocs_fintesk_com"] || []).push([["1889"], {
22318: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;
exports.add = add;
exports.fromBig = fromBig;
exports.split = split;
/**
 * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.
 * @todo re-check https://issues.chromium.org/issues/42212588
 * @module
 */
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for (let i = 0; i < len; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, _l, s) => h >>> s;
exports.shrSH = shrSH;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
exports.rotrSH = rotrSH;
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
exports.rotrBH = rotrBH;
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
exports.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l) => l;
exports.rotr32H = rotr32H;
const rotr32L = (h, _l) => h;
exports.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
exports.rotlSH = rotlSH;
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
exports.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
exports.rotlBH = rotlBH;
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
exports.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
exports.add3L = add3L;
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
exports.add3H = add3H;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
exports.add4L = add4L;
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
exports.add4H = add4H;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
exports.add5L = add5L;
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
exports.add5H = add5H;
// prettier-ignore
const u64 = {
    fromBig, split, toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
exports["default"] = u64;
//# sourceMappingURL=_u64.js.map

}),
25145: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.crypto = void 0;
exports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;
//# sourceMappingURL=crypto.js.map

}),
32955: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = void 0;
exports.keccakP = keccakP;
/**
 * SHA3 (keccak) hash function, based on a new "Sponge function" design.
 * Different from older hashes, the internal state is bigger than output size.
 *
 * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),
 * [Website](https://keccak.team/keccak.html),
 * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).
 *
 * Check out `sha3-addons` module for cSHAKE, k12, and others.
 * @module
 */
const _u64_ts_1 = __webpack_require__(22318);
// prettier-ignore
const utils_ts_1 = __webpack_require__(99175);
// No __PURE__ annotations in sha3 header:
// EVERYTHING is in fact used on every export.
// Various per round constants calculations
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(0x71);
const SHA3_PI = [];
const SHA3_ROTL = [];
const _SHA3_IOTA = [];
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const IOTAS = (0, _u64_ts_1.split)(_SHA3_IOTA, true);
const SHA3_IOTA_H = IOTAS[0];
const SHA3_IOTA_L = IOTAS[1];
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => (s > 32 ? (0, _u64_ts_1.rotlBH)(h, l, s) : (0, _u64_ts_1.rotlSH)(h, l, s));
const rotlL = (h, l, s) => (s > 32 ? (0, _u64_ts_1.rotlBL)(h, l, s) : (0, _u64_ts_1.rotlSL)(h, l, s));
/** `keccakf1600` internal function, additionally allows to adjust round count. */
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta θ
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho (ρ) and Pi (π)
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi (χ)
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota (ι)
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    (0, utils_ts_1.clean)(B);
}
/** Keccak sponge function. */
class Keccak extends utils_ts_1.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        this.enableXOF = false;
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        // Can be passed from user as dkLen
        (0, utils_ts_1.anumber)(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        // 0 < blockLen < 200
        if (!(0 < blockLen && blockLen < 200))
            throw new Error('only keccak-f1600 function is supported');
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_ts_1.u32)(this.state);
    }
    clone() {
        return this._cloneInto();
    }
    keccak() {
        (0, utils_ts_1.swap32IfBE)(this.state32);
        keccakP(this.state32, this.rounds);
        (0, utils_ts_1.swap32IfBE)(this.state32);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { blockLen, state } = this;
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        (0, utils_ts_1.aexists)(this, false);
        (0, utils_ts_1.abytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        (0, utils_ts_1.anumber)(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        (0, utils_ts_1.aoutput)(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.state);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
exports.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen) => (0, utils_ts_1.createHasher)(() => new Keccak(blockLen, suffix, outputLen));
/** SHA3-224 hash function. */
exports.sha3_224 = (() => gen(0x06, 144, 224 / 8))();
/** SHA3-256 hash function. Different from keccak-256. */
exports.sha3_256 = (() => gen(0x06, 136, 256 / 8))();
/** SHA3-384 hash function. */
exports.sha3_384 = (() => gen(0x06, 104, 384 / 8))();
/** SHA3-512 hash function. */
exports.sha3_512 = (() => gen(0x06, 72, 512 / 8))();
/** keccak-224 hash function. */
exports.keccak_224 = (() => gen(0x01, 144, 224 / 8))();
/** keccak-256 hash function. Different from SHA3-256. */
exports.keccak_256 = (() => gen(0x01, 136, 256 / 8))();
/** keccak-384 hash function. */
exports.keccak_384 = (() => gen(0x01, 104, 384 / 8))();
/** keccak-512 hash function. */
exports.keccak_512 = (() => gen(0x01, 72, 512 / 8))();
const genShake = (suffix, blockLen, outputLen) => (0, utils_ts_1.createXOFer)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
/** SHAKE128 XOF with 128-bit security. */
exports.shake128 = (() => genShake(0x1f, 168, 128 / 8))();
/** SHAKE256 XOF with 256-bit security. */
exports.shake256 = (() => genShake(0x1f, 136, 256 / 8))();
//# sourceMappingURL=sha3.js.map

}),
99175: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

/**
 * Utilities for hex, bytes, CSPRNG.
 * @module
 */
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
exports.isBytes = isBytes;
exports.anumber = anumber;
exports.abytes = abytes;
exports.ahash = ahash;
exports.aexists = aexists;
exports.aoutput = aoutput;
exports.u8 = u8;
exports.u32 = u32;
exports.clean = clean;
exports.createView = createView;
exports.rotr = rotr;
exports.rotl = rotl;
exports.byteSwap = byteSwap;
exports.byteSwap32 = byteSwap32;
exports.bytesToHex = bytesToHex;
exports.hexToBytes = hexToBytes;
exports.asyncLoop = asyncLoop;
exports.utf8ToBytes = utf8ToBytes;
exports.bytesToUtf8 = bytesToUtf8;
exports.toBytes = toBytes;
exports.kdfInputToBytes = kdfInputToBytes;
exports.concatBytes = concatBytes;
exports.checkOpts = checkOpts;
exports.createHasher = createHasher;
exports.createOptHasher = createOptHasher;
exports.createXOFer = createXOFer;
exports.randomBytes = randomBytes;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
const crypto_1 = __webpack_require__(25145);
/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */
function isBytes(a) {
    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
}
/** Asserts something is positive integer. */
function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error('positive integer expected, got ' + n);
}
/** Asserts something is Uint8Array. */
function abytes(b, ...lengths) {
    if (!isBytes(b))
        throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
/** Asserts something is hash */
function ahash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function')
        throw new Error('Hash should be wrapped by utils.createHasher');
    anumber(h.outputLen);
    anumber(h.blockLen);
}
/** Asserts a hash instance has not been destroyed / finished */
function aexists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
/** Asserts output is properly-sized byte array */
function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error('digestInto() expects output buffer of length at least ' + min);
    }
}
/** Cast u8 / u16 / u32 to u8. */
function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** Cast u8 / u16 / u32 to u32. */
function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
/** Zeroize a byte array. Warning: JS provides no guarantees. */
function clean(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
    }
}
/** Create DataView of an array for easy byte-level manipulation. */
function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** The rotate right (circular right shift) operation for uint32 */
function rotr(word, shift) {
    return (word << (32 - shift)) | (word >>> shift);
}
/** The rotate left (circular left shift) operation for uint32 */
function rotl(word, shift) {
    return (word << shift) | ((word >>> (32 - shift)) >>> 0);
}
/** Is current platform little-endian? Most are. Big-Endian platform: IBM */
exports.isLE = (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();
/** The byte swap operation for uint32 */
function byteSwap(word) {
    return (((word << 24) & 0xff000000) |
        ((word << 8) & 0xff0000) |
        ((word >>> 8) & 0xff00) |
        ((word >>> 24) & 0xff));
}
/** Conditionally byte swap if on a big-endian platform */
exports.swap8IfBE = exports.isLE
    ? (n) => n
    : (n) => byteSwap(n);
/** @deprecated */
exports.byteSwapIfBE = exports.swap8IfBE;
/** In place byte swap for Uint32Array */
function byteSwap32(arr) {
    for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
    }
    return arr;
}
exports.swap32IfBE = exports.isLE
    ? (u) => u
    : byteSwap32;
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
const hasHexBuiltin = /* @__PURE__ */ (() => 
// @ts-ignore
typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * Convert byte array to hex string. Uses built-in function, when available.
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    abytes(bytes);
    // @ts-ignore
    if (hasHexBuiltin)
        return bytes.toHex();
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0; // '2' => 50-48
    if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10); // 'B' => 66-(65-10)
    if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10); // 'b' => 98-(97-10)
    return;
}
/**
 * Convert hex string to byte array. Uses built-in function, when available.
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    // @ts-ignore
    if (hasHexBuiltin)
        return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
        throw new Error('hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
    }
    return array;
}
/**
 * There is no setImmediate in browser and setTimeout is slow.
 * Call of async fn will return Promise, which will be fullfiled only on
 * next scheduler queue processing step and this is exactly what we need.
 */
const nextTick = async () => { };
exports.nextTick = nextTick;
/** Returns control to thread each 'tick' ms to avoid blocking. */
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
/**
 * Converts string to bytes using UTF8 encoding.
 * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error('string expected');
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Converts bytes to string using UTF8 encoding.
 * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'
 */
function bytesToUtf8(bytes) {
    return new TextDecoder().decode(bytes);
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/**
 * Helper for KDFs: consumes uint8array or string.
 * When string is passed, does utf8 decoding, using TextDecoder.
 */
function kdfInputToBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/** Copies several Uint8Arrays into one. */
function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
function checkOpts(defaults, opts) {
    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')
        throw new Error('options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
/** For runtime check if class implements interface */
class Hash {
}
exports.Hash = Hash;
/** Wraps hash function, creating an interface on top of it */
function createHasher(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}
function createOptHasher(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
function createXOFer(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapConstructor = createHasher;
exports.wrapConstructorWithOpts = createOptHasher;
exports.wrapXOFConstructorWithOpts = createXOFer;
/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */
function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    // Legacy Node.js compatibility
    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
}
//# sourceMappingURL=utils.js.map

}),
96389: (function (module, __unused_webpack_exports, __webpack_require__) {
var __webpack_unused_export__;
const { createId, init, getConstants, isCuid } = __webpack_require__(25228);

module.exports.createId = createId;
__webpack_unused_export__ = init;
__webpack_unused_export__ = getConstants;
__webpack_unused_export__ = isCuid;


}),
25228: (function (module, __unused_webpack_exports, __webpack_require__) {
/* global global, window, module */
const { sha3_512: sha3 } = __webpack_require__(32955);

const defaultLength = 24;
const bigLength = 32;

const createEntropy = (length = 4, random = Math.random) => {
  let entropy = "";

  while (entropy.length < length) {
    entropy = entropy + Math.floor(random() * 36).toString(36);
  }
  return entropy;
};

/*
 * Adapted from https://github.com/juanelas/bigint-conversion
 * MIT License Copyright (c) 2018 Juan Hernández Serrano
 */
function bufToBigInt(buf) {
  let bits = BigInt(8);

  let value = BigInt(0);
  for (const i of buf.values()) {
    const bi = BigInt(i);
    value = (value << bits) + bi;
  }
  return value;
}

const hash = (input = "") => {
  // Drop the first character because it will bias the histogram
  // to the left.
  return bufToBigInt(sha3(input)).toString(36).slice(1);
};

const alphabet = Array.from({ length: 26 }, (x, i) =>
  String.fromCharCode(i + 97)
);

const randomLetter = (random) =>
  alphabet[Math.floor(random() * alphabet.length)];

/*
This is a fingerprint of the host environment. It is used to help
prevent collisions when generating ids in a distributed system.
If no global object is available, you can pass in your own, or fall back
on a random string.
*/
const createFingerprint = ({
  globalObj = typeof __webpack_require__.g !== "undefined"
    ? __webpack_require__.g
    : typeof window !== "undefined"
    ? window
    : {},
  random = Math.random,
} = {}) => {
  const globals = Object.keys(globalObj).toString();
  const sourceString = globals.length
    ? globals + createEntropy(bigLength, random)
    : createEntropy(bigLength, random);

  return hash(sourceString).substring(0, bigLength);
};

const createCounter = (count) => () => {
  return count++;
};

// ~22k hosts before 50% chance of initial counter collision
// with a remaining counter range of 9.0e+15 in JavaScript.
const initialCountMax = 476782367;

const init = ({
  // Fallback if the user does not pass in a CSPRNG. This should be OK
  // because we don't rely solely on the random number generator for entropy.
  // We also use the host fingerprint, current time, and a session counter.
  random = Math.random,
  counter = createCounter(Math.floor(random() * initialCountMax)),
  length = defaultLength,
  fingerprint = createFingerprint({ random }),
} = {}) => {
  return function cuid2() {
    const firstLetter = randomLetter(random);

    // If we're lucky, the `.toString(36)` calls may reduce hashing rounds
    // by shortening the input to the hash function a little.
    const time = Date.now().toString(36);
    const count = counter().toString(36);

    // The salt should be long enough to be globally unique across the full
    // length of the hash. For simplicity, we use the same length as the
    // intended id output.
    const salt = createEntropy(length, random);
    const hashInput = `${time + salt + count + fingerprint}`;

    return `${firstLetter + hash(hashInput).substring(1, length)}`;
  };
};

const createId = init();

const isCuid = (id, { minLength = 2, maxLength = bigLength } = {}) => {
  const length = id.length;
  const regex = /^[a-z][0-9a-z]+$/;

  try {
    if (
      typeof id === "string" &&
      length >= minLength &&
      length <= maxLength &&
      regex.test(id)
    )
      return true;
  } finally {
  }

  return false;
};

module.exports.getConstants = () => ({ defaultLength, bigLength });
module.exports.init = init;
module.exports.createId = createId;
module.exports.bufToBigInt = bufToBigInt;
module.exports.createCounter = createCounter;
module.exports.createFingerprint = createFingerprint;
module.exports.isCuid = isCuid;


}),
77612: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by css-extract-rspack-plugin


}),
56814: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by css-extract-rspack-plugin


}),
87570: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by css-extract-rspack-plugin


}),
56464: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by css-extract-rspack-plugin


}),
16448: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by css-extract-rspack-plugin


}),
33328: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  AO: () => (/* binding */ createPath),
  yJ: () => (/* binding */ createLocation),
  sC: () => (/* binding */ createMemoryHistory),
  TM: () => (/* binding */ createHashHistory),
  zR: () => (/* binding */ createBrowserHistory)
});

// UNUSED EXPORTS: parsePath, locationsAreEqual

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__(58168);
;// CONCATENATED MODULE: ./node_modules/resolve-pathname/esm/resolve-pathname.js
function isAbsolute(pathname) {
  return pathname.charAt(0) === '/';
}

// About 1.5x faster than the two-arg version of Array#splice()
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
    list[i] = list[k];
  }

  list.pop();
}

// This implementation is based heavily on node's url.parse
function resolvePathname(to, from) {
  if (from === undefined) from = '';

  var toParts = (to && to.split('/')) || [];
  var fromParts = (from && from.split('/')) || [];

  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;

  if (to && isAbsolute(to)) {
    // to is absolute
    fromParts = toParts;
  } else if (toParts.length) {
    // to is relative, drop the filename
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }

  if (!fromParts.length) return '/';

  var hasTrailingSlash;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === '.' || last === '..' || last === '';
  } else {
    hasTrailingSlash = false;
  }

  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];

    if (part === '.') {
      spliceOne(fromParts, i);
    } else if (part === '..') {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }

  if (!mustEndAbs) for (; up--; up) fromParts.unshift('..');

  if (
    mustEndAbs &&
    fromParts[0] !== '' &&
    (!fromParts[0] || !isAbsolute(fromParts[0]))
  )
    fromParts.unshift('');

  var result = fromParts.join('/');

  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';

  return result;
}

/* export default */ const resolve_pathname = (resolvePathname);

// EXTERNAL MODULE: ./node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var tiny_invariant = __webpack_require__(11561);
;// CONCATENATED MODULE: ./node_modules/history/esm/history.js






function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
}
function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
}
function hasBasename(path, prefix) {
  return path.toLowerCase().indexOf(prefix.toLowerCase()) === 0 && '/?#'.indexOf(path.charAt(prefix.length)) !== -1;
}
function stripBasename(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
}
function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
}
function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';
  var hashIndex = pathname.indexOf('#');

  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');

  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
}
function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;
  var path = pathname || '/';
  if (search && search !== '?') path += search.charAt(0) === '?' ? search : "?" + search;
  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : "#" + hash;
  return path;
}

function createLocation(path, state, key, currentLocation) {
  var location;

  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = parsePath(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = (0,esm_extends/* ["default"] */.A)({}, path);
    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = resolve_pathname(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
}
function locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && valueEqual(a.state, b.state);
}

function createTransitionManager() {
  var prompt = null;

  function setPrompt(nextPrompt) {
     false ? 0 : void 0;
    prompt = nextPrompt;
    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  }

  function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
           false ? 0 : void 0;
          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  }

  var listeners = [];

  function appendListener(fn) {
    var isActive = true;

    function listener() {
      if (isActive) fn.apply(void 0, arguments);
    }

    listeners.push(listener);
    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  }

  function notifyListeners() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(void 0, args);
    });
  }

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
}

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
function getConfirmation(message, callback) {
  callback(window.confirm(message)); // eslint-disable-line no-alert
}
/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */

function supportsHistory() {
  var ua = window.navigator.userAgent;
  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;
  return window.history && 'pushState' in window.history;
}
/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */

function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
}
/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */

function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
}
/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */

function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
}

var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
}
/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */


function createBrowserHistory(props) {
  if (props === void 0) {
    props = {};
  }

  !canUseDOM ?  false ? 0 : (0,tiny_invariant/* ["default"] */.A)(false) : void 0;
  var globalHistory = window.history;
  var canUseHistory = supportsHistory();
  var needsHashChangeListener = !supportsPopStateOnHashChange();
  var _props = props,
      _props$forceRefresh = _props.forceRefresh,
      forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh,
      _props$getUserConfirm = _props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,
      _props$keyLength = _props.keyLength,
      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';

  function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;
    var path = pathname + search + hash;
     false ? 0 : void 0;
    if (basename) path = stripBasename(path, basename);
    return createLocation(path, state, key);
  }

  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }

  var transitionManager = createTransitionManager();

  function setState(nextState) {
    (0,esm_extends/* ["default"] */.A)(history, nextState);

    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }

  function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if (isExtraneousPopstateEvent(event)) return;
    handlePop(getDOMLocation(event.state));
  }

  function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  }

  var forceNextPop = false;

  function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({
            action: action,
            location: location
          });
        } else {
          revertPop(location);
        }
      });
    }
  }

  function revertPop(fromLocation) {
    var toLocation = history.location; // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);
    if (toIndex === -1) toIndex = 0;
    var fromIndex = allKeys.indexOf(fromLocation.key);
    if (fromIndex === -1) fromIndex = 0;
    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  }

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key]; // Public interface

  function createHref(location) {
    return basename + createPath(location);
  }

  function push(path, state) {
     false ? 0 : void 0;
    var action = 'PUSH';
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var href = createHref(location);
      var key = location.key,
          state = location.state;

      if (canUseHistory) {
        globalHistory.pushState({
          key: key,
          state: state
        }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex + 1);
          nextKeys.push(location.key);
          allKeys = nextKeys;
          setState({
            action: action,
            location: location
          });
        }
      } else {
         false ? 0 : void 0;
        window.location.href = href;
      }
    });
  }

  function replace(path, state) {
     false ? 0 : void 0;
    var action = 'REPLACE';
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var href = createHref(location);
      var key = location.key,
          state = location.state;

      if (canUseHistory) {
        globalHistory.replaceState({
          key: key,
          state: state
        }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          if (prevIndex !== -1) allKeys[prevIndex] = location.key;
          setState({
            action: action,
            location: location
          });
        }
      } else {
         false ? 0 : void 0;
        window.location.replace(href);
      }
    });
  }

  function go(n) {
    globalHistory.go(n);
  }

  function goBack() {
    go(-1);
  }

  function goForward() {
    go(1);
  }

  var listenerCount = 0;

  function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener) window.addEventListener(HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener) window.removeEventListener(HashChangeEvent, handleHashChange);
    }
  }

  var isBlocked = false;

  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  }

  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  }

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };
  return history;
}

var HashChangeEvent$1 = 'hashchange';
var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: stripLeadingSlash,
    decodePath: addLeadingSlash
  },
  slash: {
    encodePath: addLeadingSlash,
    decodePath: addLeadingSlash
  }
};

function stripHash(url) {
  var hashIndex = url.indexOf('#');
  return hashIndex === -1 ? url : url.slice(0, hashIndex);
}

function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
}

function pushHashPath(path) {
  window.location.hash = path;
}

function replaceHashPath(path) {
  window.location.replace(stripHash(window.location.href) + '#' + path);
}

function createHashHistory(props) {
  if (props === void 0) {
    props = {};
  }

  !canUseDOM ?  false ? 0 : (0,tiny_invariant/* ["default"] */.A)(false) : void 0;
  var globalHistory = window.history;
  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();
  var _props = props,
      _props$getUserConfirm = _props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,
      _props$hashType = _props.hashType,
      hashType = _props$hashType === void 0 ? 'slash' : _props$hashType;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';
  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;

  function getDOMLocation() {
    var path = decodePath(getHashPath());
     false ? 0 : void 0;
    if (basename) path = stripBasename(path, basename);
    return createLocation(path);
  }

  var transitionManager = createTransitionManager();

  function setState(nextState) {
    (0,esm_extends/* ["default"] */.A)(history, nextState);

    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }

  var forceNextPop = false;
  var ignorePath = null;

  function locationsAreEqual$$1(a, b) {
    return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;
  }

  function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;
      if (!forceNextPop && locationsAreEqual$$1(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;
      handlePop(location);
    }
  }

  function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({
            action: action,
            location: location
          });
        } else {
          revertPop(location);
        }
      });
    }
  }

  function revertPop(fromLocation) {
    var toLocation = history.location; // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf(createPath(toLocation));
    if (toIndex === -1) toIndex = 0;
    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
    if (fromIndex === -1) fromIndex = 0;
    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  } // Ensure the hash is encoded properly before doing anything else.


  var path = getHashPath();
  var encodedPath = encodePath(path);
  if (path !== encodedPath) replaceHashPath(encodedPath);
  var initialLocation = getDOMLocation();
  var allPaths = [createPath(initialLocation)]; // Public interface

  function createHref(location) {
    var baseTag = document.querySelector('base');
    var href = '';

    if (baseTag && baseTag.getAttribute('href')) {
      href = stripHash(window.location.href);
    }

    return href + '#' + encodePath(basename + createPath(location));
  }

  function push(path, state) {
     false ? 0 : void 0;
    var action = 'PUSH';
    var location = createLocation(path, undefined, undefined, history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var path = createPath(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a PUSH, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        pushHashPath(encodedPath);
        var prevIndex = allPaths.lastIndexOf(createPath(history.location));
        var nextPaths = allPaths.slice(0, prevIndex + 1);
        nextPaths.push(path);
        allPaths = nextPaths;
        setState({
          action: action,
          location: location
        });
      } else {
         false ? 0 : void 0;
        setState();
      }
    });
  }

  function replace(path, state) {
     false ? 0 : void 0;
    var action = 'REPLACE';
    var location = createLocation(path, undefined, undefined, history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var path = createPath(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        replaceHashPath(encodedPath);
      }

      var prevIndex = allPaths.indexOf(createPath(history.location));
      if (prevIndex !== -1) allPaths[prevIndex] = path;
      setState({
        action: action,
        location: location
      });
    });
  }

  function go(n) {
     false ? 0 : void 0;
    globalHistory.go(n);
  }

  function goBack() {
    go(-1);
  }

  function goForward() {
    go(1);
  }

  var listenerCount = 0;

  function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(HashChangeEvent$1, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(HashChangeEvent$1, handleHashChange);
    }
  }

  var isBlocked = false;

  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  }

  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  }

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };
  return history;
}

function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
}
/**
 * Creates a history object that stores locations in memory.
 */


function createMemoryHistory(props) {
  if (props === void 0) {
    props = {};
  }

  var _props = props,
      getUserConfirmation = _props.getUserConfirmation,
      _props$initialEntries = _props.initialEntries,
      initialEntries = _props$initialEntries === void 0 ? ['/'] : _props$initialEntries,
      _props$initialIndex = _props.initialIndex,
      initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex,
      _props$keyLength = _props.keyLength,
      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var transitionManager = createTransitionManager();

  function setState(nextState) {
    (0,esm_extends/* ["default"] */.A)(history, nextState);

    history.length = history.entries.length;
    transitionManager.notifyListeners(history.location, history.action);
  }

  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? createLocation(entry, undefined, createKey()) : createLocation(entry, undefined, entry.key || createKey());
  }); // Public interface

  var createHref = createPath;

  function push(path, state) {
     false ? 0 : void 0;
    var action = 'PUSH';
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;
      var nextEntries = history.entries.slice(0);

      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  }

  function replace(path, state) {
     false ? 0 : void 0;
    var action = 'REPLACE';
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      history.entries[history.index] = location;
      setState({
        action: action,
        location: location
      });
    });
  }

  function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);
    var action = 'POP';
    var location = history.entries[nextIndex];
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  }

  function goBack() {
    go(-1);
  }

  function goForward() {
    go(1);
  }

  function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  }

  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }

    return transitionManager.setPrompt(prompt);
  }

  function listen(listener) {
    return transitionManager.appendListener(listener);
  }

  var history = {
    length: entries.length,
    action: 'POP',
    location: entries[index],
    index: index,
    entries: entries,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };
  return history;
}




}),
4146: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var reactIs = __webpack_require__(44363);

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

module.exports = hoistNonReactStatics;


}),
20311: (function (module) {
"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (false) {}

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;


}),
64634: (function (module) {
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};


}),
5947: (function (module) {
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */

;(function(root, factory) {

  if (typeof define === 'function' && define.amd) {
    define(factory);
  } else if (true) {
    module.exports = factory();
  } else {}

})(this, function() {
  var NProgress = {};

  NProgress.version = '0.2.0';

  var Settings = NProgress.settings = {
    minimum: 0.08,
    easing: 'ease',
    positionUsing: '',
    speed: 200,
    trickle: true,
    trickleRate: 0.02,
    trickleSpeed: 800,
    showSpinner: true,
    barSelector: '[role="bar"]',
    spinnerSelector: '[role="spinner"]',
    parent: 'body',
    template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
  };

  /**
   * Updates configuration.
   *
   *     NProgress.configure({
   *       minimum: 0.1
   *     });
   */
  NProgress.configure = function(options) {
    var key, value;
    for (key in options) {
      value = options[key];
      if (value !== undefined && options.hasOwnProperty(key)) Settings[key] = value;
    }

    return this;
  };

  /**
   * Last number.
   */

  NProgress.status = null;

  /**
   * Sets the progress bar status, where `n` is a number from `0.0` to `1.0`.
   *
   *     NProgress.set(0.4);
   *     NProgress.set(1.0);
   */

  NProgress.set = function(n) {
    var started = NProgress.isStarted();

    n = clamp(n, Settings.minimum, 1);
    NProgress.status = (n === 1 ? null : n);

    var progress = NProgress.render(!started),
        bar      = progress.querySelector(Settings.barSelector),
        speed    = Settings.speed,
        ease     = Settings.easing;

    progress.offsetWidth; /* Repaint */

    queue(function(next) {
      // Set positionUsing if it hasn't already been set
      if (Settings.positionUsing === '') Settings.positionUsing = NProgress.getPositioningCSS();

      // Add transition
      css(bar, barPositionCSS(n, speed, ease));

      if (n === 1) {
        // Fade out
        css(progress, { 
          transition: 'none', 
          opacity: 1 
        });
        progress.offsetWidth; /* Repaint */

        setTimeout(function() {
          css(progress, { 
            transition: 'all ' + speed + 'ms linear', 
            opacity: 0 
          });
          setTimeout(function() {
            NProgress.remove();
            next();
          }, speed);
        }, speed);
      } else {
        setTimeout(next, speed);
      }
    });

    return this;
  };

  NProgress.isStarted = function() {
    return typeof NProgress.status === 'number';
  };

  /**
   * Shows the progress bar.
   * This is the same as setting the status to 0%, except that it doesn't go backwards.
   *
   *     NProgress.start();
   *
   */
  NProgress.start = function() {
    if (!NProgress.status) NProgress.set(0);

    var work = function() {
      setTimeout(function() {
        if (!NProgress.status) return;
        NProgress.trickle();
        work();
      }, Settings.trickleSpeed);
    };

    if (Settings.trickle) work();

    return this;
  };

  /**
   * Hides the progress bar.
   * This is the *sort of* the same as setting the status to 100%, with the
   * difference being `done()` makes some placebo effect of some realistic motion.
   *
   *     NProgress.done();
   *
   * If `true` is passed, it will show the progress bar even if its hidden.
   *
   *     NProgress.done(true);
   */

  NProgress.done = function(force) {
    if (!force && !NProgress.status) return this;

    return NProgress.inc(0.3 + 0.5 * Math.random()).set(1);
  };

  /**
   * Increments by a random amount.
   */

  NProgress.inc = function(amount) {
    var n = NProgress.status;

    if (!n) {
      return NProgress.start();
    } else {
      if (typeof amount !== 'number') {
        amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95);
      }

      n = clamp(n + amount, 0, 0.994);
      return NProgress.set(n);
    }
  };

  NProgress.trickle = function() {
    return NProgress.inc(Math.random() * Settings.trickleRate);
  };

  /**
   * Waits for all supplied jQuery promises and
   * increases the progress as the promises resolve.
   *
   * @param $promise jQUery Promise
   */
  (function() {
    var initial = 0, current = 0;

    NProgress.promise = function($promise) {
      if (!$promise || $promise.state() === "resolved") {
        return this;
      }

      if (current === 0) {
        NProgress.start();
      }

      initial++;
      current++;

      $promise.always(function() {
        current--;
        if (current === 0) {
            initial = 0;
            NProgress.done();
        } else {
            NProgress.set((initial - current) / initial);
        }
      });

      return this;
    };

  })();

  /**
   * (Internal) renders the progress bar markup based on the `template`
   * setting.
   */

  NProgress.render = function(fromStart) {
    if (NProgress.isRendered()) return document.getElementById('nprogress');

    addClass(document.documentElement, 'nprogress-busy');
    
    var progress = document.createElement('div');
    progress.id = 'nprogress';
    progress.innerHTML = Settings.template;

    var bar      = progress.querySelector(Settings.barSelector),
        perc     = fromStart ? '-100' : toBarPerc(NProgress.status || 0),
        parent   = document.querySelector(Settings.parent),
        spinner;
    
    css(bar, {
      transition: 'all 0 linear',
      transform: 'translate3d(' + perc + '%,0,0)'
    });

    if (!Settings.showSpinner) {
      spinner = progress.querySelector(Settings.spinnerSelector);
      spinner && removeElement(spinner);
    }

    if (parent != document.body) {
      addClass(parent, 'nprogress-custom-parent');
    }

    parent.appendChild(progress);
    return progress;
  };

  /**
   * Removes the element. Opposite of render().
   */

  NProgress.remove = function() {
    removeClass(document.documentElement, 'nprogress-busy');
    removeClass(document.querySelector(Settings.parent), 'nprogress-custom-parent');
    var progress = document.getElementById('nprogress');
    progress && removeElement(progress);
  };

  /**
   * Checks if the progress bar is rendered.
   */

  NProgress.isRendered = function() {
    return !!document.getElementById('nprogress');
  };

  /**
   * Determine which positioning CSS rule to use.
   */

  NProgress.getPositioningCSS = function() {
    // Sniff on document.body.style
    var bodyStyle = document.body.style;

    // Sniff prefixes
    var vendorPrefix = ('WebkitTransform' in bodyStyle) ? 'Webkit' :
                       ('MozTransform' in bodyStyle) ? 'Moz' :
                       ('msTransform' in bodyStyle) ? 'ms' :
                       ('OTransform' in bodyStyle) ? 'O' : '';

    if (vendorPrefix + 'Perspective' in bodyStyle) {
      // Modern browsers with 3D support, e.g. Webkit, IE10
      return 'translate3d';
    } else if (vendorPrefix + 'Transform' in bodyStyle) {
      // Browsers without 3D support, e.g. IE9
      return 'translate';
    } else {
      // Browsers without translate() support, e.g. IE7-8
      return 'margin';
    }
  };

  /**
   * Helpers
   */

  function clamp(n, min, max) {
    if (n < min) return min;
    if (n > max) return max;
    return n;
  }

  /**
   * (Internal) converts a percentage (`0..1`) to a bar translateX
   * percentage (`-100%..0%`).
   */

  function toBarPerc(n) {
    return (-1 + n) * 100;
  }


  /**
   * (Internal) returns the correct CSS for changing the bar's
   * position given an n percentage, and speed and ease from Settings
   */

  function barPositionCSS(n, speed, ease) {
    var barCSS;

    if (Settings.positionUsing === 'translate3d') {
      barCSS = { transform: 'translate3d('+toBarPerc(n)+'%,0,0)' };
    } else if (Settings.positionUsing === 'translate') {
      barCSS = { transform: 'translate('+toBarPerc(n)+'%,0)' };
    } else {
      barCSS = { 'margin-left': toBarPerc(n)+'%' };
    }

    barCSS.transition = 'all '+speed+'ms '+ease;

    return barCSS;
  }

  /**
   * (Internal) Queues a function to be executed.
   */

  var queue = (function() {
    var pending = [];
    
    function next() {
      var fn = pending.shift();
      if (fn) {
        fn(next);
      }
    }

    return function(fn) {
      pending.push(fn);
      if (pending.length == 1) next();
    };
  })();

  /**
   * (Internal) Applies css properties to an element, similar to the jQuery 
   * css method.
   *
   * While this helper does assist with vendor prefixed property names, it 
   * does not perform any manipulation of values prior to setting styles.
   */

  var css = (function() {
    var cssPrefixes = [ 'Webkit', 'O', 'Moz', 'ms' ],
        cssProps    = {};

    function camelCase(string) {
      return string.replace(/^-ms-/, 'ms-').replace(/-([\da-z])/gi, function(match, letter) {
        return letter.toUpperCase();
      });
    }

    function getVendorProp(name) {
      var style = document.body.style;
      if (name in style) return name;

      var i = cssPrefixes.length,
          capName = name.charAt(0).toUpperCase() + name.slice(1),
          vendorName;
      while (i--) {
        vendorName = cssPrefixes[i] + capName;
        if (vendorName in style) return vendorName;
      }

      return name;
    }

    function getStyleProp(name) {
      name = camelCase(name);
      return cssProps[name] || (cssProps[name] = getVendorProp(name));
    }

    function applyCss(element, prop, value) {
      prop = getStyleProp(prop);
      element.style[prop] = value;
    }

    return function(element, properties) {
      var args = arguments,
          prop, 
          value;

      if (args.length == 2) {
        for (prop in properties) {
          value = properties[prop];
          if (value !== undefined && properties.hasOwnProperty(prop)) applyCss(element, prop, value);
        }
      } else {
        applyCss(element, args[1], args[2]);
      }
    }
  })();

  /**
   * (Internal) Determines if an element or space separated list of class names contains a class name.
   */

  function hasClass(element, name) {
    var list = typeof element == 'string' ? element : classList(element);
    return list.indexOf(' ' + name + ' ') >= 0;
  }

  /**
   * (Internal) Adds a class to an element.
   */

  function addClass(element, name) {
    var oldList = classList(element),
        newList = oldList + name;

    if (hasClass(oldList, name)) return; 

    // Trim the opening space.
    element.className = newList.substring(1);
  }

  /**
   * (Internal) Removes a class from an element.
   */

  function removeClass(element, name) {
    var oldList = classList(element),
        newList;

    if (!hasClass(element, name)) return;

    // Replace the class name.
    newList = oldList.replace(' ' + name + ' ', ' ');

    // Trim the opening and closing spaces.
    element.className = newList.substring(1, newList.length - 1);
  }

  /**
   * (Internal) Gets a space separated list of the class names on the element. 
   * The list is wrapped with a single space on each end to facilitate finding 
   * matches within the list.
   */

  function classList(element) {
    return (' ' + (element.className || '') + ' ').replace(/\s+/gi, ' ');
  }

  /**
   * (Internal) Removes an element from the DOM.
   */

  function removeElement(element) {
    element && element.parentNode && element.parentNode.removeChild(element);
  }

  return NProgress;
});



}),
19700: (function () {
(function (Prism) {

	/**
	 * Returns the placeholder for the given language id and index.
	 *
	 * @param {string} language
	 * @param {string|number} index
	 * @returns {string}
	 */
	function getPlaceholder(language, index) {
		return '___' + language.toUpperCase() + index + '___';
	}

	Object.defineProperties(Prism.languages['markup-templating'] = {}, {
		buildPlaceholders: {
			/**
			 * Tokenize all inline templating expressions matching `placeholderPattern`.
			 *
			 * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns
			 * `true` will be replaced.
			 *
			 * @param {object} env The environment of the `before-tokenize` hook.
			 * @param {string} language The language id.
			 * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.
			 * @param {(match: string) => boolean} [replaceFilter]
			 */
			value: function (env, language, placeholderPattern, replaceFilter) {
				if (env.language !== language) {
					return;
				}

				var tokenStack = env.tokenStack = [];

				env.code = env.code.replace(placeholderPattern, function (match) {
					if (typeof replaceFilter === 'function' && !replaceFilter(match)) {
						return match;
					}
					var i = tokenStack.length;
					var placeholder;

					// Check for existing strings
					while (env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1) {
						++i;
					}

					// Create a sparse array
					tokenStack[i] = match;

					return placeholder;
				});

				// Switch the grammar to markup
				env.grammar = Prism.languages.markup;
			}
		},
		tokenizePlaceholders: {
			/**
			 * Replace placeholders with proper tokens after tokenizing.
			 *
			 * @param {object} env The environment of the `after-tokenize` hook.
			 * @param {string} language The language id.
			 */
			value: function (env, language) {
				if (env.language !== language || !env.tokenStack) {
					return;
				}

				// Switch the grammar back
				env.grammar = Prism.languages[language];

				var j = 0;
				var keys = Object.keys(env.tokenStack);

				function walkTokens(tokens) {
					for (var i = 0; i < tokens.length; i++) {
						// all placeholders are replaced already
						if (j >= keys.length) {
							break;
						}

						var token = tokens[i];
						if (typeof token === 'string' || (token.content && typeof token.content === 'string')) {
							var k = keys[j];
							var t = env.tokenStack[k];
							var s = typeof token === 'string' ? token : token.content;
							var placeholder = getPlaceholder(language, k);

							var index = s.indexOf(placeholder);
							if (index > -1) {
								++j;

								var before = s.substring(0, index);
								var middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), 'language-' + language, t);
								var after = s.substring(index + placeholder.length);

								var replacement = [];
								if (before) {
									replacement.push.apply(replacement, walkTokens([before]));
								}
								replacement.push(middle);
								if (after) {
									replacement.push.apply(replacement, walkTokens([after]));
								}

								if (typeof token === 'string') {
									tokens.splice.apply(tokens, [i, 1].concat(replacement));
								} else {
									token.content = replacement;
								}
							}
						} else if (token.content /* && typeof token.content !== 'string' */) {
							walkTokens(token.content);
						}
					}

					return tokens;
				}

				walkTokens(env.tokens);
			}
		}
	});

}(Prism));


}),
43554: (function () {
/**
 * Original by Aaron Harun: http://aahacreative.com/2012/07/31/php-syntax-highlighting-prism/
 * Modified by Miles Johnson: http://milesj.me
 * Rewritten by Tom Pavelec
 *
 * Supports PHP 5.3 - 8.0
 */
(function (Prism) {
	var comment = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/;
	var constant = [
		{
			pattern: /\b(?:false|true)\b/i,
			alias: 'boolean'
		},
		{
			pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
			greedy: true,
			lookbehind: true,
		},
		{
			pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
			greedy: true,
			lookbehind: true,
		},
		/\b(?:null)\b/i,
		/\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/,
	];
	var number = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i;
	var operator = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/;
	var punctuation = /[{}\[\](),:;]/;

	Prism.languages.php = {
		'delimiter': {
			pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
			alias: 'important'
		},
		'comment': comment,
		'variable': /\$+(?:\w+\b|(?=\{))/,
		'package': {
			pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
			lookbehind: true,
			inside: {
				'punctuation': /\\/
			}
		},
		'class-name-definition': {
			pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
			lookbehind: true,
			alias: 'class-name'
		},
		'function-definition': {
			pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
			lookbehind: true,
			alias: 'function'
		},
		'keyword': [
			{
				pattern: /(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i,
				alias: 'type-casting',
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i,
				alias: 'type-hint',
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|never|object|self|static|string|void)\b/i,
				alias: 'return-type',
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i,
				alias: 'type-declaration',
				greedy: true
			},
			{
				pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i,
				alias: 'type-declaration',
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /\b(?:parent|self|static)(?=\s*::)/i,
				alias: 'static-context',
				greedy: true
			},
			{
				// yield from
				pattern: /(\byield\s+)from\b/i,
				lookbehind: true
			},
			// `class` is always a keyword unlike other keywords
			/\bclass\b/i,
			{
				// https://www.php.net/manual/en/reserved.keywords.php
				//
				// keywords cannot be preceded by "->"
				// the complex lookbehind means `(?<!(?:->|::)\s*)`
				pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|never|new|or|parent|print|private|protected|public|readonly|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i,
				lookbehind: true
			}
		],
		'argument-name': {
			pattern: /([(,]\s*)\b[a-z_]\w*(?=\s*:(?!:))/i,
			lookbehind: true
		},
		'class-name': [
			{
				pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,
				greedy: true
			},
			{
				pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
				alias: 'class-name-fully-qualified',
				greedy: true,
				lookbehind: true,
				inside: {
					'punctuation': /\\/
				}
			},
			{
				pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
				alias: 'class-name-fully-qualified',
				greedy: true,
				inside: {
					'punctuation': /\\/
				}
			},
			{
				pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
				alias: 'class-name-fully-qualified',
				greedy: true,
				lookbehind: true,
				inside: {
					'punctuation': /\\/
				}
			},
			{
				pattern: /\b[a-z_]\w*(?=\s*\$)/i,
				alias: 'type-declaration',
				greedy: true
			},
			{
				pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
				alias: ['class-name-fully-qualified', 'type-declaration'],
				greedy: true,
				inside: {
					'punctuation': /\\/
				}
			},
			{
				pattern: /\b[a-z_]\w*(?=\s*::)/i,
				alias: 'static-context',
				greedy: true
			},
			{
				pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
				alias: ['class-name-fully-qualified', 'static-context'],
				greedy: true,
				inside: {
					'punctuation': /\\/
				}
			},
			{
				pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
				alias: 'type-hint',
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
				alias: ['class-name-fully-qualified', 'type-hint'],
				greedy: true,
				lookbehind: true,
				inside: {
					'punctuation': /\\/
				}
			},
			{
				pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
				alias: 'return-type',
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
				alias: ['class-name-fully-qualified', 'return-type'],
				greedy: true,
				lookbehind: true,
				inside: {
					'punctuation': /\\/
				}
			}
		],
		'constant': constant,
		'function': {
			pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
			lookbehind: true,
			inside: {
				'punctuation': /\\/
			}
		},
		'property': {
			pattern: /(->\s*)\w+/,
			lookbehind: true
		},
		'number': number,
		'operator': operator,
		'punctuation': punctuation
	};

	var string_interpolation = {
		pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
		lookbehind: true,
		inside: Prism.languages.php
	};

	var string = [
		{
			pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
			alias: 'nowdoc-string',
			greedy: true,
			inside: {
				'delimiter': {
					pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
					alias: 'symbol',
					inside: {
						'punctuation': /^<<<'?|[';]$/
					}
				}
			}
		},
		{
			pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
			alias: 'heredoc-string',
			greedy: true,
			inside: {
				'delimiter': {
					pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
					alias: 'symbol',
					inside: {
						'punctuation': /^<<<"?|[";]$/
					}
				},
				'interpolation': string_interpolation
			}
		},
		{
			pattern: /`(?:\\[\s\S]|[^\\`])*`/,
			alias: 'backtick-quoted-string',
			greedy: true
		},
		{
			pattern: /'(?:\\[\s\S]|[^\\'])*'/,
			alias: 'single-quoted-string',
			greedy: true
		},
		{
			pattern: /"(?:\\[\s\S]|[^\\"])*"/,
			alias: 'double-quoted-string',
			greedy: true,
			inside: {
				'interpolation': string_interpolation
			}
		}
	];

	Prism.languages.insertBefore('php', 'variable', {
		'string': string,
		'attribute': {
			pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
			greedy: true,
			inside: {
				'attribute-content': {
					pattern: /^(#\[)[\s\S]+(?=\]$)/,
					lookbehind: true,
					// inside can appear subset of php
					inside: {
						'comment': comment,
						'string': string,
						'attribute-class-name': [
							{
								pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
								alias: 'class-name',
								greedy: true,
								lookbehind: true
							},
							{
								pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
								alias: [
									'class-name',
									'class-name-fully-qualified'
								],
								greedy: true,
								lookbehind: true,
								inside: {
									'punctuation': /\\/
								}
							}
						],
						'constant': constant,
						'number': number,
						'operator': operator,
						'punctuation': punctuation
					}
				},
				'delimiter': {
					pattern: /^#\[|\]$/,
					alias: 'punctuation'
				}
			}
		},
	});

	Prism.hooks.add('before-tokenize', function (env) {
		if (!/<\?/.test(env.code)) {
			return;
		}

		var phpPattern = /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
		Prism.languages['markup-templating'].buildPlaceholders(env, 'php', phpPattern);
	});

	Prism.hooks.add('after-tokenize', function (env) {
		Prism.languages['markup-templating'].tokenizePlaceholders(env, 'php');
	});

}(Prism));


}),
30905: (function () {
(function (Prism) {

	var powershell = Prism.languages.powershell = {
		'comment': [
			{
				pattern: /(^|[^`])<#[\s\S]*?#>/,
				lookbehind: true
			},
			{
				pattern: /(^|[^`])#.*/,
				lookbehind: true
			}
		],
		'string': [
			{
				pattern: /"(?:`[\s\S]|[^`"])*"/,
				greedy: true,
				inside: null // see below
			},
			{
				pattern: /'(?:[^']|'')*'/,
				greedy: true
			}
		],
		// Matches name spaces as well as casts, attribute decorators. Force starting with letter to avoid matching array indices
		// Supports two levels of nested brackets (e.g. `[OutputType([System.Collections.Generic.List[int]])]`)
		'namespace': /\[[a-z](?:\[(?:\[[^\]]*\]|[^\[\]])*\]|[^\[\]])*\]/i,
		'boolean': /\$(?:false|true)\b/i,
		'variable': /\$\w+\b/,
		// Cmdlets and aliases. Aliases should come last, otherwise "write" gets preferred over "write-host" for example
		// Get-Command | ?{ $_.ModuleName -match "Microsoft.PowerShell.(Util|Core|Management)" }
		// Get-Alias | ?{ $_.ReferencedCommand.Module.Name -match "Microsoft.PowerShell.(Util|Core|Management)" }
		'function': [
			/\b(?:Add|Approve|Assert|Backup|Block|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|ForEach|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Sort|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Tee|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Where|Write)-[a-z]+\b/i,
			/\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i
		],
		// per http://technet.microsoft.com/en-us/library/hh847744.aspx
		'keyword': /\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,
		'operator': {
			pattern: /(^|\W)(?:!|-(?:b?(?:and|x?or)|as|(?:Not)?(?:Contains|In|Like|Match)|eq|ge|gt|is(?:Not)?|Join|le|lt|ne|not|Replace|sh[lr])\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,
			lookbehind: true
		},
		'punctuation': /[|{}[\];(),.]/
	};

	// Variable interpolation inside strings, and nested expressions
	powershell.string[0].inside = {
		'function': {
			// Allow for one level of nesting
			pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/,
			lookbehind: true,
			inside: powershell
		},
		'boolean': powershell.boolean,
		'variable': powershell.variable,
	};

}(Prism));


}),
52342: (function () {
Prism.languages.python = {
	'comment': {
		pattern: /(^|[^\\])#.*/,
		lookbehind: true,
		greedy: true
	},
	'string-interpolation': {
		pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
		greedy: true,
		inside: {
			'interpolation': {
				// "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
				pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
				lookbehind: true,
				inside: {
					'format-spec': {
						pattern: /(:)[^:(){}]+(?=\}$)/,
						lookbehind: true
					},
					'conversion-option': {
						pattern: /![sra](?=[:}]$)/,
						alias: 'punctuation'
					},
					rest: null
				}
			},
			'string': /[\s\S]+/
		}
	},
	'triple-quoted-string': {
		pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
		greedy: true,
		alias: 'string'
	},
	'string': {
		pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
		greedy: true
	},
	'function': {
		pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
		lookbehind: true
	},
	'class-name': {
		pattern: /(\bclass\s+)\w+/i,
		lookbehind: true
	},
	'decorator': {
		pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
		lookbehind: true,
		alias: ['annotation', 'punctuation'],
		inside: {
			'punctuation': /\./
		}
	},
	'keyword': /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
	'builtin': /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
	'boolean': /\b(?:False|None|True)\b/,
	'number': /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
	'operator': /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
	'punctuation': /[{}[\];(),.:]/
};

Prism.languages.python['string-interpolation'].inside['interpolation'].inside.rest = Prism.languages.python;

Prism.languages.py = Prism.languages.python;


}),
75166: (function (module, __unused_webpack_exports, __webpack_require__) {
var map = {
  "./prism-php": "43554",
  "./prism-powershell": "30905",
  "./prism-python": "52342"
};


function webpackContext(req) {
  var id = webpackContextResolve(req);
  return __webpack_require__(id);
}
function webpackContextResolve(req) {
  if(!__webpack_require__.o(map, req)) {
    var e = new Error("Cannot find module '" + req + "'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
  }
  return map[req];
}
webpackContext.keys = function webpackContextKeys() {
  return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 75166;


}),
2694: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = __webpack_require__(6925);

function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,

    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };

  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


}),
5556: (function (module, __unused_webpack_exports, __webpack_require__) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (false) { var throwOnDirectAccess, ReactIs } else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(2694)();
}


}),
6925: (function (module) {
"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


}),
31247: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/

var Scheduler = __webpack_require__(69982),
  React = __webpack_require__(96540),
  ReactDOM = __webpack_require__(40961);
function formatProdErrorMessage(code) {
  var url = "https://react.dev/errors/" + code;
  if (1 < arguments.length) {
    url += "?args[]=" + encodeURIComponent(arguments[1]);
    for (var i = 2; i < arguments.length; i++)
      url += "&args[]=" + encodeURIComponent(arguments[i]);
  }
  return (
    "Minified React error #" +
    code +
    "; visit " +
    url +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
function isValidContainer(node) {
  return !(
    !node ||
    (1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType)
  );
}
function getNearestMountedFiber(fiber) {
  var node = fiber,
    nearestMounted = fiber;
  if (fiber.alternate) for (; node.return; ) node = node.return;
  else {
    fiber = node;
    do
      (node = fiber),
        0 !== (node.flags & 4098) && (nearestMounted = node.return),
        (fiber = node.return);
    while (fiber);
  }
  return 3 === node.tag ? nearestMounted : null;
}
function getSuspenseInstanceFromFiber(fiber) {
  if (13 === fiber.tag) {
    var suspenseState = fiber.memoizedState;
    null === suspenseState &&
      ((fiber = fiber.alternate),
      null !== fiber && (suspenseState = fiber.memoizedState));
    if (null !== suspenseState) return suspenseState.dehydrated;
  }
  return null;
}
function getActivityInstanceFromFiber(fiber) {
  if (31 === fiber.tag) {
    var activityState = fiber.memoizedState;
    null === activityState &&
      ((fiber = fiber.alternate),
      null !== fiber && (activityState = fiber.memoizedState));
    if (null !== activityState) return activityState.dehydrated;
  }
  return null;
}
function assertIsMounted(fiber) {
  if (getNearestMountedFiber(fiber) !== fiber)
    throw Error(formatProdErrorMessage(188));
}
function findCurrentFiberUsingSlowPath(fiber) {
  var alternate = fiber.alternate;
  if (!alternate) {
    alternate = getNearestMountedFiber(fiber);
    if (null === alternate) throw Error(formatProdErrorMessage(188));
    return alternate !== fiber ? null : fiber;
  }
  for (var a = fiber, b = alternate; ; ) {
    var parentA = a.return;
    if (null === parentA) break;
    var parentB = parentA.alternate;
    if (null === parentB) {
      b = parentA.return;
      if (null !== b) {
        a = b;
        continue;
      }
      break;
    }
    if (parentA.child === parentB.child) {
      for (parentB = parentA.child; parentB; ) {
        if (parentB === a) return assertIsMounted(parentA), fiber;
        if (parentB === b) return assertIsMounted(parentA), alternate;
        parentB = parentB.sibling;
      }
      throw Error(formatProdErrorMessage(188));
    }
    if (a.return !== b.return) (a = parentA), (b = parentB);
    else {
      for (var didFindChild = !1, child$0 = parentA.child; child$0; ) {
        if (child$0 === a) {
          didFindChild = !0;
          a = parentA;
          b = parentB;
          break;
        }
        if (child$0 === b) {
          didFindChild = !0;
          b = parentA;
          a = parentB;
          break;
        }
        child$0 = child$0.sibling;
      }
      if (!didFindChild) {
        for (child$0 = parentB.child; child$0; ) {
          if (child$0 === a) {
            didFindChild = !0;
            a = parentB;
            b = parentA;
            break;
          }
          if (child$0 === b) {
            didFindChild = !0;
            b = parentB;
            a = parentA;
            break;
          }
          child$0 = child$0.sibling;
        }
        if (!didFindChild) throw Error(formatProdErrorMessage(189));
      }
    }
    if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
  }
  if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
  return a.stateNode.current === a ? fiber : alternate;
}
function findCurrentHostFiberImpl(node) {
  var tag = node.tag;
  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
  for (node = node.child; null !== node; ) {
    tag = findCurrentHostFiberImpl(node);
    if (null !== tag) return tag;
    node = node.sibling;
  }
  return null;
}
var assign = Object.assign,
  REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
  REACT_PORTAL_TYPE = Symbol.for("react.portal"),
  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
  REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
  REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
  REACT_MEMO_TYPE = Symbol.for("react.memo"),
  REACT_LAZY_TYPE = Symbol.for("react.lazy");
Symbol.for("react.scope");
var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
Symbol.for("react.legacy_hidden");
Symbol.for("react.tracing_marker");
var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
Symbol.for("react.view_transition");
var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
function getIteratorFn(maybeIterable) {
  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
  maybeIterable =
    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
    maybeIterable["@@iterator"];
  return "function" === typeof maybeIterable ? maybeIterable : null;
}
var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
function getComponentNameFromType(type) {
  if (null == type) return null;
  if ("function" === typeof type)
    return type.$$typeof === REACT_CLIENT_REFERENCE
      ? null
      : type.displayName || type.name || null;
  if ("string" === typeof type) return type;
  switch (type) {
    case REACT_FRAGMENT_TYPE:
      return "Fragment";
    case REACT_PROFILER_TYPE:
      return "Profiler";
    case REACT_STRICT_MODE_TYPE:
      return "StrictMode";
    case REACT_SUSPENSE_TYPE:
      return "Suspense";
    case REACT_SUSPENSE_LIST_TYPE:
      return "SuspenseList";
    case REACT_ACTIVITY_TYPE:
      return "Activity";
  }
  if ("object" === typeof type)
    switch (type.$$typeof) {
      case REACT_PORTAL_TYPE:
        return "Portal";
      case REACT_CONTEXT_TYPE:
        return type.displayName || "Context";
      case REACT_CONSUMER_TYPE:
        return (type._context.displayName || "Context") + ".Consumer";
      case REACT_FORWARD_REF_TYPE:
        var innerType = type.render;
        type = type.displayName;
        type ||
          ((type = innerType.displayName || innerType.name || ""),
          (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
        return type;
      case REACT_MEMO_TYPE:
        return (
          (innerType = type.displayName || null),
          null !== innerType
            ? innerType
            : getComponentNameFromType(type.type) || "Memo"
        );
      case REACT_LAZY_TYPE:
        innerType = type._payload;
        type = type._init;
        try {
          return getComponentNameFromType(type(innerType));
        } catch (x) {}
    }
  return null;
}
var isArrayImpl = Array.isArray,
  ReactSharedInternals =
    React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
  ReactDOMSharedInternals =
    ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
  sharedNotPendingObject = {
    pending: !1,
    data: null,
    method: null,
    action: null
  },
  valueStack = [],
  index = -1;
function createCursor(defaultValue) {
  return { current: defaultValue };
}
function pop(cursor) {
  0 > index ||
    ((cursor.current = valueStack[index]), (valueStack[index] = null), index--);
}
function push(cursor, value) {
  index++;
  valueStack[index] = cursor.current;
  cursor.current = value;
}
var contextStackCursor = createCursor(null),
  contextFiberStackCursor = createCursor(null),
  rootInstanceStackCursor = createCursor(null),
  hostTransitionProviderCursor = createCursor(null);
function pushHostContainer(fiber, nextRootInstance) {
  push(rootInstanceStackCursor, nextRootInstance);
  push(contextFiberStackCursor, fiber);
  push(contextStackCursor, null);
  switch (nextRootInstance.nodeType) {
    case 9:
    case 11:
      fiber = (fiber = nextRootInstance.documentElement)
        ? (fiber = fiber.namespaceURI)
          ? getOwnHostContext(fiber)
          : 0
        : 0;
      break;
    default:
      if (
        ((fiber = nextRootInstance.tagName),
        (nextRootInstance = nextRootInstance.namespaceURI))
      )
        (nextRootInstance = getOwnHostContext(nextRootInstance)),
          (fiber = getChildHostContextProd(nextRootInstance, fiber));
      else
        switch (fiber) {
          case "svg":
            fiber = 1;
            break;
          case "math":
            fiber = 2;
            break;
          default:
            fiber = 0;
        }
  }
  pop(contextStackCursor);
  push(contextStackCursor, fiber);
}
function popHostContainer() {
  pop(contextStackCursor);
  pop(contextFiberStackCursor);
  pop(rootInstanceStackCursor);
}
function pushHostContext(fiber) {
  null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
  var context = contextStackCursor.current;
  var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
  context !== JSCompiler_inline_result &&
    (push(contextFiberStackCursor, fiber),
    push(contextStackCursor, JSCompiler_inline_result));
}
function popHostContext(fiber) {
  contextFiberStackCursor.current === fiber &&
    (pop(contextStackCursor), pop(contextFiberStackCursor));
  hostTransitionProviderCursor.current === fiber &&
    (pop(hostTransitionProviderCursor),
    (HostTransitionContext._currentValue = sharedNotPendingObject));
}
var prefix, suffix;
function describeBuiltInComponentFrame(name) {
  if (void 0 === prefix)
    try {
      throw Error();
    } catch (x) {
      var match = x.stack.trim().match(/\n( *(at )?)/);
      prefix = (match && match[1]) || "";
      suffix =
        -1 < x.stack.indexOf("\n    at")
          ? " (<anonymous>)"
          : -1 < x.stack.indexOf("@")
            ? "@unknown:0:0"
            : "";
    }
  return "\n" + prefix + name + suffix;
}
var reentry = !1;
function describeNativeComponentFrame(fn, construct) {
  if (!fn || reentry) return "";
  reentry = !0;
  var previousPrepareStackTrace = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    var RunInRootFrame = {
      DetermineComponentFrameRoot: function () {
        try {
          if (construct) {
            var Fake = function () {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function () {
                throw Error();
              }
            });
            if ("object" === typeof Reflect && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                var control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x$1) {
                control = x$1;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x$2) {
              control = x$2;
            }
            (Fake = fn()) &&
              "function" === typeof Fake.catch &&
              Fake.catch(function () {});
          }
        } catch (sample) {
          if (sample && control && "string" === typeof sample.stack)
            return [sample.stack, control.stack];
        }
        return [null, null];
      }
    };
    RunInRootFrame.DetermineComponentFrameRoot.displayName =
      "DetermineComponentFrameRoot";
    var namePropDescriptor = Object.getOwnPropertyDescriptor(
      RunInRootFrame.DetermineComponentFrameRoot,
      "name"
    );
    namePropDescriptor &&
      namePropDescriptor.configurable &&
      Object.defineProperty(
        RunInRootFrame.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),
      sampleStack = _RunInRootFrame$Deter[0],
      controlStack = _RunInRootFrame$Deter[1];
    if (sampleStack && controlStack) {
      var sampleLines = sampleStack.split("\n"),
        controlLines = controlStack.split("\n");
      for (
        namePropDescriptor = RunInRootFrame = 0;
        RunInRootFrame < sampleLines.length &&
        !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot");

      )
        RunInRootFrame++;
      for (
        ;
        namePropDescriptor < controlLines.length &&
        !controlLines[namePropDescriptor].includes(
          "DetermineComponentFrameRoot"
        );

      )
        namePropDescriptor++;
      if (
        RunInRootFrame === sampleLines.length ||
        namePropDescriptor === controlLines.length
      )
        for (
          RunInRootFrame = sampleLines.length - 1,
            namePropDescriptor = controlLines.length - 1;
          1 <= RunInRootFrame &&
          0 <= namePropDescriptor &&
          sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];

        )
          namePropDescriptor--;
      for (
        ;
        1 <= RunInRootFrame && 0 <= namePropDescriptor;
        RunInRootFrame--, namePropDescriptor--
      )
        if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
          if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
            do
              if (
                (RunInRootFrame--,
                namePropDescriptor--,
                0 > namePropDescriptor ||
                  sampleLines[RunInRootFrame] !==
                    controlLines[namePropDescriptor])
              ) {
                var frame =
                  "\n" +
                  sampleLines[RunInRootFrame].replace(" at new ", " at ");
                fn.displayName &&
                  frame.includes("<anonymous>") &&
                  (frame = frame.replace("<anonymous>", fn.displayName));
                return frame;
              }
            while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
          }
          break;
        }
    }
  } finally {
    (reentry = !1), (Error.prepareStackTrace = previousPrepareStackTrace);
  }
  return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "")
    ? describeBuiltInComponentFrame(previousPrepareStackTrace)
    : "";
}
function describeFiber(fiber, childFiber) {
  switch (fiber.tag) {
    case 26:
    case 27:
    case 5:
      return describeBuiltInComponentFrame(fiber.type);
    case 16:
      return describeBuiltInComponentFrame("Lazy");
    case 13:
      return fiber.child !== childFiber && null !== childFiber
        ? describeBuiltInComponentFrame("Suspense Fallback")
        : describeBuiltInComponentFrame("Suspense");
    case 19:
      return describeBuiltInComponentFrame("SuspenseList");
    case 0:
    case 15:
      return describeNativeComponentFrame(fiber.type, !1);
    case 11:
      return describeNativeComponentFrame(fiber.type.render, !1);
    case 1:
      return describeNativeComponentFrame(fiber.type, !0);
    case 31:
      return describeBuiltInComponentFrame("Activity");
    default:
      return "";
  }
}
function getStackByFiberInDevAndProd(workInProgress) {
  try {
    var info = "",
      previous = null;
    do
      (info += describeFiber(workInProgress, previous)),
        (previous = workInProgress),
        (workInProgress = workInProgress.return);
    while (workInProgress);
    return info;
  } catch (x) {
    return "\nError generating stack: " + x.message + "\n" + x.stack;
  }
}
var hasOwnProperty = Object.prototype.hasOwnProperty,
  scheduleCallback$3 = Scheduler.unstable_scheduleCallback,
  cancelCallback$1 = Scheduler.unstable_cancelCallback,
  shouldYield = Scheduler.unstable_shouldYield,
  requestPaint = Scheduler.unstable_requestPaint,
  now = Scheduler.unstable_now,
  getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
  ImmediatePriority = Scheduler.unstable_ImmediatePriority,
  UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
  NormalPriority$1 = Scheduler.unstable_NormalPriority,
  LowPriority = Scheduler.unstable_LowPriority,
  IdlePriority = Scheduler.unstable_IdlePriority,
  log$1 = Scheduler.log,
  unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,
  rendererID = null,
  injectedHook = null;
function setIsStrictModeForDevtools(newIsStrictMode) {
  "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
  if (injectedHook && "function" === typeof injectedHook.setStrictMode)
    try {
      injectedHook.setStrictMode(rendererID, newIsStrictMode);
    } catch (err) {}
}
var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
  log = Math.log,
  LN2 = Math.LN2;
function clz32Fallback(x) {
  x >>>= 0;
  return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;
}
var nextTransitionUpdateLane = 256,
  nextTransitionDeferredLane = 262144,
  nextRetryLane = 4194304;
function getHighestPriorityLanes(lanes) {
  var pendingSyncLanes = lanes & 42;
  if (0 !== pendingSyncLanes) return pendingSyncLanes;
  switch (lanes & -lanes) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
      return 64;
    case 128:
      return 128;
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
      return lanes & 261888;
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return lanes & 3932160;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
      return lanes & 62914560;
    case 67108864:
      return 67108864;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 0;
    default:
      return lanes;
  }
}
function getNextLanes(root, wipLanes, rootHasPendingCommit) {
  var pendingLanes = root.pendingLanes;
  if (0 === pendingLanes) return 0;
  var nextLanes = 0,
    suspendedLanes = root.suspendedLanes,
    pingedLanes = root.pingedLanes;
  root = root.warmLanes;
  var nonIdlePendingLanes = pendingLanes & 134217727;
  0 !== nonIdlePendingLanes
    ? ((pendingLanes = nonIdlePendingLanes & ~suspendedLanes),
      0 !== pendingLanes
        ? (nextLanes = getHighestPriorityLanes(pendingLanes))
        : ((pingedLanes &= nonIdlePendingLanes),
          0 !== pingedLanes
            ? (nextLanes = getHighestPriorityLanes(pingedLanes))
            : rootHasPendingCommit ||
              ((rootHasPendingCommit = nonIdlePendingLanes & ~root),
              0 !== rootHasPendingCommit &&
                (nextLanes = getHighestPriorityLanes(rootHasPendingCommit)))))
    : ((nonIdlePendingLanes = pendingLanes & ~suspendedLanes),
      0 !== nonIdlePendingLanes
        ? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))
        : 0 !== pingedLanes
          ? (nextLanes = getHighestPriorityLanes(pingedLanes))
          : rootHasPendingCommit ||
            ((rootHasPendingCommit = pendingLanes & ~root),
            0 !== rootHasPendingCommit &&
              (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
  return 0 === nextLanes
    ? 0
    : 0 !== wipLanes &&
        wipLanes !== nextLanes &&
        0 === (wipLanes & suspendedLanes) &&
        ((suspendedLanes = nextLanes & -nextLanes),
        (rootHasPendingCommit = wipLanes & -wipLanes),
        suspendedLanes >= rootHasPendingCommit ||
          (32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)))
      ? wipLanes
      : nextLanes;
}
function checkIfRootIsPrerendering(root, renderLanes) {
  return (
    0 ===
    (root.pendingLanes &
      ~(root.suspendedLanes & ~root.pingedLanes) &
      renderLanes)
  );
}
function computeExpirationTime(lane, currentTime) {
  switch (lane) {
    case 1:
    case 2:
    case 4:
    case 8:
    case 64:
      return currentTime + 250;
    case 16:
    case 32:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return currentTime + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
      return -1;
    case 67108864:
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function claimNextRetryLane() {
  var lane = nextRetryLane;
  nextRetryLane <<= 1;
  0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
  return lane;
}
function createLaneMap(initial) {
  for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
  return laneMap;
}
function markRootUpdated$1(root, updateLane) {
  root.pendingLanes |= updateLane;
  268435456 !== updateLane &&
    ((root.suspendedLanes = 0), (root.pingedLanes = 0), (root.warmLanes = 0));
}
function markRootFinished(
  root,
  finishedLanes,
  remainingLanes,
  spawnedLane,
  updatedLanes,
  suspendedRetryLanes
) {
  var previouslyPendingLanes = root.pendingLanes;
  root.pendingLanes = remainingLanes;
  root.suspendedLanes = 0;
  root.pingedLanes = 0;
  root.warmLanes = 0;
  root.expiredLanes &= remainingLanes;
  root.entangledLanes &= remainingLanes;
  root.errorRecoveryDisabledLanes &= remainingLanes;
  root.shellSuspendCounter = 0;
  var entanglements = root.entanglements,
    expirationTimes = root.expirationTimes,
    hiddenUpdates = root.hiddenUpdates;
  for (
    remainingLanes = previouslyPendingLanes & ~remainingLanes;
    0 < remainingLanes;

  ) {
    var index$7 = 31 - clz32(remainingLanes),
      lane = 1 << index$7;
    entanglements[index$7] = 0;
    expirationTimes[index$7] = -1;
    var hiddenUpdatesForLane = hiddenUpdates[index$7];
    if (null !== hiddenUpdatesForLane)
      for (
        hiddenUpdates[index$7] = null, index$7 = 0;
        index$7 < hiddenUpdatesForLane.length;
        index$7++
      ) {
        var update = hiddenUpdatesForLane[index$7];
        null !== update && (update.lane &= -536870913);
      }
    remainingLanes &= ~lane;
  }
  0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
  0 !== suspendedRetryLanes &&
    0 === updatedLanes &&
    0 !== root.tag &&
    (root.suspendedLanes |=
      suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
}
function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
  root.pendingLanes |= spawnedLane;
  root.suspendedLanes &= ~spawnedLane;
  var spawnedLaneIndex = 31 - clz32(spawnedLane);
  root.entangledLanes |= spawnedLane;
  root.entanglements[spawnedLaneIndex] =
    root.entanglements[spawnedLaneIndex] |
    1073741824 |
    (entangledLanes & 261930);
}
function markRootEntangled(root, entangledLanes) {
  var rootEntangledLanes = (root.entangledLanes |= entangledLanes);
  for (root = root.entanglements; rootEntangledLanes; ) {
    var index$8 = 31 - clz32(rootEntangledLanes),
      lane = 1 << index$8;
    (lane & entangledLanes) | (root[index$8] & entangledLanes) &&
      (root[index$8] |= entangledLanes);
    rootEntangledLanes &= ~lane;
  }
}
function getBumpedLaneForHydration(root, renderLanes) {
  var renderLane = renderLanes & -renderLanes;
  renderLane =
    0 !== (renderLane & 42) ? 1 : getBumpedLaneForHydrationByLane(renderLane);
  return 0 !== (renderLane & (root.suspendedLanes | renderLanes))
    ? 0
    : renderLane;
}
function getBumpedLaneForHydrationByLane(lane) {
  switch (lane) {
    case 2:
      lane = 1;
      break;
    case 8:
      lane = 4;
      break;
    case 32:
      lane = 16;
      break;
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
      lane = 128;
      break;
    case 268435456:
      lane = 134217728;
      break;
    default:
      lane = 0;
  }
  return lane;
}
function lanesToEventPriority(lanes) {
  lanes &= -lanes;
  return 2 < lanes
    ? 8 < lanes
      ? 0 !== (lanes & 134217727)
        ? 32
        : 268435456
      : 8
    : 2;
}
function resolveUpdatePriority() {
  var updatePriority = ReactDOMSharedInternals.p;
  if (0 !== updatePriority) return updatePriority;
  updatePriority = window.event;
  return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
}
function runWithPriority(priority, fn) {
  var previousPriority = ReactDOMSharedInternals.p;
  try {
    return (ReactDOMSharedInternals.p = priority), fn();
  } finally {
    ReactDOMSharedInternals.p = previousPriority;
  }
}
var randomKey = Math.random().toString(36).slice(2),
  internalInstanceKey = "__reactFiber$" + randomKey,
  internalPropsKey = "__reactProps$" + randomKey,
  internalContainerInstanceKey = "__reactContainer$" + randomKey,
  internalEventHandlersKey = "__reactEvents$" + randomKey,
  internalEventHandlerListenersKey = "__reactListeners$" + randomKey,
  internalEventHandlesSetKey = "__reactHandles$" + randomKey,
  internalRootNodeResourcesKey = "__reactResources$" + randomKey,
  internalHoistableMarker = "__reactMarker$" + randomKey;
function detachDeletedInstance(node) {
  delete node[internalInstanceKey];
  delete node[internalPropsKey];
  delete node[internalEventHandlersKey];
  delete node[internalEventHandlerListenersKey];
  delete node[internalEventHandlesSetKey];
}
function getClosestInstanceFromNode(targetNode) {
  var targetInst = targetNode[internalInstanceKey];
  if (targetInst) return targetInst;
  for (var parentNode = targetNode.parentNode; parentNode; ) {
    if (
      (targetInst =
        parentNode[internalContainerInstanceKey] ||
        parentNode[internalInstanceKey])
    ) {
      parentNode = targetInst.alternate;
      if (
        null !== targetInst.child ||
        (null !== parentNode && null !== parentNode.child)
      )
        for (
          targetNode = getParentHydrationBoundary(targetNode);
          null !== targetNode;

        ) {
          if ((parentNode = targetNode[internalInstanceKey])) return parentNode;
          targetNode = getParentHydrationBoundary(targetNode);
        }
      return targetInst;
    }
    targetNode = parentNode;
    parentNode = targetNode.parentNode;
  }
  return null;
}
function getInstanceFromNode(node) {
  if (
    (node = node[internalInstanceKey] || node[internalContainerInstanceKey])
  ) {
    var tag = node.tag;
    if (
      5 === tag ||
      6 === tag ||
      13 === tag ||
      31 === tag ||
      26 === tag ||
      27 === tag ||
      3 === tag
    )
      return node;
  }
  return null;
}
function getNodeFromInstance(inst) {
  var tag = inst.tag;
  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
  throw Error(formatProdErrorMessage(33));
}
function getResourcesFromRoot(root) {
  var resources = root[internalRootNodeResourcesKey];
  resources ||
    (resources = root[internalRootNodeResourcesKey] =
      { hoistableStyles: new Map(), hoistableScripts: new Map() });
  return resources;
}
function markNodeAsHoistable(node) {
  node[internalHoistableMarker] = !0;
}
var allNativeEvents = new Set(),
  registrationNameDependencies = {};
function registerTwoPhaseEvent(registrationName, dependencies) {
  registerDirectEvent(registrationName, dependencies);
  registerDirectEvent(registrationName + "Capture", dependencies);
}
function registerDirectEvent(registrationName, dependencies) {
  registrationNameDependencies[registrationName] = dependencies;
  for (
    registrationName = 0;
    registrationName < dependencies.length;
    registrationName++
  )
    allNativeEvents.add(dependencies[registrationName]);
}
var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ),
  illegalAttributeNameCache = {},
  validatedAttributeNameCache = {};
function isAttributeNameSafe(attributeName) {
  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
    return !0;
  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return !1;
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
    return (validatedAttributeNameCache[attributeName] = !0);
  illegalAttributeNameCache[attributeName] = !0;
  return !1;
}
function setValueForAttribute(node, name, value) {
  if (isAttributeNameSafe(name))
    if (null === value) node.removeAttribute(name);
    else {
      switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
          node.removeAttribute(name);
          return;
        case "boolean":
          var prefix$10 = name.toLowerCase().slice(0, 5);
          if ("data-" !== prefix$10 && "aria-" !== prefix$10) {
            node.removeAttribute(name);
            return;
          }
      }
      node.setAttribute(name, "" + value);
    }
}
function setValueForKnownAttribute(node, name, value) {
  if (null === value) node.removeAttribute(name);
  else {
    switch (typeof value) {
      case "undefined":
      case "function":
      case "symbol":
      case "boolean":
        node.removeAttribute(name);
        return;
    }
    node.setAttribute(name, "" + value);
  }
}
function setValueForNamespacedAttribute(node, namespace, name, value) {
  if (null === value) node.removeAttribute(name);
  else {
    switch (typeof value) {
      case "undefined":
      case "function":
      case "symbol":
      case "boolean":
        node.removeAttribute(name);
        return;
    }
    node.setAttributeNS(namespace, name, "" + value);
  }
}
function getToStringValue(value) {
  switch (typeof value) {
    case "bigint":
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return value;
    case "object":
      return value;
    default:
      return "";
  }
}
function isCheckable(elem) {
  var type = elem.type;
  return (
    (elem = elem.nodeName) &&
    "input" === elem.toLowerCase() &&
    ("checkbox" === type || "radio" === type)
  );
}
function trackValueOnNode(node, valueField, currentValue) {
  var descriptor = Object.getOwnPropertyDescriptor(
    node.constructor.prototype,
    valueField
  );
  if (
    !node.hasOwnProperty(valueField) &&
    "undefined" !== typeof descriptor &&
    "function" === typeof descriptor.get &&
    "function" === typeof descriptor.set
  ) {
    var get = descriptor.get,
      set = descriptor.set;
    Object.defineProperty(node, valueField, {
      configurable: !0,
      get: function () {
        return get.call(this);
      },
      set: function (value) {
        currentValue = "" + value;
        set.call(this, value);
      }
    });
    Object.defineProperty(node, valueField, {
      enumerable: descriptor.enumerable
    });
    return {
      getValue: function () {
        return currentValue;
      },
      setValue: function (value) {
        currentValue = "" + value;
      },
      stopTracking: function () {
        node._valueTracker = null;
        delete node[valueField];
      }
    };
  }
}
function track(node) {
  if (!node._valueTracker) {
    var valueField = isCheckable(node) ? "checked" : "value";
    node._valueTracker = trackValueOnNode(
      node,
      valueField,
      "" + node[valueField]
    );
  }
}
function updateValueIfChanged(node) {
  if (!node) return !1;
  var tracker = node._valueTracker;
  if (!tracker) return !0;
  var lastValue = tracker.getValue();
  var value = "";
  node &&
    (value = isCheckable(node)
      ? node.checked
        ? "true"
        : "false"
      : node.value);
  node = value;
  return node !== lastValue ? (tracker.setValue(node), !0) : !1;
}
function getActiveElement(doc) {
  doc = doc || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof doc) return null;
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}
var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
  return value.replace(
    escapeSelectorAttributeValueInsideDoubleQuotesRegex,
    function (ch) {
      return "\\" + ch.charCodeAt(0).toString(16) + " ";
    }
  );
}
function updateInput(
  element,
  value,
  defaultValue,
  lastDefaultValue,
  checked,
  defaultChecked,
  type,
  name
) {
  element.name = "";
  null != type &&
  "function" !== typeof type &&
  "symbol" !== typeof type &&
  "boolean" !== typeof type
    ? (element.type = type)
    : element.removeAttribute("type");
  if (null != value)
    if ("number" === type) {
      if ((0 === value && "" === element.value) || element.value != value)
        element.value = "" + getToStringValue(value);
    } else
      element.value !== "" + getToStringValue(value) &&
        (element.value = "" + getToStringValue(value));
  else
    ("submit" !== type && "reset" !== type) || element.removeAttribute("value");
  null != value
    ? setDefaultValue(element, type, getToStringValue(value))
    : null != defaultValue
      ? setDefaultValue(element, type, getToStringValue(defaultValue))
      : null != lastDefaultValue && element.removeAttribute("value");
  null == checked &&
    null != defaultChecked &&
    (element.defaultChecked = !!defaultChecked);
  null != checked &&
    (element.checked =
      checked && "function" !== typeof checked && "symbol" !== typeof checked);
  null != name &&
  "function" !== typeof name &&
  "symbol" !== typeof name &&
  "boolean" !== typeof name
    ? (element.name = "" + getToStringValue(name))
    : element.removeAttribute("name");
}
function initInput(
  element,
  value,
  defaultValue,
  checked,
  defaultChecked,
  type,
  name,
  isHydrating
) {
  null != type &&
    "function" !== typeof type &&
    "symbol" !== typeof type &&
    "boolean" !== typeof type &&
    (element.type = type);
  if (null != value || null != defaultValue) {
    if (
      !(
        ("submit" !== type && "reset" !== type) ||
        (void 0 !== value && null !== value)
      )
    ) {
      track(element);
      return;
    }
    defaultValue =
      null != defaultValue ? "" + getToStringValue(defaultValue) : "";
    value = null != value ? "" + getToStringValue(value) : defaultValue;
    isHydrating || value === element.value || (element.value = value);
    element.defaultValue = value;
  }
  checked = null != checked ? checked : defaultChecked;
  checked =
    "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
  element.checked = isHydrating ? element.checked : !!checked;
  element.defaultChecked = !!checked;
  null != name &&
    "function" !== typeof name &&
    "symbol" !== typeof name &&
    "boolean" !== typeof name &&
    (element.name = name);
  track(element);
}
function setDefaultValue(node, type, value) {
  ("number" === type && getActiveElement(node.ownerDocument) === node) ||
    node.defaultValue === "" + value ||
    (node.defaultValue = "" + value);
}
function updateOptions(node, multiple, propValue, setDefaultSelected) {
  node = node.options;
  if (multiple) {
    multiple = {};
    for (var i = 0; i < propValue.length; i++)
      multiple["$" + propValue[i]] = !0;
    for (propValue = 0; propValue < node.length; propValue++)
      (i = multiple.hasOwnProperty("$" + node[propValue].value)),
        node[propValue].selected !== i && (node[propValue].selected = i),
        i && setDefaultSelected && (node[propValue].defaultSelected = !0);
  } else {
    propValue = "" + getToStringValue(propValue);
    multiple = null;
    for (i = 0; i < node.length; i++) {
      if (node[i].value === propValue) {
        node[i].selected = !0;
        setDefaultSelected && (node[i].defaultSelected = !0);
        return;
      }
      null !== multiple || node[i].disabled || (multiple = node[i]);
    }
    null !== multiple && (multiple.selected = !0);
  }
}
function updateTextarea(element, value, defaultValue) {
  if (
    null != value &&
    ((value = "" + getToStringValue(value)),
    value !== element.value && (element.value = value),
    null == defaultValue)
  ) {
    element.defaultValue !== value && (element.defaultValue = value);
    return;
  }
  element.defaultValue =
    null != defaultValue ? "" + getToStringValue(defaultValue) : "";
}
function initTextarea(element, value, defaultValue, children) {
  if (null == value) {
    if (null != children) {
      if (null != defaultValue) throw Error(formatProdErrorMessage(92));
      if (isArrayImpl(children)) {
        if (1 < children.length) throw Error(formatProdErrorMessage(93));
        children = children[0];
      }
      defaultValue = children;
    }
    null == defaultValue && (defaultValue = "");
    value = defaultValue;
  }
  defaultValue = getToStringValue(value);
  element.defaultValue = defaultValue;
  children = element.textContent;
  children === defaultValue &&
    "" !== children &&
    null !== children &&
    (element.value = children);
  track(element);
}
function setTextContent(node, text) {
  if (text) {
    var firstChild = node.firstChild;
    if (
      firstChild &&
      firstChild === node.lastChild &&
      3 === firstChild.nodeType
    ) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
}
var unitlessNumbers = new Set(
  "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
    " "
  )
);
function setValueForStyle(style, styleName, value) {
  var isCustomProperty = 0 === styleName.indexOf("--");
  null == value || "boolean" === typeof value || "" === value
    ? isCustomProperty
      ? style.setProperty(styleName, "")
      : "float" === styleName
        ? (style.cssFloat = "")
        : (style[styleName] = "")
    : isCustomProperty
      ? style.setProperty(styleName, value)
      : "number" !== typeof value ||
          0 === value ||
          unitlessNumbers.has(styleName)
        ? "float" === styleName
          ? (style.cssFloat = value)
          : (style[styleName] = ("" + value).trim())
        : (style[styleName] = value + "px");
}
function setValueForStyles(node, styles, prevStyles) {
  if (null != styles && "object" !== typeof styles)
    throw Error(formatProdErrorMessage(62));
  node = node.style;
  if (null != prevStyles) {
    for (var styleName in prevStyles)
      !prevStyles.hasOwnProperty(styleName) ||
        (null != styles && styles.hasOwnProperty(styleName)) ||
        (0 === styleName.indexOf("--")
          ? node.setProperty(styleName, "")
          : "float" === styleName
            ? (node.cssFloat = "")
            : (node[styleName] = ""));
    for (var styleName$16 in styles)
      (styleName = styles[styleName$16]),
        styles.hasOwnProperty(styleName$16) &&
          prevStyles[styleName$16] !== styleName &&
          setValueForStyle(node, styleName$16, styleName);
  } else
    for (var styleName$17 in styles)
      styles.hasOwnProperty(styleName$17) &&
        setValueForStyle(node, styleName$17, styles[styleName$17]);
}
function isCustomElement(tagName) {
  if (-1 === tagName.indexOf("-")) return !1;
  switch (tagName) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var aliases = new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]),
  isJavaScriptProtocol =
    /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
function sanitizeURL(url) {
  return isJavaScriptProtocol.test("" + url)
    ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')"
    : url;
}
function noop$1() {}
var currentReplayingEvent = null;
function getEventTarget(nativeEvent) {
  nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
  nativeEvent.correspondingUseElement &&
    (nativeEvent = nativeEvent.correspondingUseElement);
  return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
}
var restoreTarget = null,
  restoreQueue = null;
function restoreStateOfTarget(target) {
  var internalInstance = getInstanceFromNode(target);
  if (internalInstance && (target = internalInstance.stateNode)) {
    var props = target[internalPropsKey] || null;
    a: switch (((target = internalInstance.stateNode), internalInstance.type)) {
      case "input":
        updateInput(
          target,
          props.value,
          props.defaultValue,
          props.defaultValue,
          props.checked,
          props.defaultChecked,
          props.type,
          props.name
        );
        internalInstance = props.name;
        if ("radio" === props.type && null != internalInstance) {
          for (props = target; props.parentNode; ) props = props.parentNode;
          props = props.querySelectorAll(
            'input[name="' +
              escapeSelectorAttributeValueInsideDoubleQuotes(
                "" + internalInstance
              ) +
              '"][type="radio"]'
          );
          for (
            internalInstance = 0;
            internalInstance < props.length;
            internalInstance++
          ) {
            var otherNode = props[internalInstance];
            if (otherNode !== target && otherNode.form === target.form) {
              var otherProps = otherNode[internalPropsKey] || null;
              if (!otherProps) throw Error(formatProdErrorMessage(90));
              updateInput(
                otherNode,
                otherProps.value,
                otherProps.defaultValue,
                otherProps.defaultValue,
                otherProps.checked,
                otherProps.defaultChecked,
                otherProps.type,
                otherProps.name
              );
            }
          }
          for (
            internalInstance = 0;
            internalInstance < props.length;
            internalInstance++
          )
            (otherNode = props[internalInstance]),
              otherNode.form === target.form && updateValueIfChanged(otherNode);
        }
        break a;
      case "textarea":
        updateTextarea(target, props.value, props.defaultValue);
        break a;
      case "select":
        (internalInstance = props.value),
          null != internalInstance &&
            updateOptions(target, !!props.multiple, internalInstance, !1);
    }
  }
}
var isInsideEventHandler = !1;
function batchedUpdates$1(fn, a, b) {
  if (isInsideEventHandler) return fn(a, b);
  isInsideEventHandler = !0;
  try {
    var JSCompiler_inline_result = fn(a);
    return JSCompiler_inline_result;
  } finally {
    if (
      ((isInsideEventHandler = !1),
      null !== restoreTarget || null !== restoreQueue)
    )
      if (
        (flushSyncWork$1(),
        restoreTarget &&
          ((a = restoreTarget),
          (fn = restoreQueue),
          (restoreQueue = restoreTarget = null),
          restoreStateOfTarget(a),
          fn))
      )
        for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
  }
}
function getListener(inst, registrationName) {
  var stateNode = inst.stateNode;
  if (null === stateNode) return null;
  var props = stateNode[internalPropsKey] || null;
  if (null === props) return null;
  stateNode = props[registrationName];
  a: switch (registrationName) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (props = !props.disabled) ||
        ((inst = inst.type),
        (props = !(
          "button" === inst ||
          "input" === inst ||
          "select" === inst ||
          "textarea" === inst
        )));
      inst = !props;
      break a;
    default:
      inst = !1;
  }
  if (inst) return null;
  if (stateNode && "function" !== typeof stateNode)
    throw Error(
      formatProdErrorMessage(231, registrationName, typeof stateNode)
    );
  return stateNode;
}
var canUseDOM = !(
    "undefined" === typeof window ||
    "undefined" === typeof window.document ||
    "undefined" === typeof window.document.createElement
  ),
  passiveBrowserEventsSupported = !1;
if (canUseDOM)
  try {
    var options = {};
    Object.defineProperty(options, "passive", {
      get: function () {
        passiveBrowserEventsSupported = !0;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (e) {
    passiveBrowserEventsSupported = !1;
  }
var root = null,
  startText = null,
  fallbackText = null;
function getData() {
  if (fallbackText) return fallbackText;
  var start,
    startValue = startText,
    startLength = startValue.length,
    end,
    endValue = "value" in root ? root.value : root.textContent,
    endLength = endValue.length;
  for (
    start = 0;
    start < startLength && startValue[start] === endValue[start];
    start++
  );
  var minEnd = startLength - start;
  for (
    end = 1;
    end <= minEnd &&
    startValue[startLength - end] === endValue[endLength - end];
    end++
  );
  return (fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0));
}
function getEventCharCode(nativeEvent) {
  var keyCode = nativeEvent.keyCode;
  "charCode" in nativeEvent
    ? ((nativeEvent = nativeEvent.charCode),
      0 === nativeEvent && 13 === keyCode && (nativeEvent = 13))
    : (nativeEvent = keyCode);
  10 === nativeEvent && (nativeEvent = 13);
  return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
}
function functionThatReturnsTrue() {
  return !0;
}
function functionThatReturnsFalse() {
  return !1;
}
function createSyntheticEvent(Interface) {
  function SyntheticBaseEvent(
    reactName,
    reactEventType,
    targetInst,
    nativeEvent,
    nativeEventTarget
  ) {
    this._reactName = reactName;
    this._targetInst = targetInst;
    this.type = reactEventType;
    this.nativeEvent = nativeEvent;
    this.target = nativeEventTarget;
    this.currentTarget = null;
    for (var propName in Interface)
      Interface.hasOwnProperty(propName) &&
        ((reactName = Interface[propName]),
        (this[propName] = reactName
          ? reactName(nativeEvent)
          : nativeEvent[propName]));
    this.isDefaultPrevented = (
      null != nativeEvent.defaultPrevented
        ? nativeEvent.defaultPrevented
        : !1 === nativeEvent.returnValue
    )
      ? functionThatReturnsTrue
      : functionThatReturnsFalse;
    this.isPropagationStopped = functionThatReturnsFalse;
    return this;
  }
  assign(SyntheticBaseEvent.prototype, {
    preventDefault: function () {
      this.defaultPrevented = !0;
      var event = this.nativeEvent;
      event &&
        (event.preventDefault
          ? event.preventDefault()
          : "unknown" !== typeof event.returnValue && (event.returnValue = !1),
        (this.isDefaultPrevented = functionThatReturnsTrue));
    },
    stopPropagation: function () {
      var event = this.nativeEvent;
      event &&
        (event.stopPropagation
          ? event.stopPropagation()
          : "unknown" !== typeof event.cancelBubble &&
            (event.cancelBubble = !0),
        (this.isPropagationStopped = functionThatReturnsTrue));
    },
    persist: function () {},
    isPersistent: functionThatReturnsTrue
  });
  return SyntheticBaseEvent;
}
var EventInterface = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  },
  SyntheticEvent = createSyntheticEvent(EventInterface),
  UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }),
  SyntheticUIEvent = createSyntheticEvent(UIEventInterface),
  lastMovementX,
  lastMovementY,
  lastMouseEvent,
  MouseEventInterface = assign({}, UIEventInterface, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: getEventModifierState,
    button: 0,
    buttons: 0,
    relatedTarget: function (event) {
      return void 0 === event.relatedTarget
        ? event.fromElement === event.srcElement
          ? event.toElement
          : event.fromElement
        : event.relatedTarget;
    },
    movementX: function (event) {
      if ("movementX" in event) return event.movementX;
      event !== lastMouseEvent &&
        (lastMouseEvent && "mousemove" === event.type
          ? ((lastMovementX = event.screenX - lastMouseEvent.screenX),
            (lastMovementY = event.screenY - lastMouseEvent.screenY))
          : (lastMovementY = lastMovementX = 0),
        (lastMouseEvent = event));
      return lastMovementX;
    },
    movementY: function (event) {
      return "movementY" in event ? event.movementY : lastMovementY;
    }
  }),
  SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),
  DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }),
  SyntheticDragEvent = createSyntheticEvent(DragEventInterface),
  FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }),
  SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),
  AnimationEventInterface = assign({}, EventInterface, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }),
  SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),
  ClipboardEventInterface = assign({}, EventInterface, {
    clipboardData: function (event) {
      return "clipboardData" in event
        ? event.clipboardData
        : window.clipboardData;
    }
  }),
  SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),
  CompositionEventInterface = assign({}, EventInterface, { data: 0 }),
  SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface),
  normalizeKey = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  },
  translateToKey = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  },
  modifierKeyToProp = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
function modifierStateGetter(keyArg) {
  var nativeEvent = this.nativeEvent;
  return nativeEvent.getModifierState
    ? nativeEvent.getModifierState(keyArg)
    : (keyArg = modifierKeyToProp[keyArg])
      ? !!nativeEvent[keyArg]
      : !1;
}
function getEventModifierState() {
  return modifierStateGetter;
}
var KeyboardEventInterface = assign({}, UIEventInterface, {
    key: function (nativeEvent) {
      if (nativeEvent.key) {
        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
        if ("Unidentified" !== key) return key;
      }
      return "keypress" === nativeEvent.type
        ? ((nativeEvent = getEventCharCode(nativeEvent)),
          13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent))
        : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type
          ? translateToKey[nativeEvent.keyCode] || "Unidentified"
          : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: getEventModifierState,
    charCode: function (event) {
      return "keypress" === event.type ? getEventCharCode(event) : 0;
    },
    keyCode: function (event) {
      return "keydown" === event.type || "keyup" === event.type
        ? event.keyCode
        : 0;
    },
    which: function (event) {
      return "keypress" === event.type
        ? getEventCharCode(event)
        : "keydown" === event.type || "keyup" === event.type
          ? event.keyCode
          : 0;
    }
  }),
  SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),
  PointerEventInterface = assign({}, MouseEventInterface, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }),
  SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),
  TouchEventInterface = assign({}, UIEventInterface, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: getEventModifierState
  }),
  SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),
  TransitionEventInterface = assign({}, EventInterface, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }),
  SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),
  WheelEventInterface = assign({}, MouseEventInterface, {
    deltaX: function (event) {
      return "deltaX" in event
        ? event.deltaX
        : "wheelDeltaX" in event
          ? -event.wheelDeltaX
          : 0;
    },
    deltaY: function (event) {
      return "deltaY" in event
        ? event.deltaY
        : "wheelDeltaY" in event
          ? -event.wheelDeltaY
          : "wheelDelta" in event
            ? -event.wheelDelta
            : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }),
  SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),
  ToggleEventInterface = assign({}, EventInterface, {
    newState: 0,
    oldState: 0
  }),
  SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),
  END_KEYCODES = [9, 13, 27, 32],
  canUseCompositionEvent = canUseDOM && "CompositionEvent" in window,
  documentMode = null;
canUseDOM &&
  "documentMode" in document &&
  (documentMode = document.documentMode);
var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode,
  useFallbackCompositionData =
    canUseDOM &&
    (!canUseCompositionEvent ||
      (documentMode && 8 < documentMode && 11 >= documentMode)),
  SPACEBAR_CHAR = String.fromCharCode(32),
  hasSpaceKeypress = !1;
function isFallbackCompositionEnd(domEventName, nativeEvent) {
  switch (domEventName) {
    case "keyup":
      return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
    case "keydown":
      return 229 !== nativeEvent.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function getDataFromCustomEvent(nativeEvent) {
  nativeEvent = nativeEvent.detail;
  return "object" === typeof nativeEvent && "data" in nativeEvent
    ? nativeEvent.data
    : null;
}
var isComposing = !1;
function getNativeBeforeInputChars(domEventName, nativeEvent) {
  switch (domEventName) {
    case "compositionend":
      return getDataFromCustomEvent(nativeEvent);
    case "keypress":
      if (32 !== nativeEvent.which) return null;
      hasSpaceKeypress = !0;
      return SPACEBAR_CHAR;
    case "textInput":
      return (
        (domEventName = nativeEvent.data),
        domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName
      );
    default:
      return null;
  }
}
function getFallbackBeforeInputChars(domEventName, nativeEvent) {
  if (isComposing)
    return "compositionend" === domEventName ||
      (!canUseCompositionEvent &&
        isFallbackCompositionEnd(domEventName, nativeEvent))
      ? ((domEventName = getData()),
        (fallbackText = startText = root = null),
        (isComposing = !1),
        domEventName)
      : null;
  switch (domEventName) {
    case "paste":
      return null;
    case "keypress":
      if (
        !(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) ||
        (nativeEvent.ctrlKey && nativeEvent.altKey)
      ) {
        if (nativeEvent.char && 1 < nativeEvent.char.length)
          return nativeEvent.char;
        if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
      }
      return null;
    case "compositionend":
      return useFallbackCompositionData && "ko" !== nativeEvent.locale
        ? null
        : nativeEvent.data;
    default:
      return null;
  }
}
var supportedInputTypes = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0
};
function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return "input" === nodeName
    ? !!supportedInputTypes[elem.type]
    : "textarea" === nodeName
      ? !0
      : !1;
}
function createAndAccumulateChangeEvent(
  dispatchQueue,
  inst,
  nativeEvent,
  target
) {
  restoreTarget
    ? restoreQueue
      ? restoreQueue.push(target)
      : (restoreQueue = [target])
    : (restoreTarget = target);
  inst = accumulateTwoPhaseListeners(inst, "onChange");
  0 < inst.length &&
    ((nativeEvent = new SyntheticEvent(
      "onChange",
      "change",
      null,
      nativeEvent,
      target
    )),
    dispatchQueue.push({ event: nativeEvent, listeners: inst }));
}
var activeElement$1 = null,
  activeElementInst$1 = null;
function runEventInBatch(dispatchQueue) {
  processDispatchQueue(dispatchQueue, 0);
}
function getInstIfValueChanged(targetInst) {
  var targetNode = getNodeFromInstance(targetInst);
  if (updateValueIfChanged(targetNode)) return targetInst;
}
function getTargetInstForChangeEvent(domEventName, targetInst) {
  if ("change" === domEventName) return targetInst;
}
var isInputEventSupported = !1;
if (canUseDOM) {
  var JSCompiler_inline_result$jscomp$286;
  if (canUseDOM) {
    var isSupported$jscomp$inline_427 = "oninput" in document;
    if (!isSupported$jscomp$inline_427) {
      var element$jscomp$inline_428 = document.createElement("div");
      element$jscomp$inline_428.setAttribute("oninput", "return;");
      isSupported$jscomp$inline_427 =
        "function" === typeof element$jscomp$inline_428.oninput;
    }
    JSCompiler_inline_result$jscomp$286 = isSupported$jscomp$inline_427;
  } else JSCompiler_inline_result$jscomp$286 = !1;
  isInputEventSupported =
    JSCompiler_inline_result$jscomp$286 &&
    (!document.documentMode || 9 < document.documentMode);
}
function stopWatchingForValueChange() {
  activeElement$1 &&
    (activeElement$1.detachEvent("onpropertychange", handlePropertyChange),
    (activeElementInst$1 = activeElement$1 = null));
}
function handlePropertyChange(nativeEvent) {
  if (
    "value" === nativeEvent.propertyName &&
    getInstIfValueChanged(activeElementInst$1)
  ) {
    var dispatchQueue = [];
    createAndAccumulateChangeEvent(
      dispatchQueue,
      activeElementInst$1,
      nativeEvent,
      getEventTarget(nativeEvent)
    );
    batchedUpdates$1(runEventInBatch, dispatchQueue);
  }
}
function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
  "focusin" === domEventName
    ? (stopWatchingForValueChange(),
      (activeElement$1 = target),
      (activeElementInst$1 = targetInst),
      activeElement$1.attachEvent("onpropertychange", handlePropertyChange))
    : "focusout" === domEventName && stopWatchingForValueChange();
}
function getTargetInstForInputEventPolyfill(domEventName) {
  if (
    "selectionchange" === domEventName ||
    "keyup" === domEventName ||
    "keydown" === domEventName
  )
    return getInstIfValueChanged(activeElementInst$1);
}
function getTargetInstForClickEvent(domEventName, targetInst) {
  if ("click" === domEventName) return getInstIfValueChanged(targetInst);
}
function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
  if ("input" === domEventName || "change" === domEventName)
    return getInstIfValueChanged(targetInst);
}
function is(x, y) {
  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
}
var objectIs = "function" === typeof Object.is ? Object.is : is;
function shallowEqual(objA, objB) {
  if (objectIs(objA, objB)) return !0;
  if (
    "object" !== typeof objA ||
    null === objA ||
    "object" !== typeof objB ||
    null === objB
  )
    return !1;
  var keysA = Object.keys(objA),
    keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) return !1;
  for (keysB = 0; keysB < keysA.length; keysB++) {
    var currentKey = keysA[keysB];
    if (
      !hasOwnProperty.call(objB, currentKey) ||
      !objectIs(objA[currentKey], objB[currentKey])
    )
      return !1;
  }
  return !0;
}
function getLeafNode(node) {
  for (; node && node.firstChild; ) node = node.firstChild;
  return node;
}
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  root = 0;
  for (var nodeEnd; node; ) {
    if (3 === node.nodeType) {
      nodeEnd = root + node.textContent.length;
      if (root <= offset && nodeEnd >= offset)
        return { node: node, offset: offset - root };
      root = nodeEnd;
    }
    a: {
      for (; node; ) {
        if (node.nextSibling) {
          node = node.nextSibling;
          break a;
        }
        node = node.parentNode;
      }
      node = void 0;
    }
    node = getLeafNode(node);
  }
}
function containsNode(outerNode, innerNode) {
  return outerNode && innerNode
    ? outerNode === innerNode
      ? !0
      : outerNode && 3 === outerNode.nodeType
        ? !1
        : innerNode && 3 === innerNode.nodeType
          ? containsNode(outerNode, innerNode.parentNode)
          : "contains" in outerNode
            ? outerNode.contains(innerNode)
            : outerNode.compareDocumentPosition
              ? !!(outerNode.compareDocumentPosition(innerNode) & 16)
              : !1
    : !1;
}
function getActiveElementDeep(containerInfo) {
  containerInfo =
    null != containerInfo &&
    null != containerInfo.ownerDocument &&
    null != containerInfo.ownerDocument.defaultView
      ? containerInfo.ownerDocument.defaultView
      : window;
  for (
    var element = getActiveElement(containerInfo.document);
    element instanceof containerInfo.HTMLIFrameElement;

  ) {
    try {
      var JSCompiler_inline_result =
        "string" === typeof element.contentWindow.location.href;
    } catch (err) {
      JSCompiler_inline_result = !1;
    }
    if (JSCompiler_inline_result) containerInfo = element.contentWindow;
    else break;
    element = getActiveElement(containerInfo.document);
  }
  return element;
}
function hasSelectionCapabilities(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return (
    nodeName &&
    (("input" === nodeName &&
      ("text" === elem.type ||
        "search" === elem.type ||
        "tel" === elem.type ||
        "url" === elem.type ||
        "password" === elem.type)) ||
      "textarea" === nodeName ||
      "true" === elem.contentEditable)
  );
}
var skipSelectionChangeEvent =
    canUseDOM && "documentMode" in document && 11 >= document.documentMode,
  activeElement = null,
  activeElementInst = null,
  lastSelection = null,
  mouseDown = !1;
function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
  var doc =
    nativeEventTarget.window === nativeEventTarget
      ? nativeEventTarget.document
      : 9 === nativeEventTarget.nodeType
        ? nativeEventTarget
        : nativeEventTarget.ownerDocument;
  mouseDown ||
    null == activeElement ||
    activeElement !== getActiveElement(doc) ||
    ((doc = activeElement),
    "selectionStart" in doc && hasSelectionCapabilities(doc)
      ? (doc = { start: doc.selectionStart, end: doc.selectionEnd })
      : ((doc = (
          (doc.ownerDocument && doc.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (doc = {
          anchorNode: doc.anchorNode,
          anchorOffset: doc.anchorOffset,
          focusNode: doc.focusNode,
          focusOffset: doc.focusOffset
        })),
    (lastSelection && shallowEqual(lastSelection, doc)) ||
      ((lastSelection = doc),
      (doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect")),
      0 < doc.length &&
        ((nativeEvent = new SyntheticEvent(
          "onSelect",
          "select",
          null,
          nativeEvent,
          nativeEventTarget
        )),
        dispatchQueue.push({ event: nativeEvent, listeners: doc }),
        (nativeEvent.target = activeElement))));
}
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};
  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes["Webkit" + styleProp] = "webkit" + eventName;
  prefixes["Moz" + styleProp] = "moz" + eventName;
  return prefixes;
}
var vendorPrefixes = {
    animationend: makePrefixMap("Animation", "AnimationEnd"),
    animationiteration: makePrefixMap("Animation", "AnimationIteration"),
    animationstart: makePrefixMap("Animation", "AnimationStart"),
    transitionrun: makePrefixMap("Transition", "TransitionRun"),
    transitionstart: makePrefixMap("Transition", "TransitionStart"),
    transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
    transitionend: makePrefixMap("Transition", "TransitionEnd")
  },
  prefixedEventNames = {},
  style = {};
canUseDOM &&
  ((style = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete vendorPrefixes.animationend.animation,
    delete vendorPrefixes.animationiteration.animation,
    delete vendorPrefixes.animationstart.animation),
  "TransitionEvent" in window ||
    delete vendorPrefixes.transitionend.transition);
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
  if (!vendorPrefixes[eventName]) return eventName;
  var prefixMap = vendorPrefixes[eventName],
    styleProp;
  for (styleProp in prefixMap)
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
      return (prefixedEventNames[eventName] = prefixMap[styleProp]);
  return eventName;
}
var ANIMATION_END = getVendorPrefixedEventName("animationend"),
  ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"),
  ANIMATION_START = getVendorPrefixedEventName("animationstart"),
  TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"),
  TRANSITION_START = getVendorPrefixedEventName("transitionstart"),
  TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"),
  TRANSITION_END = getVendorPrefixedEventName("transitionend"),
  topLevelEventsToReactNames = new Map(),
  simpleEventPluginEvents =
    "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
simpleEventPluginEvents.push("scrollEnd");
function registerSimpleEvent(domEventName, reactName) {
  topLevelEventsToReactNames.set(domEventName, reactName);
  registerTwoPhaseEvent(reactName, [domEventName]);
}
var reportGlobalError =
    "function" === typeof reportError
      ? reportError
      : function (error) {
          if (
            "object" === typeof window &&
            "function" === typeof window.ErrorEvent
          ) {
            var event = new window.ErrorEvent("error", {
              bubbles: !0,
              cancelable: !0,
              message:
                "object" === typeof error &&
                null !== error &&
                "string" === typeof error.message
                  ? String(error.message)
                  : String(error),
              error: error
            });
            if (!window.dispatchEvent(event)) return;
          } else if (
            "object" === typeof process &&
            "function" === typeof process.emit
          ) {
            process.emit("uncaughtException", error);
            return;
          }
          console.error(error);
        },
  concurrentQueues = [],
  concurrentQueuesIndex = 0,
  concurrentlyUpdatedLanes = 0;
function finishQueueingConcurrentUpdates() {
  for (
    var endIndex = concurrentQueuesIndex,
      i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = 0);
    i < endIndex;

  ) {
    var fiber = concurrentQueues[i];
    concurrentQueues[i++] = null;
    var queue = concurrentQueues[i];
    concurrentQueues[i++] = null;
    var update = concurrentQueues[i];
    concurrentQueues[i++] = null;
    var lane = concurrentQueues[i];
    concurrentQueues[i++] = null;
    if (null !== queue && null !== update) {
      var pending = queue.pending;
      null === pending
        ? (update.next = update)
        : ((update.next = pending.next), (pending.next = update));
      queue.pending = update;
    }
    0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
  }
}
function enqueueUpdate$1(fiber, queue, update, lane) {
  concurrentQueues[concurrentQueuesIndex++] = fiber;
  concurrentQueues[concurrentQueuesIndex++] = queue;
  concurrentQueues[concurrentQueuesIndex++] = update;
  concurrentQueues[concurrentQueuesIndex++] = lane;
  concurrentlyUpdatedLanes |= lane;
  fiber.lanes |= lane;
  fiber = fiber.alternate;
  null !== fiber && (fiber.lanes |= lane);
}
function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
  enqueueUpdate$1(fiber, queue, update, lane);
  return getRootForUpdatedFiber(fiber);
}
function enqueueConcurrentRenderForLane(fiber, lane) {
  enqueueUpdate$1(fiber, null, null, lane);
  return getRootForUpdatedFiber(fiber);
}
function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
  sourceFiber.lanes |= lane;
  var alternate = sourceFiber.alternate;
  null !== alternate && (alternate.lanes |= lane);
  for (var isHidden = !1, parent = sourceFiber.return; null !== parent; )
    (parent.childLanes |= lane),
      (alternate = parent.alternate),
      null !== alternate && (alternate.childLanes |= lane),
      22 === parent.tag &&
        ((sourceFiber = parent.stateNode),
        null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = !0)),
      (sourceFiber = parent),
      (parent = parent.return);
  return 3 === sourceFiber.tag
    ? ((parent = sourceFiber.stateNode),
      isHidden &&
        null !== update &&
        ((isHidden = 31 - clz32(lane)),
        (sourceFiber = parent.hiddenUpdates),
        (alternate = sourceFiber[isHidden]),
        null === alternate
          ? (sourceFiber[isHidden] = [update])
          : alternate.push(update),
        (update.lane = lane | 536870912)),
      parent)
    : null;
}
function getRootForUpdatedFiber(sourceFiber) {
  if (50 < nestedUpdateCount)
    throw (
      ((nestedUpdateCount = 0),
      (rootWithNestedUpdates = null),
      Error(formatProdErrorMessage(185)))
    );
  for (var parent = sourceFiber.return; null !== parent; )
    (sourceFiber = parent), (parent = sourceFiber.return);
  return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
}
var emptyContextObject = {};
function FiberNode(tag, pendingProps, key, mode) {
  this.tag = tag;
  this.key = key;
  this.sibling =
    this.child =
    this.return =
    this.stateNode =
    this.type =
    this.elementType =
      null;
  this.index = 0;
  this.refCleanup = this.ref = null;
  this.pendingProps = pendingProps;
  this.dependencies =
    this.memoizedState =
    this.updateQueue =
    this.memoizedProps =
      null;
  this.mode = mode;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function createFiberImplClass(tag, pendingProps, key, mode) {
  return new FiberNode(tag, pendingProps, key, mode);
}
function shouldConstruct(Component) {
  Component = Component.prototype;
  return !(!Component || !Component.isReactComponent);
}
function createWorkInProgress(current, pendingProps) {
  var workInProgress = current.alternate;
  null === workInProgress
    ? ((workInProgress = createFiberImplClass(
        current.tag,
        pendingProps,
        current.key,
        current.mode
      )),
      (workInProgress.elementType = current.elementType),
      (workInProgress.type = current.type),
      (workInProgress.stateNode = current.stateNode),
      (workInProgress.alternate = current),
      (current.alternate = workInProgress))
    : ((workInProgress.pendingProps = pendingProps),
      (workInProgress.type = current.type),
      (workInProgress.flags = 0),
      (workInProgress.subtreeFlags = 0),
      (workInProgress.deletions = null));
  workInProgress.flags = current.flags & 65011712;
  workInProgress.childLanes = current.childLanes;
  workInProgress.lanes = current.lanes;
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;
  pendingProps = current.dependencies;
  workInProgress.dependencies =
    null === pendingProps
      ? null
      : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;
  workInProgress.refCleanup = current.refCleanup;
  return workInProgress;
}
function resetWorkInProgress(workInProgress, renderLanes) {
  workInProgress.flags &= 65011714;
  var current = workInProgress.alternate;
  null === current
    ? ((workInProgress.childLanes = 0),
      (workInProgress.lanes = renderLanes),
      (workInProgress.child = null),
      (workInProgress.subtreeFlags = 0),
      (workInProgress.memoizedProps = null),
      (workInProgress.memoizedState = null),
      (workInProgress.updateQueue = null),
      (workInProgress.dependencies = null),
      (workInProgress.stateNode = null))
    : ((workInProgress.childLanes = current.childLanes),
      (workInProgress.lanes = current.lanes),
      (workInProgress.child = current.child),
      (workInProgress.subtreeFlags = 0),
      (workInProgress.deletions = null),
      (workInProgress.memoizedProps = current.memoizedProps),
      (workInProgress.memoizedState = current.memoizedState),
      (workInProgress.updateQueue = current.updateQueue),
      (workInProgress.type = current.type),
      (renderLanes = current.dependencies),
      (workInProgress.dependencies =
        null === renderLanes
          ? null
          : {
              lanes: renderLanes.lanes,
              firstContext: renderLanes.firstContext
            }));
  return workInProgress;
}
function createFiberFromTypeAndProps(
  type,
  key,
  pendingProps,
  owner,
  mode,
  lanes
) {
  var fiberTag = 0;
  owner = type;
  if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
  else if ("string" === typeof type)
    fiberTag = isHostHoistableType(
      type,
      pendingProps,
      contextStackCursor.current
    )
      ? 26
      : "html" === type || "head" === type || "body" === type
        ? 27
        : 5;
  else
    a: switch (type) {
      case REACT_ACTIVITY_TYPE:
        return (
          (type = createFiberImplClass(31, pendingProps, key, mode)),
          (type.elementType = REACT_ACTIVITY_TYPE),
          (type.lanes = lanes),
          type
        );
      case REACT_FRAGMENT_TYPE:
        return createFiberFromFragment(pendingProps.children, mode, lanes, key);
      case REACT_STRICT_MODE_TYPE:
        fiberTag = 8;
        mode |= 24;
        break;
      case REACT_PROFILER_TYPE:
        return (
          (type = createFiberImplClass(12, pendingProps, key, mode | 2)),
          (type.elementType = REACT_PROFILER_TYPE),
          (type.lanes = lanes),
          type
        );
      case REACT_SUSPENSE_TYPE:
        return (
          (type = createFiberImplClass(13, pendingProps, key, mode)),
          (type.elementType = REACT_SUSPENSE_TYPE),
          (type.lanes = lanes),
          type
        );
      case REACT_SUSPENSE_LIST_TYPE:
        return (
          (type = createFiberImplClass(19, pendingProps, key, mode)),
          (type.elementType = REACT_SUSPENSE_LIST_TYPE),
          (type.lanes = lanes),
          type
        );
      default:
        if ("object" === typeof type && null !== type)
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              fiberTag = 10;
              break a;
            case REACT_CONSUMER_TYPE:
              fiberTag = 9;
              break a;
            case REACT_FORWARD_REF_TYPE:
              fiberTag = 11;
              break a;
            case REACT_MEMO_TYPE:
              fiberTag = 14;
              break a;
            case REACT_LAZY_TYPE:
              fiberTag = 16;
              owner = null;
              break a;
          }
        fiberTag = 29;
        pendingProps = Error(
          formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
        );
        owner = null;
    }
  key = createFiberImplClass(fiberTag, pendingProps, key, mode);
  key.elementType = type;
  key.type = owner;
  key.lanes = lanes;
  return key;
}
function createFiberFromFragment(elements, mode, lanes, key) {
  elements = createFiberImplClass(7, elements, key, mode);
  elements.lanes = lanes;
  return elements;
}
function createFiberFromText(content, mode, lanes) {
  content = createFiberImplClass(6, content, null, mode);
  content.lanes = lanes;
  return content;
}
function createFiberFromDehydratedFragment(dehydratedNode) {
  var fiber = createFiberImplClass(18, null, null, 0);
  fiber.stateNode = dehydratedNode;
  return fiber;
}
function createFiberFromPortal(portal, mode, lanes) {
  mode = createFiberImplClass(
    4,
    null !== portal.children ? portal.children : [],
    portal.key,
    mode
  );
  mode.lanes = lanes;
  mode.stateNode = {
    containerInfo: portal.containerInfo,
    pendingChildren: null,
    implementation: portal.implementation
  };
  return mode;
}
var CapturedStacks = new WeakMap();
function createCapturedValueAtFiber(value, source) {
  if ("object" === typeof value && null !== value) {
    var existing = CapturedStacks.get(value);
    if (void 0 !== existing) return existing;
    source = {
      value: value,
      source: source,
      stack: getStackByFiberInDevAndProd(source)
    };
    CapturedStacks.set(value, source);
    return source;
  }
  return {
    value: value,
    source: source,
    stack: getStackByFiberInDevAndProd(source)
  };
}
var forkStack = [],
  forkStackIndex = 0,
  treeForkProvider = null,
  treeForkCount = 0,
  idStack = [],
  idStackIndex = 0,
  treeContextProvider = null,
  treeContextId = 1,
  treeContextOverflow = "";
function pushTreeFork(workInProgress, totalChildren) {
  forkStack[forkStackIndex++] = treeForkCount;
  forkStack[forkStackIndex++] = treeForkProvider;
  treeForkProvider = workInProgress;
  treeForkCount = totalChildren;
}
function pushTreeId(workInProgress, totalChildren, index) {
  idStack[idStackIndex++] = treeContextId;
  idStack[idStackIndex++] = treeContextOverflow;
  idStack[idStackIndex++] = treeContextProvider;
  treeContextProvider = workInProgress;
  var baseIdWithLeadingBit = treeContextId;
  workInProgress = treeContextOverflow;
  var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
  baseIdWithLeadingBit &= ~(1 << baseLength);
  index += 1;
  var length = 32 - clz32(totalChildren) + baseLength;
  if (30 < length) {
    var numberOfOverflowBits = baseLength - (baseLength % 5);
    length = (
      baseIdWithLeadingBit &
      ((1 << numberOfOverflowBits) - 1)
    ).toString(32);
    baseIdWithLeadingBit >>= numberOfOverflowBits;
    baseLength -= numberOfOverflowBits;
    treeContextId =
      (1 << (32 - clz32(totalChildren) + baseLength)) |
      (index << baseLength) |
      baseIdWithLeadingBit;
    treeContextOverflow = length + workInProgress;
  } else
    (treeContextId =
      (1 << length) | (index << baseLength) | baseIdWithLeadingBit),
      (treeContextOverflow = workInProgress);
}
function pushMaterializedTreeId(workInProgress) {
  null !== workInProgress.return &&
    (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
}
function popTreeContext(workInProgress) {
  for (; workInProgress === treeForkProvider; )
    (treeForkProvider = forkStack[--forkStackIndex]),
      (forkStack[forkStackIndex] = null),
      (treeForkCount = forkStack[--forkStackIndex]),
      (forkStack[forkStackIndex] = null);
  for (; workInProgress === treeContextProvider; )
    (treeContextProvider = idStack[--idStackIndex]),
      (idStack[idStackIndex] = null),
      (treeContextOverflow = idStack[--idStackIndex]),
      (idStack[idStackIndex] = null),
      (treeContextId = idStack[--idStackIndex]),
      (idStack[idStackIndex] = null);
}
function restoreSuspendedTreeContext(workInProgress, suspendedContext) {
  idStack[idStackIndex++] = treeContextId;
  idStack[idStackIndex++] = treeContextOverflow;
  idStack[idStackIndex++] = treeContextProvider;
  treeContextId = suspendedContext.id;
  treeContextOverflow = suspendedContext.overflow;
  treeContextProvider = workInProgress;
}
var hydrationParentFiber = null,
  nextHydratableInstance = null,
  isHydrating = !1,
  hydrationErrors = null,
  rootOrSingletonContext = !1,
  HydrationMismatchException = Error(formatProdErrorMessage(519));
function throwOnHydrationMismatch(fiber) {
  var error = Error(
    formatProdErrorMessage(
      418,
      1 < arguments.length && void 0 !== arguments[1] && arguments[1]
        ? "text"
        : "HTML",
      ""
    )
  );
  queueHydrationError(createCapturedValueAtFiber(error, fiber));
  throw HydrationMismatchException;
}
function prepareToHydrateHostInstance(fiber) {
  var instance = fiber.stateNode,
    type = fiber.type,
    props = fiber.memoizedProps;
  instance[internalInstanceKey] = fiber;
  instance[internalPropsKey] = props;
  switch (type) {
    case "dialog":
      listenToNonDelegatedEvent("cancel", instance);
      listenToNonDelegatedEvent("close", instance);
      break;
    case "iframe":
    case "object":
    case "embed":
      listenToNonDelegatedEvent("load", instance);
      break;
    case "video":
    case "audio":
      for (type = 0; type < mediaEventTypes.length; type++)
        listenToNonDelegatedEvent(mediaEventTypes[type], instance);
      break;
    case "source":
      listenToNonDelegatedEvent("error", instance);
      break;
    case "img":
    case "image":
    case "link":
      listenToNonDelegatedEvent("error", instance);
      listenToNonDelegatedEvent("load", instance);
      break;
    case "details":
      listenToNonDelegatedEvent("toggle", instance);
      break;
    case "input":
      listenToNonDelegatedEvent("invalid", instance);
      initInput(
        instance,
        props.value,
        props.defaultValue,
        props.checked,
        props.defaultChecked,
        props.type,
        props.name,
        !0
      );
      break;
    case "select":
      listenToNonDelegatedEvent("invalid", instance);
      break;
    case "textarea":
      listenToNonDelegatedEvent("invalid", instance),
        initTextarea(instance, props.value, props.defaultValue, props.children);
  }
  type = props.children;
  ("string" !== typeof type &&
    "number" !== typeof type &&
    "bigint" !== typeof type) ||
  instance.textContent === "" + type ||
  !0 === props.suppressHydrationWarning ||
  checkForUnmatchedText(instance.textContent, type)
    ? (null != props.popover &&
        (listenToNonDelegatedEvent("beforetoggle", instance),
        listenToNonDelegatedEvent("toggle", instance)),
      null != props.onScroll && listenToNonDelegatedEvent("scroll", instance),
      null != props.onScrollEnd &&
        listenToNonDelegatedEvent("scrollend", instance),
      null != props.onClick && (instance.onclick = noop$1),
      (instance = !0))
    : (instance = !1);
  instance || throwOnHydrationMismatch(fiber, !0);
}
function popToNextHostParent(fiber) {
  for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
    switch (hydrationParentFiber.tag) {
      case 5:
      case 31:
      case 13:
        rootOrSingletonContext = !1;
        return;
      case 27:
      case 3:
        rootOrSingletonContext = !0;
        return;
      default:
        hydrationParentFiber = hydrationParentFiber.return;
    }
}
function popHydrationState(fiber) {
  if (fiber !== hydrationParentFiber) return !1;
  if (!isHydrating) return popToNextHostParent(fiber), (isHydrating = !0), !1;
  var tag = fiber.tag,
    JSCompiler_temp;
  if ((JSCompiler_temp = 3 !== tag && 27 !== tag)) {
    if ((JSCompiler_temp = 5 === tag))
      (JSCompiler_temp = fiber.type),
        (JSCompiler_temp =
          !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) ||
          shouldSetTextContent(fiber.type, fiber.memoizedProps));
    JSCompiler_temp = !JSCompiler_temp;
  }
  JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
  popToNextHostParent(fiber);
  if (13 === tag) {
    fiber = fiber.memoizedState;
    fiber = null !== fiber ? fiber.dehydrated : null;
    if (!fiber) throw Error(formatProdErrorMessage(317));
    nextHydratableInstance =
      getNextHydratableInstanceAfterHydrationBoundary(fiber);
  } else if (31 === tag) {
    fiber = fiber.memoizedState;
    fiber = null !== fiber ? fiber.dehydrated : null;
    if (!fiber) throw Error(formatProdErrorMessage(317));
    nextHydratableInstance =
      getNextHydratableInstanceAfterHydrationBoundary(fiber);
  } else
    27 === tag
      ? ((tag = nextHydratableInstance),
        isSingletonScope(fiber.type)
          ? ((fiber = previousHydratableOnEnteringScopedSingleton),
            (previousHydratableOnEnteringScopedSingleton = null),
            (nextHydratableInstance = fiber))
          : (nextHydratableInstance = tag))
      : (nextHydratableInstance = hydrationParentFiber
          ? getNextHydratable(fiber.stateNode.nextSibling)
          : null);
  return !0;
}
function resetHydrationState() {
  nextHydratableInstance = hydrationParentFiber = null;
  isHydrating = !1;
}
function upgradeHydrationErrorsToRecoverable() {
  var queuedErrors = hydrationErrors;
  null !== queuedErrors &&
    (null === workInProgressRootRecoverableErrors
      ? (workInProgressRootRecoverableErrors = queuedErrors)
      : workInProgressRootRecoverableErrors.push.apply(
          workInProgressRootRecoverableErrors,
          queuedErrors
        ),
    (hydrationErrors = null));
  return queuedErrors;
}
function queueHydrationError(error) {
  null === hydrationErrors
    ? (hydrationErrors = [error])
    : hydrationErrors.push(error);
}
var valueCursor = createCursor(null),
  currentlyRenderingFiber$1 = null,
  lastContextDependency = null;
function pushProvider(providerFiber, context, nextValue) {
  push(valueCursor, context._currentValue);
  context._currentValue = nextValue;
}
function popProvider(context) {
  context._currentValue = valueCursor.current;
  pop(valueCursor);
}
function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
  for (; null !== parent; ) {
    var alternate = parent.alternate;
    (parent.childLanes & renderLanes) !== renderLanes
      ? ((parent.childLanes |= renderLanes),
        null !== alternate && (alternate.childLanes |= renderLanes))
      : null !== alternate &&
        (alternate.childLanes & renderLanes) !== renderLanes &&
        (alternate.childLanes |= renderLanes);
    if (parent === propagationRoot) break;
    parent = parent.return;
  }
}
function propagateContextChanges(
  workInProgress,
  contexts,
  renderLanes,
  forcePropagateEntireTree
) {
  var fiber = workInProgress.child;
  null !== fiber && (fiber.return = workInProgress);
  for (; null !== fiber; ) {
    var list = fiber.dependencies;
    if (null !== list) {
      var nextFiber = fiber.child;
      list = list.firstContext;
      a: for (; null !== list; ) {
        var dependency = list;
        list = fiber;
        for (var i = 0; i < contexts.length; i++)
          if (dependency.context === contexts[i]) {
            list.lanes |= renderLanes;
            dependency = list.alternate;
            null !== dependency && (dependency.lanes |= renderLanes);
            scheduleContextWorkOnParentPath(
              list.return,
              renderLanes,
              workInProgress
            );
            forcePropagateEntireTree || (nextFiber = null);
            break a;
          }
        list = dependency.next;
      }
    } else if (18 === fiber.tag) {
      nextFiber = fiber.return;
      if (null === nextFiber) throw Error(formatProdErrorMessage(341));
      nextFiber.lanes |= renderLanes;
      list = nextFiber.alternate;
      null !== list && (list.lanes |= renderLanes);
      scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);
      nextFiber = null;
    } else nextFiber = fiber.child;
    if (null !== nextFiber) nextFiber.return = fiber;
    else
      for (nextFiber = fiber; null !== nextFiber; ) {
        if (nextFiber === workInProgress) {
          nextFiber = null;
          break;
        }
        fiber = nextFiber.sibling;
        if (null !== fiber) {
          fiber.return = nextFiber.return;
          nextFiber = fiber;
          break;
        }
        nextFiber = nextFiber.return;
      }
    fiber = nextFiber;
  }
}
function propagateParentContextChanges(
  current,
  workInProgress,
  renderLanes,
  forcePropagateEntireTree
) {
  current = null;
  for (
    var parent = workInProgress, isInsidePropagationBailout = !1;
    null !== parent;

  ) {
    if (!isInsidePropagationBailout)
      if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;
      else if (0 !== (parent.flags & 262144)) break;
    if (10 === parent.tag) {
      var currentParent = parent.alternate;
      if (null === currentParent) throw Error(formatProdErrorMessage(387));
      currentParent = currentParent.memoizedProps;
      if (null !== currentParent) {
        var context = parent.type;
        objectIs(parent.pendingProps.value, currentParent.value) ||
          (null !== current ? current.push(context) : (current = [context]));
      }
    } else if (parent === hostTransitionProviderCursor.current) {
      currentParent = parent.alternate;
      if (null === currentParent) throw Error(formatProdErrorMessage(387));
      currentParent.memoizedState.memoizedState !==
        parent.memoizedState.memoizedState &&
        (null !== current
          ? current.push(HostTransitionContext)
          : (current = [HostTransitionContext]));
    }
    parent = parent.return;
  }
  null !== current &&
    propagateContextChanges(
      workInProgress,
      current,
      renderLanes,
      forcePropagateEntireTree
    );
  workInProgress.flags |= 262144;
}
function checkIfContextChanged(currentDependencies) {
  for (
    currentDependencies = currentDependencies.firstContext;
    null !== currentDependencies;

  ) {
    if (
      !objectIs(
        currentDependencies.context._currentValue,
        currentDependencies.memoizedValue
      )
    )
      return !0;
    currentDependencies = currentDependencies.next;
  }
  return !1;
}
function prepareToReadContext(workInProgress) {
  currentlyRenderingFiber$1 = workInProgress;
  lastContextDependency = null;
  workInProgress = workInProgress.dependencies;
  null !== workInProgress && (workInProgress.firstContext = null);
}
function readContext(context) {
  return readContextForConsumer(currentlyRenderingFiber$1, context);
}
function readContextDuringReconciliation(consumer, context) {
  null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
  return readContextForConsumer(consumer, context);
}
function readContextForConsumer(consumer, context) {
  var value = context._currentValue;
  context = { context: context, memoizedValue: value, next: null };
  if (null === lastContextDependency) {
    if (null === consumer) throw Error(formatProdErrorMessage(308));
    lastContextDependency = context;
    consumer.dependencies = { lanes: 0, firstContext: context };
    consumer.flags |= 524288;
  } else lastContextDependency = lastContextDependency.next = context;
  return value;
}
var AbortControllerLocal =
    "undefined" !== typeof AbortController
      ? AbortController
      : function () {
          var listeners = [],
            signal = (this.signal = {
              aborted: !1,
              addEventListener: function (type, listener) {
                listeners.push(listener);
              }
            });
          this.abort = function () {
            signal.aborted = !0;
            listeners.forEach(function (listener) {
              return listener();
            });
          };
        },
  scheduleCallback$2 = Scheduler.unstable_scheduleCallback,
  NormalPriority = Scheduler.unstable_NormalPriority,
  CacheContext = {
    $$typeof: REACT_CONTEXT_TYPE,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
function createCache() {
  return {
    controller: new AbortControllerLocal(),
    data: new Map(),
    refCount: 0
  };
}
function releaseCache(cache) {
  cache.refCount--;
  0 === cache.refCount &&
    scheduleCallback$2(NormalPriority, function () {
      cache.controller.abort();
    });
}
var currentEntangledListeners = null,
  currentEntangledPendingCount = 0,
  currentEntangledLane = 0,
  currentEntangledActionThenable = null;
function entangleAsyncAction(transition, thenable) {
  if (null === currentEntangledListeners) {
    var entangledListeners = (currentEntangledListeners = []);
    currentEntangledPendingCount = 0;
    currentEntangledLane = requestTransitionLane();
    currentEntangledActionThenable = {
      status: "pending",
      value: void 0,
      then: function (resolve) {
        entangledListeners.push(resolve);
      }
    };
  }
  currentEntangledPendingCount++;
  thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
  return thenable;
}
function pingEngtangledActionScope() {
  if (
    0 === --currentEntangledPendingCount &&
    null !== currentEntangledListeners
  ) {
    null !== currentEntangledActionThenable &&
      (currentEntangledActionThenable.status = "fulfilled");
    var listeners = currentEntangledListeners;
    currentEntangledListeners = null;
    currentEntangledLane = 0;
    currentEntangledActionThenable = null;
    for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
  }
}
function chainThenableValue(thenable, result) {
  var listeners = [],
    thenableWithOverride = {
      status: "pending",
      value: null,
      reason: null,
      then: function (resolve) {
        listeners.push(resolve);
      }
    };
  thenable.then(
    function () {
      thenableWithOverride.status = "fulfilled";
      thenableWithOverride.value = result;
      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
    },
    function (error) {
      thenableWithOverride.status = "rejected";
      thenableWithOverride.reason = error;
      for (error = 0; error < listeners.length; error++)
        (0, listeners[error])(void 0);
    }
  );
  return thenableWithOverride;
}
var prevOnStartTransitionFinish = ReactSharedInternals.S;
ReactSharedInternals.S = function (transition, returnValue) {
  globalMostRecentTransitionTime = now();
  "object" === typeof returnValue &&
    null !== returnValue &&
    "function" === typeof returnValue.then &&
    entangleAsyncAction(transition, returnValue);
  null !== prevOnStartTransitionFinish &&
    prevOnStartTransitionFinish(transition, returnValue);
};
var resumedCache = createCursor(null);
function peekCacheFromPool() {
  var cacheResumedFromPreviousRender = resumedCache.current;
  return null !== cacheResumedFromPreviousRender
    ? cacheResumedFromPreviousRender
    : workInProgressRoot.pooledCache;
}
function pushTransition(offscreenWorkInProgress, prevCachePool) {
  null === prevCachePool
    ? push(resumedCache, resumedCache.current)
    : push(resumedCache, prevCachePool.pool);
}
function getSuspendedCache() {
  var cacheFromPool = peekCacheFromPool();
  return null === cacheFromPool
    ? null
    : { parent: CacheContext._currentValue, pool: cacheFromPool };
}
var SuspenseException = Error(formatProdErrorMessage(460)),
  SuspenseyCommitException = Error(formatProdErrorMessage(474)),
  SuspenseActionException = Error(formatProdErrorMessage(542)),
  noopSuspenseyCommitThenable = { then: function () {} };
function isThenableResolved(thenable) {
  thenable = thenable.status;
  return "fulfilled" === thenable || "rejected" === thenable;
}
function trackUsedThenable(thenableState, thenable, index) {
  index = thenableState[index];
  void 0 === index
    ? thenableState.push(thenable)
    : index !== thenable && (thenable.then(noop$1, noop$1), (thenable = index));
  switch (thenable.status) {
    case "fulfilled":
      return thenable.value;
    case "rejected":
      throw (
        ((thenableState = thenable.reason),
        checkIfUseWrappedInAsyncCatch(thenableState),
        thenableState)
      );
    default:
      if ("string" === typeof thenable.status) thenable.then(noop$1, noop$1);
      else {
        thenableState = workInProgressRoot;
        if (null !== thenableState && 100 < thenableState.shellSuspendCounter)
          throw Error(formatProdErrorMessage(482));
        thenableState = thenable;
        thenableState.status = "pending";
        thenableState.then(
          function (fulfilledValue) {
            if ("pending" === thenable.status) {
              var fulfilledThenable = thenable;
              fulfilledThenable.status = "fulfilled";
              fulfilledThenable.value = fulfilledValue;
            }
          },
          function (error) {
            if ("pending" === thenable.status) {
              var rejectedThenable = thenable;
              rejectedThenable.status = "rejected";
              rejectedThenable.reason = error;
            }
          }
        );
      }
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw (
            ((thenableState = thenable.reason),
            checkIfUseWrappedInAsyncCatch(thenableState),
            thenableState)
          );
      }
      suspendedThenable = thenable;
      throw SuspenseException;
  }
}
function resolveLazy(lazyType) {
  try {
    var init = lazyType._init;
    return init(lazyType._payload);
  } catch (x) {
    if (null !== x && "object" === typeof x && "function" === typeof x.then)
      throw ((suspendedThenable = x), SuspenseException);
    throw x;
  }
}
var suspendedThenable = null;
function getSuspendedThenable() {
  if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
  var thenable = suspendedThenable;
  suspendedThenable = null;
  return thenable;
}
function checkIfUseWrappedInAsyncCatch(rejectedReason) {
  if (
    rejectedReason === SuspenseException ||
    rejectedReason === SuspenseActionException
  )
    throw Error(formatProdErrorMessage(483));
}
var thenableState$1 = null,
  thenableIndexCounter$1 = 0;
function unwrapThenable(thenable) {
  var index = thenableIndexCounter$1;
  thenableIndexCounter$1 += 1;
  null === thenableState$1 && (thenableState$1 = []);
  return trackUsedThenable(thenableState$1, thenable, index);
}
function coerceRef(workInProgress, element) {
  element = element.props.ref;
  workInProgress.ref = void 0 !== element ? element : null;
}
function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
  if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
    throw Error(formatProdErrorMessage(525));
  returnFiber = Object.prototype.toString.call(newChild);
  throw Error(
    formatProdErrorMessage(
      31,
      "[object Object]" === returnFiber
        ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
        : returnFiber
    )
  );
}
function createChildReconciler(shouldTrackSideEffects) {
  function deleteChild(returnFiber, childToDelete) {
    if (shouldTrackSideEffects) {
      var deletions = returnFiber.deletions;
      null === deletions
        ? ((returnFiber.deletions = [childToDelete]), (returnFiber.flags |= 16))
        : deletions.push(childToDelete);
    }
  }
  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) return null;
    for (; null !== currentFirstChild; )
      deleteChild(returnFiber, currentFirstChild),
        (currentFirstChild = currentFirstChild.sibling);
    return null;
  }
  function mapRemainingChildren(currentFirstChild) {
    for (var existingChildren = new Map(); null !== currentFirstChild; )
      null !== currentFirstChild.key
        ? existingChildren.set(currentFirstChild.key, currentFirstChild)
        : existingChildren.set(currentFirstChild.index, currentFirstChild),
        (currentFirstChild = currentFirstChild.sibling);
    return existingChildren;
  }
  function useFiber(fiber, pendingProps) {
    fiber = createWorkInProgress(fiber, pendingProps);
    fiber.index = 0;
    fiber.sibling = null;
    return fiber;
  }
  function placeChild(newFiber, lastPlacedIndex, newIndex) {
    newFiber.index = newIndex;
    if (!shouldTrackSideEffects)
      return (newFiber.flags |= 1048576), lastPlacedIndex;
    newIndex = newFiber.alternate;
    if (null !== newIndex)
      return (
        (newIndex = newIndex.index),
        newIndex < lastPlacedIndex
          ? ((newFiber.flags |= 67108866), lastPlacedIndex)
          : newIndex
      );
    newFiber.flags |= 67108866;
    return lastPlacedIndex;
  }
  function placeSingleChild(newFiber) {
    shouldTrackSideEffects &&
      null === newFiber.alternate &&
      (newFiber.flags |= 67108866);
    return newFiber;
  }
  function updateTextNode(returnFiber, current, textContent, lanes) {
    if (null === current || 6 !== current.tag)
      return (
        (current = createFiberFromText(textContent, returnFiber.mode, lanes)),
        (current.return = returnFiber),
        current
      );
    current = useFiber(current, textContent);
    current.return = returnFiber;
    return current;
  }
  function updateElement(returnFiber, current, element, lanes) {
    var elementType = element.type;
    if (elementType === REACT_FRAGMENT_TYPE)
      return updateFragment(
        returnFiber,
        current,
        element.props.children,
        lanes,
        element.key
      );
    if (
      null !== current &&
      (current.elementType === elementType ||
        ("object" === typeof elementType &&
          null !== elementType &&
          elementType.$$typeof === REACT_LAZY_TYPE &&
          resolveLazy(elementType) === current.type))
    )
      return (
        (current = useFiber(current, element.props)),
        coerceRef(current, element),
        (current.return = returnFiber),
        current
      );
    current = createFiberFromTypeAndProps(
      element.type,
      element.key,
      element.props,
      null,
      returnFiber.mode,
      lanes
    );
    coerceRef(current, element);
    current.return = returnFiber;
    return current;
  }
  function updatePortal(returnFiber, current, portal, lanes) {
    if (
      null === current ||
      4 !== current.tag ||
      current.stateNode.containerInfo !== portal.containerInfo ||
      current.stateNode.implementation !== portal.implementation
    )
      return (
        (current = createFiberFromPortal(portal, returnFiber.mode, lanes)),
        (current.return = returnFiber),
        current
      );
    current = useFiber(current, portal.children || []);
    current.return = returnFiber;
    return current;
  }
  function updateFragment(returnFiber, current, fragment, lanes, key) {
    if (null === current || 7 !== current.tag)
      return (
        (current = createFiberFromFragment(
          fragment,
          returnFiber.mode,
          lanes,
          key
        )),
        (current.return = returnFiber),
        current
      );
    current = useFiber(current, fragment);
    current.return = returnFiber;
    return current;
  }
  function createChild(returnFiber, newChild, lanes) {
    if (
      ("string" === typeof newChild && "" !== newChild) ||
      "number" === typeof newChild ||
      "bigint" === typeof newChild
    )
      return (
        (newChild = createFiberFromText(
          "" + newChild,
          returnFiber.mode,
          lanes
        )),
        (newChild.return = returnFiber),
        newChild
      );
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return (
            (lanes = createFiberFromTypeAndProps(
              newChild.type,
              newChild.key,
              newChild.props,
              null,
              returnFiber.mode,
              lanes
            )),
            coerceRef(lanes, newChild),
            (lanes.return = returnFiber),
            lanes
          );
        case REACT_PORTAL_TYPE:
          return (
            (newChild = createFiberFromPortal(
              newChild,
              returnFiber.mode,
              lanes
            )),
            (newChild.return = returnFiber),
            newChild
          );
        case REACT_LAZY_TYPE:
          return (
            (newChild = resolveLazy(newChild)),
            createChild(returnFiber, newChild, lanes)
          );
      }
      if (isArrayImpl(newChild) || getIteratorFn(newChild))
        return (
          (newChild = createFiberFromFragment(
            newChild,
            returnFiber.mode,
            lanes,
            null
          )),
          (newChild.return = returnFiber),
          newChild
        );
      if ("function" === typeof newChild.then)
        return createChild(returnFiber, unwrapThenable(newChild), lanes);
      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
        return createChild(
          returnFiber,
          readContextDuringReconciliation(returnFiber, newChild),
          lanes
        );
      throwOnInvalidObjectTypeImpl(returnFiber, newChild);
    }
    return null;
  }
  function updateSlot(returnFiber, oldFiber, newChild, lanes) {
    var key = null !== oldFiber ? oldFiber.key : null;
    if (
      ("string" === typeof newChild && "" !== newChild) ||
      "number" === typeof newChild ||
      "bigint" === typeof newChild
    )
      return null !== key
        ? null
        : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return newChild.key === key
            ? updateElement(returnFiber, oldFiber, newChild, lanes)
            : null;
        case REACT_PORTAL_TYPE:
          return newChild.key === key
            ? updatePortal(returnFiber, oldFiber, newChild, lanes)
            : null;
        case REACT_LAZY_TYPE:
          return (
            (newChild = resolveLazy(newChild)),
            updateSlot(returnFiber, oldFiber, newChild, lanes)
          );
      }
      if (isArrayImpl(newChild) || getIteratorFn(newChild))
        return null !== key
          ? null
          : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
      if ("function" === typeof newChild.then)
        return updateSlot(
          returnFiber,
          oldFiber,
          unwrapThenable(newChild),
          lanes
        );
      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
        return updateSlot(
          returnFiber,
          oldFiber,
          readContextDuringReconciliation(returnFiber, newChild),
          lanes
        );
      throwOnInvalidObjectTypeImpl(returnFiber, newChild);
    }
    return null;
  }
  function updateFromMap(
    existingChildren,
    returnFiber,
    newIdx,
    newChild,
    lanes
  ) {
    if (
      ("string" === typeof newChild && "" !== newChild) ||
      "number" === typeof newChild ||
      "bigint" === typeof newChild
    )
      return (
        (existingChildren = existingChildren.get(newIdx) || null),
        updateTextNode(returnFiber, existingChildren, "" + newChild, lanes)
      );
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return (
            (existingChildren =
              existingChildren.get(
                null === newChild.key ? newIdx : newChild.key
              ) || null),
            updateElement(returnFiber, existingChildren, newChild, lanes)
          );
        case REACT_PORTAL_TYPE:
          return (
            (existingChildren =
              existingChildren.get(
                null === newChild.key ? newIdx : newChild.key
              ) || null),
            updatePortal(returnFiber, existingChildren, newChild, lanes)
          );
        case REACT_LAZY_TYPE:
          return (
            (newChild = resolveLazy(newChild)),
            updateFromMap(
              existingChildren,
              returnFiber,
              newIdx,
              newChild,
              lanes
            )
          );
      }
      if (isArrayImpl(newChild) || getIteratorFn(newChild))
        return (
          (existingChildren = existingChildren.get(newIdx) || null),
          updateFragment(returnFiber, existingChildren, newChild, lanes, null)
        );
      if ("function" === typeof newChild.then)
        return updateFromMap(
          existingChildren,
          returnFiber,
          newIdx,
          unwrapThenable(newChild),
          lanes
        );
      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
        return updateFromMap(
          existingChildren,
          returnFiber,
          newIdx,
          readContextDuringReconciliation(returnFiber, newChild),
          lanes
        );
      throwOnInvalidObjectTypeImpl(returnFiber, newChild);
    }
    return null;
  }
  function reconcileChildrenArray(
    returnFiber,
    currentFirstChild,
    newChildren,
    lanes
  ) {
    for (
      var resultingFirstChild = null,
        previousNewFiber = null,
        oldFiber = currentFirstChild,
        newIdx = (currentFirstChild = 0),
        nextOldFiber = null;
      null !== oldFiber && newIdx < newChildren.length;
      newIdx++
    ) {
      oldFiber.index > newIdx
        ? ((nextOldFiber = oldFiber), (oldFiber = null))
        : (nextOldFiber = oldFiber.sibling);
      var newFiber = updateSlot(
        returnFiber,
        oldFiber,
        newChildren[newIdx],
        lanes
      );
      if (null === newFiber) {
        null === oldFiber && (oldFiber = nextOldFiber);
        break;
      }
      shouldTrackSideEffects &&
        oldFiber &&
        null === newFiber.alternate &&
        deleteChild(returnFiber, oldFiber);
      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
      null === previousNewFiber
        ? (resultingFirstChild = newFiber)
        : (previousNewFiber.sibling = newFiber);
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }
    if (newIdx === newChildren.length)
      return (
        deleteRemainingChildren(returnFiber, oldFiber),
        isHydrating && pushTreeFork(returnFiber, newIdx),
        resultingFirstChild
      );
    if (null === oldFiber) {
      for (; newIdx < newChildren.length; newIdx++)
        (oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),
          null !== oldFiber &&
            ((currentFirstChild = placeChild(
              oldFiber,
              currentFirstChild,
              newIdx
            )),
            null === previousNewFiber
              ? (resultingFirstChild = oldFiber)
              : (previousNewFiber.sibling = oldFiber),
            (previousNewFiber = oldFiber));
      isHydrating && pushTreeFork(returnFiber, newIdx);
      return resultingFirstChild;
    }
    for (
      oldFiber = mapRemainingChildren(oldFiber);
      newIdx < newChildren.length;
      newIdx++
    )
      (nextOldFiber = updateFromMap(
        oldFiber,
        returnFiber,
        newIdx,
        newChildren[newIdx],
        lanes
      )),
        null !== nextOldFiber &&
          (shouldTrackSideEffects &&
            null !== nextOldFiber.alternate &&
            oldFiber.delete(
              null === nextOldFiber.key ? newIdx : nextOldFiber.key
            ),
          (currentFirstChild = placeChild(
            nextOldFiber,
            currentFirstChild,
            newIdx
          )),
          null === previousNewFiber
            ? (resultingFirstChild = nextOldFiber)
            : (previousNewFiber.sibling = nextOldFiber),
          (previousNewFiber = nextOldFiber));
    shouldTrackSideEffects &&
      oldFiber.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    isHydrating && pushTreeFork(returnFiber, newIdx);
    return resultingFirstChild;
  }
  function reconcileChildrenIterator(
    returnFiber,
    currentFirstChild,
    newChildren,
    lanes
  ) {
    if (null == newChildren) throw Error(formatProdErrorMessage(151));
    for (
      var resultingFirstChild = null,
        previousNewFiber = null,
        oldFiber = currentFirstChild,
        newIdx = (currentFirstChild = 0),
        nextOldFiber = null,
        step = newChildren.next();
      null !== oldFiber && !step.done;
      newIdx++, step = newChildren.next()
    ) {
      oldFiber.index > newIdx
        ? ((nextOldFiber = oldFiber), (oldFiber = null))
        : (nextOldFiber = oldFiber.sibling);
      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
      if (null === newFiber) {
        null === oldFiber && (oldFiber = nextOldFiber);
        break;
      }
      shouldTrackSideEffects &&
        oldFiber &&
        null === newFiber.alternate &&
        deleteChild(returnFiber, oldFiber);
      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
      null === previousNewFiber
        ? (resultingFirstChild = newFiber)
        : (previousNewFiber.sibling = newFiber);
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }
    if (step.done)
      return (
        deleteRemainingChildren(returnFiber, oldFiber),
        isHydrating && pushTreeFork(returnFiber, newIdx),
        resultingFirstChild
      );
    if (null === oldFiber) {
      for (; !step.done; newIdx++, step = newChildren.next())
        (step = createChild(returnFiber, step.value, lanes)),
          null !== step &&
            ((currentFirstChild = placeChild(step, currentFirstChild, newIdx)),
            null === previousNewFiber
              ? (resultingFirstChild = step)
              : (previousNewFiber.sibling = step),
            (previousNewFiber = step));
      isHydrating && pushTreeFork(returnFiber, newIdx);
      return resultingFirstChild;
    }
    for (
      oldFiber = mapRemainingChildren(oldFiber);
      !step.done;
      newIdx++, step = newChildren.next()
    )
      (step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes)),
        null !== step &&
          (shouldTrackSideEffects &&
            null !== step.alternate &&
            oldFiber.delete(null === step.key ? newIdx : step.key),
          (currentFirstChild = placeChild(step, currentFirstChild, newIdx)),
          null === previousNewFiber
            ? (resultingFirstChild = step)
            : (previousNewFiber.sibling = step),
          (previousNewFiber = step));
    shouldTrackSideEffects &&
      oldFiber.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    isHydrating && pushTreeFork(returnFiber, newIdx);
    return resultingFirstChild;
  }
  function reconcileChildFibersImpl(
    returnFiber,
    currentFirstChild,
    newChild,
    lanes
  ) {
    "object" === typeof newChild &&
      null !== newChild &&
      newChild.type === REACT_FRAGMENT_TYPE &&
      null === newChild.key &&
      (newChild = newChild.props.children);
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          a: {
            for (var key = newChild.key; null !== currentFirstChild; ) {
              if (currentFirstChild.key === key) {
                key = newChild.type;
                if (key === REACT_FRAGMENT_TYPE) {
                  if (7 === currentFirstChild.tag) {
                    deleteRemainingChildren(
                      returnFiber,
                      currentFirstChild.sibling
                    );
                    lanes = useFiber(
                      currentFirstChild,
                      newChild.props.children
                    );
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                    break a;
                  }
                } else if (
                  currentFirstChild.elementType === key ||
                  ("object" === typeof key &&
                    null !== key &&
                    key.$$typeof === REACT_LAZY_TYPE &&
                    resolveLazy(key) === currentFirstChild.type)
                ) {
                  deleteRemainingChildren(
                    returnFiber,
                    currentFirstChild.sibling
                  );
                  lanes = useFiber(currentFirstChild, newChild.props);
                  coerceRef(lanes, newChild);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                  break a;
                }
                deleteRemainingChildren(returnFiber, currentFirstChild);
                break;
              } else deleteChild(returnFiber, currentFirstChild);
              currentFirstChild = currentFirstChild.sibling;
            }
            newChild.type === REACT_FRAGMENT_TYPE
              ? ((lanes = createFiberFromFragment(
                  newChild.props.children,
                  returnFiber.mode,
                  lanes,
                  newChild.key
                )),
                (lanes.return = returnFiber),
                (returnFiber = lanes))
              : ((lanes = createFiberFromTypeAndProps(
                  newChild.type,
                  newChild.key,
                  newChild.props,
                  null,
                  returnFiber.mode,
                  lanes
                )),
                coerceRef(lanes, newChild),
                (lanes.return = returnFiber),
                (returnFiber = lanes));
          }
          return placeSingleChild(returnFiber);
        case REACT_PORTAL_TYPE:
          a: {
            for (key = newChild.key; null !== currentFirstChild; ) {
              if (currentFirstChild.key === key)
                if (
                  4 === currentFirstChild.tag &&
                  currentFirstChild.stateNode.containerInfo ===
                    newChild.containerInfo &&
                  currentFirstChild.stateNode.implementation ===
                    newChild.implementation
                ) {
                  deleteRemainingChildren(
                    returnFiber,
                    currentFirstChild.sibling
                  );
                  lanes = useFiber(currentFirstChild, newChild.children || []);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                  break a;
                } else {
                  deleteRemainingChildren(returnFiber, currentFirstChild);
                  break;
                }
              else deleteChild(returnFiber, currentFirstChild);
              currentFirstChild = currentFirstChild.sibling;
            }
            lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
            lanes.return = returnFiber;
            returnFiber = lanes;
          }
          return placeSingleChild(returnFiber);
        case REACT_LAZY_TYPE:
          return (
            (newChild = resolveLazy(newChild)),
            reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            )
          );
      }
      if (isArrayImpl(newChild))
        return reconcileChildrenArray(
          returnFiber,
          currentFirstChild,
          newChild,
          lanes
        );
      if (getIteratorFn(newChild)) {
        key = getIteratorFn(newChild);
        if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
        newChild = key.call(newChild);
        return reconcileChildrenIterator(
          returnFiber,
          currentFirstChild,
          newChild,
          lanes
        );
      }
      if ("function" === typeof newChild.then)
        return reconcileChildFibersImpl(
          returnFiber,
          currentFirstChild,
          unwrapThenable(newChild),
          lanes
        );
      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
        return reconcileChildFibersImpl(
          returnFiber,
          currentFirstChild,
          readContextDuringReconciliation(returnFiber, newChild),
          lanes
        );
      throwOnInvalidObjectTypeImpl(returnFiber, newChild);
    }
    return ("string" === typeof newChild && "" !== newChild) ||
      "number" === typeof newChild ||
      "bigint" === typeof newChild
      ? ((newChild = "" + newChild),
        null !== currentFirstChild && 6 === currentFirstChild.tag
          ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling),
            (lanes = useFiber(currentFirstChild, newChild)),
            (lanes.return = returnFiber),
            (returnFiber = lanes))
          : (deleteRemainingChildren(returnFiber, currentFirstChild),
            (lanes = createFiberFromText(newChild, returnFiber.mode, lanes)),
            (lanes.return = returnFiber),
            (returnFiber = lanes)),
        placeSingleChild(returnFiber))
      : deleteRemainingChildren(returnFiber, currentFirstChild);
  }
  return function (returnFiber, currentFirstChild, newChild, lanes) {
    try {
      thenableIndexCounter$1 = 0;
      var firstChildFiber = reconcileChildFibersImpl(
        returnFiber,
        currentFirstChild,
        newChild,
        lanes
      );
      thenableState$1 = null;
      return firstChildFiber;
    } catch (x) {
      if (x === SuspenseException || x === SuspenseActionException) throw x;
      var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
      fiber.lanes = lanes;
      fiber.return = returnFiber;
      return fiber;
    } finally {
    }
  };
}
var reconcileChildFibers = createChildReconciler(!0),
  mountChildFibers = createChildReconciler(!1),
  hasForceUpdate = !1;
function initializeUpdateQueue(fiber) {
  fiber.updateQueue = {
    baseState: fiber.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, lanes: 0, hiddenCallbacks: null },
    callbacks: null
  };
}
function cloneUpdateQueue(current, workInProgress) {
  current = current.updateQueue;
  workInProgress.updateQueue === current &&
    (workInProgress.updateQueue = {
      baseState: current.baseState,
      firstBaseUpdate: current.firstBaseUpdate,
      lastBaseUpdate: current.lastBaseUpdate,
      shared: current.shared,
      callbacks: null
    });
}
function createUpdate(lane) {
  return { lane: lane, tag: 0, payload: null, callback: null, next: null };
}
function enqueueUpdate(fiber, update, lane) {
  var updateQueue = fiber.updateQueue;
  if (null === updateQueue) return null;
  updateQueue = updateQueue.shared;
  if (0 !== (executionContext & 2)) {
    var pending = updateQueue.pending;
    null === pending
      ? (update.next = update)
      : ((update.next = pending.next), (pending.next = update));
    updateQueue.pending = update;
    update = getRootForUpdatedFiber(fiber);
    markUpdateLaneFromFiberToRoot(fiber, null, lane);
    return update;
  }
  enqueueUpdate$1(fiber, updateQueue, update, lane);
  return getRootForUpdatedFiber(fiber);
}
function entangleTransitions(root, fiber, lane) {
  fiber = fiber.updateQueue;
  if (null !== fiber && ((fiber = fiber.shared), 0 !== (lane & 4194048))) {
    var queueLanes = fiber.lanes;
    queueLanes &= root.pendingLanes;
    lane |= queueLanes;
    fiber.lanes = lane;
    markRootEntangled(root, lane);
  }
}
function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
  var queue = workInProgress.updateQueue,
    current = workInProgress.alternate;
  if (
    null !== current &&
    ((current = current.updateQueue), queue === current)
  ) {
    var newFirst = null,
      newLast = null;
    queue = queue.firstBaseUpdate;
    if (null !== queue) {
      do {
        var clone = {
          lane: queue.lane,
          tag: queue.tag,
          payload: queue.payload,
          callback: null,
          next: null
        };
        null === newLast
          ? (newFirst = newLast = clone)
          : (newLast = newLast.next = clone);
        queue = queue.next;
      } while (null !== queue);
      null === newLast
        ? (newFirst = newLast = capturedUpdate)
        : (newLast = newLast.next = capturedUpdate);
    } else newFirst = newLast = capturedUpdate;
    queue = {
      baseState: current.baseState,
      firstBaseUpdate: newFirst,
      lastBaseUpdate: newLast,
      shared: current.shared,
      callbacks: current.callbacks
    };
    workInProgress.updateQueue = queue;
    return;
  }
  workInProgress = queue.lastBaseUpdate;
  null === workInProgress
    ? (queue.firstBaseUpdate = capturedUpdate)
    : (workInProgress.next = capturedUpdate);
  queue.lastBaseUpdate = capturedUpdate;
}
var didReadFromEntangledAsyncAction = !1;
function suspendIfUpdateReadFromEntangledAsyncAction() {
  if (didReadFromEntangledAsyncAction) {
    var entangledActionThenable = currentEntangledActionThenable;
    if (null !== entangledActionThenable) throw entangledActionThenable;
  }
}
function processUpdateQueue(
  workInProgress$jscomp$0,
  props,
  instance$jscomp$0,
  renderLanes
) {
  didReadFromEntangledAsyncAction = !1;
  var queue = workInProgress$jscomp$0.updateQueue;
  hasForceUpdate = !1;
  var firstBaseUpdate = queue.firstBaseUpdate,
    lastBaseUpdate = queue.lastBaseUpdate,
    pendingQueue = queue.shared.pending;
  if (null !== pendingQueue) {
    queue.shared.pending = null;
    var lastPendingUpdate = pendingQueue,
      firstPendingUpdate = lastPendingUpdate.next;
    lastPendingUpdate.next = null;
    null === lastBaseUpdate
      ? (firstBaseUpdate = firstPendingUpdate)
      : (lastBaseUpdate.next = firstPendingUpdate);
    lastBaseUpdate = lastPendingUpdate;
    var current = workInProgress$jscomp$0.alternate;
    null !== current &&
      ((current = current.updateQueue),
      (pendingQueue = current.lastBaseUpdate),
      pendingQueue !== lastBaseUpdate &&
        (null === pendingQueue
          ? (current.firstBaseUpdate = firstPendingUpdate)
          : (pendingQueue.next = firstPendingUpdate),
        (current.lastBaseUpdate = lastPendingUpdate)));
  }
  if (null !== firstBaseUpdate) {
    var newState = queue.baseState;
    lastBaseUpdate = 0;
    current = firstPendingUpdate = lastPendingUpdate = null;
    pendingQueue = firstBaseUpdate;
    do {
      var updateLane = pendingQueue.lane & -536870913,
        isHiddenUpdate = updateLane !== pendingQueue.lane;
      if (
        isHiddenUpdate
          ? (workInProgressRootRenderLanes & updateLane) === updateLane
          : (renderLanes & updateLane) === updateLane
      ) {
        0 !== updateLane &&
          updateLane === currentEntangledLane &&
          (didReadFromEntangledAsyncAction = !0);
        null !== current &&
          (current = current.next =
            {
              lane: 0,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: null,
              next: null
            });
        a: {
          var workInProgress = workInProgress$jscomp$0,
            update = pendingQueue;
          updateLane = props;
          var instance = instance$jscomp$0;
          switch (update.tag) {
            case 1:
              workInProgress = update.payload;
              if ("function" === typeof workInProgress) {
                newState = workInProgress.call(instance, newState, updateLane);
                break a;
              }
              newState = workInProgress;
              break a;
            case 3:
              workInProgress.flags = (workInProgress.flags & -65537) | 128;
            case 0:
              workInProgress = update.payload;
              updateLane =
                "function" === typeof workInProgress
                  ? workInProgress.call(instance, newState, updateLane)
                  : workInProgress;
              if (null === updateLane || void 0 === updateLane) break a;
              newState = assign({}, newState, updateLane);
              break a;
            case 2:
              hasForceUpdate = !0;
          }
        }
        updateLane = pendingQueue.callback;
        null !== updateLane &&
          ((workInProgress$jscomp$0.flags |= 64),
          isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192),
          (isHiddenUpdate = queue.callbacks),
          null === isHiddenUpdate
            ? (queue.callbacks = [updateLane])
            : isHiddenUpdate.push(updateLane));
      } else
        (isHiddenUpdate = {
          lane: updateLane,
          tag: pendingQueue.tag,
          payload: pendingQueue.payload,
          callback: pendingQueue.callback,
          next: null
        }),
          null === current
            ? ((firstPendingUpdate = current = isHiddenUpdate),
              (lastPendingUpdate = newState))
            : (current = current.next = isHiddenUpdate),
          (lastBaseUpdate |= updateLane);
      pendingQueue = pendingQueue.next;
      if (null === pendingQueue)
        if (((pendingQueue = queue.shared.pending), null === pendingQueue))
          break;
        else
          (isHiddenUpdate = pendingQueue),
            (pendingQueue = isHiddenUpdate.next),
            (isHiddenUpdate.next = null),
            (queue.lastBaseUpdate = isHiddenUpdate),
            (queue.shared.pending = null);
    } while (1);
    null === current && (lastPendingUpdate = newState);
    queue.baseState = lastPendingUpdate;
    queue.firstBaseUpdate = firstPendingUpdate;
    queue.lastBaseUpdate = current;
    null === firstBaseUpdate && (queue.shared.lanes = 0);
    workInProgressRootSkippedLanes |= lastBaseUpdate;
    workInProgress$jscomp$0.lanes = lastBaseUpdate;
    workInProgress$jscomp$0.memoizedState = newState;
  }
}
function callCallback(callback, context) {
  if ("function" !== typeof callback)
    throw Error(formatProdErrorMessage(191, callback));
  callback.call(context);
}
function commitCallbacks(updateQueue, context) {
  var callbacks = updateQueue.callbacks;
  if (null !== callbacks)
    for (
      updateQueue.callbacks = null, updateQueue = 0;
      updateQueue < callbacks.length;
      updateQueue++
    )
      callCallback(callbacks[updateQueue], context);
}
var currentTreeHiddenStackCursor = createCursor(null),
  prevEntangledRenderLanesCursor = createCursor(0);
function pushHiddenContext(fiber, context) {
  fiber = entangledRenderLanes;
  push(prevEntangledRenderLanesCursor, fiber);
  push(currentTreeHiddenStackCursor, context);
  entangledRenderLanes = fiber | context.baseLanes;
}
function reuseHiddenContextOnStack() {
  push(prevEntangledRenderLanesCursor, entangledRenderLanes);
  push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
}
function popHiddenContext() {
  entangledRenderLanes = prevEntangledRenderLanesCursor.current;
  pop(currentTreeHiddenStackCursor);
  pop(prevEntangledRenderLanesCursor);
}
var suspenseHandlerStackCursor = createCursor(null),
  shellBoundary = null;
function pushPrimaryTreeSuspenseHandler(handler) {
  var current = handler.alternate;
  push(suspenseStackCursor, suspenseStackCursor.current & 1);
  push(suspenseHandlerStackCursor, handler);
  null === shellBoundary &&
    (null === current || null !== currentTreeHiddenStackCursor.current
      ? (shellBoundary = handler)
      : null !== current.memoizedState && (shellBoundary = handler));
}
function pushDehydratedActivitySuspenseHandler(fiber) {
  push(suspenseStackCursor, suspenseStackCursor.current);
  push(suspenseHandlerStackCursor, fiber);
  null === shellBoundary && (shellBoundary = fiber);
}
function pushOffscreenSuspenseHandler(fiber) {
  22 === fiber.tag
    ? (push(suspenseStackCursor, suspenseStackCursor.current),
      push(suspenseHandlerStackCursor, fiber),
      null === shellBoundary && (shellBoundary = fiber))
    : reuseSuspenseHandlerOnStack(fiber);
}
function reuseSuspenseHandlerOnStack() {
  push(suspenseStackCursor, suspenseStackCursor.current);
  push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
}
function popSuspenseHandler(fiber) {
  pop(suspenseHandlerStackCursor);
  shellBoundary === fiber && (shellBoundary = null);
  pop(suspenseStackCursor);
}
var suspenseStackCursor = createCursor(0);
function findFirstSuspended(row) {
  for (var node = row; null !== node; ) {
    if (13 === node.tag) {
      var state = node.memoizedState;
      if (
        null !== state &&
        ((state = state.dehydrated),
        null === state ||
          isSuspenseInstancePending(state) ||
          isSuspenseInstanceFallback(state))
      )
        return node;
    } else if (
      19 === node.tag &&
      ("forwards" === node.memoizedProps.revealOrder ||
        "backwards" === node.memoizedProps.revealOrder ||
        "unstable_legacy-backwards" === node.memoizedProps.revealOrder ||
        "together" === node.memoizedProps.revealOrder)
    ) {
      if (0 !== (node.flags & 128)) return node;
    } else if (null !== node.child) {
      node.child.return = node;
      node = node.child;
      continue;
    }
    if (node === row) break;
    for (; null === node.sibling; ) {
      if (null === node.return || node.return === row) return null;
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
  return null;
}
var renderLanes = 0,
  currentlyRenderingFiber = null,
  currentHook = null,
  workInProgressHook = null,
  didScheduleRenderPhaseUpdate = !1,
  didScheduleRenderPhaseUpdateDuringThisPass = !1,
  shouldDoubleInvokeUserFnsInHooksDEV = !1,
  localIdCounter = 0,
  thenableIndexCounter = 0,
  thenableState = null,
  globalClientIdCounter = 0;
function throwInvalidHookError() {
  throw Error(formatProdErrorMessage(321));
}
function areHookInputsEqual(nextDeps, prevDeps) {
  if (null === prevDeps) return !1;
  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
    if (!objectIs(nextDeps[i], prevDeps[i])) return !1;
  return !0;
}
function renderWithHooks(
  current,
  workInProgress,
  Component,
  props,
  secondArg,
  nextRenderLanes
) {
  renderLanes = nextRenderLanes;
  currentlyRenderingFiber = workInProgress;
  workInProgress.memoizedState = null;
  workInProgress.updateQueue = null;
  workInProgress.lanes = 0;
  ReactSharedInternals.H =
    null === current || null === current.memoizedState
      ? HooksDispatcherOnMount
      : HooksDispatcherOnUpdate;
  shouldDoubleInvokeUserFnsInHooksDEV = !1;
  nextRenderLanes = Component(props, secondArg);
  shouldDoubleInvokeUserFnsInHooksDEV = !1;
  didScheduleRenderPhaseUpdateDuringThisPass &&
    (nextRenderLanes = renderWithHooksAgain(
      workInProgress,
      Component,
      props,
      secondArg
    ));
  finishRenderingHooks(current);
  return nextRenderLanes;
}
function finishRenderingHooks(current) {
  ReactSharedInternals.H = ContextOnlyDispatcher;
  var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
  renderLanes = 0;
  workInProgressHook = currentHook = currentlyRenderingFiber = null;
  didScheduleRenderPhaseUpdate = !1;
  thenableIndexCounter = 0;
  thenableState = null;
  if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
  null === current ||
    didReceiveUpdate ||
    ((current = current.dependencies),
    null !== current &&
      checkIfContextChanged(current) &&
      (didReceiveUpdate = !0));
}
function renderWithHooksAgain(workInProgress, Component, props, secondArg) {
  currentlyRenderingFiber = workInProgress;
  var numberOfReRenders = 0;
  do {
    didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
    thenableIndexCounter = 0;
    didScheduleRenderPhaseUpdateDuringThisPass = !1;
    if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
    numberOfReRenders += 1;
    workInProgressHook = currentHook = null;
    if (null != workInProgress.updateQueue) {
      var children = workInProgress.updateQueue;
      children.lastEffect = null;
      children.events = null;
      children.stores = null;
      null != children.memoCache && (children.memoCache.index = 0);
    }
    ReactSharedInternals.H = HooksDispatcherOnRerender;
    children = Component(props, secondArg);
  } while (didScheduleRenderPhaseUpdateDuringThisPass);
  return children;
}
function TransitionAwareHostComponent() {
  var dispatcher = ReactSharedInternals.H,
    maybeThenable = dispatcher.useState()[0];
  maybeThenable =
    "function" === typeof maybeThenable.then
      ? useThenable(maybeThenable)
      : maybeThenable;
  dispatcher = dispatcher.useState()[0];
  (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher &&
    (currentlyRenderingFiber.flags |= 1024);
  return maybeThenable;
}
function checkDidRenderIdHook() {
  var didRenderIdHook = 0 !== localIdCounter;
  localIdCounter = 0;
  return didRenderIdHook;
}
function bailoutHooks(current, workInProgress, lanes) {
  workInProgress.updateQueue = current.updateQueue;
  workInProgress.flags &= -2053;
  current.lanes &= ~lanes;
}
function resetHooksOnUnwind(workInProgress) {
  if (didScheduleRenderPhaseUpdate) {
    for (
      workInProgress = workInProgress.memoizedState;
      null !== workInProgress;

    ) {
      var queue = workInProgress.queue;
      null !== queue && (queue.pending = null);
      workInProgress = workInProgress.next;
    }
    didScheduleRenderPhaseUpdate = !1;
  }
  renderLanes = 0;
  workInProgressHook = currentHook = currentlyRenderingFiber = null;
  didScheduleRenderPhaseUpdateDuringThisPass = !1;
  thenableIndexCounter = localIdCounter = 0;
  thenableState = null;
}
function mountWorkInProgressHook() {
  var hook = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null
  };
  null === workInProgressHook
    ? (currentlyRenderingFiber.memoizedState = workInProgressHook = hook)
    : (workInProgressHook = workInProgressHook.next = hook);
  return workInProgressHook;
}
function updateWorkInProgressHook() {
  if (null === currentHook) {
    var nextCurrentHook = currentlyRenderingFiber.alternate;
    nextCurrentHook =
      null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
  } else nextCurrentHook = currentHook.next;
  var nextWorkInProgressHook =
    null === workInProgressHook
      ? currentlyRenderingFiber.memoizedState
      : workInProgressHook.next;
  if (null !== nextWorkInProgressHook)
    (workInProgressHook = nextWorkInProgressHook),
      (currentHook = nextCurrentHook);
  else {
    if (null === nextCurrentHook) {
      if (null === currentlyRenderingFiber.alternate)
        throw Error(formatProdErrorMessage(467));
      throw Error(formatProdErrorMessage(310));
    }
    currentHook = nextCurrentHook;
    nextCurrentHook = {
      memoizedState: currentHook.memoizedState,
      baseState: currentHook.baseState,
      baseQueue: currentHook.baseQueue,
      queue: currentHook.queue,
      next: null
    };
    null === workInProgressHook
      ? (currentlyRenderingFiber.memoizedState = workInProgressHook =
          nextCurrentHook)
      : (workInProgressHook = workInProgressHook.next = nextCurrentHook);
  }
  return workInProgressHook;
}
function createFunctionComponentUpdateQueue() {
  return { lastEffect: null, events: null, stores: null, memoCache: null };
}
function useThenable(thenable) {
  var index = thenableIndexCounter;
  thenableIndexCounter += 1;
  null === thenableState && (thenableState = []);
  thenable = trackUsedThenable(thenableState, thenable, index);
  index = currentlyRenderingFiber;
  null ===
    (null === workInProgressHook
      ? index.memoizedState
      : workInProgressHook.next) &&
    ((index = index.alternate),
    (ReactSharedInternals.H =
      null === index || null === index.memoizedState
        ? HooksDispatcherOnMount
        : HooksDispatcherOnUpdate));
  return thenable;
}
function use(usable) {
  if (null !== usable && "object" === typeof usable) {
    if ("function" === typeof usable.then) return useThenable(usable);
    if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
  }
  throw Error(formatProdErrorMessage(438, String(usable)));
}
function useMemoCache(size) {
  var memoCache = null,
    updateQueue = currentlyRenderingFiber.updateQueue;
  null !== updateQueue && (memoCache = updateQueue.memoCache);
  if (null == memoCache) {
    var current = currentlyRenderingFiber.alternate;
    null !== current &&
      ((current = current.updateQueue),
      null !== current &&
        ((current = current.memoCache),
        null != current &&
          (memoCache = {
            data: current.data.map(function (array) {
              return array.slice();
            }),
            index: 0
          })));
  }
  null == memoCache && (memoCache = { data: [], index: 0 });
  null === updateQueue &&
    ((updateQueue = createFunctionComponentUpdateQueue()),
    (currentlyRenderingFiber.updateQueue = updateQueue));
  updateQueue.memoCache = memoCache;
  updateQueue = memoCache.data[memoCache.index];
  if (void 0 === updateQueue)
    for (
      updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0;
      current < size;
      current++
    )
      updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
  memoCache.index++;
  return updateQueue;
}
function basicStateReducer(state, action) {
  return "function" === typeof action ? action(state) : action;
}
function updateReducer(reducer) {
  var hook = updateWorkInProgressHook();
  return updateReducerImpl(hook, currentHook, reducer);
}
function updateReducerImpl(hook, current, reducer) {
  var queue = hook.queue;
  if (null === queue) throw Error(formatProdErrorMessage(311));
  queue.lastRenderedReducer = reducer;
  var baseQueue = hook.baseQueue,
    pendingQueue = queue.pending;
  if (null !== pendingQueue) {
    if (null !== baseQueue) {
      var baseFirst = baseQueue.next;
      baseQueue.next = pendingQueue.next;
      pendingQueue.next = baseFirst;
    }
    current.baseQueue = baseQueue = pendingQueue;
    queue.pending = null;
  }
  pendingQueue = hook.baseState;
  if (null === baseQueue) hook.memoizedState = pendingQueue;
  else {
    current = baseQueue.next;
    var newBaseQueueFirst = (baseFirst = null),
      newBaseQueueLast = null,
      update = current,
      didReadFromEntangledAsyncAction$60 = !1;
    do {
      var updateLane = update.lane & -536870913;
      if (
        updateLane !== update.lane
          ? (workInProgressRootRenderLanes & updateLane) === updateLane
          : (renderLanes & updateLane) === updateLane
      ) {
        var revertLane = update.revertLane;
        if (0 === revertLane)
          null !== newBaseQueueLast &&
            (newBaseQueueLast = newBaseQueueLast.next =
              {
                lane: 0,
                revertLane: 0,
                gesture: null,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }),
            updateLane === currentEntangledLane &&
              (didReadFromEntangledAsyncAction$60 = !0);
        else if ((renderLanes & revertLane) === revertLane) {
          update = update.next;
          revertLane === currentEntangledLane &&
            (didReadFromEntangledAsyncAction$60 = !0);
          continue;
        } else
          (updateLane = {
            lane: 0,
            revertLane: update.revertLane,
            gesture: null,
            action: update.action,
            hasEagerState: update.hasEagerState,
            eagerState: update.eagerState,
            next: null
          }),
            null === newBaseQueueLast
              ? ((newBaseQueueFirst = newBaseQueueLast = updateLane),
                (baseFirst = pendingQueue))
              : (newBaseQueueLast = newBaseQueueLast.next = updateLane),
            (currentlyRenderingFiber.lanes |= revertLane),
            (workInProgressRootSkippedLanes |= revertLane);
        updateLane = update.action;
        shouldDoubleInvokeUserFnsInHooksDEV &&
          reducer(pendingQueue, updateLane);
        pendingQueue = update.hasEagerState
          ? update.eagerState
          : reducer(pendingQueue, updateLane);
      } else
        (revertLane = {
          lane: updateLane,
          revertLane: update.revertLane,
          gesture: update.gesture,
          action: update.action,
          hasEagerState: update.hasEagerState,
          eagerState: update.eagerState,
          next: null
        }),
          null === newBaseQueueLast
            ? ((newBaseQueueFirst = newBaseQueueLast = revertLane),
              (baseFirst = pendingQueue))
            : (newBaseQueueLast = newBaseQueueLast.next = revertLane),
          (currentlyRenderingFiber.lanes |= updateLane),
          (workInProgressRootSkippedLanes |= updateLane);
      update = update.next;
    } while (null !== update && update !== current);
    null === newBaseQueueLast
      ? (baseFirst = pendingQueue)
      : (newBaseQueueLast.next = newBaseQueueFirst);
    if (
      !objectIs(pendingQueue, hook.memoizedState) &&
      ((didReceiveUpdate = !0),
      didReadFromEntangledAsyncAction$60 &&
        ((reducer = currentEntangledActionThenable), null !== reducer))
    )
      throw reducer;
    hook.memoizedState = pendingQueue;
    hook.baseState = baseFirst;
    hook.baseQueue = newBaseQueueLast;
    queue.lastRenderedState = pendingQueue;
  }
  null === baseQueue && (queue.lanes = 0);
  return [hook.memoizedState, queue.dispatch];
}
function rerenderReducer(reducer) {
  var hook = updateWorkInProgressHook(),
    queue = hook.queue;
  if (null === queue) throw Error(formatProdErrorMessage(311));
  queue.lastRenderedReducer = reducer;
  var dispatch = queue.dispatch,
    lastRenderPhaseUpdate = queue.pending,
    newState = hook.memoizedState;
  if (null !== lastRenderPhaseUpdate) {
    queue.pending = null;
    var update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);
    do (newState = reducer(newState, update.action)), (update = update.next);
    while (update !== lastRenderPhaseUpdate);
    objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);
    hook.memoizedState = newState;
    null === hook.baseQueue && (hook.baseState = newState);
    queue.lastRenderedState = newState;
  }
  return [newState, dispatch];
}
function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
  var fiber = currentlyRenderingFiber,
    hook = updateWorkInProgressHook(),
    isHydrating$jscomp$0 = isHydrating;
  if (isHydrating$jscomp$0) {
    if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
    getServerSnapshot = getServerSnapshot();
  } else getServerSnapshot = getSnapshot();
  var snapshotChanged = !objectIs(
    (currentHook || hook).memoizedState,
    getServerSnapshot
  );
  snapshotChanged &&
    ((hook.memoizedState = getServerSnapshot), (didReceiveUpdate = !0));
  hook = hook.queue;
  updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe), [
    subscribe
  ]);
  if (
    hook.getSnapshot !== getSnapshot ||
    snapshotChanged ||
    (null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1)
  ) {
    fiber.flags |= 2048;
    pushSimpleEffect(
      9,
      { destroy: void 0 },
      updateStoreInstance.bind(
        null,
        fiber,
        hook,
        getServerSnapshot,
        getSnapshot
      ),
      null
    );
    if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
    isHydrating$jscomp$0 ||
      0 !== (renderLanes & 127) ||
      pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
  }
  return getServerSnapshot;
}
function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
  fiber.flags |= 16384;
  fiber = { getSnapshot: getSnapshot, value: renderedSnapshot };
  getSnapshot = currentlyRenderingFiber.updateQueue;
  null === getSnapshot
    ? ((getSnapshot = createFunctionComponentUpdateQueue()),
      (currentlyRenderingFiber.updateQueue = getSnapshot),
      (getSnapshot.stores = [fiber]))
    : ((renderedSnapshot = getSnapshot.stores),
      null === renderedSnapshot
        ? (getSnapshot.stores = [fiber])
        : renderedSnapshot.push(fiber));
}
function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
  inst.value = nextSnapshot;
  inst.getSnapshot = getSnapshot;
  checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
}
function subscribeToStore(fiber, inst, subscribe) {
  return subscribe(function () {
    checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
  });
}
function checkIfSnapshotChanged(inst) {
  var latestGetSnapshot = inst.getSnapshot;
  inst = inst.value;
  try {
    var nextValue = latestGetSnapshot();
    return !objectIs(inst, nextValue);
  } catch (error) {
    return !0;
  }
}
function forceStoreRerender(fiber) {
  var root = enqueueConcurrentRenderForLane(fiber, 2);
  null !== root && scheduleUpdateOnFiber(root, fiber, 2);
}
function mountStateImpl(initialState) {
  var hook = mountWorkInProgressHook();
  if ("function" === typeof initialState) {
    var initialStateInitializer = initialState;
    initialState = initialStateInitializer();
    if (shouldDoubleInvokeUserFnsInHooksDEV) {
      setIsStrictModeForDevtools(!0);
      try {
        initialStateInitializer();
      } finally {
        setIsStrictModeForDevtools(!1);
      }
    }
  }
  hook.memoizedState = hook.baseState = initialState;
  hook.queue = {
    pending: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState
  };
  return hook;
}
function updateOptimisticImpl(hook, current, passthrough, reducer) {
  hook.baseState = passthrough;
  return updateReducerImpl(
    hook,
    currentHook,
    "function" === typeof reducer ? reducer : basicStateReducer
  );
}
function dispatchActionState(
  fiber,
  actionQueue,
  setPendingState,
  setState,
  payload
) {
  if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
  fiber = actionQueue.action;
  if (null !== fiber) {
    var actionNode = {
      payload: payload,
      action: fiber,
      next: null,
      isTransition: !0,
      status: "pending",
      value: null,
      reason: null,
      listeners: [],
      then: function (listener) {
        actionNode.listeners.push(listener);
      }
    };
    null !== ReactSharedInternals.T
      ? setPendingState(!0)
      : (actionNode.isTransition = !1);
    setState(actionNode);
    setPendingState = actionQueue.pending;
    null === setPendingState
      ? ((actionNode.next = actionQueue.pending = actionNode),
        runActionStateAction(actionQueue, actionNode))
      : ((actionNode.next = setPendingState.next),
        (actionQueue.pending = setPendingState.next = actionNode));
  }
}
function runActionStateAction(actionQueue, node) {
  var action = node.action,
    payload = node.payload,
    prevState = actionQueue.state;
  if (node.isTransition) {
    var prevTransition = ReactSharedInternals.T,
      currentTransition = {};
    ReactSharedInternals.T = currentTransition;
    try {
      var returnValue = action(prevState, payload),
        onStartTransitionFinish = ReactSharedInternals.S;
      null !== onStartTransitionFinish &&
        onStartTransitionFinish(currentTransition, returnValue);
      handleActionReturnValue(actionQueue, node, returnValue);
    } catch (error) {
      onActionError(actionQueue, node, error);
    } finally {
      null !== prevTransition &&
        null !== currentTransition.types &&
        (prevTransition.types = currentTransition.types),
        (ReactSharedInternals.T = prevTransition);
    }
  } else
    try {
      (prevTransition = action(prevState, payload)),
        handleActionReturnValue(actionQueue, node, prevTransition);
    } catch (error$66) {
      onActionError(actionQueue, node, error$66);
    }
}
function handleActionReturnValue(actionQueue, node, returnValue) {
  null !== returnValue &&
  "object" === typeof returnValue &&
  "function" === typeof returnValue.then
    ? returnValue.then(
        function (nextState) {
          onActionSuccess(actionQueue, node, nextState);
        },
        function (error) {
          return onActionError(actionQueue, node, error);
        }
      )
    : onActionSuccess(actionQueue, node, returnValue);
}
function onActionSuccess(actionQueue, actionNode, nextState) {
  actionNode.status = "fulfilled";
  actionNode.value = nextState;
  notifyActionListeners(actionNode);
  actionQueue.state = nextState;
  actionNode = actionQueue.pending;
  null !== actionNode &&
    ((nextState = actionNode.next),
    nextState === actionNode
      ? (actionQueue.pending = null)
      : ((nextState = nextState.next),
        (actionNode.next = nextState),
        runActionStateAction(actionQueue, nextState)));
}
function onActionError(actionQueue, actionNode, error) {
  var last = actionQueue.pending;
  actionQueue.pending = null;
  if (null !== last) {
    last = last.next;
    do
      (actionNode.status = "rejected"),
        (actionNode.reason = error),
        notifyActionListeners(actionNode),
        (actionNode = actionNode.next);
    while (actionNode !== last);
  }
  actionQueue.action = null;
}
function notifyActionListeners(actionNode) {
  actionNode = actionNode.listeners;
  for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
}
function actionStateReducer(oldState, newState) {
  return newState;
}
function mountActionState(action, initialStateProp) {
  if (isHydrating) {
    var ssrFormState = workInProgressRoot.formState;
    if (null !== ssrFormState) {
      a: {
        var JSCompiler_inline_result = currentlyRenderingFiber;
        if (isHydrating) {
          if (nextHydratableInstance) {
            b: {
              var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
              for (
                var inRootOrSingleton = rootOrSingletonContext;
                8 !== JSCompiler_inline_result$jscomp$0.nodeType;

              ) {
                if (!inRootOrSingleton) {
                  JSCompiler_inline_result$jscomp$0 = null;
                  break b;
                }
                JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                  JSCompiler_inline_result$jscomp$0.nextSibling
                );
                if (null === JSCompiler_inline_result$jscomp$0) {
                  JSCompiler_inline_result$jscomp$0 = null;
                  break b;
                }
              }
              inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
              JSCompiler_inline_result$jscomp$0 =
                "F!" === inRootOrSingleton || "F" === inRootOrSingleton
                  ? JSCompiler_inline_result$jscomp$0
                  : null;
            }
            if (JSCompiler_inline_result$jscomp$0) {
              nextHydratableInstance = getNextHydratable(
                JSCompiler_inline_result$jscomp$0.nextSibling
              );
              JSCompiler_inline_result =
                "F!" === JSCompiler_inline_result$jscomp$0.data;
              break a;
            }
          }
          throwOnHydrationMismatch(JSCompiler_inline_result);
        }
        JSCompiler_inline_result = !1;
      }
      JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
    }
  }
  ssrFormState = mountWorkInProgressHook();
  ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
  JSCompiler_inline_result = {
    pending: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: actionStateReducer,
    lastRenderedState: initialStateProp
  };
  ssrFormState.queue = JSCompiler_inline_result;
  ssrFormState = dispatchSetState.bind(
    null,
    currentlyRenderingFiber,
    JSCompiler_inline_result
  );
  JSCompiler_inline_result.dispatch = ssrFormState;
  JSCompiler_inline_result = mountStateImpl(!1);
  inRootOrSingleton = dispatchOptimisticSetState.bind(
    null,
    currentlyRenderingFiber,
    !1,
    JSCompiler_inline_result.queue
  );
  JSCompiler_inline_result = mountWorkInProgressHook();
  JSCompiler_inline_result$jscomp$0 = {
    state: initialStateProp,
    dispatch: null,
    action: action,
    pending: null
  };
  JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
  ssrFormState = dispatchActionState.bind(
    null,
    currentlyRenderingFiber,
    JSCompiler_inline_result$jscomp$0,
    inRootOrSingleton,
    ssrFormState
  );
  JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
  JSCompiler_inline_result.memoizedState = action;
  return [initialStateProp, ssrFormState, !1];
}
function updateActionState(action) {
  var stateHook = updateWorkInProgressHook();
  return updateActionStateImpl(stateHook, currentHook, action);
}
function updateActionStateImpl(stateHook, currentStateHook, action) {
  currentStateHook = updateReducerImpl(
    stateHook,
    currentStateHook,
    actionStateReducer
  )[0];
  stateHook = updateReducer(basicStateReducer)[0];
  if (
    "object" === typeof currentStateHook &&
    null !== currentStateHook &&
    "function" === typeof currentStateHook.then
  )
    try {
      var state = useThenable(currentStateHook);
    } catch (x) {
      if (x === SuspenseException) throw SuspenseActionException;
      throw x;
    }
  else state = currentStateHook;
  currentStateHook = updateWorkInProgressHook();
  var actionQueue = currentStateHook.queue,
    dispatch = actionQueue.dispatch;
  action !== currentStateHook.memoizedState &&
    ((currentlyRenderingFiber.flags |= 2048),
    pushSimpleEffect(
      9,
      { destroy: void 0 },
      actionStateActionEffect.bind(null, actionQueue, action),
      null
    ));
  return [state, dispatch, stateHook];
}
function actionStateActionEffect(actionQueue, action) {
  actionQueue.action = action;
}
function rerenderActionState(action) {
  var stateHook = updateWorkInProgressHook(),
    currentStateHook = currentHook;
  if (null !== currentStateHook)
    return updateActionStateImpl(stateHook, currentStateHook, action);
  updateWorkInProgressHook();
  stateHook = stateHook.memoizedState;
  currentStateHook = updateWorkInProgressHook();
  var dispatch = currentStateHook.queue.dispatch;
  currentStateHook.memoizedState = action;
  return [stateHook, dispatch, !1];
}
function pushSimpleEffect(tag, inst, create, deps) {
  tag = { tag: tag, create: create, deps: deps, inst: inst, next: null };
  inst = currentlyRenderingFiber.updateQueue;
  null === inst &&
    ((inst = createFunctionComponentUpdateQueue()),
    (currentlyRenderingFiber.updateQueue = inst));
  create = inst.lastEffect;
  null === create
    ? (inst.lastEffect = tag.next = tag)
    : ((deps = create.next),
      (create.next = tag),
      (tag.next = deps),
      (inst.lastEffect = tag));
  return tag;
}
function updateRef() {
  return updateWorkInProgressHook().memoizedState;
}
function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  var hook = mountWorkInProgressHook();
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushSimpleEffect(
    1 | hookFlags,
    { destroy: void 0 },
    create,
    void 0 === deps ? null : deps
  );
}
function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  var hook = updateWorkInProgressHook();
  deps = void 0 === deps ? null : deps;
  var inst = hook.memoizedState.inst;
  null !== currentHook &&
  null !== deps &&
  areHookInputsEqual(deps, currentHook.memoizedState.deps)
    ? (hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps))
    : ((currentlyRenderingFiber.flags |= fiberFlags),
      (hook.memoizedState = pushSimpleEffect(
        1 | hookFlags,
        inst,
        create,
        deps
      )));
}
function mountEffect(create, deps) {
  mountEffectImpl(8390656, 8, create, deps);
}
function updateEffect(create, deps) {
  updateEffectImpl(2048, 8, create, deps);
}
function useEffectEventImpl(payload) {
  currentlyRenderingFiber.flags |= 4;
  var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
  if (null === componentUpdateQueue)
    (componentUpdateQueue = createFunctionComponentUpdateQueue()),
      (currentlyRenderingFiber.updateQueue = componentUpdateQueue),
      (componentUpdateQueue.events = [payload]);
  else {
    var events = componentUpdateQueue.events;
    null === events
      ? (componentUpdateQueue.events = [payload])
      : events.push(payload);
  }
}
function updateEvent(callback) {
  var ref = updateWorkInProgressHook().memoizedState;
  useEffectEventImpl({ ref: ref, nextImpl: callback });
  return function () {
    if (0 !== (executionContext & 2)) throw Error(formatProdErrorMessage(440));
    return ref.impl.apply(void 0, arguments);
  };
}
function updateInsertionEffect(create, deps) {
  return updateEffectImpl(4, 2, create, deps);
}
function updateLayoutEffect(create, deps) {
  return updateEffectImpl(4, 4, create, deps);
}
function imperativeHandleEffect(create, ref) {
  if ("function" === typeof ref) {
    create = create();
    var refCleanup = ref(create);
    return function () {
      "function" === typeof refCleanup ? refCleanup() : ref(null);
    };
  }
  if (null !== ref && void 0 !== ref)
    return (
      (create = create()),
      (ref.current = create),
      function () {
        ref.current = null;
      }
    );
}
function updateImperativeHandle(ref, create, deps) {
  deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
  updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
}
function mountDebugValue() {}
function updateCallback(callback, deps) {
  var hook = updateWorkInProgressHook();
  deps = void 0 === deps ? null : deps;
  var prevState = hook.memoizedState;
  if (null !== deps && areHookInputsEqual(deps, prevState[1]))
    return prevState[0];
  hook.memoizedState = [callback, deps];
  return callback;
}
function updateMemo(nextCreate, deps) {
  var hook = updateWorkInProgressHook();
  deps = void 0 === deps ? null : deps;
  var prevState = hook.memoizedState;
  if (null !== deps && areHookInputsEqual(deps, prevState[1]))
    return prevState[0];
  prevState = nextCreate();
  if (shouldDoubleInvokeUserFnsInHooksDEV) {
    setIsStrictModeForDevtools(!0);
    try {
      nextCreate();
    } finally {
      setIsStrictModeForDevtools(!1);
    }
  }
  hook.memoizedState = [prevState, deps];
  return prevState;
}
function mountDeferredValueImpl(hook, value, initialValue) {
  if (
    void 0 === initialValue ||
    (0 !== (renderLanes & 1073741824) &&
      0 === (workInProgressRootRenderLanes & 261930))
  )
    return (hook.memoizedState = value);
  hook.memoizedState = initialValue;
  hook = requestDeferredLane();
  currentlyRenderingFiber.lanes |= hook;
  workInProgressRootSkippedLanes |= hook;
  return initialValue;
}
function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
  if (objectIs(value, prevValue)) return value;
  if (null !== currentTreeHiddenStackCursor.current)
    return (
      (hook = mountDeferredValueImpl(hook, value, initialValue)),
      objectIs(hook, prevValue) || (didReceiveUpdate = !0),
      hook
    );
  if (
    0 === (renderLanes & 42) ||
    (0 !== (renderLanes & 1073741824) &&
      0 === (workInProgressRootRenderLanes & 261930))
  )
    return (didReceiveUpdate = !0), (hook.memoizedState = value);
  hook = requestDeferredLane();
  currentlyRenderingFiber.lanes |= hook;
  workInProgressRootSkippedLanes |= hook;
  return prevValue;
}
function startTransition(fiber, queue, pendingState, finishedState, callback) {
  var previousPriority = ReactDOMSharedInternals.p;
  ReactDOMSharedInternals.p =
    0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
  var prevTransition = ReactSharedInternals.T,
    currentTransition = {};
  ReactSharedInternals.T = currentTransition;
  dispatchOptimisticSetState(fiber, !1, queue, pendingState);
  try {
    var returnValue = callback(),
      onStartTransitionFinish = ReactSharedInternals.S;
    null !== onStartTransitionFinish &&
      onStartTransitionFinish(currentTransition, returnValue);
    if (
      null !== returnValue &&
      "object" === typeof returnValue &&
      "function" === typeof returnValue.then
    ) {
      var thenableForFinishedState = chainThenableValue(
        returnValue,
        finishedState
      );
      dispatchSetStateInternal(
        fiber,
        queue,
        thenableForFinishedState,
        requestUpdateLane(fiber)
      );
    } else
      dispatchSetStateInternal(
        fiber,
        queue,
        finishedState,
        requestUpdateLane(fiber)
      );
  } catch (error) {
    dispatchSetStateInternal(
      fiber,
      queue,
      { then: function () {}, status: "rejected", reason: error },
      requestUpdateLane()
    );
  } finally {
    (ReactDOMSharedInternals.p = previousPriority),
      null !== prevTransition &&
        null !== currentTransition.types &&
        (prevTransition.types = currentTransition.types),
      (ReactSharedInternals.T = prevTransition);
  }
}
function noop() {}
function startHostTransition(formFiber, pendingState, action, formData) {
  if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
  var queue = ensureFormComponentIsStateful(formFiber).queue;
  startTransition(
    formFiber,
    queue,
    pendingState,
    sharedNotPendingObject,
    null === action
      ? noop
      : function () {
          requestFormReset$1(formFiber);
          return action(formData);
        }
  );
}
function ensureFormComponentIsStateful(formFiber) {
  var existingStateHook = formFiber.memoizedState;
  if (null !== existingStateHook) return existingStateHook;
  existingStateHook = {
    memoizedState: sharedNotPendingObject,
    baseState: sharedNotPendingObject,
    baseQueue: null,
    queue: {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: sharedNotPendingObject
    },
    next: null
  };
  var initialResetState = {};
  existingStateHook.next = {
    memoizedState: initialResetState,
    baseState: initialResetState,
    baseQueue: null,
    queue: {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: initialResetState
    },
    next: null
  };
  formFiber.memoizedState = existingStateHook;
  formFiber = formFiber.alternate;
  null !== formFiber && (formFiber.memoizedState = existingStateHook);
  return existingStateHook;
}
function requestFormReset$1(formFiber) {
  var stateHook = ensureFormComponentIsStateful(formFiber);
  null === stateHook.next && (stateHook = formFiber.alternate.memoizedState);
  dispatchSetStateInternal(
    formFiber,
    stateHook.next.queue,
    {},
    requestUpdateLane()
  );
}
function useHostTransitionStatus() {
  return readContext(HostTransitionContext);
}
function updateId() {
  return updateWorkInProgressHook().memoizedState;
}
function updateRefresh() {
  return updateWorkInProgressHook().memoizedState;
}
function refreshCache(fiber) {
  for (var provider = fiber.return; null !== provider; ) {
    switch (provider.tag) {
      case 24:
      case 3:
        var lane = requestUpdateLane();
        fiber = createUpdate(lane);
        var root$69 = enqueueUpdate(provider, fiber, lane);
        null !== root$69 &&
          (scheduleUpdateOnFiber(root$69, provider, lane),
          entangleTransitions(root$69, provider, lane));
        provider = { cache: createCache() };
        fiber.payload = provider;
        return;
    }
    provider = provider.return;
  }
}
function dispatchReducerAction(fiber, queue, action) {
  var lane = requestUpdateLane();
  action = {
    lane: lane,
    revertLane: 0,
    gesture: null,
    action: action,
    hasEagerState: !1,
    eagerState: null,
    next: null
  };
  isRenderPhaseUpdate(fiber)
    ? enqueueRenderPhaseUpdate(queue, action)
    : ((action = enqueueConcurrentHookUpdate(fiber, queue, action, lane)),
      null !== action &&
        (scheduleUpdateOnFiber(action, fiber, lane),
        entangleTransitionUpdate(action, queue, lane)));
}
function dispatchSetState(fiber, queue, action) {
  var lane = requestUpdateLane();
  dispatchSetStateInternal(fiber, queue, action, lane);
}
function dispatchSetStateInternal(fiber, queue, action, lane) {
  var update = {
    lane: lane,
    revertLane: 0,
    gesture: null,
    action: action,
    hasEagerState: !1,
    eagerState: null,
    next: null
  };
  if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
  else {
    var alternate = fiber.alternate;
    if (
      0 === fiber.lanes &&
      (null === alternate || 0 === alternate.lanes) &&
      ((alternate = queue.lastRenderedReducer), null !== alternate)
    )
      try {
        var currentState = queue.lastRenderedState,
          eagerState = alternate(currentState, action);
        update.hasEagerState = !0;
        update.eagerState = eagerState;
        if (objectIs(eagerState, currentState))
          return (
            enqueueUpdate$1(fiber, queue, update, 0),
            null === workInProgressRoot && finishQueueingConcurrentUpdates(),
            !1
          );
      } catch (error) {
      } finally {
      }
    action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
    if (null !== action)
      return (
        scheduleUpdateOnFiber(action, fiber, lane),
        entangleTransitionUpdate(action, queue, lane),
        !0
      );
  }
  return !1;
}
function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
  action = {
    lane: 2,
    revertLane: requestTransitionLane(),
    gesture: null,
    action: action,
    hasEagerState: !1,
    eagerState: null,
    next: null
  };
  if (isRenderPhaseUpdate(fiber)) {
    if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
  } else
    (throwIfDuringRender = enqueueConcurrentHookUpdate(
      fiber,
      queue,
      action,
      2
    )),
      null !== throwIfDuringRender &&
        scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
}
function isRenderPhaseUpdate(fiber) {
  var alternate = fiber.alternate;
  return (
    fiber === currentlyRenderingFiber ||
    (null !== alternate && alternate === currentlyRenderingFiber)
  );
}
function enqueueRenderPhaseUpdate(queue, update) {
  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate =
    !0;
  var pending = queue.pending;
  null === pending
    ? (update.next = update)
    : ((update.next = pending.next), (pending.next = update));
  queue.pending = update;
}
function entangleTransitionUpdate(root, queue, lane) {
  if (0 !== (lane & 4194048)) {
    var queueLanes = queue.lanes;
    queueLanes &= root.pendingLanes;
    lane |= queueLanes;
    queue.lanes = lane;
    markRootEntangled(root, lane);
  }
}
var ContextOnlyDispatcher = {
  readContext: readContext,
  use: use,
  useCallback: throwInvalidHookError,
  useContext: throwInvalidHookError,
  useEffect: throwInvalidHookError,
  useImperativeHandle: throwInvalidHookError,
  useLayoutEffect: throwInvalidHookError,
  useInsertionEffect: throwInvalidHookError,
  useMemo: throwInvalidHookError,
  useReducer: throwInvalidHookError,
  useRef: throwInvalidHookError,
  useState: throwInvalidHookError,
  useDebugValue: throwInvalidHookError,
  useDeferredValue: throwInvalidHookError,
  useTransition: throwInvalidHookError,
  useSyncExternalStore: throwInvalidHookError,
  useId: throwInvalidHookError,
  useHostTransitionStatus: throwInvalidHookError,
  useFormState: throwInvalidHookError,
  useActionState: throwInvalidHookError,
  useOptimistic: throwInvalidHookError,
  useMemoCache: throwInvalidHookError,
  useCacheRefresh: throwInvalidHookError
};
ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
var HooksDispatcherOnMount = {
    readContext: readContext,
    use: use,
    useCallback: function (callback, deps) {
      mountWorkInProgressHook().memoizedState = [
        callback,
        void 0 === deps ? null : deps
      ];
      return callback;
    },
    useContext: readContext,
    useEffect: mountEffect,
    useImperativeHandle: function (ref, create, deps) {
      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
      mountEffectImpl(
        4194308,
        4,
        imperativeHandleEffect.bind(null, create, ref),
        deps
      );
    },
    useLayoutEffect: function (create, deps) {
      return mountEffectImpl(4194308, 4, create, deps);
    },
    useInsertionEffect: function (create, deps) {
      mountEffectImpl(4, 2, create, deps);
    },
    useMemo: function (nextCreate, deps) {
      var hook = mountWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var nextValue = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(!0);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
      hook.memoizedState = [nextValue, deps];
      return nextValue;
    },
    useReducer: function (reducer, initialArg, init) {
      var hook = mountWorkInProgressHook();
      if (void 0 !== init) {
        var initialState = init(initialArg);
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(!0);
          try {
            init(initialArg);
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
      } else initialState = initialArg;
      hook.memoizedState = hook.baseState = initialState;
      reducer = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: reducer,
        lastRenderedState: initialState
      };
      hook.queue = reducer;
      reducer = reducer.dispatch = dispatchReducerAction.bind(
        null,
        currentlyRenderingFiber,
        reducer
      );
      return [hook.memoizedState, reducer];
    },
    useRef: function (initialValue) {
      var hook = mountWorkInProgressHook();
      initialValue = { current: initialValue };
      return (hook.memoizedState = initialValue);
    },
    useState: function (initialState) {
      initialState = mountStateImpl(initialState);
      var queue = initialState.queue,
        dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
      queue.dispatch = dispatch;
      return [initialState.memoizedState, dispatch];
    },
    useDebugValue: mountDebugValue,
    useDeferredValue: function (value, initialValue) {
      var hook = mountWorkInProgressHook();
      return mountDeferredValueImpl(hook, value, initialValue);
    },
    useTransition: function () {
      var stateHook = mountStateImpl(!1);
      stateHook = startTransition.bind(
        null,
        currentlyRenderingFiber,
        stateHook.queue,
        !0,
        !1
      );
      mountWorkInProgressHook().memoizedState = stateHook;
      return [!1, stateHook];
    },
    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber,
        hook = mountWorkInProgressHook();
      if (isHydrating) {
        if (void 0 === getServerSnapshot)
          throw Error(formatProdErrorMessage(407));
        getServerSnapshot = getServerSnapshot();
      } else {
        getServerSnapshot = getSnapshot();
        if (null === workInProgressRoot)
          throw Error(formatProdErrorMessage(349));
        0 !== (workInProgressRootRenderLanes & 127) ||
          pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
      }
      hook.memoizedState = getServerSnapshot;
      var inst = { value: getServerSnapshot, getSnapshot: getSnapshot };
      hook.queue = inst;
      mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
        subscribe
      ]);
      fiber.flags |= 2048;
      pushSimpleEffect(
        9,
        { destroy: void 0 },
        updateStoreInstance.bind(
          null,
          fiber,
          inst,
          getServerSnapshot,
          getSnapshot
        ),
        null
      );
      return getServerSnapshot;
    },
    useId: function () {
      var hook = mountWorkInProgressHook(),
        identifierPrefix = workInProgressRoot.identifierPrefix;
      if (isHydrating) {
        var JSCompiler_inline_result = treeContextOverflow;
        var idWithLeadingBit = treeContextId;
        JSCompiler_inline_result =
          (
            idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))
          ).toString(32) + JSCompiler_inline_result;
        identifierPrefix =
          "_" + identifierPrefix + "R_" + JSCompiler_inline_result;
        JSCompiler_inline_result = localIdCounter++;
        0 < JSCompiler_inline_result &&
          (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
        identifierPrefix += "_";
      } else
        (JSCompiler_inline_result = globalClientIdCounter++),
          (identifierPrefix =
            "_" +
            identifierPrefix +
            "r_" +
            JSCompiler_inline_result.toString(32) +
            "_");
      return (hook.memoizedState = identifierPrefix);
    },
    useHostTransitionStatus: useHostTransitionStatus,
    useFormState: mountActionState,
    useActionState: mountActionState,
    useOptimistic: function (passthrough) {
      var hook = mountWorkInProgressHook();
      hook.memoizedState = hook.baseState = passthrough;
      var queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      hook.queue = queue;
      hook = dispatchOptimisticSetState.bind(
        null,
        currentlyRenderingFiber,
        !0,
        queue
      );
      queue.dispatch = hook;
      return [passthrough, hook];
    },
    useMemoCache: useMemoCache,
    useCacheRefresh: function () {
      return (mountWorkInProgressHook().memoizedState = refreshCache.bind(
        null,
        currentlyRenderingFiber
      ));
    },
    useEffectEvent: function (callback) {
      var hook = mountWorkInProgressHook(),
        ref = { impl: callback };
      hook.memoizedState = ref;
      return function () {
        if (0 !== (executionContext & 2))
          throw Error(formatProdErrorMessage(440));
        return ref.impl.apply(void 0, arguments);
      };
    }
  },
  HooksDispatcherOnUpdate = {
    readContext: readContext,
    use: use,
    useCallback: updateCallback,
    useContext: readContext,
    useEffect: updateEffect,
    useImperativeHandle: updateImperativeHandle,
    useInsertionEffect: updateInsertionEffect,
    useLayoutEffect: updateLayoutEffect,
    useMemo: updateMemo,
    useReducer: updateReducer,
    useRef: updateRef,
    useState: function () {
      return updateReducer(basicStateReducer);
    },
    useDebugValue: mountDebugValue,
    useDeferredValue: function (value, initialValue) {
      var hook = updateWorkInProgressHook();
      return updateDeferredValueImpl(
        hook,
        currentHook.memoizedState,
        value,
        initialValue
      );
    },
    useTransition: function () {
      var booleanOrThenable = updateReducer(basicStateReducer)[0],
        start = updateWorkInProgressHook().memoizedState;
      return [
        "boolean" === typeof booleanOrThenable
          ? booleanOrThenable
          : useThenable(booleanOrThenable),
        start
      ];
    },
    useSyncExternalStore: updateSyncExternalStore,
    useId: updateId,
    useHostTransitionStatus: useHostTransitionStatus,
    useFormState: updateActionState,
    useActionState: updateActionState,
    useOptimistic: function (passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
    },
    useMemoCache: useMemoCache,
    useCacheRefresh: updateRefresh
  };
HooksDispatcherOnUpdate.useEffectEvent = updateEvent;
var HooksDispatcherOnRerender = {
  readContext: readContext,
  use: use,
  useCallback: updateCallback,
  useContext: readContext,
  useEffect: updateEffect,
  useImperativeHandle: updateImperativeHandle,
  useInsertionEffect: updateInsertionEffect,
  useLayoutEffect: updateLayoutEffect,
  useMemo: updateMemo,
  useReducer: rerenderReducer,
  useRef: updateRef,
  useState: function () {
    return rerenderReducer(basicStateReducer);
  },
  useDebugValue: mountDebugValue,
  useDeferredValue: function (value, initialValue) {
    var hook = updateWorkInProgressHook();
    return null === currentHook
      ? mountDeferredValueImpl(hook, value, initialValue)
      : updateDeferredValueImpl(
          hook,
          currentHook.memoizedState,
          value,
          initialValue
        );
  },
  useTransition: function () {
    var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
      start = updateWorkInProgressHook().memoizedState;
    return [
      "boolean" === typeof booleanOrThenable
        ? booleanOrThenable
        : useThenable(booleanOrThenable),
      start
    ];
  },
  useSyncExternalStore: updateSyncExternalStore,
  useId: updateId,
  useHostTransitionStatus: useHostTransitionStatus,
  useFormState: rerenderActionState,
  useActionState: rerenderActionState,
  useOptimistic: function (passthrough, reducer) {
    var hook = updateWorkInProgressHook();
    if (null !== currentHook)
      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
    hook.baseState = passthrough;
    return [passthrough, hook.queue.dispatch];
  },
  useMemoCache: useMemoCache,
  useCacheRefresh: updateRefresh
};
HooksDispatcherOnRerender.useEffectEvent = updateEvent;
function applyDerivedStateFromProps(
  workInProgress,
  ctor,
  getDerivedStateFromProps,
  nextProps
) {
  ctor = workInProgress.memoizedState;
  getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
  getDerivedStateFromProps =
    null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps
      ? ctor
      : assign({}, ctor, getDerivedStateFromProps);
  workInProgress.memoizedState = getDerivedStateFromProps;
  0 === workInProgress.lanes &&
    (workInProgress.updateQueue.baseState = getDerivedStateFromProps);
}
var classComponentUpdater = {
  enqueueSetState: function (inst, payload, callback) {
    inst = inst._reactInternals;
    var lane = requestUpdateLane(),
      update = createUpdate(lane);
    update.payload = payload;
    void 0 !== callback && null !== callback && (update.callback = callback);
    payload = enqueueUpdate(inst, update, lane);
    null !== payload &&
      (scheduleUpdateOnFiber(payload, inst, lane),
      entangleTransitions(payload, inst, lane));
  },
  enqueueReplaceState: function (inst, payload, callback) {
    inst = inst._reactInternals;
    var lane = requestUpdateLane(),
      update = createUpdate(lane);
    update.tag = 1;
    update.payload = payload;
    void 0 !== callback && null !== callback && (update.callback = callback);
    payload = enqueueUpdate(inst, update, lane);
    null !== payload &&
      (scheduleUpdateOnFiber(payload, inst, lane),
      entangleTransitions(payload, inst, lane));
  },
  enqueueForceUpdate: function (inst, callback) {
    inst = inst._reactInternals;
    var lane = requestUpdateLane(),
      update = createUpdate(lane);
    update.tag = 2;
    void 0 !== callback && null !== callback && (update.callback = callback);
    callback = enqueueUpdate(inst, update, lane);
    null !== callback &&
      (scheduleUpdateOnFiber(callback, inst, lane),
      entangleTransitions(callback, inst, lane));
  }
};
function checkShouldComponentUpdate(
  workInProgress,
  ctor,
  oldProps,
  newProps,
  oldState,
  newState,
  nextContext
) {
  workInProgress = workInProgress.stateNode;
  return "function" === typeof workInProgress.shouldComponentUpdate
    ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext)
    : ctor.prototype && ctor.prototype.isPureReactComponent
      ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
      : !0;
}
function callComponentWillReceiveProps(
  workInProgress,
  instance,
  newProps,
  nextContext
) {
  workInProgress = instance.state;
  "function" === typeof instance.componentWillReceiveProps &&
    instance.componentWillReceiveProps(newProps, nextContext);
  "function" === typeof instance.UNSAFE_componentWillReceiveProps &&
    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
  instance.state !== workInProgress &&
    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
}
function resolveClassComponentProps(Component, baseProps) {
  var newProps = baseProps;
  if ("ref" in baseProps) {
    newProps = {};
    for (var propName in baseProps)
      "ref" !== propName && (newProps[propName] = baseProps[propName]);
  }
  if ((Component = Component.defaultProps)) {
    newProps === baseProps && (newProps = assign({}, newProps));
    for (var propName$73 in Component)
      void 0 === newProps[propName$73] &&
        (newProps[propName$73] = Component[propName$73]);
  }
  return newProps;
}
function defaultOnUncaughtError(error) {
  reportGlobalError(error);
}
function defaultOnCaughtError(error) {
  console.error(error);
}
function defaultOnRecoverableError(error) {
  reportGlobalError(error);
}
function logUncaughtError(root, errorInfo) {
  try {
    var onUncaughtError = root.onUncaughtError;
    onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
  } catch (e$74) {
    setTimeout(function () {
      throw e$74;
    });
  }
}
function logCaughtError(root, boundary, errorInfo) {
  try {
    var onCaughtError = root.onCaughtError;
    onCaughtError(errorInfo.value, {
      componentStack: errorInfo.stack,
      errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
    });
  } catch (e$75) {
    setTimeout(function () {
      throw e$75;
    });
  }
}
function createRootErrorUpdate(root, errorInfo, lane) {
  lane = createUpdate(lane);
  lane.tag = 3;
  lane.payload = { element: null };
  lane.callback = function () {
    logUncaughtError(root, errorInfo);
  };
  return lane;
}
function createClassErrorUpdate(lane) {
  lane = createUpdate(lane);
  lane.tag = 3;
  return lane;
}
function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
  if ("function" === typeof getDerivedStateFromError) {
    var error = errorInfo.value;
    update.payload = function () {
      return getDerivedStateFromError(error);
    };
    update.callback = function () {
      logCaughtError(root, fiber, errorInfo);
    };
  }
  var inst = fiber.stateNode;
  null !== inst &&
    "function" === typeof inst.componentDidCatch &&
    (update.callback = function () {
      logCaughtError(root, fiber, errorInfo);
      "function" !== typeof getDerivedStateFromError &&
        (null === legacyErrorBoundariesThatAlreadyFailed
          ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))
          : legacyErrorBoundariesThatAlreadyFailed.add(this));
      var stack = errorInfo.stack;
      this.componentDidCatch(errorInfo.value, {
        componentStack: null !== stack ? stack : ""
      });
    });
}
function throwException(
  root,
  returnFiber,
  sourceFiber,
  value,
  rootRenderLanes
) {
  sourceFiber.flags |= 32768;
  if (
    null !== value &&
    "object" === typeof value &&
    "function" === typeof value.then
  ) {
    returnFiber = sourceFiber.alternate;
    null !== returnFiber &&
      propagateParentContextChanges(
        returnFiber,
        sourceFiber,
        rootRenderLanes,
        !0
      );
    sourceFiber = suspenseHandlerStackCursor.current;
    if (null !== sourceFiber) {
      switch (sourceFiber.tag) {
        case 31:
        case 13:
          return (
            null === shellBoundary
              ? renderDidSuspendDelayIfPossible()
              : null === sourceFiber.alternate &&
                0 === workInProgressRootExitStatus &&
                (workInProgressRootExitStatus = 3),
            (sourceFiber.flags &= -257),
            (sourceFiber.flags |= 65536),
            (sourceFiber.lanes = rootRenderLanes),
            value === noopSuspenseyCommitThenable
              ? (sourceFiber.flags |= 16384)
              : ((returnFiber = sourceFiber.updateQueue),
                null === returnFiber
                  ? (sourceFiber.updateQueue = new Set([value]))
                  : returnFiber.add(value),
                attachPingListener(root, value, rootRenderLanes)),
            !1
          );
        case 22:
          return (
            (sourceFiber.flags |= 65536),
            value === noopSuspenseyCommitThenable
              ? (sourceFiber.flags |= 16384)
              : ((returnFiber = sourceFiber.updateQueue),
                null === returnFiber
                  ? ((returnFiber = {
                      transitions: null,
                      markerInstances: null,
                      retryQueue: new Set([value])
                    }),
                    (sourceFiber.updateQueue = returnFiber))
                  : ((sourceFiber = returnFiber.retryQueue),
                    null === sourceFiber
                      ? (returnFiber.retryQueue = new Set([value]))
                      : sourceFiber.add(value)),
                attachPingListener(root, value, rootRenderLanes)),
            !1
          );
      }
      throw Error(formatProdErrorMessage(435, sourceFiber.tag));
    }
    attachPingListener(root, value, rootRenderLanes);
    renderDidSuspendDelayIfPossible();
    return !1;
  }
  if (isHydrating)
    return (
      (returnFiber = suspenseHandlerStackCursor.current),
      null !== returnFiber
        ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256),
          (returnFiber.flags |= 65536),
          (returnFiber.lanes = rootRenderLanes),
          value !== HydrationMismatchException &&
            ((root = Error(formatProdErrorMessage(422), { cause: value })),
            queueHydrationError(createCapturedValueAtFiber(root, sourceFiber))))
        : (value !== HydrationMismatchException &&
            ((returnFiber = Error(formatProdErrorMessage(423), {
              cause: value
            })),
            queueHydrationError(
              createCapturedValueAtFiber(returnFiber, sourceFiber)
            )),
          (root = root.current.alternate),
          (root.flags |= 65536),
          (rootRenderLanes &= -rootRenderLanes),
          (root.lanes |= rootRenderLanes),
          (value = createCapturedValueAtFiber(value, sourceFiber)),
          (rootRenderLanes = createRootErrorUpdate(
            root.stateNode,
            value,
            rootRenderLanes
          )),
          enqueueCapturedUpdate(root, rootRenderLanes),
          4 !== workInProgressRootExitStatus &&
            (workInProgressRootExitStatus = 2)),
      !1
    );
  var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
  wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
  null === workInProgressRootConcurrentErrors
    ? (workInProgressRootConcurrentErrors = [wrapperError])
    : workInProgressRootConcurrentErrors.push(wrapperError);
  4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
  if (null === returnFiber) return !0;
  value = createCapturedValueAtFiber(value, sourceFiber);
  sourceFiber = returnFiber;
  do {
    switch (sourceFiber.tag) {
      case 3:
        return (
          (sourceFiber.flags |= 65536),
          (root = rootRenderLanes & -rootRenderLanes),
          (sourceFiber.lanes |= root),
          (root = createRootErrorUpdate(sourceFiber.stateNode, value, root)),
          enqueueCapturedUpdate(sourceFiber, root),
          !1
        );
      case 1:
        if (
          ((returnFiber = sourceFiber.type),
          (wrapperError = sourceFiber.stateNode),
          0 === (sourceFiber.flags & 128) &&
            ("function" === typeof returnFiber.getDerivedStateFromError ||
              (null !== wrapperError &&
                "function" === typeof wrapperError.componentDidCatch &&
                (null === legacyErrorBoundariesThatAlreadyFailed ||
                  !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError)))))
        )
          return (
            (sourceFiber.flags |= 65536),
            (rootRenderLanes &= -rootRenderLanes),
            (sourceFiber.lanes |= rootRenderLanes),
            (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),
            initializeClassErrorUpdate(
              rootRenderLanes,
              root,
              sourceFiber,
              value
            ),
            enqueueCapturedUpdate(sourceFiber, rootRenderLanes),
            !1
          );
    }
    sourceFiber = sourceFiber.return;
  } while (null !== sourceFiber);
  return !1;
}
var SelectiveHydrationException = Error(formatProdErrorMessage(461)),
  didReceiveUpdate = !1;
function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
  workInProgress.child =
    null === current
      ? mountChildFibers(workInProgress, null, nextChildren, renderLanes)
      : reconcileChildFibers(
          workInProgress,
          current.child,
          nextChildren,
          renderLanes
        );
}
function updateForwardRef(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  Component = Component.render;
  var ref = workInProgress.ref;
  if ("ref" in nextProps) {
    var propsWithoutRef = {};
    for (var key in nextProps)
      "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
  } else propsWithoutRef = nextProps;
  prepareToReadContext(workInProgress);
  nextProps = renderWithHooks(
    current,
    workInProgress,
    Component,
    propsWithoutRef,
    ref,
    renderLanes
  );
  key = checkDidRenderIdHook();
  if (null !== current && !didReceiveUpdate)
    return (
      bailoutHooks(current, workInProgress, renderLanes),
      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
    );
  isHydrating && key && pushMaterializedTreeId(workInProgress);
  workInProgress.flags |= 1;
  reconcileChildren(current, workInProgress, nextProps, renderLanes);
  return workInProgress.child;
}
function updateMemoComponent(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  if (null === current) {
    var type = Component.type;
    if (
      "function" === typeof type &&
      !shouldConstruct(type) &&
      void 0 === type.defaultProps &&
      null === Component.compare
    )
      return (
        (workInProgress.tag = 15),
        (workInProgress.type = type),
        updateSimpleMemoComponent(
          current,
          workInProgress,
          type,
          nextProps,
          renderLanes
        )
      );
    current = createFiberFromTypeAndProps(
      Component.type,
      null,
      nextProps,
      workInProgress,
      workInProgress.mode,
      renderLanes
    );
    current.ref = workInProgress.ref;
    current.return = workInProgress;
    return (workInProgress.child = current);
  }
  type = current.child;
  if (!checkScheduledUpdateOrContext(current, renderLanes)) {
    var prevProps = type.memoizedProps;
    Component = Component.compare;
    Component = null !== Component ? Component : shallowEqual;
    if (Component(prevProps, nextProps) && current.ref === workInProgress.ref)
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }
  workInProgress.flags |= 1;
  current = createWorkInProgress(type, nextProps);
  current.ref = workInProgress.ref;
  current.return = workInProgress;
  return (workInProgress.child = current);
}
function updateSimpleMemoComponent(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  if (null !== current) {
    var prevProps = current.memoizedProps;
    if (
      shallowEqual(prevProps, nextProps) &&
      current.ref === workInProgress.ref
    )
      if (
        ((didReceiveUpdate = !1),
        (workInProgress.pendingProps = nextProps = prevProps),
        checkScheduledUpdateOrContext(current, renderLanes))
      )
        0 !== (current.flags & 131072) && (didReceiveUpdate = !0);
      else
        return (
          (workInProgress.lanes = current.lanes),
          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
        );
  }
  return updateFunctionComponent(
    current,
    workInProgress,
    Component,
    nextProps,
    renderLanes
  );
}
function updateOffscreenComponent(
  current,
  workInProgress,
  renderLanes,
  nextProps
) {
  var nextChildren = nextProps.children,
    prevState = null !== current ? current.memoizedState : null;
  null === current &&
    null === workInProgress.stateNode &&
    (workInProgress.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    });
  if ("hidden" === nextProps.mode) {
    if (0 !== (workInProgress.flags & 128)) {
      prevState =
        null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;
      if (null !== current) {
        nextProps = workInProgress.child = current.child;
        for (nextChildren = 0; null !== nextProps; )
          (nextChildren =
            nextChildren | nextProps.lanes | nextProps.childLanes),
            (nextProps = nextProps.sibling);
        nextProps = nextChildren & ~prevState;
      } else (nextProps = 0), (workInProgress.child = null);
      return deferHiddenOffscreenComponent(
        current,
        workInProgress,
        prevState,
        renderLanes,
        nextProps
      );
    }
    if (0 !== (renderLanes & 536870912))
      (workInProgress.memoizedState = { baseLanes: 0, cachePool: null }),
        null !== current &&
          pushTransition(
            workInProgress,
            null !== prevState ? prevState.cachePool : null
          ),
        null !== prevState
          ? pushHiddenContext(workInProgress, prevState)
          : reuseHiddenContextOnStack(),
        pushOffscreenSuspenseHandler(workInProgress);
    else
      return (
        (nextProps = workInProgress.lanes = 536870912),
        deferHiddenOffscreenComponent(
          current,
          workInProgress,
          null !== prevState ? prevState.baseLanes | renderLanes : renderLanes,
          renderLanes,
          nextProps
        )
      );
  } else
    null !== prevState
      ? (pushTransition(workInProgress, prevState.cachePool),
        pushHiddenContext(workInProgress, prevState),
        reuseSuspenseHandlerOnStack(workInProgress),
        (workInProgress.memoizedState = null))
      : (null !== current && pushTransition(workInProgress, null),
        reuseHiddenContextOnStack(),
        reuseSuspenseHandlerOnStack(workInProgress));
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}
function bailoutOffscreenComponent(current, workInProgress) {
  (null !== current && 22 === current.tag) ||
    null !== workInProgress.stateNode ||
    (workInProgress.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    });
  return workInProgress.sibling;
}
function deferHiddenOffscreenComponent(
  current,
  workInProgress,
  nextBaseLanes,
  renderLanes,
  remainingChildLanes
) {
  var JSCompiler_inline_result = peekCacheFromPool();
  JSCompiler_inline_result =
    null === JSCompiler_inline_result
      ? null
      : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
  workInProgress.memoizedState = {
    baseLanes: nextBaseLanes,
    cachePool: JSCompiler_inline_result
  };
  null !== current && pushTransition(workInProgress, null);
  reuseHiddenContextOnStack();
  pushOffscreenSuspenseHandler(workInProgress);
  null !== current &&
    propagateParentContextChanges(current, workInProgress, renderLanes, !0);
  workInProgress.childLanes = remainingChildLanes;
  return null;
}
function mountActivityChildren(workInProgress, nextProps) {
  nextProps = mountWorkInProgressOffscreenFiber(
    { mode: nextProps.mode, children: nextProps.children },
    workInProgress.mode
  );
  nextProps.ref = workInProgress.ref;
  workInProgress.child = nextProps;
  nextProps.return = workInProgress;
  return nextProps;
}
function retryActivityComponentWithoutHydrating(
  current,
  workInProgress,
  renderLanes
) {
  reconcileChildFibers(workInProgress, current.child, null, renderLanes);
  current = mountActivityChildren(workInProgress, workInProgress.pendingProps);
  current.flags |= 2;
  popSuspenseHandler(workInProgress);
  workInProgress.memoizedState = null;
  return current;
}
function updateActivityComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps,
    didSuspend = 0 !== (workInProgress.flags & 128);
  workInProgress.flags &= -129;
  if (null === current) {
    if (isHydrating) {
      if ("hidden" === nextProps.mode)
        return (
          (current = mountActivityChildren(workInProgress, nextProps)),
          (workInProgress.lanes = 536870912),
          bailoutOffscreenComponent(null, current)
        );
      pushDehydratedActivitySuspenseHandler(workInProgress);
      (current = nextHydratableInstance)
        ? ((current = canHydrateHydrationBoundary(
            current,
            rootOrSingletonContext
          )),
          (current = null !== current && "&" === current.data ? current : null),
          null !== current &&
            ((workInProgress.memoizedState = {
              dehydrated: current,
              treeContext:
                null !== treeContextProvider
                  ? { id: treeContextId, overflow: treeContextOverflow }
                  : null,
              retryLane: 536870912,
              hydrationErrors: null
            }),
            (renderLanes = createFiberFromDehydratedFragment(current)),
            (renderLanes.return = workInProgress),
            (workInProgress.child = renderLanes),
            (hydrationParentFiber = workInProgress),
            (nextHydratableInstance = null)))
        : (current = null);
      if (null === current) throw throwOnHydrationMismatch(workInProgress);
      workInProgress.lanes = 536870912;
      return null;
    }
    return mountActivityChildren(workInProgress, nextProps);
  }
  var prevState = current.memoizedState;
  if (null !== prevState) {
    var dehydrated = prevState.dehydrated;
    pushDehydratedActivitySuspenseHandler(workInProgress);
    if (didSuspend)
      if (workInProgress.flags & 256)
        (workInProgress.flags &= -257),
          (workInProgress = retryActivityComponentWithoutHydrating(
            current,
            workInProgress,
            renderLanes
          ));
      else if (null !== workInProgress.memoizedState)
        (workInProgress.child = current.child),
          (workInProgress.flags |= 128),
          (workInProgress = null);
      else throw Error(formatProdErrorMessage(558));
    else if (
      (didReceiveUpdate ||
        propagateParentContextChanges(current, workInProgress, renderLanes, !1),
      (didSuspend = 0 !== (renderLanes & current.childLanes)),
      didReceiveUpdate || didSuspend)
    ) {
      nextProps = workInProgressRoot;
      if (
        null !== nextProps &&
        ((dehydrated = getBumpedLaneForHydration(nextProps, renderLanes)),
        0 !== dehydrated && dehydrated !== prevState.retryLane)
      )
        throw (
          ((prevState.retryLane = dehydrated),
          enqueueConcurrentRenderForLane(current, dehydrated),
          scheduleUpdateOnFiber(nextProps, current, dehydrated),
          SelectiveHydrationException)
        );
      renderDidSuspendDelayIfPossible();
      workInProgress = retryActivityComponentWithoutHydrating(
        current,
        workInProgress,
        renderLanes
      );
    } else
      (current = prevState.treeContext),
        (nextHydratableInstance = getNextHydratable(dehydrated.nextSibling)),
        (hydrationParentFiber = workInProgress),
        (isHydrating = !0),
        (hydrationErrors = null),
        (rootOrSingletonContext = !1),
        null !== current &&
          restoreSuspendedTreeContext(workInProgress, current),
        (workInProgress = mountActivityChildren(workInProgress, nextProps)),
        (workInProgress.flags |= 4096);
    return workInProgress;
  }
  current = createWorkInProgress(current.child, {
    mode: nextProps.mode,
    children: nextProps.children
  });
  current.ref = workInProgress.ref;
  workInProgress.child = current;
  current.return = workInProgress;
  return current;
}
function markRef(current, workInProgress) {
  var ref = workInProgress.ref;
  if (null === ref)
    null !== current &&
      null !== current.ref &&
      (workInProgress.flags |= 4194816);
  else {
    if ("function" !== typeof ref && "object" !== typeof ref)
      throw Error(formatProdErrorMessage(284));
    if (null === current || current.ref !== ref)
      workInProgress.flags |= 4194816;
  }
}
function updateFunctionComponent(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  prepareToReadContext(workInProgress);
  Component = renderWithHooks(
    current,
    workInProgress,
    Component,
    nextProps,
    void 0,
    renderLanes
  );
  nextProps = checkDidRenderIdHook();
  if (null !== current && !didReceiveUpdate)
    return (
      bailoutHooks(current, workInProgress, renderLanes),
      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
    );
  isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
  workInProgress.flags |= 1;
  reconcileChildren(current, workInProgress, Component, renderLanes);
  return workInProgress.child;
}
function replayFunctionComponent(
  current,
  workInProgress,
  nextProps,
  Component,
  secondArg,
  renderLanes
) {
  prepareToReadContext(workInProgress);
  workInProgress.updateQueue = null;
  nextProps = renderWithHooksAgain(
    workInProgress,
    Component,
    nextProps,
    secondArg
  );
  finishRenderingHooks(current);
  Component = checkDidRenderIdHook();
  if (null !== current && !didReceiveUpdate)
    return (
      bailoutHooks(current, workInProgress, renderLanes),
      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
    );
  isHydrating && Component && pushMaterializedTreeId(workInProgress);
  workInProgress.flags |= 1;
  reconcileChildren(current, workInProgress, nextProps, renderLanes);
  return workInProgress.child;
}
function updateClassComponent(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  prepareToReadContext(workInProgress);
  if (null === workInProgress.stateNode) {
    var context = emptyContextObject,
      contextType = Component.contextType;
    "object" === typeof contextType &&
      null !== contextType &&
      (context = readContext(contextType));
    context = new Component(nextProps, context);
    workInProgress.memoizedState =
      null !== context.state && void 0 !== context.state ? context.state : null;
    context.updater = classComponentUpdater;
    workInProgress.stateNode = context;
    context._reactInternals = workInProgress;
    context = workInProgress.stateNode;
    context.props = nextProps;
    context.state = workInProgress.memoizedState;
    context.refs = {};
    initializeUpdateQueue(workInProgress);
    contextType = Component.contextType;
    context.context =
      "object" === typeof contextType && null !== contextType
        ? readContext(contextType)
        : emptyContextObject;
    context.state = workInProgress.memoizedState;
    contextType = Component.getDerivedStateFromProps;
    "function" === typeof contextType &&
      (applyDerivedStateFromProps(
        workInProgress,
        Component,
        contextType,
        nextProps
      ),
      (context.state = workInProgress.memoizedState));
    "function" === typeof Component.getDerivedStateFromProps ||
      "function" === typeof context.getSnapshotBeforeUpdate ||
      ("function" !== typeof context.UNSAFE_componentWillMount &&
        "function" !== typeof context.componentWillMount) ||
      ((contextType = context.state),
      "function" === typeof context.componentWillMount &&
        context.componentWillMount(),
      "function" === typeof context.UNSAFE_componentWillMount &&
        context.UNSAFE_componentWillMount(),
      contextType !== context.state &&
        classComponentUpdater.enqueueReplaceState(context, context.state, null),
      processUpdateQueue(workInProgress, nextProps, context, renderLanes),
      suspendIfUpdateReadFromEntangledAsyncAction(),
      (context.state = workInProgress.memoizedState));
    "function" === typeof context.componentDidMount &&
      (workInProgress.flags |= 4194308);
    nextProps = !0;
  } else if (null === current) {
    context = workInProgress.stateNode;
    var unresolvedOldProps = workInProgress.memoizedProps,
      oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
    context.props = oldProps;
    var oldContext = context.context,
      contextType$jscomp$0 = Component.contextType;
    contextType = emptyContextObject;
    "object" === typeof contextType$jscomp$0 &&
      null !== contextType$jscomp$0 &&
      (contextType = readContext(contextType$jscomp$0));
    var getDerivedStateFromProps = Component.getDerivedStateFromProps;
    contextType$jscomp$0 =
      "function" === typeof getDerivedStateFromProps ||
      "function" === typeof context.getSnapshotBeforeUpdate;
    unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;
    contextType$jscomp$0 ||
      ("function" !== typeof context.UNSAFE_componentWillReceiveProps &&
        "function" !== typeof context.componentWillReceiveProps) ||
      ((unresolvedOldProps || oldContext !== contextType) &&
        callComponentWillReceiveProps(
          workInProgress,
          context,
          nextProps,
          contextType
        ));
    hasForceUpdate = !1;
    var oldState = workInProgress.memoizedState;
    context.state = oldState;
    processUpdateQueue(workInProgress, nextProps, context, renderLanes);
    suspendIfUpdateReadFromEntangledAsyncAction();
    oldContext = workInProgress.memoizedState;
    unresolvedOldProps || oldState !== oldContext || hasForceUpdate
      ? ("function" === typeof getDerivedStateFromProps &&
          (applyDerivedStateFromProps(
            workInProgress,
            Component,
            getDerivedStateFromProps,
            nextProps
          ),
          (oldContext = workInProgress.memoizedState)),
        (oldProps =
          hasForceUpdate ||
          checkShouldComponentUpdate(
            workInProgress,
            Component,
            oldProps,
            nextProps,
            oldState,
            oldContext,
            contextType
          ))
          ? (contextType$jscomp$0 ||
              ("function" !== typeof context.UNSAFE_componentWillMount &&
                "function" !== typeof context.componentWillMount) ||
              ("function" === typeof context.componentWillMount &&
                context.componentWillMount(),
              "function" === typeof context.UNSAFE_componentWillMount &&
                context.UNSAFE_componentWillMount()),
            "function" === typeof context.componentDidMount &&
              (workInProgress.flags |= 4194308))
          : ("function" === typeof context.componentDidMount &&
              (workInProgress.flags |= 4194308),
            (workInProgress.memoizedProps = nextProps),
            (workInProgress.memoizedState = oldContext)),
        (context.props = nextProps),
        (context.state = oldContext),
        (context.context = contextType),
        (nextProps = oldProps))
      : ("function" === typeof context.componentDidMount &&
          (workInProgress.flags |= 4194308),
        (nextProps = !1));
  } else {
    context = workInProgress.stateNode;
    cloneUpdateQueue(current, workInProgress);
    contextType = workInProgress.memoizedProps;
    contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
    context.props = contextType$jscomp$0;
    getDerivedStateFromProps = workInProgress.pendingProps;
    oldState = context.context;
    oldContext = Component.contextType;
    oldProps = emptyContextObject;
    "object" === typeof oldContext &&
      null !== oldContext &&
      (oldProps = readContext(oldContext));
    unresolvedOldProps = Component.getDerivedStateFromProps;
    (oldContext =
      "function" === typeof unresolvedOldProps ||
      "function" === typeof context.getSnapshotBeforeUpdate) ||
      ("function" !== typeof context.UNSAFE_componentWillReceiveProps &&
        "function" !== typeof context.componentWillReceiveProps) ||
      ((contextType !== getDerivedStateFromProps || oldState !== oldProps) &&
        callComponentWillReceiveProps(
          workInProgress,
          context,
          nextProps,
          oldProps
        ));
    hasForceUpdate = !1;
    oldState = workInProgress.memoizedState;
    context.state = oldState;
    processUpdateQueue(workInProgress, nextProps, context, renderLanes);
    suspendIfUpdateReadFromEntangledAsyncAction();
    var newState = workInProgress.memoizedState;
    contextType !== getDerivedStateFromProps ||
    oldState !== newState ||
    hasForceUpdate ||
    (null !== current &&
      null !== current.dependencies &&
      checkIfContextChanged(current.dependencies))
      ? ("function" === typeof unresolvedOldProps &&
          (applyDerivedStateFromProps(
            workInProgress,
            Component,
            unresolvedOldProps,
            nextProps
          ),
          (newState = workInProgress.memoizedState)),
        (contextType$jscomp$0 =
          hasForceUpdate ||
          checkShouldComponentUpdate(
            workInProgress,
            Component,
            contextType$jscomp$0,
            nextProps,
            oldState,
            newState,
            oldProps
          ) ||
          (null !== current &&
            null !== current.dependencies &&
            checkIfContextChanged(current.dependencies)))
          ? (oldContext ||
              ("function" !== typeof context.UNSAFE_componentWillUpdate &&
                "function" !== typeof context.componentWillUpdate) ||
              ("function" === typeof context.componentWillUpdate &&
                context.componentWillUpdate(nextProps, newState, oldProps),
              "function" === typeof context.UNSAFE_componentWillUpdate &&
                context.UNSAFE_componentWillUpdate(
                  nextProps,
                  newState,
                  oldProps
                )),
            "function" === typeof context.componentDidUpdate &&
              (workInProgress.flags |= 4),
            "function" === typeof context.getSnapshotBeforeUpdate &&
              (workInProgress.flags |= 1024))
          : ("function" !== typeof context.componentDidUpdate ||
              (contextType === current.memoizedProps &&
                oldState === current.memoizedState) ||
              (workInProgress.flags |= 4),
            "function" !== typeof context.getSnapshotBeforeUpdate ||
              (contextType === current.memoizedProps &&
                oldState === current.memoizedState) ||
              (workInProgress.flags |= 1024),
            (workInProgress.memoizedProps = nextProps),
            (workInProgress.memoizedState = newState)),
        (context.props = nextProps),
        (context.state = newState),
        (context.context = oldProps),
        (nextProps = contextType$jscomp$0))
      : ("function" !== typeof context.componentDidUpdate ||
          (contextType === current.memoizedProps &&
            oldState === current.memoizedState) ||
          (workInProgress.flags |= 4),
        "function" !== typeof context.getSnapshotBeforeUpdate ||
          (contextType === current.memoizedProps &&
            oldState === current.memoizedState) ||
          (workInProgress.flags |= 1024),
        (nextProps = !1));
  }
  context = nextProps;
  markRef(current, workInProgress);
  nextProps = 0 !== (workInProgress.flags & 128);
  context || nextProps
    ? ((context = workInProgress.stateNode),
      (Component =
        nextProps && "function" !== typeof Component.getDerivedStateFromError
          ? null
          : context.render()),
      (workInProgress.flags |= 1),
      null !== current && nextProps
        ? ((workInProgress.child = reconcileChildFibers(
            workInProgress,
            current.child,
            null,
            renderLanes
          )),
          (workInProgress.child = reconcileChildFibers(
            workInProgress,
            null,
            Component,
            renderLanes
          )))
        : reconcileChildren(current, workInProgress, Component, renderLanes),
      (workInProgress.memoizedState = context.state),
      (current = workInProgress.child))
    : (current = bailoutOnAlreadyFinishedWork(
        current,
        workInProgress,
        renderLanes
      ));
  return current;
}
function mountHostRootWithoutHydrating(
  current,
  workInProgress,
  nextChildren,
  renderLanes
) {
  resetHydrationState();
  workInProgress.flags |= 256;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}
var SUSPENDED_MARKER = {
  dehydrated: null,
  treeContext: null,
  retryLane: 0,
  hydrationErrors: null
};
function mountSuspenseOffscreenState(renderLanes) {
  return { baseLanes: renderLanes, cachePool: getSuspendedCache() };
}
function getRemainingWorkInPrimaryTree(
  current,
  primaryTreeDidDefer,
  renderLanes
) {
  current = null !== current ? current.childLanes & ~renderLanes : 0;
  primaryTreeDidDefer && (current |= workInProgressDeferredLane);
  return current;
}
function updateSuspenseComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps,
    showFallback = !1,
    didSuspend = 0 !== (workInProgress.flags & 128),
    JSCompiler_temp;
  (JSCompiler_temp = didSuspend) ||
    (JSCompiler_temp =
      null !== current && null === current.memoizedState
        ? !1
        : 0 !== (suspenseStackCursor.current & 2));
  JSCompiler_temp && ((showFallback = !0), (workInProgress.flags &= -129));
  JSCompiler_temp = 0 !== (workInProgress.flags & 32);
  workInProgress.flags &= -33;
  if (null === current) {
    if (isHydrating) {
      showFallback
        ? pushPrimaryTreeSuspenseHandler(workInProgress)
        : reuseSuspenseHandlerOnStack(workInProgress);
      (current = nextHydratableInstance)
        ? ((current = canHydrateHydrationBoundary(
            current,
            rootOrSingletonContext
          )),
          (current = null !== current && "&" !== current.data ? current : null),
          null !== current &&
            ((workInProgress.memoizedState = {
              dehydrated: current,
              treeContext:
                null !== treeContextProvider
                  ? { id: treeContextId, overflow: treeContextOverflow }
                  : null,
              retryLane: 536870912,
              hydrationErrors: null
            }),
            (renderLanes = createFiberFromDehydratedFragment(current)),
            (renderLanes.return = workInProgress),
            (workInProgress.child = renderLanes),
            (hydrationParentFiber = workInProgress),
            (nextHydratableInstance = null)))
        : (current = null);
      if (null === current) throw throwOnHydrationMismatch(workInProgress);
      isSuspenseInstanceFallback(current)
        ? (workInProgress.lanes = 32)
        : (workInProgress.lanes = 536870912);
      return null;
    }
    var nextPrimaryChildren = nextProps.children;
    nextProps = nextProps.fallback;
    if (showFallback)
      return (
        reuseSuspenseHandlerOnStack(workInProgress),
        (showFallback = workInProgress.mode),
        (nextPrimaryChildren = mountWorkInProgressOffscreenFiber(
          { mode: "hidden", children: nextPrimaryChildren },
          showFallback
        )),
        (nextProps = createFiberFromFragment(
          nextProps,
          showFallback,
          renderLanes,
          null
        )),
        (nextPrimaryChildren.return = workInProgress),
        (nextProps.return = workInProgress),
        (nextPrimaryChildren.sibling = nextProps),
        (workInProgress.child = nextPrimaryChildren),
        (nextProps = workInProgress.child),
        (nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes)),
        (nextProps.childLanes = getRemainingWorkInPrimaryTree(
          current,
          JSCompiler_temp,
          renderLanes
        )),
        (workInProgress.memoizedState = SUSPENDED_MARKER),
        bailoutOffscreenComponent(null, nextProps)
      );
    pushPrimaryTreeSuspenseHandler(workInProgress);
    return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren);
  }
  var prevState = current.memoizedState;
  if (
    null !== prevState &&
    ((nextPrimaryChildren = prevState.dehydrated), null !== nextPrimaryChildren)
  ) {
    if (didSuspend)
      workInProgress.flags & 256
        ? (pushPrimaryTreeSuspenseHandler(workInProgress),
          (workInProgress.flags &= -257),
          (workInProgress = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress,
            renderLanes
          )))
        : null !== workInProgress.memoizedState
          ? (reuseSuspenseHandlerOnStack(workInProgress),
            (workInProgress.child = current.child),
            (workInProgress.flags |= 128),
            (workInProgress = null))
          : (reuseSuspenseHandlerOnStack(workInProgress),
            (nextPrimaryChildren = nextProps.fallback),
            (showFallback = workInProgress.mode),
            (nextProps = mountWorkInProgressOffscreenFiber(
              { mode: "visible", children: nextProps.children },
              showFallback
            )),
            (nextPrimaryChildren = createFiberFromFragment(
              nextPrimaryChildren,
              showFallback,
              renderLanes,
              null
            )),
            (nextPrimaryChildren.flags |= 2),
            (nextProps.return = workInProgress),
            (nextPrimaryChildren.return = workInProgress),
            (nextProps.sibling = nextPrimaryChildren),
            (workInProgress.child = nextProps),
            reconcileChildFibers(
              workInProgress,
              current.child,
              null,
              renderLanes
            ),
            (nextProps = workInProgress.child),
            (nextProps.memoizedState =
              mountSuspenseOffscreenState(renderLanes)),
            (nextProps.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes
            )),
            (workInProgress.memoizedState = SUSPENDED_MARKER),
            (workInProgress = bailoutOffscreenComponent(null, nextProps)));
    else if (
      (pushPrimaryTreeSuspenseHandler(workInProgress),
      isSuspenseInstanceFallback(nextPrimaryChildren))
    ) {
      JSCompiler_temp =
        nextPrimaryChildren.nextSibling &&
        nextPrimaryChildren.nextSibling.dataset;
      if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
      JSCompiler_temp = digest;
      nextProps = Error(formatProdErrorMessage(419));
      nextProps.stack = "";
      nextProps.digest = JSCompiler_temp;
      queueHydrationError({ value: nextProps, source: null, stack: null });
      workInProgress = retrySuspenseComponentWithoutHydrating(
        current,
        workInProgress,
        renderLanes
      );
    } else if (
      (didReceiveUpdate ||
        propagateParentContextChanges(current, workInProgress, renderLanes, !1),
      (JSCompiler_temp = 0 !== (renderLanes & current.childLanes)),
      didReceiveUpdate || JSCompiler_temp)
    ) {
      JSCompiler_temp = workInProgressRoot;
      if (
        null !== JSCompiler_temp &&
        ((nextProps = getBumpedLaneForHydration(JSCompiler_temp, renderLanes)),
        0 !== nextProps && nextProps !== prevState.retryLane)
      )
        throw (
          ((prevState.retryLane = nextProps),
          enqueueConcurrentRenderForLane(current, nextProps),
          scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps),
          SelectiveHydrationException)
        );
      isSuspenseInstancePending(nextPrimaryChildren) ||
        renderDidSuspendDelayIfPossible();
      workInProgress = retrySuspenseComponentWithoutHydrating(
        current,
        workInProgress,
        renderLanes
      );
    } else
      isSuspenseInstancePending(nextPrimaryChildren)
        ? ((workInProgress.flags |= 192),
          (workInProgress.child = current.child),
          (workInProgress = null))
        : ((current = prevState.treeContext),
          (nextHydratableInstance = getNextHydratable(
            nextPrimaryChildren.nextSibling
          )),
          (hydrationParentFiber = workInProgress),
          (isHydrating = !0),
          (hydrationErrors = null),
          (rootOrSingletonContext = !1),
          null !== current &&
            restoreSuspendedTreeContext(workInProgress, current),
          (workInProgress = mountSuspensePrimaryChildren(
            workInProgress,
            nextProps.children
          )),
          (workInProgress.flags |= 4096));
    return workInProgress;
  }
  if (showFallback)
    return (
      reuseSuspenseHandlerOnStack(workInProgress),
      (nextPrimaryChildren = nextProps.fallback),
      (showFallback = workInProgress.mode),
      (prevState = current.child),
      (digest = prevState.sibling),
      (nextProps = createWorkInProgress(prevState, {
        mode: "hidden",
        children: nextProps.children
      })),
      (nextProps.subtreeFlags = prevState.subtreeFlags & 65011712),
      null !== digest
        ? (nextPrimaryChildren = createWorkInProgress(
            digest,
            nextPrimaryChildren
          ))
        : ((nextPrimaryChildren = createFiberFromFragment(
            nextPrimaryChildren,
            showFallback,
            renderLanes,
            null
          )),
          (nextPrimaryChildren.flags |= 2)),
      (nextPrimaryChildren.return = workInProgress),
      (nextProps.return = workInProgress),
      (nextProps.sibling = nextPrimaryChildren),
      (workInProgress.child = nextProps),
      bailoutOffscreenComponent(null, nextProps),
      (nextProps = workInProgress.child),
      (nextPrimaryChildren = current.child.memoizedState),
      null === nextPrimaryChildren
        ? (nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes))
        : ((showFallback = nextPrimaryChildren.cachePool),
          null !== showFallback
            ? ((prevState = CacheContext._currentValue),
              (showFallback =
                showFallback.parent !== prevState
                  ? { parent: prevState, pool: prevState }
                  : showFallback))
            : (showFallback = getSuspendedCache()),
          (nextPrimaryChildren = {
            baseLanes: nextPrimaryChildren.baseLanes | renderLanes,
            cachePool: showFallback
          })),
      (nextProps.memoizedState = nextPrimaryChildren),
      (nextProps.childLanes = getRemainingWorkInPrimaryTree(
        current,
        JSCompiler_temp,
        renderLanes
      )),
      (workInProgress.memoizedState = SUSPENDED_MARKER),
      bailoutOffscreenComponent(current.child, nextProps)
    );
  pushPrimaryTreeSuspenseHandler(workInProgress);
  renderLanes = current.child;
  current = renderLanes.sibling;
  renderLanes = createWorkInProgress(renderLanes, {
    mode: "visible",
    children: nextProps.children
  });
  renderLanes.return = workInProgress;
  renderLanes.sibling = null;
  null !== current &&
    ((JSCompiler_temp = workInProgress.deletions),
    null === JSCompiler_temp
      ? ((workInProgress.deletions = [current]), (workInProgress.flags |= 16))
      : JSCompiler_temp.push(current));
  workInProgress.child = renderLanes;
  workInProgress.memoizedState = null;
  return renderLanes;
}
function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
  primaryChildren = mountWorkInProgressOffscreenFiber(
    { mode: "visible", children: primaryChildren },
    workInProgress.mode
  );
  primaryChildren.return = workInProgress;
  return (workInProgress.child = primaryChildren);
}
function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
  offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
  offscreenProps.lanes = 0;
  return offscreenProps;
}
function retrySuspenseComponentWithoutHydrating(
  current,
  workInProgress,
  renderLanes
) {
  reconcileChildFibers(workInProgress, current.child, null, renderLanes);
  current = mountSuspensePrimaryChildren(
    workInProgress,
    workInProgress.pendingProps.children
  );
  current.flags |= 2;
  workInProgress.memoizedState = null;
  return current;
}
function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
  fiber.lanes |= renderLanes;
  var alternate = fiber.alternate;
  null !== alternate && (alternate.lanes |= renderLanes);
  scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);
}
function initSuspenseListRenderState(
  workInProgress,
  isBackwards,
  tail,
  lastContentRow,
  tailMode,
  treeForkCount
) {
  var renderState = workInProgress.memoizedState;
  null === renderState
    ? (workInProgress.memoizedState = {
        isBackwards: isBackwards,
        rendering: null,
        renderingStartTime: 0,
        last: lastContentRow,
        tail: tail,
        tailMode: tailMode,
        treeForkCount: treeForkCount
      })
    : ((renderState.isBackwards = isBackwards),
      (renderState.rendering = null),
      (renderState.renderingStartTime = 0),
      (renderState.last = lastContentRow),
      (renderState.tail = tail),
      (renderState.tailMode = tailMode),
      (renderState.treeForkCount = treeForkCount));
}
function updateSuspenseListComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps,
    revealOrder = nextProps.revealOrder,
    tailMode = nextProps.tail;
  nextProps = nextProps.children;
  var suspenseContext = suspenseStackCursor.current,
    shouldForceFallback = 0 !== (suspenseContext & 2);
  shouldForceFallback
    ? ((suspenseContext = (suspenseContext & 1) | 2),
      (workInProgress.flags |= 128))
    : (suspenseContext &= 1);
  push(suspenseStackCursor, suspenseContext);
  reconcileChildren(current, workInProgress, nextProps, renderLanes);
  nextProps = isHydrating ? treeForkCount : 0;
  if (!shouldForceFallback && null !== current && 0 !== (current.flags & 128))
    a: for (current = workInProgress.child; null !== current; ) {
      if (13 === current.tag)
        null !== current.memoizedState &&
          scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
      else if (19 === current.tag)
        scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
      else if (null !== current.child) {
        current.child.return = current;
        current = current.child;
        continue;
      }
      if (current === workInProgress) break a;
      for (; null === current.sibling; ) {
        if (null === current.return || current.return === workInProgress)
          break a;
        current = current.return;
      }
      current.sibling.return = current.return;
      current = current.sibling;
    }
  switch (revealOrder) {
    case "forwards":
      renderLanes = workInProgress.child;
      for (revealOrder = null; null !== renderLanes; )
        (current = renderLanes.alternate),
          null !== current &&
            null === findFirstSuspended(current) &&
            (revealOrder = renderLanes),
          (renderLanes = renderLanes.sibling);
      renderLanes = revealOrder;
      null === renderLanes
        ? ((revealOrder = workInProgress.child), (workInProgress.child = null))
        : ((revealOrder = renderLanes.sibling), (renderLanes.sibling = null));
      initSuspenseListRenderState(
        workInProgress,
        !1,
        revealOrder,
        renderLanes,
        tailMode,
        nextProps
      );
      break;
    case "backwards":
    case "unstable_legacy-backwards":
      renderLanes = null;
      revealOrder = workInProgress.child;
      for (workInProgress.child = null; null !== revealOrder; ) {
        current = revealOrder.alternate;
        if (null !== current && null === findFirstSuspended(current)) {
          workInProgress.child = revealOrder;
          break;
        }
        current = revealOrder.sibling;
        revealOrder.sibling = renderLanes;
        renderLanes = revealOrder;
        revealOrder = current;
      }
      initSuspenseListRenderState(
        workInProgress,
        !0,
        renderLanes,
        null,
        tailMode,
        nextProps
      );
      break;
    case "together":
      initSuspenseListRenderState(
        workInProgress,
        !1,
        null,
        null,
        void 0,
        nextProps
      );
      break;
    default:
      workInProgress.memoizedState = null;
  }
  return workInProgress.child;
}
function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
  null !== current && (workInProgress.dependencies = current.dependencies);
  workInProgressRootSkippedLanes |= workInProgress.lanes;
  if (0 === (renderLanes & workInProgress.childLanes))
    if (null !== current) {
      if (
        (propagateParentContextChanges(
          current,
          workInProgress,
          renderLanes,
          !1
        ),
        0 === (renderLanes & workInProgress.childLanes))
      )
        return null;
    } else return null;
  if (null !== current && workInProgress.child !== current.child)
    throw Error(formatProdErrorMessage(153));
  if (null !== workInProgress.child) {
    current = workInProgress.child;
    renderLanes = createWorkInProgress(current, current.pendingProps);
    workInProgress.child = renderLanes;
    for (renderLanes.return = workInProgress; null !== current.sibling; )
      (current = current.sibling),
        (renderLanes = renderLanes.sibling =
          createWorkInProgress(current, current.pendingProps)),
        (renderLanes.return = workInProgress);
    renderLanes.sibling = null;
  }
  return workInProgress.child;
}
function checkScheduledUpdateOrContext(current, renderLanes) {
  if (0 !== (current.lanes & renderLanes)) return !0;
  current = current.dependencies;
  return null !== current && checkIfContextChanged(current) ? !0 : !1;
}
function attemptEarlyBailoutIfNoScheduledUpdate(
  current,
  workInProgress,
  renderLanes
) {
  switch (workInProgress.tag) {
    case 3:
      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
      resetHydrationState();
      break;
    case 27:
    case 5:
      pushHostContext(workInProgress);
      break;
    case 4:
      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
      break;
    case 10:
      pushProvider(
        workInProgress,
        workInProgress.type,
        workInProgress.memoizedProps.value
      );
      break;
    case 31:
      if (null !== workInProgress.memoizedState)
        return (
          (workInProgress.flags |= 128),
          pushDehydratedActivitySuspenseHandler(workInProgress),
          null
        );
      break;
    case 13:
      var state$102 = workInProgress.memoizedState;
      if (null !== state$102) {
        if (null !== state$102.dehydrated)
          return (
            pushPrimaryTreeSuspenseHandler(workInProgress),
            (workInProgress.flags |= 128),
            null
          );
        if (0 !== (renderLanes & workInProgress.child.childLanes))
          return updateSuspenseComponent(current, workInProgress, renderLanes);
        pushPrimaryTreeSuspenseHandler(workInProgress);
        current = bailoutOnAlreadyFinishedWork(
          current,
          workInProgress,
          renderLanes
        );
        return null !== current ? current.sibling : null;
      }
      pushPrimaryTreeSuspenseHandler(workInProgress);
      break;
    case 19:
      var didSuspendBefore = 0 !== (current.flags & 128);
      state$102 = 0 !== (renderLanes & workInProgress.childLanes);
      state$102 ||
        (propagateParentContextChanges(
          current,
          workInProgress,
          renderLanes,
          !1
        ),
        (state$102 = 0 !== (renderLanes & workInProgress.childLanes)));
      if (didSuspendBefore) {
        if (state$102)
          return updateSuspenseListComponent(
            current,
            workInProgress,
            renderLanes
          );
        workInProgress.flags |= 128;
      }
      didSuspendBefore = workInProgress.memoizedState;
      null !== didSuspendBefore &&
        ((didSuspendBefore.rendering = null),
        (didSuspendBefore.tail = null),
        (didSuspendBefore.lastEffect = null));
      push(suspenseStackCursor, suspenseStackCursor.current);
      if (state$102) break;
      else return null;
    case 22:
      return (
        (workInProgress.lanes = 0),
        updateOffscreenComponent(
          current,
          workInProgress,
          renderLanes,
          workInProgress.pendingProps
        )
      );
    case 24:
      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
  }
  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
}
function beginWork(current, workInProgress, renderLanes) {
  if (null !== current)
    if (current.memoizedProps !== workInProgress.pendingProps)
      didReceiveUpdate = !0;
    else {
      if (
        !checkScheduledUpdateOrContext(current, renderLanes) &&
        0 === (workInProgress.flags & 128)
      )
        return (
          (didReceiveUpdate = !1),
          attemptEarlyBailoutIfNoScheduledUpdate(
            current,
            workInProgress,
            renderLanes
          )
        );
      didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
    }
  else
    (didReceiveUpdate = !1),
      isHydrating &&
        0 !== (workInProgress.flags & 1048576) &&
        pushTreeId(workInProgress, treeForkCount, workInProgress.index);
  workInProgress.lanes = 0;
  switch (workInProgress.tag) {
    case 16:
      a: {
        var props = workInProgress.pendingProps;
        current = resolveLazy(workInProgress.elementType);
        workInProgress.type = current;
        if ("function" === typeof current)
          shouldConstruct(current)
            ? ((props = resolveClassComponentProps(current, props)),
              (workInProgress.tag = 1),
              (workInProgress = updateClassComponent(
                null,
                workInProgress,
                current,
                props,
                renderLanes
              )))
            : ((workInProgress.tag = 0),
              (workInProgress = updateFunctionComponent(
                null,
                workInProgress,
                current,
                props,
                renderLanes
              )));
        else {
          if (void 0 !== current && null !== current) {
            var $$typeof = current.$$typeof;
            if ($$typeof === REACT_FORWARD_REF_TYPE) {
              workInProgress.tag = 11;
              workInProgress = updateForwardRef(
                null,
                workInProgress,
                current,
                props,
                renderLanes
              );
              break a;
            } else if ($$typeof === REACT_MEMO_TYPE) {
              workInProgress.tag = 14;
              workInProgress = updateMemoComponent(
                null,
                workInProgress,
                current,
                props,
                renderLanes
              );
              break a;
            }
          }
          workInProgress = getComponentNameFromType(current) || current;
          throw Error(formatProdErrorMessage(306, workInProgress, ""));
        }
      }
      return workInProgress;
    case 0:
      return updateFunctionComponent(
        current,
        workInProgress,
        workInProgress.type,
        workInProgress.pendingProps,
        renderLanes
      );
    case 1:
      return (
        (props = workInProgress.type),
        ($$typeof = resolveClassComponentProps(
          props,
          workInProgress.pendingProps
        )),
        updateClassComponent(
          current,
          workInProgress,
          props,
          $$typeof,
          renderLanes
        )
      );
    case 3:
      a: {
        pushHostContainer(
          workInProgress,
          workInProgress.stateNode.containerInfo
        );
        if (null === current) throw Error(formatProdErrorMessage(387));
        props = workInProgress.pendingProps;
        var prevState = workInProgress.memoizedState;
        $$typeof = prevState.element;
        cloneUpdateQueue(current, workInProgress);
        processUpdateQueue(workInProgress, props, null, renderLanes);
        var nextState = workInProgress.memoizedState;
        props = nextState.cache;
        pushProvider(workInProgress, CacheContext, props);
        props !== prevState.cache &&
          propagateContextChanges(
            workInProgress,
            [CacheContext],
            renderLanes,
            !0
          );
        suspendIfUpdateReadFromEntangledAsyncAction();
        props = nextState.element;
        if (prevState.isDehydrated)
          if (
            ((prevState = {
              element: props,
              isDehydrated: !1,
              cache: nextState.cache
            }),
            (workInProgress.updateQueue.baseState = prevState),
            (workInProgress.memoizedState = prevState),
            workInProgress.flags & 256)
          ) {
            workInProgress = mountHostRootWithoutHydrating(
              current,
              workInProgress,
              props,
              renderLanes
            );
            break a;
          } else if (props !== $$typeof) {
            $$typeof = createCapturedValueAtFiber(
              Error(formatProdErrorMessage(424)),
              workInProgress
            );
            queueHydrationError($$typeof);
            workInProgress = mountHostRootWithoutHydrating(
              current,
              workInProgress,
              props,
              renderLanes
            );
            break a;
          } else {
            current = workInProgress.stateNode.containerInfo;
            switch (current.nodeType) {
              case 9:
                current = current.body;
                break;
              default:
                current =
                  "HTML" === current.nodeName
                    ? current.ownerDocument.body
                    : current;
            }
            nextHydratableInstance = getNextHydratable(current.firstChild);
            hydrationParentFiber = workInProgress;
            isHydrating = !0;
            hydrationErrors = null;
            rootOrSingletonContext = !0;
            renderLanes = mountChildFibers(
              workInProgress,
              null,
              props,
              renderLanes
            );
            for (workInProgress.child = renderLanes; renderLanes; )
              (renderLanes.flags = (renderLanes.flags & -3) | 4096),
                (renderLanes = renderLanes.sibling);
          }
        else {
          resetHydrationState();
          if (props === $$typeof) {
            workInProgress = bailoutOnAlreadyFinishedWork(
              current,
              workInProgress,
              renderLanes
            );
            break a;
          }
          reconcileChildren(current, workInProgress, props, renderLanes);
        }
        workInProgress = workInProgress.child;
      }
      return workInProgress;
    case 26:
      return (
        markRef(current, workInProgress),
        null === current
          ? (renderLanes = getResource(
              workInProgress.type,
              null,
              workInProgress.pendingProps,
              null
            ))
            ? (workInProgress.memoizedState = renderLanes)
            : isHydrating ||
              ((renderLanes = workInProgress.type),
              (current = workInProgress.pendingProps),
              (props = getOwnerDocumentFromRootContainer(
                rootInstanceStackCursor.current
              ).createElement(renderLanes)),
              (props[internalInstanceKey] = workInProgress),
              (props[internalPropsKey] = current),
              setInitialProperties(props, renderLanes, current),
              markNodeAsHoistable(props),
              (workInProgress.stateNode = props))
          : (workInProgress.memoizedState = getResource(
              workInProgress.type,
              current.memoizedProps,
              workInProgress.pendingProps,
              current.memoizedState
            )),
        null
      );
    case 27:
      return (
        pushHostContext(workInProgress),
        null === current &&
          isHydrating &&
          ((props = workInProgress.stateNode =
            resolveSingletonInstance(
              workInProgress.type,
              workInProgress.pendingProps,
              rootInstanceStackCursor.current
            )),
          (hydrationParentFiber = workInProgress),
          (rootOrSingletonContext = !0),
          ($$typeof = nextHydratableInstance),
          isSingletonScope(workInProgress.type)
            ? ((previousHydratableOnEnteringScopedSingleton = $$typeof),
              (nextHydratableInstance = getNextHydratable(props.firstChild)))
            : (nextHydratableInstance = $$typeof)),
        reconcileChildren(
          current,
          workInProgress,
          workInProgress.pendingProps.children,
          renderLanes
        ),
        markRef(current, workInProgress),
        null === current && (workInProgress.flags |= 4194304),
        workInProgress.child
      );
    case 5:
      if (null === current && isHydrating) {
        if (($$typeof = props = nextHydratableInstance))
          (props = canHydrateInstance(
            props,
            workInProgress.type,
            workInProgress.pendingProps,
            rootOrSingletonContext
          )),
            null !== props
              ? ((workInProgress.stateNode = props),
                (hydrationParentFiber = workInProgress),
                (nextHydratableInstance = getNextHydratable(props.firstChild)),
                (rootOrSingletonContext = !1),
                ($$typeof = !0))
              : ($$typeof = !1);
        $$typeof || throwOnHydrationMismatch(workInProgress);
      }
      pushHostContext(workInProgress);
      $$typeof = workInProgress.type;
      prevState = workInProgress.pendingProps;
      nextState = null !== current ? current.memoizedProps : null;
      props = prevState.children;
      shouldSetTextContent($$typeof, prevState)
        ? (props = null)
        : null !== nextState &&
          shouldSetTextContent($$typeof, nextState) &&
          (workInProgress.flags |= 32);
      null !== workInProgress.memoizedState &&
        (($$typeof = renderWithHooks(
          current,
          workInProgress,
          TransitionAwareHostComponent,
          null,
          null,
          renderLanes
        )),
        (HostTransitionContext._currentValue = $$typeof));
      markRef(current, workInProgress);
      reconcileChildren(current, workInProgress, props, renderLanes);
      return workInProgress.child;
    case 6:
      if (null === current && isHydrating) {
        if ((current = renderLanes = nextHydratableInstance))
          (renderLanes = canHydrateTextInstance(
            renderLanes,
            workInProgress.pendingProps,
            rootOrSingletonContext
          )),
            null !== renderLanes
              ? ((workInProgress.stateNode = renderLanes),
                (hydrationParentFiber = workInProgress),
                (nextHydratableInstance = null),
                (current = !0))
              : (current = !1);
        current || throwOnHydrationMismatch(workInProgress);
      }
      return null;
    case 13:
      return updateSuspenseComponent(current, workInProgress, renderLanes);
    case 4:
      return (
        pushHostContainer(
          workInProgress,
          workInProgress.stateNode.containerInfo
        ),
        (props = workInProgress.pendingProps),
        null === current
          ? (workInProgress.child = reconcileChildFibers(
              workInProgress,
              null,
              props,
              renderLanes
            ))
          : reconcileChildren(current, workInProgress, props, renderLanes),
        workInProgress.child
      );
    case 11:
      return updateForwardRef(
        current,
        workInProgress,
        workInProgress.type,
        workInProgress.pendingProps,
        renderLanes
      );
    case 7:
      return (
        reconcileChildren(
          current,
          workInProgress,
          workInProgress.pendingProps,
          renderLanes
        ),
        workInProgress.child
      );
    case 8:
      return (
        reconcileChildren(
          current,
          workInProgress,
          workInProgress.pendingProps.children,
          renderLanes
        ),
        workInProgress.child
      );
    case 12:
      return (
        reconcileChildren(
          current,
          workInProgress,
          workInProgress.pendingProps.children,
          renderLanes
        ),
        workInProgress.child
      );
    case 10:
      return (
        (props = workInProgress.pendingProps),
        pushProvider(workInProgress, workInProgress.type, props.value),
        reconcileChildren(current, workInProgress, props.children, renderLanes),
        workInProgress.child
      );
    case 9:
      return (
        ($$typeof = workInProgress.type._context),
        (props = workInProgress.pendingProps.children),
        prepareToReadContext(workInProgress),
        ($$typeof = readContext($$typeof)),
        (props = props($$typeof)),
        (workInProgress.flags |= 1),
        reconcileChildren(current, workInProgress, props, renderLanes),
        workInProgress.child
      );
    case 14:
      return updateMemoComponent(
        current,
        workInProgress,
        workInProgress.type,
        workInProgress.pendingProps,
        renderLanes
      );
    case 15:
      return updateSimpleMemoComponent(
        current,
        workInProgress,
        workInProgress.type,
        workInProgress.pendingProps,
        renderLanes
      );
    case 19:
      return updateSuspenseListComponent(current, workInProgress, renderLanes);
    case 31:
      return updateActivityComponent(current, workInProgress, renderLanes);
    case 22:
      return updateOffscreenComponent(
        current,
        workInProgress,
        renderLanes,
        workInProgress.pendingProps
      );
    case 24:
      return (
        prepareToReadContext(workInProgress),
        (props = readContext(CacheContext)),
        null === current
          ? (($$typeof = peekCacheFromPool()),
            null === $$typeof &&
              (($$typeof = workInProgressRoot),
              (prevState = createCache()),
              ($$typeof.pooledCache = prevState),
              prevState.refCount++,
              null !== prevState && ($$typeof.pooledCacheLanes |= renderLanes),
              ($$typeof = prevState)),
            (workInProgress.memoizedState = { parent: props, cache: $$typeof }),
            initializeUpdateQueue(workInProgress),
            pushProvider(workInProgress, CacheContext, $$typeof))
          : (0 !== (current.lanes & renderLanes) &&
              (cloneUpdateQueue(current, workInProgress),
              processUpdateQueue(workInProgress, null, null, renderLanes),
              suspendIfUpdateReadFromEntangledAsyncAction()),
            ($$typeof = current.memoizedState),
            (prevState = workInProgress.memoizedState),
            $$typeof.parent !== props
              ? (($$typeof = { parent: props, cache: props }),
                (workInProgress.memoizedState = $$typeof),
                0 === workInProgress.lanes &&
                  (workInProgress.memoizedState =
                    workInProgress.updateQueue.baseState =
                      $$typeof),
                pushProvider(workInProgress, CacheContext, props))
              : ((props = prevState.cache),
                pushProvider(workInProgress, CacheContext, props),
                props !== $$typeof.cache &&
                  propagateContextChanges(
                    workInProgress,
                    [CacheContext],
                    renderLanes,
                    !0
                  ))),
        reconcileChildren(
          current,
          workInProgress,
          workInProgress.pendingProps.children,
          renderLanes
        ),
        workInProgress.child
      );
    case 29:
      throw workInProgress.pendingProps;
  }
  throw Error(formatProdErrorMessage(156, workInProgress.tag));
}
function markUpdate(workInProgress) {
  workInProgress.flags |= 4;
}
function preloadInstanceAndSuspendIfNeeded(
  workInProgress,
  type,
  oldProps,
  newProps,
  renderLanes
) {
  if ((type = 0 !== (workInProgress.mode & 32))) type = !1;
  if (type) {
    if (
      ((workInProgress.flags |= 16777216),
      (renderLanes & 335544128) === renderLanes)
    )
      if (workInProgress.stateNode.complete) workInProgress.flags |= 8192;
      else if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;
      else
        throw (
          ((suspendedThenable = noopSuspenseyCommitThenable),
          SuspenseyCommitException)
        );
  } else workInProgress.flags &= -16777217;
}
function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
  if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
    workInProgress.flags &= -16777217;
  else if (((workInProgress.flags |= 16777216), !preloadResource(resource)))
    if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;
    else
      throw (
        ((suspendedThenable = noopSuspenseyCommitThenable),
        SuspenseyCommitException)
      );
}
function scheduleRetryEffect(workInProgress, retryQueue) {
  null !== retryQueue && (workInProgress.flags |= 4);
  workInProgress.flags & 16384 &&
    ((retryQueue =
      22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),
    (workInProgress.lanes |= retryQueue),
    (workInProgressSuspendedRetryLanes |= retryQueue));
}
function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
  if (!isHydrating)
    switch (renderState.tailMode) {
      case "hidden":
        hasRenderedATailFallback = renderState.tail;
        for (var lastTailNode = null; null !== hasRenderedATailFallback; )
          null !== hasRenderedATailFallback.alternate &&
            (lastTailNode = hasRenderedATailFallback),
            (hasRenderedATailFallback = hasRenderedATailFallback.sibling);
        null === lastTailNode
          ? (renderState.tail = null)
          : (lastTailNode.sibling = null);
        break;
      case "collapsed":
        lastTailNode = renderState.tail;
        for (var lastTailNode$106 = null; null !== lastTailNode; )
          null !== lastTailNode.alternate && (lastTailNode$106 = lastTailNode),
            (lastTailNode = lastTailNode.sibling);
        null === lastTailNode$106
          ? hasRenderedATailFallback || null === renderState.tail
            ? (renderState.tail = null)
            : (renderState.tail.sibling = null)
          : (lastTailNode$106.sibling = null);
    }
}
function bubbleProperties(completedWork) {
  var didBailout =
      null !== completedWork.alternate &&
      completedWork.alternate.child === completedWork.child,
    newChildLanes = 0,
    subtreeFlags = 0;
  if (didBailout)
    for (var child$107 = completedWork.child; null !== child$107; )
      (newChildLanes |= child$107.lanes | child$107.childLanes),
        (subtreeFlags |= child$107.subtreeFlags & 65011712),
        (subtreeFlags |= child$107.flags & 65011712),
        (child$107.return = completedWork),
        (child$107 = child$107.sibling);
  else
    for (child$107 = completedWork.child; null !== child$107; )
      (newChildLanes |= child$107.lanes | child$107.childLanes),
        (subtreeFlags |= child$107.subtreeFlags),
        (subtreeFlags |= child$107.flags),
        (child$107.return = completedWork),
        (child$107 = child$107.sibling);
  completedWork.subtreeFlags |= subtreeFlags;
  completedWork.childLanes = newChildLanes;
  return didBailout;
}
function completeWork(current, workInProgress, renderLanes) {
  var newProps = workInProgress.pendingProps;
  popTreeContext(workInProgress);
  switch (workInProgress.tag) {
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return bubbleProperties(workInProgress), null;
    case 1:
      return bubbleProperties(workInProgress), null;
    case 3:
      renderLanes = workInProgress.stateNode;
      newProps = null;
      null !== current && (newProps = current.memoizedState.cache);
      workInProgress.memoizedState.cache !== newProps &&
        (workInProgress.flags |= 2048);
      popProvider(CacheContext);
      popHostContainer();
      renderLanes.pendingContext &&
        ((renderLanes.context = renderLanes.pendingContext),
        (renderLanes.pendingContext = null));
      if (null === current || null === current.child)
        popHydrationState(workInProgress)
          ? markUpdate(workInProgress)
          : null === current ||
            (current.memoizedState.isDehydrated &&
              0 === (workInProgress.flags & 256)) ||
            ((workInProgress.flags |= 1024),
            upgradeHydrationErrorsToRecoverable());
      bubbleProperties(workInProgress);
      return null;
    case 26:
      var type = workInProgress.type,
        nextResource = workInProgress.memoizedState;
      null === current
        ? (markUpdate(workInProgress),
          null !== nextResource
            ? (bubbleProperties(workInProgress),
              preloadResourceAndSuspendIfNeeded(workInProgress, nextResource))
            : (bubbleProperties(workInProgress),
              preloadInstanceAndSuspendIfNeeded(
                workInProgress,
                type,
                null,
                newProps,
                renderLanes
              )))
        : nextResource
          ? nextResource !== current.memoizedState
            ? (markUpdate(workInProgress),
              bubbleProperties(workInProgress),
              preloadResourceAndSuspendIfNeeded(workInProgress, nextResource))
            : (bubbleProperties(workInProgress),
              (workInProgress.flags &= -16777217))
          : ((current = current.memoizedProps),
            current !== newProps && markUpdate(workInProgress),
            bubbleProperties(workInProgress),
            preloadInstanceAndSuspendIfNeeded(
              workInProgress,
              type,
              current,
              newProps,
              renderLanes
            ));
      return null;
    case 27:
      popHostContext(workInProgress);
      renderLanes = rootInstanceStackCursor.current;
      type = workInProgress.type;
      if (null !== current && null != workInProgress.stateNode)
        current.memoizedProps !== newProps && markUpdate(workInProgress);
      else {
        if (!newProps) {
          if (null === workInProgress.stateNode)
            throw Error(formatProdErrorMessage(166));
          bubbleProperties(workInProgress);
          return null;
        }
        current = contextStackCursor.current;
        popHydrationState(workInProgress)
          ? prepareToHydrateHostInstance(workInProgress, current)
          : ((current = resolveSingletonInstance(type, newProps, renderLanes)),
            (workInProgress.stateNode = current),
            markUpdate(workInProgress));
      }
      bubbleProperties(workInProgress);
      return null;
    case 5:
      popHostContext(workInProgress);
      type = workInProgress.type;
      if (null !== current && null != workInProgress.stateNode)
        current.memoizedProps !== newProps && markUpdate(workInProgress);
      else {
        if (!newProps) {
          if (null === workInProgress.stateNode)
            throw Error(formatProdErrorMessage(166));
          bubbleProperties(workInProgress);
          return null;
        }
        nextResource = contextStackCursor.current;
        if (popHydrationState(workInProgress))
          prepareToHydrateHostInstance(workInProgress, nextResource);
        else {
          var ownerDocument = getOwnerDocumentFromRootContainer(
            rootInstanceStackCursor.current
          );
          switch (nextResource) {
            case 1:
              nextResource = ownerDocument.createElementNS(
                "http://www.w3.org/2000/svg",
                type
              );
              break;
            case 2:
              nextResource = ownerDocument.createElementNS(
                "http://www.w3.org/1998/Math/MathML",
                type
              );
              break;
            default:
              switch (type) {
                case "svg":
                  nextResource = ownerDocument.createElementNS(
                    "http://www.w3.org/2000/svg",
                    type
                  );
                  break;
                case "math":
                  nextResource = ownerDocument.createElementNS(
                    "http://www.w3.org/1998/Math/MathML",
                    type
                  );
                  break;
                case "script":
                  nextResource = ownerDocument.createElement("div");
                  nextResource.innerHTML = "<script>\x3c/script>";
                  nextResource = nextResource.removeChild(
                    nextResource.firstChild
                  );
                  break;
                case "select":
                  nextResource =
                    "string" === typeof newProps.is
                      ? ownerDocument.createElement("select", {
                          is: newProps.is
                        })
                      : ownerDocument.createElement("select");
                  newProps.multiple
                    ? (nextResource.multiple = !0)
                    : newProps.size && (nextResource.size = newProps.size);
                  break;
                default:
                  nextResource =
                    "string" === typeof newProps.is
                      ? ownerDocument.createElement(type, { is: newProps.is })
                      : ownerDocument.createElement(type);
              }
          }
          nextResource[internalInstanceKey] = workInProgress;
          nextResource[internalPropsKey] = newProps;
          a: for (
            ownerDocument = workInProgress.child;
            null !== ownerDocument;

          ) {
            if (5 === ownerDocument.tag || 6 === ownerDocument.tag)
              nextResource.appendChild(ownerDocument.stateNode);
            else if (
              4 !== ownerDocument.tag &&
              27 !== ownerDocument.tag &&
              null !== ownerDocument.child
            ) {
              ownerDocument.child.return = ownerDocument;
              ownerDocument = ownerDocument.child;
              continue;
            }
            if (ownerDocument === workInProgress) break a;
            for (; null === ownerDocument.sibling; ) {
              if (
                null === ownerDocument.return ||
                ownerDocument.return === workInProgress
              )
                break a;
              ownerDocument = ownerDocument.return;
            }
            ownerDocument.sibling.return = ownerDocument.return;
            ownerDocument = ownerDocument.sibling;
          }
          workInProgress.stateNode = nextResource;
          a: switch (
            (setInitialProperties(nextResource, type, newProps), type)
          ) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              newProps = !!newProps.autoFocus;
              break a;
            case "img":
              newProps = !0;
              break a;
            default:
              newProps = !1;
          }
          newProps && markUpdate(workInProgress);
        }
      }
      bubbleProperties(workInProgress);
      preloadInstanceAndSuspendIfNeeded(
        workInProgress,
        workInProgress.type,
        null === current ? null : current.memoizedProps,
        workInProgress.pendingProps,
        renderLanes
      );
      return null;
    case 6:
      if (current && null != workInProgress.stateNode)
        current.memoizedProps !== newProps && markUpdate(workInProgress);
      else {
        if ("string" !== typeof newProps && null === workInProgress.stateNode)
          throw Error(formatProdErrorMessage(166));
        current = rootInstanceStackCursor.current;
        if (popHydrationState(workInProgress)) {
          current = workInProgress.stateNode;
          renderLanes = workInProgress.memoizedProps;
          newProps = null;
          type = hydrationParentFiber;
          if (null !== type)
            switch (type.tag) {
              case 27:
              case 5:
                newProps = type.memoizedProps;
            }
          current[internalInstanceKey] = workInProgress;
          current =
            current.nodeValue === renderLanes ||
            (null !== newProps && !0 === newProps.suppressHydrationWarning) ||
            checkForUnmatchedText(current.nodeValue, renderLanes)
              ? !0
              : !1;
          current || throwOnHydrationMismatch(workInProgress, !0);
        } else
          (current =
            getOwnerDocumentFromRootContainer(current).createTextNode(
              newProps
            )),
            (current[internalInstanceKey] = workInProgress),
            (workInProgress.stateNode = current);
      }
      bubbleProperties(workInProgress);
      return null;
    case 31:
      renderLanes = workInProgress.memoizedState;
      if (null === current || null !== current.memoizedState) {
        newProps = popHydrationState(workInProgress);
        if (null !== renderLanes) {
          if (null === current) {
            if (!newProps) throw Error(formatProdErrorMessage(318));
            current = workInProgress.memoizedState;
            current = null !== current ? current.dehydrated : null;
            if (!current) throw Error(formatProdErrorMessage(557));
            current[internalInstanceKey] = workInProgress;
          } else
            resetHydrationState(),
              0 === (workInProgress.flags & 128) &&
                (workInProgress.memoizedState = null),
              (workInProgress.flags |= 4);
          bubbleProperties(workInProgress);
          current = !1;
        } else
          (renderLanes = upgradeHydrationErrorsToRecoverable()),
            null !== current &&
              null !== current.memoizedState &&
              (current.memoizedState.hydrationErrors = renderLanes),
            (current = !0);
        if (!current) {
          if (workInProgress.flags & 256)
            return popSuspenseHandler(workInProgress), workInProgress;
          popSuspenseHandler(workInProgress);
          return null;
        }
        if (0 !== (workInProgress.flags & 128))
          throw Error(formatProdErrorMessage(558));
      }
      bubbleProperties(workInProgress);
      return null;
    case 13:
      newProps = workInProgress.memoizedState;
      if (
        null === current ||
        (null !== current.memoizedState &&
          null !== current.memoizedState.dehydrated)
      ) {
        type = popHydrationState(workInProgress);
        if (null !== newProps && null !== newProps.dehydrated) {
          if (null === current) {
            if (!type) throw Error(formatProdErrorMessage(318));
            type = workInProgress.memoizedState;
            type = null !== type ? type.dehydrated : null;
            if (!type) throw Error(formatProdErrorMessage(317));
            type[internalInstanceKey] = workInProgress;
          } else
            resetHydrationState(),
              0 === (workInProgress.flags & 128) &&
                (workInProgress.memoizedState = null),
              (workInProgress.flags |= 4);
          bubbleProperties(workInProgress);
          type = !1;
        } else
          (type = upgradeHydrationErrorsToRecoverable()),
            null !== current &&
              null !== current.memoizedState &&
              (current.memoizedState.hydrationErrors = type),
            (type = !0);
        if (!type) {
          if (workInProgress.flags & 256)
            return popSuspenseHandler(workInProgress), workInProgress;
          popSuspenseHandler(workInProgress);
          return null;
        }
      }
      popSuspenseHandler(workInProgress);
      if (0 !== (workInProgress.flags & 128))
        return (workInProgress.lanes = renderLanes), workInProgress;
      renderLanes = null !== newProps;
      current = null !== current && null !== current.memoizedState;
      renderLanes &&
        ((newProps = workInProgress.child),
        (type = null),
        null !== newProps.alternate &&
          null !== newProps.alternate.memoizedState &&
          null !== newProps.alternate.memoizedState.cachePool &&
          (type = newProps.alternate.memoizedState.cachePool.pool),
        (nextResource = null),
        null !== newProps.memoizedState &&
          null !== newProps.memoizedState.cachePool &&
          (nextResource = newProps.memoizedState.cachePool.pool),
        nextResource !== type && (newProps.flags |= 2048));
      renderLanes !== current &&
        renderLanes &&
        (workInProgress.child.flags |= 8192);
      scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
      bubbleProperties(workInProgress);
      return null;
    case 4:
      return (
        popHostContainer(),
        null === current &&
          listenToAllSupportedEvents(workInProgress.stateNode.containerInfo),
        bubbleProperties(workInProgress),
        null
      );
    case 10:
      return (
        popProvider(workInProgress.type), bubbleProperties(workInProgress), null
      );
    case 19:
      pop(suspenseStackCursor);
      newProps = workInProgress.memoizedState;
      if (null === newProps) return bubbleProperties(workInProgress), null;
      type = 0 !== (workInProgress.flags & 128);
      nextResource = newProps.rendering;
      if (null === nextResource)
        if (type) cutOffTailIfNeeded(newProps, !1);
        else {
          if (
            0 !== workInProgressRootExitStatus ||
            (null !== current && 0 !== (current.flags & 128))
          )
            for (current = workInProgress.child; null !== current; ) {
              nextResource = findFirstSuspended(current);
              if (null !== nextResource) {
                workInProgress.flags |= 128;
                cutOffTailIfNeeded(newProps, !1);
                current = nextResource.updateQueue;
                workInProgress.updateQueue = current;
                scheduleRetryEffect(workInProgress, current);
                workInProgress.subtreeFlags = 0;
                current = renderLanes;
                for (renderLanes = workInProgress.child; null !== renderLanes; )
                  resetWorkInProgress(renderLanes, current),
                    (renderLanes = renderLanes.sibling);
                push(
                  suspenseStackCursor,
                  (suspenseStackCursor.current & 1) | 2
                );
                isHydrating &&
                  pushTreeFork(workInProgress, newProps.treeForkCount);
                return workInProgress.child;
              }
              current = current.sibling;
            }
          null !== newProps.tail &&
            now() > workInProgressRootRenderTargetTime &&
            ((workInProgress.flags |= 128),
            (type = !0),
            cutOffTailIfNeeded(newProps, !1),
            (workInProgress.lanes = 4194304));
        }
      else {
        if (!type)
          if (
            ((current = findFirstSuspended(nextResource)), null !== current)
          ) {
            if (
              ((workInProgress.flags |= 128),
              (type = !0),
              (current = current.updateQueue),
              (workInProgress.updateQueue = current),
              scheduleRetryEffect(workInProgress, current),
              cutOffTailIfNeeded(newProps, !0),
              null === newProps.tail &&
                "hidden" === newProps.tailMode &&
                !nextResource.alternate &&
                !isHydrating)
            )
              return bubbleProperties(workInProgress), null;
          } else
            2 * now() - newProps.renderingStartTime >
              workInProgressRootRenderTargetTime &&
              536870912 !== renderLanes &&
              ((workInProgress.flags |= 128),
              (type = !0),
              cutOffTailIfNeeded(newProps, !1),
              (workInProgress.lanes = 4194304));
        newProps.isBackwards
          ? ((nextResource.sibling = workInProgress.child),
            (workInProgress.child = nextResource))
          : ((current = newProps.last),
            null !== current
              ? (current.sibling = nextResource)
              : (workInProgress.child = nextResource),
            (newProps.last = nextResource));
      }
      if (null !== newProps.tail)
        return (
          (current = newProps.tail),
          (newProps.rendering = current),
          (newProps.tail = current.sibling),
          (newProps.renderingStartTime = now()),
          (current.sibling = null),
          (renderLanes = suspenseStackCursor.current),
          push(
            suspenseStackCursor,
            type ? (renderLanes & 1) | 2 : renderLanes & 1
          ),
          isHydrating && pushTreeFork(workInProgress, newProps.treeForkCount),
          current
        );
      bubbleProperties(workInProgress);
      return null;
    case 22:
    case 23:
      return (
        popSuspenseHandler(workInProgress),
        popHiddenContext(),
        (newProps = null !== workInProgress.memoizedState),
        null !== current
          ? (null !== current.memoizedState) !== newProps &&
            (workInProgress.flags |= 8192)
          : newProps && (workInProgress.flags |= 8192),
        newProps
          ? 0 !== (renderLanes & 536870912) &&
            0 === (workInProgress.flags & 128) &&
            (bubbleProperties(workInProgress),
            workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192))
          : bubbleProperties(workInProgress),
        (renderLanes = workInProgress.updateQueue),
        null !== renderLanes &&
          scheduleRetryEffect(workInProgress, renderLanes.retryQueue),
        (renderLanes = null),
        null !== current &&
          null !== current.memoizedState &&
          null !== current.memoizedState.cachePool &&
          (renderLanes = current.memoizedState.cachePool.pool),
        (newProps = null),
        null !== workInProgress.memoizedState &&
          null !== workInProgress.memoizedState.cachePool &&
          (newProps = workInProgress.memoizedState.cachePool.pool),
        newProps !== renderLanes && (workInProgress.flags |= 2048),
        null !== current && pop(resumedCache),
        null
      );
    case 24:
      return (
        (renderLanes = null),
        null !== current && (renderLanes = current.memoizedState.cache),
        workInProgress.memoizedState.cache !== renderLanes &&
          (workInProgress.flags |= 2048),
        popProvider(CacheContext),
        bubbleProperties(workInProgress),
        null
      );
    case 25:
      return null;
    case 30:
      return null;
  }
  throw Error(formatProdErrorMessage(156, workInProgress.tag));
}
function unwindWork(current, workInProgress) {
  popTreeContext(workInProgress);
  switch (workInProgress.tag) {
    case 1:
      return (
        (current = workInProgress.flags),
        current & 65536
          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
          : null
      );
    case 3:
      return (
        popProvider(CacheContext),
        popHostContainer(),
        (current = workInProgress.flags),
        0 !== (current & 65536) && 0 === (current & 128)
          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
          : null
      );
    case 26:
    case 27:
    case 5:
      return popHostContext(workInProgress), null;
    case 31:
      if (null !== workInProgress.memoizedState) {
        popSuspenseHandler(workInProgress);
        if (null === workInProgress.alternate)
          throw Error(formatProdErrorMessage(340));
        resetHydrationState();
      }
      current = workInProgress.flags;
      return current & 65536
        ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
        : null;
    case 13:
      popSuspenseHandler(workInProgress);
      current = workInProgress.memoizedState;
      if (null !== current && null !== current.dehydrated) {
        if (null === workInProgress.alternate)
          throw Error(formatProdErrorMessage(340));
        resetHydrationState();
      }
      current = workInProgress.flags;
      return current & 65536
        ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
        : null;
    case 19:
      return pop(suspenseStackCursor), null;
    case 4:
      return popHostContainer(), null;
    case 10:
      return popProvider(workInProgress.type), null;
    case 22:
    case 23:
      return (
        popSuspenseHandler(workInProgress),
        popHiddenContext(),
        null !== current && pop(resumedCache),
        (current = workInProgress.flags),
        current & 65536
          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
          : null
      );
    case 24:
      return popProvider(CacheContext), null;
    case 25:
      return null;
    default:
      return null;
  }
}
function unwindInterruptedWork(current, interruptedWork) {
  popTreeContext(interruptedWork);
  switch (interruptedWork.tag) {
    case 3:
      popProvider(CacheContext);
      popHostContainer();
      break;
    case 26:
    case 27:
    case 5:
      popHostContext(interruptedWork);
      break;
    case 4:
      popHostContainer();
      break;
    case 31:
      null !== interruptedWork.memoizedState &&
        popSuspenseHandler(interruptedWork);
      break;
    case 13:
      popSuspenseHandler(interruptedWork);
      break;
    case 19:
      pop(suspenseStackCursor);
      break;
    case 10:
      popProvider(interruptedWork.type);
      break;
    case 22:
    case 23:
      popSuspenseHandler(interruptedWork);
      popHiddenContext();
      null !== current && pop(resumedCache);
      break;
    case 24:
      popProvider(CacheContext);
  }
}
function commitHookEffectListMount(flags, finishedWork) {
  try {
    var updateQueue = finishedWork.updateQueue,
      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
    if (null !== lastEffect) {
      var firstEffect = lastEffect.next;
      updateQueue = firstEffect;
      do {
        if ((updateQueue.tag & flags) === flags) {
          lastEffect = void 0;
          var create = updateQueue.create,
            inst = updateQueue.inst;
          lastEffect = create();
          inst.destroy = lastEffect;
        }
        updateQueue = updateQueue.next;
      } while (updateQueue !== firstEffect);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHookEffectListUnmount(
  flags,
  finishedWork,
  nearestMountedAncestor$jscomp$0
) {
  try {
    var updateQueue = finishedWork.updateQueue,
      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
    if (null !== lastEffect) {
      var firstEffect = lastEffect.next;
      updateQueue = firstEffect;
      do {
        if ((updateQueue.tag & flags) === flags) {
          var inst = updateQueue.inst,
            destroy = inst.destroy;
          if (void 0 !== destroy) {
            inst.destroy = void 0;
            lastEffect = finishedWork;
            var nearestMountedAncestor = nearestMountedAncestor$jscomp$0,
              destroy_ = destroy;
            try {
              destroy_();
            } catch (error) {
              captureCommitPhaseError(
                lastEffect,
                nearestMountedAncestor,
                error
              );
            }
          }
        }
        updateQueue = updateQueue.next;
      } while (updateQueue !== firstEffect);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitClassCallbacks(finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  if (null !== updateQueue) {
    var instance = finishedWork.stateNode;
    try {
      commitCallbacks(updateQueue, instance);
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
}
function safelyCallComponentWillUnmount(
  current,
  nearestMountedAncestor,
  instance
) {
  instance.props = resolveClassComponentProps(
    current.type,
    current.memoizedProps
  );
  instance.state = current.memoizedState;
  try {
    instance.componentWillUnmount();
  } catch (error) {
    captureCommitPhaseError(current, nearestMountedAncestor, error);
  }
}
function safelyAttachRef(current, nearestMountedAncestor) {
  try {
    var ref = current.ref;
    if (null !== ref) {
      switch (current.tag) {
        case 26:
        case 27:
        case 5:
          var instanceToUse = current.stateNode;
          break;
        case 30:
          instanceToUse = current.stateNode;
          break;
        default:
          instanceToUse = current.stateNode;
      }
      "function" === typeof ref
        ? (current.refCleanup = ref(instanceToUse))
        : (ref.current = instanceToUse);
    }
  } catch (error) {
    captureCommitPhaseError(current, nearestMountedAncestor, error);
  }
}
function safelyDetachRef(current, nearestMountedAncestor) {
  var ref = current.ref,
    refCleanup = current.refCleanup;
  if (null !== ref)
    if ("function" === typeof refCleanup)
      try {
        refCleanup();
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      } finally {
        (current.refCleanup = null),
          (current = current.alternate),
          null != current && (current.refCleanup = null);
      }
    else if ("function" === typeof ref)
      try {
        ref(null);
      } catch (error$140) {
        captureCommitPhaseError(current, nearestMountedAncestor, error$140);
      }
    else ref.current = null;
}
function commitHostMount(finishedWork) {
  var type = finishedWork.type,
    props = finishedWork.memoizedProps,
    instance = finishedWork.stateNode;
  try {
    a: switch (type) {
      case "button":
      case "input":
      case "select":
      case "textarea":
        props.autoFocus && instance.focus();
        break a;
      case "img":
        props.src
          ? (instance.src = props.src)
          : props.srcSet && (instance.srcset = props.srcSet);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHostUpdate(finishedWork, newProps, oldProps) {
  try {
    var domElement = finishedWork.stateNode;
    updateProperties(domElement, finishedWork.type, oldProps, newProps);
    domElement[internalPropsKey] = newProps;
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function isHostParent(fiber) {
  return (
    5 === fiber.tag ||
    3 === fiber.tag ||
    26 === fiber.tag ||
    (27 === fiber.tag && isSingletonScope(fiber.type)) ||
    4 === fiber.tag
  );
}
function getHostSibling(fiber) {
  a: for (;;) {
    for (; null === fiber.sibling; ) {
      if (null === fiber.return || isHostParent(fiber.return)) return null;
      fiber = fiber.return;
    }
    fiber.sibling.return = fiber.return;
    for (
      fiber = fiber.sibling;
      5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;

    ) {
      if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
      if (fiber.flags & 2) continue a;
      if (null === fiber.child || 4 === fiber.tag) continue a;
      else (fiber.child.return = fiber), (fiber = fiber.child);
    }
    if (!(fiber.flags & 2)) return fiber.stateNode;
  }
}
function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
  var tag = node.tag;
  if (5 === tag || 6 === tag)
    (node = node.stateNode),
      before
        ? (9 === parent.nodeType
            ? parent.body
            : "HTML" === parent.nodeName
              ? parent.ownerDocument.body
              : parent
          ).insertBefore(node, before)
        : ((before =
            9 === parent.nodeType
              ? parent.body
              : "HTML" === parent.nodeName
                ? parent.ownerDocument.body
                : parent),
          before.appendChild(node),
          (parent = parent._reactRootContainer),
          (null !== parent && void 0 !== parent) ||
            null !== before.onclick ||
            (before.onclick = noop$1));
  else if (
    4 !== tag &&
    (27 === tag &&
      isSingletonScope(node.type) &&
      ((parent = node.stateNode), (before = null)),
    (node = node.child),
    null !== node)
  )
    for (
      insertOrAppendPlacementNodeIntoContainer(node, before, parent),
        node = node.sibling;
      null !== node;

    )
      insertOrAppendPlacementNodeIntoContainer(node, before, parent),
        (node = node.sibling);
}
function insertOrAppendPlacementNode(node, before, parent) {
  var tag = node.tag;
  if (5 === tag || 6 === tag)
    (node = node.stateNode),
      before ? parent.insertBefore(node, before) : parent.appendChild(node);
  else if (
    4 !== tag &&
    (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode),
    (node = node.child),
    null !== node)
  )
    for (
      insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
      null !== node;

    )
      insertOrAppendPlacementNode(node, before, parent), (node = node.sibling);
}
function commitHostSingletonAcquisition(finishedWork) {
  var singleton = finishedWork.stateNode,
    props = finishedWork.memoizedProps;
  try {
    for (
      var type = finishedWork.type, attributes = singleton.attributes;
      attributes.length;

    )
      singleton.removeAttributeNode(attributes[0]);
    setInitialProperties(singleton, type, props);
    singleton[internalInstanceKey] = finishedWork;
    singleton[internalPropsKey] = props;
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
var offscreenSubtreeIsHidden = !1,
  offscreenSubtreeWasHidden = !1,
  needsFormReset = !1,
  PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
  nextEffect = null;
function commitBeforeMutationEffects(root, firstChild) {
  root = root.containerInfo;
  eventsEnabled = _enabled;
  root = getActiveElementDeep(root);
  if (hasSelectionCapabilities(root)) {
    if ("selectionStart" in root)
      var JSCompiler_temp = {
        start: root.selectionStart,
        end: root.selectionEnd
      };
    else
      a: {
        JSCompiler_temp =
          ((JSCompiler_temp = root.ownerDocument) &&
            JSCompiler_temp.defaultView) ||
          window;
        var selection =
          JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
        if (selection && 0 !== selection.rangeCount) {
          JSCompiler_temp = selection.anchorNode;
          var anchorOffset = selection.anchorOffset,
            focusNode = selection.focusNode;
          selection = selection.focusOffset;
          try {
            JSCompiler_temp.nodeType, focusNode.nodeType;
          } catch (e$20) {
            JSCompiler_temp = null;
            break a;
          }
          var length = 0,
            start = -1,
            end = -1,
            indexWithinAnchor = 0,
            indexWithinFocus = 0,
            node = root,
            parentNode = null;
          b: for (;;) {
            for (var next; ; ) {
              node !== JSCompiler_temp ||
                (0 !== anchorOffset && 3 !== node.nodeType) ||
                (start = length + anchorOffset);
              node !== focusNode ||
                (0 !== selection && 3 !== node.nodeType) ||
                (end = length + selection);
              3 === node.nodeType && (length += node.nodeValue.length);
              if (null === (next = node.firstChild)) break;
              parentNode = node;
              node = next;
            }
            for (;;) {
              if (node === root) break b;
              parentNode === JSCompiler_temp &&
                ++indexWithinAnchor === anchorOffset &&
                (start = length);
              parentNode === focusNode &&
                ++indexWithinFocus === selection &&
                (end = length);
              if (null !== (next = node.nextSibling)) break;
              node = parentNode;
              parentNode = node.parentNode;
            }
            node = next;
          }
          JSCompiler_temp =
            -1 === start || -1 === end ? null : { start: start, end: end };
        } else JSCompiler_temp = null;
      }
    JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
  } else JSCompiler_temp = null;
  selectionInformation = { focusedElem: root, selectionRange: JSCompiler_temp };
  _enabled = !1;
  for (nextEffect = firstChild; null !== nextEffect; )
    if (
      ((firstChild = nextEffect),
      (root = firstChild.child),
      0 !== (firstChild.subtreeFlags & 1028) && null !== root)
    )
      (root.return = firstChild), (nextEffect = root);
    else
      for (; null !== nextEffect; ) {
        firstChild = nextEffect;
        focusNode = firstChild.alternate;
        root = firstChild.flags;
        switch (firstChild.tag) {
          case 0:
            if (
              0 !== (root & 4) &&
              ((root = firstChild.updateQueue),
              (root = null !== root ? root.events : null),
              null !== root)
            )
              for (
                JSCompiler_temp = 0;
                JSCompiler_temp < root.length;
                JSCompiler_temp++
              )
                (anchorOffset = root[JSCompiler_temp]),
                  (anchorOffset.ref.impl = anchorOffset.nextImpl);
            break;
          case 11:
          case 15:
            break;
          case 1:
            if (0 !== (root & 1024) && null !== focusNode) {
              root = void 0;
              JSCompiler_temp = firstChild;
              anchorOffset = focusNode.memoizedProps;
              focusNode = focusNode.memoizedState;
              selection = JSCompiler_temp.stateNode;
              try {
                var resolvedPrevProps = resolveClassComponentProps(
                  JSCompiler_temp.type,
                  anchorOffset
                );
                root = selection.getSnapshotBeforeUpdate(
                  resolvedPrevProps,
                  focusNode
                );
                selection.__reactInternalSnapshotBeforeUpdate = root;
              } catch (error) {
                captureCommitPhaseError(
                  JSCompiler_temp,
                  JSCompiler_temp.return,
                  error
                );
              }
            }
            break;
          case 3:
            if (0 !== (root & 1024))
              if (
                ((root = firstChild.stateNode.containerInfo),
                (JSCompiler_temp = root.nodeType),
                9 === JSCompiler_temp)
              )
                clearContainerSparingly(root);
              else if (1 === JSCompiler_temp)
                switch (root.nodeName) {
                  case "HEAD":
                  case "HTML":
                  case "BODY":
                    clearContainerSparingly(root);
                    break;
                  default:
                    root.textContent = "";
                }
            break;
          case 5:
          case 26:
          case 27:
          case 6:
          case 4:
          case 17:
            break;
          default:
            if (0 !== (root & 1024)) throw Error(formatProdErrorMessage(163));
        }
        root = firstChild.sibling;
        if (null !== root) {
          root.return = firstChild.return;
          nextEffect = root;
          break;
        }
        nextEffect = firstChild.return;
      }
}
function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
  var flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 15:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      flags & 4 && commitHookEffectListMount(5, finishedWork);
      break;
    case 1:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      if (flags & 4)
        if (((finishedRoot = finishedWork.stateNode), null === current))
          try {
            finishedRoot.componentDidMount();
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        else {
          var prevProps = resolveClassComponentProps(
            finishedWork.type,
            current.memoizedProps
          );
          current = current.memoizedState;
          try {
            finishedRoot.componentDidUpdate(
              prevProps,
              current,
              finishedRoot.__reactInternalSnapshotBeforeUpdate
            );
          } catch (error$139) {
            captureCommitPhaseError(
              finishedWork,
              finishedWork.return,
              error$139
            );
          }
        }
      flags & 64 && commitClassCallbacks(finishedWork);
      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
      break;
    case 3:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      if (
        flags & 64 &&
        ((finishedRoot = finishedWork.updateQueue), null !== finishedRoot)
      ) {
        current = null;
        if (null !== finishedWork.child)
          switch (finishedWork.child.tag) {
            case 27:
            case 5:
              current = finishedWork.child.stateNode;
              break;
            case 1:
              current = finishedWork.child.stateNode;
          }
        try {
          commitCallbacks(finishedRoot, current);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      break;
    case 27:
      null === current &&
        flags & 4 &&
        commitHostSingletonAcquisition(finishedWork);
    case 26:
    case 5:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      null === current && flags & 4 && commitHostMount(finishedWork);
      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
      break;
    case 12:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      break;
    case 31:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
      break;
    case 13:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
      flags & 64 &&
        ((finishedRoot = finishedWork.memoizedState),
        null !== finishedRoot &&
          ((finishedRoot = finishedRoot.dehydrated),
          null !== finishedRoot &&
            ((finishedWork = retryDehydratedSuspenseBoundary.bind(
              null,
              finishedWork
            )),
            registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
      break;
    case 22:
      flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
      if (!flags) {
        current =
          (null !== current && null !== current.memoizedState) ||
          offscreenSubtreeWasHidden;
        prevProps = offscreenSubtreeIsHidden;
        var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
        offscreenSubtreeIsHidden = flags;
        (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden
          ? recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              0 !== (finishedWork.subtreeFlags & 8772)
            )
          : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        offscreenSubtreeIsHidden = prevProps;
        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
      }
      break;
    case 30:
      break;
    default:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
  }
}
function detachFiberAfterEffects(fiber) {
  var alternate = fiber.alternate;
  null !== alternate &&
    ((fiber.alternate = null), detachFiberAfterEffects(alternate));
  fiber.child = null;
  fiber.deletions = null;
  fiber.sibling = null;
  5 === fiber.tag &&
    ((alternate = fiber.stateNode),
    null !== alternate && detachDeletedInstance(alternate));
  fiber.stateNode = null;
  fiber.return = null;
  fiber.dependencies = null;
  fiber.memoizedProps = null;
  fiber.memoizedState = null;
  fiber.pendingProps = null;
  fiber.stateNode = null;
  fiber.updateQueue = null;
}
var hostParent = null,
  hostParentIsContainer = !1;
function recursivelyTraverseDeletionEffects(
  finishedRoot,
  nearestMountedAncestor,
  parent
) {
  for (parent = parent.child; null !== parent; )
    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent),
      (parent = parent.sibling);
}
function commitDeletionEffectsOnFiber(
  finishedRoot,
  nearestMountedAncestor,
  deletedFiber
) {
  if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
    try {
      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
    } catch (err) {}
  switch (deletedFiber.tag) {
    case 26:
      offscreenSubtreeWasHidden ||
        safelyDetachRef(deletedFiber, nearestMountedAncestor);
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      deletedFiber.memoizedState
        ? deletedFiber.memoizedState.count--
        : deletedFiber.stateNode &&
          ((deletedFiber = deletedFiber.stateNode),
          deletedFiber.parentNode.removeChild(deletedFiber));
      break;
    case 27:
      offscreenSubtreeWasHidden ||
        safelyDetachRef(deletedFiber, nearestMountedAncestor);
      var prevHostParent = hostParent,
        prevHostParentIsContainer = hostParentIsContainer;
      isSingletonScope(deletedFiber.type) &&
        ((hostParent = deletedFiber.stateNode), (hostParentIsContainer = !1));
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      releaseSingletonInstance(deletedFiber.stateNode);
      hostParent = prevHostParent;
      hostParentIsContainer = prevHostParentIsContainer;
      break;
    case 5:
      offscreenSubtreeWasHidden ||
        safelyDetachRef(deletedFiber, nearestMountedAncestor);
    case 6:
      prevHostParent = hostParent;
      prevHostParentIsContainer = hostParentIsContainer;
      hostParent = null;
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      hostParent = prevHostParent;
      hostParentIsContainer = prevHostParentIsContainer;
      if (null !== hostParent)
        if (hostParentIsContainer)
          try {
            (9 === hostParent.nodeType
              ? hostParent.body
              : "HTML" === hostParent.nodeName
                ? hostParent.ownerDocument.body
                : hostParent
            ).removeChild(deletedFiber.stateNode);
          } catch (error) {
            captureCommitPhaseError(
              deletedFiber,
              nearestMountedAncestor,
              error
            );
          }
        else
          try {
            hostParent.removeChild(deletedFiber.stateNode);
          } catch (error) {
            captureCommitPhaseError(
              deletedFiber,
              nearestMountedAncestor,
              error
            );
          }
      break;
    case 18:
      null !== hostParent &&
        (hostParentIsContainer
          ? ((finishedRoot = hostParent),
            clearHydrationBoundary(
              9 === finishedRoot.nodeType
                ? finishedRoot.body
                : "HTML" === finishedRoot.nodeName
                  ? finishedRoot.ownerDocument.body
                  : finishedRoot,
              deletedFiber.stateNode
            ),
            retryIfBlockedOn(finishedRoot))
          : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
      break;
    case 4:
      prevHostParent = hostParent;
      prevHostParentIsContainer = hostParentIsContainer;
      hostParent = deletedFiber.stateNode.containerInfo;
      hostParentIsContainer = !0;
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      hostParent = prevHostParent;
      hostParentIsContainer = prevHostParentIsContainer;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
      offscreenSubtreeWasHidden ||
        commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      break;
    case 1:
      offscreenSubtreeWasHidden ||
        (safelyDetachRef(deletedFiber, nearestMountedAncestor),
        (prevHostParent = deletedFiber.stateNode),
        "function" === typeof prevHostParent.componentWillUnmount &&
          safelyCallComponentWillUnmount(
            deletedFiber,
            nearestMountedAncestor,
            prevHostParent
          ));
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      break;
    case 21:
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      break;
    case 22:
      offscreenSubtreeWasHidden =
        (prevHostParent = offscreenSubtreeWasHidden) ||
        null !== deletedFiber.memoizedState;
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      offscreenSubtreeWasHidden = prevHostParent;
      break;
    default:
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
  }
}
function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
  if (
    null === finishedWork.memoizedState &&
    ((finishedRoot = finishedWork.alternate),
    null !== finishedRoot &&
      ((finishedRoot = finishedRoot.memoizedState), null !== finishedRoot))
  ) {
    finishedRoot = finishedRoot.dehydrated;
    try {
      retryIfBlockedOn(finishedRoot);
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
}
function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
  if (
    null === finishedWork.memoizedState &&
    ((finishedRoot = finishedWork.alternate),
    null !== finishedRoot &&
      ((finishedRoot = finishedRoot.memoizedState),
      null !== finishedRoot &&
        ((finishedRoot = finishedRoot.dehydrated), null !== finishedRoot)))
  )
    try {
      retryIfBlockedOn(finishedRoot);
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
}
function getRetryCache(finishedWork) {
  switch (finishedWork.tag) {
    case 31:
    case 13:
    case 19:
      var retryCache = finishedWork.stateNode;
      null === retryCache &&
        (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
      return retryCache;
    case 22:
      return (
        (finishedWork = finishedWork.stateNode),
        (retryCache = finishedWork._retryCache),
        null === retryCache &&
          (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),
        retryCache
      );
    default:
      throw Error(formatProdErrorMessage(435, finishedWork.tag));
  }
}
function attachSuspenseRetryListeners(finishedWork, wakeables) {
  var retryCache = getRetryCache(finishedWork);
  wakeables.forEach(function (wakeable) {
    if (!retryCache.has(wakeable)) {
      retryCache.add(wakeable);
      var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
      wakeable.then(retry, retry);
    }
  });
}
function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
  var deletions = parentFiber.deletions;
  if (null !== deletions)
    for (var i = 0; i < deletions.length; i++) {
      var childToDelete = deletions[i],
        root = root$jscomp$0,
        returnFiber = parentFiber,
        parent = returnFiber;
      a: for (; null !== parent; ) {
        switch (parent.tag) {
          case 27:
            if (isSingletonScope(parent.type)) {
              hostParent = parent.stateNode;
              hostParentIsContainer = !1;
              break a;
            }
            break;
          case 5:
            hostParent = parent.stateNode;
            hostParentIsContainer = !1;
            break a;
          case 3:
          case 4:
            hostParent = parent.stateNode.containerInfo;
            hostParentIsContainer = !0;
            break a;
        }
        parent = parent.return;
      }
      if (null === hostParent) throw Error(formatProdErrorMessage(160));
      commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);
      hostParent = null;
      hostParentIsContainer = !1;
      root = childToDelete.alternate;
      null !== root && (root.return = null);
      childToDelete.return = null;
    }
  if (parentFiber.subtreeFlags & 13886)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),
        (parentFiber = parentFiber.sibling);
}
var currentHoistableRoot = null;
function commitMutationEffectsOnFiber(finishedWork, root) {
  var current = finishedWork.alternate,
    flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 4 &&
        (commitHookEffectListUnmount(3, finishedWork, finishedWork.return),
        commitHookEffectListMount(3, finishedWork),
        commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
      break;
    case 1:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 &&
        (offscreenSubtreeWasHidden ||
          null === current ||
          safelyDetachRef(current, current.return));
      flags & 64 &&
        offscreenSubtreeIsHidden &&
        ((finishedWork = finishedWork.updateQueue),
        null !== finishedWork &&
          ((flags = finishedWork.callbacks),
          null !== flags &&
            ((current = finishedWork.shared.hiddenCallbacks),
            (finishedWork.shared.hiddenCallbacks =
              null === current ? flags : current.concat(flags)))));
      break;
    case 26:
      var hoistableRoot = currentHoistableRoot;
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 &&
        (offscreenSubtreeWasHidden ||
          null === current ||
          safelyDetachRef(current, current.return));
      if (flags & 4) {
        var currentResource = null !== current ? current.memoizedState : null;
        flags = finishedWork.memoizedState;
        if (null === current)
          if (null === flags)
            if (null === finishedWork.stateNode) {
              a: {
                flags = finishedWork.type;
                current = finishedWork.memoizedProps;
                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                b: switch (flags) {
                  case "title":
                    currentResource =
                      hoistableRoot.getElementsByTagName("title")[0];
                    if (
                      !currentResource ||
                      currentResource[internalHoistableMarker] ||
                      currentResource[internalInstanceKey] ||
                      "http://www.w3.org/2000/svg" ===
                        currentResource.namespaceURI ||
                      currentResource.hasAttribute("itemprop")
                    )
                      (currentResource = hoistableRoot.createElement(flags)),
                        hoistableRoot.head.insertBefore(
                          currentResource,
                          hoistableRoot.querySelector("head > title")
                        );
                    setInitialProperties(currentResource, flags, current);
                    currentResource[internalInstanceKey] = finishedWork;
                    markNodeAsHoistable(currentResource);
                    flags = currentResource;
                    break a;
                  case "link":
                    var maybeNodes = getHydratableHoistableCache(
                      "link",
                      "href",
                      hoistableRoot
                    ).get(flags + (current.href || ""));
                    if (maybeNodes)
                      for (var i = 0; i < maybeNodes.length; i++)
                        if (
                          ((currentResource = maybeNodes[i]),
                          currentResource.getAttribute("href") ===
                            (null == current.href || "" === current.href
                              ? null
                              : current.href) &&
                            currentResource.getAttribute("rel") ===
                              (null == current.rel ? null : current.rel) &&
                            currentResource.getAttribute("title") ===
                              (null == current.title ? null : current.title) &&
                            currentResource.getAttribute("crossorigin") ===
                              (null == current.crossOrigin
                                ? null
                                : current.crossOrigin))
                        ) {
                          maybeNodes.splice(i, 1);
                          break b;
                        }
                    currentResource = hoistableRoot.createElement(flags);
                    setInitialProperties(currentResource, flags, current);
                    hoistableRoot.head.appendChild(currentResource);
                    break;
                  case "meta":
                    if (
                      (maybeNodes = getHydratableHoistableCache(
                        "meta",
                        "content",
                        hoistableRoot
                      ).get(flags + (current.content || "")))
                    )
                      for (i = 0; i < maybeNodes.length; i++)
                        if (
                          ((currentResource = maybeNodes[i]),
                          currentResource.getAttribute("content") ===
                            (null == current.content
                              ? null
                              : "" + current.content) &&
                            currentResource.getAttribute("name") ===
                              (null == current.name ? null : current.name) &&
                            currentResource.getAttribute("property") ===
                              (null == current.property
                                ? null
                                : current.property) &&
                            currentResource.getAttribute("http-equiv") ===
                              (null == current.httpEquiv
                                ? null
                                : current.httpEquiv) &&
                            currentResource.getAttribute("charset") ===
                              (null == current.charSet
                                ? null
                                : current.charSet))
                        ) {
                          maybeNodes.splice(i, 1);
                          break b;
                        }
                    currentResource = hoistableRoot.createElement(flags);
                    setInitialProperties(currentResource, flags, current);
                    hoistableRoot.head.appendChild(currentResource);
                    break;
                  default:
                    throw Error(formatProdErrorMessage(468, flags));
                }
                currentResource[internalInstanceKey] = finishedWork;
                markNodeAsHoistable(currentResource);
                flags = currentResource;
              }
              finishedWork.stateNode = flags;
            } else
              mountHoistable(
                hoistableRoot,
                finishedWork.type,
                finishedWork.stateNode
              );
          else
            finishedWork.stateNode = acquireResource(
              hoistableRoot,
              flags,
              finishedWork.memoizedProps
            );
        else
          currentResource !== flags
            ? (null === currentResource
                ? null !== current.stateNode &&
                  ((current = current.stateNode),
                  current.parentNode.removeChild(current))
                : currentResource.count--,
              null === flags
                ? mountHoistable(
                    hoistableRoot,
                    finishedWork.type,
                    finishedWork.stateNode
                  )
                : acquireResource(
                    hoistableRoot,
                    flags,
                    finishedWork.memoizedProps
                  ))
            : null === flags &&
              null !== finishedWork.stateNode &&
              commitHostUpdate(
                finishedWork,
                finishedWork.memoizedProps,
                current.memoizedProps
              );
      }
      break;
    case 27:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 &&
        (offscreenSubtreeWasHidden ||
          null === current ||
          safelyDetachRef(current, current.return));
      null !== current &&
        flags & 4 &&
        commitHostUpdate(
          finishedWork,
          finishedWork.memoizedProps,
          current.memoizedProps
        );
      break;
    case 5:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 &&
        (offscreenSubtreeWasHidden ||
          null === current ||
          safelyDetachRef(current, current.return));
      if (finishedWork.flags & 32) {
        hoistableRoot = finishedWork.stateNode;
        try {
          setTextContent(hoistableRoot, "");
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      flags & 4 &&
        null != finishedWork.stateNode &&
        ((hoistableRoot = finishedWork.memoizedProps),
        commitHostUpdate(
          finishedWork,
          hoistableRoot,
          null !== current ? current.memoizedProps : hoistableRoot
        ));
      flags & 1024 && (needsFormReset = !0);
      break;
    case 6:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      if (flags & 4) {
        if (null === finishedWork.stateNode)
          throw Error(formatProdErrorMessage(162));
        flags = finishedWork.memoizedProps;
        current = finishedWork.stateNode;
        try {
          current.nodeValue = flags;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      break;
    case 3:
      tagCaches = null;
      hoistableRoot = currentHoistableRoot;
      currentHoistableRoot = getHoistableRoot(root.containerInfo);
      recursivelyTraverseMutationEffects(root, finishedWork);
      currentHoistableRoot = hoistableRoot;
      commitReconciliationEffects(finishedWork);
      if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
        try {
          retryIfBlockedOn(root.containerInfo);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      needsFormReset &&
        ((needsFormReset = !1), recursivelyResetForms(finishedWork));
      break;
    case 4:
      flags = currentHoistableRoot;
      currentHoistableRoot = getHoistableRoot(
        finishedWork.stateNode.containerInfo
      );
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      currentHoistableRoot = flags;
      break;
    case 12:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    case 31:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 4 &&
        ((flags = finishedWork.updateQueue),
        null !== flags &&
          ((finishedWork.updateQueue = null),
          attachSuspenseRetryListeners(finishedWork, flags)));
      break;
    case 13:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      finishedWork.child.flags & 8192 &&
        (null !== finishedWork.memoizedState) !==
          (null !== current && null !== current.memoizedState) &&
        (globalMostRecentFallbackTime = now());
      flags & 4 &&
        ((flags = finishedWork.updateQueue),
        null !== flags &&
          ((finishedWork.updateQueue = null),
          attachSuspenseRetryListeners(finishedWork, flags)));
      break;
    case 22:
      hoistableRoot = null !== finishedWork.memoizedState;
      var wasHidden = null !== current && null !== current.memoizedState,
        prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
        prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
      recursivelyTraverseMutationEffects(root, finishedWork);
      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
      commitReconciliationEffects(finishedWork);
      if (flags & 8192)
        a: for (
          root = finishedWork.stateNode,
            root._visibility = hoistableRoot
              ? root._visibility & -2
              : root._visibility | 1,
            hoistableRoot &&
              (null === current ||
                wasHidden ||
                offscreenSubtreeIsHidden ||
                offscreenSubtreeWasHidden ||
                recursivelyTraverseDisappearLayoutEffects(finishedWork)),
            current = null,
            root = finishedWork;
          ;

        ) {
          if (5 === root.tag || 26 === root.tag) {
            if (null === current) {
              wasHidden = current = root;
              try {
                if (((currentResource = wasHidden.stateNode), hoistableRoot))
                  (maybeNodes = currentResource.style),
                    "function" === typeof maybeNodes.setProperty
                      ? maybeNodes.setProperty("display", "none", "important")
                      : (maybeNodes.display = "none");
                else {
                  i = wasHidden.stateNode;
                  var styleProp = wasHidden.memoizedProps.style,
                    display =
                      void 0 !== styleProp &&
                      null !== styleProp &&
                      styleProp.hasOwnProperty("display")
                        ? styleProp.display
                        : null;
                  i.style.display =
                    null == display || "boolean" === typeof display
                      ? ""
                      : ("" + display).trim();
                }
              } catch (error) {
                captureCommitPhaseError(wasHidden, wasHidden.return, error);
              }
            }
          } else if (6 === root.tag) {
            if (null === current) {
              wasHidden = root;
              try {
                wasHidden.stateNode.nodeValue = hoistableRoot
                  ? ""
                  : wasHidden.memoizedProps;
              } catch (error) {
                captureCommitPhaseError(wasHidden, wasHidden.return, error);
              }
            }
          } else if (18 === root.tag) {
            if (null === current) {
              wasHidden = root;
              try {
                var instance = wasHidden.stateNode;
                hoistableRoot
                  ? hideOrUnhideDehydratedBoundary(instance, !0)
                  : hideOrUnhideDehydratedBoundary(wasHidden.stateNode, !1);
              } catch (error) {
                captureCommitPhaseError(wasHidden, wasHidden.return, error);
              }
            }
          } else if (
            ((22 !== root.tag && 23 !== root.tag) ||
              null === root.memoizedState ||
              root === finishedWork) &&
            null !== root.child
          ) {
            root.child.return = root;
            root = root.child;
            continue;
          }
          if (root === finishedWork) break a;
          for (; null === root.sibling; ) {
            if (null === root.return || root.return === finishedWork) break a;
            current === root && (current = null);
            root = root.return;
          }
          current === root && (current = null);
          root.sibling.return = root.return;
          root = root.sibling;
        }
      flags & 4 &&
        ((flags = finishedWork.updateQueue),
        null !== flags &&
          ((current = flags.retryQueue),
          null !== current &&
            ((flags.retryQueue = null),
            attachSuspenseRetryListeners(finishedWork, current))));
      break;
    case 19:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 4 &&
        ((flags = finishedWork.updateQueue),
        null !== flags &&
          ((finishedWork.updateQueue = null),
          attachSuspenseRetryListeners(finishedWork, flags)));
      break;
    case 30:
      break;
    case 21:
      break;
    default:
      recursivelyTraverseMutationEffects(root, finishedWork),
        commitReconciliationEffects(finishedWork);
  }
}
function commitReconciliationEffects(finishedWork) {
  var flags = finishedWork.flags;
  if (flags & 2) {
    try {
      for (
        var hostParentFiber, parentFiber = finishedWork.return;
        null !== parentFiber;

      ) {
        if (isHostParent(parentFiber)) {
          hostParentFiber = parentFiber;
          break;
        }
        parentFiber = parentFiber.return;
      }
      if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
      switch (hostParentFiber.tag) {
        case 27:
          var parent = hostParentFiber.stateNode,
            before = getHostSibling(finishedWork);
          insertOrAppendPlacementNode(finishedWork, before, parent);
          break;
        case 5:
          var parent$141 = hostParentFiber.stateNode;
          hostParentFiber.flags & 32 &&
            (setTextContent(parent$141, ""), (hostParentFiber.flags &= -33));
          var before$142 = getHostSibling(finishedWork);
          insertOrAppendPlacementNode(finishedWork, before$142, parent$141);
          break;
        case 3:
        case 4:
          var parent$143 = hostParentFiber.stateNode.containerInfo,
            before$144 = getHostSibling(finishedWork);
          insertOrAppendPlacementNodeIntoContainer(
            finishedWork,
            before$144,
            parent$143
          );
          break;
        default:
          throw Error(formatProdErrorMessage(161));
      }
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
    finishedWork.flags &= -3;
  }
  flags & 4096 && (finishedWork.flags &= -4097);
}
function recursivelyResetForms(parentFiber) {
  if (parentFiber.subtreeFlags & 1024)
    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
      var fiber = parentFiber;
      recursivelyResetForms(fiber);
      5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
      parentFiber = parentFiber.sibling;
    }
}
function recursivelyTraverseLayoutEffects(root, parentFiber) {
  if (parentFiber.subtreeFlags & 8772)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),
        (parentFiber = parentFiber.sibling);
}
function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
    var finishedWork = parentFiber;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 1:
        safelyDetachRef(finishedWork, finishedWork.return);
        var instance = finishedWork.stateNode;
        "function" === typeof instance.componentWillUnmount &&
          safelyCallComponentWillUnmount(
            finishedWork,
            finishedWork.return,
            instance
          );
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 27:
        releaseSingletonInstance(finishedWork.stateNode);
      case 26:
      case 5:
        safelyDetachRef(finishedWork, finishedWork.return);
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 22:
        null === finishedWork.memoizedState &&
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 30:
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      default:
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
    }
    parentFiber = parentFiber.sibling;
  }
}
function recursivelyTraverseReappearLayoutEffects(
  finishedRoot$jscomp$0,
  parentFiber,
  includeWorkInProgressEffects
) {
  includeWorkInProgressEffects =
    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
    var current = parentFiber.alternate,
      finishedRoot = finishedRoot$jscomp$0,
      finishedWork = parentFiber,
      flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        commitHookEffectListMount(4, finishedWork);
        break;
      case 1:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        current = finishedWork;
        finishedRoot = current.stateNode;
        if ("function" === typeof finishedRoot.componentDidMount)
          try {
            finishedRoot.componentDidMount();
          } catch (error) {
            captureCommitPhaseError(current, current.return, error);
          }
        current = finishedWork;
        finishedRoot = current.updateQueue;
        if (null !== finishedRoot) {
          var instance = current.stateNode;
          try {
            var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
            if (null !== hiddenCallbacks)
              for (
                finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0;
                finishedRoot < hiddenCallbacks.length;
                finishedRoot++
              )
                callCallback(hiddenCallbacks[finishedRoot], instance);
          } catch (error) {
            captureCommitPhaseError(current, current.return, error);
          }
        }
        includeWorkInProgressEffects &&
          flags & 64 &&
          commitClassCallbacks(finishedWork);
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 27:
        commitHostSingletonAcquisition(finishedWork);
      case 26:
      case 5:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        includeWorkInProgressEffects &&
          null === current &&
          flags & 4 &&
          commitHostMount(finishedWork);
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 12:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        break;
      case 31:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        includeWorkInProgressEffects &&
          flags & 4 &&
          commitActivityHydrationCallbacks(finishedRoot, finishedWork);
        break;
      case 13:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        includeWorkInProgressEffects &&
          flags & 4 &&
          commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
        break;
      case 22:
        null === finishedWork.memoizedState &&
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 30:
        break;
      default:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
    }
    parentFiber = parentFiber.sibling;
  }
}
function commitOffscreenPassiveMountEffects(current, finishedWork) {
  var previousCache = null;
  null !== current &&
    null !== current.memoizedState &&
    null !== current.memoizedState.cachePool &&
    (previousCache = current.memoizedState.cachePool.pool);
  current = null;
  null !== finishedWork.memoizedState &&
    null !== finishedWork.memoizedState.cachePool &&
    (current = finishedWork.memoizedState.cachePool.pool);
  current !== previousCache &&
    (null != current && current.refCount++,
    null != previousCache && releaseCache(previousCache));
}
function commitCachePassiveMountEffect(current, finishedWork) {
  current = null;
  null !== finishedWork.alternate &&
    (current = finishedWork.alternate.memoizedState.cache);
  finishedWork = finishedWork.memoizedState.cache;
  finishedWork !== current &&
    (finishedWork.refCount++, null != current && releaseCache(current));
}
function recursivelyTraversePassiveMountEffects(
  root,
  parentFiber,
  committedLanes,
  committedTransitions
) {
  if (parentFiber.subtreeFlags & 10256)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      commitPassiveMountOnFiber(
        root,
        parentFiber,
        committedLanes,
        committedTransitions
      ),
        (parentFiber = parentFiber.sibling);
}
function commitPassiveMountOnFiber(
  finishedRoot,
  finishedWork,
  committedLanes,
  committedTransitions
) {
  var flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 15:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      flags & 2048 && commitHookEffectListMount(9, finishedWork);
      break;
    case 1:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      break;
    case 3:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      flags & 2048 &&
        ((finishedRoot = null),
        null !== finishedWork.alternate &&
          (finishedRoot = finishedWork.alternate.memoizedState.cache),
        (finishedWork = finishedWork.memoizedState.cache),
        finishedWork !== finishedRoot &&
          (finishedWork.refCount++,
          null != finishedRoot && releaseCache(finishedRoot)));
      break;
    case 12:
      if (flags & 2048) {
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
        finishedRoot = finishedWork.stateNode;
        try {
          var _finishedWork$memoize2 = finishedWork.memoizedProps,
            id = _finishedWork$memoize2.id,
            onPostCommit = _finishedWork$memoize2.onPostCommit;
          "function" === typeof onPostCommit &&
            onPostCommit(
              id,
              null === finishedWork.alternate ? "mount" : "update",
              finishedRoot.passiveEffectDuration,
              -0
            );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      } else
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
      break;
    case 31:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      break;
    case 13:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      break;
    case 23:
      break;
    case 22:
      _finishedWork$memoize2 = finishedWork.stateNode;
      id = finishedWork.alternate;
      null !== finishedWork.memoizedState
        ? _finishedWork$memoize2._visibility & 2
          ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            )
          : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork)
        : _finishedWork$memoize2._visibility & 2
          ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            )
          : ((_finishedWork$memoize2._visibility |= 2),
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              0 !== (finishedWork.subtreeFlags & 10256) || !1
            ));
      flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
      break;
    case 24:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      flags & 2048 &&
        commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
      break;
    default:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
  }
}
function recursivelyTraverseReconnectPassiveEffects(
  finishedRoot$jscomp$0,
  parentFiber,
  committedLanes$jscomp$0,
  committedTransitions$jscomp$0,
  includeWorkInProgressEffects
) {
  includeWorkInProgressEffects =
    includeWorkInProgressEffects &&
    (0 !== (parentFiber.subtreeFlags & 10256) || !1);
  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
    var finishedRoot = finishedRoot$jscomp$0,
      finishedWork = parentFiber,
      committedLanes = committedLanes$jscomp$0,
      committedTransitions = committedTransitions$jscomp$0,
      flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraverseReconnectPassiveEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          includeWorkInProgressEffects
        );
        commitHookEffectListMount(8, finishedWork);
        break;
      case 23:
        break;
      case 22:
        var instance = finishedWork.stateNode;
        null !== finishedWork.memoizedState
          ? instance._visibility & 2
            ? recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              )
            : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              )
          : ((instance._visibility |= 2),
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            ));
        includeWorkInProgressEffects &&
          flags & 2048 &&
          commitOffscreenPassiveMountEffects(
            finishedWork.alternate,
            finishedWork
          );
        break;
      case 24:
        recursivelyTraverseReconnectPassiveEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          includeWorkInProgressEffects
        );
        includeWorkInProgressEffects &&
          flags & 2048 &&
          commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
        break;
      default:
        recursivelyTraverseReconnectPassiveEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          includeWorkInProgressEffects
        );
    }
    parentFiber = parentFiber.sibling;
  }
}
function recursivelyTraverseAtomicPassiveEffects(
  finishedRoot$jscomp$0,
  parentFiber
) {
  if (parentFiber.subtreeFlags & 10256)
    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
      var finishedRoot = finishedRoot$jscomp$0,
        finishedWork = parentFiber,
        flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 22:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
          flags & 2048 &&
            commitOffscreenPassiveMountEffects(
              finishedWork.alternate,
              finishedWork
            );
          break;
        case 24:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
          flags & 2048 &&
            commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
      }
      parentFiber = parentFiber.sibling;
    }
}
var suspenseyCommitFlag = 8192;
function recursivelyAccumulateSuspenseyCommit(
  parentFiber,
  committedLanes,
  suspendedState
) {
  if (parentFiber.subtreeFlags & suspenseyCommitFlag)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      accumulateSuspenseyCommitOnFiber(
        parentFiber,
        committedLanes,
        suspendedState
      ),
        (parentFiber = parentFiber.sibling);
}
function accumulateSuspenseyCommitOnFiber(
  fiber,
  committedLanes,
  suspendedState
) {
  switch (fiber.tag) {
    case 26:
      recursivelyAccumulateSuspenseyCommit(
        fiber,
        committedLanes,
        suspendedState
      );
      fiber.flags & suspenseyCommitFlag &&
        null !== fiber.memoizedState &&
        suspendResource(
          suspendedState,
          currentHoistableRoot,
          fiber.memoizedState,
          fiber.memoizedProps
        );
      break;
    case 5:
      recursivelyAccumulateSuspenseyCommit(
        fiber,
        committedLanes,
        suspendedState
      );
      break;
    case 3:
    case 4:
      var previousHoistableRoot = currentHoistableRoot;
      currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
      recursivelyAccumulateSuspenseyCommit(
        fiber,
        committedLanes,
        suspendedState
      );
      currentHoistableRoot = previousHoistableRoot;
      break;
    case 22:
      null === fiber.memoizedState &&
        ((previousHoistableRoot = fiber.alternate),
        null !== previousHoistableRoot &&
        null !== previousHoistableRoot.memoizedState
          ? ((previousHoistableRoot = suspenseyCommitFlag),
            (suspenseyCommitFlag = 16777216),
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            ),
            (suspenseyCommitFlag = previousHoistableRoot))
          : recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            ));
      break;
    default:
      recursivelyAccumulateSuspenseyCommit(
        fiber,
        committedLanes,
        suspendedState
      );
  }
}
function detachAlternateSiblings(parentFiber) {
  var previousFiber = parentFiber.alternate;
  if (
    null !== previousFiber &&
    ((parentFiber = previousFiber.child), null !== parentFiber)
  ) {
    previousFiber.child = null;
    do
      (previousFiber = parentFiber.sibling),
        (parentFiber.sibling = null),
        (parentFiber = previousFiber);
    while (null !== parentFiber);
  }
}
function recursivelyTraversePassiveUnmountEffects(parentFiber) {
  var deletions = parentFiber.deletions;
  if (0 !== (parentFiber.flags & 16)) {
    if (null !== deletions)
      for (var i = 0; i < deletions.length; i++) {
        var childToDelete = deletions[i];
        nextEffect = childToDelete;
        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
          childToDelete,
          parentFiber
        );
      }
    detachAlternateSiblings(parentFiber);
  }
  if (parentFiber.subtreeFlags & 10256)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      commitPassiveUnmountOnFiber(parentFiber),
        (parentFiber = parentFiber.sibling);
}
function commitPassiveUnmountOnFiber(finishedWork) {
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 15:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      finishedWork.flags & 2048 &&
        commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
      break;
    case 3:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    case 12:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    case 22:
      var instance = finishedWork.stateNode;
      null !== finishedWork.memoizedState &&
      instance._visibility & 2 &&
      (null === finishedWork.return || 13 !== finishedWork.return.tag)
        ? ((instance._visibility &= -3),
          recursivelyTraverseDisconnectPassiveEffects(finishedWork))
        : recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    default:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
  }
}
function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
  var deletions = parentFiber.deletions;
  if (0 !== (parentFiber.flags & 16)) {
    if (null !== deletions)
      for (var i = 0; i < deletions.length; i++) {
        var childToDelete = deletions[i];
        nextEffect = childToDelete;
        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
          childToDelete,
          parentFiber
        );
      }
    detachAlternateSiblings(parentFiber);
  }
  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
    deletions = parentFiber;
    switch (deletions.tag) {
      case 0:
      case 11:
      case 15:
        commitHookEffectListUnmount(8, deletions, deletions.return);
        recursivelyTraverseDisconnectPassiveEffects(deletions);
        break;
      case 22:
        i = deletions.stateNode;
        i._visibility & 2 &&
          ((i._visibility &= -3),
          recursivelyTraverseDisconnectPassiveEffects(deletions));
        break;
      default:
        recursivelyTraverseDisconnectPassiveEffects(deletions);
    }
    parentFiber = parentFiber.sibling;
  }
}
function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
  deletedSubtreeRoot,
  nearestMountedAncestor
) {
  for (; null !== nextEffect; ) {
    var fiber = nextEffect;
    switch (fiber.tag) {
      case 0:
      case 11:
      case 15:
        commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
        break;
      case 23:
      case 22:
        if (
          null !== fiber.memoizedState &&
          null !== fiber.memoizedState.cachePool
        ) {
          var cache = fiber.memoizedState.cachePool.pool;
          null != cache && cache.refCount++;
        }
        break;
      case 24:
        releaseCache(fiber.memoizedState.cache);
    }
    cache = fiber.child;
    if (null !== cache) (cache.return = fiber), (nextEffect = cache);
    else
      a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
        cache = nextEffect;
        var sibling = cache.sibling,
          returnFiber = cache.return;
        detachFiberAfterEffects(cache);
        if (cache === fiber) {
          nextEffect = null;
          break a;
        }
        if (null !== sibling) {
          sibling.return = returnFiber;
          nextEffect = sibling;
          break a;
        }
        nextEffect = returnFiber;
      }
  }
}
var DefaultAsyncDispatcher = {
    getCacheForType: function (resourceType) {
      var cache = readContext(CacheContext),
        cacheForType = cache.data.get(resourceType);
      void 0 === cacheForType &&
        ((cacheForType = resourceType()),
        cache.data.set(resourceType, cacheForType));
      return cacheForType;
    },
    cacheSignal: function () {
      return readContext(CacheContext).controller.signal;
    }
  },
  PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
  executionContext = 0,
  workInProgressRoot = null,
  workInProgress = null,
  workInProgressRootRenderLanes = 0,
  workInProgressSuspendedReason = 0,
  workInProgressThrownValue = null,
  workInProgressRootDidSkipSuspendedSiblings = !1,
  workInProgressRootIsPrerendering = !1,
  workInProgressRootDidAttachPingListener = !1,
  entangledRenderLanes = 0,
  workInProgressRootExitStatus = 0,
  workInProgressRootSkippedLanes = 0,
  workInProgressRootInterleavedUpdatedLanes = 0,
  workInProgressRootPingedLanes = 0,
  workInProgressDeferredLane = 0,
  workInProgressSuspendedRetryLanes = 0,
  workInProgressRootConcurrentErrors = null,
  workInProgressRootRecoverableErrors = null,
  workInProgressRootDidIncludeRecursiveRenderUpdate = !1,
  globalMostRecentFallbackTime = 0,
  globalMostRecentTransitionTime = 0,
  workInProgressRootRenderTargetTime = Infinity,
  workInProgressTransitions = null,
  legacyErrorBoundariesThatAlreadyFailed = null,
  pendingEffectsStatus = 0,
  pendingEffectsRoot = null,
  pendingFinishedWork = null,
  pendingEffectsLanes = 0,
  pendingEffectsRemainingLanes = 0,
  pendingPassiveTransitions = null,
  pendingRecoverableErrors = null,
  nestedUpdateCount = 0,
  rootWithNestedUpdates = null;
function requestUpdateLane() {
  return 0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes
    ? workInProgressRootRenderLanes & -workInProgressRootRenderLanes
    : null !== ReactSharedInternals.T
      ? requestTransitionLane()
      : resolveUpdatePriority();
}
function requestDeferredLane() {
  if (0 === workInProgressDeferredLane)
    if (0 === (workInProgressRootRenderLanes & 536870912) || isHydrating) {
      var lane = nextTransitionDeferredLane;
      nextTransitionDeferredLane <<= 1;
      0 === (nextTransitionDeferredLane & 3932160) &&
        (nextTransitionDeferredLane = 262144);
      workInProgressDeferredLane = lane;
    } else workInProgressDeferredLane = 536870912;
  lane = suspenseHandlerStackCursor.current;
  null !== lane && (lane.flags |= 32);
  return workInProgressDeferredLane;
}
function scheduleUpdateOnFiber(root, fiber, lane) {
  if (
    (root === workInProgressRoot &&
      (2 === workInProgressSuspendedReason ||
        9 === workInProgressSuspendedReason)) ||
    null !== root.cancelPendingCommit
  )
    prepareFreshStack(root, 0),
      markRootSuspended(
        root,
        workInProgressRootRenderLanes,
        workInProgressDeferredLane,
        !1
      );
  markRootUpdated$1(root, lane);
  if (0 === (executionContext & 2) || root !== workInProgressRoot)
    root === workInProgressRoot &&
      (0 === (executionContext & 2) &&
        (workInProgressRootInterleavedUpdatedLanes |= lane),
      4 === workInProgressRootExitStatus &&
        markRootSuspended(
          root,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          !1
        )),
      ensureRootIsScheduled(root);
}
function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
  var shouldTimeSlice =
      (!forceSync &&
        0 === (lanes & 127) &&
        0 === (lanes & root$jscomp$0.expiredLanes)) ||
      checkIfRootIsPrerendering(root$jscomp$0, lanes),
    exitStatus = shouldTimeSlice
      ? renderRootConcurrent(root$jscomp$0, lanes)
      : renderRootSync(root$jscomp$0, lanes, !0),
    renderWasConcurrent = shouldTimeSlice;
  do {
    if (0 === exitStatus) {
      workInProgressRootIsPrerendering &&
        !shouldTimeSlice &&
        markRootSuspended(root$jscomp$0, lanes, 0, !1);
      break;
    } else {
      forceSync = root$jscomp$0.current.alternate;
      if (
        renderWasConcurrent &&
        !isRenderConsistentWithExternalStores(forceSync)
      ) {
        exitStatus = renderRootSync(root$jscomp$0, lanes, !1);
        renderWasConcurrent = !1;
        continue;
      }
      if (2 === exitStatus) {
        renderWasConcurrent = lanes;
        if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
          var JSCompiler_inline_result = 0;
        else
          (JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913),
            (JSCompiler_inline_result =
              0 !== JSCompiler_inline_result
                ? JSCompiler_inline_result
                : JSCompiler_inline_result & 536870912
                  ? 536870912
                  : 0);
        if (0 !== JSCompiler_inline_result) {
          lanes = JSCompiler_inline_result;
          a: {
            var root = root$jscomp$0;
            exitStatus = workInProgressRootConcurrentErrors;
            var wasRootDehydrated = root.current.memoizedState.isDehydrated;
            wasRootDehydrated &&
              (prepareFreshStack(root, JSCompiler_inline_result).flags |= 256);
            JSCompiler_inline_result = renderRootSync(
              root,
              JSCompiler_inline_result,
              !1
            );
            if (2 !== JSCompiler_inline_result) {
              if (
                workInProgressRootDidAttachPingListener &&
                !wasRootDehydrated
              ) {
                root.errorRecoveryDisabledLanes |= renderWasConcurrent;
                workInProgressRootInterleavedUpdatedLanes |=
                  renderWasConcurrent;
                exitStatus = 4;
                break a;
              }
              renderWasConcurrent = workInProgressRootRecoverableErrors;
              workInProgressRootRecoverableErrors = exitStatus;
              null !== renderWasConcurrent &&
                (null === workInProgressRootRecoverableErrors
                  ? (workInProgressRootRecoverableErrors = renderWasConcurrent)
                  : workInProgressRootRecoverableErrors.push.apply(
                      workInProgressRootRecoverableErrors,
                      renderWasConcurrent
                    ));
            }
            exitStatus = JSCompiler_inline_result;
          }
          renderWasConcurrent = !1;
          if (2 !== exitStatus) continue;
        }
      }
      if (1 === exitStatus) {
        prepareFreshStack(root$jscomp$0, 0);
        markRootSuspended(root$jscomp$0, lanes, 0, !0);
        break;
      }
      a: {
        shouldTimeSlice = root$jscomp$0;
        renderWasConcurrent = exitStatus;
        switch (renderWasConcurrent) {
          case 0:
          case 1:
            throw Error(formatProdErrorMessage(345));
          case 4:
            if ((lanes & 4194048) !== lanes) break;
          case 6:
            markRootSuspended(
              shouldTimeSlice,
              lanes,
              workInProgressDeferredLane,
              !workInProgressRootDidSkipSuspendedSiblings
            );
            break a;
          case 2:
            workInProgressRootRecoverableErrors = null;
            break;
          case 3:
          case 5:
            break;
          default:
            throw Error(formatProdErrorMessage(329));
        }
        if (
          (lanes & 62914560) === lanes &&
          ((exitStatus = globalMostRecentFallbackTime + 300 - now()),
          10 < exitStatus)
        ) {
          markRootSuspended(
            shouldTimeSlice,
            lanes,
            workInProgressDeferredLane,
            !workInProgressRootDidSkipSuspendedSiblings
          );
          if (0 !== getNextLanes(shouldTimeSlice, 0, !0)) break a;
          pendingEffectsLanes = lanes;
          shouldTimeSlice.timeoutHandle = scheduleTimeout(
            commitRootWhenReady.bind(
              null,
              shouldTimeSlice,
              forceSync,
              workInProgressRootRecoverableErrors,
              workInProgressTransitions,
              workInProgressRootDidIncludeRecursiveRenderUpdate,
              lanes,
              workInProgressDeferredLane,
              workInProgressRootInterleavedUpdatedLanes,
              workInProgressSuspendedRetryLanes,
              workInProgressRootDidSkipSuspendedSiblings,
              renderWasConcurrent,
              "Throttled",
              -0,
              0
            ),
            exitStatus
          );
          break a;
        }
        commitRootWhenReady(
          shouldTimeSlice,
          forceSync,
          workInProgressRootRecoverableErrors,
          workInProgressTransitions,
          workInProgressRootDidIncludeRecursiveRenderUpdate,
          lanes,
          workInProgressDeferredLane,
          workInProgressRootInterleavedUpdatedLanes,
          workInProgressSuspendedRetryLanes,
          workInProgressRootDidSkipSuspendedSiblings,
          renderWasConcurrent,
          null,
          -0,
          0
        );
      }
    }
    break;
  } while (1);
  ensureRootIsScheduled(root$jscomp$0);
}
function commitRootWhenReady(
  root,
  finishedWork,
  recoverableErrors,
  transitions,
  didIncludeRenderPhaseUpdate,
  lanes,
  spawnedLane,
  updatedLanes,
  suspendedRetryLanes,
  didSkipSuspendedSiblings,
  exitStatus,
  suspendedCommitReason,
  completedRenderStartTime,
  completedRenderEndTime
) {
  root.timeoutHandle = -1;
  suspendedCommitReason = finishedWork.subtreeFlags;
  if (
    suspendedCommitReason & 8192 ||
    16785408 === (suspendedCommitReason & 16785408)
  ) {
    suspendedCommitReason = {
      stylesheets: null,
      count: 0,
      imgCount: 0,
      imgBytes: 0,
      suspenseyImages: [],
      waitingForImages: !0,
      waitingForViewTransition: !1,
      unsuspend: noop$1
    };
    accumulateSuspenseyCommitOnFiber(
      finishedWork,
      lanes,
      suspendedCommitReason
    );
    var timeoutOffset =
      (lanes & 62914560) === lanes
        ? globalMostRecentFallbackTime - now()
        : (lanes & 4194048) === lanes
          ? globalMostRecentTransitionTime - now()
          : 0;
    timeoutOffset = waitForCommitToBeReady(
      suspendedCommitReason,
      timeoutOffset
    );
    if (null !== timeoutOffset) {
      pendingEffectsLanes = lanes;
      root.cancelPendingCommit = timeoutOffset(
        commitRoot.bind(
          null,
          root,
          finishedWork,
          lanes,
          recoverableErrors,
          transitions,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes,
          exitStatus,
          suspendedCommitReason,
          null,
          completedRenderStartTime,
          completedRenderEndTime
        )
      );
      markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);
      return;
    }
  }
  commitRoot(
    root,
    finishedWork,
    lanes,
    recoverableErrors,
    transitions,
    didIncludeRenderPhaseUpdate,
    spawnedLane,
    updatedLanes,
    suspendedRetryLanes
  );
}
function isRenderConsistentWithExternalStores(finishedWork) {
  for (var node = finishedWork; ; ) {
    var tag = node.tag;
    if (
      (0 === tag || 11 === tag || 15 === tag) &&
      node.flags & 16384 &&
      ((tag = node.updateQueue),
      null !== tag && ((tag = tag.stores), null !== tag))
    )
      for (var i = 0; i < tag.length; i++) {
        var check = tag[i],
          getSnapshot = check.getSnapshot;
        check = check.value;
        try {
          if (!objectIs(getSnapshot(), check)) return !1;
        } catch (error) {
          return !1;
        }
      }
    tag = node.child;
    if (node.subtreeFlags & 16384 && null !== tag)
      (tag.return = node), (node = tag);
    else {
      if (node === finishedWork) break;
      for (; null === node.sibling; ) {
        if (null === node.return || node.return === finishedWork) return !0;
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
  }
  return !0;
}
function markRootSuspended(
  root,
  suspendedLanes,
  spawnedLane,
  didAttemptEntireTree
) {
  suspendedLanes &= ~workInProgressRootPingedLanes;
  suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
  root.suspendedLanes |= suspendedLanes;
  root.pingedLanes &= ~suspendedLanes;
  didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
  didAttemptEntireTree = root.expirationTimes;
  for (var lanes = suspendedLanes; 0 < lanes; ) {
    var index$6 = 31 - clz32(lanes),
      lane = 1 << index$6;
    didAttemptEntireTree[index$6] = -1;
    lanes &= ~lane;
  }
  0 !== spawnedLane &&
    markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
}
function flushSyncWork$1() {
  return 0 === (executionContext & 6)
    ? (flushSyncWorkAcrossRoots_impl(0, !1), !1)
    : !0;
}
function resetWorkInProgressStack() {
  if (null !== workInProgress) {
    if (0 === workInProgressSuspendedReason)
      var interruptedWork = workInProgress.return;
    else
      (interruptedWork = workInProgress),
        (lastContextDependency = currentlyRenderingFiber$1 = null),
        resetHooksOnUnwind(interruptedWork),
        (thenableState$1 = null),
        (thenableIndexCounter$1 = 0),
        (interruptedWork = workInProgress);
    for (; null !== interruptedWork; )
      unwindInterruptedWork(interruptedWork.alternate, interruptedWork),
        (interruptedWork = interruptedWork.return);
    workInProgress = null;
  }
}
function prepareFreshStack(root, lanes) {
  var timeoutHandle = root.timeoutHandle;
  -1 !== timeoutHandle &&
    ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));
  timeoutHandle = root.cancelPendingCommit;
  null !== timeoutHandle &&
    ((root.cancelPendingCommit = null), timeoutHandle());
  pendingEffectsLanes = 0;
  resetWorkInProgressStack();
  workInProgressRoot = root;
  workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
  workInProgressRootRenderLanes = lanes;
  workInProgressSuspendedReason = 0;
  workInProgressThrownValue = null;
  workInProgressRootDidSkipSuspendedSiblings = !1;
  workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
  workInProgressRootDidAttachPingListener = !1;
  workInProgressSuspendedRetryLanes =
    workInProgressDeferredLane =
    workInProgressRootPingedLanes =
    workInProgressRootInterleavedUpdatedLanes =
    workInProgressRootSkippedLanes =
    workInProgressRootExitStatus =
      0;
  workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =
    null;
  workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
  0 !== (lanes & 8) && (lanes |= lanes & 32);
  var allEntangledLanes = root.entangledLanes;
  if (0 !== allEntangledLanes)
    for (
      root = root.entanglements, allEntangledLanes &= lanes;
      0 < allEntangledLanes;

    ) {
      var index$4 = 31 - clz32(allEntangledLanes),
        lane = 1 << index$4;
      lanes |= root[index$4];
      allEntangledLanes &= ~lane;
    }
  entangledRenderLanes = lanes;
  finishQueueingConcurrentUpdates();
  return timeoutHandle;
}
function handleThrow(root, thrownValue) {
  currentlyRenderingFiber = null;
  ReactSharedInternals.H = ContextOnlyDispatcher;
  thrownValue === SuspenseException || thrownValue === SuspenseActionException
    ? ((thrownValue = getSuspendedThenable()),
      (workInProgressSuspendedReason = 3))
    : thrownValue === SuspenseyCommitException
      ? ((thrownValue = getSuspendedThenable()),
        (workInProgressSuspendedReason = 4))
      : (workInProgressSuspendedReason =
          thrownValue === SelectiveHydrationException
            ? 8
            : null !== thrownValue &&
                "object" === typeof thrownValue &&
                "function" === typeof thrownValue.then
              ? 6
              : 1);
  workInProgressThrownValue = thrownValue;
  null === workInProgress &&
    ((workInProgressRootExitStatus = 1),
    logUncaughtError(
      root,
      createCapturedValueAtFiber(thrownValue, root.current)
    ));
}
function shouldRemainOnPreviousScreen() {
  var handler = suspenseHandlerStackCursor.current;
  return null === handler
    ? !0
    : (workInProgressRootRenderLanes & 4194048) ===
        workInProgressRootRenderLanes
      ? null === shellBoundary
        ? !0
        : !1
      : (workInProgressRootRenderLanes & 62914560) ===
            workInProgressRootRenderLanes ||
          0 !== (workInProgressRootRenderLanes & 536870912)
        ? handler === shellBoundary
        : !1;
}
function pushDispatcher() {
  var prevDispatcher = ReactSharedInternals.H;
  ReactSharedInternals.H = ContextOnlyDispatcher;
  return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
}
function pushAsyncDispatcher() {
  var prevAsyncDispatcher = ReactSharedInternals.A;
  ReactSharedInternals.A = DefaultAsyncDispatcher;
  return prevAsyncDispatcher;
}
function renderDidSuspendDelayIfPossible() {
  workInProgressRootExitStatus = 4;
  workInProgressRootDidSkipSuspendedSiblings ||
    ((workInProgressRootRenderLanes & 4194048) !==
      workInProgressRootRenderLanes &&
      null !== suspenseHandlerStackCursor.current) ||
    (workInProgressRootIsPrerendering = !0);
  (0 === (workInProgressRootSkippedLanes & 134217727) &&
    0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||
    null === workInProgressRoot ||
    markRootSuspended(
      workInProgressRoot,
      workInProgressRootRenderLanes,
      workInProgressDeferredLane,
      !1
    );
}
function renderRootSync(root, lanes, shouldYieldForPrerendering) {
  var prevExecutionContext = executionContext;
  executionContext |= 2;
  var prevDispatcher = pushDispatcher(),
    prevAsyncDispatcher = pushAsyncDispatcher();
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes)
    (workInProgressTransitions = null), prepareFreshStack(root, lanes);
  lanes = !1;
  var exitStatus = workInProgressRootExitStatus;
  a: do
    try {
      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
        var unitOfWork = workInProgress,
          thrownValue = workInProgressThrownValue;
        switch (workInProgressSuspendedReason) {
          case 8:
            resetWorkInProgressStack();
            exitStatus = 6;
            break a;
          case 3:
          case 2:
          case 9:
          case 6:
            null === suspenseHandlerStackCursor.current && (lanes = !0);
            var reason = workInProgressSuspendedReason;
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
            if (
              shouldYieldForPrerendering &&
              workInProgressRootIsPrerendering
            ) {
              exitStatus = 0;
              break a;
            }
            break;
          default:
            (reason = workInProgressSuspendedReason),
              (workInProgressSuspendedReason = 0),
              (workInProgressThrownValue = null),
              throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
        }
      }
      workLoopSync();
      exitStatus = workInProgressRootExitStatus;
      break;
    } catch (thrownValue$165) {
      handleThrow(root, thrownValue$165);
    }
  while (1);
  lanes && root.shellSuspendCounter++;
  lastContextDependency = currentlyRenderingFiber$1 = null;
  executionContext = prevExecutionContext;
  ReactSharedInternals.H = prevDispatcher;
  ReactSharedInternals.A = prevAsyncDispatcher;
  null === workInProgress &&
    ((workInProgressRoot = null),
    (workInProgressRootRenderLanes = 0),
    finishQueueingConcurrentUpdates());
  return exitStatus;
}
function workLoopSync() {
  for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
}
function renderRootConcurrent(root, lanes) {
  var prevExecutionContext = executionContext;
  executionContext |= 2;
  var prevDispatcher = pushDispatcher(),
    prevAsyncDispatcher = pushAsyncDispatcher();
  workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes
    ? ((workInProgressTransitions = null),
      (workInProgressRootRenderTargetTime = now() + 500),
      prepareFreshStack(root, lanes))
    : (workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
        root,
        lanes
      ));
  a: do
    try {
      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
        lanes = workInProgress;
        var thrownValue = workInProgressThrownValue;
        b: switch (workInProgressSuspendedReason) {
          case 1:
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, lanes, thrownValue, 1);
            break;
          case 2:
          case 9:
            if (isThenableResolved(thrownValue)) {
              workInProgressSuspendedReason = 0;
              workInProgressThrownValue = null;
              replaySuspendedUnitOfWork(lanes);
              break;
            }
            lanes = function () {
              (2 !== workInProgressSuspendedReason &&
                9 !== workInProgressSuspendedReason) ||
                workInProgressRoot !== root ||
                (workInProgressSuspendedReason = 7);
              ensureRootIsScheduled(root);
            };
            thrownValue.then(lanes, lanes);
            break a;
          case 3:
            workInProgressSuspendedReason = 7;
            break a;
          case 4:
            workInProgressSuspendedReason = 5;
            break a;
          case 7:
            isThenableResolved(thrownValue)
              ? ((workInProgressSuspendedReason = 0),
                (workInProgressThrownValue = null),
                replaySuspendedUnitOfWork(lanes))
              : ((workInProgressSuspendedReason = 0),
                (workInProgressThrownValue = null),
                throwAndUnwindWorkLoop(root, lanes, thrownValue, 7));
            break;
          case 5:
            var resource = null;
            switch (workInProgress.tag) {
              case 26:
                resource = workInProgress.memoizedState;
              case 5:
              case 27:
                var hostFiber = workInProgress;
                if (
                  resource
                    ? preloadResource(resource)
                    : hostFiber.stateNode.complete
                ) {
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  var sibling = hostFiber.sibling;
                  if (null !== sibling) workInProgress = sibling;
                  else {
                    var returnFiber = hostFiber.return;
                    null !== returnFiber
                      ? ((workInProgress = returnFiber),
                        completeUnitOfWork(returnFiber))
                      : (workInProgress = null);
                  }
                  break b;
                }
            }
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, lanes, thrownValue, 5);
            break;
          case 6:
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, lanes, thrownValue, 6);
            break;
          case 8:
            resetWorkInProgressStack();
            workInProgressRootExitStatus = 6;
            break a;
          default:
            throw Error(formatProdErrorMessage(462));
        }
      }
      workLoopConcurrentByScheduler();
      break;
    } catch (thrownValue$167) {
      handleThrow(root, thrownValue$167);
    }
  while (1);
  lastContextDependency = currentlyRenderingFiber$1 = null;
  ReactSharedInternals.H = prevDispatcher;
  ReactSharedInternals.A = prevAsyncDispatcher;
  executionContext = prevExecutionContext;
  if (null !== workInProgress) return 0;
  workInProgressRoot = null;
  workInProgressRootRenderLanes = 0;
  finishQueueingConcurrentUpdates();
  return workInProgressRootExitStatus;
}
function workLoopConcurrentByScheduler() {
  for (; null !== workInProgress && !shouldYield(); )
    performUnitOfWork(workInProgress);
}
function performUnitOfWork(unitOfWork) {
  var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
}
function replaySuspendedUnitOfWork(unitOfWork) {
  var next = unitOfWork;
  var current = next.alternate;
  switch (next.tag) {
    case 15:
    case 0:
      next = replayFunctionComponent(
        current,
        next,
        next.pendingProps,
        next.type,
        void 0,
        workInProgressRootRenderLanes
      );
      break;
    case 11:
      next = replayFunctionComponent(
        current,
        next,
        next.pendingProps,
        next.type.render,
        next.ref,
        workInProgressRootRenderLanes
      );
      break;
    case 5:
      resetHooksOnUnwind(next);
    default:
      unwindInterruptedWork(current, next),
        (next = workInProgress =
          resetWorkInProgress(next, entangledRenderLanes)),
        (next = beginWork(current, next, entangledRenderLanes));
  }
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
}
function throwAndUnwindWorkLoop(
  root,
  unitOfWork,
  thrownValue,
  suspendedReason
) {
  lastContextDependency = currentlyRenderingFiber$1 = null;
  resetHooksOnUnwind(unitOfWork);
  thenableState$1 = null;
  thenableIndexCounter$1 = 0;
  var returnFiber = unitOfWork.return;
  try {
    if (
      throwException(
        root,
        returnFiber,
        unitOfWork,
        thrownValue,
        workInProgressRootRenderLanes
      )
    ) {
      workInProgressRootExitStatus = 1;
      logUncaughtError(
        root,
        createCapturedValueAtFiber(thrownValue, root.current)
      );
      workInProgress = null;
      return;
    }
  } catch (error) {
    if (null !== returnFiber) throw ((workInProgress = returnFiber), error);
    workInProgressRootExitStatus = 1;
    logUncaughtError(
      root,
      createCapturedValueAtFiber(thrownValue, root.current)
    );
    workInProgress = null;
    return;
  }
  if (unitOfWork.flags & 32768) {
    if (isHydrating || 1 === suspendedReason) root = !0;
    else if (
      workInProgressRootIsPrerendering ||
      0 !== (workInProgressRootRenderLanes & 536870912)
    )
      root = !1;
    else if (
      ((workInProgressRootDidSkipSuspendedSiblings = root = !0),
      2 === suspendedReason ||
        9 === suspendedReason ||
        3 === suspendedReason ||
        6 === suspendedReason)
    )
      (suspendedReason = suspenseHandlerStackCursor.current),
        null !== suspendedReason &&
          13 === suspendedReason.tag &&
          (suspendedReason.flags |= 16384);
    unwindUnitOfWork(unitOfWork, root);
  } else completeUnitOfWork(unitOfWork);
}
function completeUnitOfWork(unitOfWork) {
  var completedWork = unitOfWork;
  do {
    if (0 !== (completedWork.flags & 32768)) {
      unwindUnitOfWork(
        completedWork,
        workInProgressRootDidSkipSuspendedSiblings
      );
      return;
    }
    unitOfWork = completedWork.return;
    var next = completeWork(
      completedWork.alternate,
      completedWork,
      entangledRenderLanes
    );
    if (null !== next) {
      workInProgress = next;
      return;
    }
    completedWork = completedWork.sibling;
    if (null !== completedWork) {
      workInProgress = completedWork;
      return;
    }
    workInProgress = completedWork = unitOfWork;
  } while (null !== completedWork);
  0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
}
function unwindUnitOfWork(unitOfWork, skipSiblings) {
  do {
    var next = unwindWork(unitOfWork.alternate, unitOfWork);
    if (null !== next) {
      next.flags &= 32767;
      workInProgress = next;
      return;
    }
    next = unitOfWork.return;
    null !== next &&
      ((next.flags |= 32768), (next.subtreeFlags = 0), (next.deletions = null));
    if (
      !skipSiblings &&
      ((unitOfWork = unitOfWork.sibling), null !== unitOfWork)
    ) {
      workInProgress = unitOfWork;
      return;
    }
    workInProgress = unitOfWork = next;
  } while (null !== unitOfWork);
  workInProgressRootExitStatus = 6;
  workInProgress = null;
}
function commitRoot(
  root,
  finishedWork,
  lanes,
  recoverableErrors,
  transitions,
  didIncludeRenderPhaseUpdate,
  spawnedLane,
  updatedLanes,
  suspendedRetryLanes
) {
  root.cancelPendingCommit = null;
  do flushPendingEffects();
  while (0 !== pendingEffectsStatus);
  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
  if (null !== finishedWork) {
    if (finishedWork === root.current) throw Error(formatProdErrorMessage(177));
    didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
    didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
    markRootFinished(
      root,
      lanes,
      didIncludeRenderPhaseUpdate,
      spawnedLane,
      updatedLanes,
      suspendedRetryLanes
    );
    root === workInProgressRoot &&
      ((workInProgress = workInProgressRoot = null),
      (workInProgressRootRenderLanes = 0));
    pendingFinishedWork = finishedWork;
    pendingEffectsRoot = root;
    pendingEffectsLanes = lanes;
    pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
    pendingPassiveTransitions = transitions;
    pendingRecoverableErrors = recoverableErrors;
    0 !== (finishedWork.subtreeFlags & 10256) ||
    0 !== (finishedWork.flags & 10256)
      ? ((root.callbackNode = null),
        (root.callbackPriority = 0),
        scheduleCallback$1(NormalPriority$1, function () {
          flushPassiveEffects();
          return null;
        }))
      : ((root.callbackNode = null), (root.callbackPriority = 0));
    recoverableErrors = 0 !== (finishedWork.flags & 13878);
    if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
      recoverableErrors = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      transitions = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 2;
      spawnedLane = executionContext;
      executionContext |= 4;
      try {
        commitBeforeMutationEffects(root, finishedWork, lanes);
      } finally {
        (executionContext = spawnedLane),
          (ReactDOMSharedInternals.p = transitions),
          (ReactSharedInternals.T = recoverableErrors);
      }
    }
    pendingEffectsStatus = 1;
    flushMutationEffects();
    flushLayoutEffects();
    flushSpawnedWork();
  }
}
function flushMutationEffects() {
  if (1 === pendingEffectsStatus) {
    pendingEffectsStatus = 0;
    var root = pendingEffectsRoot,
      finishedWork = pendingFinishedWork,
      rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
    if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
      rootMutationHasEffect = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 2;
      var prevExecutionContext = executionContext;
      executionContext |= 4;
      try {
        commitMutationEffectsOnFiber(finishedWork, root);
        var priorSelectionInformation = selectionInformation,
          curFocusedElem = getActiveElementDeep(root.containerInfo),
          priorFocusedElem = priorSelectionInformation.focusedElem,
          priorSelectionRange = priorSelectionInformation.selectionRange;
        if (
          curFocusedElem !== priorFocusedElem &&
          priorFocusedElem &&
          priorFocusedElem.ownerDocument &&
          containsNode(
            priorFocusedElem.ownerDocument.documentElement,
            priorFocusedElem
          )
        ) {
          if (
            null !== priorSelectionRange &&
            hasSelectionCapabilities(priorFocusedElem)
          ) {
            var start = priorSelectionRange.start,
              end = priorSelectionRange.end;
            void 0 === end && (end = start);
            if ("selectionStart" in priorFocusedElem)
              (priorFocusedElem.selectionStart = start),
                (priorFocusedElem.selectionEnd = Math.min(
                  end,
                  priorFocusedElem.value.length
                ));
            else {
              var doc = priorFocusedElem.ownerDocument || document,
                win = (doc && doc.defaultView) || window;
              if (win.getSelection) {
                var selection = win.getSelection(),
                  length = priorFocusedElem.textContent.length,
                  start$jscomp$0 = Math.min(priorSelectionRange.start, length),
                  end$jscomp$0 =
                    void 0 === priorSelectionRange.end
                      ? start$jscomp$0
                      : Math.min(priorSelectionRange.end, length);
                !selection.extend &&
                  start$jscomp$0 > end$jscomp$0 &&
                  ((curFocusedElem = end$jscomp$0),
                  (end$jscomp$0 = start$jscomp$0),
                  (start$jscomp$0 = curFocusedElem));
                var startMarker = getNodeForCharacterOffset(
                    priorFocusedElem,
                    start$jscomp$0
                  ),
                  endMarker = getNodeForCharacterOffset(
                    priorFocusedElem,
                    end$jscomp$0
                  );
                if (
                  startMarker &&
                  endMarker &&
                  (1 !== selection.rangeCount ||
                    selection.anchorNode !== startMarker.node ||
                    selection.anchorOffset !== startMarker.offset ||
                    selection.focusNode !== endMarker.node ||
                    selection.focusOffset !== endMarker.offset)
                ) {
                  var range = doc.createRange();
                  range.setStart(startMarker.node, startMarker.offset);
                  selection.removeAllRanges();
                  start$jscomp$0 > end$jscomp$0
                    ? (selection.addRange(range),
                      selection.extend(endMarker.node, endMarker.offset))
                    : (range.setEnd(endMarker.node, endMarker.offset),
                      selection.addRange(range));
                }
              }
            }
          }
          doc = [];
          for (
            selection = priorFocusedElem;
            (selection = selection.parentNode);

          )
            1 === selection.nodeType &&
              doc.push({
                element: selection,
                left: selection.scrollLeft,
                top: selection.scrollTop
              });
          "function" === typeof priorFocusedElem.focus &&
            priorFocusedElem.focus();
          for (
            priorFocusedElem = 0;
            priorFocusedElem < doc.length;
            priorFocusedElem++
          ) {
            var info = doc[priorFocusedElem];
            info.element.scrollLeft = info.left;
            info.element.scrollTop = info.top;
          }
        }
        _enabled = !!eventsEnabled;
        selectionInformation = eventsEnabled = null;
      } finally {
        (executionContext = prevExecutionContext),
          (ReactDOMSharedInternals.p = previousPriority),
          (ReactSharedInternals.T = rootMutationHasEffect);
      }
    }
    root.current = finishedWork;
    pendingEffectsStatus = 2;
  }
}
function flushLayoutEffects() {
  if (2 === pendingEffectsStatus) {
    pendingEffectsStatus = 0;
    var root = pendingEffectsRoot,
      finishedWork = pendingFinishedWork,
      rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
    if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
      rootHasLayoutEffect = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 2;
      var prevExecutionContext = executionContext;
      executionContext |= 4;
      try {
        commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);
      } finally {
        (executionContext = prevExecutionContext),
          (ReactDOMSharedInternals.p = previousPriority),
          (ReactSharedInternals.T = rootHasLayoutEffect);
      }
    }
    pendingEffectsStatus = 3;
  }
}
function flushSpawnedWork() {
  if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
    pendingEffectsStatus = 0;
    requestPaint();
    var root = pendingEffectsRoot,
      finishedWork = pendingFinishedWork,
      lanes = pendingEffectsLanes,
      recoverableErrors = pendingRecoverableErrors;
    0 !== (finishedWork.subtreeFlags & 10256) ||
    0 !== (finishedWork.flags & 10256)
      ? (pendingEffectsStatus = 5)
      : ((pendingEffectsStatus = 0),
        (pendingFinishedWork = pendingEffectsRoot = null),
        releaseRootPooledCache(root, root.pendingLanes));
    var remainingLanes = root.pendingLanes;
    0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
    lanesToEventPriority(lanes);
    finishedWork = finishedWork.stateNode;
    if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
      try {
        injectedHook.onCommitFiberRoot(
          rendererID,
          finishedWork,
          void 0,
          128 === (finishedWork.current.flags & 128)
        );
      } catch (err) {}
    if (null !== recoverableErrors) {
      finishedWork = ReactSharedInternals.T;
      remainingLanes = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 2;
      ReactSharedInternals.T = null;
      try {
        for (
          var onRecoverableError = root.onRecoverableError, i = 0;
          i < recoverableErrors.length;
          i++
        ) {
          var recoverableError = recoverableErrors[i];
          onRecoverableError(recoverableError.value, {
            componentStack: recoverableError.stack
          });
        }
      } finally {
        (ReactSharedInternals.T = finishedWork),
          (ReactDOMSharedInternals.p = remainingLanes);
      }
    }
    0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
    ensureRootIsScheduled(root);
    remainingLanes = root.pendingLanes;
    0 !== (lanes & 261930) && 0 !== (remainingLanes & 42)
      ? root === rootWithNestedUpdates
        ? nestedUpdateCount++
        : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root))
      : (nestedUpdateCount = 0);
    flushSyncWorkAcrossRoots_impl(0, !1);
  }
}
function releaseRootPooledCache(root, remainingLanes) {
  0 === (root.pooledCacheLanes &= remainingLanes) &&
    ((remainingLanes = root.pooledCache),
    null != remainingLanes &&
      ((root.pooledCache = null), releaseCache(remainingLanes)));
}
function flushPendingEffects() {
  flushMutationEffects();
  flushLayoutEffects();
  flushSpawnedWork();
  return flushPassiveEffects();
}
function flushPassiveEffects() {
  if (5 !== pendingEffectsStatus) return !1;
  var root = pendingEffectsRoot,
    remainingLanes = pendingEffectsRemainingLanes;
  pendingEffectsRemainingLanes = 0;
  var renderPriority = lanesToEventPriority(pendingEffectsLanes),
    prevTransition = ReactSharedInternals.T,
    previousPriority = ReactDOMSharedInternals.p;
  try {
    ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
    ReactSharedInternals.T = null;
    renderPriority = pendingPassiveTransitions;
    pendingPassiveTransitions = null;
    var root$jscomp$0 = pendingEffectsRoot,
      lanes = pendingEffectsLanes;
    pendingEffectsStatus = 0;
    pendingFinishedWork = pendingEffectsRoot = null;
    pendingEffectsLanes = 0;
    if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
    var prevExecutionContext = executionContext;
    executionContext |= 4;
    commitPassiveUnmountOnFiber(root$jscomp$0.current);
    commitPassiveMountOnFiber(
      root$jscomp$0,
      root$jscomp$0.current,
      lanes,
      renderPriority
    );
    executionContext = prevExecutionContext;
    flushSyncWorkAcrossRoots_impl(0, !1);
    if (
      injectedHook &&
      "function" === typeof injectedHook.onPostCommitFiberRoot
    )
      try {
        injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
      } catch (err) {}
    return !0;
  } finally {
    (ReactDOMSharedInternals.p = previousPriority),
      (ReactSharedInternals.T = prevTransition),
      releaseRootPooledCache(root, remainingLanes);
  }
}
function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
  sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
  rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
  null !== rootFiber &&
    (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
}
function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
  if (3 === sourceFiber.tag)
    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
  else
    for (; null !== nearestMountedAncestor; ) {
      if (3 === nearestMountedAncestor.tag) {
        captureCommitPhaseErrorOnRoot(
          nearestMountedAncestor,
          sourceFiber,
          error
        );
        break;
      } else if (1 === nearestMountedAncestor.tag) {
        var instance = nearestMountedAncestor.stateNode;
        if (
          "function" ===
            typeof nearestMountedAncestor.type.getDerivedStateFromError ||
          ("function" === typeof instance.componentDidCatch &&
            (null === legacyErrorBoundariesThatAlreadyFailed ||
              !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
        ) {
          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
          error = createClassErrorUpdate(2);
          instance = enqueueUpdate(nearestMountedAncestor, error, 2);
          null !== instance &&
            (initializeClassErrorUpdate(
              error,
              instance,
              nearestMountedAncestor,
              sourceFiber
            ),
            markRootUpdated$1(instance, 2),
            ensureRootIsScheduled(instance));
          break;
        }
      }
      nearestMountedAncestor = nearestMountedAncestor.return;
    }
}
function attachPingListener(root, wakeable, lanes) {
  var pingCache = root.pingCache;
  if (null === pingCache) {
    pingCache = root.pingCache = new PossiblyWeakMap();
    var threadIDs = new Set();
    pingCache.set(wakeable, threadIDs);
  } else
    (threadIDs = pingCache.get(wakeable)),
      void 0 === threadIDs &&
        ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));
  threadIDs.has(lanes) ||
    ((workInProgressRootDidAttachPingListener = !0),
    threadIDs.add(lanes),
    (root = pingSuspendedRoot.bind(null, root, wakeable, lanes)),
    wakeable.then(root, root));
}
function pingSuspendedRoot(root, wakeable, pingedLanes) {
  var pingCache = root.pingCache;
  null !== pingCache && pingCache.delete(wakeable);
  root.pingedLanes |= root.suspendedLanes & pingedLanes;
  root.warmLanes &= ~pingedLanes;
  workInProgressRoot === root &&
    (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
    (4 === workInProgressRootExitStatus ||
    (3 === workInProgressRootExitStatus &&
      (workInProgressRootRenderLanes & 62914560) ===
        workInProgressRootRenderLanes &&
      300 > now() - globalMostRecentFallbackTime)
      ? 0 === (executionContext & 2) && prepareFreshStack(root, 0)
      : (workInProgressRootPingedLanes |= pingedLanes),
    workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes &&
      (workInProgressSuspendedRetryLanes = 0));
  ensureRootIsScheduled(root);
}
function retryTimedOutBoundary(boundaryFiber, retryLane) {
  0 === retryLane && (retryLane = claimNextRetryLane());
  boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
  null !== boundaryFiber &&
    (markRootUpdated$1(boundaryFiber, retryLane),
    ensureRootIsScheduled(boundaryFiber));
}
function retryDehydratedSuspenseBoundary(boundaryFiber) {
  var suspenseState = boundaryFiber.memoizedState,
    retryLane = 0;
  null !== suspenseState && (retryLane = suspenseState.retryLane);
  retryTimedOutBoundary(boundaryFiber, retryLane);
}
function resolveRetryWakeable(boundaryFiber, wakeable) {
  var retryLane = 0;
  switch (boundaryFiber.tag) {
    case 31:
    case 13:
      var retryCache = boundaryFiber.stateNode;
      var suspenseState = boundaryFiber.memoizedState;
      null !== suspenseState && (retryLane = suspenseState.retryLane);
      break;
    case 19:
      retryCache = boundaryFiber.stateNode;
      break;
    case 22:
      retryCache = boundaryFiber.stateNode._retryCache;
      break;
    default:
      throw Error(formatProdErrorMessage(314));
  }
  null !== retryCache && retryCache.delete(wakeable);
  retryTimedOutBoundary(boundaryFiber, retryLane);
}
function scheduleCallback$1(priorityLevel, callback) {
  return scheduleCallback$3(priorityLevel, callback);
}
var firstScheduledRoot = null,
  lastScheduledRoot = null,
  didScheduleMicrotask = !1,
  mightHavePendingSyncWork = !1,
  isFlushingWork = !1,
  currentEventTransitionLane = 0;
function ensureRootIsScheduled(root) {
  root !== lastScheduledRoot &&
    null === root.next &&
    (null === lastScheduledRoot
      ? (firstScheduledRoot = lastScheduledRoot = root)
      : (lastScheduledRoot = lastScheduledRoot.next = root));
  mightHavePendingSyncWork = !0;
  didScheduleMicrotask ||
    ((didScheduleMicrotask = !0), scheduleImmediateRootScheduleTask());
}
function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
  if (!isFlushingWork && mightHavePendingSyncWork) {
    isFlushingWork = !0;
    do {
      var didPerformSomeWork = !1;
      for (var root$170 = firstScheduledRoot; null !== root$170; ) {
        if (!onlyLegacy)
          if (0 !== syncTransitionLanes) {
            var pendingLanes = root$170.pendingLanes;
            if (0 === pendingLanes) var JSCompiler_inline_result = 0;
            else {
              var suspendedLanes = root$170.suspendedLanes,
                pingedLanes = root$170.pingedLanes;
              JSCompiler_inline_result =
                (1 << (31 - clz32(42 | syncTransitionLanes) + 1)) - 1;
              JSCompiler_inline_result &=
                pendingLanes & ~(suspendedLanes & ~pingedLanes);
              JSCompiler_inline_result =
                JSCompiler_inline_result & 201326741
                  ? (JSCompiler_inline_result & 201326741) | 1
                  : JSCompiler_inline_result
                    ? JSCompiler_inline_result | 2
                    : 0;
            }
            0 !== JSCompiler_inline_result &&
              ((didPerformSomeWork = !0),
              performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
          } else
            (JSCompiler_inline_result = workInProgressRootRenderLanes),
              (JSCompiler_inline_result = getNextLanes(
                root$170,
                root$170 === workInProgressRoot ? JSCompiler_inline_result : 0,
                null !== root$170.cancelPendingCommit ||
                  -1 !== root$170.timeoutHandle
              )),
              0 === (JSCompiler_inline_result & 3) ||
                checkIfRootIsPrerendering(root$170, JSCompiler_inline_result) ||
                ((didPerformSomeWork = !0),
                performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
        root$170 = root$170.next;
      }
    } while (didPerformSomeWork);
    isFlushingWork = !1;
  }
}
function processRootScheduleInImmediateTask() {
  processRootScheduleInMicrotask();
}
function processRootScheduleInMicrotask() {
  mightHavePendingSyncWork = didScheduleMicrotask = !1;
  var syncTransitionLanes = 0;
  0 !== currentEventTransitionLane &&
    shouldAttemptEagerTransition() &&
    (syncTransitionLanes = currentEventTransitionLane);
  for (
    var currentTime = now(), prev = null, root = firstScheduledRoot;
    null !== root;

  ) {
    var next = root.next,
      nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
    if (0 === nextLanes)
      (root.next = null),
        null === prev ? (firstScheduledRoot = next) : (prev.next = next),
        null === next && (lastScheduledRoot = prev);
    else if (
      ((prev = root), 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
    )
      mightHavePendingSyncWork = !0;
    root = next;
  }
  (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus) ||
    flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);
  0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);
}
function scheduleTaskForRootDuringMicrotask(root, currentTime) {
  for (
    var suspendedLanes = root.suspendedLanes,
      pingedLanes = root.pingedLanes,
      expirationTimes = root.expirationTimes,
      lanes = root.pendingLanes & -62914561;
    0 < lanes;

  ) {
    var index$5 = 31 - clz32(lanes),
      lane = 1 << index$5,
      expirationTime = expirationTimes[index$5];
    if (-1 === expirationTime) {
      if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
        expirationTimes[index$5] = computeExpirationTime(lane, currentTime);
    } else expirationTime <= currentTime && (root.expiredLanes |= lane);
    lanes &= ~lane;
  }
  currentTime = workInProgressRoot;
  suspendedLanes = workInProgressRootRenderLanes;
  suspendedLanes = getNextLanes(
    root,
    root === currentTime ? suspendedLanes : 0,
    null !== root.cancelPendingCommit || -1 !== root.timeoutHandle
  );
  pingedLanes = root.callbackNode;
  if (
    0 === suspendedLanes ||
    (root === currentTime &&
      (2 === workInProgressSuspendedReason ||
        9 === workInProgressSuspendedReason)) ||
    null !== root.cancelPendingCommit
  )
    return (
      null !== pingedLanes &&
        null !== pingedLanes &&
        cancelCallback$1(pingedLanes),
      (root.callbackNode = null),
      (root.callbackPriority = 0)
    );
  if (
    0 === (suspendedLanes & 3) ||
    checkIfRootIsPrerendering(root, suspendedLanes)
  ) {
    currentTime = suspendedLanes & -suspendedLanes;
    if (currentTime === root.callbackPriority) return currentTime;
    null !== pingedLanes && cancelCallback$1(pingedLanes);
    switch (lanesToEventPriority(suspendedLanes)) {
      case 2:
      case 8:
        suspendedLanes = UserBlockingPriority;
        break;
      case 32:
        suspendedLanes = NormalPriority$1;
        break;
      case 268435456:
        suspendedLanes = IdlePriority;
        break;
      default:
        suspendedLanes = NormalPriority$1;
    }
    pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
    suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
    root.callbackPriority = currentTime;
    root.callbackNode = suspendedLanes;
    return currentTime;
  }
  null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
  root.callbackPriority = 2;
  root.callbackNode = null;
  return 2;
}
function performWorkOnRootViaSchedulerTask(root, didTimeout) {
  if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
    return (root.callbackNode = null), (root.callbackPriority = 0), null;
  var originalCallbackNode = root.callbackNode;
  if (flushPendingEffects() && root.callbackNode !== originalCallbackNode)
    return null;
  var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
  workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
    root,
    root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
    null !== root.cancelPendingCommit || -1 !== root.timeoutHandle
  );
  if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
  performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);
  scheduleTaskForRootDuringMicrotask(root, now());
  return null != root.callbackNode && root.callbackNode === originalCallbackNode
    ? performWorkOnRootViaSchedulerTask.bind(null, root)
    : null;
}
function performSyncWorkOnRoot(root, lanes) {
  if (flushPendingEffects()) return null;
  performWorkOnRoot(root, lanes, !0);
}
function scheduleImmediateRootScheduleTask() {
  scheduleMicrotask(function () {
    0 !== (executionContext & 6)
      ? scheduleCallback$3(
          ImmediatePriority,
          processRootScheduleInImmediateTask
        )
      : processRootScheduleInMicrotask();
  });
}
function requestTransitionLane() {
  if (0 === currentEventTransitionLane) {
    var actionScopeLane = currentEntangledLane;
    0 === actionScopeLane &&
      ((actionScopeLane = nextTransitionUpdateLane),
      (nextTransitionUpdateLane <<= 1),
      0 === (nextTransitionUpdateLane & 261888) &&
        (nextTransitionUpdateLane = 256));
    currentEventTransitionLane = actionScopeLane;
  }
  return currentEventTransitionLane;
}
function coerceFormActionProp(actionProp) {
  return null == actionProp ||
    "symbol" === typeof actionProp ||
    "boolean" === typeof actionProp
    ? null
    : "function" === typeof actionProp
      ? actionProp
      : sanitizeURL("" + actionProp);
}
function createFormDataWithSubmitter(form, submitter) {
  var temp = submitter.ownerDocument.createElement("input");
  temp.name = submitter.name;
  temp.value = submitter.value;
  form.id && temp.setAttribute("form", form.id);
  submitter.parentNode.insertBefore(temp, submitter);
  form = new FormData(form);
  temp.parentNode.removeChild(temp);
  return form;
}
function extractEvents$1(
  dispatchQueue,
  domEventName,
  maybeTargetInst,
  nativeEvent,
  nativeEventTarget
) {
  if (
    "submit" === domEventName &&
    maybeTargetInst &&
    maybeTargetInst.stateNode === nativeEventTarget
  ) {
    var action = coerceFormActionProp(
        (nativeEventTarget[internalPropsKey] || null).action
      ),
      submitter = nativeEvent.submitter;
    submitter &&
      ((domEventName = (domEventName = submitter[internalPropsKey] || null)
        ? coerceFormActionProp(domEventName.formAction)
        : submitter.getAttribute("formAction")),
      null !== domEventName && ((action = domEventName), (submitter = null)));
    var event = new SyntheticEvent(
      "action",
      "action",
      null,
      nativeEvent,
      nativeEventTarget
    );
    dispatchQueue.push({
      event: event,
      listeners: [
        {
          instance: null,
          listener: function () {
            if (nativeEvent.defaultPrevented) {
              if (0 !== currentEventTransitionLane) {
                var formData = submitter
                  ? createFormDataWithSubmitter(nativeEventTarget, submitter)
                  : new FormData(nativeEventTarget);
                startHostTransition(
                  maybeTargetInst,
                  {
                    pending: !0,
                    data: formData,
                    method: nativeEventTarget.method,
                    action: action
                  },
                  null,
                  formData
                );
              }
            } else
              "function" === typeof action &&
                (event.preventDefault(),
                (formData = submitter
                  ? createFormDataWithSubmitter(nativeEventTarget, submitter)
                  : new FormData(nativeEventTarget)),
                startHostTransition(
                  maybeTargetInst,
                  {
                    pending: !0,
                    data: formData,
                    method: nativeEventTarget.method,
                    action: action
                  },
                  action,
                  formData
                ));
          },
          currentTarget: nativeEventTarget
        }
      ]
    });
  }
}
for (
  var i$jscomp$inline_1577 = 0;
  i$jscomp$inline_1577 < simpleEventPluginEvents.length;
  i$jscomp$inline_1577++
) {
  var eventName$jscomp$inline_1578 =
      simpleEventPluginEvents[i$jscomp$inline_1577],
    domEventName$jscomp$inline_1579 =
      eventName$jscomp$inline_1578.toLowerCase(),
    capitalizedEvent$jscomp$inline_1580 =
      eventName$jscomp$inline_1578[0].toUpperCase() +
      eventName$jscomp$inline_1578.slice(1);
  registerSimpleEvent(
    domEventName$jscomp$inline_1579,
    "on" + capitalizedEvent$jscomp$inline_1580
  );
}
registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
registerSimpleEvent(ANIMATION_START, "onAnimationStart");
registerSimpleEvent("dblclick", "onDoubleClick");
registerSimpleEvent("focusin", "onFocus");
registerSimpleEvent("focusout", "onBlur");
registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
registerSimpleEvent(TRANSITION_START, "onTransitionStart");
registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
registerTwoPhaseEvent(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
registerTwoPhaseEvent(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
registerTwoPhaseEvent("onBeforeInput", [
  "compositionend",
  "keypress",
  "textInput",
  "paste"
]);
registerTwoPhaseEvent(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
registerTwoPhaseEvent(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
registerTwoPhaseEvent(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var mediaEventTypes =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  nonDelegatedEvents = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle"
      .split(" ")
      .concat(mediaEventTypes)
  );
function processDispatchQueue(dispatchQueue, eventSystemFlags) {
  eventSystemFlags = 0 !== (eventSystemFlags & 4);
  for (var i = 0; i < dispatchQueue.length; i++) {
    var _dispatchQueue$i = dispatchQueue[i],
      event = _dispatchQueue$i.event;
    _dispatchQueue$i = _dispatchQueue$i.listeners;
    a: {
      var previousInstance = void 0;
      if (eventSystemFlags)
        for (
          var i$jscomp$0 = _dispatchQueue$i.length - 1;
          0 <= i$jscomp$0;
          i$jscomp$0--
        ) {
          var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],
            instance = _dispatchListeners$i.instance,
            currentTarget = _dispatchListeners$i.currentTarget;
          _dispatchListeners$i = _dispatchListeners$i.listener;
          if (instance !== previousInstance && event.isPropagationStopped())
            break a;
          previousInstance = _dispatchListeners$i;
          event.currentTarget = currentTarget;
          try {
            previousInstance(event);
          } catch (error) {
            reportGlobalError(error);
          }
          event.currentTarget = null;
          previousInstance = instance;
        }
      else
        for (
          i$jscomp$0 = 0;
          i$jscomp$0 < _dispatchQueue$i.length;
          i$jscomp$0++
        ) {
          _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
          instance = _dispatchListeners$i.instance;
          currentTarget = _dispatchListeners$i.currentTarget;
          _dispatchListeners$i = _dispatchListeners$i.listener;
          if (instance !== previousInstance && event.isPropagationStopped())
            break a;
          previousInstance = _dispatchListeners$i;
          event.currentTarget = currentTarget;
          try {
            previousInstance(event);
          } catch (error) {
            reportGlobalError(error);
          }
          event.currentTarget = null;
          previousInstance = instance;
        }
    }
  }
}
function listenToNonDelegatedEvent(domEventName, targetElement) {
  var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
  void 0 === JSCompiler_inline_result &&
    (JSCompiler_inline_result = targetElement[internalEventHandlersKey] =
      new Set());
  var listenerSetKey = domEventName + "__bubble";
  JSCompiler_inline_result.has(listenerSetKey) ||
    (addTrappedEventListener(targetElement, domEventName, 2, !1),
    JSCompiler_inline_result.add(listenerSetKey));
}
function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
  var eventSystemFlags = 0;
  isCapturePhaseListener && (eventSystemFlags |= 4);
  addTrappedEventListener(
    target,
    domEventName,
    eventSystemFlags,
    isCapturePhaseListener
  );
}
var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
function listenToAllSupportedEvents(rootContainerElement) {
  if (!rootContainerElement[listeningMarker]) {
    rootContainerElement[listeningMarker] = !0;
    allNativeEvents.forEach(function (domEventName) {
      "selectionchange" !== domEventName &&
        (nonDelegatedEvents.has(domEventName) ||
          listenToNativeEvent(domEventName, !1, rootContainerElement),
        listenToNativeEvent(domEventName, !0, rootContainerElement));
    });
    var ownerDocument =
      9 === rootContainerElement.nodeType
        ? rootContainerElement
        : rootContainerElement.ownerDocument;
    null === ownerDocument ||
      ownerDocument[listeningMarker] ||
      ((ownerDocument[listeningMarker] = !0),
      listenToNativeEvent("selectionchange", !1, ownerDocument));
  }
}
function addTrappedEventListener(
  targetContainer,
  domEventName,
  eventSystemFlags,
  isCapturePhaseListener
) {
  switch (getEventPriority(domEventName)) {
    case 2:
      var listenerWrapper = dispatchDiscreteEvent;
      break;
    case 8:
      listenerWrapper = dispatchContinuousEvent;
      break;
    default:
      listenerWrapper = dispatchEvent;
  }
  eventSystemFlags = listenerWrapper.bind(
    null,
    domEventName,
    eventSystemFlags,
    targetContainer
  );
  listenerWrapper = void 0;
  !passiveBrowserEventsSupported ||
    ("touchstart" !== domEventName &&
      "touchmove" !== domEventName &&
      "wheel" !== domEventName) ||
    (listenerWrapper = !0);
  isCapturePhaseListener
    ? void 0 !== listenerWrapper
      ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          capture: !0,
          passive: listenerWrapper
        })
      : targetContainer.addEventListener(domEventName, eventSystemFlags, !0)
    : void 0 !== listenerWrapper
      ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          passive: listenerWrapper
        })
      : targetContainer.addEventListener(domEventName, eventSystemFlags, !1);
}
function dispatchEventForPluginEventSystem(
  domEventName,
  eventSystemFlags,
  nativeEvent,
  targetInst$jscomp$0,
  targetContainer
) {
  var ancestorInst = targetInst$jscomp$0;
  if (
    0 === (eventSystemFlags & 1) &&
    0 === (eventSystemFlags & 2) &&
    null !== targetInst$jscomp$0
  )
    a: for (;;) {
      if (null === targetInst$jscomp$0) return;
      var nodeTag = targetInst$jscomp$0.tag;
      if (3 === nodeTag || 4 === nodeTag) {
        var container = targetInst$jscomp$0.stateNode.containerInfo;
        if (container === targetContainer) break;
        if (4 === nodeTag)
          for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
            var grandTag = nodeTag.tag;
            if (
              (3 === grandTag || 4 === grandTag) &&
              nodeTag.stateNode.containerInfo === targetContainer
            )
              return;
            nodeTag = nodeTag.return;
          }
        for (; null !== container; ) {
          nodeTag = getClosestInstanceFromNode(container);
          if (null === nodeTag) return;
          grandTag = nodeTag.tag;
          if (
            5 === grandTag ||
            6 === grandTag ||
            26 === grandTag ||
            27 === grandTag
          ) {
            targetInst$jscomp$0 = ancestorInst = nodeTag;
            continue a;
          }
          container = container.parentNode;
        }
      }
      targetInst$jscomp$0 = targetInst$jscomp$0.return;
    }
  batchedUpdates$1(function () {
    var targetInst = ancestorInst,
      nativeEventTarget = getEventTarget(nativeEvent),
      dispatchQueue = [];
    a: {
      var reactName = topLevelEventsToReactNames.get(domEventName);
      if (void 0 !== reactName) {
        var SyntheticEventCtor = SyntheticEvent,
          reactEventType = domEventName;
        switch (domEventName) {
          case "keypress":
            if (0 === getEventCharCode(nativeEvent)) break a;
          case "keydown":
          case "keyup":
            SyntheticEventCtor = SyntheticKeyboardEvent;
            break;
          case "focusin":
            reactEventType = "focus";
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "focusout":
            reactEventType = "blur";
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "beforeblur":
          case "afterblur":
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "click":
            if (2 === nativeEvent.button) break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            SyntheticEventCtor = SyntheticMouseEvent;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            SyntheticEventCtor = SyntheticDragEvent;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            SyntheticEventCtor = SyntheticTouchEvent;
            break;
          case ANIMATION_END:
          case ANIMATION_ITERATION:
          case ANIMATION_START:
            SyntheticEventCtor = SyntheticAnimationEvent;
            break;
          case TRANSITION_END:
            SyntheticEventCtor = SyntheticTransitionEvent;
            break;
          case "scroll":
          case "scrollend":
            SyntheticEventCtor = SyntheticUIEvent;
            break;
          case "wheel":
            SyntheticEventCtor = SyntheticWheelEvent;
            break;
          case "copy":
          case "cut":
          case "paste":
            SyntheticEventCtor = SyntheticClipboardEvent;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            SyntheticEventCtor = SyntheticPointerEvent;
            break;
          case "toggle":
          case "beforetoggle":
            SyntheticEventCtor = SyntheticToggleEvent;
        }
        var inCapturePhase = 0 !== (eventSystemFlags & 4),
          accumulateTargetOnly =
            !inCapturePhase &&
            ("scroll" === domEventName || "scrollend" === domEventName),
          reactEventName = inCapturePhase
            ? null !== reactName
              ? reactName + "Capture"
              : null
            : reactName;
        inCapturePhase = [];
        for (
          var instance = targetInst, lastHostComponent;
          null !== instance;

        ) {
          var _instance = instance;
          lastHostComponent = _instance.stateNode;
          _instance = _instance.tag;
          (5 !== _instance && 26 !== _instance && 27 !== _instance) ||
            null === lastHostComponent ||
            null === reactEventName ||
            ((_instance = getListener(instance, reactEventName)),
            null != _instance &&
              inCapturePhase.push(
                createDispatchListener(instance, _instance, lastHostComponent)
              ));
          if (accumulateTargetOnly) break;
          instance = instance.return;
        }
        0 < inCapturePhase.length &&
          ((reactName = new SyntheticEventCtor(
            reactName,
            reactEventType,
            null,
            nativeEvent,
            nativeEventTarget
          )),
          dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
      }
    }
    if (0 === (eventSystemFlags & 7)) {
      a: {
        reactName =
          "mouseover" === domEventName || "pointerover" === domEventName;
        SyntheticEventCtor =
          "mouseout" === domEventName || "pointerout" === domEventName;
        if (
          reactName &&
          nativeEvent !== currentReplayingEvent &&
          (reactEventType =
            nativeEvent.relatedTarget || nativeEvent.fromElement) &&
          (getClosestInstanceFromNode(reactEventType) ||
            reactEventType[internalContainerInstanceKey])
        )
          break a;
        if (SyntheticEventCtor || reactName) {
          reactName =
            nativeEventTarget.window === nativeEventTarget
              ? nativeEventTarget
              : (reactName = nativeEventTarget.ownerDocument)
                ? reactName.defaultView || reactName.parentWindow
                : window;
          if (SyntheticEventCtor) {
            if (
              ((reactEventType =
                nativeEvent.relatedTarget || nativeEvent.toElement),
              (SyntheticEventCtor = targetInst),
              (reactEventType = reactEventType
                ? getClosestInstanceFromNode(reactEventType)
                : null),
              null !== reactEventType &&
                ((accumulateTargetOnly =
                  getNearestMountedFiber(reactEventType)),
                (inCapturePhase = reactEventType.tag),
                reactEventType !== accumulateTargetOnly ||
                  (5 !== inCapturePhase &&
                    27 !== inCapturePhase &&
                    6 !== inCapturePhase)))
            )
              reactEventType = null;
          } else (SyntheticEventCtor = null), (reactEventType = targetInst);
          if (SyntheticEventCtor !== reactEventType) {
            inCapturePhase = SyntheticMouseEvent;
            _instance = "onMouseLeave";
            reactEventName = "onMouseEnter";
            instance = "mouse";
            if ("pointerout" === domEventName || "pointerover" === domEventName)
              (inCapturePhase = SyntheticPointerEvent),
                (_instance = "onPointerLeave"),
                (reactEventName = "onPointerEnter"),
                (instance = "pointer");
            accumulateTargetOnly =
              null == SyntheticEventCtor
                ? reactName
                : getNodeFromInstance(SyntheticEventCtor);
            lastHostComponent =
              null == reactEventType
                ? reactName
                : getNodeFromInstance(reactEventType);
            reactName = new inCapturePhase(
              _instance,
              instance + "leave",
              SyntheticEventCtor,
              nativeEvent,
              nativeEventTarget
            );
            reactName.target = accumulateTargetOnly;
            reactName.relatedTarget = lastHostComponent;
            _instance = null;
            getClosestInstanceFromNode(nativeEventTarget) === targetInst &&
              ((inCapturePhase = new inCapturePhase(
                reactEventName,
                instance + "enter",
                reactEventType,
                nativeEvent,
                nativeEventTarget
              )),
              (inCapturePhase.target = lastHostComponent),
              (inCapturePhase.relatedTarget = accumulateTargetOnly),
              (_instance = inCapturePhase));
            accumulateTargetOnly = _instance;
            if (SyntheticEventCtor && reactEventType)
              b: {
                inCapturePhase = getParent;
                reactEventName = SyntheticEventCtor;
                instance = reactEventType;
                lastHostComponent = 0;
                for (
                  _instance = reactEventName;
                  _instance;
                  _instance = inCapturePhase(_instance)
                )
                  lastHostComponent++;
                _instance = 0;
                for (var tempB = instance; tempB; tempB = inCapturePhase(tempB))
                  _instance++;
                for (; 0 < lastHostComponent - _instance; )
                  (reactEventName = inCapturePhase(reactEventName)),
                    lastHostComponent--;
                for (; 0 < _instance - lastHostComponent; )
                  (instance = inCapturePhase(instance)), _instance--;
                for (; lastHostComponent--; ) {
                  if (
                    reactEventName === instance ||
                    (null !== instance && reactEventName === instance.alternate)
                  ) {
                    inCapturePhase = reactEventName;
                    break b;
                  }
                  reactEventName = inCapturePhase(reactEventName);
                  instance = inCapturePhase(instance);
                }
                inCapturePhase = null;
              }
            else inCapturePhase = null;
            null !== SyntheticEventCtor &&
              accumulateEnterLeaveListenersForEvent(
                dispatchQueue,
                reactName,
                SyntheticEventCtor,
                inCapturePhase,
                !1
              );
            null !== reactEventType &&
              null !== accumulateTargetOnly &&
              accumulateEnterLeaveListenersForEvent(
                dispatchQueue,
                accumulateTargetOnly,
                reactEventType,
                inCapturePhase,
                !0
              );
          }
        }
      }
      a: {
        reactName = targetInst ? getNodeFromInstance(targetInst) : window;
        SyntheticEventCtor =
          reactName.nodeName && reactName.nodeName.toLowerCase();
        if (
          "select" === SyntheticEventCtor ||
          ("input" === SyntheticEventCtor && "file" === reactName.type)
        )
          var getTargetInstFunc = getTargetInstForChangeEvent;
        else if (isTextInputElement(reactName))
          if (isInputEventSupported)
            getTargetInstFunc = getTargetInstForInputOrChangeEvent;
          else {
            getTargetInstFunc = getTargetInstForInputEventPolyfill;
            var handleEventFunc = handleEventsForInputEventPolyfill;
          }
        else
          (SyntheticEventCtor = reactName.nodeName),
            !SyntheticEventCtor ||
            "input" !== SyntheticEventCtor.toLowerCase() ||
            ("checkbox" !== reactName.type && "radio" !== reactName.type)
              ? targetInst &&
                isCustomElement(targetInst.elementType) &&
                (getTargetInstFunc = getTargetInstForChangeEvent)
              : (getTargetInstFunc = getTargetInstForClickEvent);
        if (
          getTargetInstFunc &&
          (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))
        ) {
          createAndAccumulateChangeEvent(
            dispatchQueue,
            getTargetInstFunc,
            nativeEvent,
            nativeEventTarget
          );
          break a;
        }
        handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
        "focusout" === domEventName &&
          targetInst &&
          "number" === reactName.type &&
          null != targetInst.memoizedProps.value &&
          setDefaultValue(reactName, "number", reactName.value);
      }
      handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
      switch (domEventName) {
        case "focusin":
          if (
            isTextInputElement(handleEventFunc) ||
            "true" === handleEventFunc.contentEditable
          )
            (activeElement = handleEventFunc),
              (activeElementInst = targetInst),
              (lastSelection = null);
          break;
        case "focusout":
          lastSelection = activeElementInst = activeElement = null;
          break;
        case "mousedown":
          mouseDown = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          mouseDown = !1;
          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          break;
        case "selectionchange":
          if (skipSelectionChangeEvent) break;
        case "keydown":
        case "keyup":
          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
      }
      var fallbackData;
      if (canUseCompositionEvent)
        b: {
          switch (domEventName) {
            case "compositionstart":
              var eventType = "onCompositionStart";
              break b;
            case "compositionend":
              eventType = "onCompositionEnd";
              break b;
            case "compositionupdate":
              eventType = "onCompositionUpdate";
              break b;
          }
          eventType = void 0;
        }
      else
        isComposing
          ? isFallbackCompositionEnd(domEventName, nativeEvent) &&
            (eventType = "onCompositionEnd")
          : "keydown" === domEventName &&
            229 === nativeEvent.keyCode &&
            (eventType = "onCompositionStart");
      eventType &&
        (useFallbackCompositionData &&
          "ko" !== nativeEvent.locale &&
          (isComposing || "onCompositionStart" !== eventType
            ? "onCompositionEnd" === eventType &&
              isComposing &&
              (fallbackData = getData())
            : ((root = nativeEventTarget),
              (startText = "value" in root ? root.value : root.textContent),
              (isComposing = !0))),
        (handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType)),
        0 < handleEventFunc.length &&
          ((eventType = new SyntheticCompositionEvent(
            eventType,
            domEventName,
            null,
            nativeEvent,
            nativeEventTarget
          )),
          dispatchQueue.push({ event: eventType, listeners: handleEventFunc }),
          fallbackData
            ? (eventType.data = fallbackData)
            : ((fallbackData = getDataFromCustomEvent(nativeEvent)),
              null !== fallbackData && (eventType.data = fallbackData))));
      if (
        (fallbackData = canUseTextInputEvent
          ? getNativeBeforeInputChars(domEventName, nativeEvent)
          : getFallbackBeforeInputChars(domEventName, nativeEvent))
      )
        (eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput")),
          0 < eventType.length &&
            ((handleEventFunc = new SyntheticCompositionEvent(
              "onBeforeInput",
              "beforeinput",
              null,
              nativeEvent,
              nativeEventTarget
            )),
            dispatchQueue.push({
              event: handleEventFunc,
              listeners: eventType
            }),
            (handleEventFunc.data = fallbackData));
      extractEvents$1(
        dispatchQueue,
        domEventName,
        targetInst,
        nativeEvent,
        nativeEventTarget
      );
    }
    processDispatchQueue(dispatchQueue, eventSystemFlags);
  });
}
function createDispatchListener(instance, listener, currentTarget) {
  return {
    instance: instance,
    listener: listener,
    currentTarget: currentTarget
  };
}
function accumulateTwoPhaseListeners(targetFiber, reactName) {
  for (
    var captureName = reactName + "Capture", listeners = [];
    null !== targetFiber;

  ) {
    var _instance2 = targetFiber,
      stateNode = _instance2.stateNode;
    _instance2 = _instance2.tag;
    (5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2) ||
      null === stateNode ||
      ((_instance2 = getListener(targetFiber, captureName)),
      null != _instance2 &&
        listeners.unshift(
          createDispatchListener(targetFiber, _instance2, stateNode)
        ),
      (_instance2 = getListener(targetFiber, reactName)),
      null != _instance2 &&
        listeners.push(
          createDispatchListener(targetFiber, _instance2, stateNode)
        ));
    if (3 === targetFiber.tag) return listeners;
    targetFiber = targetFiber.return;
  }
  return [];
}
function getParent(inst) {
  if (null === inst) return null;
  do inst = inst.return;
  while (inst && 5 !== inst.tag && 27 !== inst.tag);
  return inst ? inst : null;
}
function accumulateEnterLeaveListenersForEvent(
  dispatchQueue,
  event,
  target,
  common,
  inCapturePhase
) {
  for (
    var registrationName = event._reactName, listeners = [];
    null !== target && target !== common;

  ) {
    var _instance3 = target,
      alternate = _instance3.alternate,
      stateNode = _instance3.stateNode;
    _instance3 = _instance3.tag;
    if (null !== alternate && alternate === common) break;
    (5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3) ||
      null === stateNode ||
      ((alternate = stateNode),
      inCapturePhase
        ? ((stateNode = getListener(target, registrationName)),
          null != stateNode &&
            listeners.unshift(
              createDispatchListener(target, stateNode, alternate)
            ))
        : inCapturePhase ||
          ((stateNode = getListener(target, registrationName)),
          null != stateNode &&
            listeners.push(
              createDispatchListener(target, stateNode, alternate)
            )));
    target = target.return;
  }
  0 !== listeners.length &&
    dispatchQueue.push({ event: event, listeners: listeners });
}
var NORMALIZE_NEWLINES_REGEX = /\r\n?/g,
  NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
function normalizeMarkupForTextOrAttribute(markup) {
  return ("string" === typeof markup ? markup : "" + markup)
    .replace(NORMALIZE_NEWLINES_REGEX, "\n")
    .replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
}
function checkForUnmatchedText(serverText, clientText) {
  clientText = normalizeMarkupForTextOrAttribute(clientText);
  return normalizeMarkupForTextOrAttribute(serverText) === clientText ? !0 : !1;
}
function setProp(domElement, tag, key, value, props, prevValue) {
  switch (key) {
    case "children":
      "string" === typeof value
        ? "body" === tag ||
          ("textarea" === tag && "" === value) ||
          setTextContent(domElement, value)
        : ("number" === typeof value || "bigint" === typeof value) &&
          "body" !== tag &&
          setTextContent(domElement, "" + value);
      break;
    case "className":
      setValueForKnownAttribute(domElement, "class", value);
      break;
    case "tabIndex":
      setValueForKnownAttribute(domElement, "tabindex", value);
      break;
    case "dir":
    case "role":
    case "viewBox":
    case "width":
    case "height":
      setValueForKnownAttribute(domElement, key, value);
      break;
    case "style":
      setValueForStyles(domElement, value, prevValue);
      break;
    case "data":
      if ("object" !== tag) {
        setValueForKnownAttribute(domElement, "data", value);
        break;
      }
    case "src":
    case "href":
      if ("" === value && ("a" !== tag || "href" !== key)) {
        domElement.removeAttribute(key);
        break;
      }
      if (
        null == value ||
        "function" === typeof value ||
        "symbol" === typeof value ||
        "boolean" === typeof value
      ) {
        domElement.removeAttribute(key);
        break;
      }
      value = sanitizeURL("" + value);
      domElement.setAttribute(key, value);
      break;
    case "action":
    case "formAction":
      if ("function" === typeof value) {
        domElement.setAttribute(
          key,
          "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
        );
        break;
      } else
        "function" === typeof prevValue &&
          ("formAction" === key
            ? ("input" !== tag &&
                setProp(domElement, tag, "name", props.name, props, null),
              setProp(
                domElement,
                tag,
                "formEncType",
                props.formEncType,
                props,
                null
              ),
              setProp(
                domElement,
                tag,
                "formMethod",
                props.formMethod,
                props,
                null
              ),
              setProp(
                domElement,
                tag,
                "formTarget",
                props.formTarget,
                props,
                null
              ))
            : (setProp(domElement, tag, "encType", props.encType, props, null),
              setProp(domElement, tag, "method", props.method, props, null),
              setProp(domElement, tag, "target", props.target, props, null)));
      if (
        null == value ||
        "symbol" === typeof value ||
        "boolean" === typeof value
      ) {
        domElement.removeAttribute(key);
        break;
      }
      value = sanitizeURL("" + value);
      domElement.setAttribute(key, value);
      break;
    case "onClick":
      null != value && (domElement.onclick = noop$1);
      break;
    case "onScroll":
      null != value && listenToNonDelegatedEvent("scroll", domElement);
      break;
    case "onScrollEnd":
      null != value && listenToNonDelegatedEvent("scrollend", domElement);
      break;
    case "dangerouslySetInnerHTML":
      if (null != value) {
        if ("object" !== typeof value || !("__html" in value))
          throw Error(formatProdErrorMessage(61));
        key = value.__html;
        if (null != key) {
          if (null != props.children) throw Error(formatProdErrorMessage(60));
          domElement.innerHTML = key;
        }
      }
      break;
    case "multiple":
      domElement.multiple =
        value && "function" !== typeof value && "symbol" !== typeof value;
      break;
    case "muted":
      domElement.muted =
        value && "function" !== typeof value && "symbol" !== typeof value;
      break;
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "defaultValue":
    case "defaultChecked":
    case "innerHTML":
    case "ref":
      break;
    case "autoFocus":
      break;
    case "xlinkHref":
      if (
        null == value ||
        "function" === typeof value ||
        "boolean" === typeof value ||
        "symbol" === typeof value
      ) {
        domElement.removeAttribute("xlink:href");
        break;
      }
      key = sanitizeURL("" + value);
      domElement.setAttributeNS(
        "http://www.w3.org/1999/xlink",
        "xlink:href",
        key
      );
      break;
    case "contentEditable":
    case "spellCheck":
    case "draggable":
    case "value":
    case "autoReverse":
    case "externalResourcesRequired":
    case "focusable":
    case "preserveAlpha":
      null != value && "function" !== typeof value && "symbol" !== typeof value
        ? domElement.setAttribute(key, "" + value)
        : domElement.removeAttribute(key);
      break;
    case "inert":
    case "allowFullScreen":
    case "async":
    case "autoPlay":
    case "controls":
    case "default":
    case "defer":
    case "disabled":
    case "disablePictureInPicture":
    case "disableRemotePlayback":
    case "formNoValidate":
    case "hidden":
    case "loop":
    case "noModule":
    case "noValidate":
    case "open":
    case "playsInline":
    case "readOnly":
    case "required":
    case "reversed":
    case "scoped":
    case "seamless":
    case "itemScope":
      value && "function" !== typeof value && "symbol" !== typeof value
        ? domElement.setAttribute(key, "")
        : domElement.removeAttribute(key);
      break;
    case "capture":
    case "download":
      !0 === value
        ? domElement.setAttribute(key, "")
        : !1 !== value &&
            null != value &&
            "function" !== typeof value &&
            "symbol" !== typeof value
          ? domElement.setAttribute(key, value)
          : domElement.removeAttribute(key);
      break;
    case "cols":
    case "rows":
    case "size":
    case "span":
      null != value &&
      "function" !== typeof value &&
      "symbol" !== typeof value &&
      !isNaN(value) &&
      1 <= value
        ? domElement.setAttribute(key, value)
        : domElement.removeAttribute(key);
      break;
    case "rowSpan":
    case "start":
      null == value ||
      "function" === typeof value ||
      "symbol" === typeof value ||
      isNaN(value)
        ? domElement.removeAttribute(key)
        : domElement.setAttribute(key, value);
      break;
    case "popover":
      listenToNonDelegatedEvent("beforetoggle", domElement);
      listenToNonDelegatedEvent("toggle", domElement);
      setValueForAttribute(domElement, "popover", value);
      break;
    case "xlinkActuate":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:actuate",
        value
      );
      break;
    case "xlinkArcrole":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:arcrole",
        value
      );
      break;
    case "xlinkRole":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:role",
        value
      );
      break;
    case "xlinkShow":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:show",
        value
      );
      break;
    case "xlinkTitle":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:title",
        value
      );
      break;
    case "xlinkType":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:type",
        value
      );
      break;
    case "xmlBase":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/XML/1998/namespace",
        "xml:base",
        value
      );
      break;
    case "xmlLang":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/XML/1998/namespace",
        "xml:lang",
        value
      );
      break;
    case "xmlSpace":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/XML/1998/namespace",
        "xml:space",
        value
      );
      break;
    case "is":
      setValueForAttribute(domElement, "is", value);
      break;
    case "innerText":
    case "textContent":
      break;
    default:
      if (
        !(2 < key.length) ||
        ("o" !== key[0] && "O" !== key[0]) ||
        ("n" !== key[1] && "N" !== key[1])
      )
        (key = aliases.get(key) || key),
          setValueForAttribute(domElement, key, value);
  }
}
function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
  switch (key) {
    case "style":
      setValueForStyles(domElement, value, prevValue);
      break;
    case "dangerouslySetInnerHTML":
      if (null != value) {
        if ("object" !== typeof value || !("__html" in value))
          throw Error(formatProdErrorMessage(61));
        key = value.__html;
        if (null != key) {
          if (null != props.children) throw Error(formatProdErrorMessage(60));
          domElement.innerHTML = key;
        }
      }
      break;
    case "children":
      "string" === typeof value
        ? setTextContent(domElement, value)
        : ("number" === typeof value || "bigint" === typeof value) &&
          setTextContent(domElement, "" + value);
      break;
    case "onScroll":
      null != value && listenToNonDelegatedEvent("scroll", domElement);
      break;
    case "onScrollEnd":
      null != value && listenToNonDelegatedEvent("scrollend", domElement);
      break;
    case "onClick":
      null != value && (domElement.onclick = noop$1);
      break;
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "innerHTML":
    case "ref":
      break;
    case "innerText":
    case "textContent":
      break;
    default:
      if (!registrationNameDependencies.hasOwnProperty(key))
        a: {
          if (
            "o" === key[0] &&
            "n" === key[1] &&
            ((props = key.endsWith("Capture")),
            (tag = key.slice(2, props ? key.length - 7 : void 0)),
            (prevValue = domElement[internalPropsKey] || null),
            (prevValue = null != prevValue ? prevValue[key] : null),
            "function" === typeof prevValue &&
              domElement.removeEventListener(tag, prevValue, props),
            "function" === typeof value)
          ) {
            "function" !== typeof prevValue &&
              null !== prevValue &&
              (key in domElement
                ? (domElement[key] = null)
                : domElement.hasAttribute(key) &&
                  domElement.removeAttribute(key));
            domElement.addEventListener(tag, value, props);
            break a;
          }
          key in domElement
            ? (domElement[key] = value)
            : !0 === value
              ? domElement.setAttribute(key, "")
              : setValueForAttribute(domElement, key, value);
        }
  }
}
function setInitialProperties(domElement, tag, props) {
  switch (tag) {
    case "div":
    case "span":
    case "svg":
    case "path":
    case "a":
    case "g":
    case "p":
    case "li":
      break;
    case "img":
      listenToNonDelegatedEvent("error", domElement);
      listenToNonDelegatedEvent("load", domElement);
      var hasSrc = !1,
        hasSrcSet = !1,
        propKey;
      for (propKey in props)
        if (props.hasOwnProperty(propKey)) {
          var propValue = props[propKey];
          if (null != propValue)
            switch (propKey) {
              case "src":
                hasSrc = !0;
                break;
              case "srcSet":
                hasSrcSet = !0;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(formatProdErrorMessage(137, tag));
              default:
                setProp(domElement, tag, propKey, propValue, props, null);
            }
        }
      hasSrcSet &&
        setProp(domElement, tag, "srcSet", props.srcSet, props, null);
      hasSrc && setProp(domElement, tag, "src", props.src, props, null);
      return;
    case "input":
      listenToNonDelegatedEvent("invalid", domElement);
      var defaultValue = (propKey = propValue = hasSrcSet = null),
        checked = null,
        defaultChecked = null;
      for (hasSrc in props)
        if (props.hasOwnProperty(hasSrc)) {
          var propValue$184 = props[hasSrc];
          if (null != propValue$184)
            switch (hasSrc) {
              case "name":
                hasSrcSet = propValue$184;
                break;
              case "type":
                propValue = propValue$184;
                break;
              case "checked":
                checked = propValue$184;
                break;
              case "defaultChecked":
                defaultChecked = propValue$184;
                break;
              case "value":
                propKey = propValue$184;
                break;
              case "defaultValue":
                defaultValue = propValue$184;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (null != propValue$184)
                  throw Error(formatProdErrorMessage(137, tag));
                break;
              default:
                setProp(domElement, tag, hasSrc, propValue$184, props, null);
            }
        }
      initInput(
        domElement,
        propKey,
        defaultValue,
        checked,
        defaultChecked,
        propValue,
        hasSrcSet,
        !1
      );
      return;
    case "select":
      listenToNonDelegatedEvent("invalid", domElement);
      hasSrc = propValue = propKey = null;
      for (hasSrcSet in props)
        if (
          props.hasOwnProperty(hasSrcSet) &&
          ((defaultValue = props[hasSrcSet]), null != defaultValue)
        )
          switch (hasSrcSet) {
            case "value":
              propKey = defaultValue;
              break;
            case "defaultValue":
              propValue = defaultValue;
              break;
            case "multiple":
              hasSrc = defaultValue;
            default:
              setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
          }
      tag = propKey;
      props = propValue;
      domElement.multiple = !!hasSrc;
      null != tag
        ? updateOptions(domElement, !!hasSrc, tag, !1)
        : null != props && updateOptions(domElement, !!hasSrc, props, !0);
      return;
    case "textarea":
      listenToNonDelegatedEvent("invalid", domElement);
      propKey = hasSrcSet = hasSrc = null;
      for (propValue in props)
        if (
          props.hasOwnProperty(propValue) &&
          ((defaultValue = props[propValue]), null != defaultValue)
        )
          switch (propValue) {
            case "value":
              hasSrc = defaultValue;
              break;
            case "defaultValue":
              hasSrcSet = defaultValue;
              break;
            case "children":
              propKey = defaultValue;
              break;
            case "dangerouslySetInnerHTML":
              if (null != defaultValue) throw Error(formatProdErrorMessage(91));
              break;
            default:
              setProp(domElement, tag, propValue, defaultValue, props, null);
          }
      initTextarea(domElement, hasSrc, hasSrcSet, propKey);
      return;
    case "option":
      for (checked in props)
        if (
          props.hasOwnProperty(checked) &&
          ((hasSrc = props[checked]), null != hasSrc)
        )
          switch (checked) {
            case "selected":
              domElement.selected =
                hasSrc &&
                "function" !== typeof hasSrc &&
                "symbol" !== typeof hasSrc;
              break;
            default:
              setProp(domElement, tag, checked, hasSrc, props, null);
          }
      return;
    case "dialog":
      listenToNonDelegatedEvent("beforetoggle", domElement);
      listenToNonDelegatedEvent("toggle", domElement);
      listenToNonDelegatedEvent("cancel", domElement);
      listenToNonDelegatedEvent("close", domElement);
      break;
    case "iframe":
    case "object":
      listenToNonDelegatedEvent("load", domElement);
      break;
    case "video":
    case "audio":
      for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
        listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
      break;
    case "image":
      listenToNonDelegatedEvent("error", domElement);
      listenToNonDelegatedEvent("load", domElement);
      break;
    case "details":
      listenToNonDelegatedEvent("toggle", domElement);
      break;
    case "embed":
    case "source":
    case "link":
      listenToNonDelegatedEvent("error", domElement),
        listenToNonDelegatedEvent("load", domElement);
    case "area":
    case "base":
    case "br":
    case "col":
    case "hr":
    case "keygen":
    case "meta":
    case "param":
    case "track":
    case "wbr":
    case "menuitem":
      for (defaultChecked in props)
        if (
          props.hasOwnProperty(defaultChecked) &&
          ((hasSrc = props[defaultChecked]), null != hasSrc)
        )
          switch (defaultChecked) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(formatProdErrorMessage(137, tag));
            default:
              setProp(domElement, tag, defaultChecked, hasSrc, props, null);
          }
      return;
    default:
      if (isCustomElement(tag)) {
        for (propValue$184 in props)
          props.hasOwnProperty(propValue$184) &&
            ((hasSrc = props[propValue$184]),
            void 0 !== hasSrc &&
              setPropOnCustomElement(
                domElement,
                tag,
                propValue$184,
                hasSrc,
                props,
                void 0
              ));
        return;
      }
  }
  for (defaultValue in props)
    props.hasOwnProperty(defaultValue) &&
      ((hasSrc = props[defaultValue]),
      null != hasSrc &&
        setProp(domElement, tag, defaultValue, hasSrc, props, null));
}
function updateProperties(domElement, tag, lastProps, nextProps) {
  switch (tag) {
    case "div":
    case "span":
    case "svg":
    case "path":
    case "a":
    case "g":
    case "p":
    case "li":
      break;
    case "input":
      var name = null,
        type = null,
        value = null,
        defaultValue = null,
        lastDefaultValue = null,
        checked = null,
        defaultChecked = null;
      for (propKey in lastProps) {
        var lastProp = lastProps[propKey];
        if (lastProps.hasOwnProperty(propKey) && null != lastProp)
          switch (propKey) {
            case "checked":
              break;
            case "value":
              break;
            case "defaultValue":
              lastDefaultValue = lastProp;
            default:
              nextProps.hasOwnProperty(propKey) ||
                setProp(domElement, tag, propKey, null, nextProps, lastProp);
          }
      }
      for (var propKey$201 in nextProps) {
        var propKey = nextProps[propKey$201];
        lastProp = lastProps[propKey$201];
        if (
          nextProps.hasOwnProperty(propKey$201) &&
          (null != propKey || null != lastProp)
        )
          switch (propKey$201) {
            case "type":
              type = propKey;
              break;
            case "name":
              name = propKey;
              break;
            case "checked":
              checked = propKey;
              break;
            case "defaultChecked":
              defaultChecked = propKey;
              break;
            case "value":
              value = propKey;
              break;
            case "defaultValue":
              defaultValue = propKey;
              break;
            case "children":
            case "dangerouslySetInnerHTML":
              if (null != propKey)
                throw Error(formatProdErrorMessage(137, tag));
              break;
            default:
              propKey !== lastProp &&
                setProp(
                  domElement,
                  tag,
                  propKey$201,
                  propKey,
                  nextProps,
                  lastProp
                );
          }
      }
      updateInput(
        domElement,
        value,
        defaultValue,
        lastDefaultValue,
        checked,
        defaultChecked,
        type,
        name
      );
      return;
    case "select":
      propKey = value = defaultValue = propKey$201 = null;
      for (type in lastProps)
        if (
          ((lastDefaultValue = lastProps[type]),
          lastProps.hasOwnProperty(type) && null != lastDefaultValue)
        )
          switch (type) {
            case "value":
              break;
            case "multiple":
              propKey = lastDefaultValue;
            default:
              nextProps.hasOwnProperty(type) ||
                setProp(
                  domElement,
                  tag,
                  type,
                  null,
                  nextProps,
                  lastDefaultValue
                );
          }
      for (name in nextProps)
        if (
          ((type = nextProps[name]),
          (lastDefaultValue = lastProps[name]),
          nextProps.hasOwnProperty(name) &&
            (null != type || null != lastDefaultValue))
        )
          switch (name) {
            case "value":
              propKey$201 = type;
              break;
            case "defaultValue":
              defaultValue = type;
              break;
            case "multiple":
              value = type;
            default:
              type !== lastDefaultValue &&
                setProp(
                  domElement,
                  tag,
                  name,
                  type,
                  nextProps,
                  lastDefaultValue
                );
          }
      tag = defaultValue;
      lastProps = value;
      nextProps = propKey;
      null != propKey$201
        ? updateOptions(domElement, !!lastProps, propKey$201, !1)
        : !!nextProps !== !!lastProps &&
          (null != tag
            ? updateOptions(domElement, !!lastProps, tag, !0)
            : updateOptions(domElement, !!lastProps, lastProps ? [] : "", !1));
      return;
    case "textarea":
      propKey = propKey$201 = null;
      for (defaultValue in lastProps)
        if (
          ((name = lastProps[defaultValue]),
          lastProps.hasOwnProperty(defaultValue) &&
            null != name &&
            !nextProps.hasOwnProperty(defaultValue))
        )
          switch (defaultValue) {
            case "value":
              break;
            case "children":
              break;
            default:
              setProp(domElement, tag, defaultValue, null, nextProps, name);
          }
      for (value in nextProps)
        if (
          ((name = nextProps[value]),
          (type = lastProps[value]),
          nextProps.hasOwnProperty(value) && (null != name || null != type))
        )
          switch (value) {
            case "value":
              propKey$201 = name;
              break;
            case "defaultValue":
              propKey = name;
              break;
            case "children":
              break;
            case "dangerouslySetInnerHTML":
              if (null != name) throw Error(formatProdErrorMessage(91));
              break;
            default:
              name !== type &&
                setProp(domElement, tag, value, name, nextProps, type);
          }
      updateTextarea(domElement, propKey$201, propKey);
      return;
    case "option":
      for (var propKey$217 in lastProps)
        if (
          ((propKey$201 = lastProps[propKey$217]),
          lastProps.hasOwnProperty(propKey$217) &&
            null != propKey$201 &&
            !nextProps.hasOwnProperty(propKey$217))
        )
          switch (propKey$217) {
            case "selected":
              domElement.selected = !1;
              break;
            default:
              setProp(
                domElement,
                tag,
                propKey$217,
                null,
                nextProps,
                propKey$201
              );
          }
      for (lastDefaultValue in nextProps)
        if (
          ((propKey$201 = nextProps[lastDefaultValue]),
          (propKey = lastProps[lastDefaultValue]),
          nextProps.hasOwnProperty(lastDefaultValue) &&
            propKey$201 !== propKey &&
            (null != propKey$201 || null != propKey))
        )
          switch (lastDefaultValue) {
            case "selected":
              domElement.selected =
                propKey$201 &&
                "function" !== typeof propKey$201 &&
                "symbol" !== typeof propKey$201;
              break;
            default:
              setProp(
                domElement,
                tag,
                lastDefaultValue,
                propKey$201,
                nextProps,
                propKey
              );
          }
      return;
    case "img":
    case "link":
    case "area":
    case "base":
    case "br":
    case "col":
    case "embed":
    case "hr":
    case "keygen":
    case "meta":
    case "param":
    case "source":
    case "track":
    case "wbr":
    case "menuitem":
      for (var propKey$222 in lastProps)
        (propKey$201 = lastProps[propKey$222]),
          lastProps.hasOwnProperty(propKey$222) &&
            null != propKey$201 &&
            !nextProps.hasOwnProperty(propKey$222) &&
            setProp(domElement, tag, propKey$222, null, nextProps, propKey$201);
      for (checked in nextProps)
        if (
          ((propKey$201 = nextProps[checked]),
          (propKey = lastProps[checked]),
          nextProps.hasOwnProperty(checked) &&
            propKey$201 !== propKey &&
            (null != propKey$201 || null != propKey))
        )
          switch (checked) {
            case "children":
            case "dangerouslySetInnerHTML":
              if (null != propKey$201)
                throw Error(formatProdErrorMessage(137, tag));
              break;
            default:
              setProp(
                domElement,
                tag,
                checked,
                propKey$201,
                nextProps,
                propKey
              );
          }
      return;
    default:
      if (isCustomElement(tag)) {
        for (var propKey$227 in lastProps)
          (propKey$201 = lastProps[propKey$227]),
            lastProps.hasOwnProperty(propKey$227) &&
              void 0 !== propKey$201 &&
              !nextProps.hasOwnProperty(propKey$227) &&
              setPropOnCustomElement(
                domElement,
                tag,
                propKey$227,
                void 0,
                nextProps,
                propKey$201
              );
        for (defaultChecked in nextProps)
          (propKey$201 = nextProps[defaultChecked]),
            (propKey = lastProps[defaultChecked]),
            !nextProps.hasOwnProperty(defaultChecked) ||
              propKey$201 === propKey ||
              (void 0 === propKey$201 && void 0 === propKey) ||
              setPropOnCustomElement(
                domElement,
                tag,
                defaultChecked,
                propKey$201,
                nextProps,
                propKey
              );
        return;
      }
  }
  for (var propKey$232 in lastProps)
    (propKey$201 = lastProps[propKey$232]),
      lastProps.hasOwnProperty(propKey$232) &&
        null != propKey$201 &&
        !nextProps.hasOwnProperty(propKey$232) &&
        setProp(domElement, tag, propKey$232, null, nextProps, propKey$201);
  for (lastProp in nextProps)
    (propKey$201 = nextProps[lastProp]),
      (propKey = lastProps[lastProp]),
      !nextProps.hasOwnProperty(lastProp) ||
        propKey$201 === propKey ||
        (null == propKey$201 && null == propKey) ||
        setProp(domElement, tag, lastProp, propKey$201, nextProps, propKey);
}
function isLikelyStaticResource(initiatorType) {
  switch (initiatorType) {
    case "css":
    case "script":
    case "font":
    case "img":
    case "image":
    case "input":
    case "link":
      return !0;
    default:
      return !1;
  }
}
function estimateBandwidth() {
  if ("function" === typeof performance.getEntriesByType) {
    for (
      var count = 0,
        bits = 0,
        resourceEntries = performance.getEntriesByType("resource"),
        i = 0;
      i < resourceEntries.length;
      i++
    ) {
      var entry = resourceEntries[i],
        transferSize = entry.transferSize,
        initiatorType = entry.initiatorType,
        duration = entry.duration;
      if (transferSize && duration && isLikelyStaticResource(initiatorType)) {
        initiatorType = 0;
        duration = entry.responseEnd;
        for (i += 1; i < resourceEntries.length; i++) {
          var overlapEntry = resourceEntries[i],
            overlapStartTime = overlapEntry.startTime;
          if (overlapStartTime > duration) break;
          var overlapTransferSize = overlapEntry.transferSize,
            overlapInitiatorType = overlapEntry.initiatorType;
          overlapTransferSize &&
            isLikelyStaticResource(overlapInitiatorType) &&
            ((overlapEntry = overlapEntry.responseEnd),
            (initiatorType +=
              overlapTransferSize *
              (overlapEntry < duration
                ? 1
                : (duration - overlapStartTime) /
                  (overlapEntry - overlapStartTime))));
        }
        --i;
        bits += (8 * (transferSize + initiatorType)) / (entry.duration / 1e3);
        count++;
        if (10 < count) break;
      }
    }
    if (0 < count) return bits / count / 1e6;
  }
  return navigator.connection &&
    ((count = navigator.connection.downlink), "number" === typeof count)
    ? count
    : 5;
}
var eventsEnabled = null,
  selectionInformation = null;
function getOwnerDocumentFromRootContainer(rootContainerElement) {
  return 9 === rootContainerElement.nodeType
    ? rootContainerElement
    : rootContainerElement.ownerDocument;
}
function getOwnHostContext(namespaceURI) {
  switch (namespaceURI) {
    case "http://www.w3.org/2000/svg":
      return 1;
    case "http://www.w3.org/1998/Math/MathML":
      return 2;
    default:
      return 0;
  }
}
function getChildHostContextProd(parentNamespace, type) {
  if (0 === parentNamespace)
    switch (type) {
      case "svg":
        return 1;
      case "math":
        return 2;
      default:
        return 0;
    }
  return 1 === parentNamespace && "foreignObject" === type
    ? 0
    : parentNamespace;
}
function shouldSetTextContent(type, props) {
  return (
    "textarea" === type ||
    "noscript" === type ||
    "string" === typeof props.children ||
    "number" === typeof props.children ||
    "bigint" === typeof props.children ||
    ("object" === typeof props.dangerouslySetInnerHTML &&
      null !== props.dangerouslySetInnerHTML &&
      null != props.dangerouslySetInnerHTML.__html)
  );
}
var currentPopstateTransitionEvent = null;
function shouldAttemptEagerTransition() {
  var event = window.event;
  if (event && "popstate" === event.type) {
    if (event === currentPopstateTransitionEvent) return !1;
    currentPopstateTransitionEvent = event;
    return !0;
  }
  currentPopstateTransitionEvent = null;
  return !1;
}
var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0,
  cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0,
  localPromise = "function" === typeof Promise ? Promise : void 0,
  scheduleMicrotask =
    "function" === typeof queueMicrotask
      ? queueMicrotask
      : "undefined" !== typeof localPromise
        ? function (callback) {
            return localPromise
              .resolve(null)
              .then(callback)
              .catch(handleErrorInNextTick);
          }
        : scheduleTimeout;
function handleErrorInNextTick(error) {
  setTimeout(function () {
    throw error;
  });
}
function isSingletonScope(type) {
  return "head" === type;
}
function clearHydrationBoundary(parentInstance, hydrationInstance) {
  var node = hydrationInstance,
    depth = 0;
  do {
    var nextNode = node.nextSibling;
    parentInstance.removeChild(node);
    if (nextNode && 8 === nextNode.nodeType)
      if (((node = nextNode.data), "/$" === node || "/&" === node)) {
        if (0 === depth) {
          parentInstance.removeChild(nextNode);
          retryIfBlockedOn(hydrationInstance);
          return;
        }
        depth--;
      } else if (
        "$" === node ||
        "$?" === node ||
        "$~" === node ||
        "$!" === node ||
        "&" === node
      )
        depth++;
      else if ("html" === node)
        releaseSingletonInstance(parentInstance.ownerDocument.documentElement);
      else if ("head" === node) {
        node = parentInstance.ownerDocument.head;
        releaseSingletonInstance(node);
        for (var node$jscomp$0 = node.firstChild; node$jscomp$0; ) {
          var nextNode$jscomp$0 = node$jscomp$0.nextSibling,
            nodeName = node$jscomp$0.nodeName;
          node$jscomp$0[internalHoistableMarker] ||
            "SCRIPT" === nodeName ||
            "STYLE" === nodeName ||
            ("LINK" === nodeName &&
              "stylesheet" === node$jscomp$0.rel.toLowerCase()) ||
            node.removeChild(node$jscomp$0);
          node$jscomp$0 = nextNode$jscomp$0;
        }
      } else
        "body" === node &&
          releaseSingletonInstance(parentInstance.ownerDocument.body);
    node = nextNode;
  } while (node);
  retryIfBlockedOn(hydrationInstance);
}
function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden) {
  var node = suspenseInstance;
  suspenseInstance = 0;
  do {
    var nextNode = node.nextSibling;
    1 === node.nodeType
      ? isHidden
        ? ((node._stashedDisplay = node.style.display),
          (node.style.display = "none"))
        : ((node.style.display = node._stashedDisplay || ""),
          "" === node.getAttribute("style") && node.removeAttribute("style"))
      : 3 === node.nodeType &&
        (isHidden
          ? ((node._stashedText = node.nodeValue), (node.nodeValue = ""))
          : (node.nodeValue = node._stashedText || ""));
    if (nextNode && 8 === nextNode.nodeType)
      if (((node = nextNode.data), "/$" === node))
        if (0 === suspenseInstance) break;
        else suspenseInstance--;
      else
        ("$" !== node && "$?" !== node && "$~" !== node && "$!" !== node) ||
          suspenseInstance++;
    node = nextNode;
  } while (node);
}
function clearContainerSparingly(container) {
  var nextNode = container.firstChild;
  nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
  for (; nextNode; ) {
    var node = nextNode;
    nextNode = nextNode.nextSibling;
    switch (node.nodeName) {
      case "HTML":
      case "HEAD":
      case "BODY":
        clearContainerSparingly(node);
        detachDeletedInstance(node);
        continue;
      case "SCRIPT":
      case "STYLE":
        continue;
      case "LINK":
        if ("stylesheet" === node.rel.toLowerCase()) continue;
    }
    container.removeChild(node);
  }
}
function canHydrateInstance(instance, type, props, inRootOrSingleton) {
  for (; 1 === instance.nodeType; ) {
    var anyProps = props;
    if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
      if (
        !inRootOrSingleton &&
        ("INPUT" !== instance.nodeName || "hidden" !== instance.type)
      )
        break;
    } else if (!inRootOrSingleton)
      if ("input" === type && "hidden" === instance.type) {
        var name = null == anyProps.name ? null : "" + anyProps.name;
        if (
          "hidden" === anyProps.type &&
          instance.getAttribute("name") === name
        )
          return instance;
      } else return instance;
    else if (!instance[internalHoistableMarker])
      switch (type) {
        case "meta":
          if (!instance.hasAttribute("itemprop")) break;
          return instance;
        case "link":
          name = instance.getAttribute("rel");
          if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
            break;
          else if (
            name !== anyProps.rel ||
            instance.getAttribute("href") !==
              (null == anyProps.href || "" === anyProps.href
                ? null
                : anyProps.href) ||
            instance.getAttribute("crossorigin") !==
              (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) ||
            instance.getAttribute("title") !==
              (null == anyProps.title ? null : anyProps.title)
          )
            break;
          return instance;
        case "style":
          if (instance.hasAttribute("data-precedence")) break;
          return instance;
        case "script":
          name = instance.getAttribute("src");
          if (
            (name !== (null == anyProps.src ? null : anyProps.src) ||
              instance.getAttribute("type") !==
                (null == anyProps.type ? null : anyProps.type) ||
              instance.getAttribute("crossorigin") !==
                (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) &&
            name &&
            instance.hasAttribute("async") &&
            !instance.hasAttribute("itemprop")
          )
            break;
          return instance;
        default:
          return instance;
      }
    instance = getNextHydratable(instance.nextSibling);
    if (null === instance) break;
  }
  return null;
}
function canHydrateTextInstance(instance, text, inRootOrSingleton) {
  if ("" === text) return null;
  for (; 3 !== instance.nodeType; ) {
    if (
      (1 !== instance.nodeType ||
        "INPUT" !== instance.nodeName ||
        "hidden" !== instance.type) &&
      !inRootOrSingleton
    )
      return null;
    instance = getNextHydratable(instance.nextSibling);
    if (null === instance) return null;
  }
  return instance;
}
function canHydrateHydrationBoundary(instance, inRootOrSingleton) {
  for (; 8 !== instance.nodeType; ) {
    if (
      (1 !== instance.nodeType ||
        "INPUT" !== instance.nodeName ||
        "hidden" !== instance.type) &&
      !inRootOrSingleton
    )
      return null;
    instance = getNextHydratable(instance.nextSibling);
    if (null === instance) return null;
  }
  return instance;
}
function isSuspenseInstancePending(instance) {
  return "$?" === instance.data || "$~" === instance.data;
}
function isSuspenseInstanceFallback(instance) {
  return (
    "$!" === instance.data ||
    ("$?" === instance.data && "loading" !== instance.ownerDocument.readyState)
  );
}
function registerSuspenseInstanceRetry(instance, callback) {
  var ownerDocument = instance.ownerDocument;
  if ("$~" === instance.data) instance._reactRetry = callback;
  else if ("$?" !== instance.data || "loading" !== ownerDocument.readyState)
    callback();
  else {
    var listener = function () {
      callback();
      ownerDocument.removeEventListener("DOMContentLoaded", listener);
    };
    ownerDocument.addEventListener("DOMContentLoaded", listener);
    instance._reactRetry = listener;
  }
}
function getNextHydratable(node) {
  for (; null != node; node = node.nextSibling) {
    var nodeType = node.nodeType;
    if (1 === nodeType || 3 === nodeType) break;
    if (8 === nodeType) {
      nodeType = node.data;
      if (
        "$" === nodeType ||
        "$!" === nodeType ||
        "$?" === nodeType ||
        "$~" === nodeType ||
        "&" === nodeType ||
        "F!" === nodeType ||
        "F" === nodeType
      )
        break;
      if ("/$" === nodeType || "/&" === nodeType) return null;
    }
  }
  return node;
}
var previousHydratableOnEnteringScopedSingleton = null;
function getNextHydratableInstanceAfterHydrationBoundary(hydrationInstance) {
  hydrationInstance = hydrationInstance.nextSibling;
  for (var depth = 0; hydrationInstance; ) {
    if (8 === hydrationInstance.nodeType) {
      var data = hydrationInstance.data;
      if ("/$" === data || "/&" === data) {
        if (0 === depth)
          return getNextHydratable(hydrationInstance.nextSibling);
        depth--;
      } else
        ("$" !== data &&
          "$!" !== data &&
          "$?" !== data &&
          "$~" !== data &&
          "&" !== data) ||
          depth++;
    }
    hydrationInstance = hydrationInstance.nextSibling;
  }
  return null;
}
function getParentHydrationBoundary(targetInstance) {
  targetInstance = targetInstance.previousSibling;
  for (var depth = 0; targetInstance; ) {
    if (8 === targetInstance.nodeType) {
      var data = targetInstance.data;
      if (
        "$" === data ||
        "$!" === data ||
        "$?" === data ||
        "$~" === data ||
        "&" === data
      ) {
        if (0 === depth) return targetInstance;
        depth--;
      } else ("/$" !== data && "/&" !== data) || depth++;
    }
    targetInstance = targetInstance.previousSibling;
  }
  return null;
}
function resolveSingletonInstance(type, props, rootContainerInstance) {
  props = getOwnerDocumentFromRootContainer(rootContainerInstance);
  switch (type) {
    case "html":
      type = props.documentElement;
      if (!type) throw Error(formatProdErrorMessage(452));
      return type;
    case "head":
      type = props.head;
      if (!type) throw Error(formatProdErrorMessage(453));
      return type;
    case "body":
      type = props.body;
      if (!type) throw Error(formatProdErrorMessage(454));
      return type;
    default:
      throw Error(formatProdErrorMessage(451));
  }
}
function releaseSingletonInstance(instance) {
  for (var attributes = instance.attributes; attributes.length; )
    instance.removeAttributeNode(attributes[0]);
  detachDeletedInstance(instance);
}
var preloadPropsMap = new Map(),
  preconnectsSet = new Set();
function getHoistableRoot(container) {
  return "function" === typeof container.getRootNode
    ? container.getRootNode()
    : 9 === container.nodeType
      ? container
      : container.ownerDocument;
}
var previousDispatcher = ReactDOMSharedInternals.d;
ReactDOMSharedInternals.d = {
  f: flushSyncWork,
  r: requestFormReset,
  D: prefetchDNS,
  C: preconnect,
  L: preload,
  m: preloadModule,
  X: preinitScript,
  S: preinitStyle,
  M: preinitModuleScript
};
function flushSyncWork() {
  var previousWasRendering = previousDispatcher.f(),
    wasRendering = flushSyncWork$1();
  return previousWasRendering || wasRendering;
}
function requestFormReset(form) {
  var formInst = getInstanceFromNode(form);
  null !== formInst && 5 === formInst.tag && "form" === formInst.type
    ? requestFormReset$1(formInst)
    : previousDispatcher.r(form);
}
var globalDocument = "undefined" === typeof document ? null : document;
function preconnectAs(rel, href, crossOrigin) {
  var ownerDocument = globalDocument;
  if (ownerDocument && "string" === typeof href && href) {
    var limitedEscapedHref =
      escapeSelectorAttributeValueInsideDoubleQuotes(href);
    limitedEscapedHref =
      'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
    "string" === typeof crossOrigin &&
      (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
    preconnectsSet.has(limitedEscapedHref) ||
      (preconnectsSet.add(limitedEscapedHref),
      (rel = { rel: rel, crossOrigin: crossOrigin, href: href }),
      null === ownerDocument.querySelector(limitedEscapedHref) &&
        ((href = ownerDocument.createElement("link")),
        setInitialProperties(href, "link", rel),
        markNodeAsHoistable(href),
        ownerDocument.head.appendChild(href)));
  }
}
function prefetchDNS(href) {
  previousDispatcher.D(href);
  preconnectAs("dns-prefetch", href, null);
}
function preconnect(href, crossOrigin) {
  previousDispatcher.C(href, crossOrigin);
  preconnectAs("preconnect", href, crossOrigin);
}
function preload(href, as, options) {
  previousDispatcher.L(href, as, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && href && as) {
    var preloadSelector =
      'link[rel="preload"][as="' +
      escapeSelectorAttributeValueInsideDoubleQuotes(as) +
      '"]';
    "image" === as
      ? options && options.imageSrcSet
        ? ((preloadSelector +=
            '[imagesrcset="' +
            escapeSelectorAttributeValueInsideDoubleQuotes(
              options.imageSrcSet
            ) +
            '"]'),
          "string" === typeof options.imageSizes &&
            (preloadSelector +=
              '[imagesizes="' +
              escapeSelectorAttributeValueInsideDoubleQuotes(
                options.imageSizes
              ) +
              '"]'))
        : (preloadSelector +=
            '[href="' +
            escapeSelectorAttributeValueInsideDoubleQuotes(href) +
            '"]')
      : (preloadSelector +=
          '[href="' +
          escapeSelectorAttributeValueInsideDoubleQuotes(href) +
          '"]');
    var key = preloadSelector;
    switch (as) {
      case "style":
        key = getStyleKey(href);
        break;
      case "script":
        key = getScriptKey(href);
    }
    preloadPropsMap.has(key) ||
      ((href = assign(
        {
          rel: "preload",
          href:
            "image" === as && options && options.imageSrcSet ? void 0 : href,
          as: as
        },
        options
      )),
      preloadPropsMap.set(key, href),
      null !== ownerDocument.querySelector(preloadSelector) ||
        ("style" === as &&
          ownerDocument.querySelector(getStylesheetSelectorFromKey(key))) ||
        ("script" === as &&
          ownerDocument.querySelector(getScriptSelectorFromKey(key))) ||
        ((as = ownerDocument.createElement("link")),
        setInitialProperties(as, "link", href),
        markNodeAsHoistable(as),
        ownerDocument.head.appendChild(as)));
  }
}
function preloadModule(href, options) {
  previousDispatcher.m(href, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && href) {
    var as = options && "string" === typeof options.as ? options.as : "script",
      preloadSelector =
        'link[rel="modulepreload"][as="' +
        escapeSelectorAttributeValueInsideDoubleQuotes(as) +
        '"][href="' +
        escapeSelectorAttributeValueInsideDoubleQuotes(href) +
        '"]',
      key = preloadSelector;
    switch (as) {
      case "audioworklet":
      case "paintworklet":
      case "serviceworker":
      case "sharedworker":
      case "worker":
      case "script":
        key = getScriptKey(href);
    }
    if (
      !preloadPropsMap.has(key) &&
      ((href = assign({ rel: "modulepreload", href: href }, options)),
      preloadPropsMap.set(key, href),
      null === ownerDocument.querySelector(preloadSelector))
    ) {
      switch (as) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
            return;
      }
      as = ownerDocument.createElement("link");
      setInitialProperties(as, "link", href);
      markNodeAsHoistable(as);
      ownerDocument.head.appendChild(as);
    }
  }
}
function preinitStyle(href, precedence, options) {
  previousDispatcher.S(href, precedence, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && href) {
    var styles = getResourcesFromRoot(ownerDocument).hoistableStyles,
      key = getStyleKey(href);
    precedence = precedence || "default";
    var resource = styles.get(key);
    if (!resource) {
      var state = { loading: 0, preload: null };
      if (
        (resource = ownerDocument.querySelector(
          getStylesheetSelectorFromKey(key)
        ))
      )
        state.loading = 5;
      else {
        href = assign(
          { rel: "stylesheet", href: href, "data-precedence": precedence },
          options
        );
        (options = preloadPropsMap.get(key)) &&
          adoptPreloadPropsForStylesheet(href, options);
        var link = (resource = ownerDocument.createElement("link"));
        markNodeAsHoistable(link);
        setInitialProperties(link, "link", href);
        link._p = new Promise(function (resolve, reject) {
          link.onload = resolve;
          link.onerror = reject;
        });
        link.addEventListener("load", function () {
          state.loading |= 1;
        });
        link.addEventListener("error", function () {
          state.loading |= 2;
        });
        state.loading |= 4;
        insertStylesheet(resource, precedence, ownerDocument);
      }
      resource = {
        type: "stylesheet",
        instance: resource,
        count: 1,
        state: state
      };
      styles.set(key, resource);
    }
  }
}
function preinitScript(src, options) {
  previousDispatcher.X(src, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && src) {
    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
      key = getScriptKey(src),
      resource = scripts.get(key);
    resource ||
      ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),
      resource ||
        ((src = assign({ src: src, async: !0 }, options)),
        (options = preloadPropsMap.get(key)) &&
          adoptPreloadPropsForScript(src, options),
        (resource = ownerDocument.createElement("script")),
        markNodeAsHoistable(resource),
        setInitialProperties(resource, "link", src),
        ownerDocument.head.appendChild(resource)),
      (resource = {
        type: "script",
        instance: resource,
        count: 1,
        state: null
      }),
      scripts.set(key, resource));
  }
}
function preinitModuleScript(src, options) {
  previousDispatcher.M(src, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && src) {
    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
      key = getScriptKey(src),
      resource = scripts.get(key);
    resource ||
      ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),
      resource ||
        ((src = assign({ src: src, async: !0, type: "module" }, options)),
        (options = preloadPropsMap.get(key)) &&
          adoptPreloadPropsForScript(src, options),
        (resource = ownerDocument.createElement("script")),
        markNodeAsHoistable(resource),
        setInitialProperties(resource, "link", src),
        ownerDocument.head.appendChild(resource)),
      (resource = {
        type: "script",
        instance: resource,
        count: 1,
        state: null
      }),
      scripts.set(key, resource));
  }
}
function getResource(type, currentProps, pendingProps, currentResource) {
  var JSCompiler_inline_result = (JSCompiler_inline_result =
    rootInstanceStackCursor.current)
    ? getHoistableRoot(JSCompiler_inline_result)
    : null;
  if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
  switch (type) {
    case "meta":
    case "title":
      return null;
    case "style":
      return "string" === typeof pendingProps.precedence &&
        "string" === typeof pendingProps.href
        ? ((currentProps = getStyleKey(pendingProps.href)),
          (pendingProps = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableStyles),
          (currentResource = pendingProps.get(currentProps)),
          currentResource ||
            ((currentResource = {
              type: "style",
              instance: null,
              count: 0,
              state: null
            }),
            pendingProps.set(currentProps, currentResource)),
          currentResource)
        : { type: "void", instance: null, count: 0, state: null };
    case "link":
      if (
        "stylesheet" === pendingProps.rel &&
        "string" === typeof pendingProps.href &&
        "string" === typeof pendingProps.precedence
      ) {
        type = getStyleKey(pendingProps.href);
        var styles$243 = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableStyles,
          resource$244 = styles$243.get(type);
        resource$244 ||
          ((JSCompiler_inline_result =
            JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result),
          (resource$244 = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }),
          styles$243.set(type, resource$244),
          (styles$243 = JSCompiler_inline_result.querySelector(
            getStylesheetSelectorFromKey(type)
          )) &&
            !styles$243._p &&
            ((resource$244.instance = styles$243),
            (resource$244.state.loading = 5)),
          preloadPropsMap.has(type) ||
            ((pendingProps = {
              rel: "preload",
              as: "style",
              href: pendingProps.href,
              crossOrigin: pendingProps.crossOrigin,
              integrity: pendingProps.integrity,
              media: pendingProps.media,
              hrefLang: pendingProps.hrefLang,
              referrerPolicy: pendingProps.referrerPolicy
            }),
            preloadPropsMap.set(type, pendingProps),
            styles$243 ||
              preloadStylesheet(
                JSCompiler_inline_result,
                type,
                pendingProps,
                resource$244.state
              )));
        if (currentProps && null === currentResource)
          throw Error(formatProdErrorMessage(528, ""));
        return resource$244;
      }
      if (currentProps && null !== currentResource)
        throw Error(formatProdErrorMessage(529, ""));
      return null;
    case "script":
      return (
        (currentProps = pendingProps.async),
        (pendingProps = pendingProps.src),
        "string" === typeof pendingProps &&
        currentProps &&
        "function" !== typeof currentProps &&
        "symbol" !== typeof currentProps
          ? ((currentProps = getScriptKey(pendingProps)),
            (pendingProps = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableScripts),
            (currentResource = pendingProps.get(currentProps)),
            currentResource ||
              ((currentResource = {
                type: "script",
                instance: null,
                count: 0,
                state: null
              }),
              pendingProps.set(currentProps, currentResource)),
            currentResource)
          : { type: "void", instance: null, count: 0, state: null }
      );
    default:
      throw Error(formatProdErrorMessage(444, type));
  }
}
function getStyleKey(href) {
  return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
}
function getStylesheetSelectorFromKey(key) {
  return 'link[rel="stylesheet"][' + key + "]";
}
function stylesheetPropsFromRawProps(rawProps) {
  return assign({}, rawProps, {
    "data-precedence": rawProps.precedence,
    precedence: null
  });
}
function preloadStylesheet(ownerDocument, key, preloadProps, state) {
  ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]")
    ? (state.loading = 1)
    : ((key = ownerDocument.createElement("link")),
      (state.preload = key),
      key.addEventListener("load", function () {
        return (state.loading |= 1);
      }),
      key.addEventListener("error", function () {
        return (state.loading |= 2);
      }),
      setInitialProperties(key, "link", preloadProps),
      markNodeAsHoistable(key),
      ownerDocument.head.appendChild(key));
}
function getScriptKey(src) {
  return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
}
function getScriptSelectorFromKey(key) {
  return "script[async]" + key;
}
function acquireResource(hoistableRoot, resource, props) {
  resource.count++;
  if (null === resource.instance)
    switch (resource.type) {
      case "style":
        var instance = hoistableRoot.querySelector(
          'style[data-href~="' +
            escapeSelectorAttributeValueInsideDoubleQuotes(props.href) +
            '"]'
        );
        if (instance)
          return (
            (resource.instance = instance),
            markNodeAsHoistable(instance),
            instance
          );
        var styleProps = assign({}, props, {
          "data-href": props.href,
          "data-precedence": props.precedence,
          href: null,
          precedence: null
        });
        instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
          "style"
        );
        markNodeAsHoistable(instance);
        setInitialProperties(instance, "style", styleProps);
        insertStylesheet(instance, props.precedence, hoistableRoot);
        return (resource.instance = instance);
      case "stylesheet":
        styleProps = getStyleKey(props.href);
        var instance$249 = hoistableRoot.querySelector(
          getStylesheetSelectorFromKey(styleProps)
        );
        if (instance$249)
          return (
            (resource.state.loading |= 4),
            (resource.instance = instance$249),
            markNodeAsHoistable(instance$249),
            instance$249
          );
        instance = stylesheetPropsFromRawProps(props);
        (styleProps = preloadPropsMap.get(styleProps)) &&
          adoptPreloadPropsForStylesheet(instance, styleProps);
        instance$249 = (
          hoistableRoot.ownerDocument || hoistableRoot
        ).createElement("link");
        markNodeAsHoistable(instance$249);
        var linkInstance = instance$249;
        linkInstance._p = new Promise(function (resolve, reject) {
          linkInstance.onload = resolve;
          linkInstance.onerror = reject;
        });
        setInitialProperties(instance$249, "link", instance);
        resource.state.loading |= 4;
        insertStylesheet(instance$249, props.precedence, hoistableRoot);
        return (resource.instance = instance$249);
      case "script":
        instance$249 = getScriptKey(props.src);
        if (
          (styleProps = hoistableRoot.querySelector(
            getScriptSelectorFromKey(instance$249)
          ))
        )
          return (
            (resource.instance = styleProps),
            markNodeAsHoistable(styleProps),
            styleProps
          );
        instance = props;
        if ((styleProps = preloadPropsMap.get(instance$249)))
          (instance = assign({}, props)),
            adoptPreloadPropsForScript(instance, styleProps);
        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
        styleProps = hoistableRoot.createElement("script");
        markNodeAsHoistable(styleProps);
        setInitialProperties(styleProps, "link", instance);
        hoistableRoot.head.appendChild(styleProps);
        return (resource.instance = styleProps);
      case "void":
        return null;
      default:
        throw Error(formatProdErrorMessage(443, resource.type));
    }
  else
    "stylesheet" === resource.type &&
      0 === (resource.state.loading & 4) &&
      ((instance = resource.instance),
      (resource.state.loading |= 4),
      insertStylesheet(instance, props.precedence, hoistableRoot));
  return resource.instance;
}
function insertStylesheet(instance, precedence, root) {
  for (
    var nodes = root.querySelectorAll(
        'link[rel="stylesheet"][data-precedence],style[data-precedence]'
      ),
      last = nodes.length ? nodes[nodes.length - 1] : null,
      prior = last,
      i = 0;
    i < nodes.length;
    i++
  ) {
    var node = nodes[i];
    if (node.dataset.precedence === precedence) prior = node;
    else if (prior !== last) break;
  }
  prior
    ? prior.parentNode.insertBefore(instance, prior.nextSibling)
    : ((precedence = 9 === root.nodeType ? root.head : root),
      precedence.insertBefore(instance, precedence.firstChild));
}
function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
  null == stylesheetProps.crossOrigin &&
    (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
  null == stylesheetProps.referrerPolicy &&
    (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
  null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
}
function adoptPreloadPropsForScript(scriptProps, preloadProps) {
  null == scriptProps.crossOrigin &&
    (scriptProps.crossOrigin = preloadProps.crossOrigin);
  null == scriptProps.referrerPolicy &&
    (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
  null == scriptProps.integrity &&
    (scriptProps.integrity = preloadProps.integrity);
}
var tagCaches = null;
function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
  if (null === tagCaches) {
    var cache = new Map();
    var caches = (tagCaches = new Map());
    caches.set(ownerDocument, cache);
  } else
    (caches = tagCaches),
      (cache = caches.get(ownerDocument)),
      cache || ((cache = new Map()), caches.set(ownerDocument, cache));
  if (cache.has(type)) return cache;
  cache.set(type, null);
  ownerDocument = ownerDocument.getElementsByTagName(type);
  for (caches = 0; caches < ownerDocument.length; caches++) {
    var node = ownerDocument[caches];
    if (
      !(
        node[internalHoistableMarker] ||
        node[internalInstanceKey] ||
        ("link" === type && "stylesheet" === node.getAttribute("rel"))
      ) &&
      "http://www.w3.org/2000/svg" !== node.namespaceURI
    ) {
      var nodeKey = node.getAttribute(keyAttribute) || "";
      nodeKey = type + nodeKey;
      var existing = cache.get(nodeKey);
      existing ? existing.push(node) : cache.set(nodeKey, [node]);
    }
  }
  return cache;
}
function mountHoistable(hoistableRoot, type, instance) {
  hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
  hoistableRoot.head.insertBefore(
    instance,
    "title" === type ? hoistableRoot.querySelector("head > title") : null
  );
}
function isHostHoistableType(type, props, hostContext) {
  if (1 === hostContext || null != props.itemProp) return !1;
  switch (type) {
    case "meta":
    case "title":
      return !0;
    case "style":
      if (
        "string" !== typeof props.precedence ||
        "string" !== typeof props.href ||
        "" === props.href
      )
        break;
      return !0;
    case "link":
      if (
        "string" !== typeof props.rel ||
        "string" !== typeof props.href ||
        "" === props.href ||
        props.onLoad ||
        props.onError
      )
        break;
      switch (props.rel) {
        case "stylesheet":
          return (
            (type = props.disabled),
            "string" === typeof props.precedence && null == type
          );
        default:
          return !0;
      }
    case "script":
      if (
        props.async &&
        "function" !== typeof props.async &&
        "symbol" !== typeof props.async &&
        !props.onLoad &&
        !props.onError &&
        props.src &&
        "string" === typeof props.src
      )
        return !0;
  }
  return !1;
}
function preloadResource(resource) {
  return "stylesheet" === resource.type && 0 === (resource.state.loading & 3)
    ? !1
    : !0;
}
function suspendResource(state, hoistableRoot, resource, props) {
  if (
    "stylesheet" === resource.type &&
    ("string" !== typeof props.media ||
      !1 !== matchMedia(props.media).matches) &&
    0 === (resource.state.loading & 4)
  ) {
    if (null === resource.instance) {
      var key = getStyleKey(props.href),
        instance = hoistableRoot.querySelector(
          getStylesheetSelectorFromKey(key)
        );
      if (instance) {
        hoistableRoot = instance._p;
        null !== hoistableRoot &&
          "object" === typeof hoistableRoot &&
          "function" === typeof hoistableRoot.then &&
          (state.count++,
          (state = onUnsuspend.bind(state)),
          hoistableRoot.then(state, state));
        resource.state.loading |= 4;
        resource.instance = instance;
        markNodeAsHoistable(instance);
        return;
      }
      instance = hoistableRoot.ownerDocument || hoistableRoot;
      props = stylesheetPropsFromRawProps(props);
      (key = preloadPropsMap.get(key)) &&
        adoptPreloadPropsForStylesheet(props, key);
      instance = instance.createElement("link");
      markNodeAsHoistable(instance);
      var linkInstance = instance;
      linkInstance._p = new Promise(function (resolve, reject) {
        linkInstance.onload = resolve;
        linkInstance.onerror = reject;
      });
      setInitialProperties(instance, "link", props);
      resource.instance = instance;
    }
    null === state.stylesheets && (state.stylesheets = new Map());
    state.stylesheets.set(resource, hoistableRoot);
    (hoistableRoot = resource.state.preload) &&
      0 === (resource.state.loading & 3) &&
      (state.count++,
      (resource = onUnsuspend.bind(state)),
      hoistableRoot.addEventListener("load", resource),
      hoistableRoot.addEventListener("error", resource));
  }
}
var estimatedBytesWithinLimit = 0;
function waitForCommitToBeReady(state, timeoutOffset) {
  state.stylesheets &&
    0 === state.count &&
    insertSuspendedStylesheets(state, state.stylesheets);
  return 0 < state.count || 0 < state.imgCount
    ? function (commit) {
        var stylesheetTimer = setTimeout(function () {
          state.stylesheets &&
            insertSuspendedStylesheets(state, state.stylesheets);
          if (state.unsuspend) {
            var unsuspend = state.unsuspend;
            state.unsuspend = null;
            unsuspend();
          }
        }, 6e4 + timeoutOffset);
        0 < state.imgBytes &&
          0 === estimatedBytesWithinLimit &&
          (estimatedBytesWithinLimit = 62500 * estimateBandwidth());
        var imgTimer = setTimeout(
          function () {
            state.waitingForImages = !1;
            if (
              0 === state.count &&
              (state.stylesheets &&
                insertSuspendedStylesheets(state, state.stylesheets),
              state.unsuspend)
            ) {
              var unsuspend = state.unsuspend;
              state.unsuspend = null;
              unsuspend();
            }
          },
          (state.imgBytes > estimatedBytesWithinLimit ? 50 : 800) +
            timeoutOffset
        );
        state.unsuspend = commit;
        return function () {
          state.unsuspend = null;
          clearTimeout(stylesheetTimer);
          clearTimeout(imgTimer);
        };
      }
    : null;
}
function onUnsuspend() {
  this.count--;
  if (0 === this.count && (0 === this.imgCount || !this.waitingForImages))
    if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
    else if (this.unsuspend) {
      var unsuspend = this.unsuspend;
      this.unsuspend = null;
      unsuspend();
    }
}
var precedencesByRoot = null;
function insertSuspendedStylesheets(state, resources) {
  state.stylesheets = null;
  null !== state.unsuspend &&
    (state.count++,
    (precedencesByRoot = new Map()),
    resources.forEach(insertStylesheetIntoRoot, state),
    (precedencesByRoot = null),
    onUnsuspend.call(state));
}
function insertStylesheetIntoRoot(root, resource) {
  if (!(resource.state.loading & 4)) {
    var precedences = precedencesByRoot.get(root);
    if (precedences) var last = precedences.get(null);
    else {
      precedences = new Map();
      precedencesByRoot.set(root, precedences);
      for (
        var nodes = root.querySelectorAll(
            "link[data-precedence],style[data-precedence]"
          ),
          i = 0;
        i < nodes.length;
        i++
      ) {
        var node = nodes[i];
        if (
          "LINK" === node.nodeName ||
          "not all" !== node.getAttribute("media")
        )
          precedences.set(node.dataset.precedence, node), (last = node);
      }
      last && precedences.set(null, last);
    }
    nodes = resource.instance;
    node = nodes.getAttribute("data-precedence");
    i = precedences.get(node) || last;
    i === last && precedences.set(null, nodes);
    precedences.set(node, nodes);
    this.count++;
    last = onUnsuspend.bind(this);
    nodes.addEventListener("load", last);
    nodes.addEventListener("error", last);
    i
      ? i.parentNode.insertBefore(nodes, i.nextSibling)
      : ((root = 9 === root.nodeType ? root.head : root),
        root.insertBefore(nodes, root.firstChild));
    resource.state.loading |= 4;
  }
}
var HostTransitionContext = {
  $$typeof: REACT_CONTEXT_TYPE,
  Provider: null,
  Consumer: null,
  _currentValue: sharedNotPendingObject,
  _currentValue2: sharedNotPendingObject,
  _threadCount: 0
};
function FiberRootNode(
  containerInfo,
  tag,
  hydrate,
  identifierPrefix,
  onUncaughtError,
  onCaughtError,
  onRecoverableError,
  onDefaultTransitionIndicator,
  formState
) {
  this.tag = 1;
  this.containerInfo = containerInfo;
  this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode =
    this.next =
    this.pendingContext =
    this.context =
    this.cancelPendingCommit =
      null;
  this.callbackPriority = 0;
  this.expirationTimes = createLaneMap(-1);
  this.entangledLanes =
    this.shellSuspendCounter =
    this.errorRecoveryDisabledLanes =
    this.expiredLanes =
    this.warmLanes =
    this.pingedLanes =
    this.suspendedLanes =
    this.pendingLanes =
      0;
  this.entanglements = createLaneMap(0);
  this.hiddenUpdates = createLaneMap(null);
  this.identifierPrefix = identifierPrefix;
  this.onUncaughtError = onUncaughtError;
  this.onCaughtError = onCaughtError;
  this.onRecoverableError = onRecoverableError;
  this.pooledCache = null;
  this.pooledCacheLanes = 0;
  this.formState = formState;
  this.incompleteTransitions = new Map();
}
function createFiberRoot(
  containerInfo,
  tag,
  hydrate,
  initialChildren,
  hydrationCallbacks,
  isStrictMode,
  identifierPrefix,
  formState,
  onUncaughtError,
  onCaughtError,
  onRecoverableError,
  onDefaultTransitionIndicator
) {
  containerInfo = new FiberRootNode(
    containerInfo,
    tag,
    hydrate,
    identifierPrefix,
    onUncaughtError,
    onCaughtError,
    onRecoverableError,
    onDefaultTransitionIndicator,
    formState
  );
  tag = 1;
  !0 === isStrictMode && (tag |= 24);
  isStrictMode = createFiberImplClass(3, null, null, tag);
  containerInfo.current = isStrictMode;
  isStrictMode.stateNode = containerInfo;
  tag = createCache();
  tag.refCount++;
  containerInfo.pooledCache = tag;
  tag.refCount++;
  isStrictMode.memoizedState = {
    element: initialChildren,
    isDehydrated: hydrate,
    cache: tag
  };
  initializeUpdateQueue(isStrictMode);
  return containerInfo;
}
function getContextForSubtree(parentComponent) {
  if (!parentComponent) return emptyContextObject;
  parentComponent = emptyContextObject;
  return parentComponent;
}
function updateContainerImpl(
  rootFiber,
  lane,
  element,
  container,
  parentComponent,
  callback
) {
  parentComponent = getContextForSubtree(parentComponent);
  null === container.context
    ? (container.context = parentComponent)
    : (container.pendingContext = parentComponent);
  container = createUpdate(lane);
  container.payload = { element: element };
  callback = void 0 === callback ? null : callback;
  null !== callback && (container.callback = callback);
  element = enqueueUpdate(rootFiber, container, lane);
  null !== element &&
    (scheduleUpdateOnFiber(element, rootFiber, lane),
    entangleTransitions(element, rootFiber, lane));
}
function markRetryLaneImpl(fiber, retryLane) {
  fiber = fiber.memoizedState;
  if (null !== fiber && null !== fiber.dehydrated) {
    var a = fiber.retryLane;
    fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
  }
}
function markRetryLaneIfNotHydrated(fiber, retryLane) {
  markRetryLaneImpl(fiber, retryLane);
  (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
}
function attemptContinuousHydration(fiber) {
  if (13 === fiber.tag || 31 === fiber.tag) {
    var root = enqueueConcurrentRenderForLane(fiber, 67108864);
    null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
    markRetryLaneIfNotHydrated(fiber, 67108864);
  }
}
function attemptHydrationAtCurrentPriority(fiber) {
  if (13 === fiber.tag || 31 === fiber.tag) {
    var lane = requestUpdateLane();
    lane = getBumpedLaneForHydrationByLane(lane);
    var root = enqueueConcurrentRenderForLane(fiber, lane);
    null !== root && scheduleUpdateOnFiber(root, fiber, lane);
    markRetryLaneIfNotHydrated(fiber, lane);
  }
}
var _enabled = !0;
function dispatchDiscreteEvent(
  domEventName,
  eventSystemFlags,
  container,
  nativeEvent
) {
  var prevTransition = ReactSharedInternals.T;
  ReactSharedInternals.T = null;
  var previousPriority = ReactDOMSharedInternals.p;
  try {
    (ReactDOMSharedInternals.p = 2),
      dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
  } finally {
    (ReactDOMSharedInternals.p = previousPriority),
      (ReactSharedInternals.T = prevTransition);
  }
}
function dispatchContinuousEvent(
  domEventName,
  eventSystemFlags,
  container,
  nativeEvent
) {
  var prevTransition = ReactSharedInternals.T;
  ReactSharedInternals.T = null;
  var previousPriority = ReactDOMSharedInternals.p;
  try {
    (ReactDOMSharedInternals.p = 8),
      dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
  } finally {
    (ReactDOMSharedInternals.p = previousPriority),
      (ReactSharedInternals.T = prevTransition);
  }
}
function dispatchEvent(
  domEventName,
  eventSystemFlags,
  targetContainer,
  nativeEvent
) {
  if (_enabled) {
    var blockedOn = findInstanceBlockingEvent(nativeEvent);
    if (null === blockedOn)
      dispatchEventForPluginEventSystem(
        domEventName,
        eventSystemFlags,
        nativeEvent,
        return_targetInst,
        targetContainer
      ),
        clearIfContinuousEvent(domEventName, nativeEvent);
    else if (
      queueIfContinuousEvent(
        blockedOn,
        domEventName,
        eventSystemFlags,
        targetContainer,
        nativeEvent
      )
    )
      nativeEvent.stopPropagation();
    else if (
      (clearIfContinuousEvent(domEventName, nativeEvent),
      eventSystemFlags & 4 &&
        -1 < discreteReplayableEvents.indexOf(domEventName))
    ) {
      for (; null !== blockedOn; ) {
        var fiber = getInstanceFromNode(blockedOn);
        if (null !== fiber)
          switch (fiber.tag) {
            case 3:
              fiber = fiber.stateNode;
              if (fiber.current.memoizedState.isDehydrated) {
                var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                if (0 !== lanes) {
                  var root = fiber;
                  root.pendingLanes |= 2;
                  for (root.entangledLanes |= 2; lanes; ) {
                    var lane = 1 << (31 - clz32(lanes));
                    root.entanglements[1] |= lane;
                    lanes &= ~lane;
                  }
                  ensureRootIsScheduled(fiber);
                  0 === (executionContext & 6) &&
                    ((workInProgressRootRenderTargetTime = now() + 500),
                    flushSyncWorkAcrossRoots_impl(0, !1));
                }
              }
              break;
            case 31:
            case 13:
              (root = enqueueConcurrentRenderForLane(fiber, 2)),
                null !== root && scheduleUpdateOnFiber(root, fiber, 2),
                flushSyncWork$1(),
                markRetryLaneIfNotHydrated(fiber, 2);
          }
        fiber = findInstanceBlockingEvent(nativeEvent);
        null === fiber &&
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            return_targetInst,
            targetContainer
          );
        if (fiber === blockedOn) break;
        blockedOn = fiber;
      }
      null !== blockedOn && nativeEvent.stopPropagation();
    } else
      dispatchEventForPluginEventSystem(
        domEventName,
        eventSystemFlags,
        nativeEvent,
        null,
        targetContainer
      );
  }
}
function findInstanceBlockingEvent(nativeEvent) {
  nativeEvent = getEventTarget(nativeEvent);
  return findInstanceBlockingTarget(nativeEvent);
}
var return_targetInst = null;
function findInstanceBlockingTarget(targetNode) {
  return_targetInst = null;
  targetNode = getClosestInstanceFromNode(targetNode);
  if (null !== targetNode) {
    var nearestMounted = getNearestMountedFiber(targetNode);
    if (null === nearestMounted) targetNode = null;
    else {
      var tag = nearestMounted.tag;
      if (13 === tag) {
        targetNode = getSuspenseInstanceFromFiber(nearestMounted);
        if (null !== targetNode) return targetNode;
        targetNode = null;
      } else if (31 === tag) {
        targetNode = getActivityInstanceFromFiber(nearestMounted);
        if (null !== targetNode) return targetNode;
        targetNode = null;
      } else if (3 === tag) {
        if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
          return 3 === nearestMounted.tag
            ? nearestMounted.stateNode.containerInfo
            : null;
        targetNode = null;
      } else nearestMounted !== targetNode && (targetNode = null);
    }
  }
  return_targetInst = targetNode;
  return null;
}
function getEventPriority(domEventName) {
  switch (domEventName) {
    case "beforetoggle":
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "toggle":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 2;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 8;
    case "message":
      switch (getCurrentPriorityLevel()) {
        case ImmediatePriority:
          return 2;
        case UserBlockingPriority:
          return 8;
        case NormalPriority$1:
        case LowPriority:
          return 32;
        case IdlePriority:
          return 268435456;
        default:
          return 32;
      }
    default:
      return 32;
  }
}
var hasScheduledReplayAttempt = !1,
  queuedFocus = null,
  queuedDrag = null,
  queuedMouse = null,
  queuedPointers = new Map(),
  queuedPointerCaptures = new Map(),
  queuedExplicitHydrationTargets = [],
  discreteReplayableEvents =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
      " "
    );
function clearIfContinuousEvent(domEventName, nativeEvent) {
  switch (domEventName) {
    case "focusin":
    case "focusout":
      queuedFocus = null;
      break;
    case "dragenter":
    case "dragleave":
      queuedDrag = null;
      break;
    case "mouseover":
    case "mouseout":
      queuedMouse = null;
      break;
    case "pointerover":
    case "pointerout":
      queuedPointers.delete(nativeEvent.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      queuedPointerCaptures.delete(nativeEvent.pointerId);
  }
}
function accumulateOrCreateContinuousQueuedReplayableEvent(
  existingQueuedEvent,
  blockedOn,
  domEventName,
  eventSystemFlags,
  targetContainer,
  nativeEvent
) {
  if (
    null === existingQueuedEvent ||
    existingQueuedEvent.nativeEvent !== nativeEvent
  )
    return (
      (existingQueuedEvent = {
        blockedOn: blockedOn,
        domEventName: domEventName,
        eventSystemFlags: eventSystemFlags,
        nativeEvent: nativeEvent,
        targetContainers: [targetContainer]
      }),
      null !== blockedOn &&
        ((blockedOn = getInstanceFromNode(blockedOn)),
        null !== blockedOn && attemptContinuousHydration(blockedOn)),
      existingQueuedEvent
    );
  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
  blockedOn = existingQueuedEvent.targetContainers;
  null !== targetContainer &&
    -1 === blockedOn.indexOf(targetContainer) &&
    blockedOn.push(targetContainer);
  return existingQueuedEvent;
}
function queueIfContinuousEvent(
  blockedOn,
  domEventName,
  eventSystemFlags,
  targetContainer,
  nativeEvent
) {
  switch (domEventName) {
    case "focusin":
      return (
        (queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedFocus,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        )),
        !0
      );
    case "dragenter":
      return (
        (queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedDrag,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        )),
        !0
      );
    case "mouseover":
      return (
        (queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedMouse,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        )),
        !0
      );
    case "pointerover":
      var pointerId = nativeEvent.pointerId;
      queuedPointers.set(
        pointerId,
        accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedPointers.get(pointerId) || null,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        )
      );
      return !0;
    case "gotpointercapture":
      return (
        (pointerId = nativeEvent.pointerId),
        queuedPointerCaptures.set(
          pointerId,
          accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedPointerCaptures.get(pointerId) || null,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          )
        ),
        !0
      );
  }
  return !1;
}
function attemptExplicitHydrationTarget(queuedTarget) {
  var targetInst = getClosestInstanceFromNode(queuedTarget.target);
  if (null !== targetInst) {
    var nearestMounted = getNearestMountedFiber(targetInst);
    if (null !== nearestMounted)
      if (((targetInst = nearestMounted.tag), 13 === targetInst)) {
        if (
          ((targetInst = getSuspenseInstanceFromFiber(nearestMounted)),
          null !== targetInst)
        ) {
          queuedTarget.blockedOn = targetInst;
          runWithPriority(queuedTarget.priority, function () {
            attemptHydrationAtCurrentPriority(nearestMounted);
          });
          return;
        }
      } else if (31 === targetInst) {
        if (
          ((targetInst = getActivityInstanceFromFiber(nearestMounted)),
          null !== targetInst)
        ) {
          queuedTarget.blockedOn = targetInst;
          runWithPriority(queuedTarget.priority, function () {
            attemptHydrationAtCurrentPriority(nearestMounted);
          });
          return;
        }
      } else if (
        3 === targetInst &&
        nearestMounted.stateNode.current.memoizedState.isDehydrated
      ) {
        queuedTarget.blockedOn =
          3 === nearestMounted.tag
            ? nearestMounted.stateNode.containerInfo
            : null;
        return;
      }
  }
  queuedTarget.blockedOn = null;
}
function attemptReplayContinuousQueuedEvent(queuedEvent) {
  if (null !== queuedEvent.blockedOn) return !1;
  for (
    var targetContainers = queuedEvent.targetContainers;
    0 < targetContainers.length;

  ) {
    var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
    if (null === nextBlockedOn) {
      nextBlockedOn = queuedEvent.nativeEvent;
      var nativeEventClone = new nextBlockedOn.constructor(
        nextBlockedOn.type,
        nextBlockedOn
      );
      currentReplayingEvent = nativeEventClone;
      nextBlockedOn.target.dispatchEvent(nativeEventClone);
      currentReplayingEvent = null;
    } else
      return (
        (targetContainers = getInstanceFromNode(nextBlockedOn)),
        null !== targetContainers &&
          attemptContinuousHydration(targetContainers),
        (queuedEvent.blockedOn = nextBlockedOn),
        !1
      );
    targetContainers.shift();
  }
  return !0;
}
function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
  attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
}
function replayUnblockedEvents() {
  hasScheduledReplayAttempt = !1;
  null !== queuedFocus &&
    attemptReplayContinuousQueuedEvent(queuedFocus) &&
    (queuedFocus = null);
  null !== queuedDrag &&
    attemptReplayContinuousQueuedEvent(queuedDrag) &&
    (queuedDrag = null);
  null !== queuedMouse &&
    attemptReplayContinuousQueuedEvent(queuedMouse) &&
    (queuedMouse = null);
  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
}
function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
  queuedEvent.blockedOn === unblocked &&
    ((queuedEvent.blockedOn = null),
    hasScheduledReplayAttempt ||
      ((hasScheduledReplayAttempt = !0),
      Scheduler.unstable_scheduleCallback(
        Scheduler.unstable_NormalPriority,
        replayUnblockedEvents
      )));
}
var lastScheduledReplayQueue = null;
function scheduleReplayQueueIfNeeded(formReplayingQueue) {
  lastScheduledReplayQueue !== formReplayingQueue &&
    ((lastScheduledReplayQueue = formReplayingQueue),
    Scheduler.unstable_scheduleCallback(
      Scheduler.unstable_NormalPriority,
      function () {
        lastScheduledReplayQueue === formReplayingQueue &&
          (lastScheduledReplayQueue = null);
        for (var i = 0; i < formReplayingQueue.length; i += 3) {
          var form = formReplayingQueue[i],
            submitterOrAction = formReplayingQueue[i + 1],
            formData = formReplayingQueue[i + 2];
          if ("function" !== typeof submitterOrAction)
            if (null === findInstanceBlockingTarget(submitterOrAction || form))
              continue;
            else break;
          var formInst = getInstanceFromNode(form);
          null !== formInst &&
            (formReplayingQueue.splice(i, 3),
            (i -= 3),
            startHostTransition(
              formInst,
              {
                pending: !0,
                data: formData,
                method: form.method,
                action: submitterOrAction
              },
              submitterOrAction,
              formData
            ));
        }
      }
    ));
}
function retryIfBlockedOn(unblocked) {
  function unblock(queuedEvent) {
    return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
  }
  null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
  null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
  null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
  queuedPointers.forEach(unblock);
  queuedPointerCaptures.forEach(unblock);
  for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
    var queuedTarget = queuedExplicitHydrationTargets[i];
    queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
  }
  for (
    ;
    0 < queuedExplicitHydrationTargets.length &&
    ((i = queuedExplicitHydrationTargets[0]), null === i.blockedOn);

  )
    attemptExplicitHydrationTarget(i),
      null === i.blockedOn && queuedExplicitHydrationTargets.shift();
  i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
  if (null != i)
    for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
      var form = i[queuedTarget],
        submitterOrAction = i[queuedTarget + 1],
        formProps = form[internalPropsKey] || null;
      if ("function" === typeof submitterOrAction)
        formProps || scheduleReplayQueueIfNeeded(i);
      else if (formProps) {
        var action = null;
        if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
          if (
            ((form = submitterOrAction),
            (formProps = submitterOrAction[internalPropsKey] || null))
          )
            action = formProps.formAction;
          else {
            if (null !== findInstanceBlockingTarget(form)) continue;
          }
        else action = formProps.action;
        "function" === typeof action
          ? (i[queuedTarget + 1] = action)
          : (i.splice(queuedTarget, 3), (queuedTarget -= 3));
        scheduleReplayQueueIfNeeded(i);
      }
    }
}
function defaultOnDefaultTransitionIndicator() {
  function handleNavigate(event) {
    event.canIntercept &&
      "react-transition" === event.info &&
      event.intercept({
        handler: function () {
          return new Promise(function (resolve) {
            return (pendingResolve = resolve);
          });
        },
        focusReset: "manual",
        scroll: "manual"
      });
  }
  function handleNavigateComplete() {
    null !== pendingResolve && (pendingResolve(), (pendingResolve = null));
    isCancelled || setTimeout(startFakeNavigation, 20);
  }
  function startFakeNavigation() {
    if (!isCancelled && !navigation.transition) {
      var currentEntry = navigation.currentEntry;
      currentEntry &&
        null != currentEntry.url &&
        navigation.navigate(currentEntry.url, {
          state: currentEntry.getState(),
          info: "react-transition",
          history: "replace"
        });
    }
  }
  if ("object" === typeof navigation) {
    var isCancelled = !1,
      pendingResolve = null;
    navigation.addEventListener("navigate", handleNavigate);
    navigation.addEventListener("navigatesuccess", handleNavigateComplete);
    navigation.addEventListener("navigateerror", handleNavigateComplete);
    setTimeout(startFakeNavigation, 100);
    return function () {
      isCancelled = !0;
      navigation.removeEventListener("navigate", handleNavigate);
      navigation.removeEventListener("navigatesuccess", handleNavigateComplete);
      navigation.removeEventListener("navigateerror", handleNavigateComplete);
      null !== pendingResolve && (pendingResolve(), (pendingResolve = null));
    };
  }
}
function ReactDOMRoot(internalRoot) {
  this._internalRoot = internalRoot;
}
ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =
  function (children) {
    var root = this._internalRoot;
    if (null === root) throw Error(formatProdErrorMessage(409));
    var current = root.current,
      lane = requestUpdateLane();
    updateContainerImpl(current, lane, children, root, null, null);
  };
ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount =
  function () {
    var root = this._internalRoot;
    if (null !== root) {
      this._internalRoot = null;
      var container = root.containerInfo;
      updateContainerImpl(root.current, 2, null, root, null, null);
      flushSyncWork$1();
      container[internalContainerInstanceKey] = null;
    }
  };
function ReactDOMHydrationRoot(internalRoot) {
  this._internalRoot = internalRoot;
}
ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {
  if (target) {
    var updatePriority = resolveUpdatePriority();
    target = { blockedOn: null, target: target, priority: updatePriority };
    for (
      var i = 0;
      i < queuedExplicitHydrationTargets.length &&
      0 !== updatePriority &&
      updatePriority < queuedExplicitHydrationTargets[i].priority;
      i++
    );
    queuedExplicitHydrationTargets.splice(i, 0, target);
    0 === i && attemptExplicitHydrationTarget(target);
  }
};
var isomorphicReactPackageVersion$jscomp$inline_1840 = React.version;
if (
  "19.2.0" !==
  isomorphicReactPackageVersion$jscomp$inline_1840
)
  throw Error(
    formatProdErrorMessage(
      527,
      isomorphicReactPackageVersion$jscomp$inline_1840,
      "19.2.0"
    )
  );
ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {
  var fiber = componentOrElement._reactInternals;
  if (void 0 === fiber) {
    if ("function" === typeof componentOrElement.render)
      throw Error(formatProdErrorMessage(188));
    componentOrElement = Object.keys(componentOrElement).join(",");
    throw Error(formatProdErrorMessage(268, componentOrElement));
  }
  componentOrElement = findCurrentFiberUsingSlowPath(fiber);
  componentOrElement =
    null !== componentOrElement
      ? findCurrentHostFiberImpl(componentOrElement)
      : null;
  componentOrElement =
    null === componentOrElement ? null : componentOrElement.stateNode;
  return componentOrElement;
};
var internals$jscomp$inline_2347 = {
  bundleType: 0,
  version: "19.2.0",
  rendererPackageName: "react-dom",
  currentDispatcherRef: ReactSharedInternals,
  reconcilerVersion: "19.2.0"
};
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var hook$jscomp$inline_2348 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (
    !hook$jscomp$inline_2348.isDisabled &&
    hook$jscomp$inline_2348.supportsFiber
  )
    try {
      (rendererID = hook$jscomp$inline_2348.inject(
        internals$jscomp$inline_2347
      )),
        (injectedHook = hook$jscomp$inline_2348);
    } catch (err) {}
}
exports.createRoot = function (container, options) {
  if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
  var isStrictMode = !1,
    identifierPrefix = "",
    onUncaughtError = defaultOnUncaughtError,
    onCaughtError = defaultOnCaughtError,
    onRecoverableError = defaultOnRecoverableError;
  null !== options &&
    void 0 !== options &&
    (!0 === options.unstable_strictMode && (isStrictMode = !0),
    void 0 !== options.identifierPrefix &&
      (identifierPrefix = options.identifierPrefix),
    void 0 !== options.onUncaughtError &&
      (onUncaughtError = options.onUncaughtError),
    void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError),
    void 0 !== options.onRecoverableError &&
      (onRecoverableError = options.onRecoverableError));
  options = createFiberRoot(
    container,
    1,
    !1,
    null,
    null,
    isStrictMode,
    identifierPrefix,
    null,
    onUncaughtError,
    onCaughtError,
    onRecoverableError,
    defaultOnDefaultTransitionIndicator
  );
  container[internalContainerInstanceKey] = options.current;
  listenToAllSupportedEvents(container);
  return new ReactDOMRoot(options);
};
exports.hydrateRoot = function (container, initialChildren, options) {
  if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
  var isStrictMode = !1,
    identifierPrefix = "",
    onUncaughtError = defaultOnUncaughtError,
    onCaughtError = defaultOnCaughtError,
    onRecoverableError = defaultOnRecoverableError,
    formState = null;
  null !== options &&
    void 0 !== options &&
    (!0 === options.unstable_strictMode && (isStrictMode = !0),
    void 0 !== options.identifierPrefix &&
      (identifierPrefix = options.identifierPrefix),
    void 0 !== options.onUncaughtError &&
      (onUncaughtError = options.onUncaughtError),
    void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError),
    void 0 !== options.onRecoverableError &&
      (onRecoverableError = options.onRecoverableError),
    void 0 !== options.formState && (formState = options.formState));
  initialChildren = createFiberRoot(
    container,
    1,
    !0,
    initialChildren,
    null != options ? options : null,
    isStrictMode,
    identifierPrefix,
    formState,
    onUncaughtError,
    onCaughtError,
    onRecoverableError,
    defaultOnDefaultTransitionIndicator
  );
  initialChildren.context = getContextForSubtree(null);
  options = initialChildren.current;
  isStrictMode = requestUpdateLane();
  isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
  identifierPrefix = createUpdate(isStrictMode);
  identifierPrefix.callback = null;
  enqueueUpdate(options, identifierPrefix, isStrictMode);
  options = isStrictMode;
  initialChildren.current.lanes = options;
  markRootUpdated$1(initialChildren, options);
  ensureRootIsScheduled(initialChildren);
  container[internalContainerInstanceKey] = initialChildren.current;
  listenToAllSupportedEvents(container);
  return new ReactDOMHydrationRoot(initialChildren);
};
exports.version = "19.2.0";


}),
6221: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var React = __webpack_require__(96540);
function formatProdErrorMessage(code) {
  var url = "https://react.dev/errors/" + code;
  if (1 < arguments.length) {
    url += "?args[]=" + encodeURIComponent(arguments[1]);
    for (var i = 2; i < arguments.length; i++)
      url += "&args[]=" + encodeURIComponent(arguments[i]);
  }
  return (
    "Minified React error #" +
    code +
    "; visit " +
    url +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
function noop() {}
var Internals = {
    d: {
      f: noop,
      r: function () {
        throw Error(formatProdErrorMessage(522));
      },
      D: noop,
      C: noop,
      L: noop,
      m: noop,
      X: noop,
      S: noop,
      M: noop
    },
    p: 0,
    findDOMNode: null
  },
  REACT_PORTAL_TYPE = Symbol.for("react.portal");
function createPortal$1(children, containerInfo, implementation) {
  var key =
    3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return {
    $$typeof: REACT_PORTAL_TYPE,
    key: null == key ? null : "" + key,
    children: children,
    containerInfo: containerInfo,
    implementation: implementation
  };
}
var ReactSharedInternals =
  React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
function getCrossOriginStringAs(as, input) {
  if ("font" === as) return "";
  if ("string" === typeof input)
    return "use-credentials" === input ? input : "";
}
exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
  Internals;
exports.createPortal = function (children, container) {
  var key =
    2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (
    !container ||
    (1 !== container.nodeType &&
      9 !== container.nodeType &&
      11 !== container.nodeType)
  )
    throw Error(formatProdErrorMessage(299));
  return createPortal$1(children, container, null, key);
};
exports.flushSync = function (fn) {
  var previousTransition = ReactSharedInternals.T,
    previousUpdatePriority = Internals.p;
  try {
    if (((ReactSharedInternals.T = null), (Internals.p = 2), fn)) return fn();
  } finally {
    (ReactSharedInternals.T = previousTransition),
      (Internals.p = previousUpdatePriority),
      Internals.d.f();
  }
};
exports.preconnect = function (href, options) {
  "string" === typeof href &&
    (options
      ? ((options = options.crossOrigin),
        (options =
          "string" === typeof options
            ? "use-credentials" === options
              ? options
              : ""
            : void 0))
      : (options = null),
    Internals.d.C(href, options));
};
exports.prefetchDNS = function (href) {
  "string" === typeof href && Internals.d.D(href);
};
exports.preinit = function (href, options) {
  if ("string" === typeof href && options && "string" === typeof options.as) {
    var as = options.as,
      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),
      integrity =
        "string" === typeof options.integrity ? options.integrity : void 0,
      fetchPriority =
        "string" === typeof options.fetchPriority
          ? options.fetchPriority
          : void 0;
    "style" === as
      ? Internals.d.S(
          href,
          "string" === typeof options.precedence ? options.precedence : void 0,
          {
            crossOrigin: crossOrigin,
            integrity: integrity,
            fetchPriority: fetchPriority
          }
        )
      : "script" === as &&
        Internals.d.X(href, {
          crossOrigin: crossOrigin,
          integrity: integrity,
          fetchPriority: fetchPriority,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0
        });
  }
};
exports.preinitModule = function (href, options) {
  if ("string" === typeof href)
    if ("object" === typeof options && null !== options) {
      if (null == options.as || "script" === options.as) {
        var crossOrigin = getCrossOriginStringAs(
          options.as,
          options.crossOrigin
        );
        Internals.d.M(href, {
          crossOrigin: crossOrigin,
          integrity:
            "string" === typeof options.integrity ? options.integrity : void 0,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0
        });
      }
    } else null == options && Internals.d.M(href);
};
exports.preload = function (href, options) {
  if (
    "string" === typeof href &&
    "object" === typeof options &&
    null !== options &&
    "string" === typeof options.as
  ) {
    var as = options.as,
      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
    Internals.d.L(href, as, {
      crossOrigin: crossOrigin,
      integrity:
        "string" === typeof options.integrity ? options.integrity : void 0,
      nonce: "string" === typeof options.nonce ? options.nonce : void 0,
      type: "string" === typeof options.type ? options.type : void 0,
      fetchPriority:
        "string" === typeof options.fetchPriority
          ? options.fetchPriority
          : void 0,
      referrerPolicy:
        "string" === typeof options.referrerPolicy
          ? options.referrerPolicy
          : void 0,
      imageSrcSet:
        "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
      imageSizes:
        "string" === typeof options.imageSizes ? options.imageSizes : void 0,
      media: "string" === typeof options.media ? options.media : void 0
    });
  }
};
exports.preloadModule = function (href, options) {
  if ("string" === typeof href)
    if (options) {
      var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
      Internals.d.m(href, {
        as:
          "string" === typeof options.as && "script" !== options.as
            ? options.as
            : void 0,
        crossOrigin: crossOrigin,
        integrity:
          "string" === typeof options.integrity ? options.integrity : void 0
      });
    } else Internals.d.m(href);
};
exports.requestFormReset = function (form) {
  Internals.d.r(form);
};
exports.unstable_batchedUpdates = function (fn, a) {
  return fn(a);
};
exports.useFormState = function (action, initialState, permalink) {
  return ReactSharedInternals.H.useFormState(action, initialState, permalink);
};
exports.useFormStatus = function () {
  return ReactSharedInternals.H.useHostTransitionStatus();
};
exports.version = "19.2.0";


}),
5338: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (false) {}
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (true) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(31247);
} else {}


}),
40961: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (false) {}
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (true) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(6221);
} else {}


}),
30115: (function (module) {
/* global Map:readonly, Set:readonly, ArrayBuffer:readonly */

var hasElementType = typeof Element !== 'undefined';
var hasMap = typeof Map === 'function';
var hasSet = typeof Set === 'function';
var hasArrayBuffer = typeof ArrayBuffer === 'function' && !!ArrayBuffer.isView;

// Note: We **don't** need `envHasBigInt64Array` in fde es6/index.js

function equal(a, b) {
  // START: fast-deep-equal es6/index.js 3.1.3
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }

    // START: Modifications:
    // 1. Extra `has<Type> &&` helpers in initial condition allow es6 code
    //    to co-exist with es5.
    // 2. Replace `for of` with es5 compliant iteration using `for`.
    //    Basically, take:
    //
    //    ```js
    //    for (i of a.entries())
    //      if (!b.has(i[0])) return false;
    //    ```
    //
    //    ... and convert to:
    //
    //    ```js
    //    it = a.entries();
    //    while (!(i = it.next()).done)
    //      if (!b.has(i.value[0])) return false;
    //    ```
    //
    //    **Note**: `i` access switches to `i.value`.
    var it;
    if (hasMap && (a instanceof Map) && (b instanceof Map)) {
      if (a.size !== b.size) return false;
      it = a.entries();
      while (!(i = it.next()).done)
        if (!b.has(i.value[0])) return false;
      it = a.entries();
      while (!(i = it.next()).done)
        if (!equal(i.value[1], b.get(i.value[0]))) return false;
      return true;
    }

    if (hasSet && (a instanceof Set) && (b instanceof Set)) {
      if (a.size !== b.size) return false;
      it = a.entries();
      while (!(i = it.next()).done)
        if (!b.has(i.value[0])) return false;
      return true;
    }
    // END: Modifications

    if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (a[i] !== b[i]) return false;
      return true;
    }

    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    // START: Modifications:
    // Apply guards for `Object.create(null)` handling. See:
    // - https://github.com/FormidableLabs/react-fast-compare/issues/64
    // - https://github.com/epoberezkin/fast-deep-equal/issues/49
    if (a.valueOf !== Object.prototype.valueOf && typeof a.valueOf === 'function' && typeof b.valueOf === 'function') return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString && typeof a.toString === 'function' && typeof b.toString === 'function') return a.toString() === b.toString();
    // END: Modifications

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
    // END: fast-deep-equal

    // START: react-fast-compare
    // custom handling for DOM elements
    if (hasElementType && a instanceof Element) return false;

    // custom handling for React/Preact
    for (i = length; i-- !== 0;) {
      if ((keys[i] === '_owner' || keys[i] === '__v' || keys[i] === '__o') && a.$$typeof) {
        // React-specific: avoid traversing React elements' _owner
        // Preact-specific: avoid traversing Preact elements' __v and __o
        //    __v = $_original / $_vnode
        //    __o = $_owner
        // These properties contain circular references and are not needed when
        // comparing the actual elements (and not their owners)
        // .$$typeof and ._store on just reasonable markers of elements

        continue;
      }

      // all other properties should be traversed as usual
      if (!equal(a[keys[i]], b[keys[i]])) return false;
    }
    // END: react-fast-compare

    // START: fast-deep-equal
    return true;
  }

  return a !== a && b !== b;
}
// end fast-deep-equal

module.exports = function isEqual(a, b) {
  try {
    return equal(a, b);
  } catch (error) {
    if (((error.message || '').match(/stack|recursion/i))) {
      // warn on circular references, don't crash
      // browsers give this different errors name and messages:
      // chrome/safari: "RangeError", "Maximum call stack size exceeded"
      // firefox: "InternalError", too much recursion"
      // edge: "Error", "Out of stack space"
      console.warn('react-fast-compare cannot handle circular refs');
      return false;
    }
    // some other error. we should definitely know about these
    throw error;
  }
};


}),
80545: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  mg: () => (W),
  vd: () => (q)
});
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var prop_types__rspack_import_4 = __webpack_require__(5556);
/* import */ var prop_types__rspack_import_4_default = /*#__PURE__*/__webpack_require__.n(prop_types__rspack_import_4);
/* import */ var react_fast_compare__rspack_import_1 = __webpack_require__(30115);
/* import */ var react_fast_compare__rspack_import_1_default = /*#__PURE__*/__webpack_require__.n(react_fast_compare__rspack_import_1);
/* import */ var invariant__rspack_import_2 = __webpack_require__(20311);
/* import */ var invariant__rspack_import_2_default = /*#__PURE__*/__webpack_require__.n(invariant__rspack_import_2);
/* import */ var shallowequal__rspack_import_3 = __webpack_require__(2833);
/* import */ var shallowequal__rspack_import_3_default = /*#__PURE__*/__webpack_require__.n(shallowequal__rspack_import_3);
function a(){return a=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(t[n]=r[n])}return t},a.apply(this,arguments)}function s(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t,c(t,e)}function c(t,e){return c=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t},c(t,e)}function u(t,e){if(null==t)return{};var r,n,i={},o=Object.keys(t);for(n=0;n<o.length;n++)e.indexOf(r=o[n])>=0||(i[r]=t[r]);return i}var l={BASE:"base",BODY:"body",HEAD:"head",HTML:"html",LINK:"link",META:"meta",NOSCRIPT:"noscript",SCRIPT:"script",STYLE:"style",TITLE:"title",FRAGMENT:"Symbol(react.fragment)"},p={rel:["amphtml","canonical","alternate"]},f={type:["application/ld+json"]},d={charset:"",name:["robots","description"],property:["og:type","og:title","og:url","og:image","og:image:alt","og:description","twitter:url","twitter:title","twitter:description","twitter:image","twitter:image:alt","twitter:card","twitter:site"]},h=Object.keys(l).map(function(t){return l[t]}),m={accesskey:"accessKey",charset:"charSet",class:"className",contenteditable:"contentEditable",contextmenu:"contextMenu","http-equiv":"httpEquiv",itemprop:"itemProp",tabindex:"tabIndex"},y=Object.keys(m).reduce(function(t,e){return t[m[e]]=e,t},{}),T=function(t,e){for(var r=t.length-1;r>=0;r-=1){var n=t[r];if(Object.prototype.hasOwnProperty.call(n,e))return n[e]}return null},g=function(t){var e=T(t,l.TITLE),r=T(t,"titleTemplate");if(Array.isArray(e)&&(e=e.join("")),r&&e)return r.replace(/%s/g,function(){return e});var n=T(t,"defaultTitle");return e||n||void 0},b=function(t){return T(t,"onChangeClientState")||function(){}},v=function(t,e){return e.filter(function(e){return void 0!==e[t]}).map(function(e){return e[t]}).reduce(function(t,e){return a({},t,e)},{})},A=function(t,e){return e.filter(function(t){return void 0!==t[l.BASE]}).map(function(t){return t[l.BASE]}).reverse().reduce(function(e,r){if(!e.length)for(var n=Object.keys(r),i=0;i<n.length;i+=1){var o=n[i].toLowerCase();if(-1!==t.indexOf(o)&&r[o])return e.concat(r)}return e},[])},C=function(t,e,r){var n={};return r.filter(function(e){return!!Array.isArray(e[t])||(void 0!==e[t]&&console&&"function"==typeof console.warn&&console.warn("Helmet: "+t+' should be of type "Array". Instead found type "'+typeof e[t]+'"'),!1)}).map(function(e){return e[t]}).reverse().reduce(function(t,r){var i={};r.filter(function(t){for(var r,o=Object.keys(t),a=0;a<o.length;a+=1){var s=o[a],c=s.toLowerCase();-1===e.indexOf(c)||"rel"===r&&"canonical"===t[r].toLowerCase()||"rel"===c&&"stylesheet"===t[c].toLowerCase()||(r=c),-1===e.indexOf(s)||"innerHTML"!==s&&"cssText"!==s&&"itemprop"!==s||(r=s)}if(!r||!t[r])return!1;var u=t[r].toLowerCase();return n[r]||(n[r]={}),i[r]||(i[r]={}),!n[r][u]&&(i[r][u]=!0,!0)}).reverse().forEach(function(e){return t.push(e)});for(var o=Object.keys(i),s=0;s<o.length;s+=1){var c=o[s],u=a({},n[c],i[c]);n[c]=u}return t},[]).reverse()},O=function(t,e){if(Array.isArray(t)&&t.length)for(var r=0;r<t.length;r+=1)if(t[r][e])return!0;return!1},S=function(t){return Array.isArray(t)?t.join(""):t},E=function(t,e){return Array.isArray(t)?t.reduce(function(t,r){return function(t,e){for(var r=Object.keys(t),n=0;n<r.length;n+=1)if(e[r[n]]&&e[r[n]].includes(t[r[n]]))return!0;return!1}(r,e)?t.priority.push(r):t.default.push(r),t},{priority:[],default:[]}):{default:t}},I=function(t,e){var r;return a({},t,((r={})[e]=void 0,r))},P=[l.NOSCRIPT,l.SCRIPT,l.STYLE],w=function(t,e){return void 0===e&&(e=!0),!1===e?String(t):String(t).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#x27;")},x=function(t){return Object.keys(t).reduce(function(e,r){var n=void 0!==t[r]?r+'="'+t[r]+'"':""+r;return e?e+" "+n:n},"")},L=function(t,e){return void 0===e&&(e={}),Object.keys(t).reduce(function(e,r){return e[m[r]||r]=t[r],e},e)},j=function(e,r){return r.map(function(r,n){var i,o=((i={key:n})["data-rh"]=!0,i);return Object.keys(r).forEach(function(t){var e=m[t]||t;"innerHTML"===e||"cssText"===e?o.dangerouslySetInnerHTML={__html:r.innerHTML||r.cssText}:o[e]=r[t]}),react__rspack_import_0.createElement(e,o)})},M=function(e,r,n){switch(e){case l.TITLE:return{toComponent:function(){return n=r.titleAttributes,(i={key:e=r.title})["data-rh"]=!0,o=L(n,i),[react__rspack_import_0.createElement(l.TITLE,o,e)];var e,n,i,o},toString:function(){return function(t,e,r,n){var i=x(r),o=S(e);return i?"<"+t+' data-rh="true" '+i+">"+w(o,n)+"</"+t+">":"<"+t+' data-rh="true">'+w(o,n)+"</"+t+">"}(e,r.title,r.titleAttributes,n)}};case"bodyAttributes":case"htmlAttributes":return{toComponent:function(){return L(r)},toString:function(){return x(r)}};default:return{toComponent:function(){return j(e,r)},toString:function(){return function(t,e,r){return e.reduce(function(e,n){var i=Object.keys(n).filter(function(t){return!("innerHTML"===t||"cssText"===t)}).reduce(function(t,e){var i=void 0===n[e]?e:e+'="'+w(n[e],r)+'"';return t?t+" "+i:i},""),o=n.innerHTML||n.cssText||"",a=-1===P.indexOf(t);return e+"<"+t+' data-rh="true" '+i+(a?"/>":">"+o+"</"+t+">")},"")}(e,r,n)}}}},k=function(t){var e=t.baseTag,r=t.bodyAttributes,n=t.encode,i=t.htmlAttributes,o=t.noscriptTags,a=t.styleTags,s=t.title,c=void 0===s?"":s,u=t.titleAttributes,h=t.linkTags,m=t.metaTags,y=t.scriptTags,T={toComponent:function(){},toString:function(){return""}};if(t.prioritizeSeoTags){var g=function(t){var e=t.linkTags,r=t.scriptTags,n=t.encode,i=E(t.metaTags,d),o=E(e,p),a=E(r,f);return{priorityMethods:{toComponent:function(){return[].concat(j(l.META,i.priority),j(l.LINK,o.priority),j(l.SCRIPT,a.priority))},toString:function(){return M(l.META,i.priority,n)+" "+M(l.LINK,o.priority,n)+" "+M(l.SCRIPT,a.priority,n)}},metaTags:i.default,linkTags:o.default,scriptTags:a.default}}(t);T=g.priorityMethods,h=g.linkTags,m=g.metaTags,y=g.scriptTags}return{priority:T,base:M(l.BASE,e,n),bodyAttributes:M("bodyAttributes",r,n),htmlAttributes:M("htmlAttributes",i,n),link:M(l.LINK,h,n),meta:M(l.META,m,n),noscript:M(l.NOSCRIPT,o,n),script:M(l.SCRIPT,y,n),style:M(l.STYLE,a,n),title:M(l.TITLE,{title:c,titleAttributes:u},n)}},H=[],N=function(t,e){var r=this;void 0===e&&(e="undefined"!=typeof document),this.instances=[],this.value={setHelmet:function(t){r.context.helmet=t},helmetInstances:{get:function(){return r.canUseDOM?H:r.instances},add:function(t){(r.canUseDOM?H:r.instances).push(t)},remove:function(t){var e=(r.canUseDOM?H:r.instances).indexOf(t);(r.canUseDOM?H:r.instances).splice(e,1)}}},this.context=t,this.canUseDOM=e,e||(t.helmet=k({baseTag:[],bodyAttributes:{},encodeSpecialCharacters:!0,htmlAttributes:{},linkTags:[],metaTags:[],noscriptTags:[],scriptTags:[],styleTags:[],title:"",titleAttributes:{}}))},R=react__rspack_import_0.createContext({}),D=prop_types__rspack_import_4_default().shape({setHelmet:(prop_types__rspack_import_4_default().func),helmetInstances:prop_types__rspack_import_4_default().shape({get:(prop_types__rspack_import_4_default().func),add:(prop_types__rspack_import_4_default().func),remove:(prop_types__rspack_import_4_default().func)})}),U="undefined"!=typeof document,q=/*#__PURE__*/function(e){function r(t){var n;return(n=e.call(this,t)||this).helmetData=new N(n.props.context,r.canUseDOM),n}return s(r,e),r.prototype.render=function(){/*#__PURE__*/return react__rspack_import_0.createElement(R.Provider,{value:this.helmetData.value},this.props.children)},r}(react__rspack_import_0.Component);q.canUseDOM=U,q.propTypes={context:prop_types__rspack_import_4_default().shape({helmet:prop_types__rspack_import_4_default().shape()}),children:(prop_types__rspack_import_4_default().node.isRequired)},q.defaultProps={context:{}},q.displayName="HelmetProvider";var Y=function(t,e){var r,n=document.head||document.querySelector(l.HEAD),i=n.querySelectorAll(t+"[data-rh]"),o=[].slice.call(i),a=[];return e&&e.length&&e.forEach(function(e){var n=document.createElement(t);for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&("innerHTML"===i?n.innerHTML=e.innerHTML:"cssText"===i?n.styleSheet?n.styleSheet.cssText=e.cssText:n.appendChild(document.createTextNode(e.cssText)):n.setAttribute(i,void 0===e[i]?"":e[i]));n.setAttribute("data-rh","true"),o.some(function(t,e){return r=e,n.isEqualNode(t)})?o.splice(r,1):a.push(n)}),o.forEach(function(t){return t.parentNode.removeChild(t)}),a.forEach(function(t){return n.appendChild(t)}),{oldTags:o,newTags:a}},B=function(t,e){var r=document.getElementsByTagName(t)[0];if(r){for(var n=r.getAttribute("data-rh"),i=n?n.split(","):[],o=[].concat(i),a=Object.keys(e),s=0;s<a.length;s+=1){var c=a[s],u=e[c]||"";r.getAttribute(c)!==u&&r.setAttribute(c,u),-1===i.indexOf(c)&&i.push(c);var l=o.indexOf(c);-1!==l&&o.splice(l,1)}for(var p=o.length-1;p>=0;p-=1)r.removeAttribute(o[p]);i.length===o.length?r.removeAttribute("data-rh"):r.getAttribute("data-rh")!==a.join(",")&&r.setAttribute("data-rh",a.join(","))}},K=function(t,e){var r=t.baseTag,n=t.htmlAttributes,i=t.linkTags,o=t.metaTags,a=t.noscriptTags,s=t.onChangeClientState,c=t.scriptTags,u=t.styleTags,p=t.title,f=t.titleAttributes;B(l.BODY,t.bodyAttributes),B(l.HTML,n),function(t,e){void 0!==t&&document.title!==t&&(document.title=S(t)),B(l.TITLE,e)}(p,f);var d={baseTag:Y(l.BASE,r),linkTags:Y(l.LINK,i),metaTags:Y(l.META,o),noscriptTags:Y(l.NOSCRIPT,a),scriptTags:Y(l.SCRIPT,c),styleTags:Y(l.STYLE,u)},h={},m={};Object.keys(d).forEach(function(t){var e=d[t],r=e.newTags,n=e.oldTags;r.length&&(h[t]=r),n.length&&(m[t]=d[t].oldTags)}),e&&e(),s(t,h,m)},_=null,z=/*#__PURE__*/function(t){function e(){for(var e,r=arguments.length,n=new Array(r),i=0;i<r;i++)n[i]=arguments[i];return(e=t.call.apply(t,[this].concat(n))||this).rendered=!1,e}s(e,t);var r=e.prototype;return r.shouldComponentUpdate=function(t){return!shallowequal__rspack_import_3_default()(t,this.props)},r.componentDidUpdate=function(){this.emitChange()},r.componentWillUnmount=function(){this.props.context.helmetInstances.remove(this),this.emitChange()},r.emitChange=function(){var t,e,r=this.props.context,n=r.setHelmet,i=null,o=(t=r.helmetInstances.get().map(function(t){var e=a({},t.props);return delete e.context,e}),{baseTag:A(["href"],t),bodyAttributes:v("bodyAttributes",t),defer:T(t,"defer"),encode:T(t,"encodeSpecialCharacters"),htmlAttributes:v("htmlAttributes",t),linkTags:C(l.LINK,["rel","href"],t),metaTags:C(l.META,["name","charset","http-equiv","property","itemprop"],t),noscriptTags:C(l.NOSCRIPT,["innerHTML"],t),onChangeClientState:b(t),scriptTags:C(l.SCRIPT,["src","innerHTML"],t),styleTags:C(l.STYLE,["cssText"],t),title:g(t),titleAttributes:v("titleAttributes",t),prioritizeSeoTags:O(t,"prioritizeSeoTags")});q.canUseDOM?(e=o,_&&cancelAnimationFrame(_),e.defer?_=requestAnimationFrame(function(){K(e,function(){_=null})}):(K(e),_=null)):k&&(i=k(o)),n(i)},r.init=function(){this.rendered||(this.rendered=!0,this.props.context.helmetInstances.add(this),this.emitChange())},r.render=function(){return this.init(),null},e}(react__rspack_import_0.Component);z.propTypes={context:D.isRequired},z.displayName="HelmetDispatcher";var F=["children"],G=["children"],W=/*#__PURE__*/function(e){function r(){return e.apply(this,arguments)||this}s(r,e);var o=r.prototype;return o.shouldComponentUpdate=function(t){return!react_fast_compare__rspack_import_1_default()(I(this.props,"helmetData"),I(t,"helmetData"))},o.mapNestedChildrenToProps=function(t,e){if(!e)return null;switch(t.type){case l.SCRIPT:case l.NOSCRIPT:return{innerHTML:e};case l.STYLE:return{cssText:e};default:throw new Error("<"+t.type+" /> elements are self-closing and can not contain children. Refer to our API for more information.")}},o.flattenArrayTypeChildren=function(t){var e,r=t.child,n=t.arrayTypeChildren;return a({},n,((e={})[r.type]=[].concat(n[r.type]||[],[a({},t.newChildProps,this.mapNestedChildrenToProps(r,t.nestedChildren))]),e))},o.mapObjectTypeChildren=function(t){var e,r,n=t.child,i=t.newProps,o=t.newChildProps,s=t.nestedChildren;switch(n.type){case l.TITLE:return a({},i,((e={})[n.type]=s,e.titleAttributes=a({},o),e));case l.BODY:return a({},i,{bodyAttributes:a({},o)});case l.HTML:return a({},i,{htmlAttributes:a({},o)});default:return a({},i,((r={})[n.type]=a({},o),r))}},o.mapArrayTypeChildrenToProps=function(t,e){var r=a({},e);return Object.keys(t).forEach(function(e){var n;r=a({},r,((n={})[e]=t[e],n))}),r},o.warnOnInvalidChildren=function(t,e){return invariant__rspack_import_2_default()(h.some(function(e){return t.type===e}),"function"==typeof t.type?"You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information.":"Only elements types "+h.join(", ")+" are allowed. Helmet does not support rendering <"+t.type+"> elements. Refer to our API for more information."),invariant__rspack_import_2_default()(!e||"string"==typeof e||Array.isArray(e)&&!e.some(function(t){return"string"!=typeof t}),"Helmet expects a string as a child of <"+t.type+">. Did you forget to wrap your children in braces? ( <"+t.type+">{``}</"+t.type+"> ) Refer to our API for more information."),!0},o.mapChildrenToProps=function(e,r){var n=this,i={};return react__rspack_import_0.Children.forEach(e,function(t){if(t&&t.props){var e=t.props,o=e.children,a=u(e,F),s=Object.keys(a).reduce(function(t,e){return t[y[e]||e]=a[e],t},{}),c=t.type;switch("symbol"==typeof c?c=c.toString():n.warnOnInvalidChildren(t,o),c){case l.FRAGMENT:r=n.mapChildrenToProps(o,r);break;case l.LINK:case l.META:case l.NOSCRIPT:case l.SCRIPT:case l.STYLE:i=n.flattenArrayTypeChildren({child:t,arrayTypeChildren:i,newChildProps:s,nestedChildren:o});break;default:r=n.mapObjectTypeChildren({child:t,newProps:r,newChildProps:s,nestedChildren:o})}}}),this.mapArrayTypeChildrenToProps(i,r)},o.render=function(){var e=this.props,r=e.children,n=u(e,G),i=a({},n),o=n.helmetData;return r&&(i=this.mapChildrenToProps(r,i)),!o||o instanceof N||(o=new N(o.context,o.instances)),o?/*#__PURE__*/react__rspack_import_0.createElement(z,a({},i,{context:o.value,helmetData:void 0})):/*#__PURE__*/react__rspack_import_0.createElement(R.Consumer,null,function(e){/*#__PURE__*/return react__rspack_import_0.createElement(z,a({},i,{context:e}))})},r}(react__rspack_import_0.Component);W.propTypes={base:(prop_types__rspack_import_4_default().object),bodyAttributes:(prop_types__rspack_import_4_default().object),children:prop_types__rspack_import_4_default().oneOfType([prop_types__rspack_import_4_default().arrayOf((prop_types__rspack_import_4_default().node)),(prop_types__rspack_import_4_default().node)]),defaultTitle:(prop_types__rspack_import_4_default().string),defer:(prop_types__rspack_import_4_default().bool),encodeSpecialCharacters:(prop_types__rspack_import_4_default().bool),htmlAttributes:(prop_types__rspack_import_4_default().object),link:prop_types__rspack_import_4_default().arrayOf((prop_types__rspack_import_4_default().object)),meta:prop_types__rspack_import_4_default().arrayOf((prop_types__rspack_import_4_default().object)),noscript:prop_types__rspack_import_4_default().arrayOf((prop_types__rspack_import_4_default().object)),onChangeClientState:(prop_types__rspack_import_4_default().func),script:prop_types__rspack_import_4_default().arrayOf((prop_types__rspack_import_4_default().object)),style:prop_types__rspack_import_4_default().arrayOf((prop_types__rspack_import_4_default().object)),title:(prop_types__rspack_import_4_default().string),titleAttributes:(prop_types__rspack_import_4_default().object),titleTemplate:(prop_types__rspack_import_4_default().string),prioritizeSeoTags:(prop_types__rspack_import_4_default().bool),helmetData:(prop_types__rspack_import_4_default().object)},W.defaultProps={defer:!0,encodeSpecialCharacters:!0,prioritizeSeoTags:!1},W.displayName="Helmet";
//# sourceMappingURL=index.module.js.map


}),
22799: (function (__unused_webpack_module, exports) {
"use strict";
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;exports.Fragment=e;exports.Lazy=t;exports.Memo=r;exports.Portal=d;
exports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isAsyncMode=function(a){return A(a)||z(a)===l};exports.isConcurrentMode=A;exports.isContextConsumer=function(a){return z(a)===k};exports.isContextProvider=function(a){return z(a)===h};exports.isElement=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return z(a)===n};exports.isFragment=function(a){return z(a)===e};exports.isLazy=function(a){return z(a)===t};
exports.isMemo=function(a){return z(a)===r};exports.isPortal=function(a){return z(a)===d};exports.isProfiler=function(a){return z(a)===g};exports.isStrictMode=function(a){return z(a)===f};exports.isSuspense=function(a){return z(a)===p};
exports.isValidElementType=function(a){return"string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};exports.typeOf=z;


}),
44363: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


if (true) {
  module.exports = __webpack_require__(22799);
} else {}


}),
53259: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var React = __webpack_require__(96540);

var ALL_INITIALIZERS = [];
var READY_INITIALIZERS = [];

function isWebpackReady(getModuleIds) {
  if (false) {}

  return getModuleIds().every(function (moduleId) {
    return typeof moduleId !== "undefined" && typeof __webpack_require__.m[moduleId] !== "undefined";
  });
}

var LoadableCaptureContext = React.createContext(null);

function load(loader) {
  var promise = loader();
  var state = {
    loading: true,
    loaded: null,
    error: null
  };
  state.promise = promise.then(function (loaded) {
    state.loading = false;
    state.loaded = loaded;
    return loaded;
  }).catch(function (err) {
    state.loading = false;
    state.error = err;
    throw err;
  });
  return state;
}

function loadMap(obj) {
  var state = {
    loading: false,
    loaded: {},
    error: null
  };
  var promises = [];

  try {
    Object.keys(obj).forEach(function (key) {
      var result = load(obj[key]);

      if (!result.loading) {
        state.loaded[key] = result.loaded;
        state.error = result.error;
      } else {
        state.loading = true;
      }

      promises.push(result.promise);
      result.promise.then(function (res) {
        state.loaded[key] = res;
      }).catch(function (err) {
        state.error = err;
      });
    });
  } catch (err) {
    state.error = err;
  }

  state.promise = Promise.all(promises).then(function (res) {
    state.loading = false;
    return res;
  }).catch(function (err) {
    state.loading = false;
    throw err;
  });
  return state;
}

function resolve(obj) {
  return obj && obj.__esModule ? obj.default : obj;
}

function render(loaded, props) {
  return React.createElement(resolve(loaded), props);
}

function createLoadableComponent(loadFn, options) {
  var _class, _temp;

  if (!options.loading) {
    throw new Error("react-loadable requires a `loading` component");
  }

  var opts = _extends({
    loader: null,
    loading: null,
    delay: 200,
    timeout: null,
    render: render,
    webpack: null,
    modules: null
  }, options);

  var res = null;

  function init() {
    if (!res) {
      res = loadFn(opts.loader);
    }

    return res.promise;
  }

  ALL_INITIALIZERS.push(init);

  if (typeof opts.webpack === "function") {
    READY_INITIALIZERS.push(function () {
      if (isWebpackReady(opts.webpack)) {
        return init();
      }
    });
  }

  return _temp = _class =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(LoadableComponent, _React$Component);

    function LoadableComponent(props) {
      var _this;

      _this = _React$Component.call(this, props) || this;

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "retry", function () {
        _this.setState({
          error: null,
          loading: true,
          timedOut: false
        });

        res = loadFn(opts.loader);

        _this._loadModule();
      });

      init();
      _this.state = {
        error: res.error,
        pastDelay: false,
        timedOut: false,
        loading: res.loading,
        loaded: res.loaded
      };
      return _this;
    }

    LoadableComponent.preload = function preload() {
      return init();
    };

    var _proto = LoadableComponent.prototype;

    _proto.UNSAFE_componentWillMount = function UNSAFE_componentWillMount() {
      this._loadModule();
    };

    _proto.componentDidMount = function componentDidMount() {
      this._mounted = true;
    };

    _proto._loadModule = function _loadModule() {
      var _this2 = this;

      if (this.context && Array.isArray(opts.modules)) {
        opts.modules.forEach(function (moduleName) {
          _this2.context.report(moduleName);
        });
      }

      if (!res.loading) {
        return;
      }

      var setStateWithMountCheck = function setStateWithMountCheck(newState) {
        if (!_this2._mounted) {
          return;
        }

        _this2.setState(newState);
      };

      if (typeof opts.delay === 'number') {
        if (opts.delay === 0) {
          this.setState({
            pastDelay: true
          });
        } else {
          this._delay = setTimeout(function () {
            setStateWithMountCheck({
              pastDelay: true
            });
          }, opts.delay);
        }
      }

      if (typeof opts.timeout === "number") {
        this._timeout = setTimeout(function () {
          setStateWithMountCheck({
            timedOut: true
          });
        }, opts.timeout);
      }

      var update = function update() {
        setStateWithMountCheck({
          error: res.error,
          loaded: res.loaded,
          loading: res.loading
        });

        _this2._clearTimeouts();
      };

      res.promise.then(function () {
        update();
        return null;
      }).catch(function (err) {
        update();
        return null;
      });
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this._mounted = false;

      this._clearTimeouts();
    };

    _proto._clearTimeouts = function _clearTimeouts() {
      clearTimeout(this._delay);
      clearTimeout(this._timeout);
    };

    _proto.render = function render() {
      if (this.state.loading || this.state.error) {
        return React.createElement(opts.loading, {
          isLoading: this.state.loading,
          pastDelay: this.state.pastDelay,
          timedOut: this.state.timedOut,
          error: this.state.error,
          retry: this.retry
        });
      } else if (this.state.loaded) {
        return opts.render(this.state.loaded, this.props);
      } else {
        return null;
      }
    };

    return LoadableComponent;
  }(React.Component), _defineProperty(_class, "contextType", LoadableCaptureContext), _temp;
}

function Loadable(opts) {
  return createLoadableComponent(load, opts);
}

function LoadableMap(opts) {
  if (typeof opts.render !== "function") {
    throw new Error("LoadableMap requires a `render(loaded, props)` function");
  }

  return createLoadableComponent(loadMap, opts);
}

Loadable.Map = LoadableMap;

var Capture =
/*#__PURE__*/
function (_React$Component2) {
  _inheritsLoose(Capture, _React$Component2);

  function Capture() {
    return _React$Component2.apply(this, arguments) || this;
  }

  var _proto2 = Capture.prototype;

  _proto2.render = function render() {
    return React.createElement(LoadableCaptureContext.Provider, {
      value: {
        report: this.props.report
      }
    }, React.Children.only(this.props.children));
  };

  return Capture;
}(React.Component);

Loadable.Capture = Capture;

function flushInitializers(initializers) {
  var promises = [];

  while (initializers.length) {
    var init = initializers.pop();
    promises.push(init());
  }

  return Promise.all(promises).then(function () {
    if (initializers.length) {
      return flushInitializers(initializers);
    }
  });
}

Loadable.preloadAll = function () {
  return new Promise(function (resolve, reject) {
    flushInitializers(ALL_INITIALIZERS).then(resolve, reject);
  });
};

Loadable.preloadReady = function () {
  return new Promise(function (resolve, reject) {
    // We always will resolve, errors should be handled within loading UIs.
    flushInitializers(READY_INITIALIZERS).then(resolve, resolve);
  });
};

module.exports = Loadable;

}),
22831: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  u: () => (matchRoutes),
  v: () => (renderRoutes)
});
/* import */ var react_router__rspack_import_1 = __webpack_require__(56347);
/* import */ var _babel_runtime_helpers_esm_extends__rspack_import_2 = __webpack_require__(58168);
/* import */ var react__rspack_import_0 = __webpack_require__(96540);




function matchRoutes(routes, pathname,
/*not public API*/
branch) {
  if (branch === void 0) {
    branch = [];
  }

  routes.some(function (route) {
    var match = route.path ? (0,react_router__rspack_import_1/* .matchPath */.B6)(pathname, route) : branch.length ? branch[branch.length - 1].match // use parent match
    : react_router__rspack_import_1/* .Router.computeRootMatch */.Ix.computeRootMatch(pathname); // use default "root" match

    if (match) {
      branch.push({
        route: route,
        match: match
      });

      if (route.routes) {
        matchRoutes(route.routes, pathname, branch);
      }
    }

    return match;
  });
  return branch;
}

function renderRoutes(routes, extraProps, switchProps) {
  if (extraProps === void 0) {
    extraProps = {};
  }

  if (switchProps === void 0) {
    switchProps = {};
  }

  return routes ? react__rspack_import_0.createElement(react_router__rspack_import_1/* .Switch */.dO, switchProps, routes.map(function (route, i) {
    return react__rspack_import_0.createElement(react_router__rspack_import_1/* .Route */.qh, {
      key: route.key || i,
      path: route.path,
      exact: route.exact,
      strict: route.strict,
      render: function render(props) {
        return route.render ? route.render((0,_babel_runtime_helpers_esm_extends__rspack_import_2/* ["default"] */.A)({}, props, {}, extraProps, {
          route: route
        })) : react__rspack_import_0.createElement(route.component, (0,_babel_runtime_helpers_esm_extends__rspack_import_2/* ["default"] */.A)({}, props, extraProps, {
          route: route
        }));
      }
    });
  })) : null;
}


//# sourceMappingURL=react-router-config.js.map


}),
54625: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  I9: () => (HashRouter),
  Kd: () => (BrowserRouter),
  N_: () => (Link),
  k2: () => (NavLink)
});
/* import */ var react_router__rspack_import_4 = __webpack_require__(56347);
/* import */ var _babel_runtime_helpers_esm_inheritsLoose__rspack_import_2 = __webpack_require__(77387);
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var history__rspack_import_3 = __webpack_require__(33328);
/* import */ var _babel_runtime_helpers_esm_extends__rspack_import_6 = __webpack_require__(58168);
/* import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__rspack_import_5 = __webpack_require__(98587);
/* import */ var tiny_invariant__rspack_import_1 = __webpack_require__(11561);











/**
 * The public API for a <Router> that uses HTML5 history.
 */

var BrowserRouter = /*#__PURE__*/function (_React$Component) {
  (0,_babel_runtime_helpers_esm_inheritsLoose__rspack_import_2/* ["default"] */.A)(BrowserRouter, _React$Component);

  function BrowserRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = (0,history__rspack_import_3/* .createBrowserHistory */.zR)(_this.props);
    return _this;
  }

  var _proto = BrowserRouter.prototype;

  _proto.render = function render() {
    return /*#__PURE__*/react__rspack_import_0.createElement(react_router__rspack_import_4/* .Router */.Ix, {
      history: this.history,
      children: this.props.children
    });
  };

  return BrowserRouter;
}(react__rspack_import_0.Component);

if (false) {}

/**
 * The public API for a <Router> that uses window.location.hash.
 */

var HashRouter = /*#__PURE__*/function (_React$Component) {
  (0,_babel_runtime_helpers_esm_inheritsLoose__rspack_import_2/* ["default"] */.A)(HashRouter, _React$Component);

  function HashRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = (0,history__rspack_import_3/* .createHashHistory */.TM)(_this.props);
    return _this;
  }

  var _proto = HashRouter.prototype;

  _proto.render = function render() {
    return /*#__PURE__*/react__rspack_import_0.createElement(react_router__rspack_import_4/* .Router */.Ix, {
      history: this.history,
      children: this.props.children
    });
  };

  return HashRouter;
}(react__rspack_import_0.Component);

if (false) {}

var resolveToLocation = function resolveToLocation(to, currentLocation) {
  return typeof to === "function" ? to(currentLocation) : to;
};
var normalizeToLocation = function normalizeToLocation(to, currentLocation) {
  return typeof to === "string" ? (0,history__rspack_import_3/* .createLocation */.yJ)(to, null, null, currentLocation) : to;
};

var forwardRefShim = function forwardRefShim(C) {
  return C;
};

var forwardRef = react__rspack_import_0.forwardRef;

if (typeof forwardRef === "undefined") {
  forwardRef = forwardRefShim;
}

function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}

var LinkAnchor = forwardRef(function (_ref, forwardedRef) {
  var innerRef = _ref.innerRef,
      navigate = _ref.navigate,
      _onClick = _ref.onClick,
      rest = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__rspack_import_5/* ["default"] */.A)(_ref, ["innerRef", "navigate", "onClick"]);

  var target = rest.target;

  var props = (0,_babel_runtime_helpers_esm_extends__rspack_import_6/* ["default"] */.A)({}, rest, {
    onClick: function onClick(event) {
      try {
        if (_onClick) _onClick(event);
      } catch (ex) {
        event.preventDefault();
        throw ex;
      }

      if (!event.defaultPrevented && // onClick prevented default
      event.button === 0 && ( // ignore everything but left clicks
      !target || target === "_self") && // let browser handle "target=_blank" etc.
      !isModifiedEvent(event) // ignore clicks with modifier keys
      ) {
          event.preventDefault();
          navigate();
        }
    }
  }); // React 15 compat


  if (forwardRefShim !== forwardRef) {
    props.ref = forwardedRef || innerRef;
  } else {
    props.ref = innerRef;
  }
  /* eslint-disable-next-line jsx-a11y/anchor-has-content */


  return /*#__PURE__*/react__rspack_import_0.createElement("a", props);
});

if (false) {}
/**
 * The public API for rendering a history-aware <a>.
 */


var Link = forwardRef(function (_ref2, forwardedRef) {
  var _ref2$component = _ref2.component,
      component = _ref2$component === void 0 ? LinkAnchor : _ref2$component,
      replace = _ref2.replace,
      to = _ref2.to,
      innerRef = _ref2.innerRef,
      rest = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__rspack_import_5/* ["default"] */.A)(_ref2, ["component", "replace", "to", "innerRef"]);

  return /*#__PURE__*/react__rspack_import_0.createElement(react_router__rspack_import_4/* .__RouterContext.Consumer */.XZ.Consumer, null, function (context) {
    !context ?  false ? 0 : (0,tiny_invariant__rspack_import_1/* ["default"] */.A)(false) : void 0;
    var history = context.history;
    var location = normalizeToLocation(resolveToLocation(to, context.location), context.location);
    var href = location ? history.createHref(location) : "";

    var props = (0,_babel_runtime_helpers_esm_extends__rspack_import_6/* ["default"] */.A)({}, rest, {
      href: href,
      navigate: function navigate() {
        var location = resolveToLocation(to, context.location);
        var isDuplicateNavigation = (0,history__rspack_import_3/* .createPath */.AO)(context.location) === (0,history__rspack_import_3/* .createPath */.AO)(normalizeToLocation(location));
        var method = replace || isDuplicateNavigation ? history.replace : history.push;
        method(location);
      }
    }); // React 15 compat


    if (forwardRefShim !== forwardRef) {
      props.ref = forwardedRef || innerRef;
    } else {
      props.innerRef = innerRef;
    }

    return /*#__PURE__*/react__rspack_import_0.createElement(component, props);
  });
});

if (false) { var refType, toType }

var forwardRefShim$1 = function forwardRefShim(C) {
  return C;
};

var forwardRef$1 = react__rspack_import_0.forwardRef;

if (typeof forwardRef$1 === "undefined") {
  forwardRef$1 = forwardRefShim$1;
}

function joinClassnames() {
  for (var _len = arguments.length, classnames = new Array(_len), _key = 0; _key < _len; _key++) {
    classnames[_key] = arguments[_key];
  }

  return classnames.filter(function (i) {
    return i;
  }).join(" ");
}
/**
 * A <Link> wrapper that knows if it's "active" or not.
 */


var NavLink = forwardRef$1(function (_ref, forwardedRef) {
  var _ref$ariaCurrent = _ref["aria-current"],
      ariaCurrent = _ref$ariaCurrent === void 0 ? "page" : _ref$ariaCurrent,
      _ref$activeClassName = _ref.activeClassName,
      activeClassName = _ref$activeClassName === void 0 ? "active" : _ref$activeClassName,
      activeStyle = _ref.activeStyle,
      classNameProp = _ref.className,
      exact = _ref.exact,
      isActiveProp = _ref.isActive,
      locationProp = _ref.location,
      sensitive = _ref.sensitive,
      strict = _ref.strict,
      styleProp = _ref.style,
      to = _ref.to,
      innerRef = _ref.innerRef,
      rest = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__rspack_import_5/* ["default"] */.A)(_ref, ["aria-current", "activeClassName", "activeStyle", "className", "exact", "isActive", "location", "sensitive", "strict", "style", "to", "innerRef"]);

  return /*#__PURE__*/react__rspack_import_0.createElement(react_router__rspack_import_4/* .__RouterContext.Consumer */.XZ.Consumer, null, function (context) {
    !context ?  false ? 0 : (0,tiny_invariant__rspack_import_1/* ["default"] */.A)(false) : void 0;
    var currentLocation = locationProp || context.location;
    var toLocation = normalizeToLocation(resolveToLocation(to, currentLocation), currentLocation);
    var path = toLocation.pathname; // Regex taken from: https://github.com/pillarjs/path-to-regexp/blob/master/index.js#L202

    var escapedPath = path && path.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
    var match = escapedPath ? (0,react_router__rspack_import_4/* .matchPath */.B6)(currentLocation.pathname, {
      path: escapedPath,
      exact: exact,
      sensitive: sensitive,
      strict: strict
    }) : null;
    var isActive = !!(isActiveProp ? isActiveProp(match, currentLocation) : match);
    var className = typeof classNameProp === "function" ? classNameProp(isActive) : classNameProp;
    var style = typeof styleProp === "function" ? styleProp(isActive) : styleProp;

    if (isActive) {
      className = joinClassnames(className, activeClassName);
      style = (0,_babel_runtime_helpers_esm_extends__rspack_import_6/* ["default"] */.A)({}, style, activeStyle);
    }

    var props = (0,_babel_runtime_helpers_esm_extends__rspack_import_6/* ["default"] */.A)({
      "aria-current": isActive && ariaCurrent || null,
      className: className,
      style: style,
      to: toLocation
    }, rest); // React 15 compat


    if (forwardRefShim$1 !== forwardRef$1) {
      props.ref = forwardedRef || innerRef;
    } else {
      props.innerRef = innerRef;
    }

    return /*#__PURE__*/react__rspack_import_0.createElement(Link, props);
  });
});

if (false) { var ariaCurrentType }


//# sourceMappingURL=react-router-dom.js.map


}),
56347: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  B6: () => (matchPath),
  Ix: () => (Router),
  W6: () => (useHistory),
  XZ: () => (context),
  dO: () => (Switch),
  qh: () => (Route),
  zy: () => (useLocation)
});
/* import */ var _babel_runtime_helpers_esm_inheritsLoose__rspack_import_5 = __webpack_require__(77387);
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var prop_types__rspack_import_6 = __webpack_require__(5556);
/* import */ var prop_types__rspack_import_6_default = /*#__PURE__*/__webpack_require__.n(prop_types__rspack_import_6);
/* import */ var history__rspack_import_7 = __webpack_require__(33328);
/* import */ var tiny_invariant__rspack_import_1 = __webpack_require__(11561);
/* import */ var _babel_runtime_helpers_esm_extends__rspack_import_8 = __webpack_require__(58168);
/* import */ var path_to_regexp__rspack_import_2 = __webpack_require__(8505);
/* import */ var path_to_regexp__rspack_import_2_default = /*#__PURE__*/__webpack_require__.n(path_to_regexp__rspack_import_2);
/* import */ var react_is__rspack_import_3 = __webpack_require__(44363);
/* import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__rspack_import_9 = __webpack_require__(98587);
/* import */ var hoist_non_react_statics__rspack_import_4 = __webpack_require__(4146);
/* import */ var hoist_non_react_statics__rspack_import_4_default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics__rspack_import_4);












var MAX_SIGNED_31_BIT_INT = 1073741823;
var commonjsGlobal = typeof globalThis !== "undefined" // 'global proper'
? // eslint-disable-next-line no-undef
globalThis : typeof window !== "undefined" ? window // Browser
: typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g // node.js
: {};

function getUniqueId() {
  var key = "__global_unique_id__";
  return commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1;
} // Inlined Object.is polyfill.
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is


function objectIs(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    // eslint-disable-next-line no-self-compare
    return x !== x && y !== y;
  }
}

function createEventEmitter(value) {
  var handlers = [];
  return {
    on: function on(handler) {
      handlers.push(handler);
    },
    off: function off(handler) {
      handlers = handlers.filter(function (h) {
        return h !== handler;
      });
    },
    get: function get() {
      return value;
    },
    set: function set(newValue, changedBits) {
      value = newValue;
      handlers.forEach(function (handler) {
        return handler(value, changedBits);
      });
    }
  };
}

function onlyChild(children) {
  return Array.isArray(children) ? children[0] : children;
}

function createReactContext(defaultValue, calculateChangedBits) {
  var _Provider$childContex, _Consumer$contextType;

  var contextProp = "__create-react-context-" + getUniqueId() + "__";

  var Provider = /*#__PURE__*/function (_React$Component) {
    (0,_babel_runtime_helpers_esm_inheritsLoose__rspack_import_5/* ["default"] */.A)(Provider, _React$Component);

    function Provider() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.emitter = createEventEmitter(_this.props.value);
      return _this;
    }

    var _proto = Provider.prototype;

    _proto.getChildContext = function getChildContext() {
      var _ref;

      return _ref = {}, _ref[contextProp] = this.emitter, _ref;
    };

    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if (this.props.value !== nextProps.value) {
        var oldValue = this.props.value;
        var newValue = nextProps.value;
        var changedBits;

        if (objectIs(oldValue, newValue)) {
          changedBits = 0; // No change
        } else {
          changedBits = typeof calculateChangedBits === "function" ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;

          if (false) {}

          changedBits |= 0;

          if (changedBits !== 0) {
            this.emitter.set(nextProps.value, changedBits);
          }
        }
      }
    };

    _proto.render = function render() {
      return this.props.children;
    };

    return Provider;
  }(react__rspack_import_0.Component);

  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = (prop_types__rspack_import_6_default().object.isRequired), _Provider$childContex);

  var Consumer = /*#__PURE__*/function (_React$Component2) {
    (0,_babel_runtime_helpers_esm_inheritsLoose__rspack_import_5/* ["default"] */.A)(Consumer, _React$Component2);

    function Consumer() {
      var _this2;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      _this2 = _React$Component2.call.apply(_React$Component2, [this].concat(args)) || this;
      _this2.observedBits = void 0;
      _this2.state = {
        value: _this2.getValue()
      };

      _this2.onUpdate = function (newValue, changedBits) {
        var observedBits = _this2.observedBits | 0;

        if ((observedBits & changedBits) !== 0) {
          _this2.setState({
            value: _this2.getValue()
          });
        }
      };

      return _this2;
    }

    var _proto2 = Consumer.prototype;

    _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var observedBits = nextProps.observedBits;
      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT // Subscribe to all changes by default
      : observedBits;
    };

    _proto2.componentDidMount = function componentDidMount() {
      if (this.context[contextProp]) {
        this.context[contextProp].on(this.onUpdate);
      }

      var observedBits = this.props.observedBits;
      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT // Subscribe to all changes by default
      : observedBits;
    };

    _proto2.componentWillUnmount = function componentWillUnmount() {
      if (this.context[contextProp]) {
        this.context[contextProp].off(this.onUpdate);
      }
    };

    _proto2.getValue = function getValue() {
      if (this.context[contextProp]) {
        return this.context[contextProp].get();
      } else {
        return defaultValue;
      }
    };

    _proto2.render = function render() {
      return onlyChild(this.props.children)(this.state.value);
    };

    return Consumer;
  }(react__rspack_import_0.Component);

  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = (prop_types__rspack_import_6_default().object), _Consumer$contextType);
  return {
    Provider: Provider,
    Consumer: Consumer
  };
}

// MIT License
var createContext = react__rspack_import_0.createContext || createReactContext;

// TODO: Replace with React.createContext once we can assume React 16+

var createNamedContext = function createNamedContext(name) {
  var context = createContext();
  context.displayName = name;
  return context;
};

var historyContext = /*#__PURE__*/createNamedContext("Router-History");

var context = /*#__PURE__*/createNamedContext("Router");

/**
 * The public API for putting history on context.
 */

var Router = /*#__PURE__*/function (_React$Component) {
  (0,_babel_runtime_helpers_esm_inheritsLoose__rspack_import_5/* ["default"] */.A)(Router, _React$Component);

  Router.computeRootMatch = function computeRootMatch(pathname) {
    return {
      path: "/",
      url: "/",
      params: {},
      isExact: pathname === "/"
    };
  };

  function Router(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.state = {
      location: props.history.location
    }; // This is a bit of a hack. We have to start listening for location
    // changes here in the constructor in case there are any <Redirect>s
    // on the initial render. If there are, they will replace/push when
    // they mount and since cDM fires in children before parents, we may
    // get a new location before the <Router> is mounted.

    _this._isMounted = false;
    _this._pendingLocation = null;

    if (!props.staticContext) {
      _this.unlisten = props.history.listen(function (location) {
        _this._pendingLocation = location;
      });
    }

    return _this;
  }

  var _proto = Router.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;

    this._isMounted = true;

    if (this.unlisten) {
      // Any pre-mount location changes have been captured at
      // this point, so unregister the listener.
      this.unlisten();
    }

    if (!this.props.staticContext) {
      this.unlisten = this.props.history.listen(function (location) {
        if (_this2._isMounted) {
          _this2.setState({
            location: location
          });
        }
      });
    }

    if (this._pendingLocation) {
      this.setState({
        location: this._pendingLocation
      });
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.unlisten) {
      this.unlisten();
      this._isMounted = false;
      this._pendingLocation = null;
    }
  };

  _proto.render = function render() {
    return /*#__PURE__*/react__rspack_import_0.createElement(context.Provider, {
      value: {
        history: this.props.history,
        location: this.state.location,
        match: Router.computeRootMatch(this.state.location.pathname),
        staticContext: this.props.staticContext
      }
    }, /*#__PURE__*/react__rspack_import_0.createElement(historyContext.Provider, {
      children: this.props.children || null,
      value: this.props.history
    }));
  };

  return Router;
}(react__rspack_import_0.Component);

if (false) {}

/**
 * The public API for a <Router> that stores location in memory.
 */

var MemoryRouter = /*#__PURE__*/function (_React$Component) {
  (0,_babel_runtime_helpers_esm_inheritsLoose__rspack_import_5/* ["default"] */.A)(MemoryRouter, _React$Component);

  function MemoryRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = (0,history__rspack_import_7/* .createMemoryHistory */.sC)(_this.props);
    return _this;
  }

  var _proto = MemoryRouter.prototype;

  _proto.render = function render() {
    return /*#__PURE__*/react__rspack_import_0.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };

  return MemoryRouter;
}(react__rspack_import_0.Component);

if (false) {}

var Lifecycle = /*#__PURE__*/function (_React$Component) {
  (0,_babel_runtime_helpers_esm_inheritsLoose__rspack_import_5/* ["default"] */.A)(Lifecycle, _React$Component);

  function Lifecycle() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = Lifecycle.prototype;

  _proto.componentDidMount = function componentDidMount() {
    if (this.props.onMount) this.props.onMount.call(this, this);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.onUpdate) this.props.onUpdate.call(this, this, prevProps);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.props.onUnmount) this.props.onUnmount.call(this, this);
  };

  _proto.render = function render() {
    return null;
  };

  return Lifecycle;
}(react__rspack_import_0.Component);

/**
 * The public API for prompting the user before navigating away from a screen.
 */

function Prompt(_ref) {
  var message = _ref.message,
      _ref$when = _ref.when,
      when = _ref$when === void 0 ? true : _ref$when;
  return /*#__PURE__*/React.createElement(context.Consumer, null, function (context) {
    !context ?  false ? 0 : invariant(false) : void 0;
    if (!when || context.staticContext) return null;
    var method = context.history.block;
    return /*#__PURE__*/React.createElement(Lifecycle, {
      onMount: function onMount(self) {
        self.release = method(message);
      },
      onUpdate: function onUpdate(self, prevProps) {
        if (prevProps.message !== message) {
          self.release();
          self.release = method(message);
        }
      },
      onUnmount: function onUnmount(self) {
        self.release();
      },
      message: message
    });
  });
}

if (false) { var messageType }

var cache = (/* unused pure expression or super */ null && ({}));
var cacheLimit = 10000;
var cacheCount = 0;

function compilePath(path) {
  if (cache[path]) return cache[path];
  var generator = pathToRegexp.compile(path);

  if (cacheCount < cacheLimit) {
    cache[path] = generator;
    cacheCount++;
  }

  return generator;
}
/**
 * Public API for generating a URL pathname from a path and parameters.
 */


function generatePath(path, params) {
  if (path === void 0) {
    path = "/";
  }

  if (params === void 0) {
    params = {};
  }

  return path === "/" ? path : compilePath(path)(params, {
    pretty: true
  });
}

/**
 * The public API for navigating programmatically with a component.
 */

function Redirect(_ref) {
  var computedMatch = _ref.computedMatch,
      to = _ref.to,
      _ref$push = _ref.push,
      push = _ref$push === void 0 ? false : _ref$push;
  return /*#__PURE__*/React.createElement(context.Consumer, null, function (context) {
    !context ?  false ? 0 : invariant(false) : void 0;
    var history = context.history,
        staticContext = context.staticContext;
    var method = push ? history.push : history.replace;
    var location = createLocation(computedMatch ? typeof to === "string" ? generatePath(to, computedMatch.params) : _extends({}, to, {
      pathname: generatePath(to.pathname, computedMatch.params)
    }) : to); // When rendering in a static context,
    // set the new location immediately.

    if (staticContext) {
      method(location);
      return null;
    }

    return /*#__PURE__*/React.createElement(Lifecycle, {
      onMount: function onMount() {
        method(location);
      },
      onUpdate: function onUpdate(self, prevProps) {
        var prevLocation = createLocation(prevProps.to);

        if (!locationsAreEqual(prevLocation, _extends({}, location, {
          key: prevLocation.key
        }))) {
          method(location);
        }
      },
      to: to
    });
  });
}

if (false) {}

var cache$1 = {};
var cacheLimit$1 = 10000;
var cacheCount$1 = 0;

function compilePath$1(path, options) {
  var cacheKey = "" + options.end + options.strict + options.sensitive;
  var pathCache = cache$1[cacheKey] || (cache$1[cacheKey] = {});
  if (pathCache[path]) return pathCache[path];
  var keys = [];
  var regexp = path_to_regexp__rspack_import_2_default()(path, keys, options);
  var result = {
    regexp: regexp,
    keys: keys
  };

  if (cacheCount$1 < cacheLimit$1) {
    pathCache[path] = result;
    cacheCount$1++;
  }

  return result;
}
/**
 * Public API for matching a URL pathname to a path.
 */


function matchPath(pathname, options) {
  if (options === void 0) {
    options = {};
  }

  if (typeof options === "string" || Array.isArray(options)) {
    options = {
      path: options
    };
  }

  var _options = options,
      path = _options.path,
      _options$exact = _options.exact,
      exact = _options$exact === void 0 ? false : _options$exact,
      _options$strict = _options.strict,
      strict = _options$strict === void 0 ? false : _options$strict,
      _options$sensitive = _options.sensitive,
      sensitive = _options$sensitive === void 0 ? false : _options$sensitive;
  var paths = [].concat(path);
  return paths.reduce(function (matched, path) {
    if (!path && path !== "") return null;
    if (matched) return matched;

    var _compilePath = compilePath$1(path, {
      end: exact,
      strict: strict,
      sensitive: sensitive
    }),
        regexp = _compilePath.regexp,
        keys = _compilePath.keys;

    var match = regexp.exec(pathname);
    if (!match) return null;
    var url = match[0],
        values = match.slice(1);
    var isExact = pathname === url;
    if (exact && !isExact) return null;
    return {
      path: path,
      // the path used to match
      url: path === "/" && url === "" ? "/" : url,
      // the matched portion of the URL
      isExact: isExact,
      // whether or not we matched exactly
      params: keys.reduce(function (memo, key, index) {
        memo[key.name] = values[index];
        return memo;
      }, {})
    };
  }, null);
}

function isEmptyChildren(children) {
  return react__rspack_import_0.Children.count(children) === 0;
}

function evalChildrenDev(children, props, path) {
  var value = children(props);
   false ? 0 : void 0;
  return value || null;
}
/**
 * The public API for matching a single path and rendering.
 */


var Route = /*#__PURE__*/function (_React$Component) {
  (0,_babel_runtime_helpers_esm_inheritsLoose__rspack_import_5/* ["default"] */.A)(Route, _React$Component);

  function Route() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = Route.prototype;

  _proto.render = function render() {
    var _this = this;

    return /*#__PURE__*/react__rspack_import_0.createElement(context.Consumer, null, function (context$1) {
      !context$1 ?  false ? 0 : (0,tiny_invariant__rspack_import_1/* ["default"] */.A)(false) : void 0;
      var location = _this.props.location || context$1.location;
      var match = _this.props.computedMatch ? _this.props.computedMatch // <Switch> already computed the match for us
      : _this.props.path ? matchPath(location.pathname, _this.props) : context$1.match;

      var props = (0,_babel_runtime_helpers_esm_extends__rspack_import_8/* ["default"] */.A)({}, context$1, {
        location: location,
        match: match
      });

      var _this$props = _this.props,
          children = _this$props.children,
          component = _this$props.component,
          render = _this$props.render; // Preact uses an empty array as children by
      // default, so use null if that's the case.

      if (Array.isArray(children) && isEmptyChildren(children)) {
        children = null;
      }

      return /*#__PURE__*/react__rspack_import_0.createElement(context.Provider, {
        value: props
      }, props.match ? children ? typeof children === "function" ?  false ? 0 : children(props) : children : component ? /*#__PURE__*/react__rspack_import_0.createElement(component, props) : render ? render(props) : null : typeof children === "function" ?  false ? 0 : children(props) : null);
    });
  };

  return Route;
}(react__rspack_import_0.Component);

if (false) {}

function addLeadingSlash(path) {
  return path.charAt(0) === "/" ? path : "/" + path;
}

function addBasename(basename, location) {
  if (!basename) return location;
  return (0,_babel_runtime_helpers_esm_extends__rspack_import_8/* ["default"] */.A)({}, location, {
    pathname: addLeadingSlash(basename) + location.pathname
  });
}

function stripBasename(basename, location) {
  if (!basename) return location;
  var base = addLeadingSlash(basename);
  if (location.pathname.indexOf(base) !== 0) return location;
  return (0,_babel_runtime_helpers_esm_extends__rspack_import_8/* ["default"] */.A)({}, location, {
    pathname: location.pathname.substr(base.length)
  });
}

function createURL(location) {
  return typeof location === "string" ? location : (0,history__rspack_import_7/* .createPath */.AO)(location);
}

function staticHandler(methodName) {
  return function () {
      false ? 0 : (0,tiny_invariant__rspack_import_1/* ["default"] */.A)(false) ;
  };
}

function noop() {}
/**
 * The public top-level API for a "static" <Router>, so-called because it
 * can't actually change the current location. Instead, it just records
 * location changes in a context object. Useful mainly in testing and
 * server-rendering scenarios.
 */


var StaticRouter = /*#__PURE__*/function (_React$Component) {
  (0,_babel_runtime_helpers_esm_inheritsLoose__rspack_import_5/* ["default"] */.A)(StaticRouter, _React$Component);

  function StaticRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

    _this.handlePush = function (location) {
      return _this.navigateTo(location, "PUSH");
    };

    _this.handleReplace = function (location) {
      return _this.navigateTo(location, "REPLACE");
    };

    _this.handleListen = function () {
      return noop;
    };

    _this.handleBlock = function () {
      return noop;
    };

    return _this;
  }

  var _proto = StaticRouter.prototype;

  _proto.navigateTo = function navigateTo(location, action) {
    var _this$props = this.props,
        _this$props$basename = _this$props.basename,
        basename = _this$props$basename === void 0 ? "" : _this$props$basename,
        _this$props$context = _this$props.context,
        context = _this$props$context === void 0 ? {} : _this$props$context;
    context.action = action;
    context.location = addBasename(basename, (0,history__rspack_import_7/* .createLocation */.yJ)(location));
    context.url = createURL(context.location);
  };

  _proto.render = function render() {
    var _this$props2 = this.props,
        _this$props2$basename = _this$props2.basename,
        basename = _this$props2$basename === void 0 ? "" : _this$props2$basename,
        _this$props2$context = _this$props2.context,
        context = _this$props2$context === void 0 ? {} : _this$props2$context,
        _this$props2$location = _this$props2.location,
        location = _this$props2$location === void 0 ? "/" : _this$props2$location,
        rest = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__rspack_import_9/* ["default"] */.A)(_this$props2, ["basename", "context", "location"]);

    var history = {
      createHref: function createHref(path) {
        return addLeadingSlash(basename + createURL(path));
      },
      action: "POP",
      location: stripBasename(basename, (0,history__rspack_import_7/* .createLocation */.yJ)(location)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler("go"),
      goBack: staticHandler("goBack"),
      goForward: staticHandler("goForward"),
      listen: this.handleListen,
      block: this.handleBlock
    };
    return /*#__PURE__*/react__rspack_import_0.createElement(Router, (0,_babel_runtime_helpers_esm_extends__rspack_import_8/* ["default"] */.A)({}, rest, {
      history: history,
      staticContext: context
    }));
  };

  return StaticRouter;
}(react__rspack_import_0.Component);

if (false) {}

/**
 * The public API for rendering the first <Route> that matches.
 */

var Switch = /*#__PURE__*/function (_React$Component) {
  (0,_babel_runtime_helpers_esm_inheritsLoose__rspack_import_5/* ["default"] */.A)(Switch, _React$Component);

  function Switch() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = Switch.prototype;

  _proto.render = function render() {
    var _this = this;

    return /*#__PURE__*/react__rspack_import_0.createElement(context.Consumer, null, function (context) {
      !context ?  false ? 0 : (0,tiny_invariant__rspack_import_1/* ["default"] */.A)(false) : void 0;
      var location = _this.props.location || context.location;
      var element, match; // We use React.Children.forEach instead of React.Children.toArray().find()
      // here because toArray adds keys to all child elements and we do not want
      // to trigger an unmount/remount for two <Route>s that render the same
      // component at different URLs.

      react__rspack_import_0.Children.forEach(_this.props.children, function (child) {
        if (match == null && /*#__PURE__*/react__rspack_import_0.isValidElement(child)) {
          element = child;
          var path = child.props.path || child.props.from;
          match = path ? matchPath(location.pathname, (0,_babel_runtime_helpers_esm_extends__rspack_import_8/* ["default"] */.A)({}, child.props, {
            path: path
          })) : context.match;
        }
      });
      return match ? /*#__PURE__*/react__rspack_import_0.cloneElement(element, {
        location: location,
        computedMatch: match
      }) : null;
    });
  };

  return Switch;
}(react__rspack_import_0.Component);

if (false) {}

/**
 * A public higher-order component to access the imperative API
 */

function withRouter(Component) {
  var displayName = "withRouter(" + (Component.displayName || Component.name) + ")";

  var C = function C(props) {
    var wrappedComponentRef = props.wrappedComponentRef,
        remainingProps = _objectWithoutPropertiesLoose(props, ["wrappedComponentRef"]);

    return /*#__PURE__*/React.createElement(context.Consumer, null, function (context) {
      !context ?  false ? 0 : invariant(false) : void 0;
      return /*#__PURE__*/React.createElement(Component, _extends({}, remainingProps, context, {
        ref: wrappedComponentRef
      }));
    });
  };

  C.displayName = displayName;
  C.WrappedComponent = Component;

  if (false) {}

  return hoistStatics(C, Component);
}

var useContext = react__rspack_import_0.useContext;
function useHistory() {
  if (false) {}

  return useContext(historyContext);
}
function useLocation() {
  if (false) {}

  return useContext(context).location;
}
function useParams() {
  if (false) {}

  var match = useContext(context).match;
  return match ? match.params : {};
}
function useRouteMatch(path) {
  if (false) {}

  var location = useLocation();
  var match = useContext(context).match;
  return path ? matchPath(location.pathname, path) : match;
}

if (false) { var global$1, buildNames, secondaryBuildName, initialBuildName, key }


//# sourceMappingURL=react-router.js.map


}),
8505: (function (module, __unused_webpack_exports, __webpack_require__) {
var isarray = __webpack_require__(64634)

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp
module.exports.parse = parse
module.exports.compile = compile
module.exports.tokensToFunction = tokensToFunction
module.exports.tokensToRegExp = tokensToRegExp

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g')

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = []
  var key = 0
  var index = 0
  var path = ''
  var defaultDelimiter = options && options.delimiter || '/'
  var res

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0]
    var escaped = res[1]
    var offset = res.index
    path += str.slice(index, offset)
    index = offset + m.length

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1]
      continue
    }

    var next = str[index]
    var prefix = res[2]
    var name = res[3]
    var capture = res[4]
    var group = res[5]
    var modifier = res[6]
    var asterisk = res[7]

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path)
      path = ''
    }

    var partial = prefix != null && next != null && next !== prefix
    var repeat = modifier === '+' || modifier === '*'
    var optional = modifier === '?' || modifier === '*'
    var delimiter = prefix || defaultDelimiter
    var pattern = capture || group
    var prevText = prefix || (typeof tokens[tokens.length - 1] === 'string' ? tokens[tokens.length - 1] : '')

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : restrictBacktrack(delimiter, prevText))
    })
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index)
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path)
  }

  return tokens
}

function restrictBacktrack(delimiter, prevText) {
  if (!prevText || prevText.indexOf(delimiter) > -1) {
    return '[^' + escapeString(delimiter) + ']+?'
  }

  return escapeString(prevText) + '|(?:(?!' + escapeString(prevText) + ')[^' + escapeString(delimiter) + '])+?'
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options), options)
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty (str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk (str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens, options) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length)

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options))
    }
  }

  return function (obj, opts) {
    var path = ''
    var data = obj || {}
    var options = opts || {}
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i]

      if (typeof token === 'string') {
        path += token

        continue
      }

      var value = data[token.name]
      var segment

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix
          }

          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j])

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment
        }

        continue
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value)

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options && options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g)

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      })
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = []

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source)
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  var strict = options.strict
  var end = options.end !== false
  var route = ''

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i]

    if (typeof token === 'string') {
      route += escapeString(token)
    } else {
      var prefix = escapeString(token.prefix)
      var capture = '(?:' + token.pattern + ')'

      keys.push(token)

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*'
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?'
        } else {
          capture = prefix + '(' + capture + ')?'
        }
      } else {
        capture = prefix + '(' + capture + ')'
      }

      route += capture
    }
  }

  var delimiter = escapeString(options.delimiter || '/')
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'
  }

  if (end) {
    route += '$'
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys)
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */ (keys))
  }

  if (isarray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
  }

  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
}


}),
29698: (function (__unused_webpack_module, exports) {
"use strict";
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
function jsxProd(type, config, maybeKey) {
  var key = null;
  void 0 !== maybeKey && (key = "" + maybeKey);
  void 0 !== config.key && (key = "" + config.key);
  if ("key" in config) {
    maybeKey = {};
    for (var propName in config)
      "key" !== propName && (maybeKey[propName] = config[propName]);
  } else maybeKey = config;
  config = maybeKey.ref;
  return {
    $$typeof: REACT_ELEMENT_TYPE,
    type: type,
    key: key,
    ref: void 0 !== config ? config : null,
    props: maybeKey
  };
}
exports.Fragment = REACT_FRAGMENT_TYPE;
exports.jsx = jsxProd;
exports.jsxs = jsxProd;


}),
29869: (function (__unused_webpack_module, exports) {
"use strict";
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
  REACT_PORTAL_TYPE = Symbol.for("react.portal"),
  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
  REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
  REACT_MEMO_TYPE = Symbol.for("react.memo"),
  REACT_LAZY_TYPE = Symbol.for("react.lazy"),
  REACT_ACTIVITY_TYPE = Symbol.for("react.activity"),
  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
function getIteratorFn(maybeIterable) {
  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
  maybeIterable =
    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
    maybeIterable["@@iterator"];
  return "function" === typeof maybeIterable ? maybeIterable : null;
}
var ReactNoopUpdateQueue = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {}
  },
  assign = Object.assign,
  emptyObject = {};
function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}
Component.prototype.isReactComponent = {};
Component.prototype.setState = function (partialState, callback) {
  if (
    "object" !== typeof partialState &&
    "function" !== typeof partialState &&
    null != partialState
  )
    throw Error(
      "takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, partialState, callback, "setState");
};
Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
};
function ComponentDummy() {}
ComponentDummy.prototype = Component.prototype;
function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}
var pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());
pureComponentPrototype.constructor = PureComponent;
assign(pureComponentPrototype, Component.prototype);
pureComponentPrototype.isPureReactComponent = !0;
var isArrayImpl = Array.isArray;
function noop() {}
var ReactSharedInternals = { H: null, A: null, T: null, S: null },
  hasOwnProperty = Object.prototype.hasOwnProperty;
function ReactElement(type, key, props) {
  var refProp = props.ref;
  return {
    $$typeof: REACT_ELEMENT_TYPE,
    type: type,
    key: key,
    ref: void 0 !== refProp ? refProp : null,
    props: props
  };
}
function cloneAndReplaceKey(oldElement, newKey) {
  return ReactElement(oldElement.type, newKey, oldElement.props);
}
function isValidElement(object) {
  return (
    "object" === typeof object &&
    null !== object &&
    object.$$typeof === REACT_ELEMENT_TYPE
  );
}
function escape(key) {
  var escaperLookup = { "=": "=0", ":": "=2" };
  return (
    "$" +
    key.replace(/[=:]/g, function (match) {
      return escaperLookup[match];
    })
  );
}
var userProvidedKeyEscapeRegex = /\/+/g;
function getElementKey(element, index) {
  return "object" === typeof element && null !== element && null != element.key
    ? escape("" + element.key)
    : index.toString(36);
}
function resolveThenable(thenable) {
  switch (thenable.status) {
    case "fulfilled":
      return thenable.value;
    case "rejected":
      throw thenable.reason;
    default:
      switch (
        ("string" === typeof thenable.status
          ? thenable.then(noop, noop)
          : ((thenable.status = "pending"),
            thenable.then(
              function (fulfilledValue) {
                "pending" === thenable.status &&
                  ((thenable.status = "fulfilled"),
                  (thenable.value = fulfilledValue));
              },
              function (error) {
                "pending" === thenable.status &&
                  ((thenable.status = "rejected"), (thenable.reason = error));
              }
            )),
        thenable.status)
      ) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
      }
  }
  throw thenable;
}
function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
  var type = typeof children;
  if ("undefined" === type || "boolean" === type) children = null;
  var invokeCallback = !1;
  if (null === children) invokeCallback = !0;
  else
    switch (type) {
      case "bigint":
      case "string":
      case "number":
        invokeCallback = !0;
        break;
      case "object":
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = !0;
            break;
          case REACT_LAZY_TYPE:
            return (
              (invokeCallback = children._init),
              mapIntoArray(
                invokeCallback(children._payload),
                array,
                escapedPrefix,
                nameSoFar,
                callback
              )
            );
        }
    }
  if (invokeCallback)
    return (
      (callback = callback(children)),
      (invokeCallback =
        "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar),
      isArrayImpl(callback)
        ? ((escapedPrefix = ""),
          null != invokeCallback &&
            (escapedPrefix =
              invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"),
          mapIntoArray(callback, array, escapedPrefix, "", function (c) {
            return c;
          }))
        : null != callback &&
          (isValidElement(callback) &&
            (callback = cloneAndReplaceKey(
              callback,
              escapedPrefix +
                (null == callback.key ||
                (children && children.key === callback.key)
                  ? ""
                  : ("" + callback.key).replace(
                      userProvidedKeyEscapeRegex,
                      "$&/"
                    ) + "/") +
                invokeCallback
            )),
          array.push(callback)),
      1
    );
  invokeCallback = 0;
  var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
  if (isArrayImpl(children))
    for (var i = 0; i < children.length; i++)
      (nameSoFar = children[i]),
        (type = nextNamePrefix + getElementKey(nameSoFar, i)),
        (invokeCallback += mapIntoArray(
          nameSoFar,
          array,
          escapedPrefix,
          type,
          callback
        ));
  else if (((i = getIteratorFn(children)), "function" === typeof i))
    for (
      children = i.call(children), i = 0;
      !(nameSoFar = children.next()).done;

    )
      (nameSoFar = nameSoFar.value),
        (type = nextNamePrefix + getElementKey(nameSoFar, i++)),
        (invokeCallback += mapIntoArray(
          nameSoFar,
          array,
          escapedPrefix,
          type,
          callback
        ));
  else if ("object" === type) {
    if ("function" === typeof children.then)
      return mapIntoArray(
        resolveThenable(children),
        array,
        escapedPrefix,
        nameSoFar,
        callback
      );
    array = String(children);
    throw Error(
      "Objects are not valid as a React child (found: " +
        ("[object Object]" === array
          ? "object with keys {" + Object.keys(children).join(", ") + "}"
          : array) +
        "). If you meant to render a collection of children, use an array instead."
    );
  }
  return invokeCallback;
}
function mapChildren(children, func, context) {
  if (null == children) return children;
  var result = [],
    count = 0;
  mapIntoArray(children, result, "", "", function (child) {
    return func.call(context, child, count++);
  });
  return result;
}
function lazyInitializer(payload) {
  if (-1 === payload._status) {
    var ctor = payload._result;
    ctor = ctor();
    ctor.then(
      function (moduleObject) {
        if (0 === payload._status || -1 === payload._status)
          (payload._status = 1), (payload._result = moduleObject);
      },
      function (error) {
        if (0 === payload._status || -1 === payload._status)
          (payload._status = 2), (payload._result = error);
      }
    );
    -1 === payload._status && ((payload._status = 0), (payload._result = ctor));
  }
  if (1 === payload._status) return payload._result.default;
  throw payload._result;
}
var reportGlobalError =
    "function" === typeof reportError
      ? reportError
      : function (error) {
          if (
            "object" === typeof window &&
            "function" === typeof window.ErrorEvent
          ) {
            var event = new window.ErrorEvent("error", {
              bubbles: !0,
              cancelable: !0,
              message:
                "object" === typeof error &&
                null !== error &&
                "string" === typeof error.message
                  ? String(error.message)
                  : String(error),
              error: error
            });
            if (!window.dispatchEvent(event)) return;
          } else if (
            "object" === typeof process &&
            "function" === typeof process.emit
          ) {
            process.emit("uncaughtException", error);
            return;
          }
          console.error(error);
        },
  Children = {
    map: mapChildren,
    forEach: function (children, forEachFunc, forEachContext) {
      mapChildren(
        children,
        function () {
          forEachFunc.apply(this, arguments);
        },
        forEachContext
      );
    },
    count: function (children) {
      var n = 0;
      mapChildren(children, function () {
        n++;
      });
      return n;
    },
    toArray: function (children) {
      return (
        mapChildren(children, function (child) {
          return child;
        }) || []
      );
    },
    only: function (children) {
      if (!isValidElement(children))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return children;
    }
  };
exports.Activity = REACT_ACTIVITY_TYPE;
exports.Children = Children;
exports.Component = Component;
exports.Fragment = REACT_FRAGMENT_TYPE;
exports.Profiler = REACT_PROFILER_TYPE;
exports.PureComponent = PureComponent;
exports.StrictMode = REACT_STRICT_MODE_TYPE;
exports.Suspense = REACT_SUSPENSE_TYPE;
exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
  ReactSharedInternals;
exports.__COMPILER_RUNTIME = {
  __proto__: null,
  c: function (size) {
    return ReactSharedInternals.H.useMemoCache(size);
  }
};
exports.cache = function (fn) {
  return function () {
    return fn.apply(null, arguments);
  };
};
exports.cacheSignal = function () {
  return null;
};
exports.cloneElement = function (element, config, children) {
  if (null === element || void 0 === element)
    throw Error(
      "The argument must be a React element, but you passed " + element + "."
    );
  var props = assign({}, element.props),
    key = element.key;
  if (null != config)
    for (propName in (void 0 !== config.key && (key = "" + config.key), config))
      !hasOwnProperty.call(config, propName) ||
        "key" === propName ||
        "__self" === propName ||
        "__source" === propName ||
        ("ref" === propName && void 0 === config.ref) ||
        (props[propName] = config[propName]);
  var propName = arguments.length - 2;
  if (1 === propName) props.children = children;
  else if (1 < propName) {
    for (var childArray = Array(propName), i = 0; i < propName; i++)
      childArray[i] = arguments[i + 2];
    props.children = childArray;
  }
  return ReactElement(element.type, key, props);
};
exports.createContext = function (defaultValue) {
  defaultValue = {
    $$typeof: REACT_CONTEXT_TYPE,
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    _threadCount: 0,
    Provider: null,
    Consumer: null
  };
  defaultValue.Provider = defaultValue;
  defaultValue.Consumer = {
    $$typeof: REACT_CONSUMER_TYPE,
    _context: defaultValue
  };
  return defaultValue;
};
exports.createElement = function (type, config, children) {
  var propName,
    props = {},
    key = null;
  if (null != config)
    for (propName in (void 0 !== config.key && (key = "" + config.key), config))
      hasOwnProperty.call(config, propName) &&
        "key" !== propName &&
        "__self" !== propName &&
        "__source" !== propName &&
        (props[propName] = config[propName]);
  var childrenLength = arguments.length - 2;
  if (1 === childrenLength) props.children = children;
  else if (1 < childrenLength) {
    for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
      childArray[i] = arguments[i + 2];
    props.children = childArray;
  }
  if (type && type.defaultProps)
    for (propName in ((childrenLength = type.defaultProps), childrenLength))
      void 0 === props[propName] &&
        (props[propName] = childrenLength[propName]);
  return ReactElement(type, key, props);
};
exports.createRef = function () {
  return { current: null };
};
exports.forwardRef = function (render) {
  return { $$typeof: REACT_FORWARD_REF_TYPE, render: render };
};
exports.isValidElement = isValidElement;
exports.lazy = function (ctor) {
  return {
    $$typeof: REACT_LAZY_TYPE,
    _payload: { _status: -1, _result: ctor },
    _init: lazyInitializer
  };
};
exports.memo = function (type, compare) {
  return {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: void 0 === compare ? null : compare
  };
};
exports.startTransition = function (scope) {
  var prevTransition = ReactSharedInternals.T,
    currentTransition = {};
  ReactSharedInternals.T = currentTransition;
  try {
    var returnValue = scope(),
      onStartTransitionFinish = ReactSharedInternals.S;
    null !== onStartTransitionFinish &&
      onStartTransitionFinish(currentTransition, returnValue);
    "object" === typeof returnValue &&
      null !== returnValue &&
      "function" === typeof returnValue.then &&
      returnValue.then(noop, reportGlobalError);
  } catch (error) {
    reportGlobalError(error);
  } finally {
    null !== prevTransition &&
      null !== currentTransition.types &&
      (prevTransition.types = currentTransition.types),
      (ReactSharedInternals.T = prevTransition);
  }
};
exports.unstable_useCacheRefresh = function () {
  return ReactSharedInternals.H.useCacheRefresh();
};
exports.use = function (usable) {
  return ReactSharedInternals.H.use(usable);
};
exports.useActionState = function (action, initialState, permalink) {
  return ReactSharedInternals.H.useActionState(action, initialState, permalink);
};
exports.useCallback = function (callback, deps) {
  return ReactSharedInternals.H.useCallback(callback, deps);
};
exports.useContext = function (Context) {
  return ReactSharedInternals.H.useContext(Context);
};
exports.useDebugValue = function () {};
exports.useDeferredValue = function (value, initialValue) {
  return ReactSharedInternals.H.useDeferredValue(value, initialValue);
};
exports.useEffect = function (create, deps) {
  return ReactSharedInternals.H.useEffect(create, deps);
};
exports.useEffectEvent = function (callback) {
  return ReactSharedInternals.H.useEffectEvent(callback);
};
exports.useId = function () {
  return ReactSharedInternals.H.useId();
};
exports.useImperativeHandle = function (ref, create, deps) {
  return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
};
exports.useInsertionEffect = function (create, deps) {
  return ReactSharedInternals.H.useInsertionEffect(create, deps);
};
exports.useLayoutEffect = function (create, deps) {
  return ReactSharedInternals.H.useLayoutEffect(create, deps);
};
exports.useMemo = function (create, deps) {
  return ReactSharedInternals.H.useMemo(create, deps);
};
exports.useOptimistic = function (passthrough, reducer) {
  return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
};
exports.useReducer = function (reducer, initialArg, init) {
  return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
};
exports.useRef = function (initialValue) {
  return ReactSharedInternals.H.useRef(initialValue);
};
exports.useState = function (initialState) {
  return ReactSharedInternals.H.useState(initialState);
};
exports.useSyncExternalStore = function (
  subscribe,
  getSnapshot,
  getServerSnapshot
) {
  return ReactSharedInternals.H.useSyncExternalStore(
    subscribe,
    getSnapshot,
    getServerSnapshot
  );
};
exports.useTransition = function () {
  return ReactSharedInternals.H.useTransition();
};
exports.version = "19.2.0";


}),
96540: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


if (true) {
  module.exports = __webpack_require__(29869);
} else {}


}),
74848: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


if (true) {
  module.exports = __webpack_require__(29698);
} else {}


}),
4477: (function (__unused_webpack_module, exports) {
"use strict";
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


function push(heap, node) {
  var index = heap.length;
  heap.push(node);
  a: for (; 0 < index; ) {
    var parentIndex = (index - 1) >>> 1,
      parent = heap[parentIndex];
    if (0 < compare(parent, node))
      (heap[parentIndex] = node), (heap[index] = parent), (index = parentIndex);
    else break a;
  }
}
function peek(heap) {
  return 0 === heap.length ? null : heap[0];
}
function pop(heap) {
  if (0 === heap.length) return null;
  var first = heap[0],
    last = heap.pop();
  if (last !== first) {
    heap[0] = last;
    a: for (
      var index = 0, length = heap.length, halfLength = length >>> 1;
      index < halfLength;

    ) {
      var leftIndex = 2 * (index + 1) - 1,
        left = heap[leftIndex],
        rightIndex = leftIndex + 1,
        right = heap[rightIndex];
      if (0 > compare(left, last))
        rightIndex < length && 0 > compare(right, left)
          ? ((heap[index] = right),
            (heap[rightIndex] = last),
            (index = rightIndex))
          : ((heap[index] = left),
            (heap[leftIndex] = last),
            (index = leftIndex));
      else if (rightIndex < length && 0 > compare(right, last))
        (heap[index] = right), (heap[rightIndex] = last), (index = rightIndex);
      else break a;
    }
  }
  return first;
}
function compare(a, b) {
  var diff = a.sortIndex - b.sortIndex;
  return 0 !== diff ? diff : a.id - b.id;
}
exports.unstable_now = void 0;
if ("object" === typeof performance && "function" === typeof performance.now) {
  var localPerformance = performance;
  exports.unstable_now = function () {
    return localPerformance.now();
  };
} else {
  var localDate = Date,
    initialTime = localDate.now();
  exports.unstable_now = function () {
    return localDate.now() - initialTime;
  };
}
var taskQueue = [],
  timerQueue = [],
  taskIdCounter = 1,
  currentTask = null,
  currentPriorityLevel = 3,
  isPerformingWork = !1,
  isHostCallbackScheduled = !1,
  isHostTimeoutScheduled = !1,
  needsPaint = !1,
  localSetTimeout = "function" === typeof setTimeout ? setTimeout : null,
  localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null,
  localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
function advanceTimers(currentTime) {
  for (var timer = peek(timerQueue); null !== timer; ) {
    if (null === timer.callback) pop(timerQueue);
    else if (timer.startTime <= currentTime)
      pop(timerQueue),
        (timer.sortIndex = timer.expirationTime),
        push(taskQueue, timer);
    else break;
    timer = peek(timerQueue);
  }
}
function handleTimeout(currentTime) {
  isHostTimeoutScheduled = !1;
  advanceTimers(currentTime);
  if (!isHostCallbackScheduled)
    if (null !== peek(taskQueue))
      (isHostCallbackScheduled = !0),
        isMessageLoopRunning ||
          ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline());
    else {
      var firstTimer = peek(timerQueue);
      null !== firstTimer &&
        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    }
}
var isMessageLoopRunning = !1,
  taskTimeoutID = -1,
  frameInterval = 5,
  startTime = -1;
function shouldYieldToHost() {
  return needsPaint
    ? !0
    : exports.unstable_now() - startTime < frameInterval
      ? !1
      : !0;
}
function performWorkUntilDeadline() {
  needsPaint = !1;
  if (isMessageLoopRunning) {
    var currentTime = exports.unstable_now();
    startTime = currentTime;
    var hasMoreWork = !0;
    try {
      a: {
        isHostCallbackScheduled = !1;
        isHostTimeoutScheduled &&
          ((isHostTimeoutScheduled = !1),
          localClearTimeout(taskTimeoutID),
          (taskTimeoutID = -1));
        isPerformingWork = !0;
        var previousPriorityLevel = currentPriorityLevel;
        try {
          b: {
            advanceTimers(currentTime);
            for (
              currentTask = peek(taskQueue);
              null !== currentTask &&
              !(
                currentTask.expirationTime > currentTime && shouldYieldToHost()
              );

            ) {
              var callback = currentTask.callback;
              if ("function" === typeof callback) {
                currentTask.callback = null;
                currentPriorityLevel = currentTask.priorityLevel;
                var continuationCallback = callback(
                  currentTask.expirationTime <= currentTime
                );
                currentTime = exports.unstable_now();
                if ("function" === typeof continuationCallback) {
                  currentTask.callback = continuationCallback;
                  advanceTimers(currentTime);
                  hasMoreWork = !0;
                  break b;
                }
                currentTask === peek(taskQueue) && pop(taskQueue);
                advanceTimers(currentTime);
              } else pop(taskQueue);
              currentTask = peek(taskQueue);
            }
            if (null !== currentTask) hasMoreWork = !0;
            else {
              var firstTimer = peek(timerQueue);
              null !== firstTimer &&
                requestHostTimeout(
                  handleTimeout,
                  firstTimer.startTime - currentTime
                );
              hasMoreWork = !1;
            }
          }
          break a;
        } finally {
          (currentTask = null),
            (currentPriorityLevel = previousPriorityLevel),
            (isPerformingWork = !1);
        }
        hasMoreWork = void 0;
      }
    } finally {
      hasMoreWork
        ? schedulePerformWorkUntilDeadline()
        : (isMessageLoopRunning = !1);
    }
  }
}
var schedulePerformWorkUntilDeadline;
if ("function" === typeof localSetImmediate)
  schedulePerformWorkUntilDeadline = function () {
    localSetImmediate(performWorkUntilDeadline);
  };
else if ("undefined" !== typeof MessageChannel) {
  var channel = new MessageChannel(),
    port = channel.port2;
  channel.port1.onmessage = performWorkUntilDeadline;
  schedulePerformWorkUntilDeadline = function () {
    port.postMessage(null);
  };
} else
  schedulePerformWorkUntilDeadline = function () {
    localSetTimeout(performWorkUntilDeadline, 0);
  };
function requestHostTimeout(callback, ms) {
  taskTimeoutID = localSetTimeout(function () {
    callback(exports.unstable_now());
  }, ms);
}
exports.unstable_IdlePriority = 5;
exports.unstable_ImmediatePriority = 1;
exports.unstable_LowPriority = 4;
exports.unstable_NormalPriority = 3;
exports.unstable_Profiling = null;
exports.unstable_UserBlockingPriority = 2;
exports.unstable_cancelCallback = function (task) {
  task.callback = null;
};
exports.unstable_forceFrameRate = function (fps) {
  0 > fps || 125 < fps
    ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      )
    : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);
};
exports.unstable_getCurrentPriorityLevel = function () {
  return currentPriorityLevel;
};
exports.unstable_next = function (eventHandler) {
  switch (currentPriorityLevel) {
    case 1:
    case 2:
    case 3:
      var priorityLevel = 3;
      break;
    default:
      priorityLevel = currentPriorityLevel;
  }
  var previousPriorityLevel = currentPriorityLevel;
  currentPriorityLevel = priorityLevel;
  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
};
exports.unstable_requestPaint = function () {
  needsPaint = !0;
};
exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {
  switch (priorityLevel) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      break;
    default:
      priorityLevel = 3;
  }
  var previousPriorityLevel = currentPriorityLevel;
  currentPriorityLevel = priorityLevel;
  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
};
exports.unstable_scheduleCallback = function (
  priorityLevel,
  callback,
  options
) {
  var currentTime = exports.unstable_now();
  "object" === typeof options && null !== options
    ? ((options = options.delay),
      (options =
        "number" === typeof options && 0 < options
          ? currentTime + options
          : currentTime))
    : (options = currentTime);
  switch (priorityLevel) {
    case 1:
      var timeout = -1;
      break;
    case 2:
      timeout = 250;
      break;
    case 5:
      timeout = 1073741823;
      break;
    case 4:
      timeout = 1e4;
      break;
    default:
      timeout = 5e3;
  }
  timeout = options + timeout;
  priorityLevel = {
    id: taskIdCounter++,
    callback: callback,
    priorityLevel: priorityLevel,
    startTime: options,
    expirationTime: timeout,
    sortIndex: -1
  };
  options > currentTime
    ? ((priorityLevel.sortIndex = options),
      push(timerQueue, priorityLevel),
      null === peek(taskQueue) &&
        priorityLevel === peek(timerQueue) &&
        (isHostTimeoutScheduled
          ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))
          : (isHostTimeoutScheduled = !0),
        requestHostTimeout(handleTimeout, options - currentTime)))
    : ((priorityLevel.sortIndex = timeout),
      push(taskQueue, priorityLevel),
      isHostCallbackScheduled ||
        isPerformingWork ||
        ((isHostCallbackScheduled = !0),
        isMessageLoopRunning ||
          ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline())));
  return priorityLevel;
};
exports.unstable_shouldYield = shouldYieldToHost;
exports.unstable_wrapCallback = function (callback) {
  var parentPriorityLevel = currentPriorityLevel;
  return function () {
    var previousPriorityLevel = currentPriorityLevel;
    currentPriorityLevel = parentPriorityLevel;
    try {
      return callback.apply(this, arguments);
    } finally {
      currentPriorityLevel = previousPriorityLevel;
    }
  };
};


}),
69982: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


if (true) {
  module.exports = __webpack_require__(4477);
} else {}


}),
2833: (function (module) {
//

module.exports = function shallowEqual(objA, objB, compare, compareContext) {
  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

  if (ret !== void 0) {
    return !!ret;
  }

  if (objA === objB) {
    return true;
  }

  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);

  // Test for A's keys different from B.
  for (var idx = 0; idx < keysA.length; idx++) {
    var key = keysA[idx];

    if (!bHasOwnProperty(key)) {
      return false;
    }

    var valueA = objA[key];
    var valueB = objB[key];

    ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;

    if (ret === false || (ret === void 0 && valueA !== valueB)) {
      return false;
    }
  }

  return true;
};


}),
58460: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ routes)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(74848);
// EXTERNAL MODULE: ./node_modules/react-loadable/lib/index.js
var lib = __webpack_require__(53259);
var lib_default = /*#__PURE__*/__webpack_require__.n(lib);
// EXTERNAL MODULE: ./.docusaurus/routesChunkNames.json
var routesChunkNames = __webpack_require__(84054);
;// CONCATENATED MODULE: ./.docusaurus/registry.js
/* export default */ const registry = ({
    "00e732e1": [
        ()=>__webpack_require__.e(/* import() | 00e732e1 */ "9931").then(__webpack_require__.t.bind(__webpack_require__, 78147, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/blog-tags-embudo-ventas-cb4.json",
        /*require.resolve*/(78147)
    ],
    "01a85c17": [
        ()=>Promise.all(/* import() | 01a85c17 */ [__webpack_require__.e("4014"), __webpack_require__.e("9786")]).then(__webpack_require__.bind(__webpack_require__, 73084)),
        "@theme/BlogTagsListPage",
        /*require.resolve*/(73084)
    ],
    "01fb8007": [
        ()=>__webpack_require__.e(/* import() | 01fb8007 */ "9978").then(__webpack_require__.bind(__webpack_require__, 49840)),
        "@site/blog/2025-04-06-indicadores-clave-de-rendimiento-kpi-para-medir-el-exito.md?truncated=true",
        /*require.resolve*/(49840)
    ],
    "02387f82": [
        ()=>__webpack_require__.e(/* import() | 02387f82 */ "5614").then(__webpack_require__.t.bind(__webpack_require__, 54255, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-getting-started-1be.json",
        /*require.resolve*/(54255)
    ],
    "0420c4c4": [
        ()=>__webpack_require__.e(/* import() | 0420c4c4 */ "9394").then(__webpack_require__.t.bind(__webpack_require__, 85186, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-billing-7c1.json",
        /*require.resolve*/(85186)
    ],
    "04aa852f": [
        ()=>__webpack_require__.e(/* import() | 04aa852f */ "8125").then(__webpack_require__.t.bind(__webpack_require__, 24312, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-troubleshooting-042.json",
        /*require.resolve*/(24312)
    ],
    "0641b426": [
        ()=>__webpack_require__.e(/* import() | 0641b426 */ "3483").then(__webpack_require__.t.bind(__webpack_require__, 86067, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/blog-tags-leads-8df.json",
        /*require.resolve*/(86067)
    ],
    "06e61810": [
        ()=>__webpack_require__.e(/* import() | 06e61810 */ "6429").then(__webpack_require__.bind(__webpack_require__, 73051)),
        "@site/docs/kb/users-and-permissions/how-can-i-add-a-user.md",
        /*require.resolve*/(73051)
    ],
    "076880ce": [
        ()=>__webpack_require__.e(/* import() | 076880ce */ "9167").then(__webpack_require__.bind(__webpack_require__, 14300)),
        "@site/docs/kb/importing-data/importing-mapping-your-fields.md",
        /*require.resolve*/(14300)
    ],
    "08d3a22b": [
        ()=>__webpack_require__.e(/* import() | 08d3a22b */ "1394").then(__webpack_require__.bind(__webpack_require__, 36768)),
        "@site/docs/kb/troubleshooting/how-can-i-take-a-screenshot.md",
        /*require.resolve*/(36768)
    ],
    "0a7e2833": [
        ()=>__webpack_require__.e(/* import() | 0a7e2833 */ "5139").then(__webpack_require__.t.bind(__webpack_require__, 9277, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-data-fields-8f0.json",
        /*require.resolve*/(9277)
    ],
    "0a9aba24": [
        ()=>__webpack_require__.e(/* import() | 0a9aba24 */ "1130").then(__webpack_require__.t.bind(__webpack_require__, 983, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-basic-concepts-6c4.json",
        /*require.resolve*/(983)
    ],
    "0b32ee9d": [
        ()=>__webpack_require__.e(/* import() | 0b32ee9d */ "1860").then(__webpack_require__.bind(__webpack_require__, 87374)),
        "@site/docs/kb/filtering/filters-common-uses.md",
        /*require.resolve*/(87374)
    ],
    "0cab6d25": [
        ()=>__webpack_require__.e(/* import() | 0cab6d25 */ "7545").then(__webpack_require__.bind(__webpack_require__, 63935)),
        "@site/blog/2025-04-05-alineando-marketing-y-ventas-para-una-conversion-optima.md?truncated=true",
        /*require.resolve*/(63935)
    ],
    "0ddb9610": [
        ()=>Promise.all(/* import() | 0ddb9610 */ [__webpack_require__.e("4014"), __webpack_require__.e("513"), __webpack_require__.e("3452")]).then(__webpack_require__.bind(__webpack_require__, 20039)),
        "@site/docs/fintesk/v1.mdx",
        /*require.resolve*/(20039)
    ],
    "0f049439": [
        ()=>__webpack_require__.e(/* import() | 0f049439 */ "2247").then(__webpack_require__.t.bind(__webpack_require__, 37283, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-tos-26c.json",
        /*require.resolve*/(37283)
    ],
    "105c8d66": [
        ()=>__webpack_require__.e(/* import() | 105c8d66 */ "9401").then(__webpack_require__.bind(__webpack_require__, 80266)),
        "@site/docs/kb/personal-settings/how-can-i-change-or-reset-my-password.md",
        /*require.resolve*/(80266)
    ],
    "11db73b9": [
        ()=>__webpack_require__.e(/* import() | 11db73b9 */ "3639").then(__webpack_require__.bind(__webpack_require__, 80100)),
        "@site/docs/kb/getting-started/how-can-i-delete-items-in-fintesk.md",
        /*require.resolve*/(80100)
    ],
    "14426f04": [
        ()=>__webpack_require__.e(/* import() | 14426f04 */ "5523").then(__webpack_require__.t.bind(__webpack_require__, 16372, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-knowledge-base-61d.json",
        /*require.resolve*/(16372)
    ],
    "14eb3368": [
        ()=>Promise.all(/* import() | 14eb3368 */ [__webpack_require__.e("4014"), __webpack_require__.e("7234")]).then(__webpack_require__.bind(__webpack_require__, 53838)),
        "@theme/DocCategoryGeneratedIndexPage",
        /*require.resolve*/(53838)
    ],
    "15152d82": [
        ()=>__webpack_require__.e(/* import() | 15152d82 */ "6044").then(__webpack_require__.bind(__webpack_require__, 68804)),
        "@site/docs/kb/products/can-i-import-products-and-automatically-link-them-to-deals.md",
        /*require.resolve*/(68804)
    ],
    "1561ae7f": [
        ()=>__webpack_require__.e(/* import() | 1561ae7f */ "5452").then(__webpack_require__.bind(__webpack_require__, 12225)),
        "@site/docs/kb/importing-data/changing-the-field-type-of-a-custom-field.md",
        /*require.resolve*/(12225)
    ],
    "159ada6c": [
        ()=>__webpack_require__.e(/* import() | 159ada6c */ "5304").then(__webpack_require__.bind(__webpack_require__, 46316)),
        "@site/docs/kb/troubleshooting/troubleshooting-fintesk-web-app.md",
        /*require.resolve*/(46316)
    ],
    "15bc0e42": [
        ()=>__webpack_require__.e(/* import() | 15bc0e42 */ "768").then(__webpack_require__.bind(__webpack_require__, 10295)),
        "@site/docs/kb/detail-view/how-can-i-add-notes-to-a-deal-or-contact.md",
        /*require.resolve*/(10295)
    ],
    "16b8a101": [
        ()=>__webpack_require__.e(/* import() | 16b8a101 */ "3663").then(__webpack_require__.t.bind(__webpack_require__, 41604, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-filtering-d8e.json",
        /*require.resolve*/(41604)
    ],
    "17896441": [
        ()=>Promise.all(/* import() | 17896441 */ [__webpack_require__.e("4014"), __webpack_require__.e("4473"), __webpack_require__.e("106")]).then(__webpack_require__.bind(__webpack_require__, 46627)),
        "@theme/DocItem",
        /*require.resolve*/(46627)
    ],
    "17e0ce07": [
        ()=>__webpack_require__.e(/* import() | 17e0ce07 */ "9220").then(__webpack_require__.bind(__webpack_require__, 31315)),
        "@site/docs/kb/detail-view/updating-items-in-the-detail-view.md",
        /*require.resolve*/(31315)
    ],
    "1a1bfc42": [
        ()=>__webpack_require__.e(/* import() | 1a1bfc42 */ "6708").then(__webpack_require__.t.bind(__webpack_require__, 71889, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-filtering-e2f.json",
        /*require.resolve*/(71889)
    ],
    "1a6e6df9": [
        ()=>__webpack_require__.e(/* import() | 1a6e6df9 */ "6600").then(__webpack_require__.t.bind(__webpack_require__, 54978, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-list-view-168.json",
        /*require.resolve*/(54978)
    ],
    "1d8fdc93": [
        ()=>__webpack_require__.e(/* import() | 1d8fdc93 */ "758").then(__webpack_require__.t.bind(__webpack_require__, 2760, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/blog-tags-excel-vs-crm-77f.json",
        /*require.resolve*/(2760)
    ],
    "1f391b9e": [
        ()=>Promise.all(/* import() | 1f391b9e */ [__webpack_require__.e("4014"), __webpack_require__.e("4473"), __webpack_require__.e("7182")]).then(__webpack_require__.bind(__webpack_require__, 70155)),
        "@theme/MDXPage",
        /*require.resolve*/(70155)
    ],
    "20e4b877": [
        ()=>__webpack_require__.e(/* import() | 20e4b877 */ "7827").then(__webpack_require__.bind(__webpack_require__, 42669)),
        "@site/blog/2025-04-06-crm-vs-excel-un-analisis-comparativo.md",
        /*require.resolve*/(42669)
    ],
    "217e589f": [
        ()=>__webpack_require__.e(/* import() | 217e589f */ "4043").then(__webpack_require__.t.bind(__webpack_require__, 11523, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-pipelines-68e.json",
        /*require.resolve*/(11523)
    ],
    "22dd74f7": [
        ()=>__webpack_require__.e(/* import() | 22dd74f7 */ "1924").then(__webpack_require__.t.bind(__webpack_require__, 55226, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/index-466.json",
        /*require.resolve*/(55226)
    ],
    "22ed1d20": [
        ()=>__webpack_require__.e(/* import() | 22ed1d20 */ "4338").then(__webpack_require__.bind(__webpack_require__, 37682)),
        "@site/docs/kb/filtering/filtering.md",
        /*require.resolve*/(37682)
    ],
    "2387fda4": [
        ()=>__webpack_require__.e(/* import() | 2387fda4 */ "9405").then(__webpack_require__.bind(__webpack_require__, 7724)),
        "@site/docs/kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user.md",
        /*require.resolve*/(7724)
    ],
    "23f37113": [
        ()=>__webpack_require__.e(/* import() | 23f37113 */ "3316").then(__webpack_require__.t.bind(__webpack_require__, 38295, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/blog-tags-crm-page-2-cf5.json",
        /*require.resolve*/(38295)
    ],
    "24bd74fc": [
        ()=>__webpack_require__.e(/* import() | 24bd74fc */ "2584").then(__webpack_require__.bind(__webpack_require__, 11093)),
        "@site/docs/privacy/fintesk-data-sub-processors.md",
        /*require.resolve*/(11093)
    ],
    "2500cc84": [
        ()=>__webpack_require__.e(/* import() | 2500cc84 */ "875").then(__webpack_require__.t.bind(__webpack_require__, 51313, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-developers-5cd.json",
        /*require.resolve*/(51313)
    ],
    "26cb95a8": [
        ()=>__webpack_require__.e(/* import() | 26cb95a8 */ "6262").then(__webpack_require__.t.bind(__webpack_require__, 3357, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-changelog-3f4.json",
        /*require.resolve*/(3357)
    ],
    "278a4813": [
        ()=>__webpack_require__.e(/* import() | 278a4813 */ "4620").then(__webpack_require__.bind(__webpack_require__, 64229)),
        "@site/docs/kb/users-and-permissions/what-is-a-regular-user.md",
        /*require.resolve*/(64229)
    ],
    "288fdf9d": [
        ()=>__webpack_require__.e(/* import() | 288fdf9d */ "7167").then(__webpack_require__.t.bind(__webpack_require__, 70955, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-privacy-288.json",
        /*require.resolve*/(70955)
    ],
    "28b9f67b": [
        ()=>__webpack_require__.e(/* import() | 28b9f67b */ "4362").then(__webpack_require__.bind(__webpack_require__, 3179)),
        "@site/docs/kb/importing-data/why-do-my-imported-currency-values-appear-as-0.md",
        /*require.resolve*/(3179)
    ],
    "2e6f48d8": [
        ()=>__webpack_require__.e(/* import() | 2e6f48d8 */ "2197").then(__webpack_require__.bind(__webpack_require__, 79255)),
        "@site/docs/kb/pipelines/how-can-i-have-multiple-pipelines.md",
        /*require.resolve*/(79255)
    ],
    "321734ec": [
        ()=>__webpack_require__.e(/* import() | 321734ec */ "42").then(__webpack_require__.bind(__webpack_require__, 46527)),
        "@site/docs/kb/importing-data/importing-advanced-mapping.md",
        /*require.resolve*/(46527)
    ],
    "3344a506": [
        ()=>__webpack_require__.e(/* import() | 3344a506 */ "6022").then(__webpack_require__.t.bind(__webpack_require__, 82794, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-detail-view-e1d.json",
        /*require.resolve*/(82794)
    ],
    "339d9f16": [
        ()=>__webpack_require__.e(/* import() | 339d9f16 */ "9059").then(__webpack_require__.t.bind(__webpack_require__, 73254, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-troubleshooting-the-web-app-d0e.json",
        /*require.resolve*/(73254)
    ],
    "347da0e9": [
        ()=>__webpack_require__.e(/* import() | 347da0e9 */ "6699").then(__webpack_require__.t.bind(__webpack_require__, 59374, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-activities-e11.json",
        /*require.resolve*/(59374)
    ],
    "348d668f": [
        ()=>__webpack_require__.e(/* import() | 348d668f */ "297").then(__webpack_require__.t.bind(__webpack_require__, 30123, 19)),
        "/Users/fabo/Documents/code/documentacion-fintesk/.docusaurus/docusaurus-plugin-redoc/fintesk-v1/redocApiSpecV1.2-fintesk-v1.json",
        /*require.resolve*/(30123)
    ],
    "350e7c1c": [
        ()=>__webpack_require__.e(/* import() | 350e7c1c */ "1233").then(__webpack_require__.bind(__webpack_require__, 34591)),
        "@site/docs/kb/deals/deals-what-they-are-and-how-to-add-them.md",
        /*require.resolve*/(34591)
    ],
    "35f50680": [
        ()=>__webpack_require__.e(/* import() | 35f50680 */ "9375").then(__webpack_require__.t.bind(__webpack_require__, 34572, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-core-api-concepts-611.json",
        /*require.resolve*/(34572)
    ],
    "360fe992": [
        ()=>__webpack_require__.e(/* import() | 360fe992 */ "970").then(__webpack_require__.bind(__webpack_require__, 13526)),
        "@site/docs/kb/importing-data/importing-sample-import-spreadsheets.md",
        /*require.resolve*/(13526)
    ],
    "36947cfd": [
        ()=>__webpack_require__.e(/* import() | 36947cfd */ "2032").then(__webpack_require__.t.bind(__webpack_require__, 37813, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-company-settings-2d3.json",
        /*require.resolve*/(37813)
    ],
    "36994c47": [
        ()=>__webpack_require__.e(/* import() | 36994c47 */ "191").then(__webpack_require__.t.bind(__webpack_require__, 45516, 19)),
        "@generated/docusaurus-plugin-content-blog/default/__plugin.json",
        /*require.resolve*/(45516)
    ],
    "3720c009": [
        ()=>Promise.all(/* import() | 3720c009 */ [__webpack_require__.e("4014"), __webpack_require__.e("5616")]).then(__webpack_require__.bind(__webpack_require__, 77610)),
        "@theme/DocTagsListPage",
        /*require.resolve*/(77610)
    ],
    "393be207": [
        ()=>__webpack_require__.e(/* import() | 393be207 */ "3627").then(__webpack_require__.bind(__webpack_require__, 66301)),
        "@site/src/pages/markdown-page.md",
        /*require.resolve*/(66301)
    ],
    "3964d4cf": [
        ()=>__webpack_require__.e(/* import() | 3964d4cf */ "491").then(__webpack_require__.t.bind(__webpack_require__, 36266, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-personal-settings-0a4.json",
        /*require.resolve*/(36266)
    ],
    "39a1d5e5": [
        ()=>__webpack_require__.e(/* import() | 39a1d5e5 */ "4359").then(__webpack_require__.bind(__webpack_require__, 90447)),
        "@site/docs/kb/pipeline-view/pipeline-view.md",
        /*require.resolve*/(90447)
    ],
    "3a2db09e": [
        ()=>__webpack_require__.e(/* import() | 3a2db09e */ "3186").then(__webpack_require__.t.bind(__webpack_require__, 68070, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/blog-tags-df9.json",
        /*require.resolve*/(68070)
    ],
    "3a790c7e": [
        ()=>__webpack_require__.e(/* import() | 3a790c7e */ "5217").then(__webpack_require__.t.bind(__webpack_require__, 96677, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-billing-information-e81.json",
        /*require.resolve*/(96677)
    ],
    "3aa59ccb": [
        ()=>__webpack_require__.e(/* import() | 3aa59ccb */ "1703").then(__webpack_require__.t.bind(__webpack_require__, 94928, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-troubleshooting-452.json",
        /*require.resolve*/(94928)
    ],
    "3e0612ca": [
        ()=>__webpack_require__.e(/* import() | 3e0612ca */ "2133").then(__webpack_require__.bind(__webpack_require__, 75676)),
        "@site/blog/2025-04-09-estrategias-para-atraer-leads-de-alta-calidad.md?truncated=true",
        /*require.resolve*/(75676)
    ],
    "3ec0aa47": [
        ()=>__webpack_require__.e(/* import() | 3ec0aa47 */ "6588").then(__webpack_require__.t.bind(__webpack_require__, 93750, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-products-1ab.json",
        /*require.resolve*/(93750)
    ],
    "40a066f6": [
        ()=>__webpack_require__.e(/* import() | 40a066f6 */ "1049").then(__webpack_require__.t.bind(__webpack_require__, 63996, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-company-settings-f67.json",
        /*require.resolve*/(63996)
    ],
    "414cb524": [
        ()=>__webpack_require__.e(/* import() | 414cb524 */ "1537").then(__webpack_require__.bind(__webpack_require__, 30059)),
        "@site/docs/kb/troubleshooting/can-fintesk-be-used-offline.md",
        /*require.resolve*/(30059)
    ],
    "41e76799": [
        ()=>__webpack_require__.e(/* import() | 41e76799 */ "3594").then(__webpack_require__.bind(__webpack_require__, 49179)),
        "@site/docs/kb/getting-started/fintesk-user-vs-company-account.md",
        /*require.resolve*/(49179)
    ],
    "4266b0db": [
        ()=>__webpack_require__.e(/* import() | 4266b0db */ "3190").then(__webpack_require__.bind(__webpack_require__, 20607)),
        "@site/docs/kb/importing-data/transferring-data-to-a-different-fintesk-company-account.md",
        /*require.resolve*/(20607)
    ],
    "42702193": [
        ()=>__webpack_require__.e(/* import() | 42702193 */ "3368").then(__webpack_require__.bind(__webpack_require__, 35293)),
        "@site/blog/2025-04-05-alineando-marketing-y-ventas-para-una-conversion-optima.md",
        /*require.resolve*/(35293)
    ],
    "42dbfab1": [
        ()=>__webpack_require__.e(/* import() | 42dbfab1 */ "5836").then(__webpack_require__.bind(__webpack_require__, 57168)),
        "@site/blog/2025-04-09-estrategias-para-atraer-leads-de-alta-calidad.md",
        /*require.resolve*/(57168)
    ],
    "4355a079": [
        ()=>__webpack_require__.e(/* import() | 4355a079 */ "6186").then(__webpack_require__.t.bind(__webpack_require__, 3344, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-pipeline-view-708.json",
        /*require.resolve*/(3344)
    ],
    "460bd348": [
        ()=>__webpack_require__.e(/* import() | 460bd348 */ "6621").then(__webpack_require__.bind(__webpack_require__, 68631)),
        "@site/docs/kb/data-fields/custom-fields.md",
        /*require.resolve*/(68631)
    ],
    "46212578": [
        ()=>__webpack_require__.e(/* import() | 46212578 */ "5865").then(__webpack_require__.bind(__webpack_require__, 76948)),
        "@site/docs/kb/products/how-can-i-link-products-to-a-deal.md",
        /*require.resolve*/(76948)
    ],
    "47a1e68f": [
        ()=>__webpack_require__.e(/* import() | 47a1e68f */ "1374").then(__webpack_require__.bind(__webpack_require__, 41443)),
        "@site/docs/tos/terms-of-service.md",
        /*require.resolve*/(41443)
    ],
    "497e7b2b": [
        ()=>__webpack_require__.e(/* import() | 497e7b2b */ "4910").then(__webpack_require__.bind(__webpack_require__, 13209)),
        "@site/docs/developers/core-api-concepts/core-api-concepts-about-fintesk-api.md",
        /*require.resolve*/(13209)
    ],
    "4efe2e96": [
        ()=>__webpack_require__.e(/* import() | 4efe2e96 */ "6956").then(__webpack_require__.t.bind(__webpack_require__, 61184, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-core-api-concepts-326.json",
        /*require.resolve*/(61184)
    ],
    "4f35b503": [
        ()=>__webpack_require__.e(/* import() | 4f35b503 */ "9230").then(__webpack_require__.bind(__webpack_require__, 55890)),
        "@site/docs/kb/troubleshooting/which-browser-is-best-for-fintesk.md",
        /*require.resolve*/(55890)
    ],
    "4f5dbec8": [
        ()=>__webpack_require__.e(/* import() | 4f5dbec8 */ "7937").then(__webpack_require__.bind(__webpack_require__, 65933)),
        "@site/docs/developers/core-api-concepts/core-api-concepts-http-status-codes.md",
        /*require.resolve*/(65933)
    ],
    "4fad16d7": [
        ()=>__webpack_require__.e(/* import() | 4fad16d7 */ "1301").then(__webpack_require__.bind(__webpack_require__, 46532)),
        "@site/docs/kb/personal-settings/usage-limits-in-fintesk.md",
        /*require.resolve*/(46532)
    ],
    "5032f16e": [
        ()=>__webpack_require__.e(/* import() | 5032f16e */ "7056").then(__webpack_require__.bind(__webpack_require__, 49359)),
        "@site/docs/kb/list-view/how-can-i-set-default-columns-for-all-my-users-in-the-list-view.md",
        /*require.resolve*/(49359)
    ],
    "54136c51": [
        ()=>__webpack_require__.e(/* import() | 54136c51 */ "6212").then(__webpack_require__.t.bind(__webpack_require__, 17932, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-deals-647.json",
        /*require.resolve*/(17932)
    ],
    "552c5e87": [
        ()=>__webpack_require__.e(/* import() | 552c5e87 */ "8834").then(__webpack_require__.t.bind(__webpack_require__, 2044, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-organizing-your-data-61d.json",
        /*require.resolve*/(2044)
    ],
    "557b7ec6": [
        ()=>__webpack_require__.e(/* import() | 557b7ec6 */ "5126").then(__webpack_require__.bind(__webpack_require__, 36721)),
        "@site/docs/kb/deals/adding-deals-in-bulk.md",
        /*require.resolve*/(36721)
    ],
    "55b8e973": [
        ()=>__webpack_require__.e(/* import() | 55b8e973 */ "4924").then(__webpack_require__.t.bind(__webpack_require__, 90960, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-activities-1de.json",
        /*require.resolve*/(90960)
    ],
    "57536add": [
        ()=>__webpack_require__.e(/* import() | 57536add */ "2917").then(__webpack_require__.bind(__webpack_require__, 21251)),
        "@site/docs/developers/core-api-concepts/changes-to-the-api.md",
        /*require.resolve*/(21251)
    ],
    "57886a6f": [
        ()=>__webpack_require__.e(/* import() | 57886a6f */ "1269").then(__webpack_require__.bind(__webpack_require__, 90288)),
        "@site/blog/2025-04-05-mejora-de-las-tasas-de-conversion-a-traves-del-embudo-de-marketing-y-ventas.md",
        /*require.resolve*/(90288)
    ],
    "583624b8": [
        ()=>__webpack_require__.e(/* import() | 583624b8 */ "3920").then(__webpack_require__.bind(__webpack_require__, 97296)),
        "@site/docs/kb/pipeline-view/the-rotting-feature.md",
        /*require.resolve*/(97296)
    ],
    "58c2ff45": [
        ()=>__webpack_require__.e(/* import() | 58c2ff45 */ "5223").then(__webpack_require__.t.bind(__webpack_require__, 97474, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-deals-f15.json",
        /*require.resolve*/(97474)
    ],
    "59423c55": [
        ()=>__webpack_require__.e(/* import() | 59423c55 */ "1068").then(__webpack_require__.bind(__webpack_require__, 72680)),
        "@site/blog/2025-04-06-las-desventajas-de-usar-excel-para-la-nutricion-y-el-seguimiento-de-leads.md?truncated=true",
        /*require.resolve*/(72680)
    ],
    "59af61a6": [
        ()=>__webpack_require__.e(/* import() | 59af61a6 */ "235").then(__webpack_require__.t.bind(__webpack_require__, 5332, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-b9f.json",
        /*require.resolve*/(5332)
    ],
    "5a7b92dd": [
        ()=>__webpack_require__.e(/* import() | 5a7b92dd */ "7360").then(__webpack_require__.t.bind(__webpack_require__, 8167, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-billing-4cb.json",
        /*require.resolve*/(8167)
    ],
    "5ad9b99e": [
        ()=>__webpack_require__.e(/* import() | 5ad9b99e */ "5766").then(__webpack_require__.t.bind(__webpack_require__, 67675, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-billing-information-d6c.json",
        /*require.resolve*/(67675)
    ],
    "5b13c556": [
        ()=>__webpack_require__.e(/* import() | 5b13c556 */ "8840").then(__webpack_require__.t.bind(__webpack_require__, 7187, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-pipelines-de7.json",
        /*require.resolve*/(7187)
    ],
    "5bc11281": [
        ()=>__webpack_require__.e(/* import() | 5bc11281 */ "2159").then(__webpack_require__.bind(__webpack_require__, 1545)),
        "@site/docs/billing/billing-information/what-happens-to-my-billing-when-i-add-a-user-in-fintesk.md",
        /*require.resolve*/(1545)
    ],
    "5d7e0aec": [
        ()=>__webpack_require__.e(/* import() | 5d7e0aec */ "1414").then(__webpack_require__.t.bind(__webpack_require__, 46953, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-personal-settings-9f2.json",
        /*require.resolve*/(46953)
    ],
    "5e95c892": [
        ()=>__webpack_require__.e(/* import() | 5e95c892 */ "1668").then(__webpack_require__.bind(__webpack_require__, 86569)),
        "@theme/DocsRoot",
        /*require.resolve*/(86569)
    ],
    "5f673c16": [
        ()=>__webpack_require__.e(/* import() | 5f673c16 */ "8637").then(__webpack_require__.bind(__webpack_require__, 10108)),
        "@site/docs/kb/getting-started/organization-vs-company-account.md",
        /*require.resolve*/(10108)
    ],
    "5f97402f": [
        ()=>__webpack_require__.e(/* import() | 5f97402f */ "5959").then(__webpack_require__.bind(__webpack_require__, 26804)),
        "@site/docs/kb/data-fields/data-fields-in-fintesk.md",
        /*require.resolve*/(26804)
    ],
    "6114d855": [
        ()=>__webpack_require__.e(/* import() | 6114d855 */ "1906").then(__webpack_require__.bind(__webpack_require__, 83367)),
        "@site/blog/2025-04-06-comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel.md?truncated=true",
        /*require.resolve*/(83367)
    ],
    "621db11d": [
        ()=>Promise.all(/* import() | 621db11d */ [__webpack_require__.e("4014"), __webpack_require__.e("6726"), __webpack_require__.e("1221")]).then(__webpack_require__.bind(__webpack_require__, 86433)),
        "@theme/Blog/Pages/BlogAuthorsListPage",
        /*require.resolve*/(86433)
    ],
    "64b4bdc3": [
        ()=>__webpack_require__.e(/* import() | 64b4bdc3 */ "5420").then(__webpack_require__.bind(__webpack_require__, 84317)),
        "@site/docs/kb/detail-view/deal-detail-view.md",
        /*require.resolve*/(84317)
    ],
    "65f62bf7": [
        ()=>__webpack_require__.e(/* import() | 65f62bf7 */ "5178").then(__webpack_require__.t.bind(__webpack_require__, 82937, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/blog-tags-ventas-af9.json",
        /*require.resolve*/(82937)
    ],
    "66b10d08": [
        ()=>__webpack_require__.e(/* import() | 66b10d08 */ "1145").then(__webpack_require__.bind(__webpack_require__, 79331)),
        "@site/docs/kb/list-view/how-can-i-add-or-remove-columns-in-the-list-view.md",
        /*require.resolve*/(79331)
    ],
    "6875c492": [
        ()=>Promise.all(/* import() | 6875c492 */ [__webpack_require__.e("4014"), __webpack_require__.e("4473"), __webpack_require__.e("6726"), __webpack_require__.e("766")]).then(__webpack_require__.bind(__webpack_require__, 20149)),
        "@theme/BlogTagsPostsPage",
        /*require.resolve*/(20149)
    ],
    "68a6222d": [
        ()=>__webpack_require__.e(/* import() | 68a6222d */ "9843").then(__webpack_require__.bind(__webpack_require__, 66636)),
        "@site/docs/kb/exporting-data/exporting-data-from-fintesk.md",
        /*require.resolve*/(66636)
    ],
    "68d382cf": [
        ()=>__webpack_require__.e(/* import() | 68d382cf */ "7224").then(__webpack_require__.bind(__webpack_require__, 24125)),
        "@site/blog/2025-04-05-estrategias-para-mejorar-las-tasas-de-conversion-en-cada-etapa-del-embudo.md",
        /*require.resolve*/(24125)
    ],
    "68f438f9": [
        ()=>__webpack_require__.e(/* import() | 68f438f9 */ "310").then(__webpack_require__.bind(__webpack_require__, 11815)),
        "@site/docs/privacy/dpa.md",
        /*require.resolve*/(11815)
    ],
    "6a26327e": [
        ()=>__webpack_require__.e(/* import() | 6a26327e */ "1052").then(__webpack_require__.bind(__webpack_require__, 33020)),
        "@site/blog/2025-04-05-mejora-de-las-tasas-de-conversion-a-traves-del-embudo-de-marketing-y-ventas.md?truncated=true",
        /*require.resolve*/(33020)
    ],
    "6c8a611e": [
        ()=>__webpack_require__.e(/* import() | 6c8a611e */ "6727").then(__webpack_require__.bind(__webpack_require__, 8562)),
        "@site/docs/kb/pipelines/how-can-i-add-a-stage-to-my-pipeline.md",
        /*require.resolve*/(8562)
    ],
    "6de61594": [
        ()=>__webpack_require__.e(/* import() | 6de61594 */ "2990").then(__webpack_require__.bind(__webpack_require__, 17343)),
        "@site/blog/2025-04-05-estrategias-para-mejorar-las-tasas-de-conversion-en-cada-etapa-del-embudo.md?truncated=true",
        /*require.resolve*/(17343)
    ],
    "6ee5b1e1": [
        ()=>__webpack_require__.e(/* import() | 6ee5b1e1 */ "1912").then(__webpack_require__.t.bind(__webpack_require__, 72764, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-data-fields-f75.json",
        /*require.resolve*/(72764)
    ],
    "703821d4": [
        ()=>__webpack_require__.e(/* import() | 703821d4 */ "3769").then(__webpack_require__.bind(__webpack_require__, 15400)),
        "@site/docs/kb/activities/how-can-i-create-activities-in-bulk.md",
        /*require.resolve*/(15400)
    ],
    "71b694a8": [
        ()=>__webpack_require__.e(/* import() | 71b694a8 */ "4556").then(__webpack_require__.bind(__webpack_require__, 94736)),
        "@site/blog/2025-04-08-como-elegir-el-crm-o-software-de-gestion-de-ventas.md?truncated=true",
        /*require.resolve*/(94736)
    ],
    "72450ad2": [
        ()=>__webpack_require__.e(/* import() | 72450ad2 */ "1031").then(__webpack_require__.bind(__webpack_require__, 58077)),
        "@site/docs/kb/troubleshooting/how-do-i-clear-my-browser-s-cache-and-cookies.md",
        /*require.resolve*/(58077)
    ],
    "73975f86": [
        ()=>__webpack_require__.e(/* import() | 73975f86 */ "3307").then(__webpack_require__.t.bind(__webpack_require__, 24182, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-browser-895.json",
        /*require.resolve*/(24182)
    ],
    "740980d9": [
        ()=>__webpack_require__.e(/* import() | 740980d9 */ "1195").then(__webpack_require__.bind(__webpack_require__, 23246)),
        "@site/docs/billing/your-fintesk-subscription-plan/what-features-do-the-fintesk-plans-have.md",
        /*require.resolve*/(23246)
    ],
    "7658d294": [
        ()=>__webpack_require__.e(/* import() | 7658d294 */ "8103").then(__webpack_require__.bind(__webpack_require__, 48971)),
        "@site/docs/kb/deals/how-can-i-move-a-deal-to-another-pipeline.md",
        /*require.resolve*/(48971)
    ],
    "7665015b": [
        ()=>__webpack_require__.e(/* import() | 7665015b */ "4207").then(__webpack_require__.bind(__webpack_require__, 25151)),
        "@site/docs/kb/activities/how-can-i-see-done-activities.md",
        /*require.resolve*/(25151)
    ],
    "76e8ffac": [
        ()=>__webpack_require__.e(/* import() | 76e8ffac */ "6964").then(__webpack_require__.bind(__webpack_require__, 5458)),
        "@site/docs/kb/personal-settings/how-can-i-free-up-space.md",
        /*require.resolve*/(5458)
    ],
    "7711c30d": [
        ()=>__webpack_require__.e(/* import() | 7711c30d */ "3990").then(__webpack_require__.t.bind(__webpack_require__, 70248, 19)),
        "/Users/fabo/Documents/code/documentacion-fintesk/.docusaurus/docusaurus-plugin-redoc/fintesk-v1/redocApiLayoutV1-fintesk-v1.json",
        /*require.resolve*/(70248)
    ],
    "77181fba": [
        ()=>__webpack_require__.e(/* import() | 77181fba */ "8229").then(__webpack_require__.t.bind(__webpack_require__, 37203, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-privacy-e80.json",
        /*require.resolve*/(37203)
    ],
    "78f609cd": [
        ()=>__webpack_require__.e(/* import() | 78f609cd */ "2047").then(__webpack_require__.bind(__webpack_require__, 57834)),
        "@site/docs/kb/users-and-permissions/global-user-management.md",
        /*require.resolve*/(57834)
    ],
    "7918b82f": [
        ()=>__webpack_require__.e(/* import() | 7918b82f */ "6671").then(__webpack_require__.bind(__webpack_require__, 19040)),
        "@site/docs/privacy/privacy.md",
        /*require.resolve*/(19040)
    ],
    "79b26084": [
        ()=>__webpack_require__.e(/* import() | 79b26084 */ "6638").then(__webpack_require__.bind(__webpack_require__, 36826)),
        "@site/docs/kb/personal-settings/fintesk-settings.md",
        /*require.resolve*/(36826)
    ],
    "79c74b4f": [
        ()=>__webpack_require__.e(/* import() | 79c74b4f */ "7882").then(__webpack_require__.t.bind(__webpack_require__, 68872, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-terms-of-service-84d.json",
        /*require.resolve*/(68872)
    ],
    "7a29ade3": [
        ()=>__webpack_require__.e(/* import() | 7a29ade3 */ "5916").then(__webpack_require__.t.bind(__webpack_require__, 33253, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-exporting-data-e4f.json",
        /*require.resolve*/(33253)
    ],
    "7e188a67": [
        ()=>__webpack_require__.e(/* import() | 7e188a67 */ "153").then(__webpack_require__.bind(__webpack_require__, 63658)),
        "@site/docs/developers/core-api-concepts/core-api-concepts-custom-fields.md",
        /*require.resolve*/(63658)
    ],
    "7ff52d0a": [
        ()=>__webpack_require__.e(/* import() | 7ff52d0a */ "9265").then(__webpack_require__.bind(__webpack_require__, 27724)),
        "@site/docs/kb/activities/activity-marked-as-done-logic.md",
        /*require.resolve*/(27724)
    ],
    "8133f5e8": [
        ()=>__webpack_require__.e(/* import() | 8133f5e8 */ "2433").then(__webpack_require__.t.bind(__webpack_require__, 77753, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/blog-tags-embudo-marketing-81a.json",
        /*require.resolve*/(77753)
    ],
    "814f3328": [
        ()=>__webpack_require__.e(/* import() | 814f3328 */ "1833").then(__webpack_require__.t.bind(__webpack_require__, 55513, 19)),
        "~blog/default/blog-post-list-prop-default.json",
        /*require.resolve*/(55513)
    ],
    "8405ba0f": [
        ()=>__webpack_require__.e(/* import() | 8405ba0f */ "7508").then(__webpack_require__.t.bind(__webpack_require__, 48516, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-progress-abd.json",
        /*require.resolve*/(48516)
    ],
    "8457b37d": [
        ()=>__webpack_require__.e(/* import() | 8457b37d */ "7892").then(__webpack_require__.t.bind(__webpack_require__, 77110, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/blog-tags-ventas-page-2-99d.json",
        /*require.resolve*/(77110)
    ],
    "8493f915": [
        ()=>__webpack_require__.e(/* import() | 8493f915 */ "1983").then(__webpack_require__.t.bind(__webpack_require__, 63607, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-importing-data-826.json",
        /*require.resolve*/(63607)
    ],
    "86c6c05b": [
        ()=>__webpack_require__.e(/* import() | 86c6c05b */ "5675").then(__webpack_require__.t.bind(__webpack_require__, 39653, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-account-settings-853.json",
        /*require.resolve*/(39653)
    ],
    "891c2643": [
        ()=>__webpack_require__.e(/* import() | 891c2643 */ "8022").then(__webpack_require__.bind(__webpack_require__, 38963)),
        "@site/docs/kb/pipeline-view/how-can-i-delete-a-deal-in-the-pipeline-view.md",
        /*require.resolve*/(38963)
    ],
    "8b8ca0e3": [
        ()=>__webpack_require__.e(/* import() | 8b8ca0e3 */ "890").then(__webpack_require__.bind(__webpack_require__, 92796)),
        "@site/docs/fintesk/changelog.md",
        /*require.resolve*/(92796)
    ],
    "8ba53785": [
        ()=>__webpack_require__.e(/* import() | 8ba53785 */ "8993").then(__webpack_require__.bind(__webpack_require__, 37288)),
        "@site/docs/kb/contacts/contacts-persons-and-organizations.md",
        /*require.resolve*/(37288)
    ],
    "8bea8cac": [
        ()=>__webpack_require__.e(/* import() | 8bea8cac */ "5469").then(__webpack_require__.bind(__webpack_require__, 22366)),
        "@site/docs/developers/core-api-concepts/core-api-concepts-pagination.md",
        /*require.resolve*/(22366)
    ],
    "8cd1d658": [
        ()=>__webpack_require__.e(/* import() | 8cd1d658 */ "5733").then(__webpack_require__.t.bind(__webpack_require__, 15683, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-importing-data-2f9.json",
        /*require.resolve*/(15683)
    ],
    "8ea09047": [
        ()=>__webpack_require__.e(/* import() | 8ea09047 */ "3666").then(__webpack_require__.t.bind(__webpack_require__, 40600, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/blog-page-2-433.json",
        /*require.resolve*/(40600)
    ],
    "908f8316": [
        ()=>__webpack_require__.e(/* import() | 908f8316 */ "73").then(__webpack_require__.bind(__webpack_require__, 39554)),
        "@site/blog/2025-04-08-software-crm-popular-en-el-mercado-estadounidense.md?truncated=true",
        /*require.resolve*/(39554)
    ],
    "92fdd400": [
        ()=>__webpack_require__.e(/* import() | 92fdd400 */ "3049").then(__webpack_require__.bind(__webpack_require__, 51959)),
        "@site/docs/kb/importing-data/how-can-i-format-dates-to-import-into-fintesk.md",
        /*require.resolve*/(51959)
    ],
    "934382b2": [
        ()=>__webpack_require__.e(/* import() | 934382b2 */ "2075").then(__webpack_require__.bind(__webpack_require__, 55534)),
        "@site/docs/kb/data-fields/what-types-of-custom-fields-are-there.md",
        /*require.resolve*/(55534)
    ],
    "9373caed": [
        ()=>__webpack_require__.e(/* import() | 9373caed */ "8791").then(__webpack_require__.bind(__webpack_require__, 29647)),
        "@site/blog/2025-04-06-crm-vs-excel-un-analisis-comparativo.md?truncated=true",
        /*require.resolve*/(29647)
    ],
    "93a29f76": [
        ()=>__webpack_require__.e(/* import() | 93a29f76 */ "9025").then(__webpack_require__.bind(__webpack_require__, 69745)),
        "@site/docs/kb/products/products.md",
        /*require.resolve*/(69745)
    ],
    "9685dfba": [
        ()=>__webpack_require__.e(/* import() | 9685dfba */ "7571").then(__webpack_require__.bind(__webpack_require__, 5844)),
        "@site/docs/kb/list-view/customizing-the-columns-in-the-list-view.md",
        /*require.resolve*/(5844)
    ],
    "98258112": [
        ()=>__webpack_require__.e(/* import() | 98258112 */ "6848").then(__webpack_require__.bind(__webpack_require__, 70694)),
        "@site/docs/kb/importing-data/updating-fintesk-data-with-a-spreadsheet.md",
        /*require.resolve*/(70694)
    ],
    "98c47b7a": [
        ()=>__webpack_require__.e(/* import() | 98c47b7a */ "1307").then(__webpack_require__.bind(__webpack_require__, 19581)),
        "@site/docs/kb/list-view/list-view.md",
        /*require.resolve*/(19581)
    ],
    "9997302d": [
        ()=>__webpack_require__.e(/* import() | 9997302d */ "6315").then(__webpack_require__.bind(__webpack_require__, 64405)),
        "@site/docs/kb/troubleshooting/how-do-i-open-my-browser-console.md",
        /*require.resolve*/(64405)
    ],
    "9a23c939": [
        ()=>__webpack_require__.e(/* import() | 9a23c939 */ "6117").then(__webpack_require__.bind(__webpack_require__, 72366)),
        "@site/docs/kb/products/can-i-have-one-product-in-different-price-variations.md",
        /*require.resolve*/(72366)
    ],
    "9c239c1c": [
        ()=>__webpack_require__.e(/* import() | 9c239c1c */ "9483").then(__webpack_require__.bind(__webpack_require__, 31016)),
        "@site/docs/billing/billing-information/what-happens-to-my-billing-when-i-change-my-fintesk-subscription-plan.md",
        /*require.resolve*/(31016)
    ],
    "9c343362": [
        ()=>__webpack_require__.e(/* import() | 9c343362 */ "3689").then(__webpack_require__.bind(__webpack_require__, 21601)),
        "@site/docs/kb/users-and-permissions/how-can-i-replace-users-in-my-fintesk-company-account.md",
        /*require.resolve*/(21601)
    ],
    "9ddd768b": [
        ()=>__webpack_require__.e(/* import() | 9ddd768b */ "3146").then(__webpack_require__.bind(__webpack_require__, 52382)),
        "@site/docs/kb/deals/how-can-i-restore-deleted-deals.md",
        /*require.resolve*/(52382)
    ],
    "9e2e739c": [
        ()=>__webpack_require__.e(/* import() | 9e2e739c */ "4709").then(__webpack_require__.t.bind(__webpack_require__, 99129, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-your-fintesk-subscription-plan-c5a.json",
        /*require.resolve*/(99129)
    ],
    "9e4087bc": [
        ()=>__webpack_require__.e(/* import() | 9e4087bc */ "9660").then(__webpack_require__.bind(__webpack_require__, 87243)),
        "@theme/BlogArchivePage",
        /*require.resolve*/(87243)
    ],
    "9ed7a22e": [
        ()=>__webpack_require__.e(/* import() | 9ed7a22e */ "4345").then(__webpack_require__.bind(__webpack_require__, 38725)),
        "@site/docs/kb/contacts/linking-persons-and-organizations.md",
        /*require.resolve*/(38725)
    ],
    "9f82584d": [
        ()=>__webpack_require__.e(/* import() | 9f82584d */ "2028").then(__webpack_require__.bind(__webpack_require__, 99259)),
        "@site/docs/developers/core-api-concepts/core-api-concepts-requests.md",
        /*require.resolve*/(99259)
    ],
    "a1391e31": [
        ()=>__webpack_require__.e(/* import() | a1391e31 */ "8736").then(__webpack_require__.bind(__webpack_require__, 81579)),
        "@site/docs/kb/contacts/how-can-i-add-related-persons-or-organizations-to-a-deal.md",
        /*require.resolve*/(81579)
    ],
    "a2a5017d": [
        ()=>__webpack_require__.e(/* import() | a2a5017d */ "4381").then(__webpack_require__.t.bind(__webpack_require__, 47645, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-contact-support-786.json",
        /*require.resolve*/(47645)
    ],
    "a4bb4cf1": [
        ()=>__webpack_require__.e(/* import() | a4bb4cf1 */ "2701").then(__webpack_require__.bind(__webpack_require__, 60564)),
        "@site/docs/kb/list-view/fintesk-system-ids.md",
        /*require.resolve*/(60564)
    ],
    "a55d7aae": [
        ()=>__webpack_require__.e(/* import() | a55d7aae */ "9837").then(__webpack_require__.t.bind(__webpack_require__, 76802, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-pipeline-view-598.json",
        /*require.resolve*/(76802)
    ],
    "a6aa9e1f": [
        ()=>Promise.all(/* import() | a6aa9e1f */ [__webpack_require__.e("4014"), __webpack_require__.e("4473"), __webpack_require__.e("6726"), __webpack_require__.e("7496")]).then(__webpack_require__.bind(__webpack_require__, 92152)),
        "@theme/BlogListPage",
        /*require.resolve*/(92152)
    ],
    "a7456010": [
        ()=>__webpack_require__.e(/* import() | a7456010 */ "3056").then(__webpack_require__.t.bind(__webpack_require__, 88552, 19)),
        "@generated/docusaurus-plugin-content-pages/default/__plugin.json",
        /*require.resolve*/(88552)
    ],
    "a7bd4aaa": [
        ()=>__webpack_require__.e(/* import() | a7bd4aaa */ "5575").then(__webpack_require__.bind(__webpack_require__, 60524)),
        "@theme/DocVersionRoot",
        /*require.resolve*/(60524)
    ],
    "a94703ab": [
        ()=>Promise.all(/* import() | a94703ab */ [__webpack_require__.e("4014"), __webpack_require__.e("6785")]).then(__webpack_require__.bind(__webpack_require__, 81399)),
        "@theme/DocRoot",
        /*require.resolve*/(81399)
    ],
    "aa775e8c": [
        ()=>__webpack_require__.e(/* import() | aa775e8c */ "9163").then(__webpack_require__.bind(__webpack_require__, 5782)),
        "@site/docs/kb/getting-started/interface-in-fintesk.md",
        /*require.resolve*/(5782)
    ],
    "aaa9ddfb": [
        ()=>__webpack_require__.e(/* import() | aaa9ddfb */ "2004").then(__webpack_require__.t.bind(__webpack_require__, 80560, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/blog-tags-leads-alta-calidad-779.json",
        /*require.resolve*/(80560)
    ],
    "aad23ca5": [
        ()=>__webpack_require__.e(/* import() | aad23ca5 */ "5804").then(__webpack_require__.t.bind(__webpack_require__, 43968, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-overview-d15.json",
        /*require.resolve*/(43968)
    ],
    "aba21aa0": [
        ()=>__webpack_require__.e(/* import() | aba21aa0 */ "3747").then(__webpack_require__.t.bind(__webpack_require__, 27093, 19)),
        "@generated/docusaurus-plugin-content-docs/default/__plugin.json",
        /*require.resolve*/(27093)
    ],
    "acecf23e": [
        ()=>__webpack_require__.e(/* import() | acecf23e */ "3220").then(__webpack_require__.t.bind(__webpack_require__, 1912, 19)),
        "~blog/default/blogMetadata-default.json",
        /*require.resolve*/(1912)
    ],
    "ae26eec0": [
        ()=>__webpack_require__.e(/* import() | ae26eec0 */ "7155").then(__webpack_require__.bind(__webpack_require__, 4800)),
        "@site/docs/kb/getting-started/search-finding-what-you-need.md",
        /*require.resolve*/(4800)
    ],
    "b11c7337": [
        ()=>__webpack_require__.e(/* import() | b11c7337 */ "3681").then(__webpack_require__.t.bind(__webpack_require__, 88105, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-detail-view-c14.json",
        /*require.resolve*/(88105)
    ],
    "b1371af7": [
        ()=>__webpack_require__.e(/* import() | b1371af7 */ "5042").then(__webpack_require__.t.bind(__webpack_require__, 97544, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-fintesk-api-ae9.json",
        /*require.resolve*/(97544)
    ],
    "b13ea042": [
        ()=>__webpack_require__.e(/* import() | b13ea042 */ "5590").then(__webpack_require__.bind(__webpack_require__, 12715)),
        "@site/docs/kb/importing-data/import-fields.md",
        /*require.resolve*/(12715)
    ],
    "b17dd5db": [
        ()=>__webpack_require__.e(/* import() | b17dd5db */ "7911").then(__webpack_require__.bind(__webpack_require__, 72191)),
        "@site/docs/kb/products/where-do-i-activate-or-deactivate-individual-products.md",
        /*require.resolve*/(72191)
    ],
    "b2d6b5e2": [
        ()=>__webpack_require__.e(/* import() | b2d6b5e2 */ "5440").then(__webpack_require__.bind(__webpack_require__, 9378)),
        "@site/blog/2025-04-06-las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads.md",
        /*require.resolve*/(9378)
    ],
    "b3361e2b": [
        ()=>__webpack_require__.e(/* import() | b3361e2b */ "140").then(__webpack_require__.bind(__webpack_require__, 70196)),
        "@site/blog/2025-04-06-indicadores-clave-de-rendimiento-kpi-para-medir-el-exito.md",
        /*require.resolve*/(70196)
    ],
    "b4465dc8": [
        ()=>__webpack_require__.e(/* import() | b4465dc8 */ "5154").then(__webpack_require__.t.bind(__webpack_require__, 30971, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-contacts-290.json",
        /*require.resolve*/(30971)
    ],
    "b8387ec1": [
        ()=>__webpack_require__.e(/* import() | b8387ec1 */ "3277").then(__webpack_require__.t.bind(__webpack_require__, 5210, 19)),
        "@generated/docusaurus-plugin-redoc/fintesk-v1/__plugin.json",
        /*require.resolve*/(5210)
    ],
    "b83a625c": [
        ()=>__webpack_require__.e(/* import() | b83a625c */ "3330").then(__webpack_require__.bind(__webpack_require__, 55935)),
        "@site/docs/kb/activities/how-can-i-link-my-activities-with-multiple-contact-persons.md",
        /*require.resolve*/(55935)
    ],
    "bb18f21e": [
        ()=>__webpack_require__.e(/* import() | bb18f21e */ "2727").then(__webpack_require__.bind(__webpack_require__, 58972)),
        "@site/docs/kb/products/can-i-add-extra-fields-to-the-add-new-product-modal.md",
        /*require.resolve*/(58972)
    ],
    "be6789a8": [
        ()=>__webpack_require__.e(/* import() | be6789a8 */ "4692").then(__webpack_require__.t.bind(__webpack_require__, 68941, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-manage-users-f38.json",
        /*require.resolve*/(68941)
    ],
    "bf0b52ac": [
        ()=>__webpack_require__.e(/* import() | bf0b52ac */ "8289").then(__webpack_require__.t.bind(__webpack_require__, 87427, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-list-view-reporting-9a4.json",
        /*require.resolve*/(87427)
    ],
    "c15d9823": [
        ()=>__webpack_require__.e(/* import() | c15d9823 */ "6431").then(__webpack_require__.t.bind(__webpack_require__, 29328, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/blog-bd9.json",
        /*require.resolve*/(29328)
    ],
    "c3467b10": [
        ()=>__webpack_require__.e(/* import() | c3467b10 */ "7840").then(__webpack_require__.bind(__webpack_require__, 58597)),
        "@site/docs/kb/contacts/contact-detail-view.md",
        /*require.resolve*/(58597)
    ],
    "c3f8fc91": [
        ()=>__webpack_require__.e(/* import() | c3f8fc91 */ "8901").then(__webpack_require__.t.bind(__webpack_require__, 59848, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/blog-tags-excel-986.json",
        /*require.resolve*/(59848)
    ],
    "c57612b1": [
        ()=>__webpack_require__.e(/* import() | c57612b1 */ "2335").then(__webpack_require__.t.bind(__webpack_require__, 90813, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/blog-tags-crm-2b1.json",
        /*require.resolve*/(90813)
    ],
    "c57f6fe4": [
        ()=>__webpack_require__.e(/* import() | c57f6fe4 */ "3980").then(__webpack_require__.bind(__webpack_require__, 6496)),
        "@site/docs/kb/users-and-permissions/users.md",
        /*require.resolve*/(6496)
    ],
    "c5c6524c": [
        ()=>__webpack_require__.e(/* import() | c5c6524c */ "8099").then(__webpack_require__.bind(__webpack_require__, 16283)),
        "@site/docs/kb/activities/creating-custom-activity-types.md",
        /*require.resolve*/(16283)
    ],
    "c610caec": [
        ()=>__webpack_require__.e(/* import() | c610caec */ "1316").then(__webpack_require__.t.bind(__webpack_require__, 6706, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-users-and-permissions-4b0.json",
        /*require.resolve*/(6706)
    ],
    "c665a9b3": [
        ()=>__webpack_require__.e(/* import() | c665a9b3 */ "8241").then(__webpack_require__.bind(__webpack_require__, 6653)),
        "@site/docs/kb/deals/editing-the-contact-linked-to-a-deal.md",
        /*require.resolve*/(6653)
    ],
    "ca74cf47": [
        ()=>__webpack_require__.e(/* import() | ca74cf47 */ "2019").then(__webpack_require__.bind(__webpack_require__, 17150)),
        "@site/docs/kb/getting-started/how-is-fintesk-data-organized.md",
        /*require.resolve*/(17150)
    ],
    "ccc49370": [
        ()=>Promise.all(/* import() | ccc49370 */ [__webpack_require__.e("4014"), __webpack_require__.e("4473"), __webpack_require__.e("6726"), __webpack_require__.e("6074")]).then(__webpack_require__.bind(__webpack_require__, 2063)),
        "@theme/BlogPostPage",
        /*require.resolve*/(2063)
    ],
    "ce193921": [
        ()=>__webpack_require__.e(/* import() | ce193921 */ "4291").then(__webpack_require__.bind(__webpack_require__, 52273)),
        "@site/docs/kb/importing-data/importing-mandatory-fields.md",
        /*require.resolve*/(52273)
    ],
    "cf1e8ef5": [
        ()=>__webpack_require__.e(/* import() | cf1e8ef5 */ "5349").then(__webpack_require__.bind(__webpack_require__, 82277)),
        "@site/blog/2025-04-06-comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel.md",
        /*require.resolve*/(82277)
    ],
    "d0f09388": [
        ()=>__webpack_require__.e(/* import() | d0f09388 */ "8338").then(__webpack_require__.bind(__webpack_require__, 71647)),
        "@site/docs/billing/your-fintesk-subscription-plan/how-can-i-switch-to-a-different-fintesk-plan-or-change-my-billing-frequency.md",
        /*require.resolve*/(71647)
    ],
    "d1afd025": [
        ()=>__webpack_require__.e(/* import() | d1afd025 */ "4313").then(__webpack_require__.t.bind(__webpack_require__, 50005, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-list-view-f90.json",
        /*require.resolve*/(50005)
    ],
    "d4adaca3": [
        ()=>__webpack_require__.e(/* import() | d4adaca3 */ "9217").then(__webpack_require__.bind(__webpack_require__, 49044)),
        "@site/blog/2025-04-08-como-elegir-el-crm-o-software-de-gestion-de-ventas.md",
        /*require.resolve*/(49044)
    ],
    "d557e752": [
        ()=>__webpack_require__.e(/* import() | d557e752 */ "7404").then(__webpack_require__.bind(__webpack_require__, 7113)),
        "@site/docs/kb/detail-view/detail-view.md",
        /*require.resolve*/(7113)
    ],
    "d5eb89e4": [
        ()=>__webpack_require__.e(/* import() | d5eb89e4 */ "7098").then(__webpack_require__.bind(__webpack_require__, 6404)),
        "@site/docs/kb/importing-data/importing-data-into-fintesk-with-spreadsheets.md",
        /*require.resolve*/(6404)
    ],
    "d5f456ae": [
        ()=>__webpack_require__.e(/* import() | d5f456ae */ "6680").then(__webpack_require__.bind(__webpack_require__, 52542)),
        "@site/docs/kb/activities/how-can-i-filter-my-activities-in-the-list-view.md",
        /*require.resolve*/(52542)
    ],
    "d8a6de9e": [
        ()=>__webpack_require__.e(/* import() | d8a6de9e */ "4434").then(__webpack_require__.bind(__webpack_require__, 16310)),
        "@site/blog/2025-04-06-las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads.md?truncated=true",
        /*require.resolve*/(16310)
    ],
    "dadb3d7b": [
        ()=>__webpack_require__.e(/* import() | dadb3d7b */ "7867").then(__webpack_require__.bind(__webpack_require__, 75238)),
        "@site/docs/kb/activities/activities.md",
        /*require.resolve*/(75238)
    ],
    "dc1d0bdb": [
        ()=>__webpack_require__.e(/* import() | dc1d0bdb */ "9904").then(__webpack_require__.t.bind(__webpack_require__, 46256, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-products-38d.json",
        /*require.resolve*/(46256)
    ],
    "dd8eb1f7": [
        ()=>__webpack_require__.e(/* import() | dd8eb1f7 */ "4421").then(__webpack_require__.bind(__webpack_require__, 94084)),
        "@site/docs/billing/billing-information/what-happens-to-my-billing-when-i-deactivate-a-user-in-fintesk.md",
        /*require.resolve*/(94084)
    ],
    "deef8cf1": [
        ()=>__webpack_require__.e(/* import() | deef8cf1 */ "1304").then(__webpack_require__.t.bind(__webpack_require__, 64586, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-developers-509.json",
        /*require.resolve*/(64586)
    ],
    "df203c0f": [
        ()=>Promise.all(/* import() | df203c0f */ [__webpack_require__.e("4014"), __webpack_require__.e("4380")]).then(__webpack_require__.bind(__webpack_require__, 32761)),
        "@theme/DocTagDocListPage",
        /*require.resolve*/(32761)
    ],
    "e0fede9b": [
        ()=>__webpack_require__.e(/* import() | e0fede9b */ "5528").then(__webpack_require__.bind(__webpack_require__, 73004)),
        "@site/blog/2025-04-06-las-desventajas-de-usar-excel-para-la-nutricion-y-el-seguimiento-de-leads.md",
        /*require.resolve*/(73004)
    ],
    "e426a42f": [
        ()=>__webpack_require__.e(/* import() | e426a42f */ "8060").then(__webpack_require__.bind(__webpack_require__, 82050)),
        "@site/docs/kb/users-and-permissions/updating-user-information.md",
        /*require.resolve*/(82050)
    ],
    "e4ebf854": [
        ()=>__webpack_require__.e(/* import() | e4ebf854 */ "3869").then(__webpack_require__.bind(__webpack_require__, 32798)),
        "@site/blog/2025-04-08-software-crm-popular-en-el-mercado-estadounidense.md",
        /*require.resolve*/(32798)
    ],
    "e502ecb5": [
        ()=>__webpack_require__.e(/* import() | e502ecb5 */ "6157").then(__webpack_require__.t.bind(__webpack_require__, 41692, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-users-and-permissions-d87.json",
        /*require.resolve*/(41692)
    ],
    "e518d369": [
        ()=>__webpack_require__.e(/* import() | e518d369 */ "2383").then(__webpack_require__.bind(__webpack_require__, 86032)),
        "@site/docs/kb/getting-started/fintesk-glossary.md",
        /*require.resolve*/(86032)
    ],
    "e5f74b05": [
        ()=>__webpack_require__.e(/* import() | e5f74b05 */ "7108").then(__webpack_require__.t.bind(__webpack_require__, 30364, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-getting-started-f42.json",
        /*require.resolve*/(30364)
    ],
    "eb185d82": [
        ()=>__webpack_require__.e(/* import() | eb185d82 */ "5985").then(__webpack_require__.bind(__webpack_require__, 3690)),
        "@site/docs/kb/getting-started/what-is-the-difference-between-a-user-and-a-seat.md",
        /*require.resolve*/(3690)
    ],
    "ebe4800a": [
        ()=>__webpack_require__.e(/* import() | ebe4800a */ "6133").then(__webpack_require__.bind(__webpack_require__, 47232)),
        "@site/docs/kb/pipeline-view/how-can-i-see-deals-in-a-different-pipeline.md",
        /*require.resolve*/(47232)
    ],
    "ebf7d2d7": [
        ()=>__webpack_require__.e(/* import() | ebf7d2d7 */ "4255").then(__webpack_require__.bind(__webpack_require__, 59581)),
        "@site/docs/kb/company-settings/how-can-i-enable-predefined-lost-reasons.md",
        /*require.resolve*/(59581)
    ],
    "ec4249a1": [
        ()=>__webpack_require__.e(/* import() | ec4249a1 */ "6151").then(__webpack_require__.bind(__webpack_require__, 99908)),
        "@site/docs/developers/core-api-concepts/core-api-concepts-date-format.md",
        /*require.resolve*/(99908)
    ],
    "ed379444": [
        ()=>__webpack_require__.e(/* import() | ed379444 */ "1506").then(__webpack_require__.bind(__webpack_require__, 29306)),
        "@site/docs/kb/list-view/how-can-i-edit-a-field-in-the-list-view.md",
        /*require.resolve*/(29306)
    ],
    "eda2513a": [
        ()=>__webpack_require__.e(/* import() | eda2513a */ "4784").then(__webpack_require__.bind(__webpack_require__, 93736)),
        "@site/docs/developers/overview/getting-started.md",
        /*require.resolve*/(93736)
    ],
    "ef5e0799": [
        ()=>__webpack_require__.e(/* import() | ef5e0799 */ "1910").then(__webpack_require__.bind(__webpack_require__, 34084)),
        "@site/docs/kb/deals/filtering-for-my-won-lost-or-deleted-deals.md",
        /*require.resolve*/(34084)
    ],
    "ef8b811a": [
        ()=>__webpack_require__.e(/* import() | ef8b811a */ "8416").then(__webpack_require__.t.bind(__webpack_require__, 56600, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/blog-authors-790.json",
        /*require.resolve*/(56600)
    ],
    "f0ad3fbb": [
        ()=>Promise.all(/* import() | f0ad3fbb */ [__webpack_require__.e("4014"), __webpack_require__.e("513"), __webpack_require__.e("8354")]).then(__webpack_require__.bind(__webpack_require__, 88418)),
        "@theme/ApiDoc",
        /*require.resolve*/(88418)
    ],
    "f0f9da59": [
        ()=>__webpack_require__.e(/* import() | f0f9da59 */ "3566").then(__webpack_require__.t.bind(__webpack_require__, 83336, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/blog-tags-tasa-de-conversion-844.json",
        /*require.resolve*/(83336)
    ],
    "f26f0e2c": [
        ()=>__webpack_require__.e(/* import() | f26f0e2c */ "1184").then(__webpack_require__.t.bind(__webpack_require__, 38419, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-your-fintesk-subscription-plan-abe.json",
        /*require.resolve*/(38419)
    ],
    "f2c1b3ae": [
        ()=>__webpack_require__.e(/* import() | f2c1b3ae */ "5789").then(__webpack_require__.t.bind(__webpack_require__, 70840, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/blog-tags-como-elegir-crm-9c0.json",
        /*require.resolve*/(70840)
    ],
    "f36639c8": [
        ()=>__webpack_require__.e(/* import() | f36639c8 */ "9476").then(__webpack_require__.bind(__webpack_require__, 78456)),
        "@site/docs/kb/users-and-permissions/who-is-the-admin-user-of-my-account.md",
        /*require.resolve*/(78456)
    ],
    "f3b52007": [
        ()=>__webpack_require__.e(/* import() | f3b52007 */ "6701").then(__webpack_require__.bind(__webpack_require__, 30907)),
        "@site/docs/kb/data-fields/how-can-i-add-data-fields-to-an-add-deal-contact-or-product-modal.md",
        /*require.resolve*/(30907)
    ],
    "f5d0524d": [
        ()=>__webpack_require__.e(/* import() | f5d0524d */ "5558").then(__webpack_require__.t.bind(__webpack_require__, 71183, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-features-db4.json",
        /*require.resolve*/(71183)
    ],
    "f81c1134": [
        ()=>__webpack_require__.e(/* import() | f81c1134 */ "6607").then(__webpack_require__.t.bind(__webpack_require__, 77735, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/blog-archive-f05.json",
        /*require.resolve*/(77735)
    ],
    "f985740b": [
        ()=>__webpack_require__.e(/* import() | f985740b */ "8203").then(__webpack_require__.bind(__webpack_require__, 49828)),
        "@site/docs/kb/pipelines/how-can-i-customize-my-pipeline-stages.md",
        /*require.resolve*/(49828)
    ],
    "faa1f05b": [
        ()=>__webpack_require__.e(/* import() | faa1f05b */ "8030").then(__webpack_require__.bind(__webpack_require__, 66775)),
        "@site/docs/kb/company-settings/lost-reasons.md",
        /*require.resolve*/(66775)
    ],
    "fad1eddb": [
        ()=>__webpack_require__.e(/* import() | fad1eddb */ "4861").then(__webpack_require__.t.bind(__webpack_require__, 33354, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/tags-contacts-cbf.json",
        /*require.resolve*/(33354)
    ],
    "fe54bfe0": [
        ()=>__webpack_require__.e(/* import() | fe54bfe0 */ "6661").then(__webpack_require__.t.bind(__webpack_require__, 32889, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/category-fintesk-api-e2d.json",
        /*require.resolve*/(32889)
    ],
    "feb46e2b": [
        ()=>__webpack_require__.e(/* import() | feb46e2b */ "1290").then(__webpack_require__.bind(__webpack_require__, 34926)),
        "@site/docs/billing/billing-information/what-happens-to-my-billing-when-i-change-my-billing-frequency.md",
        /*require.resolve*/(34926)
    ],
    "ff67488a": [
        ()=>__webpack_require__.e(/* import() | ff67488a */ "6856").then(__webpack_require__.bind(__webpack_require__, 19789)),
        "@site/docs/kb/company-settings/how-can-i-create-a-custom-currency.md",
        /*require.resolve*/(19789)
    ]
});

;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/theme-fallback/Loading/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ // Should we translate theme-fallback?
/* eslint-disable @docusaurus/no-untranslated-text */ 

function Loading({ error, retry, pastDelay }) {
    if (error) {
        return /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
            style: {
                textAlign: 'center',
                color: '#fff',
                backgroundColor: '#fa383e',
                borderColor: '#fa383e',
                borderStyle: 'solid',
                borderRadius: '0.25rem',
                borderWidth: '1px',
                boxSizing: 'border-box',
                display: 'block',
                padding: '1rem',
                flex: '0 0 50%',
                marginLeft: '25%',
                marginRight: '25%',
                marginTop: '5rem',
                maxWidth: '50%',
                width: '100%'
            },
            children: [
                /*#__PURE__*/ (0,jsx_runtime.jsx)("p", {
                    children: String(error)
                }),
                /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
                    children: /*#__PURE__*/ (0,jsx_runtime.jsx)("button", {
                        type: "button",
                        onClick: retry,
                        children: "Retry"
                    })
                })
            ]
        });
    }
    if (pastDelay) {
        return /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
            style: {
                display: 'flex',
                justifyContent: 'center',
                alignItems: 'center',
                height: '100vh'
            },
            children: /*#__PURE__*/ (0,jsx_runtime.jsx)("svg", {
                id: "loader",
                style: {
                    width: 128,
                    height: 110,
                    position: 'absolute',
                    top: 'calc(100vh - 64%)'
                },
                viewBox: "0 0 45 45",
                xmlns: "http://www.w3.org/2000/svg",
                stroke: "#61dafb",
                children: /*#__PURE__*/ (0,jsx_runtime.jsxs)("g", {
                    fill: "none",
                    fillRule: "evenodd",
                    transform: "translate(1 1)",
                    strokeWidth: "2",
                    children: [
                        /*#__PURE__*/ (0,jsx_runtime.jsxs)("circle", {
                            cx: "22",
                            cy: "22",
                            r: "6",
                            strokeOpacity: "0",
                            children: [
                                /*#__PURE__*/ (0,jsx_runtime.jsx)("animate", {
                                    attributeName: "r",
                                    begin: "1.5s",
                                    dur: "3s",
                                    values: "6;22",
                                    calcMode: "linear",
                                    repeatCount: "indefinite"
                                }),
                                /*#__PURE__*/ (0,jsx_runtime.jsx)("animate", {
                                    attributeName: "stroke-opacity",
                                    begin: "1.5s",
                                    dur: "3s",
                                    values: "1;0",
                                    calcMode: "linear",
                                    repeatCount: "indefinite"
                                }),
                                /*#__PURE__*/ (0,jsx_runtime.jsx)("animate", {
                                    attributeName: "stroke-width",
                                    begin: "1.5s",
                                    dur: "3s",
                                    values: "2;0",
                                    calcMode: "linear",
                                    repeatCount: "indefinite"
                                })
                            ]
                        }),
                        /*#__PURE__*/ (0,jsx_runtime.jsxs)("circle", {
                            cx: "22",
                            cy: "22",
                            r: "6",
                            strokeOpacity: "0",
                            children: [
                                /*#__PURE__*/ (0,jsx_runtime.jsx)("animate", {
                                    attributeName: "r",
                                    begin: "3s",
                                    dur: "3s",
                                    values: "6;22",
                                    calcMode: "linear",
                                    repeatCount: "indefinite"
                                }),
                                /*#__PURE__*/ (0,jsx_runtime.jsx)("animate", {
                                    attributeName: "stroke-opacity",
                                    begin: "3s",
                                    dur: "3s",
                                    values: "1;0",
                                    calcMode: "linear",
                                    repeatCount: "indefinite"
                                }),
                                /*#__PURE__*/ (0,jsx_runtime.jsx)("animate", {
                                    attributeName: "stroke-width",
                                    begin: "3s",
                                    dur: "3s",
                                    values: "2;0",
                                    calcMode: "linear",
                                    repeatCount: "indefinite"
                                })
                            ]
                        }),
                        /*#__PURE__*/ (0,jsx_runtime.jsx)("circle", {
                            cx: "22",
                            cy: "22",
                            r: "8",
                            children: /*#__PURE__*/ (0,jsx_runtime.jsx)("animate", {
                                attributeName: "r",
                                begin: "0s",
                                dur: "1.5s",
                                values: "6;1;2;3;4;5;6",
                                calcMode: "linear",
                                repeatCount: "indefinite"
                            })
                        })
                    ]
                })
            })
        });
    }
    return null;
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/flat.js
var flat = __webpack_require__(27665);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/routeContext.js
var client_routeContext = __webpack_require__(97574);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/exports/ComponentCreator.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 







function ComponentCreator(path, hash) {
    // 404 page
    if (path === '*') {
        return lib_default()({
            loading: Loading,
            loader: ()=>__webpack_require__.e(/* import() */ "5062").then(__webpack_require__.bind(__webpack_require__, 70629)),
            modules: [
                '@theme/NotFound'
            ],
            webpack: ()=>[
                    /*require.resolve*/(70629)
                ],
            render (loaded, props) {
                const NotFound = loaded.default;
                return /*#__PURE__*/ (0,jsx_runtime.jsx)(client_routeContext/* .RouteContextProvider */.W, {
                    // Do we want a better name than native-default?
                    value: {
                        plugin: {
                            name: 'native',
                            id: 'default'
                        }
                    },
                    children: /*#__PURE__*/ (0,jsx_runtime.jsx)(NotFound, {
                        ...props
                    })
                });
            }
        });
    }
    const chunkNames = routesChunkNames[`${path}-${hash}`];
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const loader = {};
    const modules = [];
    const optsWebpack = [];
    // A map from prop names to chunk names.
    // e.g. Suppose the plugin added this as route:
    //   { __comp: "...", prop: { foo: "..." }, items: ["...", "..."] }
    // It will become:
    //   { __comp: "...", "prop.foo": "...", "items.0": "...", "items.1": ... }
    // Loadable.Map will _map_ over `loader` and load each key.
    const flatChunkNames = (0,flat/* ["default"] */.A)(chunkNames);
    Object.entries(flatChunkNames).forEach(([keyPath, chunkName])=>{
        const chunkRegistry = registry[chunkName];
        if (chunkRegistry) {
            loader[keyPath] = chunkRegistry[0];
            modules.push(chunkRegistry[1]);
            optsWebpack.push(chunkRegistry[2]);
        }
    });
    return lib_default().Map({
        loading: Loading,
        loader,
        modules,
        webpack: ()=>optsWebpack,
        render (loaded, props) {
            // `loaded` will be a map from key path (as returned from the flattened
            // chunk names) to the modules loaded from the loaders. We now have to
            // restore the chunk names' previous shape from this flat record.
            // We do so by taking advantage of the existing `chunkNames` and replacing
            // each chunk name with its loaded module, so we don't create another
            // object from scratch.
            const loadedModules = JSON.parse(JSON.stringify(chunkNames));
            Object.entries(loaded).forEach(([keyPath, loadedModule])=>{
                // JSON modules are also loaded as `{ default: ... }` (`import()`
                // semantics) but we just want to pass the actual value to props.
                const chunk = loadedModule.default;
                // One loaded chunk can only be one of two things: a module (props) or a
                // component. Modules are always JSON, so `default` always exists. This
                // could only happen with a user-defined component.
                if (!chunk) {
                    throw new Error(`The page component at ${path} doesn't have a default export. This makes it impossible to render anything. Consider default-exporting a React component.`);
                }
                // A module can be a primitive, for example, if the user stored a string
                // as a prop. However, there seems to be a bug with swc-loader's CJS
                // logic, in that it would load a JSON module with content "foo" as
                // `{ default: "foo", 0: "f", 1: "o", 2: "o" }`. Just to be safe, we
                // first make sure that the chunk is non-primitive.
                if (typeof chunk === 'object' || typeof chunk === 'function') {
                    Object.keys(loadedModule).filter((k)=>k !== 'default').forEach((nonDefaultKey)=>{
                        chunk[nonDefaultKey] = loadedModule[nonDefaultKey];
                    });
                }
                // We now have this chunk prepared. Go down the key path and replace the
                // chunk name with the actual chunk.
                let val = loadedModules;
                const keyPaths = keyPath.split('.');
                keyPaths.slice(0, -1).forEach((k)=>{
                    val = val[k];
                });
                val[keyPaths[keyPaths.length - 1]] = chunk;
            });
            /* eslint-disable no-underscore-dangle */ const Component = loadedModules.__comp;
            delete loadedModules.__comp;
            const routeContext = loadedModules.__context;
            delete loadedModules.__context;
            const routeProps = loadedModules.__props;
            delete loadedModules.__props;
            /* eslint-enable no-underscore-dangle */ // Is there any way to put this RouteContextProvider upper in the tree?
            return /*#__PURE__*/ (0,jsx_runtime.jsx)(client_routeContext/* .RouteContextProvider */.W, {
                value: routeContext,
                children: /*#__PURE__*/ (0,jsx_runtime.jsx)(Component, {
                    ...loadedModules,
                    ...routeProps,
                    ...props
                })
            });
        }
    });
}

;// CONCATENATED MODULE: ./.docusaurus/routes.js


/* export default */ const routes = ([
    {
        path: '/blog',
        component: ComponentCreator('/blog', '895'),
        exact: true
    },
    {
        path: '/blog/alineando-marketing-y-ventas-para-una-conversion-optima',
        component: ComponentCreator('/blog/alineando-marketing-y-ventas-para-una-conversion-optima', '5fc'),
        exact: true
    },
    {
        path: '/blog/archive',
        component: ComponentCreator('/blog/archive', '182'),
        exact: true
    },
    {
        path: '/blog/authors',
        component: ComponentCreator('/blog/authors', '0b7'),
        exact: true
    },
    {
        path: '/blog/como-elegir-el-crm-o-software-de-gestion-de-ventas-adecuado-para-su-empresa',
        component: ComponentCreator('/blog/como-elegir-el-crm-o-software-de-gestion-de-ventas-adecuado-para-su-empresa', '027'),
        exact: true
    },
    {
        path: '/blog/comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel',
        component: ComponentCreator('/blog/comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel', 'b2c'),
        exact: true
    },
    {
        path: '/blog/crm-vs-excel-un-analisis-comparativo',
        component: ComponentCreator('/blog/crm-vs-excel-un-analisis-comparativo', '927'),
        exact: true
    },
    {
        path: '/blog/estrategias-para-atraer-leads-de-alta-calidad',
        component: ComponentCreator('/blog/estrategias-para-atraer-leads-de-alta-calidad', 'af7'),
        exact: true
    },
    {
        path: '/blog/estrategias-para-mejorar-las-tasas-de-conversion-en-cada-etapa-del-embudo',
        component: ComponentCreator('/blog/estrategias-para-mejorar-las-tasas-de-conversion-en-cada-etapa-del-embudo', 'c14'),
        exact: true
    },
    {
        path: '/blog/indicadores-clave-de-rendimiento-kpi-para-medir-el-exito',
        component: ComponentCreator('/blog/indicadores-clave-de-rendimiento-kpi-para-medir-el-exito', '8db'),
        exact: true
    },
    {
        path: '/blog/las-desventajas-de-usar-excel-para-la-nutricion-y-el-seguimiento-de-leads',
        component: ComponentCreator('/blog/las-desventajas-de-usar-excel-para-la-nutricion-y-el-seguimiento-de-leads', '345'),
        exact: true
    },
    {
        path: '/blog/las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads',
        component: ComponentCreator('/blog/las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads', '646'),
        exact: true
    },
    {
        path: '/blog/mejora-de-las-tasas-de-conversion-a-traves-del-embudo-de-marketing-y-ventas',
        component: ComponentCreator('/blog/mejora-de-las-tasas-de-conversion-a-traves-del-embudo-de-marketing-y-ventas', '42b'),
        exact: true
    },
    {
        path: '/blog/page/2',
        component: ComponentCreator('/blog/page/2', '698'),
        exact: true
    },
    {
        path: '/blog/software-crm-popular-en-el-mercado-estadounidense',
        component: ComponentCreator('/blog/software-crm-popular-en-el-mercado-estadounidense', '198'),
        exact: true
    },
    {
        path: '/blog/tags',
        component: ComponentCreator('/blog/tags', '287'),
        exact: true
    },
    {
        path: '/blog/tags/como-elegir-crm',
        component: ComponentCreator('/blog/tags/como-elegir-crm', 'be1'),
        exact: true
    },
    {
        path: '/blog/tags/crm',
        component: ComponentCreator('/blog/tags/crm', '6a1'),
        exact: true
    },
    {
        path: '/blog/tags/crm/page/2',
        component: ComponentCreator('/blog/tags/crm/page/2', 'a2a'),
        exact: true
    },
    {
        path: '/blog/tags/embudo-marketing',
        component: ComponentCreator('/blog/tags/embudo-marketing', '2cf'),
        exact: true
    },
    {
        path: '/blog/tags/embudo-ventas',
        component: ComponentCreator('/blog/tags/embudo-ventas', '188'),
        exact: true
    },
    {
        path: '/blog/tags/excel',
        component: ComponentCreator('/blog/tags/excel', 'c87'),
        exact: true
    },
    {
        path: '/blog/tags/excel-vs-crm',
        component: ComponentCreator('/blog/tags/excel-vs-crm', 'e20'),
        exact: true
    },
    {
        path: '/blog/tags/leads',
        component: ComponentCreator('/blog/tags/leads', '730'),
        exact: true
    },
    {
        path: '/blog/tags/leads-alta-calidad',
        component: ComponentCreator('/blog/tags/leads-alta-calidad', '3b7'),
        exact: true
    },
    {
        path: '/blog/tags/tasa-de-conversion',
        component: ComponentCreator('/blog/tags/tasa-de-conversion', 'c09'),
        exact: true
    },
    {
        path: '/blog/tags/ventas',
        component: ComponentCreator('/blog/tags/ventas', '155'),
        exact: true
    },
    {
        path: '/blog/tags/ventas/page/2',
        component: ComponentCreator('/blog/tags/ventas/page/2', '492'),
        exact: true
    },
    {
        path: '/docs/fintesk-v1',
        component: ComponentCreator('/docs/fintesk-v1', 'e50'),
        exact: true
    },
    {
        path: '/markdown-page',
        component: ComponentCreator('/markdown-page', '3d7'),
        exact: true
    },
    {
        path: '/',
        component: ComponentCreator('/', '452'),
        routes: [
            {
                path: '/',
                component: ComponentCreator('/', 'd2b'),
                routes: [
                    {
                        path: '/tags',
                        component: ComponentCreator('/tags', 'ce1'),
                        exact: true
                    },
                    {
                        path: '/tags/account-settings',
                        component: ComponentCreator('/tags/account-settings', 'da9'),
                        exact: true
                    },
                    {
                        path: '/tags/activities',
                        component: ComponentCreator('/tags/activities', '676'),
                        exact: true
                    },
                    {
                        path: '/tags/basic-concepts',
                        component: ComponentCreator('/tags/basic-concepts', 'ffb'),
                        exact: true
                    },
                    {
                        path: '/tags/billing',
                        component: ComponentCreator('/tags/billing', 'aa4'),
                        exact: true
                    },
                    {
                        path: '/tags/billing-information',
                        component: ComponentCreator('/tags/billing-information', 'c18'),
                        exact: true
                    },
                    {
                        path: '/tags/browser',
                        component: ComponentCreator('/tags/browser', 'a2b'),
                        exact: true
                    },
                    {
                        path: '/tags/changelog',
                        component: ComponentCreator('/tags/changelog', 'bc9'),
                        exact: true
                    },
                    {
                        path: '/tags/company-settings',
                        component: ComponentCreator('/tags/company-settings', '468'),
                        exact: true
                    },
                    {
                        path: '/tags/contact-support',
                        component: ComponentCreator('/tags/contact-support', '140'),
                        exact: true
                    },
                    {
                        path: '/tags/contacts',
                        component: ComponentCreator('/tags/contacts', '84d'),
                        exact: true
                    },
                    {
                        path: '/tags/core-api-concepts',
                        component: ComponentCreator('/tags/core-api-concepts', '02d'),
                        exact: true
                    },
                    {
                        path: '/tags/data-fields',
                        component: ComponentCreator('/tags/data-fields', '2f0'),
                        exact: true
                    },
                    {
                        path: '/tags/deals',
                        component: ComponentCreator('/tags/deals', 'f34'),
                        exact: true
                    },
                    {
                        path: '/tags/detail-view',
                        component: ComponentCreator('/tags/detail-view', 'cde'),
                        exact: true
                    },
                    {
                        path: '/tags/developers',
                        component: ComponentCreator('/tags/developers', '015'),
                        exact: true
                    },
                    {
                        path: '/tags/features',
                        component: ComponentCreator('/tags/features', '372'),
                        exact: true
                    },
                    {
                        path: '/tags/filtering',
                        component: ComponentCreator('/tags/filtering', '2f8'),
                        exact: true
                    },
                    {
                        path: '/tags/fintesk-api',
                        component: ComponentCreator('/tags/fintesk-api', '194'),
                        exact: true
                    },
                    {
                        path: '/tags/getting-started',
                        component: ComponentCreator('/tags/getting-started', '4b7'),
                        exact: true
                    },
                    {
                        path: '/tags/importing-data',
                        component: ComponentCreator('/tags/importing-data', '8b5'),
                        exact: true
                    },
                    {
                        path: '/tags/list-view',
                        component: ComponentCreator('/tags/list-view', '6e1'),
                        exact: true
                    },
                    {
                        path: '/tags/list-view-reporting',
                        component: ComponentCreator('/tags/list-view-reporting', 'dc4'),
                        exact: true
                    },
                    {
                        path: '/tags/manage-users',
                        component: ComponentCreator('/tags/manage-users', '13d'),
                        exact: true
                    },
                    {
                        path: '/tags/organizing-your-data',
                        component: ComponentCreator('/tags/organizing-your-data', 'a55'),
                        exact: true
                    },
                    {
                        path: '/tags/personal-settings',
                        component: ComponentCreator('/tags/personal-settings', '336'),
                        exact: true
                    },
                    {
                        path: '/tags/pipeline-view',
                        component: ComponentCreator('/tags/pipeline-view', 'f24'),
                        exact: true
                    },
                    {
                        path: '/tags/pipelines',
                        component: ComponentCreator('/tags/pipelines', 'd57'),
                        exact: true
                    },
                    {
                        path: '/tags/privacy',
                        component: ComponentCreator('/tags/privacy', '856'),
                        exact: true
                    },
                    {
                        path: '/tags/products',
                        component: ComponentCreator('/tags/products', 'de5'),
                        exact: true
                    },
                    {
                        path: '/tags/progress',
                        component: ComponentCreator('/tags/progress', '15d'),
                        exact: true
                    },
                    {
                        path: '/tags/tos',
                        component: ComponentCreator('/tags/tos', 'af1'),
                        exact: true
                    },
                    {
                        path: '/tags/troubleshooting',
                        component: ComponentCreator('/tags/troubleshooting', '220'),
                        exact: true
                    },
                    {
                        path: '/tags/troubleshooting-the-web-app',
                        component: ComponentCreator('/tags/troubleshooting-the-web-app', '1fa'),
                        exact: true
                    },
                    {
                        path: '/tags/users-and-permissions',
                        component: ComponentCreator('/tags/users-and-permissions', 'f54'),
                        exact: true
                    },
                    {
                        path: '/tags/your-fintesk-subscription-plan',
                        component: ComponentCreator('/tags/your-fintesk-subscription-plan', '107'),
                        exact: true
                    },
                    {
                        path: '/',
                        component: ComponentCreator('/', '961'),
                        routes: [
                            {
                                path: '/billing/billing-information/what-happens-to-my-billing-when-i-add-a-user-in-fintesk',
                                component: ComponentCreator('/billing/billing-information/what-happens-to-my-billing-when-i-add-a-user-in-fintesk', '9b3'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/billing/billing-information/what-happens-to-my-billing-when-i-change-my-billing-frequency',
                                component: ComponentCreator('/billing/billing-information/what-happens-to-my-billing-when-i-change-my-billing-frequency', '6bf'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/billing/billing-information/what-happens-to-my-billing-when-i-change-my-fintesk-subscription-plan',
                                component: ComponentCreator('/billing/billing-information/what-happens-to-my-billing-when-i-change-my-fintesk-subscription-plan', 'cd7'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/billing/billing-information/what-happens-to-my-billing-when-i-deactivate-a-user-in-fintesk',
                                component: ComponentCreator('/billing/billing-information/what-happens-to-my-billing-when-i-deactivate-a-user-in-fintesk', 'd15'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/billing/your-fintesk-subscription-plan/how-can-i-switch-to-a-different-fintesk-plan-or-change-my-billing-frequency',
                                component: ComponentCreator('/billing/your-fintesk-subscription-plan/how-can-i-switch-to-a-different-fintesk-plan-or-change-my-billing-frequency', '048'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/billing/your-fintesk-subscription-plan/what-features-do-the-fintesk-plans-have',
                                component: ComponentCreator('/billing/your-fintesk-subscription-plan/what-features-do-the-fintesk-plans-have', '91a'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/activities',
                                component: ComponentCreator('/category/activities', '43d'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/billing',
                                component: ComponentCreator('/category/billing', '825'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/billing-information',
                                component: ComponentCreator('/category/billing-information', '0b8'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/company-settings',
                                component: ComponentCreator('/category/company-settings', 'f20'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/contacts',
                                component: ComponentCreator('/category/contacts', 'c70'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/core-api-concepts',
                                component: ComponentCreator('/category/core-api-concepts', '98e'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/data-fields',
                                component: ComponentCreator('/category/data-fields', 'ba7'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/deals',
                                component: ComponentCreator('/category/deals', 'b06'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/detail-view',
                                component: ComponentCreator('/category/detail-view', 'c86'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/developers',
                                component: ComponentCreator('/category/developers', '620'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/exporting-data',
                                component: ComponentCreator('/category/exporting-data', '08c'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/filtering',
                                component: ComponentCreator('/category/filtering', '81c'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/fintesk-api',
                                component: ComponentCreator('/category/fintesk-api', 'ad6'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/getting-started',
                                component: ComponentCreator('/category/getting-started', '685'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/importing-data',
                                component: ComponentCreator('/category/importing-data', '5d9'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/knowledge-base',
                                component: ComponentCreator('/category/knowledge-base', '3a1'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/list-view',
                                component: ComponentCreator('/category/list-view', '7e9'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/overview',
                                component: ComponentCreator('/category/overview', '178'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/personal-settings',
                                component: ComponentCreator('/category/personal-settings', 'eca'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/pipeline-view',
                                component: ComponentCreator('/category/pipeline-view', '9c9'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/pipelines',
                                component: ComponentCreator('/category/pipelines', '4f5'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/privacy',
                                component: ComponentCreator('/category/privacy', '91c'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/products',
                                component: ComponentCreator('/category/products', 'f9b'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/terms-of-service',
                                component: ComponentCreator('/category/terms-of-service', '7fd'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/troubleshooting',
                                component: ComponentCreator('/category/troubleshooting', '366'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/users-and-permissions',
                                component: ComponentCreator('/category/users-and-permissions', 'b08'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/category/your-fintesk-subscription-plan',
                                component: ComponentCreator('/category/your-fintesk-subscription-plan', 'f39'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/developers/core-api-concepts/changes-to-the-api',
                                component: ComponentCreator('/developers/core-api-concepts/changes-to-the-api', '2ac'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/developers/core-api-concepts/core-api-concepts-about-fintesk-api',
                                component: ComponentCreator('/developers/core-api-concepts/core-api-concepts-about-fintesk-api', '995'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/developers/core-api-concepts/core-api-concepts-custom-fields',
                                component: ComponentCreator('/developers/core-api-concepts/core-api-concepts-custom-fields', '1ec'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/developers/core-api-concepts/core-api-concepts-date-format',
                                component: ComponentCreator('/developers/core-api-concepts/core-api-concepts-date-format', '2d6'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/developers/core-api-concepts/core-api-concepts-http-status-codes',
                                component: ComponentCreator('/developers/core-api-concepts/core-api-concepts-http-status-codes', '1f1'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/developers/core-api-concepts/core-api-concepts-pagination',
                                component: ComponentCreator('/developers/core-api-concepts/core-api-concepts-pagination', '656'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/developers/core-api-concepts/core-api-concepts-requests',
                                component: ComponentCreator('/developers/core-api-concepts/core-api-concepts-requests', 'cfe'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/developers/overview/getting-started',
                                component: ComponentCreator('/developers/overview/getting-started', '15e'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/fintesk/api-v1',
                                component: ComponentCreator('/fintesk/api-v1', '61c'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/fintesk/changelog',
                                component: ComponentCreator('/fintesk/changelog', 'a18'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/activities',
                                component: ComponentCreator('/kb/activities', 'de6'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/activities/activity-marked-as-done-logic',
                                component: ComponentCreator('/kb/activities/activity-marked-as-done-logic', 'ab2'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/activities/creating-custom-activity-types',
                                component: ComponentCreator('/kb/activities/creating-custom-activity-types', '333'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/activities/how-can-i-create-activities-in-bulk',
                                component: ComponentCreator('/kb/activities/how-can-i-create-activities-in-bulk', 'a0c'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/activities/how-can-i-filter-my-activities-in-the-list-view',
                                component: ComponentCreator('/kb/activities/how-can-i-filter-my-activities-in-the-list-view', '2e1'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/activities/how-can-i-link-my-activities-with-multiple-contact-persons',
                                component: ComponentCreator('/kb/activities/how-can-i-link-my-activities-with-multiple-contact-persons', '05a'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/activities/how-can-i-see-done-activities',
                                component: ComponentCreator('/kb/activities/how-can-i-see-done-activities', 'efd'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/company-settings/how-can-i-create-a-custom-currency',
                                component: ComponentCreator('/kb/company-settings/how-can-i-create-a-custom-currency', 'a90'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/company-settings/how-can-i-enable-predefined-lost-reasons',
                                component: ComponentCreator('/kb/company-settings/how-can-i-enable-predefined-lost-reasons', '142'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/company-settings/lost-reasons',
                                component: ComponentCreator('/kb/company-settings/lost-reasons', '9d2'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/contacts/contact-detail-view',
                                component: ComponentCreator('/kb/contacts/contact-detail-view', 'd37'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/contacts/contacts-persons-and-organizations',
                                component: ComponentCreator('/kb/contacts/contacts-persons-and-organizations', 'fa1'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/contacts/how-can-i-add-related-persons-or-organizations-to-a-deal',
                                component: ComponentCreator('/kb/contacts/how-can-i-add-related-persons-or-organizations-to-a-deal', 'bf7'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/contacts/linking-persons-and-organizations',
                                component: ComponentCreator('/kb/contacts/linking-persons-and-organizations', 'fe4'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/data-fields/custom-fields',
                                component: ComponentCreator('/kb/data-fields/custom-fields', '8f0'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/data-fields/data-fields-in-fintesk',
                                component: ComponentCreator('/kb/data-fields/data-fields-in-fintesk', 'fc7'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/data-fields/how-can-i-add-data-fields-to-an-add-deal-contact-or-product-modal',
                                component: ComponentCreator('/kb/data-fields/how-can-i-add-data-fields-to-an-add-deal-contact-or-product-modal', 'ce8'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/data-fields/what-types-of-custom-fields-are-there',
                                component: ComponentCreator('/kb/data-fields/what-types-of-custom-fields-are-there', '118'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/deals/adding-deals-in-bulk',
                                component: ComponentCreator('/kb/deals/adding-deals-in-bulk', '4b4'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/deals/deals-what-they-are-and-how-to-add-them',
                                component: ComponentCreator('/kb/deals/deals-what-they-are-and-how-to-add-them', '0a6'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/deals/editing-the-contact-linked-to-a-deal',
                                component: ComponentCreator('/kb/deals/editing-the-contact-linked-to-a-deal', '136'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/deals/filtering-for-my-won-lost-or-deleted-deals',
                                component: ComponentCreator('/kb/deals/filtering-for-my-won-lost-or-deleted-deals', '451'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/deals/how-can-i-move-a-deal-to-another-pipeline',
                                component: ComponentCreator('/kb/deals/how-can-i-move-a-deal-to-another-pipeline', '12a'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/deals/how-can-i-restore-deleted-deals',
                                component: ComponentCreator('/kb/deals/how-can-i-restore-deleted-deals', '5da'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/detail-view',
                                component: ComponentCreator('/kb/detail-view', '98e'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/detail-view/deal-detail-view',
                                component: ComponentCreator('/kb/detail-view/deal-detail-view', 'ae0'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/detail-view/how-can-i-add-notes-to-a-deal-or-contact',
                                component: ComponentCreator('/kb/detail-view/how-can-i-add-notes-to-a-deal-or-contact', '5c4'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/detail-view/updating-items-in-the-detail-view',
                                component: ComponentCreator('/kb/detail-view/updating-items-in-the-detail-view', 'aa5'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/exporting-data/exporting-data-from-fintesk',
                                component: ComponentCreator('/kb/exporting-data/exporting-data-from-fintesk', '977'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/filtering',
                                component: ComponentCreator('/kb/filtering', 'b55'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/filtering/filters-common-uses',
                                component: ComponentCreator('/kb/filtering/filters-common-uses', 'a73'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/getting-started/fintesk-glossary',
                                component: ComponentCreator('/kb/getting-started/fintesk-glossary', 'c98'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/getting-started/fintesk-user-vs-company-account',
                                component: ComponentCreator('/kb/getting-started/fintesk-user-vs-company-account', '07c'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/getting-started/how-can-i-delete-items-in-fintesk',
                                component: ComponentCreator('/kb/getting-started/how-can-i-delete-items-in-fintesk', '090'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/getting-started/interface-in-fintesk',
                                component: ComponentCreator('/kb/getting-started/interface-in-fintesk', '2d6'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/getting-started/organization-vs-company-account',
                                component: ComponentCreator('/kb/getting-started/organization-vs-company-account', '560'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/getting-started/search-finding-what-you-need',
                                component: ComponentCreator('/kb/getting-started/search-finding-what-you-need', 'a62'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/getting-started/what-is-the-difference-between-a-user-and-a-seat',
                                component: ComponentCreator('/kb/getting-started/what-is-the-difference-between-a-user-and-a-seat', 'e02'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/importing-data/changing-the-field-type-of-a-custom-field',
                                component: ComponentCreator('/kb/importing-data/changing-the-field-type-of-a-custom-field', 'f77'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/importing-data/how-can-i-format-dates-to-import-into-fintesk',
                                component: ComponentCreator('/kb/importing-data/how-can-i-format-dates-to-import-into-fintesk', '7fa'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/importing-data/import-fields',
                                component: ComponentCreator('/kb/importing-data/import-fields', 'a8f'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/importing-data/importing-advanced-mapping',
                                component: ComponentCreator('/kb/importing-data/importing-advanced-mapping', 'e34'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/importing-data/importing-data-into-fintesk-with-spreadsheets',
                                component: ComponentCreator('/kb/importing-data/importing-data-into-fintesk-with-spreadsheets', '9da'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/importing-data/importing-mandatory-fields',
                                component: ComponentCreator('/kb/importing-data/importing-mandatory-fields', '251'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/importing-data/importing-mapping-your-fields',
                                component: ComponentCreator('/kb/importing-data/importing-mapping-your-fields', 'fdf'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/importing-data/importing-sample-import-spreadsheets',
                                component: ComponentCreator('/kb/importing-data/importing-sample-import-spreadsheets', '889'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/importing-data/transferring-data-to-a-different-fintesk-company-account',
                                component: ComponentCreator('/kb/importing-data/transferring-data-to-a-different-fintesk-company-account', '42c'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/importing-data/updating-fintesk-data-with-a-spreadsheet',
                                component: ComponentCreator('/kb/importing-data/updating-fintesk-data-with-a-spreadsheet', 'c8f'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/importing-data/why-do-my-imported-currency-values-appear-as-0',
                                component: ComponentCreator('/kb/importing-data/why-do-my-imported-currency-values-appear-as-0', '560'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/list-view',
                                component: ComponentCreator('/kb/list-view', '55a'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/list-view/customizing-the-columns-in-the-list-view',
                                component: ComponentCreator('/kb/list-view/customizing-the-columns-in-the-list-view', '3bc'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/list-view/fintesk-system-ids',
                                component: ComponentCreator('/kb/list-view/fintesk-system-ids', 'ce6'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/list-view/how-can-i-add-or-remove-columns-in-the-list-view',
                                component: ComponentCreator('/kb/list-view/how-can-i-add-or-remove-columns-in-the-list-view', 'a2f'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/list-view/how-can-i-edit-a-field-in-the-list-view',
                                component: ComponentCreator('/kb/list-view/how-can-i-edit-a-field-in-the-list-view', '976'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/list-view/how-can-i-set-default-columns-for-all-my-users-in-the-list-view',
                                component: ComponentCreator('/kb/list-view/how-can-i-set-default-columns-for-all-my-users-in-the-list-view', '595'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/personal-settings/fintesk-settings',
                                component: ComponentCreator('/kb/personal-settings/fintesk-settings', '73d'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/personal-settings/how-can-i-change-or-reset-my-password',
                                component: ComponentCreator('/kb/personal-settings/how-can-i-change-or-reset-my-password', '8c8'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/personal-settings/how-can-i-free-up-space',
                                component: ComponentCreator('/kb/personal-settings/how-can-i-free-up-space', '16f'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/personal-settings/usage-limits-in-fintesk',
                                component: ComponentCreator('/kb/personal-settings/usage-limits-in-fintesk', '20f'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/pipeline-view',
                                component: ComponentCreator('/kb/pipeline-view', '2b5'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/pipeline-view/how-can-i-delete-a-deal-in-the-pipeline-view',
                                component: ComponentCreator('/kb/pipeline-view/how-can-i-delete-a-deal-in-the-pipeline-view', '1dc'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/pipeline-view/how-can-i-see-deals-in-a-different-pipeline',
                                component: ComponentCreator('/kb/pipeline-view/how-can-i-see-deals-in-a-different-pipeline', '363'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/pipeline-view/the-rotting-feature',
                                component: ComponentCreator('/kb/pipeline-view/the-rotting-feature', 'a1a'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/pipelines/how-can-i-add-a-stage-to-my-pipeline',
                                component: ComponentCreator('/kb/pipelines/how-can-i-add-a-stage-to-my-pipeline', '31f'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/pipelines/how-can-i-customize-my-pipeline-stages',
                                component: ComponentCreator('/kb/pipelines/how-can-i-customize-my-pipeline-stages', '33f'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/pipelines/how-can-i-have-multiple-pipelines',
                                component: ComponentCreator('/kb/pipelines/how-can-i-have-multiple-pipelines', '9e7'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/products',
                                component: ComponentCreator('/kb/products', '879'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/products/can-i-add-extra-fields-to-the-add-new-product-modal',
                                component: ComponentCreator('/kb/products/can-i-add-extra-fields-to-the-add-new-product-modal', '6f3'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/products/can-i-have-one-product-in-different-price-variations',
                                component: ComponentCreator('/kb/products/can-i-have-one-product-in-different-price-variations', 'afd'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/products/can-i-import-products-and-automatically-link-them-to-deals',
                                component: ComponentCreator('/kb/products/can-i-import-products-and-automatically-link-them-to-deals', 'fc0'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/products/how-can-i-link-products-to-a-deal',
                                component: ComponentCreator('/kb/products/how-can-i-link-products-to-a-deal', '94d'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/products/where-do-i-activate-or-deactivate-individual-products',
                                component: ComponentCreator('/kb/products/where-do-i-activate-or-deactivate-individual-products', 'c3c'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/troubleshooting/can-fintesk-be-used-offline',
                                component: ComponentCreator('/kb/troubleshooting/can-fintesk-be-used-offline', 'b3f'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/troubleshooting/how-can-i-take-a-screenshot',
                                component: ComponentCreator('/kb/troubleshooting/how-can-i-take-a-screenshot', '293'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/troubleshooting/how-do-i-clear-my-browser-s-cache-and-cookies',
                                component: ComponentCreator('/kb/troubleshooting/how-do-i-clear-my-browser-s-cache-and-cookies', '5ea'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/troubleshooting/how-do-i-open-my-browser-console',
                                component: ComponentCreator('/kb/troubleshooting/how-do-i-open-my-browser-console', '373'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/troubleshooting/troubleshooting-fintesk-web-app',
                                component: ComponentCreator('/kb/troubleshooting/troubleshooting-fintesk-web-app', '7b0'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/troubleshooting/which-browser-is-best-for-fintesk',
                                component: ComponentCreator('/kb/troubleshooting/which-browser-is-best-for-fintesk', 'c11'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/users-and-permissions/global-user-management',
                                component: ComponentCreator('/kb/users-and-permissions/global-user-management', 'f4e'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/users-and-permissions/how-can-i-add-a-user',
                                component: ComponentCreator('/kb/users-and-permissions/how-can-i-add-a-user', '094'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user',
                                component: ComponentCreator('/kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user', '799'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/users-and-permissions/how-can-i-replace-users-in-my-fintesk-company-account',
                                component: ComponentCreator('/kb/users-and-permissions/how-can-i-replace-users-in-my-fintesk-company-account', 'a93'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/users-and-permissions/updating-user-information',
                                component: ComponentCreator('/kb/users-and-permissions/updating-user-information', '98d'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/users-and-permissions/users',
                                component: ComponentCreator('/kb/users-and-permissions/users', 'de0'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/users-and-permissions/what-is-a-regular-user',
                                component: ComponentCreator('/kb/users-and-permissions/what-is-a-regular-user', '2b9'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/kb/users-and-permissions/who-is-the-admin-user-of-my-account',
                                component: ComponentCreator('/kb/users-and-permissions/who-is-the-admin-user-of-my-account', 'e9f'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/privacy',
                                component: ComponentCreator('/privacy', 'c0d'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/privacy/dpa',
                                component: ComponentCreator('/privacy/dpa', '02b'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/privacy/fintesk-data-sub-processors',
                                component: ComponentCreator('/privacy/fintesk-data-sub-processors', '78a'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/tos/terms-of-service',
                                component: ComponentCreator('/tos/terms-of-service', '421'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/',
                                component: ComponentCreator('/', 'f06'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        path: '*',
        component: ComponentCreator('*')
    }
]);


}),
91173: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  o: () => (Context),
  x: () => (BrowserContextProvider)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

// Encapsulate the logic to avoid React hydration problems
// See https://www.joshwcomeau.com/react/the-perils-of-rehydration/
// On first client-side render, we need to render exactly as the server rendered
// isBrowser is set to true only after a successful hydration
// Note, isBrowser is not part of useDocusaurusContext() for perf reasons
// Using useDocusaurusContext() (much more common need) should not trigger
// re-rendering after a successful hydration
const Context = /*#__PURE__*/ react__rspack_import_1.createContext(false);
function BrowserContextProvider({ children }) {
    const [isBrowser, setIsBrowser] = (0,react__rspack_import_1.useState)(false);
    (0,react__rspack_import_1.useEffect)(()=>{
        setIsBrowser(true);
    }, []);
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(Context.Provider, {
        value: isBrowser,
        children: children
    });
}


}),
10354: (function (__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) {
"use strict";

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(74848);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/react-dom/client.js
var client = __webpack_require__(5338);
// EXTERNAL MODULE: ./node_modules/react-helmet-async/lib/index.module.js
var index_module = __webpack_require__(80545);
// EXTERNAL MODULE: ./node_modules/react-router-dom/esm/react-router-dom.js
var react_router_dom = __webpack_require__(54625);
// EXTERNAL MODULE: ./.docusaurus/docusaurus.config.mjs
var docusaurus_config = __webpack_require__(4784);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/ExecutionEnvironment.js
var ExecutionEnvironment = __webpack_require__(91289);
;// CONCATENATED MODULE: ./.docusaurus/client-modules.js
/* export default */ const client_modules = ([
    __webpack_require__(77612),
    __webpack_require__(56464),
    __webpack_require__(32489),
    __webpack_require__(33678),
    __webpack_require__(16448),
    __webpack_require__(87570),
    __webpack_require__(70630),
    __webpack_require__(56814)
]);

// EXTERNAL MODULE: ./.docusaurus/routes.js + 3 modules
var routes = __webpack_require__(58460);
// EXTERNAL MODULE: ./node_modules/react-router/esm/react-router.js
var react_router = __webpack_require__(56347);
// EXTERNAL MODULE: ./node_modules/react-router-config/esm/react-router-config.js
var react_router_config = __webpack_require__(22831);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/theme-fallback/Root/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

// Wrapper at the very top of the app, that is applied constantly
// and does not depend on current route (unlike the layout)
//
// Gives the opportunity to add stateful providers on top of the app
// and these providers won't reset state when we navigate
//
// See https://github.com/facebook/docusaurus/issues/3919
function Root({ children }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
        children: children
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/titleFormatterUtils.js
var titleFormatterUtils = __webpack_require__(3899);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/ThemeProvider/TitleFormatter/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


const formatter = (params)=>{
    // Add your own title formatting logic here!
    return params.defaultFormatter(params);
};
function ThemeProviderTitleFormatter({ children }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(titleFormatterUtils/* .TitleFormatterProvider */.AL, {
        formatter: formatter,
        children: children
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/ThemeProvider/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


function ThemeProvider({ children }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(ThemeProviderTitleFormatter, {
        children: children
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/Head.js
var Head = __webpack_require__(53572);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/useDocusaurusContext.js
var useDocusaurusContext = __webpack_require__(10898);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/useBaseUrl.js
var useBaseUrl = __webpack_require__(66497);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/useThemeConfig.js
var useThemeConfig = __webpack_require__(61022);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/metadataUtils.js
var metadataUtils = __webpack_require__(34308);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/useAlternatePageUtils.js
var useAlternatePageUtils = __webpack_require__(5243);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/hooks/useKeyboardNavigation.js + 1 modules
var useKeyboardNavigation = __webpack_require__(23433);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/searchUtils.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ const DEFAULT_SEARCH_TAG = 'default'; //# sourceMappingURL=searchUtils.js.map

// EXTERNAL MODULE: ./node_modules/@docusaurus/utils-common/lib/index.js
var lib = __webpack_require__(5248);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/SearchMetadata/index.js
var SearchMetadata = __webpack_require__(54175);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/SiteMetadata/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 









// TODO move to SiteMetadataDefaults or theme-common ?
// Useful for i18n/SEO
// See https://developers.google.com/search/docs/advanced/crawling/localized-versions
// See https://github.com/facebook/docusaurus/issues/3317
function AlternateLangHeaders() {
    const { i18n: { currentLocale, defaultLocale, localeConfigs } } = (0,useDocusaurusContext/* ["default"] */.A)();
    const alternatePageUtils = (0,useAlternatePageUtils/* .useAlternatePageUtils */.o)();
    const currentHtmlLang = localeConfigs[currentLocale].htmlLang;
    // HTML lang is a BCP 47 tag, but the Open Graph protocol requires
    // using underscores instead of dashes.
    // See https://ogp.me/#optional
    // See https://en.wikipedia.org/wiki/IETF_language_tag)
    const bcp47ToOpenGraphLocale = (code)=>code.replace('-', '_');
    // Note: it is fine to use both "x-default" and "en" to target the same url
    // See https://www.searchviu.com/en/multiple-hreflang-tags-one-url/
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)(Head/* ["default"] */.A, {
        children: [
            Object.entries(localeConfigs).map(([locale, { htmlLang }])=>/*#__PURE__*/ (0,jsx_runtime.jsx)("link", {
                    rel: "alternate",
                    href: alternatePageUtils.createUrl({
                        locale,
                        fullyQualified: true
                    }),
                    hrefLang: htmlLang
                }, locale)),
            /*#__PURE__*/ (0,jsx_runtime.jsx)("link", {
                rel: "alternate",
                href: alternatePageUtils.createUrl({
                    locale: defaultLocale,
                    fullyQualified: true
                }),
                hrefLang: "x-default"
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)("meta", {
                property: "og:locale",
                content: bcp47ToOpenGraphLocale(currentHtmlLang)
            }),
            Object.values(localeConfigs).filter((config)=>currentHtmlLang !== config.htmlLang).map((config)=>/*#__PURE__*/ (0,jsx_runtime.jsx)("meta", {
                    property: "og:locale:alternate",
                    content: bcp47ToOpenGraphLocale(config.htmlLang)
                }, `meta-og-${config.htmlLang}`))
        ]
    });
}
// Default canonical url inferred from current page location pathname
function useDefaultCanonicalUrl() {
    const { siteConfig: { url: siteUrl, baseUrl, trailingSlash } } = (0,useDocusaurusContext/* ["default"] */.A)();
    // TODO using useLocation().pathname is not a super idea
    // See https://github.com/facebook/docusaurus/issues/9170
    const { pathname } = (0,react_router/* .useLocation */.zy)();
    const canonicalPathname = (0,lib.applyTrailingSlash)((0,useBaseUrl/* ["default"] */.Ay)(pathname), {
        trailingSlash,
        baseUrl
    });
    return siteUrl + canonicalPathname;
}
// TODO move to SiteMetadataDefaults or theme-common ?
function CanonicalUrlHeaders({ permalink }) {
    const { siteConfig: { url: siteUrl } } = (0,useDocusaurusContext/* ["default"] */.A)();
    const defaultCanonicalUrl = useDefaultCanonicalUrl();
    const canonicalUrl = permalink ? `${siteUrl}${permalink}` : defaultCanonicalUrl;
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)(Head/* ["default"] */.A, {
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsx)("meta", {
                property: "og:url",
                content: canonicalUrl
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)("link", {
                rel: "canonical",
                href: canonicalUrl
            })
        ]
    });
}
function SiteMetadata() {
    const { i18n: { currentLocale } } = (0,useDocusaurusContext/* ["default"] */.A)();
    // TODO maybe move these 2 themeConfig to siteConfig?
    // These seems useful for other themes as well
    const { metadata, image: defaultImage } = (0,useThemeConfig/* .useThemeConfig */.p)();
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsxs)(Head/* ["default"] */.A, {
                children: [
                    /*#__PURE__*/ (0,jsx_runtime.jsx)("meta", {
                        name: "twitter:card",
                        content: "summary_large_image"
                    }),
                    /*#__PURE__*/ (0,jsx_runtime.jsx)("body", {
                        className: useKeyboardNavigation/* .keyboardFocusedClassName */.w
                    })
                ]
            }),
            defaultImage && /*#__PURE__*/ (0,jsx_runtime.jsx)(metadataUtils/* .PageMetadata */.be, {
                image: defaultImage
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(CanonicalUrlHeaders, {}),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(AlternateLangHeaders, {}),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(SearchMetadata/* ["default"] */.A, {
                tag: DEFAULT_SEARCH_TAG,
                locale: currentLocale
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(Head/* ["default"] */.A, {
                children: metadata.map((metadatum, i)=>/*#__PURE__*/ (0,jsx_runtime.jsx)("meta", {
                        ...metadatum
                    }, i))
            })
        ]
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/normalizeLocation.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

// Memoize previously normalized pathnames.
const pathnames = new Map();
function normalizeLocation(location) {
    if (pathnames.has(location.pathname)) {
        return {
            ...location,
            pathname: pathnames.get(location.pathname)
        };
    }
    // If the location was registered with an `.html` extension, we don't strip it
    // away, or it will render to a 404 page.
    const matchedRoutes = (0,react_router_config/* .matchRoutes */.u)(routes/* ["default"] */.A, location.pathname);
    if (matchedRoutes.some(({ route })=>route.exact === true)) {
        pathnames.set(location.pathname, location.pathname);
        return location;
    }
    const pathname = location.pathname.trim().replace(/(?:\/index)?\.html$/, '') || '/';
    pathnames.set(location.pathname, pathname);
    return {
        ...location,
        pathname
    };
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/browserContext.js
var browserContext = __webpack_require__(91173);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/docusaurusContext.js + 3 modules
var docusaurusContext = __webpack_require__(93587);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/useIsomorphicLayoutEffect.js
var useIsomorphicLayoutEffect = __webpack_require__(99989);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/ClientLifecyclesDispatcher.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

function dispatchLifecycleAction(lifecycleAction, ...args) {
    const callbacks = client_modules.map((clientModule)=>{
        const lifecycleFunction = clientModule.default?.[lifecycleAction] ?? clientModule[lifecycleAction];
        return lifecycleFunction?.(...args);
    });
    return ()=>callbacks.forEach((cb)=>cb?.());
}
function scrollAfterNavigation({ location, previousLocation }) {
    if (!previousLocation) {
        return; // no-op: use native browser feature
    }
    const samePathname = location.pathname === previousLocation.pathname;
    const sameHash = location.hash === previousLocation.hash;
    const sameSearch = location.search === previousLocation.search;
    // Query-string changes: do not scroll to top/hash
    if (samePathname && sameHash && !sameSearch) {
        return;
    }
    const { hash } = location;
    if (!hash) {
        window.scrollTo(0, 0);
    } else {
        const id = decodeURIComponent(hash.substring(1));
        const element = document.getElementById(id);
        element?.scrollIntoView();
    }
}
function ClientLifecyclesDispatcher({ children, location, previousLocation }) {
    (0,useIsomorphicLayoutEffect/* ["default"] */.A)(()=>{
        if (previousLocation !== location) {
            scrollAfterNavigation({
                location,
                previousLocation
            });
            dispatchLifecycleAction('onRouteDidUpdate', {
                previousLocation,
                location
            });
        }
    }, [
        previousLocation,
        location
    ]);
    return children;
}
/* export default */ const client_ClientLifecyclesDispatcher = (ClientLifecyclesDispatcher);

;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/preload.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

/**
 * Helper function to make sure all async components for that particular route
 * is preloaded before rendering. This is especially useful to avoid loading
 * screens.
 *
 * @param pathname the route pathname, example: /docs/installation
 * @returns Promise object represents whether pathname has been preloaded
 */ function preload(pathname) {
    const matches = Array.from(new Set([
        pathname,
        decodeURI(pathname)
    ])).map((p)=>(0,react_router_config/* .matchRoutes */.u)(routes/* ["default"] */.A, p)).flat();
    return Promise.all(matches.map((match)=>match.route.component.preload?.()));
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/PendingNavigation.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 





class PendingNavigation extends react.Component {
    previousLocation;
    routeUpdateCleanupCb;
    constructor(props){
        super(props);
        // previousLocation doesn't affect rendering, hence not stored in state.
        this.previousLocation = null;
        this.routeUpdateCleanupCb = ExecutionEnvironment["default"].canUseDOM ? dispatchLifecycleAction('onRouteUpdate', {
            previousLocation: null,
            location: this.props.location
        }) : ()=>{};
        this.state = {
            nextRouteHasLoaded: true
        };
    }
    // Intercept location update and still show current route until next route
    // is done loading.
    shouldComponentUpdate(nextProps, nextState) {
        if (nextProps.location === this.props.location) {
            // `nextRouteHasLoaded` is false means there's a pending route transition.
            // Don't update until it's done.
            return nextState.nextRouteHasLoaded;
        }
        // props.location being different means the router is trying to navigate to
        // a new route. We will preload the new route.
        const nextLocation = nextProps.location;
        // Save the location first.
        this.previousLocation = this.props.location;
        this.setState({
            nextRouteHasLoaded: false
        });
        this.routeUpdateCleanupCb = dispatchLifecycleAction('onRouteUpdate', {
            previousLocation: this.previousLocation,
            location: nextLocation
        });
        // Load data while the old screen remains. Force preload instead of using
        // `window.docusaurus`, because we want to avoid loading screen even when
        // user is on saveData
        preload(nextLocation.pathname).then(()=>{
            this.routeUpdateCleanupCb();
            this.setState({
                nextRouteHasLoaded: true
            });
        }).catch((e)=>{
            console.warn(e);
            // If chunk loading failed, it could be because the path to a chunk
            // no longer exists due to a new deployment. Force refresh the page
            // instead of just not navigating.
            window.location.reload();
        });
        return false;
    }
    render() {
        const { children, location } = this.props;
        // Use a controlled <Route> to trick all descendants into rendering the old
        // location.
        return /*#__PURE__*/ (0,jsx_runtime.jsx)(client_ClientLifecyclesDispatcher, {
            previousLocation: this.previousLocation,
            location: location,
            children: /*#__PURE__*/ (0,jsx_runtime.jsx)(react_router/* .Route */.qh, {
                location: location,
                render: ()=>children
            })
        });
    }
}
/* export default */ const client_PendingNavigation = (PendingNavigation);

;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/BaseUrlIssueBanner/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 





// Double-security: critical CSS will hide the banner if CSS can load!

// __ prefix allows search crawlers (Algolia/DocSearch) to ignore anchors
// https://github.com/facebook/docusaurus/issues/8883#issuecomment-1516328368
const BannerContainerId = '__docusaurus-base-url-issue-banner-container';
const BannerId = '__docusaurus-base-url-issue-banner';
const SuggestionContainerId = '__docusaurus-base-url-issue-banner-suggestion-container';
// It is important to not use React to render this banner
// otherwise Google would index it, even if it's hidden with some critical CSS!
// See https://github.com/facebook/docusaurus/issues/4028
// - We can't SSR (or it would be indexed)
// - We can't CSR (as it means the baseurl is correct)
function createInlineHtmlBanner(baseUrl) {
    return `
<div id="${BannerId}" style="border: thick solid red; background-color: rgb(255, 230, 179); margin: 20px; padding: 20px; font-size: 20px;">
   <p style="font-weight: bold; font-size: 30px;">Your Docusaurus site did not load properly.</p>
   <p>A very common reason is a wrong site <a href="https://docusaurus.io/docs/docusaurus.config.js/#baseUrl" style="font-weight: bold;">baseUrl configuration</a>.</p>
   <p>Current configured baseUrl = <span style="font-weight: bold; color: red;">${baseUrl}</span> ${baseUrl === '/' ? ' (default value)' : ''}</p>
   <p>We suggest trying baseUrl = <span id="${SuggestionContainerId}" style="font-weight: bold; color: green;"></span></p>
</div>
`;
}
// Needs to work for older browsers!
function createInlineScript(baseUrl) {
    /* language=js */ return `
document.addEventListener('DOMContentLoaded', function maybeInsertBanner() {
  var shouldInsert = typeof window['docusaurus'] === 'undefined';
  shouldInsert && insertBanner();
});

function insertBanner() {
  var bannerContainer = document.createElement('div');
  bannerContainer.id = '${BannerContainerId}';
  var bannerHtml = ${JSON.stringify(createInlineHtmlBanner(baseUrl))// See https://redux.js.org/recipes/server-rendering/#security-considerations
    .replace(/</g, '\\\u003c')};
  bannerContainer.innerHTML = bannerHtml;
  document.body.prepend(bannerContainer);
  var suggestionContainer = document.getElementById('${SuggestionContainerId}');
  var actualHomePagePath = window.location.pathname;
  var suggestedBaseUrl = actualHomePagePath.substr(-1) === '/'
        ? actualHomePagePath
        : actualHomePagePath + '/';
  suggestionContainer.innerHTML = suggestedBaseUrl;
}
`;
}
function BaseUrlIssueBanner() {
    const { siteConfig: { baseUrl } } = (0,useDocusaurusContext/* ["default"] */.A)();
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
        children: !ExecutionEnvironment["default"].canUseDOM && // Safe to use `ExecutionEnvironment`, because `Head` is purely
        // side-effect and doesn't affect hydration
        /*#__PURE__*/ (0,jsx_runtime.jsx)(Head/* ["default"] */.A, {
            children: /*#__PURE__*/ (0,jsx_runtime.jsx)("script", {
                children: createInlineScript(baseUrl)
            })
        })
    });
}
/**
 * We want to help the users with a bad baseUrl configuration (very common
 * error). Help message is inlined, and hidden if JS or CSS is able to load.
 *
 * This component only inserts the base URL banner for the homepage, to avoid
 * polluting every statically rendered page.
 *
 * Note: it might create false positives (ie network failures): not a big deal
 *
 * @see https://github.com/facebook/docusaurus/pull/3621
 */ function MaybeBaseUrlIssueBanner() {
    const { siteConfig: { baseUrl, baseUrlIssueBanner } } = (0,useDocusaurusContext/* ["default"] */.A)();
    const { pathname } = (0,react_router/* .useLocation */.zy)();
    const isHomePage = pathname === baseUrl;
    const enabled = baseUrlIssueBanner && isHomePage;
    return enabled ? /*#__PURE__*/ (0,jsx_runtime.jsx)(BaseUrlIssueBanner, {}) : null;
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/SiteMetadataDefaults.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




function SiteMetadataDefaults() {
    const { siteConfig: { favicon, title, noIndex }, i18n: { currentLocale, localeConfigs } } = (0,useDocusaurusContext/* ["default"] */.A)();
    const faviconUrl = (0,useBaseUrl/* ["default"] */.Ay)(favicon);
    const { htmlLang, direction: htmlDir } = localeConfigs[currentLocale];
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)(Head/* ["default"] */.A, {
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsx)("html", {
                lang: htmlLang,
                dir: htmlDir
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)("title", {
                children: title
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)("meta", {
                property: "og:title",
                content: title
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)("meta", {
                name: "viewport",
                content: "width=device-width, initial-scale=1.0"
            }),
            noIndex && /*#__PURE__*/ (0,jsx_runtime.jsx)("meta", {
                name: "robots",
                content: "noindex, nofollow"
            }),
            favicon && /*#__PURE__*/ (0,jsx_runtime.jsx)("link", {
                rel: "icon",
                href: faviconUrl
            })
        ]
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/ErrorBoundary.js + 1 modules
var ErrorBoundary = __webpack_require__(11701);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/useIsBrowser.js
var useIsBrowser = __webpack_require__(19863);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/hasHydratedDataAttribute.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



// See https://github.com/facebook/docusaurus/pull/9256
// Docusaurus adds a <html data-has-hydrated="true"> after hydration
function HasHydratedDataAttribute() {
    const isBrowser = (0,useIsBrowser/* ["default"] */.A)();
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(Head/* ["default"] */.A, {
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)("html", {
            "data-has-hydrated": isBrowser
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/App.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 














// TODO, quick fix for CSS insertion order
// eslint-disable-next-line import/order


const routesElement = (0,react_router_config/* .renderRoutes */.v)(routes/* ["default"] */.A);
function AppNavigation() {
    const location = (0,react_router/* .useLocation */.zy)();
    const normalizedLocation = normalizeLocation(location);
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(client_PendingNavigation, {
        location: normalizedLocation,
        children: routesElement
    });
}
function App() {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(ErrorBoundary/* ["default"] */.A, {
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(docusaurusContext/* .DocusaurusContextProvider */.l, {
            children: /*#__PURE__*/ (0,jsx_runtime.jsxs)(browserContext/* .BrowserContextProvider */.x, {
                children: [
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(Root, {
                        children: /*#__PURE__*/ (0,jsx_runtime.jsxs)(ThemeProvider, {
                            children: [
                                /*#__PURE__*/ (0,jsx_runtime.jsx)(SiteMetadataDefaults, {}),
                                /*#__PURE__*/ (0,jsx_runtime.jsx)(SiteMetadata, {}),
                                /*#__PURE__*/ (0,jsx_runtime.jsx)(MaybeBaseUrlIssueBanner, {}),
                                /*#__PURE__*/ (0,jsx_runtime.jsx)(AppNavigation, {})
                            ]
                        })
                    }),
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(HasHydratedDataAttribute, {})
                ]
            })
        })
    });
}

// EXTERNAL MODULE: ./.docusaurus/routesChunkNames.json
var routesChunkNames = __webpack_require__(84054);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/prefetch.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ function supports(feature) {
    try {
        const fakeLink = document.createElement('link');
        return fakeLink.relList.supports(feature);
    } catch  {
        return false;
    }
}
function linkPrefetchStrategy(url) {
    return new Promise((resolve, reject)=>{
        if (typeof document === 'undefined') {
            reject();
            return;
        }
        const link = document.createElement('link');
        link.setAttribute('rel', 'prefetch');
        link.setAttribute('href', url);
        link.onload = ()=>resolve();
        link.onerror = ()=>reject();
        const parentElement = document.getElementsByTagName('head')[0] ?? document.getElementsByName('script')[0]?.parentNode;
        parentElement?.appendChild(link);
    });
}
function xhrPrefetchStrategy(url) {
    return new Promise((resolve, reject)=>{
        const req = new XMLHttpRequest();
        req.open('GET', url, true);
        req.withCredentials = true;
        req.onload = ()=>{
            if (req.status === 200) {
                resolve();
            } else {
                reject();
            }
        };
        req.send(null);
    });
}
const supportedPrefetchStrategy = supports('prefetch') ? linkPrefetchStrategy : xhrPrefetchStrategy;
function prefetch(url) {
    return supportedPrefetchStrategy(url).catch(()=>{}); // 404s are logged to the console anyway.
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/flat.js
var flat = __webpack_require__(27665);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/docusaurus.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 





const fetched = new Set();
const loaded = new Set();
// If user is on slow or constrained connection.
const isSlowConnection = ()=>navigator.connection?.effectiveType.includes('2g') || navigator.connection?.saveData;
const canPrefetch = (routePath)=>!isSlowConnection() && !loaded.has(routePath) && !fetched.has(routePath);
const canPreload = (routePath)=>!isSlowConnection() && !loaded.has(routePath);
const getChunkNamesToLoad = (path)=>Object.entries(routesChunkNames).filter(// Remove the last part containing the route hash
    // input: /blog/2018/12/14/Happy-First-Birthday-Slash-fe9
    // output: /blog/2018/12/14/Happy-First-Birthday-Slash
    ([routeNameWithHash])=>routeNameWithHash.replace(/-[^-]+$/, '') === path).flatMap(([, routeChunks])=>Object.values((0,flat/* ["default"] */.A)(routeChunks)));
const docusaurus_prefetch = (routePath)=>{
    if (!canPrefetch(routePath)) {
        return false;
    }
    fetched.add(routePath);
    // Find all webpack chunk names needed.
    const matches = (0,react_router_config/* .matchRoutes */.u)(routes/* ["default"] */.A, routePath);
    const chunkNamesNeeded = matches.flatMap((match)=>getChunkNamesToLoad(match.route.path));
    // Prefetch all webpack chunk assets file needed.
    return Promise.all(chunkNamesNeeded.map((chunkName)=>{
        // "__webpack_require__.gca" is injected by ChunkAssetPlugin. Pass it
        // the name of the chunk you want to load and it will return its URL.
        // eslint-disable-next-line camelcase
        const chunkAsset = __webpack_require__.gca(chunkName);
        // In some cases, webpack might decide to optimize further, leading to
        // the chunk assets being merged to another chunk. In this case, we can
        // safely filter it out and don't need to load it.
        if (chunkAsset && !chunkAsset.includes('undefined')) {
            return prefetch(chunkAsset);
        }
        return Promise.resolve();
    }));
};
const docusaurus_preload = (routePath)=>{
    if (!canPreload(routePath)) {
        return false;
    }
    loaded.add(routePath);
    return preload(routePath);
};
const docusaurus = {
    prefetch: docusaurus_prefetch,
    preload: docusaurus_preload
};
// This object is directly mounted onto window, better freeze it
/* export default */ const client_docusaurus = (Object.freeze(docusaurus));

;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/clientEntry.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 









function Router({ children }) {
    return docusaurus_config/* ["default"].future.experimental_router */.A.future.experimental_router === 'hash' ? /*#__PURE__*/ (0,jsx_runtime.jsx)(react_router_dom/* .HashRouter */.I9, {
        children: children
    }) : /*#__PURE__*/ (0,jsx_runtime.jsx)(react_router_dom/* .BrowserRouter */.Kd, {
        children: children
    });
}
const hydrate = Boolean(true);
// Client-side render (e.g: running in browser) to become single-page
// application (SPA).
if (ExecutionEnvironment["default"].canUseDOM) {
    window.docusaurus = client_docusaurus;
    const container = document.getElementById('__docusaurus');
    const app = /*#__PURE__*/ (0,jsx_runtime.jsx)(index_module/* .HelmetProvider */.vd, {
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(Router, {
            children: /*#__PURE__*/ (0,jsx_runtime.jsx)(App, {})
        })
    });
    const onRecoverableError = (error, errorInfo)=>{
        console.error('Docusaurus React Root onRecoverableError:', error, errorInfo);
    };
    const renderApp = ()=>{
        if (window.docusaurusRoot) {
            window.docusaurusRoot.render(app);
            return;
        }
        if (hydrate) {
            window.docusaurusRoot = client.hydrateRoot(container, app, {
                onRecoverableError
            });
        } else {
            const root = client.createRoot(container, {
                onRecoverableError
            });
            root.render(app);
            window.docusaurusRoot = root;
        }
    };
    preload(window.location.pathname).then(()=>{
        (0,react.startTransition)(renderApp);
    });
    // Webpack Hot Module Replacement API
    if (false) {}
}


}),
93587: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  l: () => (/* binding */ DocusaurusContextProvider),
  o: () => (/* binding */ Context)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(74848);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./.docusaurus/docusaurus.config.mjs
var docusaurus_config = __webpack_require__(4784);
;// CONCATENATED MODULE: ./.docusaurus/globalData.json
var globalData_namespaceObject = JSON.parse('{"docusaurus-plugin-content-docs":{"default":{"path":"/","versions":[{"name":"current","label":"Next","isLast":true,"path":"/","mainDocId":"kb/getting-started/how-is-fintesk-data-organized","docs":[{"id":"billing/billing-information/what-happens-to-my-billing-when-i-add-a-user-in-fintesk","path":"/billing/billing-information/what-happens-to-my-billing-when-i-add-a-user-in-fintesk","sidebar":"tutorialSidebar"},{"id":"billing/billing-information/what-happens-to-my-billing-when-i-change-my-billing-frequency","path":"/billing/billing-information/what-happens-to-my-billing-when-i-change-my-billing-frequency","sidebar":"tutorialSidebar"},{"id":"billing/billing-information/what-happens-to-my-billing-when-i-change-my-fintesk-subscription-plan","path":"/billing/billing-information/what-happens-to-my-billing-when-i-change-my-fintesk-subscription-plan","sidebar":"tutorialSidebar"},{"id":"billing/billing-information/what-happens-to-my-billing-when-i-deactivate-a-user-in-fintesk","path":"/billing/billing-information/what-happens-to-my-billing-when-i-deactivate-a-user-in-fintesk","sidebar":"tutorialSidebar"},{"id":"billing/your-fintesk-subscription-plan/how-can-i-switch-to-a-different-fintesk-plan-or-change-my-billing-frequency","path":"/billing/your-fintesk-subscription-plan/how-can-i-switch-to-a-different-fintesk-plan-or-change-my-billing-frequency","sidebar":"tutorialSidebar"},{"id":"billing/your-fintesk-subscription-plan/what-features-do-the-fintesk-plans-have","path":"/billing/your-fintesk-subscription-plan/what-features-do-the-fintesk-plans-have","sidebar":"tutorialSidebar"},{"id":"developers/core-api-concepts/changes-to-the-api","path":"/developers/core-api-concepts/changes-to-the-api","sidebar":"tutorialSidebar"},{"id":"developers/core-api-concepts/core-api-concepts-about-fintesk-api","path":"/developers/core-api-concepts/core-api-concepts-about-fintesk-api","sidebar":"tutorialSidebar"},{"id":"developers/core-api-concepts/core-api-concepts-custom-fields","path":"/developers/core-api-concepts/core-api-concepts-custom-fields","sidebar":"tutorialSidebar"},{"id":"developers/core-api-concepts/core-api-concepts-date-format","path":"/developers/core-api-concepts/core-api-concepts-date-format","sidebar":"tutorialSidebar"},{"id":"developers/core-api-concepts/core-api-concepts-http-status-codes","path":"/developers/core-api-concepts/core-api-concepts-http-status-codes","sidebar":"tutorialSidebar"},{"id":"developers/core-api-concepts/core-api-concepts-pagination","path":"/developers/core-api-concepts/core-api-concepts-pagination","sidebar":"tutorialSidebar"},{"id":"developers/core-api-concepts/core-api-concepts-requests","path":"/developers/core-api-concepts/core-api-concepts-requests","sidebar":"tutorialSidebar"},{"id":"developers/overview/getting-started","path":"/developers/overview/getting-started","sidebar":"tutorialSidebar"},{"id":"fintesk/api-v1","path":"/fintesk/api-v1","sidebar":"tutorialSidebar"},{"id":"fintesk/changelog","path":"/fintesk/changelog","sidebar":"tutorialSidebar"},{"id":"kb/activities/activities","path":"/kb/activities/","sidebar":"tutorialSidebar"},{"id":"kb/activities/activity-marked-as-done-logic","path":"/kb/activities/activity-marked-as-done-logic","sidebar":"tutorialSidebar"},{"id":"kb/activities/creating-custom-activity-types","path":"/kb/activities/creating-custom-activity-types","sidebar":"tutorialSidebar"},{"id":"kb/activities/how-can-i-create-activities-in-bulk","path":"/kb/activities/how-can-i-create-activities-in-bulk","sidebar":"tutorialSidebar"},{"id":"kb/activities/how-can-i-filter-my-activities-in-the-list-view","path":"/kb/activities/how-can-i-filter-my-activities-in-the-list-view","sidebar":"tutorialSidebar"},{"id":"kb/activities/how-can-i-link-my-activities-with-multiple-contact-persons","path":"/kb/activities/how-can-i-link-my-activities-with-multiple-contact-persons","sidebar":"tutorialSidebar"},{"id":"kb/activities/how-can-i-see-done-activities","path":"/kb/activities/how-can-i-see-done-activities","sidebar":"tutorialSidebar"},{"id":"kb/company-settings/how-can-i-create-a-custom-currency","path":"/kb/company-settings/how-can-i-create-a-custom-currency","sidebar":"tutorialSidebar"},{"id":"kb/company-settings/how-can-i-enable-predefined-lost-reasons","path":"/kb/company-settings/how-can-i-enable-predefined-lost-reasons","sidebar":"tutorialSidebar"},{"id":"kb/company-settings/lost-reasons","path":"/kb/company-settings/lost-reasons","sidebar":"tutorialSidebar"},{"id":"kb/contacts/contact-detail-view","path":"/kb/contacts/contact-detail-view","sidebar":"tutorialSidebar"},{"id":"kb/contacts/contacts-persons-and-organizations","path":"/kb/contacts/contacts-persons-and-organizations","sidebar":"tutorialSidebar"},{"id":"kb/contacts/how-can-i-add-related-persons-or-organizations-to-a-deal","path":"/kb/contacts/how-can-i-add-related-persons-or-organizations-to-a-deal","sidebar":"tutorialSidebar"},{"id":"kb/contacts/linking-persons-and-organizations","path":"/kb/contacts/linking-persons-and-organizations","sidebar":"tutorialSidebar"},{"id":"kb/data-fields/custom-fields","path":"/kb/data-fields/custom-fields","sidebar":"tutorialSidebar"},{"id":"kb/data-fields/data-fields-in-fintesk","path":"/kb/data-fields/data-fields-in-fintesk","sidebar":"tutorialSidebar"},{"id":"kb/data-fields/how-can-i-add-data-fields-to-an-add-deal-contact-or-product-modal","path":"/kb/data-fields/how-can-i-add-data-fields-to-an-add-deal-contact-or-product-modal","sidebar":"tutorialSidebar"},{"id":"kb/data-fields/what-types-of-custom-fields-are-there","path":"/kb/data-fields/what-types-of-custom-fields-are-there","sidebar":"tutorialSidebar"},{"id":"kb/deals/adding-deals-in-bulk","path":"/kb/deals/adding-deals-in-bulk","sidebar":"tutorialSidebar"},{"id":"kb/deals/deals-what-they-are-and-how-to-add-them","path":"/kb/deals/deals-what-they-are-and-how-to-add-them","sidebar":"tutorialSidebar"},{"id":"kb/deals/editing-the-contact-linked-to-a-deal","path":"/kb/deals/editing-the-contact-linked-to-a-deal","sidebar":"tutorialSidebar"},{"id":"kb/deals/filtering-for-my-won-lost-or-deleted-deals","path":"/kb/deals/filtering-for-my-won-lost-or-deleted-deals","sidebar":"tutorialSidebar"},{"id":"kb/deals/how-can-i-move-a-deal-to-another-pipeline","path":"/kb/deals/how-can-i-move-a-deal-to-another-pipeline","sidebar":"tutorialSidebar"},{"id":"kb/deals/how-can-i-restore-deleted-deals","path":"/kb/deals/how-can-i-restore-deleted-deals","sidebar":"tutorialSidebar"},{"id":"kb/detail-view/deal-detail-view","path":"/kb/detail-view/deal-detail-view","sidebar":"tutorialSidebar"},{"id":"kb/detail-view/detail-view","path":"/kb/detail-view/","sidebar":"tutorialSidebar"},{"id":"kb/detail-view/how-can-i-add-notes-to-a-deal-or-contact","path":"/kb/detail-view/how-can-i-add-notes-to-a-deal-or-contact","sidebar":"tutorialSidebar"},{"id":"kb/detail-view/updating-items-in-the-detail-view","path":"/kb/detail-view/updating-items-in-the-detail-view","sidebar":"tutorialSidebar"},{"id":"kb/exporting-data/exporting-data-from-fintesk","path":"/kb/exporting-data/exporting-data-from-fintesk","sidebar":"tutorialSidebar"},{"id":"kb/filtering/filtering","path":"/kb/filtering/","sidebar":"tutorialSidebar"},{"id":"kb/filtering/filters-common-uses","path":"/kb/filtering/filters-common-uses","sidebar":"tutorialSidebar"},{"id":"kb/getting-started/fintesk-glossary","path":"/kb/getting-started/fintesk-glossary","sidebar":"tutorialSidebar"},{"id":"kb/getting-started/fintesk-user-vs-company-account","path":"/kb/getting-started/fintesk-user-vs-company-account","sidebar":"tutorialSidebar"},{"id":"kb/getting-started/how-can-i-delete-items-in-fintesk","path":"/kb/getting-started/how-can-i-delete-items-in-fintesk","sidebar":"tutorialSidebar"},{"id":"kb/getting-started/how-is-fintesk-data-organized","path":"/","sidebar":"tutorialSidebar"},{"id":"kb/getting-started/interface-in-fintesk","path":"/kb/getting-started/interface-in-fintesk","sidebar":"tutorialSidebar"},{"id":"kb/getting-started/organization-vs-company-account","path":"/kb/getting-started/organization-vs-company-account","sidebar":"tutorialSidebar"},{"id":"kb/getting-started/search-finding-what-you-need","path":"/kb/getting-started/search-finding-what-you-need","sidebar":"tutorialSidebar"},{"id":"kb/getting-started/what-is-the-difference-between-a-user-and-a-seat","path":"/kb/getting-started/what-is-the-difference-between-a-user-and-a-seat","sidebar":"tutorialSidebar"},{"id":"kb/importing-data/changing-the-field-type-of-a-custom-field","path":"/kb/importing-data/changing-the-field-type-of-a-custom-field","sidebar":"tutorialSidebar"},{"id":"kb/importing-data/how-can-i-format-dates-to-import-into-fintesk","path":"/kb/importing-data/how-can-i-format-dates-to-import-into-fintesk","sidebar":"tutorialSidebar"},{"id":"kb/importing-data/import-fields","path":"/kb/importing-data/import-fields","sidebar":"tutorialSidebar"},{"id":"kb/importing-data/importing-advanced-mapping","path":"/kb/importing-data/importing-advanced-mapping","sidebar":"tutorialSidebar"},{"id":"kb/importing-data/importing-data-into-fintesk-with-spreadsheets","path":"/kb/importing-data/importing-data-into-fintesk-with-spreadsheets","sidebar":"tutorialSidebar"},{"id":"kb/importing-data/importing-mandatory-fields","path":"/kb/importing-data/importing-mandatory-fields","sidebar":"tutorialSidebar"},{"id":"kb/importing-data/importing-mapping-your-fields","path":"/kb/importing-data/importing-mapping-your-fields","sidebar":"tutorialSidebar"},{"id":"kb/importing-data/importing-sample-import-spreadsheets","path":"/kb/importing-data/importing-sample-import-spreadsheets","sidebar":"tutorialSidebar"},{"id":"kb/importing-data/transferring-data-to-a-different-fintesk-company-account","path":"/kb/importing-data/transferring-data-to-a-different-fintesk-company-account","sidebar":"tutorialSidebar"},{"id":"kb/importing-data/updating-fintesk-data-with-a-spreadsheet","path":"/kb/importing-data/updating-fintesk-data-with-a-spreadsheet","sidebar":"tutorialSidebar"},{"id":"kb/importing-data/why-do-my-imported-currency-values-appear-as-0","path":"/kb/importing-data/why-do-my-imported-currency-values-appear-as-0","sidebar":"tutorialSidebar"},{"id":"kb/list-view/customizing-the-columns-in-the-list-view","path":"/kb/list-view/customizing-the-columns-in-the-list-view","sidebar":"tutorialSidebar"},{"id":"kb/list-view/fintesk-system-ids","path":"/kb/list-view/fintesk-system-ids","sidebar":"tutorialSidebar"},{"id":"kb/list-view/how-can-i-add-or-remove-columns-in-the-list-view","path":"/kb/list-view/how-can-i-add-or-remove-columns-in-the-list-view","sidebar":"tutorialSidebar"},{"id":"kb/list-view/how-can-i-edit-a-field-in-the-list-view","path":"/kb/list-view/how-can-i-edit-a-field-in-the-list-view","sidebar":"tutorialSidebar"},{"id":"kb/list-view/how-can-i-set-default-columns-for-all-my-users-in-the-list-view","path":"/kb/list-view/how-can-i-set-default-columns-for-all-my-users-in-the-list-view","sidebar":"tutorialSidebar"},{"id":"kb/list-view/list-view","path":"/kb/list-view/","sidebar":"tutorialSidebar"},{"id":"kb/personal-settings/fintesk-settings","path":"/kb/personal-settings/fintesk-settings","sidebar":"tutorialSidebar"},{"id":"kb/personal-settings/how-can-i-change-or-reset-my-password","path":"/kb/personal-settings/how-can-i-change-or-reset-my-password","sidebar":"tutorialSidebar"},{"id":"kb/personal-settings/how-can-i-free-up-space","path":"/kb/personal-settings/how-can-i-free-up-space","sidebar":"tutorialSidebar"},{"id":"kb/personal-settings/usage-limits-in-fintesk","path":"/kb/personal-settings/usage-limits-in-fintesk","sidebar":"tutorialSidebar"},{"id":"kb/pipeline-view/how-can-i-delete-a-deal-in-the-pipeline-view","path":"/kb/pipeline-view/how-can-i-delete-a-deal-in-the-pipeline-view","sidebar":"tutorialSidebar"},{"id":"kb/pipeline-view/how-can-i-see-deals-in-a-different-pipeline","path":"/kb/pipeline-view/how-can-i-see-deals-in-a-different-pipeline","sidebar":"tutorialSidebar"},{"id":"kb/pipeline-view/pipeline-view","path":"/kb/pipeline-view/","sidebar":"tutorialSidebar"},{"id":"kb/pipeline-view/the-rotting-feature","path":"/kb/pipeline-view/the-rotting-feature","sidebar":"tutorialSidebar"},{"id":"kb/pipelines/how-can-i-add-a-stage-to-my-pipeline","path":"/kb/pipelines/how-can-i-add-a-stage-to-my-pipeline","sidebar":"tutorialSidebar"},{"id":"kb/pipelines/how-can-i-customize-my-pipeline-stages","path":"/kb/pipelines/how-can-i-customize-my-pipeline-stages","sidebar":"tutorialSidebar"},{"id":"kb/pipelines/how-can-i-have-multiple-pipelines","path":"/kb/pipelines/how-can-i-have-multiple-pipelines","sidebar":"tutorialSidebar"},{"id":"kb/products/can-i-add-extra-fields-to-the-add-new-product-modal","path":"/kb/products/can-i-add-extra-fields-to-the-add-new-product-modal","sidebar":"tutorialSidebar"},{"id":"kb/products/can-i-have-one-product-in-different-price-variations","path":"/kb/products/can-i-have-one-product-in-different-price-variations","sidebar":"tutorialSidebar"},{"id":"kb/products/can-i-import-products-and-automatically-link-them-to-deals","path":"/kb/products/can-i-import-products-and-automatically-link-them-to-deals","sidebar":"tutorialSidebar"},{"id":"kb/products/how-can-i-link-products-to-a-deal","path":"/kb/products/how-can-i-link-products-to-a-deal","sidebar":"tutorialSidebar"},{"id":"kb/products/products","path":"/kb/products/","sidebar":"tutorialSidebar"},{"id":"kb/products/where-do-i-activate-or-deactivate-individual-products","path":"/kb/products/where-do-i-activate-or-deactivate-individual-products","sidebar":"tutorialSidebar"},{"id":"kb/troubleshooting/can-fintesk-be-used-offline","path":"/kb/troubleshooting/can-fintesk-be-used-offline","sidebar":"tutorialSidebar"},{"id":"kb/troubleshooting/how-can-i-take-a-screenshot","path":"/kb/troubleshooting/how-can-i-take-a-screenshot","sidebar":"tutorialSidebar"},{"id":"kb/troubleshooting/how-do-i-clear-my-browser-s-cache-and-cookies","path":"/kb/troubleshooting/how-do-i-clear-my-browser-s-cache-and-cookies","sidebar":"tutorialSidebar"},{"id":"kb/troubleshooting/how-do-i-open-my-browser-console","path":"/kb/troubleshooting/how-do-i-open-my-browser-console","sidebar":"tutorialSidebar"},{"id":"kb/troubleshooting/troubleshooting-fintesk-web-app","path":"/kb/troubleshooting/troubleshooting-fintesk-web-app","sidebar":"tutorialSidebar"},{"id":"kb/troubleshooting/which-browser-is-best-for-fintesk","path":"/kb/troubleshooting/which-browser-is-best-for-fintesk","sidebar":"tutorialSidebar"},{"id":"kb/users-and-permissions/global-user-management","path":"/kb/users-and-permissions/global-user-management","sidebar":"tutorialSidebar"},{"id":"kb/users-and-permissions/how-can-i-add-a-user","path":"/kb/users-and-permissions/how-can-i-add-a-user","sidebar":"tutorialSidebar"},{"id":"kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user","path":"/kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user","sidebar":"tutorialSidebar"},{"id":"kb/users-and-permissions/how-can-i-replace-users-in-my-fintesk-company-account","path":"/kb/users-and-permissions/how-can-i-replace-users-in-my-fintesk-company-account","sidebar":"tutorialSidebar"},{"id":"kb/users-and-permissions/updating-user-information","path":"/kb/users-and-permissions/updating-user-information","sidebar":"tutorialSidebar"},{"id":"kb/users-and-permissions/users","path":"/kb/users-and-permissions/users","sidebar":"tutorialSidebar"},{"id":"kb/users-and-permissions/what-is-a-regular-user","path":"/kb/users-and-permissions/what-is-a-regular-user","sidebar":"tutorialSidebar"},{"id":"kb/users-and-permissions/who-is-the-admin-user-of-my-account","path":"/kb/users-and-permissions/who-is-the-admin-user-of-my-account","sidebar":"tutorialSidebar"},{"id":"privacy/dpa","path":"/privacy/dpa","sidebar":"tutorialSidebar"},{"id":"privacy/fintesk-data-sub-processors","path":"/privacy/fintesk-data-sub-processors","sidebar":"tutorialSidebar"},{"id":"privacy/privacy-notice","path":"/privacy/","sidebar":"tutorialSidebar"},{"id":"tos/terms-of-service","path":"/tos/terms-of-service","sidebar":"tutorialSidebar"},{"id":"/category/developers","path":"/category/developers","sidebar":"tutorialSidebar"},{"id":"/category/overview","path":"/category/overview","sidebar":"tutorialSidebar"},{"id":"/category/core-api-concepts","path":"/category/core-api-concepts","sidebar":"tutorialSidebar"},{"id":"/category/knowledge-base","path":"/category/knowledge-base","sidebar":"tutorialSidebar"},{"id":"/category/getting-started","path":"/category/getting-started","sidebar":"tutorialSidebar"},{"id":"/category/exporting-data","path":"/category/exporting-data","sidebar":"tutorialSidebar"},{"id":"/category/importing-data","path":"/category/importing-data","sidebar":"tutorialSidebar"},{"id":"/category/pipeline-view","path":"/category/pipeline-view","sidebar":"tutorialSidebar"},{"id":"/category/pipelines","path":"/category/pipelines","sidebar":"tutorialSidebar"},{"id":"/category/data-fields","path":"/category/data-fields","sidebar":"tutorialSidebar"},{"id":"/category/list-view","path":"/category/list-view","sidebar":"tutorialSidebar"},{"id":"/category/detail-view","path":"/category/detail-view","sidebar":"tutorialSidebar"},{"id":"/category/filtering","path":"/category/filtering","sidebar":"tutorialSidebar"},{"id":"/category/deals","path":"/category/deals","sidebar":"tutorialSidebar"},{"id":"/category/activities","path":"/category/activities","sidebar":"tutorialSidebar"},{"id":"/category/contacts","path":"/category/contacts","sidebar":"tutorialSidebar"},{"id":"/category/users-and-permissions","path":"/category/users-and-permissions","sidebar":"tutorialSidebar"},{"id":"/category/personal-settings","path":"/category/personal-settings","sidebar":"tutorialSidebar"},{"id":"/category/company-settings","path":"/category/company-settings","sidebar":"tutorialSidebar"},{"id":"/category/products","path":"/category/products","sidebar":"tutorialSidebar"},{"id":"/category/troubleshooting","path":"/category/troubleshooting","sidebar":"tutorialSidebar"},{"id":"/category/billing","path":"/category/billing","sidebar":"tutorialSidebar"},{"id":"/category/billing-information","path":"/category/billing-information","sidebar":"tutorialSidebar"},{"id":"/category/your-fintesk-subscription-plan","path":"/category/your-fintesk-subscription-plan","sidebar":"tutorialSidebar"},{"id":"/category/fintesk-api","path":"/category/fintesk-api","sidebar":"tutorialSidebar"},{"id":"/category/privacy","path":"/category/privacy","sidebar":"tutorialSidebar"},{"id":"/category/terms-of-service","path":"/category/terms-of-service","sidebar":"tutorialSidebar"}],"draftIds":["billing/billing-information/billing-troubleshooting","billing/billing-information/booster-packs","billing/billing-information/how-can-i-cancel-my-trial","billing/billing-information/how-can-i-remove-seats","billing/billing-information/how-can-i-update-my-billing-details-in-fintesk","billing/billing-information/paying-for-fintesk-with-a-local-credit-card-brazil","billing/billing-information/what-are-the-accepted-payment-methods-for-fintesk","billing/billing-information/who-can-access-the-billing-information-on-my-fintesk-account","billing/billing-information/why-do-i-need-to-re-submit-my-payment-details-for-subscription-renewals-india","billing/invoices/adding-my-vat-abn-or-gst-number-to-fintesk","billing/invoices/can-i-change-the-information-in-a-past-fintesk-invoice","billing/invoices/how-can-i-view-my-past-fintesk-invoices","billing/invoices/how-is-the-subscription-cost-of-the-fintesk-invoice-calculated","billing/invoices/how-will-i-receive-my-fintesk-invoice","billing/invoices/what-happens-when-my-fintesk-invoice-is-marked-as-past-due","billing/invoices/what-vendor-name-will-appear-on-my-bank-statements","billing/invoices/when-does-my-fintesk-invoice-need-to-be-paid-by","billing/invoices/why-do-my-invoices-say-taxamo","billing/your-fintesk-subscription-plan/can-i-delete-my-account","billing/your-fintesk-subscription-plan/how-can-i-cancel-my-paid-fintesk-account","billing/your-fintesk-subscription-plan/how-can-i-regain-access-to-a-closed-fintesk-account","billing/your-fintesk-subscription-plan/how-can-i-start-paying-for-fintesk","billing/your-fintesk-subscription-plan/how-does-pricing-work-in-fintesk","billing/your-fintesk-subscription-plan/what-happens-when-my-fintesk-trial-expires","billing/your-fintesk-subscription-plan/what-is-the-difference-between-annual-and-monthly-billing-in-fintesk","developers/coming-soon/enabling-api-for-company-users","developers/coming-soon/how-to-find-the-api-token","developers/coming-soon/how-to-get-the-company-domain","developers/coming-soon/merging-deals-via-api","developers/coming-soon/merging-two-organizations-via-api","developers/coming-soon/merging-two-persons-via-api","developers/coming-soon/working-with-labels","developers/core-api-concepts/core-api-concepts-authentication","developers/core-api-concepts/core-api-concepts-rate-limiting","developers/faq/faq","developers/overview/run-fintesk-api-in-postman-or-insomnia","developers/quick-start/add-custom-field-via-api","developers/quick-start/adding-a-filter-via-fintesk-api","developers/quick-start/adding-a-product","developers/quick-start/adding-an-activity-via-api","developers/quick-start/adding-an-organization-via-api","developers/quick-start/assigning-a-deal-to-a-certain-user-via-api","developers/quick-start/create-a-deal-via-api","developers/quick-start/delete-custom-field-via-api","developers/quick-start/get-deals-via-api","developers/quick-start/getting-details-of-a-deal-via-api","developers/quick-start/pagination-via-api","developers/quick-start/update-a-deal-via-api","developers/quick-start/update-custom-field-via-api","developers/quick-start/updating-a-person-via-api","integrations/contact-sync/contact-sync","integrations/zapier/zapier-add-new-facebook-ad-leads-as-people-in-fintesk","integrations/zapier/zapier-creating-a-new-person-in-fintesk-from-a-business-card-in-contacts","integrations/zapier/zapier-creating-fintesk-deals-with-gravity-forms","integrations/zapier/zapier-creating-fintesk-deals-with-wufoo-forms","integrations/zapier/zapier-creating-new-fintesk-deals-from-hubspot-form-submissions","integrations/zapier/zapier-creating-new-fintesk-deals-from-mailchimp-subscribers","integrations/zapier/zapier-get-notifications-in-slack-of-new-fintesk-deals","integrations/zapier/zapier-saving-new-rows-in-google-sheets-as-new-deals-in-fintesk","integrations/zapier/zapier-saving-unbounce-leads-to-fintesk","integrations/zapier/zapier-sending-fintesk-contacts-to-mailchimp-subscribers","integrations/zapier/zapier-sending-gmail-emails-about-new-fintesk-deals","integrations/zapier/zapier-what-it-is-and-how-to-use-it","kb/activities/activity-invites","kb/activities/activity-priority-labels","kb/activities/activity-reminder-emails","kb/activities/add-activities-bulk","kb/activities/calendar-sync","kb/activities/calendar-view","kb/activities/can-i-see-activities-that-have-been-assigned-to-me","kb/activities/contextual-view-activities","kb/activities/how-can-i-disable-the-follow-up-activity-pop-up","kb/activities/how-can-i-propose-my-general-availability-in-the-scheduler","kb/activities/how-can-i-propose-my-specific-times-in-the-scheduler","kb/activities/meeting-scheduler","kb/activities/private-activities","kb/activities/recurring-activities","kb/activities/troubleshooting-the-calendar-sync-feature","kb/activities/what-is-the-red-number-on-the-activities-icon","kb/activities/why-are-emails-that-i-ve-sent-or-received-not-in-the-list-view-of-activities","kb/company-settings/changing-a-company-domain-in-fintesk","kb/company-settings/changing-the-name-of-a-company-account","kb/company-settings/restore-data","kb/contacts/address-fields-in-fitnesk","kb/contacts/contact-labels","kb/contacts/contacts-timeline","kb/contacts/how-can-i-add-a-picture-to-a-person-in-fintesk","kb/contacts/how-can-i-create-a-person-contact-from-a-received-email","kb/contacts/related-organizations","kb/contacts/show-on-map-feature","kb/contacts/timeline-view-follow-up-frequency","kb/data-fields/important-fields","kb/data-fields/required-fields","kb/deals/can-multiple-contact-be-linked-to-a-deal","kb/deals/deal-labels","kb/deals/deals-waitlist","kb/deals/how-can-i-duplicate-a-deal","kb/deals/how-can-i-edit-the-deal-created-date","kb/deals/how-can-i-edit-the-deal-won-time","kb/deals/how-can-i-see-the-total-value-of-my-deals-by-stage-or-pipeline","kb/deals/leads-vs-deals","kb/detail-view/detail-view-sidebar","kb/detail-view/followers","kb/detail-view/how-can-i-upload-a-file-to-a-deal-or-a-contact","kb/detail-view/mentions-and-comments","kb/detail-view/participants","kb/detail-view/why-are-emails-not-showing-on-the-detail-view-of-the-deal","kb/detail-view/why-are-items-shown-as-hidden","kb/detail-view/why-are-my-emails-not-showing-on-the-organization-page-but-appear-in-the-deal-and-contact","kb/email/archiving-and-deleting-emails","kb/email/can-i-sync-multiple-email-addresses-to-one-user","kb/email/changing-your-email-sender-name","kb/email/email-labels","kb/email/email-privacy-and-sharing-emails-in-fintesk","kb/email/email-provider-vs-email-client","kb/email/email-signature","kb/email/email-sync","kb/email/email-templates","kb/email/email-tracking-reports-with-gmail-and-apple","kb/email/email-tracking","kb/email/group-emailing","kb/email/how-are-emails-threaded-in-fintesk","kb/email/how-are-first-and-last-names-separated-in-email-template-merge-fields","kb/email/how-can-i-find-my-imap-and-smtp-information","kb/email/how-can-i-re-authenticate-my-email-sync-in-fintesk","kb/email/how-can-i-set-up-the-email-sync","kb/email/how-to-link-emails-to-fintesk-items","kb/email/schedule-emails-for-later","kb/email/syncing-multiple-email-accounts","kb/email/which-provider-is-best-for-email-sync","kb/email/why-are-my-emails-appearing-with-different-formatting-when-i-send-them","kb/features/how-does-the-merge-duplicates-feature-identify-duplicates-in-fintesk","kb/features/merge-duplicates","kb/features/recurring-revenue-feature","kb/filtering/how-can-i-favorite-filters","kb/filtering/viewing-and-reassigning-the-data-of-a-deactivated-user","kb/forecast-view/how-are-deals-ordered-in-the-forecast-view","kb/forecast-view/how-can-i-see-projected-revenue-for-my-colleagues-deals-in-the-forecast-view","kb/forecast-view/how-can-i-sort-deals-in-the-forecast-view-by-a-different-timeframe","kb/forecast-view/the-forecast-view-revenue-projection","kb/forecast-view/what-is-the-green-bar-on-the-bottom-of-a-deal-in-the-forecast-view","kb/forecast-view/why-can-t-i-see-won-deals-in-the-forecast-view","kb/importing-data/how-to-avoid-duplicates-during-an-import","kb/importing-data/importing-deals-into-a-specific-stage-or-pipeline","kb/importing-data/importing-errors-and-skip-files","kb/importing-data/importing-followers-and-participants","kb/leads/adding-leads-to-my-leads-inbox","kb/leads/converting-deals-to-leads","kb/leads/emails-in-leads","kb/leads/how-can-i-import-leads","kb/leads/how-can-i-update-my-leads","kb/leads/lead-labels","kb/leads/leads-inbox","kb/leads/messaging-inbox","kb/leads/troubleshooting-messaging-inbox","kb/leads/visibility-groups-for-leads","kb/leads/when-should-a-lead-become-a-deal","kb/list-view/bulk-deleting-items-in-the-list-view","kb/list-view/bulk-editing-and-filtering","kb/list-view/how-can-i-reassign-items-owned-by-one-user-to-another-user","kb/list-view/sorting-by-multiple-columns-in-list-view","kb/list-view/why-can-t-i-see-my-colleagues-items-in-the-list-view","kb/notifications/how-can-i-enable-or-disable-desktop-notifications","kb/notifications/notifications","kb/notifications/sales-assistant-notifications","kb/notifications/sales-assistant","kb/personal-settings/can-all-users-access-the-fintesk-api","kb/personal-settings/can-i-be-in-multiple-fintesk-company-accounts","kb/personal-settings/can-i-change-my-displayed-timezone","kb/personal-settings/changing-or-updating-login-credentials","kb/personal-settings/convert-phone-numbers-to-us-format","kb/personal-settings/deactivated-users-data","kb/personal-settings/how-can-i-change-my-language-or-date-number-format","kb/personal-settings/how-can-i-compose-emails-in-a-separate-browser-tab","kb/personal-settings/how-can-i-find-my-personal-api-key","kb/personal-settings/how-can-i-switch-between-multiple-fintesk-accounts","kb/personal-settings/user-overview","kb/personal-settings/webhooks","kb/personal-settings/what-is-the-api-key-for","kb/pipeline-view/can-i-change-the-order-of-my-deals-in-the-pipeline-view","kb/pipeline-view/deal-card-customization-sorting","kb/pipeline-view/how-are-deals-ordered-in-the-pipeline-view","kb/pipeline-view/why-can-t-i-see-my-colleagues-deals-in-the-pipeline-view","kb/pipelines/how-can-i-set-deal-probability","kb/pipelines/how-can-i-set-stage-probability","kb/pipelines/pipeline-visibility","kb/pipelines/probability-in-fintesk","kb/privacy-and-security/2fa-two-factor-authentication","kb/privacy-and-security/how-can-i-log-myself-out-of-fintesk-on-my-connected-devices","kb/privacy-and-security/how-can-i-see-which-devices-i-have-used-to-access-fintesk","kb/privacy-and-security/how-can-i-sync-outlook-when-i-have-2fa-enabled","kb/privacy-and-security/how-is-data-backed-up-in-fintesk","kb/privacy-and-security/logging-into-fintesk-using-google","kb/privacy-and-security/security-alerts","kb/privacy-and-security/security-dashboard","kb/privacy-and-security/security-features-in-fintesk","kb/privacy-and-security/security-locked-out-of-account-after-failed-login-attempts","kb/privacy-and-security/security-rules-access-restrictions","kb/privacy-and-security/security-rules","kb/privacy-and-security/single-sign-on-entra-id","kb/privacy-and-security/single-sign-on-okta","kb/privacy-and-security/single-sign-on","kb/privacy-and-security/using-sso-single-sign-on-with-security-rules","kb/privacy-and-security/why-does-fintesk-log-me-out","kb/products/product-duration","kb/products/recurring-products","kb/tags-internal","kb/troubleshooting/how-can-i-generate-a-har-file","kb/troubleshooting/what-if-fintesk-support-is-not-available-in-the-app","kb/users-and-permissions/data-deleted-deactivated-user","kb/users-and-permissions/how-can-i-follow-items-owned-by-other-fintesk-users","kb/users-and-permissions/how-can-i-make-a-user-into-an-admin-user","kb/users-and-permissions/how-to-change-the-visibility-of-items","kb/users-and-permissions/permission-sets","kb/users-and-permissions/teams","kb/users-and-permissions/types-of-users-in-fintesk","kb/users-and-permissions/viewing-last-log-in-time-by-user","kb/users-and-permissions/visibility-groups","kb/users-and-permissions/what-happens-when-a-user-gets-deactivated"],"sidebars":{"tutorialSidebar":{"link":{"path":"/category/developers","label":"Developers"}}}}],"breadcrumbs":true}},"docusaurus-plugin-redoc":{"fintesk-v1":{"url":"redocusaurus/fintesk-v1.yaml","themeId":"theme-redoc","isSpecFile":true,"normalizeUrl":true,"spec":{"openapi":"3.0.1","info":{"title":"Fintesk API v2","version":"2.0.27"},"servers":[{"url":"{protocol}://api.fintesk.com","variables":{"protocol":{"enum":["http","https"],"default":"https"}}}],"tags":[{"name":"Activities","description":"Activities are appointments/tasks/events on a calendar that can be associated with a deal, a lead, a person and an organization. \\nActivities can be of different type (such as call, meeting, lunch or a custom type - see ActivityTypes object) and can be assigned to a particular user. \\nNote that activities can also be created without a specific date/time.\\n"},{"name":"ActivityFields","description":"Activity fields represent different fields that an activity has.\\n"},{"name":"ActivityTypes","description":"Activity types represent different kinds of activities that can be stored.\\nEach activity type is presented to the user with an icon and a name.\\nAdditionally, a color can be defined (not implemented in the Fintesk app as of today). \\nActivity types are linked to activities via  `ActivityType.key_string = Activity.type`. \\nThe `key_string` will be generated by the API based on the given name of the  activity type upon creation, and cannot be changed. \\nActivity types should be presented to the user in an ordered manner, using the `ActivityType.order_nr` value.\\n"},{"name":"Currencies","description":"Supported currencies which can be used to represent the monetary value of a deal, or a value of any monetary type custom field. \\nThe `Currency.code` field must be used to point to a currency. \\n`Currency.code` is the ISO-4217 format currency code for non-custom currencies. \\nYou can differentiate custom and non-custom currencies using the  `is_custom_flag` property. \\n"},{"name":"DealFields","description":"Deal fields represent the near-complete schema for a deal in the context of the company of the authorized user. \\nEach company can have a different schema for their deals, with various custom fields. \\nIn the context of using deal fields as a schema for defining the data fields  of a deal, it must be kept in mind that some types of custom fields can have  additional data fields which are not separate deal fields per se. Such is the case with monetary, daterange and timerange fields  – each of these fields will have one additional data field in addition to  the one presented in the context of deal fields. \\nFor example, if there is a monetary field with the key `ffk9s9` stored on  the account, `ffk9s9` would hold the numeric value of the field,  and `ffk9s9_currency` would hold the ISO currency code that goes along with the numeric value. \\nTo find out which data fields are available, fetch one deal and list its keys.\\n"},{"name":"Deals","description":"Deals represent ongoing, lost or won sales to an organization or to a person. \\nEach deal has a monetary value and must be placed in a stage.\\nDeals can be owned by a user.\\nEach deal consists of standard data fields but can also contain a number of custom fields. \\nThe custom fields can be recognized by long hashes as keys. \\nThese hashes can be mapped against `DealField.key`. \\nThe corresponding label for each such custom field can be obtained from `DealField.name`.\\n"},{"name":"Filters","description":"Each filter is essentially a set of data validation conditions. \\nA filter of the same kind can be applied when fetching a list of deals, persons, organizations or products in the context of a pipeline. \\nFilters are limited to a maximum of 16 conditions. \\nWhen applied, only items matching the conditions of the filter are returned. \\nDetailed definitions of filter conditions and additional functionality is not yet available.\\n"},{"name":"ItemSearch","description":"Ordered reference objects, pointing to either deals, persons, organizations, or products.\\n"},{"name":"OrganizationFields","description":"Organization fields represent the near-complete schema for an organization in the context of the company of the authorized user. \\nEach company can have a different schema for their organizations,  with various custom fields. \\nIn the context of using organization fields as a schema for defining the data  fields of an organization, it must be kept in mind that some types of custom  fields can have additional data fields which are not separate organization  fields per se. \\nSuch is the case with monetary, daterange and timerange fields - each of these  fields will have one additional data field in addition to the one presented  in the context of organization fields. \\nFor example, if there is a monetary field with the key `ffk9s9` stored on the  account, `ffk9s9` would hold the numeric value of the field,  and `ffk9s9_currency` would hold the ISO currency code that goes along with the numeric value. \\nTo find out which data fields are available, fetch one organization  and list its keys.\\n"},{"name":"OrganizationRelationships","description":"Organization relationships represent how different organizations are related to each other. \\nThe relationship can be hierarchical (parent-child companies) or lateral as defined by the `type` field - either `parent` or `related`.\\n","deprecated":true},{"name":"Organizations","description":"Organizations are companies and other kinds of organizations you are making deals with. Persons can be associated with organizations so that each organization can contain one or more persons.\\n"},{"name":"PersonFields","description":"Person fields represent the near-complete schema for a person in the context of the company of the authorized user. \\nEach company can have a different schema for their persons,  with various custom fields. \\nIn the context of using person fields as a schema for defining the data  fields of a person, it must be kept in mind that some types of custom fields  can have additional data fields which are not separate person fields per se.\\nSuch is the case with monetary, daterange and timerange fields – each of these fields will have one additional data field in addition to the one presented in the context of person fields. \\nFor example, if there is a monetary field with the key `ffk9s9` stored on the  account, `ffk9s9` would hold the numeric value of the field,  and `ffk9s9_currency` would hold the ISO currency code that  goes along with the numeric value. \\nTo find out which data fields are available, fetch one person and list its keys.\\n"},{"name":"Persons","description":"Persons are your contacts, the customers you are doing deals with. \\nEach person can belong to an organization. \\nPersons should not be confused with users.\\n"},{"name":"Pipelines","description":"Pipelines are essentially ordered collections of stages.\\n"},{"name":"ProductFields","description":"Product fields represent the near-complete schema for a product in the context of the company of the authorized user. \\nEach company can have a different schema for their products, with various  custom fields. \\nIn the context of using product fields as a schema for  defining the data fields of a product, it must be kept in mind that some  types of custom fields can have additional data fields which are  not separate product fields per se.\\nSuch is the case with monetary, daterange and timerange fields – each of these fields will have one additional data field in addition to the one presented in the context of product fields. \\nFor example, if there is a monetary field with the key `ffk9s9`  stored on the account, `ffk9s9` would hold the numeric value of the field,  and `ffk9s9_currency` would hold the ISO currency code that goes along  with the numeric value. \\nTo find out which data fields are available, fetch one product and list its keys.\\n"},{"name":"Products","description":"Products are the goods or services you are dealing with.\\nEach product can have N different price points - firstly, each product can  have a price in N different currencies, and secondly, each product can have  N variations of itself, each having N prices in different currencies.\\n \\nNote that only one price per variation per currency is supported. \\nProducts can be instantiated to deals. \\nIn the context of instatiation, a custom price, quantity, duration and discount  can be applied.\\n"},{"name":"Recents","description":"Recent changes across all item types in Fintesk (deals, persons, etc).\\n"},{"name":"Roles","description":"Roles are a part of the Visibility groups’ feature that allow the admin user to categorize other users and dictate what items they will be allowed access to see.\\n"},{"name":"Stages","description":"Stage is a logical component of a pipeline, and essentially a bucket that can hold a number of deals. \\nIn the context of the pipeline a stage belongs to, it has an order number which defines the order of stages in that pipeline.\\n"},{"name":"Users","description":"Users are people with access to your Fintesk account. A user may belong to one or many Fintesk accounts, so deleting a user from one Fintesk account will not remove the user from the data store if he/she is connected to multiple accounts. \\nUsers should not be confused with persons.\\n"}],"paths":{"/oauth/authorize":{"get":{"summary":"Requesting authorization","description":"Authorize a user by redirecting them to the Pipedrive OAuth authorization page and request their permissions to act on their behalf. This step is necessary to implement only when you allow app installation outside of the Marketplace.","operationId":"authorize","deprecated":true,"servers":[{"url":"https://oauth.fintesk.com"}],"tags":["Oauth"],"parameters":[{"in":"query","name":"client_id","required":true,"schema":{"type":"string"},"description":"The client ID provided to you by the Pipedrive Marketplace when you register your app"},{"in":"query","name":"redirect_uri","required":true,"schema":{"type":"string"},"description":"The callback URL you provided when you registered your app. Authorization code will be sent to that URL (if it matches with the value you entered in the registration form) if a user approves the app install. Or, if a customer declines, the corresponding error will also be sent to this URL."},{"in":"query","name":"state","schema":{"type":"string"},"description":"You may pass any random string as the state parameter and the same string will be returned to your app after a user authorizes access. It may be used to store the user\'s session ID from your app or distinguish different responses. Using state may increase security; see RFC-6749. \\n"}],"responses":{"200":{"description":"Authorize user in the app.","content":{"text/html":{"example":"As a result of the request, the customer will see a page with the confirmation dialog, which will present the details of your app (title, company name, icon) and explain the permission scopes that you have set for the app. Customers should confirm their wish to install the app by clicking \\"Allow and install\\" or deny authorization by clicking \\"Cancel\\".\\n"}}}}}},"/oauth/token":{"post":{"summary":"Getting the tokens","description":"After the customer has confirmed the app installation, you will need to exchange the `authorization_code` to a pair of access and refresh tokens. Using an access token, you can access the user\'s data through the API.","operationId":"get-tokens","deprecated":true,"servers":[{"url":"https://oauth.fintesk.com"}],"tags":["Oauth"],"security":[{"basic_authentication":[]}],"parameters":[{"in":"header","name":"Authorization","required":true,"schema":{"type":"string"},"description":"Base 64 encoded string containing the `client_id` and `client_secret` values. The header value should be `Basic <base64(client_id:client_secret)>`."}],"requestBody":{"content":{"application/x-www-form-urlencoded":{"schema":{"title":"getTokensRequest","type":"object","properties":{"grant_type":{"type":"string","enum":["authorization_code","refresh_token"],"default":"authorization_code","description":"Since you are trying to exchange an authorization code for a pair of tokens, you must use the value \\"authorization_code\\""},"code":{"type":"string","description":"The authorization code that you received after the user confirmed app installation"},"redirect_uri":{"type":"string","description":"The callback URL you provided when you registered your app"}}}}}},"responses":{"200":{"description":"Returns user Oauth2 tokens.","content":{"application/json":{"schema":{"title":"getTokensResponse200","type":"object","properties":{"access_token":{"type":"string","description":"You need to use an `access_token` for accessing the user\'s data via API. You will need to refresh the access token if the `access_token` becomes invalid."},"token_type":{"type":"string","description":"The format of the token. Always \\"Bearer\\"."},"refresh_token":{"type":"string","description":"A refresh token is needed when you refresh the access token. refresh_token will expire if it isn\'t used in 60 days. Each time refresh_token is used, its expiry date is reset back to 60 days."},"scope":{"type":"string","description":"List of scopes to which users have agreed to grant access within this `access_token`"},"expires_in":{"type":"integer","description":"The maximum time in seconds until the `access_token` expires"},"api_domain":{"type":"string","description":"The base URL path, including the company_domain, where the requests can be sent to"}}}}}}}}},"/oauth/token/":{"post":{"summary":"Refreshing the tokens","description":"The `access_token` has a lifetime. After a period of time, which was returned to you in `expires_in` JSON property, the `access_token` will be invalid, and you can no longer use it to get data from our API. To refresh the `access_token`, you must use the `refresh_token`.","operationId":"refresh-tokens","deprecated":true,"servers":[{"url":"https://oauth.fintesk.com"}],"tags":["Oauth"],"security":[{"basic_authentication":[]}],"parameters":[{"in":"header","name":"Authorization","required":true,"schema":{"type":"string"},"description":"Base 64 encoded string containing the `client_id` and `client_secret` values. The header value should be `Basic <base64(client_id:client_secret)>`."}],"requestBody":{"content":{"application/x-www-form-urlencoded":{"schema":{"title":"getTokensRequest","type":"object","properties":{"grant_type":{"type":"string","enum":["authorization_code","refresh_token"],"default":"refresh_token","description":"Since you are to refresh your access_token, you must use the value \\"refresh_token\\""},"refresh_token":{"type":"string","description":"The refresh token that you received after you exchanged the authorization code"}}}}}},"responses":{"200":{"description":"Returns user Oauth2 tokens.","content":{"application/json":{"schema":{"title":"getTokensResponse200","type":"object","properties":{"access_token":{"type":"string","description":"You need to use an `access_token` for accessing the user\'s data via API. You will need to refresh the access token if the `access_token` becomes invalid."},"token_type":{"type":"string","description":"The format of the token. Always \\"Bearer\\"."},"refresh_token":{"type":"string","description":"A refresh token is needed when you refresh the access token. refresh_token will expire if it isn\'t used in 60 days. Each time refresh_token is used, its expiry date is reset back to 60 days."},"scope":{"type":"string","description":"List of scopes to which users have agreed to grant access within this `access_token`"},"expires_in":{"type":"integer","description":"The maximum time in seconds until the `access_token` expires"},"api_domain":{"type":"string","description":"The base URL path, including the company_domain, where the requests can be sent to"}}}}}}}}},"/activities":{"delete":{"summary":"Delete multiple activities in bulk","description":"Marks multiple activities as deleted. After 30 days, the activities will be permanently deleted.","operationId":"deleteActivities","tags":["Activities"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_ids"}],"responses":{"200":{"description":"Success Deleting multiple activities in bulk","content":{"application/json":{"schema":{"title":"deleteActivitiesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted_list"}}}]}}}}}},"get":{"summary":"Get all activities assigned to a particular user","description":"Returns all activities assigned to a particular user.","operationId":"getActivities","tags":["Activities"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_activity_user_id"},{"$ref":"#/components/parameters/p_query_filter_id"},{"$ref":"#/components/parameters/p_query_activity_type"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_activity_start_date"},{"$ref":"#/components/parameters/p_query_activity_end_date"},{"$ref":"#/components/parameters/p_query_activity_done"}],"responses":{"200":{"description":"Success getting all activities assigned to a particular user","content":{"application/json":{"schema":{"title":"getActivitiesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"title":"activityResponseObject","allOf":[{"$ref":"#/components/schemas/s_activity_extended"},{"$ref":"#/components/schemas/s_activity"}]}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_3E_U"}}}]}}}}}},"post":{"summary":"Add an activity","description":"Adds a new activity. Includes `more_activities_scheduled_in_context` property in response\'s `additional_data` which indicates whether there are more undone activities scheduled with the same deal, person or organization (depending on the supplied data). For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/adding-an-activity\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">adding an activity</a>.","operationId":"addActivity","tags":["Activities"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"title":"addActivityRequest","allOf":[{"$ref":"#/components/schemas/s_activity_extended"},{"$ref":"#/components/schemas/s_activity"}]}}}},"responses":{"201":{"description":"Success Adding an activity","content":{"application/json":{"schema":{"title":"addActivityResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"title":"activityResponseObject","allOf":[{"$ref":"#/components/schemas/s_activity_extended"},{"$ref":"#/components/schemas/s_activity"}]},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_3E_U"}}}]}}}}}}},"/activities/{id}":{"delete":{"summary":"Delete an activity","description":"Marks an activity as deleted. After 30 days, the activity will be permanently deleted.","operationId":"deleteActivity","tags":["Activities"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"The activity was successfully deleted","content":{"application/json":{"schema":{"title":"deleteActivityResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted"}}}]}}}}}},"get":{"summary":"Get details of an activity","description":"Returns the details of a specific activity.","operationId":"getActivity","tags":["Activities"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success getting details of an activity","content":{"application/json":{"schema":{"title":"getActivityResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"title":"activityResponseObject","allOf":[{"$ref":"#/components/schemas/s_activity_extended"},{"$ref":"#/components/schemas/s_activity"}]},"related_objects":{"$ref":"#/components/schemas/s_related_objects_3E_U"}}}]}}}}}},"put":{"summary":"Update an activity","description":"Updates an activity. Includes `more_activities_scheduled_in_context` property in response\'s `additional_data` which indicates whether there are more undone activities scheduled with the same deal, person or organization (depending on the supplied data).","operationId":"updateActivity","tags":["Activities"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"title":"updateActivityRequest","allOf":[{"$ref":"#/components/schemas/s_activity_extended"},{"$ref":"#/components/schemas/s_activity"}]}}}},"responses":{"200":{"description":"Success updating an activity","content":{"application/json":{"schema":{"title":"updateActivityResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"title":"activityResponseObject","allOf":[{"$ref":"#/components/schemas/s_activity_extended"},{"$ref":"#/components/schemas/s_activity"}]},"related_objects":{"$ref":"#/components/schemas/s_related_objects_3E_U"}}}]}}}}}}},"/activityFields":{"get":{"summary":"Get all activity fields","description":"Returns all activity fields.","operationId":"getActivityFields","tags":["ActivityFields"],"security":[{"bearerAuth":[]}],"responses":{"200":{"description":"Success Getting all activity fields","content":{"application/json":{"schema":{"title":"fieldsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":[{"$ref":"#/components/schemas/s_field"}]},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}}},"/activityTypes":{"delete":{"summary":"Delete multiple activity types in bulk","description":"Marks multiple activity types as deleted.","operationId":"deleteActivityTypes","tags":["ActivityTypes"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_ids"}],"responses":{"200":{"description":"Success Deleting multiple activity types in bulk","content":{"application/json":{"schema":{"title":"deleteActivityTypesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"object","properties":{"type":"object","title":"deletedListID","properties":{"id":{"type":"array","description":"Array of all the IDs of the deleted items.","items":{"type":"integer"}}}}}}}]}}}}}},"get":{"summary":"Get all activity types","description":"Returns all activity types.","operationId":"getActivityTypes","tags":["ActivityTypes"],"security":[{"bearerAuth":[]}],"responses":{"200":{"description":"Success Getting all activity types","content":{"application/json":{"schema":{"title":"getActivityTypesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":[{"$ref":"#/components/schemas/s_activity_type"}],"description":"The array of activity types"}}}]}}}}}},"post":{"summary":"Add new activity type","description":"Adds a new activity type.","operationId":"addActivityType","tags":["ActivityTypes"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"title":"addActivityTypeRequest","allOf":[{"type":"object","required":["name","icon_key"]},{"$ref":"#/components/schemas/s_activity_type_put"}]}}}},"responses":{"200":{"description":"Success Adding new activity type","content":{"application/json":{"schema":{"title":"createActivityTypeResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_activity_type"}}}]}}}}}}},"/activityTypes/{id}":{"delete":{"summary":"Delete an activity type","description":"Marks an activity type as deleted.","operationId":"deleteActivityType","tags":["ActivityTypes"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success deleting an activity type","content":{"application/json":{"schema":{"title":"DeleteActivityTypeResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_activity_type"}}}]}}}}}},"put":{"summary":"Update an activity type","description":"Updates an activity type.","operationId":"updateActivityType","tags":["ActivityTypes"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"title":"updateActivityTypeRequest","$ref":"#/components/schemas/s_activity_type_put"}}}},"responses":{"200":{"description":"Success Updating an activity type","content":{"application/json":{"schema":{"title":"UpdateActivityTypeResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_activity_type"}}}]}}}}}}},"/currencies":{"get":{"summary":"Get all supported currencies","description":"Returns all supported currencies in given account which should be used when saving monetary values with other objects. The `code` parameter of the returning objects is the currency code according to ISO 4217 for all non-custom currencies.","operationId":"getCurrencies","tags":["Currencies"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_currency_term"}],"responses":{"200":{"description":"Success Getting all supported currencies","content":{"application/json":{"schema":{"title":"getCurrenciesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_currency"}}}]}}}}}}},"/deals":{"get":{"summary":"Get all deals","description":"Returns all deals. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/getting-all-deals\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">getting all deals</a>.","operationId":"getDeals","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_deal_user_id"},{"$ref":"#/components/parameters/p_query_filter_id"},{"$ref":"#/components/parameters/p_query_deal_stage_id"},{"$ref":"#/components/parameters/p_query_status"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_sort"},{"$ref":"#/components/parameters/p_query_deal_owned_by_you"}],"responses":{"200":{"description":"Success getting all deals","content":{"application/json":{"schema":{"title":"getDealsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"$ref":"#/components/schemas/s_deal_non_strict"}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_2E_U_S_P"}}}]}}}}}},"post":{"summary":"Add a deal","description":"Adds a new deal. All deals created through the Pipedrive API will have a `origin` set to `API`. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the dealFields and look for `key` values. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/creating-a-deal\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">adding a deal</a>.","operationId":"addDeal","tags":["Deals"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"title":"addDealRequest","allOf":[{"$ref":"#/components/schemas/s_attr_deal_title"},{"title":"requredTitleParameter","type":"object","required":["title"]},{"$ref":"#/components/schemas/s_deal_request_cru"},{"$ref":"#/components/schemas/s_deal_request_cru_basic"}]}}}},"responses":{"201":{"description":"Success Adding a deal","content":{"application/json":{"schema":{"title":"addDealResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_deal_non_strict"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_2E_U_S_P"}}}]}}}}}},"delete":{"summary":"Delete multiple deals in bulk","description":"Marks multiple deals as deleted. After 30 days, the deals will be permanently deleted.","operationId":"deleteDeals","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_ids"}],"responses":{"200":{"description":"Delete multiple deals in bulk","content":{"application/json":{"schema":{"title":"deleteDealsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted_list"}}}]}}}}}}},"/deals/search":{"get":{"summary":"Search deals","description":"Searches all deals by title, notes and/or custom fields. This endpoint is a wrapper of [/v1/itemSearch](../../fintesk/api/v1#tag/ItemSearch) with a narrower OAuth scope. Found deals can be filtered by the person ID and the organization ID.","operationId":"searchDeals","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_is_term"},{"$ref":"#/components/parameters/p_query_deal_fields"},{"$ref":"#/components/parameters/p_query_is_exact_match"},{"$ref":"#/components/parameters/p_query_is_person_id"},{"$ref":"#/components/parameters/p_query_is_organization_id"},{"$ref":"#/components/parameters/p_query_status"},{"$ref":"#/components/parameters/p_query_is_start"},{"$ref":"#/components/parameters/p_query_limit"}],"responses":{"200":{"description":"Success Searching deals","content":{"application/json":{"schema":{"title":"searchDealsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"object","properties":{"items":{"type":"array","description":"The array of deals","items":{"allOf":[{"$ref":"#/components/schemas/s_search_result_score"},{"type":"object","properties":{"item":{"$ref":"#/components/schemas/s_search_item_deal"}}}]}}}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}}},"/deals/summary":{"get":{"summary":"Get deals summary","description":"Returns a summary of all the deals.","operationId":"getDealsSummary","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_deal_filter_id"},{"$ref":"#/components/parameters/p_query_deal_user_id"},{"$ref":"#/components/parameters/p_query_deal_stage_id"}],"responses":{"200":{"description":"Success Getting the summary of the deals","content":{"application/json":{"schema":{"title":"getDealsSummaryResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_deals_summary"}}}]}}}}}}},"/deals/timeline":{"get":{"summary":"Get deals timeline","deprecated":true,"description":"Returns open and won deals, grouped by a defined interval of time set in a date-type dealField (`field_key`)  - e.g. when month is the chosen interval,  and 3 months are asked starting from January 1st, 2023,  deals are returned grouped into 3 groups - January, February and March - based on the value of the given `field_key`.","operationId":"getDealsTimeline","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_deal_start_date"},{"$ref":"#/components/parameters/p_query_deal_interval"},{"$ref":"#/components/parameters/p_query_deal_amount"},{"$ref":"#/components/parameters/p_query_deal_field_key"},{"$ref":"#/components/parameters/p_query_deal_user_id"},{"$ref":"#/components/parameters/p_query_deal_pipeline_id"},{"$ref":"#/components/parameters/p_query_filter_id"},{"$ref":"#/components/parameters/p_query_deal_exclude_deals"},{"$ref":"#/components/parameters/p_query_pipeline_totals_convert_currency"}],"responses":{"200":{"description":"Get open and won deals, grouped by the defined interval of time","content":{"application/json":{"schema":{"title":"getDealsTimelineResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_deals_timeline_grouped"}}}]}}}}}}},"/deals/{id}":{"delete":{"summary":"Delete a deal","description":"Marks a deal as deleted. After 30 days, the deal will be permanently deleted.","operationId":"deleteDeal","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Delete a deal","content":{"application/json":{"schema":{"title":"deleteDealResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted"}}}]}}}}}},"get":{"summary":"Get details of a deal","description":"Returns the details of a specific deal. Note that this also returns some additional fields which are not present when asking for all deals – such as deal age and stay in pipeline stages. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of dealFields. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/getting-details-of-a-deal\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">getting details of a deal</a>.","operationId":"getDeal","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success getting a deal by it\'s ID","content":{"application/json":{"schema":{"title":"getDealResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_deal"},"additional_data":{"allOf":[{"type":"object"}]},"related_objects":{"$ref":"#/components/schemas/s_related_objects_2E_U_S_P"}}}]}}}}}},"put":{"summary":"Update a deal","description":"Updates the properties of a deal. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/updating-a-deal\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">updating a deal</a>.","operationId":"updateDeal","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"title":"updateDealRequest","type":"object","allOf":[{"$ref":"#/components/schemas/s_attr_deal_title"},{"$ref":"#/components/schemas/s_deal_request_cru"},{"$ref":"#/components/schemas/s_deal_request_cru_basic"}]}}}},"responses":{"200":{"description":"Success Updating a deal","content":{"application/json":{"schema":{"title":"UpdateDealResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_deal_non_strict"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_2E_U_S_P"}}}]}}}}}}},"/deals/{id}/activities":{"get":{"summary":"List activities associated with a deal","description":"Lists activities associated with a deal.","operationId":"getDealActivities","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_activity_done"},{"$ref":"#/components/parameters/p_query_activity_exclude"}],"responses":{"200":{"description":"Success listing activities associated with a deal","content":{"application/json":{"schema":{"title":"getDealActivitiesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"title":"activityResponseObject","allOf":[{"$ref":"#/components/schemas/s_activity_extended"},{"$ref":"#/components/schemas/s_activity"}]},"description":"The array of activities"},"additional_data":{"title":"activityDistributionDataWithAdditionalData","allOf":[{"$ref":"#/components/schemas/s_additional_data_pagination"}]},"related_objects":{"$ref":"#/components/schemas/s_related_objects_3E_U"}}}]}}}}}}},"/deals/{id}/flow":{"get":{"summary":"List updates about a deal","description":"Lists updates about a deal.","operationId":"getDealUpdates","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_all_changes"},{"$ref":"#/components/parameters/p_query_deal_items"}],"responses":{"200":{"description":"Get the deal updates","content":{"application/json":{"schema":{"title":"getDealUpdatesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"type":"object","properties":{"object":{"type":"string","description":"The type of the deal update. (Possible object types - dealChange, note, activity, mailMessage, invoice, document, file)"},"timestamp":{"type":"string","description":"The creation date and time of the update"},"data":{"type":"object","description":"The data related to the update"}}}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_3E_U"}}}]}}}}}}},"/deals/{id}/persons":{"get":{"summary":"List all persons associated with a deal","description":"Lists all persons associated with a deal, regardless of whether the person is the primary contact of the deal, or added as a participant.","operationId":"getDealPersons","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"}],"responses":{"200":{"description":"Success listing all persons associated with a deal","content":{"application/json":{"schema":{"title":"listPersonsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"type":"object","title":"personItem","allOf":[{"$ref":"#/components/schemas/s_person_item"},{"$ref":"#/components/schemas/s_person_additional_info"}]},"description":"The array of persons"},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_O_U"}}}]}}}}}}},"/deals/{id}/products":{"get":{"summary":"List products attached to a deal","description":"Lists products attached to a deal.","operationId":"getDealProducts","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_deal_include_product_data"}],"responses":{"200":{"description":"Success listing products attached to a deal","content":{"application/json":{"schema":{"title":"listProductsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"The array of products","items":{"$ref":"#/components/schemas/s_deal_product_extended"}},"additional_data":{"allOf":[{"$ref":"#/components/schemas/s_deal_product_totals"},{"$ref":"#/components/schemas/s_additional_data_pagination"}]},"related_objects":{"$ref":"#/components/schemas/s_related_objects_USER"}}}]}}}}}},"post":{"summary":"Add a product to a deal","description":"Adds a product to a deal, creating a new item called a deal-product.","operationId":"addDealProduct","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"title":"addDealProductRequest","type":"object","allOf":[{"type":"object","title":"dealProductRequestBasic","required":["product_id","item_price","quantity"]},{"$ref":"#/components/schemas/s_deal_product_request"}]}}}},"responses":{"200":{"description":"Success Adding a product to a deal","content":{"application/json":{"schema":{"title":"getAddProductAttachementResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"description":"The added product object attached to the deal","allOf":[{"allOf":[{"allOf":[{"title":"basicDealProductRequest","type":"object","allOf":[{"$ref":"#/components/schemas/s_product_response"}]},{"$ref":"#/components/schemas/s_deal_product_basic"}]},{"$ref":"#/components/schemas/prod_attr_product_attachment_id"}]}]}}}]}}}}}}},"/deals/{id}/products/{product_attachment_id}":{"put":{"summary":"Update the product attached to a deal","description":"Updates the details of the product that has been attached to a deal.","operationId":"updateDealProduct","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_path_product_attachment_id"}],"requestBody":{"content":{"application/json":{"schema":{"title":"UpdateDealProductRequest","type":"object","allOf":[{"$ref":"#/components/schemas/s_deal_product_request"}]}}}},"responses":{"200":{"description":"Update product attachment details","content":{"application/json":{"schema":{"title":"getProductAttachementResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"description":"The updated product object attached to the deal","allOf":[{"title":"basicDealProductRequest","type":"object"},{"$ref":"#/components/schemas/s_product_response"},{"$ref":"#/components/schemas/s_deal_product_basic"}]}}}]}}}}}},"delete":{"summary":"Delete an attached product from a deal","description":"Deletes a product attachment from a deal, using the `product_attachment_id`.","operationId":"deleteDealProduct","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_path_product_attachment_id"}],"responses":{"200":{"description":"Delete an attached product from a deal","content":{"application/json":{"schema":{"title":"deleteDealProductResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted"}}}]}}}}}}},"/dealFields":{"get":{"summary":"Get all deal fields","description":"Returns data about all deal fields.","operationId":"getDealFields","parameters":[{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_start"}],"tags":["DealFields"],"security":[{"bearerAuth":[]}],"responses":{"200":{"description":"Success getting all deal fields","content":{"application/json":{"schema":{"title":"fieldsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"data":{"$ref":"#/components/schemas/s_field"}}}]}}}}}},"post":{"summary":"Add a new deal field","description":"Adds a new deal field. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">adding a new custom field</a>.","operationId":"addDealField","tags":["DealFields"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"title":"createFieldRequest","allOf":[{"$ref":"#/components/schemas/s_field_post_body"}]}}}},"responses":{"200":{"description":"Success adding a new deal field","content":{"application/json":{"schema":{"title":"fieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field"}}}]}}}}}},"delete":{"summary":"Delete multiple deal fields in bulk","description":"Marks multiple deal fields as deleted.","operationId":"deleteDealFields","tags":["DealFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_ids"}],"responses":{"200":{"description":"Success deleting multiple deal fields in bulk","content":{"application/json":{"schema":{"title":"deleteFieldsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted_list"}}}]}}}}}}},"/dealFields/{id}":{"get":{"summary":"Get one deal field","description":"Returns data about a specific deal field.","operationId":"getDealField","tags":["DealFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_field_id"}],"responses":{"200":{"description":"Success getting one deal field","content":{"application/json":{"schema":{"title":"fieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field"}}}]}}}}}},"delete":{"summary":"Delete a deal field","description":"Marks a field as deleted. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/deleting-a-custom-field\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">deleting a custom field</a>.","operationId":"deleteDealField","tags":["DealFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_field_id"}],"responses":{"200":{"description":"Success Deleting a deal field","content":{"application/json":{"schema":{"title":"deleteFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field_response_delete_id"}}}]}}}}}},"put":{"summary":"Update a deal field","description":"Updates a deal field. For more information, see the tutorial for <a href=\\" https://pipedrive.readme.io/docs/updating-custom-field-value \\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">updating custom fields\' values</a>.","operationId":"updateDealField","tags":["DealFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_field_id"}],"requestBody":{"content":{"application/json":{"schema":{"title":"updateFieldRequest","allOf":[{"$ref":"#/components/schemas/s_field_put_body"}]}}}},"responses":{"200":{"description":"Success updating a deal field","content":{"application/json":{"schema":{"title":"fieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field"}}}]}}}}}}},"/filters":{"delete":{"summary":"Delete multiple filters in bulk","description":"Marks multiple filters as deleted.","operationId":"deleteFilters","tags":["Filters"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_ids"}],"responses":{"200":{"description":"Success Deleting multiple filters in bulk","content":{"application/json":{"schema":{"title":"deleteFiltersResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted_list"}}}]}}}}}},"get":{"summary":"Get all filters","description":"Returns data about all filters.","operationId":"getFilters","tags":["Filters"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_filter_type"}],"responses":{"200":{"description":"Success Getting all filters","content":{"application/json":{"schema":{"title":"getFiltersResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"properties":{"data":{"type":"array","description":"The array of filters","items":{"$ref":"#/components/schemas/s_filter_base"}}}}]}}}}}},"post":{"summary":"Add a new filter","description":"Adds a new filter, returns the ID upon success. Note that in the conditions JSON object only one first-level condition group is supported, and it must be glued with \'AND\', and only two second level condition groups are supported of which one must be glued with \'AND\' and the second with \'OR\'. Other combinations do not work (yet) but the syntax supports introducing them in future. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/adding-a-filter\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">adding a filter</a>.","operationId":"addFilter","tags":["Filters"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_filter_request_add"}}}},"responses":{"200":{"description":"Success Adding a new filter","content":{"application/json":{"schema":{"title":"postFilterResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_filter_w_conditions"}}}]}}}}}}},"/filters/helpers":{"get":{"summary":"Get all filter helpers","description":"Returns all supported filter helpers. It helps to know what conditions and helpers are available when you want to <a href=\\"/docs/api/v1/Filters#addFilter\\">add</a> or <a href=\\"/docs/api/v1/Filters#updateFilter\\">update</a> filters. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/adding-a-filter\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">adding a filter</a>.","operationId":"getFilterHelpers","tags":["Filters"],"security":[{"bearerAuth":[]}],"responses":{"200":{"description":"Success Getting all filter helpers","content":{"application/json":{"schema":{"title":"getFilterHelpersResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"object","description":"The rules for filters"}}}]}}}}}}},"/filters/{id}":{"delete":{"summary":"Delete a filter","description":"Marks a filter as deleted.","operationId":"deleteFilter","tags":["Filters"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success Deleting a filter","content":{"application/json":{"schema":{"title":"deleteFilterResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted"}}}]}}}}}},"get":{"summary":"Get one filter","description":"Returns data about a specific filter. Note that this also returns the condition lines of the filter.","operationId":"getFilter","tags":["Filters"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success Getting one filter","content":{"application/json":{"schema":{"title":"getFilterResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_filter_base"}}}]}}}}}},"put":{"summary":"Update a filter","description":"Updates an existing filter.","operationId":"updateFilter","tags":["Filters"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_filter_request_upd"}}}},"responses":{"200":{"description":"Success Updating a filter","content":{"application/json":{"schema":{"title":"postFilterResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_filter_w_conditions"}}}]}}}}}}},"/itemSearch":{"get":{"summary":"Perform a search from multiple item types","description":"Performs a search from your choice of item types and fields.","operationId":"searchItem","tags":["ItemSearch"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_is_item_types"},{"$ref":"#/components/parameters/p_query_is_fields"},{"$ref":"#/components/parameters/p_query_is_search_for_related_items"},{"$ref":"#/components/parameters/p_query_is_include_fields"},{"$ref":"#/components/parameters/p_query_is_term"},{"$ref":"#/components/parameters/p_query_is_exact_match"},{"$ref":"#/components/parameters/p_query_is_start"},{"$ref":"#/components/parameters/p_query_limit"}],"responses":{"200":{"description":"Success searching from multiple item types","content":{"application/json":{"schema":{"title":"searchItemResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"object","properties":{"items":{"type":"array","description":"The array of found items","items":{"allOf":[{"$ref":"#/components/schemas/s_search_result_score"},{"type":"object","properties":{"item":{"type":"object","description":"Item"}}}]}},"related_items":{"type":"array","description":"The array of related items if `search_for_related_items` was enabled","items":{"allOf":[{"$ref":"#/components/schemas/s_search_result_score"},{"type":"object","properties":{"item":{"type":"object","description":"Item"}}}]}}}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}}},"/itemSearch/field":{"get":{"summary":"Perform a search using a specific field from an item type","description":"Performs a search from the values of a specific field. Results can either be the distinct values of the field (useful for searching autocomplete field values), or the IDs of actual items (deals, leads, persons, organizations or products).","operationId":"searchItemByField","tags":["ItemSearch"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_is_field_type"},{"$ref":"#/components/parameters/p_query_is_field_key"},{"$ref":"#/components/parameters/p_query_is_return_item_ids"},{"$ref":"#/components/parameters/p_query_is_term"},{"$ref":"#/components/parameters/p_query_is_exact_match"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"}],"responses":{"200":{"description":"Success searching a specific field","content":{"application/json":{"schema":{"title":"searchItemByFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"The array of results","items":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the item"},"$field_key":{"description":"The value of the searched `field_key`"}}}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}}},"/notes":{"get":{"summary":"Get all notes","description":"Returns all notes.","operationId":"getNotes","deprecated":true,"tags":["Notes"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_note_user_id"},{"$ref":"#/components/parameters/p_query_note_deal_id"},{"$ref":"#/components/parameters/p_query_note_person_id"},{"$ref":"#/components/parameters/p_query_note_org_id"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_note_sort"},{"$ref":"#/components/parameters/p_query_note_start_date"},{"$ref":"#/components/parameters/p_query_note_end_date"},{"$ref":"#/components/parameters/p_query_note_pinned_to_deal_flag"},{"$ref":"#/components/parameters/p_query_note_pinned_to_organization_flag"},{"$ref":"#/components/parameters/p_query_note_pinned_to_person_flag"}],"responses":{"200":{"description":"Success Getting all notes","content":{"application/json":{"schema":{"title":"getNotesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"The array of notes","items":{"$ref":"#/components/schemas/s_note_w_objects"}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_3E_U"}}}]}}}}}},"post":{"summary":"Add a note","description":"Adds a new note.","operationId":"addNote","deprecated":true,"tags":["Notes"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_note_request"}}}},"responses":{"200":{"description":"Success Adding a note","content":{"application/json":{"schema":{"title":"addNoteResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_note_w_objects"}}}]}}}}}}},"/notes/{id}":{"delete":{"summary":"Delete a note","description":"Deletes a specific note.","operationId":"deleteNote","deprecated":true,"tags":["Notes"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success Deleting a note","content":{"application/json":{"schema":{"title":"deleteNoteResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"boolean","description":"If the response is successful or not"}}}]}}}}}},"get":{"summary":"Get one note","description":"Returns details about a specific note.","operationId":"getNote","deprecated":true,"tags":["Notes"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success Getting one note","content":{"application/json":{"schema":{"title":"getNoteResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_note_w_objects"}}}]}}}}}},"put":{"summary":"Update a note","description":"Updates a note.","operationId":"updateNote","deprecated":true,"tags":["Notes"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_note_request"}}}},"responses":{"200":{"description":"Success Updating a note","content":{"application/json":{"schema":{"title":"updateNoteResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_note_w_objects"}}}]}}}}}}},"/notes/{id}/comments":{"get":{"summary":"Get all comments for a note","description":"Returns all comments associated with a note.","operationId":"getNoteComments","deprecated":true,"tags":["Notes"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_start"}],"responses":{"200":{"description":"Success Getting all comments for a note","content":{"application/json":{"schema":{"title":"getCommentsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"The array of comments","items":{"$ref":"#/components/schemas/s_note_w_comment"}},"related_objects":{"$ref":"#/components/schemas/s_related_objects_3E_U"},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}},"post":{"summary":"Add a comment to a note","description":"Adds a new comment to a note.","operationId":"addNoteComment","deprecated":true,"tags":["Notes"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"allOf":[{"title":"CommentPostPutObject","type":"object","required":["content"]},{"$ref":"#/components/schemas/s_note_request_content"}]}}}},"responses":{"200":{"description":"Success Adding a comment to a note","content":{"application/json":{"schema":{"title":"oneCommentResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_note_w_comment"}}}]}}}}}}},"/notes/{id}/comments/{commentId}":{"get":{"summary":"Get one comment","description":"Returns the details of a comment.","operationId":"getComment","deprecated":true,"tags":["Notes"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_path_note_comment_id"}],"responses":{"200":{"description":"Success Getting one comment","content":{"application/json":{"schema":{"title":"oneCommentResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_note_w_comment"}}}]}}}}}},"put":{"summary":"Update a comment related to a note","description":"Updates a comment related to a note.","operationId":"updateCommentForNote","deprecated":true,"tags":["Notes"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_path_note_comment_id"}],"requestBody":{"content":{"application/json":{"schema":{"allOf":[{"title":"CommentPostPutObject","type":"object","required":["content"]},{"$ref":"#/components/schemas/s_note_request_content"}]}}}},"responses":{"200":{"description":"Success Updating a comment related to a note","content":{"application/json":{"schema":{"title":"oneCommentResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_note_w_comment"}}}]}}}}}},"delete":{"summary":"Delete a comment related to a note","description":"Deletes a comment.","operationId":"deleteComment","deprecated":true,"tags":["Notes"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_path_note_comment_id"}],"responses":{"200":{"description":"Success Deleting a comment related to a note","content":{"application/json":{"schema":{"title":"deleteCommentResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"boolean","description":"If the response is successful or not"}}}]}}}}}}},"/noteFields":{"get":{"summary":"Get all note fields","description":"Returns data about all note fields.","operationId":"getNoteFields","deprecated":true,"tags":["NoteFields"],"security":[{"bearerAuth":[]}],"responses":{"200":{"description":"Success getting all note fields","content":{"application/json":{"schema":{"title":"getNoteFieldsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":[{"$ref":"#/components/schemas/s_field"}]},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}}},"/organizations":{"delete":{"summary":"Delete multiple organizations in bulk","description":"Marks multiple organizations as deleted. After 30 days, the organizations will be permanently deleted.","operationId":"deleteOrganizations","tags":["Organizations"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_ids"}],"responses":{"200":{"description":"Success","content":{"application/json":{"schema":{"title":"deleteOrganizationsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted_list"}}}]}}}}}},"get":{"summary":"Get all organizations","description":"Returns all organizations.","operationId":"getOrganizations","tags":["Organizations"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_org_user_id"},{"$ref":"#/components/parameters/p_query_filter_id"},{"$ref":"#/components/parameters/p_query_first_char"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_sort"}],"responses":{"200":{"description":"Success Getting all organizations","content":{"application/json":{"schema":{"title":"getOrganizationsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"The array of organizations","items":{"$ref":"#/components/schemas/s_organization_base"}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_O_U_Pic"}}}]}}}}}},"post":{"summary":"Add an organization","description":"Adds a new organization. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the organizationFields and look for `key` values. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/adding-an-organization\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">adding an organization</a>.","operationId":"addOrganization","tags":["Organizations"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"title":"addOrganizationRequest","allOf":[{"$ref":"#/components/schemas/s_attr_organization_name"},{"type":"object","required":["name"],"properties":{"add_time":{"type":"string","description":"The optional creation date & time of the organization in UTC. Requires admin user API token. Format: YYYY-MM-DD HH:MM:SS"}}},{"title":"basicOrganization","type":"object","properties":{"allOf":[{"$ref":"../../Organizations/schemas/s_attr_organization_owner_id.yaml"},{"$ref":"../../_components/schemas_entities/s_attr_label_array.yaml"},{"type":"object"}]}}]}}}},"responses":{"201":{"description":"Success Adding an organization","content":{"application/json":{"schema":{"title":"addOrganizationResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_organization_w_edit_name"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_O_U_Pic"}}}]}}}}}}},"/organizations/search":{"get":{"summary":"Search organizations","description":"Searches all organizations by name, address, notes and/or custom fields. This endpoint is a wrapper of [/v1/itemSearch](../../fintesk/api/v1#tag/ItemSearch) with a narrower OAuth scope.","operationId":"searchOrganization","tags":["Organizations"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_is_term"},{"$ref":"#/components/parameters/p_query_org_fields"},{"$ref":"#/components/parameters/p_query_is_exact_match"},{"$ref":"#/components/parameters/p_query_is_start"},{"$ref":"#/components/parameters/p_query_limit"}],"responses":{"200":{"description":"Success Searching organizations","content":{"application/json":{"schema":{"title":"searchOrganizationResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"object","properties":{"items":{"type":"array","description":"The array of found items","items":{"allOf":[{"$ref":"#/components/schemas/s_search_result_score"},{"type":"object","properties":{"item":{"$ref":"#/components/schemas/s_search_item_organization"}}}]}}}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}}},"/organizations/{id}":{"delete":{"summary":"Delete an organization","description":"Marks an organization as deleted. After 30 days, the organization will be permanently deleted.","operationId":"deleteOrganization","tags":["Organizations"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success deleting an organization","content":{"application/json":{"schema":{"title":"deleteOrganizationResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted"}}}]}}}}}},"get":{"summary":"Get details of an organization","description":"Returns the details of an organization. Note that this also returns some additional fields which are not present when asking for all organizations. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of organizationFields.","operationId":"getOrganization","tags":["Organizations"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success getting details of an organization","content":{"application/json":{"schema":{"title":"getOrganizationResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_organization_item"},"additional_data":{"allOf":[{"$ref":"#/components/schemas/s_organization_item_follower"},{"$ref":"#/components/schemas/s_additional_data_pagination"}]},"related_objects":{"$ref":"#/components/schemas/s_related_objects_O_U_Pic"}}}]}}}}}},"put":{"summary":"Update an organization","description":"Updates the properties of an organization.","operationId":"updateOrganization","tags":["Organizations"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"title":"updateOrganizationRequest","allOf":[{"$ref":"#/components/schemas/s_attr_organization_name"},{"title":"basicOrganization","type":"object","properties":{"allOf":[{"$ref":"../../Organizations/schemas/s_attr_organization_owner_id.yaml"},{"$ref":"../../_components/schemas_entities/s_attr_label_array.yaml"},{"type":"object"}]}}]}}}},"responses":{"200":{"description":"Success updating an organization","content":{"application/json":{"schema":{"title":"updateOrganizationResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_organization_base"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_O_U_Pic"}}}]}}}}}}},"/organizations/{id}/activities":{"get":{"summary":"List activities associated with an organization","description":"Lists activities associated with an organization.","operationId":"getOrganizationActivities","tags":["Organizations"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_activity_done"},{"$ref":"#/components/parameters/p_query_activity_exclude"}],"responses":{"200":{"description":"Success listing activities associated with an organization","content":{"application/json":{"schema":{"title":"getAssociatedActivitiesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"title":"activityResponseObject","allOf":[{"$ref":"#/components/schemas/s_activity_extended"},{"$ref":"#/components/schemas/s_activity"}]},"description":"The array of activities"},"additional_data":{"title":"activityDistributionDataWithAdditionalData","allOf":[{"$ref":"#/components/schemas/s_additional_data_pagination"}]}}}]}}}}}}},"/organizations/{id}/deals":{"get":{"summary":"List deals associated with an organization","description":"Lists deals associated with an organization.","operationId":"getOrganizationDeals","tags":["Organizations"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_status"},{"$ref":"#/components/parameters/p_query_sort"}],"responses":{"200":{"description":"Success Listing deals associated with an organization","content":{"application/json":{"schema":{"title":"getAssociatedDealsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"The array of deals","items":{"$ref":"#/components/schemas/s_deal_non_strict"}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_2E_U_S_P"}}}]}}}}}}},"/organizations/{id}/files":{"get":{"summary":"List files attached to an organization","description":"Lists files associated with an organization.","operationId":"getOrganizationFiles","deprecated":true,"tags":["Organizations"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_org_sort"},{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"}],"responses":{"200":{"description":"Success Listing files attached to an organization","content":{"application/json":{"schema":{"title":"getAssociatedFilesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"$ref":"#/components/schemas/s_file"},"description":"The array of files"},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}}},"/organizations/{id}/flow":{"get":{"summary":"List updates about an organization","description":"Lists updates about an organization.","operationId":"getOrganizationUpdates","tags":["Organizations"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_all_changes"},{"$ref":"#/components/parameters/p_query_org_items"}],"responses":{"200":{"description":"Get the organization updates","content":{"application/json":{"schema":{"title":"getAssociatedUpdatesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"type":"object","properties":{"object":{"type":"string","description":"The type of the person update. (Possible object types - organizationChange, dealChange, file, activity)"},"timestamp":{"type":"string","description":"The creation date and time of the update"},"data":{"type":"object","description":"The data related to the update"}}}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_O_U"}}}]}}}}}}},"/organizations/{id}/persons":{"get":{"summary":"List persons of an organization","description":"Lists persons associated with an organization.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.","operationId":"getOrganizationPersons","tags":["Organizations"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"}],"responses":{"200":{"description":"Success Listing persons of an organization","content":{"application/json":{"schema":{"title":"listPersonsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"type":"object","title":"personItem","allOf":[{"$ref":"#/components/schemas/s_person_item"},{"$ref":"#/components/schemas/s_person_additional_info"}]},"description":"The array of persons"},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_O_U"}}}]}}}}}}},"/organizationFields":{"get":{"summary":"Get all organization fields","description":"Returns data about all organization fields.","operationId":"getOrganizationFields","parameters":[{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_start"}],"tags":["OrganizationFields"],"security":[{"bearerAuth":[]}],"responses":{"200":{"description":"Success getting all organization fields","content":{"application/json":{"schema":{"title":"getOrganizationFieldsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":[{"$ref":"#/components/schemas/s_field"}]},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}},"post":{"summary":"Add a new organization field","description":"Adds a new organization field. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">adding a new custom field</a>.","operationId":"addOrganizationField","tags":["OrganizationFields"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"title":"createFieldRequest","allOf":[{"$ref":"#/components/schemas/s_field_post_body"}]}}}},"responses":{"200":{"description":"Success adding a new organization field","content":{"application/json":{"schema":{"title":"addOrganizationFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field"}}}]}}}}}},"delete":{"summary":"Delete multiple organization fields in bulk","description":"Marks multiple fields as deleted.","operationId":"deleteOrganizationFields","tags":["OrganizationFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_ids"}],"responses":{"200":{"description":"Success deleting multiple organization fields in bulk","content":{"application/json":{"schema":{"title":"deleteOrganizationFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted_list"}}}]}}}}}}},"/organizationFields/{id}":{"get":{"summary":"Get one organization field","description":"Returns data about a specific organization field.","operationId":"getOrganizationField","tags":["OrganizationFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_field_id"}],"responses":{"200":{"description":"Success getting one organization field","content":{"application/json":{"schema":{"title":"getOrganizationFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"data":{"$ref":"#/components/schemas/s_field"}}}]}}}}}},"delete":{"summary":"Delete an organization field","description":"Marks a field as deleted. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/deleting-a-custom-field\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">deleting a custom field</a>.","operationId":"deleteOrganizationField","tags":["OrganizationFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_field_id"}],"responses":{"200":{"description":"Success deleting an organization field","content":{"application/json":{"schema":{"title":"deleteOrganizationFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field_response_delete_id"}}}]}}}}}},"put":{"summary":"Update an organization field","description":"Updates an organization field. For more information, see the tutorial for <a href=\\" https://pipedrive.readme.io/docs/updating-custom-field-value \\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">updating custom fields\' values</a>.","operationId":"updateOrganizationField","tags":["OrganizationFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_field_id"}],"requestBody":{"content":{"application/json":{"schema":{"title":"updateFieldRequest","allOf":[{"$ref":"#/components/schemas/s_field_put_body"}]}}}},"responses":{"200":{"description":"Success updating an organization field","content":{"application/json":{"schema":{"title":"updateOrganizationFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field"}}}]}}}}}}},"/persons":{"delete":{"summary":"Delete multiple persons in bulk","description":"Marks multiple persons as deleted. After 30 days, the persons will be permanently deleted.","operationId":"deletePersons","tags":["Persons"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_ids"}],"responses":{"200":{"description":"Success","content":{"application/json":{"schema":{"title":"deletePersonsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted_list"}}}]}}}}}},"get":{"summary":"Get all persons","description":"Returns all persons.","operationId":"getPersons","tags":["Persons"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_person_user_id"},{"$ref":"#/components/parameters/p_query_filter_id"},{"$ref":"#/components/parameters/p_query_first_char"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_sort"}],"responses":{"200":{"description":"Success Getting all persons","content":{"application/json":{"schema":{"title":"getPersonsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"allOf":[{"$ref":"#/components/schemas/s_person_item"},{"$ref":"#/components/schemas/s_person_additional_info"}]},"description":"The array of persons"},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_O_U_Pic"}}}]}}}}}},"post":{"summary":"Add a person","description":"Adds a new person. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the personFields and look for `key` values.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.","operationId":"addPerson","tags":["Persons"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"title":"addPersonRequest","allOf":[{"$ref":"#/components/schemas/s_person_request"}]}}}},"responses":{"201":{"description":"Success","content":{"application/json":{"schema":{"title":"addPersonResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"object","title":"personItem","allOf":[{"$ref":"#/components/schemas/s_person_item"},{"$ref":"#/components/schemas/s_person_additional_info"}]},"related_objects":{"$ref":"#/components/schemas/s_related_objects_USER"}}}]}}}}}}},"/persons/search":{"get":{"summary":"Search persons","description":"Searches all persons by name, email, phone, notes and/or custom fields. This endpoint is a wrapper of [/v1/itemSearch](../../fintesk/api/v1#tag/ItemSearch) with a narrower OAuth scope. Found persons can be filtered by organization ID.","operationId":"searchPersons","tags":["Persons"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_is_term"},{"$ref":"#/components/parameters/p_query_fields"},{"$ref":"#/components/parameters/p_query_is_exact_match"},{"$ref":"#/components/parameters/p_query_is_organization_id"},{"$ref":"#/components/parameters/p_query_include_fields"},{"$ref":"#/components/parameters/p_query_is_start"},{"$ref":"#/components/parameters/p_query_limit"}],"responses":{"200":{"description":"Success Searching persons","content":{"application/json":{"schema":{"title":"searchPersonsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"object","properties":{"items":{"type":"array","description":"The array of found items","items":{"allOf":[{"$ref":"#/components/schemas/s_search_result_score"},{"type":"object","properties":{"item":{"$ref":"#/components/schemas/s_search_item_person"}}}]}}}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}}},"/persons/{id}":{"delete":{"summary":"Delete a person","description":"Marks a person as deleted. After 30 days, the person will be permanently deleted.","operationId":"deletePerson","tags":["Persons"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success","content":{"application/json":{"schema":{"title":"deletePersonResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted"}}}]}}}}}},"get":{"summary":"Get details of a person","description":"Returns the details of a person. Note that this also returns some additional fields which are not present when asking for all persons. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of personFields.","operationId":"getPerson","tags":["Persons"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success Getting details of a person","content":{"application/json":{"schema":{"title":"getPersonResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"object","title":"personItem","allOf":[{"$ref":"#/components/schemas/s_person_item"},{"$ref":"#/components/schemas/s_person_additional_info"}]},"additional_data":{"allOf":[{"type":"object"}]},"related_objects":{"$ref":"#/components/schemas/s_related_objects_O_U_Pic"}}}]}}}}}},"put":{"summary":"Update a person","description":"Updates the properties of a person.  For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/updating-a-person\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">updating a person</a>.","operationId":"updatePerson","tags":["Persons"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"title":"updatePersonRequest","allOf":[{"$ref":"#/components/schemas/s_person_request"}]}}}},"responses":{"200":{"description":"Success","content":{"application/json":{"schema":{"title":"updatePersonResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"object","title":"personItem","allOf":[{"$ref":"#/components/schemas/s_person_item"},{"$ref":"#/components/schemas/s_person_additional_info"}]},"related_objects":{"$ref":"#/components/schemas/s_related_objects_USER"}}}]}}}}}}},"/persons/{id}/activities":{"get":{"summary":"List activities associated with a person","description":"Lists activities associated with a person.","operationId":"getPersonActivities","tags":["Persons"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_activity_done"},{"$ref":"#/components/parameters/p_query_activity_exclude"}],"responses":{"200":{"description":"Success","content":{"application/json":{"schema":{"title":"getAssociatedActivitiesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"title":"activityResponseObject","allOf":[{"$ref":"#/components/schemas/s_activity_extended"},{"$ref":"#/components/schemas/s_activity"}]},"description":"The array of activities"},"additional_data":{"title":"activityDistributionDataWithAdditionalData","allOf":[{"$ref":"#/components/schemas/s_additional_data_pagination"}]}}}]}}}}}}},"/persons/{id}/deals":{"get":{"summary":"List deals associated with a person","description":"Lists deals associated with a person.","operationId":"getPersonDeals","tags":["Persons"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_status"},{"$ref":"#/components/parameters/p_query_sort"}],"responses":{"200":{"description":"Success Listing deals associated with a person","content":{"application/json":{"schema":{"title":"getAssociatedDealsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"The array of deals","items":{"$ref":"#/components/schemas/s_deal_non_strict"}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_2E_U_S_P"}}}]}}}}}}},"/persons/{id}/flow":{"get":{"summary":"List updates about a person","description":"Lists updates about a person.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint\'s response will also include updates for the `marketing_status` field.","operationId":"getPersonUpdates","tags":["Persons"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_all_changes"},{"$ref":"#/components/parameters/p_query_person_items"}],"responses":{"200":{"description":"Success Listing updates about a person","content":{"application/json":{"schema":{"title":"getAssociatedPersonUpdatesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"type":"object","properties":{"object":{"type":"string","description":"The type of the person update."},"timestamp":{"type":"string","description":"The creation date and time of the update"},"data":{"type":"object","description":"The data related to the update"}}}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_3E_U"}}}]}}}}}}},"/persons/{id}/products":{"get":{"summary":"List products associated with a person","description":"Lists products associated with a person.","operationId":"getPersonProducts","tags":["Persons"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"}],"responses":{"200":{"description":"Success Listing products associated with a person","content":{"application/json":{"schema":{"title":"getPersonProductsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"The array of deal products","items":{"$ref":"#/components/schemas/s_person_products"}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}}},"/personFields":{"get":{"summary":"Get all person fields","description":"Returns data about all person fields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.","operationId":"getPersonFields","parameters":[{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_start"}],"tags":["PersonFields"],"security":[{"bearerAuth":[]}],"responses":{"200":{"description":"Success getting all person fields","content":{"application/json":{"schema":{"title":"getPersonFieldsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"data":{"$ref":"#/components/schemas/s_field"}}}]}}}}}},"post":{"summary":"Add a new person field","description":"Adds a new person field. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">adding a new custom field</a>.","operationId":"addPersonField","tags":["PersonFields"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"title":"createFieldRequest","allOf":[{"$ref":"#/components/schemas/s_field_post_body"}]}}}},"responses":{"200":{"description":"Success adding a new person field","content":{"application/json":{"schema":{"title":"AddPersonFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field"}}}]}}}}}},"delete":{"summary":"Delete multiple person fields in bulk","description":"Marks multiple fields as deleted.","operationId":"deletePersonFields","tags":["PersonFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_ids"}],"responses":{"200":{"description":"Success deleting multiple person fields in bulk","content":{"application/json":{"schema":{"title":"deletePersonFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted_list"}}}]}}}}}}},"/personFields/{id}":{"get":{"summary":"Get one person field","description":"Returns data about a specific person field.","operationId":"getPersonField","tags":["PersonFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_field_id"}],"responses":{"200":{"description":"Success getting one person field","content":{"application/json":{"schema":{"title":"getPersonFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field"}}}]}}}}}},"delete":{"summary":"Delete a person field","description":"Marks a field as deleted. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/deleting-a-custom-field\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">deleting a custom field</a>.","operationId":"deletePersonField","tags":["PersonFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_field_id"}],"responses":{"200":{"description":"Success deleting a person field","content":{"application/json":{"schema":{"title":"deletePersonFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field_response_delete_id"}}}]}}}}}},"put":{"summary":"Update a person field","description":"Updates a person field. For more information, see the tutorial for <a href=\\" https://pipedrive.readme.io/docs/updating-custom-field-value \\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">updating custom fields\' values</a>.","operationId":"updatePersonField","tags":["PersonFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_field_id"}],"requestBody":{"content":{"application/json":{"schema":{"title":"updateFieldRequest","allOf":[{"$ref":"#/components/schemas/s_field_put_body"}]}}}},"responses":{"200":{"description":"Success updating a person field","content":{"application/json":{"schema":{"title":"updatePersonFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field"}}}]}}}}}}},"/pipelines":{"get":{"summary":"Get all pipelines","description":"Returns data about all pipelines.","operationId":"getPipelines","tags":["Pipelines"],"security":[{"bearerAuth":[]}],"responses":{"200":{"description":"Get all pipelines","content":{"application/json":{"schema":{"type":"object","title":"getPipelinesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"Pipelines array","items":{"type":"object","title":"basePipelineWithSelectedFlag","allOf":[{"$ref":"#/components/schemas/s_pipeline_base_w_selected_flag"}]}}}}]}}}}}},"post":{"summary":"Add a new pipeline","description":"Adds a new pipeline.","operationId":"addPipeline","tags":["Pipelines"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"allOf":[{"type":"object","title":"pipelineRequestRequiredName","required":["name"]},{"$ref":"#/components/schemas/s_pipeline_request"}]}}}},"responses":{"200":{"description":"Success Adding a new pipeline","content":{"application/json":{"schema":{"type":"object","title":"addPipelineResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_pipeline_base"}}}]}}}}}}},"/pipelines/{id}":{"delete":{"summary":"Delete a pipeline","description":"Marks a pipeline as deleted.","operationId":"deletePipeline","tags":["Pipelines"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success Deleting a pipeline","content":{"application/json":{"schema":{"title":"deletePipelineResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted"}}}]}}}}}},"get":{"summary":"Get one pipeline","description":"Returns data about a specific pipeline.  Also returns the summary of the deals in this pipeline across its stages.","operationId":"getPipeline","tags":["Pipelines"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_pipeline_totals_convert_currency"}],"responses":{"200":{"description":"Success Getting one pipeline","content":{"application/json":{"schema":{"type":"object","title":"getPipelineResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"object","description":"The pipeline object","title":"pipelineDetails","allOf":[{"$ref":"#/components/schemas/s_pipeline_base_w_selected_flag"}]}}}]}}}}}},"put":{"summary":"Update a pipeline","description":"Updates the properties of a pipeline.","operationId":"updatePipeline","tags":["Pipelines"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_pipeline_request"}}}},"responses":{"200":{"description":"Success Updating a pipeline","content":{"application/json":{"schema":{"type":"object","title":"updatePipelineResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"object","description":"The pipeline object","allOf":[{"$ref":"#/components/schemas/s_pipeline_base_w_selected_flag"}]}}}]}}}}}}},"/pipelines/{id}/deals":{"get":{"summary":"Get deals in a pipeline","description":"Lists deals in a specific pipeline across all its stages.","operationId":"getPipelineDeals","tags":["Pipelines"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_filter_id"},{"$ref":"#/components/parameters/p_query_pipeline_user_id"},{"$ref":"#/components/parameters/p_query_pipeline_everyone"},{"$ref":"#/components/parameters/p_query_deal_stage_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_pipeline_get_summary"},{"$ref":"#/components/parameters/p_query_pipeline_totals_convert_currency"}],"responses":{"200":{"description":"Success Get deals in a pipeline","content":{"application/json":{"schema":{"title":"getStageDealsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"The array of deals","items":{"$ref":"#/components/schemas/s_deal_strict"}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}}},"/products":{"get":{"summary":"Get all products","description":"Returns data about all products.","operationId":"getProducts","tags":["Products"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_product_user_id"},{"$ref":"#/components/parameters/p_query_filter_id"},{"$ref":"#/components/parameters/p_query_product_ids"},{"$ref":"#/components/parameters/p_query_first_char"},{"$ref":"#/components/parameters/p_query_product_get_summary"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"}],"responses":{"200":{"description":"Success Getting all products","content":{"application/json":{"schema":{"title":"getProductsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"Array containing data for all products","items":{"title":"subGetProductResponseCode200","type":"object","properties":{"data":{"$ref":"#/components/schemas/s_product_w_owner_obj"}}}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_3E_U"}}}]}}}}}},"post":{"summary":"Add a product","description":"Adds a new product to the Products inventory.  For more information, see the tutorial for <a  href=\\"https://pipedrive.readme.io/docs/adding-a-product\\"  target=\\"_blank\\" rel=\\"noopener noreferrer\\">adding a product</a>.","operationId":"addProduct","tags":["Products"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"allOf":[{"type":"object","title":"addProductRequest"},{"$ref":"#/components/schemas/s_product_request_crud"}]}}}},"responses":{"201":{"description":"Success Adding product data","content":{"application/json":{"schema":{"title":"getproductResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_product_w_owner_obj"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_3E_U"}}}]}}}}}}},"/products/{id}":{"delete":{"summary":"Delete a product","description":"Marks a product as deleted.","operationId":"deleteProduct","tags":["Products"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success Deleting a product","content":{"application/json":{"schema":{"title":"deleteProductResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted"}}}]}}}}}},"get":{"summary":"Get one product","description":"Returns data about a specific product.","operationId":"getProduct","tags":["Products"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success Getting one product","content":{"application/json":{"schema":{"title":"getproductResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_product_w_owner_obj"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_3E_U"}}}]}}}}}},"put":{"summary":"Update a product","description":"Updates product data.","operationId":"updateProduct","tags":["Products"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"allOf":[{"type":"object","title":"updateProductRequest"},{"$ref":"#/components/schemas/s_product_request_crud"}]}}}},"responses":{"200":{"description":"Updates product data","content":{"application/json":{"schema":{"title":"updateProductResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_product_w_owner_obj"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_3E_U"}}}]}}}}}}},"/products/{id}/deals":{"get":{"summary":"Get deals where a product is attached to","description":"Returns data about deals that have a product attached to it.","operationId":"getProductDeals","tags":["Products"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_status"}],"responses":{"200":{"description":"The data of deals that have a product attached","content":{"application/json":{"schema":{"title":"getAssociatedDealsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"The array of deals","items":{"$ref":"#/components/schemas/s_deal_non_strict"}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_2E_U_S_P"}}}]}}}}}}},"/productFields":{"delete":{"summary":"Delete multiple product fields in bulk","description":"Marks multiple fields as deleted.","operationId":"deleteProductFields","tags":["ProductFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_ids"}],"responses":{"200":{"description":"Success deleting multiple product fields in bulk","content":{"application/json":{"schema":{"title":"deleteProductFieldsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted_list"}}}]}}}}}},"get":{"summary":"Get all product fields","description":"Returns data about all product fields.","operationId":"getProductFields","parameters":[{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_start"}],"tags":["ProductFields"],"security":[{"bearerAuth":[]}],"responses":{"200":{"description":"Success getting all product fields","content":{"application/json":{"schema":{"title":"getProductFieldsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"Array containing data for all product fields","items":[{"$ref":"#/components/schemas/s_field"}]},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}},"post":{"summary":"Add a new product field","description":"Adds a new product field. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">adding a new custom field</a>.","operationId":"addProductField","tags":["ProductFields"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_field_post_body"}}}},"responses":{"201":{"description":"Success adding a new product field","content":{"application/json":{"schema":{"title":"getProductFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field"}}}]}}}}}}},"/productFields/{id}":{"delete":{"summary":"Delete a product field","description":"Marks a product field as deleted. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/deleting-a-custom-field\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">deleting a custom field</a>.","operationId":"deleteProductField","tags":["ProductFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_field_id"}],"responses":{"200":{"description":"Success deleting a product field","content":{"application/json":{"schema":{"title":"deleteProductFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted"}}}]}}}},"410":{"description":"The product field with the specified ID does not exist or is inaccessible","content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_fail_response"}}}}}},"get":{"summary":"Get one product field","description":"Returns data about a specific product field.","operationId":"getProductField","tags":["ProductFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_field_id"}],"responses":{"200":{"description":"Success getting one product field","content":{"application/json":{"schema":{"title":"getProductFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field"}}}]}}}},"410":{"description":"The product field with the specified ID does not exist or is inaccessible","content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_fail_response"}}}}}},"put":{"summary":"Update a product field","description":"Updates a product field. For more information, see the tutorial for <a href=\\" https://pipedrive.readme.io/docs/updating-custom-field-value \\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">updating custom fields\' values</a>.","operationId":"updateProductField","tags":["ProductFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_field_id"}],"requestBody":{"content":{"application/json":{"schema":{"allOf":[{"$ref":"#/components/schemas/s_attr_field_options"},{"$ref":"#/components/schemas/s_attr_field_name"},{"title":"UpdateProductFieldResponse200","type":"object"}]}}}},"responses":{"200":{"description":"Success updating a product field","content":{"application/json":{"schema":{"title":"getProductFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field"}}}]}}}}}}},"/recents":{"get":{"summary":"Get recents","description":"Returns data about all recent changes occurred after the given timestamp.","operationId":"getRecents","deprecated":true,"tags":["Recents"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_recent_since_timestamp"},{"$ref":"#/components/parameters/p_query_recent_items"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_start"}],"responses":{"200":{"description":"List of items changed since \\"since_timestamp\\"","content":{"application/json":{"schema":{"title":"getRecentsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"anyOf":[{"$ref":"#/components/schemas/s_item_activity"},{"$ref":"#/components/schemas/s_item_activity_type"},{"$ref":"#/components/schemas/s_item_deal"},{"$ref":"#/components/schemas/s_item_file"},{"$ref":"#/components/schemas/s_item_filter"},{"$ref":"#/components/schemas/s_item_note"},{"$ref":"#/components/schemas/s_item_person"},{"$ref":"#/components/schemas/s_item_organization"},{"$ref":"#/components/schemas/s_item_pipeline"},{"$ref":"#/components/schemas/s_item_product"},{"$ref":"#/components/schemas/s_item_stage"},{"$ref":"#/components/schemas/s_item_user"}]}},"additional_data":{"allOf":[{"type":"object","properties":{"since_timestamp":{"type":"string","description":"The timestamp in UTC. Format: YYYY-MM-DD HH:MM:SS"},"last_timestamp_on_page":{"type":"string","description":"The timestamp in UTC. Format: YYYY-MM-DD HH:MM:SS"}}},{"$ref":"#/components/schemas/s_additional_data_pagination"}]}}}]}}}}}}},"/roles":{"get":{"summary":"Get all roles","description":"Returns all the roles within the company.","operationId":"getRoles","tags":["Roles"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_start"}],"responses":{"200":{"description":"Success Getting all roles","content":{"application/json":{"schema":{"title":"getRolesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"$ref":"#/components/schemas/s_role_fullrole"},"description":"The array of roles"},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}},"post":{"summary":"Add a role","description":"Adds a new role.","operationId":"addRole","tags":["Roles"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"allOf":[{"$ref":"#/components/schemas/s_attr_role_name"},{"$ref":"#/components/schemas/s_attr_role_parent_role_id"},{"type":"object","title":"addRoleRequest","description":"The details of the role","required":["name"]}]}}}},"responses":{"200":{"description":"Success Adding a role","content":{"application/json":{"schema":{"title":"addRoleResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_created"}}}]}}}}}}},"/roles/{id}":{"delete":{"summary":"Delete a role","description":"Marks a role as deleted.","operationId":"deleteRole","tags":["Roles"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success Deleting a role","content":{"application/json":{"schema":{"title":"deleteRoleResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted"}}}]}}}}}},"get":{"summary":"Get one role","description":"Returns the details of a specific role.","operationId":"getRole","tags":["Roles"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success Getting one role","content":{"application/json":{"schema":{"title":"getRoleResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_role_subrole"},"additional_data":{"type":"object","description":"The additional data in the role","properties":{"settings":{"$ref":"#/components/schemas/s_role_settings_default_visibility"}}}}}]}}}}}},"put":{"summary":"Update role details","description":"Updates the parent role and/or the name of a specific role.","operationId":"updateRole","tags":["Roles"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_role_base_request"}}}},"responses":{"200":{"description":"Success Updating role details","content":{"application/json":{"schema":{"title":"updateRoleResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_updated"}}}]}}}}}}},"/roles/{id}/assignments":{"delete":{"summary":"Delete a role assignment","description":"Removes the assigned user from a role and adds to the default role.","operationId":"deleteRoleAssignment","deprecated":true,"tags":["Roles"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"allOf":[{"$ref":"#/components/schemas/s_attr_user_user_id"},{"title":"deleteRoleAssignmentRequest","type":"object","required":["user_id"]}]}}}},"responses":{"200":{"description":"Delete assignment from a role","content":{"application/json":{"schema":{"title":"deleteRoleAssignmentResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted"}}}]}}}}}},"get":{"summary":"List role assignments","description":"Returns all users assigned to a role.","operationId":"getRoleAssignments","deprecated":true,"tags":["Roles"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"}],"responses":{"200":{"description":"Success Listing role assignments","content":{"application/json":{"schema":{"title":"getUserRoleAssignmentsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"$ref":"#/components/schemas/s_role_assignment"},"description":"The role assignments"},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}},"post":{"summary":"Add role assignment","description":"Assigns a user to a role.","operationId":"addRoleAssignment","deprecated":true,"tags":["Roles"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"allOf":[{"$ref":"#/components/schemas/s_attr_user_user_id"},{"title":"addRoleAssignmentRequest","type":"object","required":["user_id"]}]}}}},"responses":{"200":{"description":"Success Adding a role assignment","content":{"application/json":{"schema":{"title":"addRoleAssignmentResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"allOf":[{"$ref":"#/components/schemas/s_attr_user_role_id"},{"$ref":"#/components/schemas/s_attr_user_user_id"}]}}}]}}}}}}},"/roles/{id}/settings":{"get":{"summary":"List role settings","description":"Returns the visibility settings of a specific role.","operationId":"getRoleSettings","deprecated":true,"tags":["Roles"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success Listing role settings","content":{"application/json":{"schema":{"title":"getRoleSettingsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_role_settings_default_visibility"}}}]}}}}}},"post":{"summary":"Add or update role setting","description":"Adds or updates the visibility setting for a role.","operationId":"addOrUpdateRoleSetting","deprecated":true,"tags":["Roles"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_role_setting_post"}}}},"responses":{"200":{"description":"List role settings","content":{"application/json":{"schema":{"title":"addOrUpdateRoleSettingResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"allOf":[{"$ref":"#/components/schemas/s_attr_role_id"},{"type":"object","properties":{"deal_default_visibility":{"type":"number","enum":[1,3,5,7],"description":"The setting"}}}],"description":"The response data"}}}]}}}}}}},"/roles/{id}/pipelines":{"get":{"summary":"List pipeline visibility for a role","description":"Returns the list of either visible or hidden pipeline IDs for a specific role.  For more information on pipeline visibility, please refer to the <a href=\\"https://support.pipedrive.com/en/article/visibility-groups\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Visibility groups article</a>.","operationId":"getRolePipelines","deprecated":true,"tags":["Roles"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_visible"}],"responses":{"200":{"description":"Get either visible or hidden pipeline ids for a role","content":{"application/json":{"schema":{"title":"getRolePipelinesCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_role_pipelines"}}}]}}}}}},"put":{"summary":"Update pipeline visibility for a role","description":"Updates the specified pipelines to be visible and/or hidden for a specific role. For more information on pipeline visibility, please refer to the <a href=\\"https://support.pipedrive.com/en/article/visibility-groups\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Visibility groups article</a>.","operationId":"updateRolePipelines","deprecated":true,"tags":["Roles"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_attr_role_visible_pipeline_ids"}}}},"responses":{"200":{"description":"Update pipeline visibility for a role","content":{"application/json":{"schema":{"title":"getRolePipelinesCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_role_pipelines"}}}]}}}}}}},"/stages":{"delete":{"summary":"Delete multiple stages in bulk","description":"Marks multiple stages as deleted.","operationId":"deleteStages","tags":["Stages"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_ids"}],"responses":{"200":{"description":"Delete multiple stages","content":{"application/json":{"schema":{"title":"deleteStagesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted_list"}}}]}}}}}},"get":{"summary":"Get all stages","description":"Returns data about all stages.","operationId":"getStages","tags":["Stages"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_stage_pipeline_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"}],"responses":{"200":{"description":"Success Getting all stages","content":{"application/json":{"schema":{"title":"getStagesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"The array of stages","items":{"$ref":"#/components/schemas/s_stage"}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}},"post":{"summary":"Add a new stage","description":"Adds a new stage, returns the ID upon success.","operationId":"addStage","tags":["Stages"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"allOf":[{"title":"addStageRequest","required":["name","pipeline_id"],"type":"object"},{"$ref":"#/components/schemas/s_stage_request_basic"}]}}}},"responses":{"200":{"description":"Success Adding a new stage","content":{"application/json":{"schema":{"title":"stageResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","description":"Updated stage object","properties":{"data":{"$ref":"#/components/schemas/s_stage_base"}}}]}}}}}}},"/stages/{id}":{"delete":{"summary":"Delete a stage","description":"Marks a stage as deleted.","operationId":"deleteStage","tags":["Stages"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Delete stage","content":{"application/json":{"schema":{"title":"deleteStageResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted"}}}]}}}}}},"get":{"summary":"Get one stage","description":"Returns data about a specific stage.","operationId":"getStage","tags":["Stages"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_stage_everyone"}],"responses":{"200":{"description":"Success Gettting a stage","content":{"application/json":{"schema":{"title":"getStageResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"object","description":"The stage object","allOf":[{"$ref":"#/components/schemas/s_stage_base"},{"$ref":"#/components/schemas/s_deal_summary"}]}}}]}}}}}},"put":{"summary":"Update stage details","description":"Updates the properties of a stage.","operationId":"updateStage","tags":["Stages"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"title":"updateStageRequest","$ref":"#/components/schemas/s_stage_request_w_order_nbr"}}}},"responses":{"200":{"description":"Success Updating stage details","content":{"application/json":{"schema":{"title":"stageResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","description":"Updated stage object","properties":{"data":{"$ref":"#/components/schemas/s_stage_base"}}}]}}}}}}},"/stages/{id}/deals":{"get":{"summary":"Get deals in a stage","description":"Lists deals in a specific stage.","operationId":"getStageDeals","deprecated":true,"tags":["Stages"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_filter_id"},{"$ref":"#/components/parameters/p_query_stage_user_id"},{"$ref":"#/components/parameters/p_query_pipeline_everyone"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"}],"responses":{"200":{"description":"Success Getting deals in a stage","content":{"application/json":{"schema":{"title":"getStageDealsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"The array of deals","items":{"$ref":"#/components/schemas/s_deal_strict"}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}}},"/users":{"get":{"summary":"Get all users","description":"Returns data about all users within the company.","operationId":"getUsers","tags":["Users"],"security":[{"bearerAuth":[]}],"responses":{"200":{"description":"The list of user objects","content":{"application/json":{"schema":{"title":"usersResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"$ref":"#/components/schemas/s_user"}}}}]}}}}}},"post":{"summary":"Add a new user","description":"Adds a new user to the company, returns the ID upon success.","operationId":"addUser","tags":["Users"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"title":"addUserRequest","type":"object","required":["email"],"allOf":[{"$ref":"#/components/schemas/s_user_access"},{"$ref":"#/components/schemas/s_attr_user_email"},{"$ref":"#/components/schemas/s_attr_active_flag"}]}}}},"responses":{"200":{"description":"The data of the user","content":{"application/json":{"schema":{"title":"userResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_user"}}}]}}}},"403":{"description":"Forbidden response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_fail_response"}}}}}}},"/users/find":{"get":{"summary":"Find users by name","description":"Finds users by their name.","operationId":"findUsersByName","tags":["Users"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_is_term"},{"$ref":"#/components/parameters/p_query_user_search_by_email"}],"responses":{"200":{"description":"The list of user objects","content":{"application/json":{"schema":{"title":"usersResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"$ref":"#/components/schemas/s_user"}}}}]}}}}}}},"/users/me":{"get":{"summary":"Get current user data","description":"Returns data about an authorized user within the company with bound company data: company ID, company name, and domain. Note that the `locale` property means \'Date/number format\' in the Pipedrive account settings, not the chosen language.","operationId":"getCurrentUser","tags":["Users"],"security":[{"bearerAuth":[]}],"responses":{"200":{"description":"The data of the logged in user","content":{"application/json":{"schema":{"title":"getCurrentUserResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_user_w_company"}}}]}}}},"401":{"description":"Unauthorized response","content":{"application/json":{"schema":{"allOf":[{"type":"object","title":"unathorizedResponse"},{"$ref":"#/components/schemas/s_fail_response"}]}}}}}}},"/users/{id}":{"get":{"summary":"Get one user","description":"Returns data about a specific user within the company.","operationId":"getUser","tags":["Users"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success Getting one user","content":{"application/json":{"schema":{"title":"userResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_user"}}}]}}}},"404":{"description":"User with specified ID does not exist or is inaccessible","content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_fail_response"}}}}}},"put":{"summary":"Update user details","description":"Updates the properties of a user. Currently, only `active_flag` can be updated.","operationId":"updateUser","tags":["Users"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"allOf":[{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"title":"updateUserRequest","type":"object","required":["active_flag"]}]}}}},"responses":{"200":{"description":"Success Updating user details","content":{"application/json":{"schema":{"title":"userResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_user"}}}]}}}},"403":{"description":"Forbidden response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_fail_response"}}}},"404":{"description":"User with specified ID does not exist or is inaccessible","content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_fail_response"}}}}}}}},"components":{"securitySchemes":{"bearerAuth":{"type":"http","scheme":"bearer","bearerFormat":"JWT","description":"Enter the token with the `Bearer: ` prefix, e.g. \\"Bearer abcde12345\\"."}},"parameters":{"p_query_activity_user_id":{"in":"query","name":"user_id","required":false,"schema":{"type":"integer"},"description":"The ID of the user whose activities will be fetched. If omitted, the user associated with the API token will be used. If 0, activities for all company users will be fetched based on the permission sets."},"p_query_filter_id":{"in":"query","name":"filter_id","required":false,"schema":{"type":"integer"},"description":"The ID of the filter to use (will narrow down results if used together with `user_id` parameter)"},"p_query_activity_type":{"in":"query","name":"type","required":false,"schema":{"type":"string"},"description":"The type of the activity, can be one type or multiple types separated by a comma. This is in correlation with the `key_string` parameter of ActivityTypes."},"p_query_limit":{"name":"limit","in":"query","description":"Limits the number of returned results. If not provided, 100 items will be returned.","required":false,"schema":{"type":"integer","format":"int32","minimum":1,"default":100,"example":100}},"p_query_start":{"in":"query","name":"start","description":"For pagination, the position that represents the first result for the page.","schema":{"type":"integer","default":0}},"p_query_activity_start_date":{"in":"query","name":"start_date","required":false,"schema":{"type":"string","format":"date"},"description":"Use the activity due date where you wish to begin fetching activities from. Insert due date in YYYY-MM-DD format."},"p_query_activity_end_date":{"in":"query","name":"end_date","required":false,"schema":{"type":"string","format":"date"},"description":"Use the activity due date where you wish to stop fetching activities from. Insert due date in YYYY-MM-DD format."},"p_query_activity_done":{"in":"query","name":"done","schema":{"title":"doneNumberBoolean","type":"number","enum":[0,1]},"description":"Whether the activity is done or not. 0 = Not done, 1 = Done. If omitted, returns both Done and Not done activities."},"p_query_ids":{"in":"query","name":"ids","required":true,"description":"The comma-separated IDs that will be deleted","schema":{"type":"string"}},"p_path_id":{"in":"path","name":"id","description":"The ID of the Entity we want to retrieve.","required":true,"schema":{"type":"integer"}},"p_query_currency_term":{"in":"query","name":"term","description":"Optional search term that is searched for from currency\'s name and/or code","schema":{"type":"string"}},"p_query_deal_user_id":{"in":"query","name":"user_id","schema":{"type":"integer"},"description":"If supplied, only deals matching the given user will be returned. However, `filter_id` and `owned_by_you` takes precedence over `user_id` when supplied (if any of them apply for this endpoint)."},"p_query_deal_stage_id":{"in":"query","name":"stage_id","schema":{"type":"integer"},"description":"If supplied, only deals within the given stage will be returned"},"p_query_status":{"in":"query","name":"status","schema":{"type":"string","default":"all_not_deleted","enum":["open","won","lost","deleted","all_not_deleted"]},"description":"Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included. The upper limit of found deals  associated with the status is 2000."},"p_query_sort":{"in":"query","name":"sort","schema":{"type":"string"},"description":"The field names and sorting mode separated by a comma  (`field_name_1 ASC`, `field_name_2 DESC`).  Only first-level field keys are supported (no nested keys)."},"p_query_deal_owned_by_you":{"in":"query","name":"owned_by_you","description":"When supplied, only deals owned by you are returned. However, `filter_id` takes precedence over `owned_by_you` when both are supplied.","schema":{"title":"ownedNumberBoolean","type":"number","enum":[0,1]}},"p_query_is_term":{"in":"query","name":"term","required":true,"schema":{"type":"string"},"description":"The search term to look for. Minimum 2 characters (or 1 if using `exact_match`). Please note that the search term has to be URL encoded."},"p_query_deal_fields":{"in":"query","name":"fields","schema":{"type":"string","enum":["custom_fields","notes","title"]},"description":"A comma-separated string array. \\nThe fields to perform the search from. \\nDefaults to all of them. \\nOnly the following custom field types are searchable:  `address`, `varchar`, `text`, and `phone`. \\nRead more about searching by custom fields [here](../../kb/getting-started/search-finding-what-you-need#searching-by-custom-fields)"},"p_query_is_exact_match":{"in":"query","name":"exact_match","schema":{"type":"boolean"},"description":"When enabled, only full exact matches against the given term are returned. It is <b>not</b> case sensitive."},"p_query_is_person_id":{"in":"query","name":"person_id","schema":{"type":"integer"},"description":"Will filter deals by the provided person ID. The upper limit of found deals associated with the person is 2000."},"p_query_is_organization_id":{"in":"query","name":"organization_id","schema":{"type":"integer"},"description":"Will filter items by the provided organization ID. The upper limit of found items associated with the organization is 2000."},"p_query_is_start":{"in":"query","name":"start","description":"For pagination, the position that represents the first result for the page. Note that the pagination is based on main results and does not include related items when using `search_for_related_items` parameter.","schema":{"type":"integer","default":0}},"p_query_deal_filter_id":{"in":"query","name":"filter_id","schema":{"type":"integer"},"description":"<code>user_id</code> will not be considered. Only deals matching the given filter will be returned."},"p_query_deal_start_date":{"in":"query","name":"start_date","required":true,"schema":{"type":"string","format":"date"},"description":"The date when the first interval starts. Format: YYYY-MM-DD."},"p_query_deal_interval":{"in":"query","name":"interval","required":true,"schema":{"type":"string","enum":["day","week","month","quarter"]},"description":"The type of the interval<table><tr><th>Value</th><th>Description</th></tr><tr><td>`day`</td><td>Day</td></tr><tr><td>`week`</td><td>A full week (7 days) starting from `start_date`</td></tr><tr><td>`month`</td><td>A full month (depending on the number of days in given month) starting from `start_date`</td></tr><tr><td>`quarter`</td><td>A full quarter (3 months) starting from `start_date`</td></tr></table>"},"p_query_deal_amount":{"in":"query","name":"amount","required":true,"schema":{"type":"integer"},"description":"The number of given intervals, starting from `start_date`, to fetch. E.g. 3 (months)."},"p_query_deal_field_key":{"in":"query","name":"field_key","required":true,"schema":{"type":"string"},"description":"The date field key which deals will be retrieved from"},"p_query_deal_pipeline_id":{"in":"query","name":"pipeline_id","schema":{"type":"integer"},"description":"If supplied, only deals matching the given pipeline will be returned"},"p_query_deal_exclude_deals":{"in":"query","name":"exclude_deals","schema":{"title":"excludeNumberBoolean","type":"number","enum":[0,1]},"description":"Whether to exclude deals list (1) or not (0). Note that when deals are excluded, the timeline summary (counts and values) is still returned."},"p_query_pipeline_totals_convert_currency":{"in":"query","name":"totals_convert_currency","schema":{"type":"string"},"description":"The 3-letter currency code of any of the supported currencies. When supplied, `per_stages_converted` is returned inside `deals_summary` inside `additional_data` which contains the currency-converted total amounts in the given currency per each stage. You may also set this parameter to `default_currency` in which case users default currency is used. If `get_summary` is present in this endpoint, Only works  when `get_summary` parameter flag is enabled."},"p_query_activity_exclude":{"in":"query","name":"exclude","schema":{"type":"string"},"description":"A comma-separated string of activity IDs to exclude from result"},"p_query_all_changes":{"in":"query","name":"all_changes","description":"Whether to show custom field updates or not. 1 = Include custom field changes. If omitted, returns changes without custom field updates.","schema":{"type":"string"}},"p_query_deal_items":{"in":"query","name":"items","description":"A comma-separated string for filtering out item specific updates. (Possible values - activity, note, deal, dealChange, personChange, organizationChange).","schema":{"type":"string"}},"p_query_deal_include_product_data":{"in":"query","name":"include_product_data","description":"Whether to fetch product data along with each attached product (1) or not (0, default)","schema":{"title":"queryNumberBoolean","type":"number","enum":[0,1]}},"p_path_product_attachment_id":{"in":"path","name":"product_attachment_id","required":true,"schema":{"type":"integer"},"description":"The ID of the deal-product (the ID of the product attached to the deal)"},"p_path_field_id":{"in":"path","name":"id","description":"The ID of the Entity Field we want to retrieve.","required":true,"schema":{"type":"integer"}},"p_query_filter_type":{"in":"query","name":"type","schema":{"type":"string","enum":["deals","org","persons","products","activity"]},"description":"The types of filters to fetch"},"p_query_is_item_types":{"in":"query","name":"item_types","schema":{"type":"string","enum":["deal","person","organization","product","lead","file","mail_attachment","project"]},"description":"A comma-separated string array. The type of items to perform the search from. Defaults to all."},"p_query_is_fields":{"in":"query","name":"fields","schema":{"type":"string","enum":["address","code","custom_fields","email","name","notes","organization_name","person_name","phone","title","description"]},"description":"A comma-separated string array. The fields to perform the search from. Defaults to all. Relevant for each item type are:\\n<br>  <table>\\n  <tr>\\n      <th><b>Item type</b></th>\\n      <th><b>Field</b></th>\\n  </tr>\\n  <tr>\\n      <td>Deal</td>\\n      <td>`custom_fields`, `notes`, `title`\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>Person</td>\\n      <td>`custom_fields`, `email`, `name`, `notes`, `phone`\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>Organization</td>\\n      <td>`address`, `custom_fields`, `name`, `notes`\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>Product</td>\\n      <td>`code`, `custom_fields`, `name`\\n      </td>\\n  </tr>\\n</table> <br>\\nOnly the following custom field types are searchable:  `address`, `varchar`, `text`, and `phone`. \\nRead more about searching by custom fields  [here](../../kb/getting-started/search-finding-what-you-need#searching-by-custom-fields)."},"p_query_is_search_for_related_items":{"in":"query","name":"search_for_related_items","schema":{"type":"boolean"},"description":"When enabled, the response will include up to 100 newest related leads and 100 newest related deals for each found person and organization and up to 100 newest related persons for each found organization"},"p_query_is_include_fields":{"in":"query","name":"include_fields","schema":{"type":"string","enum":["deal.cc_email","person.picture","product.price"]},"description":"A comma-separated string array. Supports including optional fields in the results which are not provided by default."},"p_query_is_field_type":{"in":"query","name":"field_type","required":true,"schema":{"type":"string","enum":["dealField","personField","organizationField","productField"]},"description":"The type of the field to perform the search from"},"p_query_is_field_key":{"in":"query","name":"field_key","required":true,"schema":{"type":"string"},"description":"The key of the field to search from. \\nThe field key can be obtained by fetching the list of  the fields using any of the fields\' API GET methods (dealFields, personFields, etc.). \\nOnly the following custom field types are searchable:  `address`, `varchar`, `text`, and `phone`. \\nRead more about searching by custom fields  [here](../../kb/getting-started/search-finding-what-you-need#searching-by-custom-fields)."},"p_query_is_return_item_ids":{"in":"query","name":"return_item_ids","schema":{"type":"boolean"},"description":"Whether to return the IDs of the matching items or not. When not set or set to `0` or `false`, only distinct values of the searched field are returned. When set to `1` or `true`, the ID of each found item is returned."},"p_query_note_user_id":{"in":"query","name":"user_id","schema":{"type":"integer"},"description":"The ID of the user whose notes to fetch. If omitted, notes by all users will be returned."},"p_query_note_deal_id":{"in":"query","name":"deal_id","schema":{"type":"integer"},"description":"The ID of the deal which notes to fetch. If omitted, notes about all deals will be returned."},"p_query_note_person_id":{"in":"query","name":"person_id","schema":{"type":"integer"},"description":"The ID of the person whose notes to fetch. If omitted, notes about all persons will be returned."},"p_query_note_org_id":{"in":"query","name":"org_id","schema":{"type":"integer"},"description":"The ID of the organization which notes to fetch. If omitted, notes about all organizations will be returned."},"p_query_note_sort":{"in":"query","name":"sort","schema":{"type":"string"},"description":"The field names and sorting mode separated by a comma (`field_name_1 ASC`, `field_name_2 DESC`).  Only first-level field keys are supported (no nested keys).  Supported fields:  `id`, `user_id`, `deal_id`, `person_id`, `org_id`, `content`,  `add_time`, `update_time`."},"p_query_note_start_date":{"in":"query","name":"start_date","schema":{"type":"string","format":"date"},"description":"The date in format of YYYY-MM-DD from which notes to fetch"},"p_query_note_end_date":{"in":"query","name":"end_date","schema":{"type":"string","format":"date"},"description":"The date in format of YYYY-MM-DD until which notes to fetch to"},"p_query_note_pinned_to_deal_flag":{"in":"query","name":"pinned_to_deal_flag","schema":{"title":"numberBoolean","type":"number","enum":[0,1]},"description":"If set, the results are filtered by note to deal pinning state"},"p_query_note_pinned_to_organization_flag":{"in":"query","name":"pinned_to_organization_flag","schema":{"title":"numberBoolean","type":"number","enum":[0,1]},"description":"If set, the results are filtered by note to organization pinning state"},"p_query_note_pinned_to_person_flag":{"in":"query","name":"pinned_to_person_flag","schema":{"title":"numberBoolean","type":"number","enum":[0,1]},"description":"If set, the results are filtered by note to person pinning state"},"p_path_note_comment_id":{"in":"path","name":"commentId","description":"The ID of the comment","required":true,"schema":{"type":"string","format":"uuid"}},"p_query_org_user_id":{"in":"query","name":"user_id","schema":{"type":"integer"},"description":"If supplied, only organizations owned by the given user will be returned. However, `filter_id` takes precedence over `user_id` when both are supplied."},"p_query_first_char":{"in":"query","name":"first_char","schema":{"type":"string"},"description":"If supplied, only entities whose name starts with the specified letter will be returned (case-insensitive)"},"p_query_org_fields":{"in":"query","name":"fields","schema":{"type":"string","enum":["address","custom_fields","notes","name"]},"description":"A comma-separated string array. \\nThe fields to perform the search from. \\nDefaults to all of them. \\nOnly the following custom field types are searchable:  `address`, `varchar`, `text`, and `phone`. \\nRead more about searching by custom fields  [here](../../kb/getting-started/search-finding-what-you-need#searching-by-custom-fields)."},"p_query_org_sort":{"in":"query","name":"sort","schema":{"type":"string"},"description":"The field names and sorting mode separated by a comma  (`field_name_1 ASC`, `field_name_2 DESC`).  Only first-level field keys are supported (no nested keys).  Supported fields:  `id`, `user_id`,  `deal_id`, `person_id`, `org_id`, `product_id`,  `add_time`, `update_time`, `comment`."},"p_query_org_items":{"in":"query","name":"items","description":"A comma-separated string for filtering out item specific updates. (Possible values - activity, note, deal).","schema":{"type":"string"}},"p_query_person_user_id":{"in":"query","name":"user_id","schema":{"type":"integer"},"description":"If supplied, only persons owned by the given user will be returned. However, `filter_id` takes precedence over `user_id` when both are supplied."},"p_query_fields":{"in":"query","name":"fields","schema":{"type":"string","enum":["custom_fields","email","notes","phone","name"]},"description":"A comma-separated string array. The fields to perform the search from. Defaults to all of them. \\nOnly the following custom field types are searchable:  `address`, `varchar`, `text`, and `phone`. \\nRead more about searching by custom fields  [here](../../kb/getting-started/search-finding-what-you-need#searching-by-custom-fields)."},"p_query_include_fields":{"in":"query","name":"include_fields","schema":{"type":"string","enum":["person.picture"]},"description":"Supports including optional fields in the results which are not provided by default"},"p_query_person_items":{"in":"query","name":"items","description":"A comma-separated string for filtering out item specific updates. (Possible values - activity, note, deal).","schema":{"type":"string"}},"p_query_pipeline_user_id":{"in":"query","name":"user_id","schema":{"type":"integer"},"description":"If supplied, `filter_id` will not be considered and only deals owned by the given user will be returned. If omitted, deals owned by the authorized user will be returned."},"p_query_pipeline_everyone":{"in":"query","name":"everyone","schema":{"title":"numberBoolean","type":"number","enum":[0,1]},"description":"If supplied, `filter_id` and `user_id` will not be considered – instead, deals owned by everyone will be returned"},"p_query_pipeline_get_summary":{"in":"query","name":"get_summary","schema":{"title":"numberBoolean","type":"number","enum":[0,1]},"description":"Whether to include a summary of the pipeline in the `additional_data` or not"},"p_query_product_user_id":{"in":"query","name":"user_id","schema":{"type":"integer"},"description":"If supplied, only products owned by the given user will be returned"},"p_query_product_ids":{"in":"query","name":"ids","schema":{"type":"array","items":{"type":"integer"}},"description":"An array of integers with the IDs of the products that should be returned in the response"},"p_query_product_get_summary":{"in":"query","name":"get_summary","schema":{"type":"boolean"},"description":"If supplied, the response will return the total numbers of products in the `additional_data.summary.total_count` property"},"p_query_recent_since_timestamp":{"in":"query","name":"since_timestamp","required":true,"schema":{"type":"string"},"description":"The timestamp in UTC. Format: YYYY-MM-DD HH:MM:SS."},"p_query_recent_items":{"in":"query","name":"items","schema":{"type":"string","enum":["activity","activityType","deal","filter","note","person","organization","pipeline","product","stage","user"]},"description":"Multiple selection of item types to include in the  query (optional)"},"p_query_visible":{"in":"query","name":"visible","schema":{"type":"boolean","default":true},"description":"Whether to return the visible or hidden pipelines  for the role"},"p_query_stage_pipeline_id":{"in":"query","name":"pipeline_id","schema":{"type":"integer"},"description":"The ID of the pipeline to fetch stages for. If omitted, stages for all pipelines will be fetched."},"p_query_stage_everyone":{"in":"query","name":"everyone","schema":{"title":"stageNumberBoolean","type":"number","enum":[0,1]},"description":"If `everyone=1` is provided, deals summary will return deals owned by every user"},"p_query_stage_user_id":{"in":"query","name":"user_id","schema":{"type":"integer"},"description":"If supplied, `filter_id` will not be considered and only deals owned by the given user will be returned. If omitted, deals owned by the authorized user will be returned."},"p_query_user_search_by_email":{"in":"query","name":"search_by_email","schema":{"title":"numberBooleanDefault0","type":"number","default":0,"enum":[0,1]},"description":"When enabled, the term will only be matched against email addresses of users. Default: `false`."}},"schemas":{"s_base_response":{"title":"baseResponse","type":"object","properties":{"success":{"type":"boolean","description":"If the response is successful or not"}}},"s_attr_person_id_ref":{"type":"object","properties":{"person_id":{"description":"The ID of the person this Item is associated with","type":"integer"}}},"s_attr_deal_id_ref":{"type":"object","properties":{"deal_id":{"description":"The ID of the deal this Item is associated with","type":"integer"}}},"s_attr_org_id":{"type":"object","properties":{"org_id":{"description":"The ID of the organization this Item is associated with","type":"integer"}}},"s_activity_extended":{"allOf":[{"$ref":"#/components/schemas/s_attr_person_id_ref"},{"$ref":"#/components/schemas/s_attr_deal_id_ref"},{"$ref":"#/components/schemas/s_attr_org_id"},{"type":"object","properties":{"due_date":{"description":"\\"The due date of the activity. Format: YYYY-MM-DD\\"","type":"string","format":"date"},"due_time":{"description":"\\"The due time of the activity in UTC. Format: HH:MM\\"","type":"string"},"duration":{"description":"\\"The duration of the activity. Format: HH:MM\\"","type":"string"}}}]},"s_attr_active_flag":{"type":"object","title":"entityActiveFlag","properties":{"active_flag":{"type":"boolean","description":"Whether the entity is active or not. false = Not activated, true = Activated"}}},"s_attr_created_by_user_id":{"type":"object","properties":{"created_by_user_id":{"type":"integer","description":"The ID of the user who created the  item."}}},"s_basic_entity_attributes":{"allOf":[{"$ref":"#/components/schemas/s_attr_active_flag"},{"$ref":"#/components/schemas/s_attr_created_by_user_id"},{"type":"object","title":"entityBasicSchema","properties":{"add_time":{"type":"string","format":"date-time","description":"The creation time in UTC. Format: YYYY-MM-DD HH:MM:SS"},"update_time":{"type":"string","format":"date-time","description":"The last update time in UTC. Format: YYYY-MM-DD HH:MM:SS"},"last_updated_by_user_id":{"type":"integer","description":"The ID of the user who created or most recently updated the item."}}}]},"s_attr_organization_org_name":{"type":"object","title":"organizationOrgName","properties":{"org_name":{"type":"string","description":"The name of the organization associated with the entity"}}},"s_attr_person_person_name":{"type":"object","title":"personPersonName","properties":{"person_name":{"type":"string","description":"The name of the peson associated with the entity"}}},"s_attr_user_owner_name":{"type":"object","properties":{"owner_name":{"type":"string","description":"The name of the owner associated with the entity"}}},"s_attr_deal_deal_title":{"type":"object","title":"dealDealTitle","properties":{"deal_name":{"description":"The name of the deal this entity is associated with","type":"string"}}},"s_activity_redundant":{"allOf":[{"$ref":"#/components/schemas/s_attr_organization_org_name"},{"$ref":"#/components/schemas/s_attr_person_person_name"},{"$ref":"#/components/schemas/s_attr_user_owner_name"},{"$ref":"#/components/schemas/s_attr_deal_deal_title"},{"type":"object","title":"activityRedundant"}]},"s_basic_company_id":{"type":"object","properties":{"company_id":{"type":"integer","description":"The ID of the company"}}},"s_attr_activity_id":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the activity, generated when the activity was created"}}},"s_activity":{"allOf":[{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_activity_redundant"},{"$ref":"#/components/schemas/s_basic_company_id"},{"$ref":"#/components/schemas/s_attr_activity_id"},{"type":"object","properties":{"done":{"allOf":[{"title":"doneNumberBoolean","type":"number","enum":[0,1]}],"description":"Whether the activity is done or not. 0 = Not done, 1 = Done"},"subject":{"description":"The subject of the activity","type":"string"},"type":{"description":"The type of the activity. This is in correlation with the `key_string` parameter of ActivityTypes.","type":"string"},"assigned_to_user_id":{"description":"The ID of the user to whom the activity is assigned to. Equal to `user_id`.","type":"integer"},"user_id":{"description":"The ID of the user whom the activity is assigned to","type":"integer"},"participants":{"description":"List of multiple persons (participants) this activity is associated with.  It requires a structure as follows: `[{\\"person_id\\":1,\\"primary_flag\\":true}]`","type":"array","nullable":true,"items":{"type":"object"}},"marked_as_done_time":{"type":"string","description":"The date and time this activity was marked as done. Format: YYYY-MM-DD HH:MM:SS."}}}]},"s_additional_data_pagination":{"type":"object","description":"The additional data of the list","properties":{"pagination":{"description":"Pagination details of the list","type":"object","properties":{"start":{"type":"integer","description":"Pagination start"},"limit":{"type":"integer","description":"Items shown per page"},"more_items_in_collection":{"type":"boolean","description":"Whether there are more list items in the collection than displayed"},"next_start":{"type":"integer","description":"Next pagination start"}}}}},"s_attr_user_email":{"type":"object","properties":{"email":{"type":"string","description":"The user email"}}},"s_attr_user_id":{"type":"object","properties":{"id":{"type":"string","description":"The ID of the user"}}},"s_attr_user_name":{"type":"object","properties":{"name":{"type":"string","description":"The name of the user"}}},"s_basic_user_id":{"type":"object","title":"userBasicData","allOf":[{"type":"object","description":"The user who is associated with the Entity"},{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_attr_user_email"},{"$ref":"#/components/schemas/s_attr_user_id"},{"$ref":"#/components/schemas/s_attr_user_name"}]},"s_ro_user":{"type":"object","properties":{"user":{"type":"object","properties":{"USER_ID":{"$ref":"#/components/schemas/s_basic_user_id"}}}}},"s_person_item_email_array":{"type":"object","properties":{"value":{"type":"string","description":"The Email"},"primary":{"type":"boolean","description":"Boolean that indicates if email is primary for the person or not"},"label":{"type":"string","description":"The label that indicates the type of the email. (Possible values - work, home or other)"}}},"s_person_item_phone_array":{"type":"object","properties":{"value":{"type":"string","description":"The phone number"},"primary":{"type":"boolean","description":"Boolean that indicates if phone number is primary for the person or not"},"label":{"type":"string","description":"The label that indicates the type of the phone number. (Possible values - work, home, mobile or other)"}}},"s_basic_person":{"type":"object","title":"personBasicData","description":"The person associated with the entity (whitout ID)","allOf":[{"type":"object","properties":{"name":{"type":"string","description":"The name of the person associated with the entity"},"email":{"type":"array","description":"The emails of the person associated with the entity","items":{"$ref":"#/components/schemas/s_person_item_email_array"}},"phone":{"type":"array","description":"The phone numbers of the person associated with the entity","items":{"$ref":"#/components/schemas/s_person_item_phone_array"}},"owner_id":{"type":"integer","description":"The ID of the user owner of the person that is associated with the entity"}}}]},"s_basic_person_id":{"type":"object","title":"personBasicDataWithID","description":"The ID of the person associated with the  entity","allOf":[{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the person associated with the entity"}}},{"$ref":"#/components/schemas/s_basic_person"}]},"s_ro_person":{"type":"object","properties":{"person":{"type":"object","properties":{"PERSON_ID":{"$ref":"#/components/schemas/s_basic_person_id"}}}}},"s_attr_organization_address":{"type":"object","title":"organizationAddress","properties":{"address":{"type":"string","description":"The full address of the organization"}}},"s_basic_organization":{"allOf":[{"$ref":"#/components/schemas/s_attr_organization_address"},{"type":"object","title":"organizationBasicData","description":"The Organization associated with the entity (Without ID)","properties":{"name":{"type":"string","description":"The name of the organization associated with the entity"},"people_count":{"type":"integer","description":"The number of people connected with the organization that is associated with the entity"},"owner_id":{"type":"integer","description":"The ID of the user owner of the organization that is associated with the entity"}}}]},"s_basic_organization_id":{"type":"object","title":"organizationBasicDataWithID","description":"The ID of the organization associated with the entity","allOf":[{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the organization associated with the entity"}}},{"$ref":"#/components/schemas/s_basic_organization"}]},"s_ro_organization":{"type":"object","properties":{"organization":{"type":"object","properties":{"ORGANIZATION_ID":{"$ref":"#/components/schemas/s_basic_organization_id"}}}}},"s_attr_deal_stage_id":{"type":"object","properties":{"stage_id":{"type":"integer","description":"The ID of the stage the deal is currently at"}}},"s_attr_deal_pipeline_id":{"type":"object","properties":{"pipeline_id":{"type":"integer","description":"The ID of the pipeline associated with the deal"}}},"s_attr_deal_currency":{"type":"object","properties":{"currency":{"type":"string","description":"The currency of the deal value"}}},"s_attr_deal_value":{"type":"object","properties":{"value":{"type":"number","description":"The value of the deal"}}},"s_basic_deal_id":{"allOf":[{"$ref":"#/components/schemas/s_attr_deal_stage_id"},{"$ref":"#/components/schemas/s_attr_deal_pipeline_id"},{"$ref":"#/components/schemas/s_attr_deal_currency"},{"$ref":"#/components/schemas/s_attr_deal_value"},{"type":"object","title":"dealBasicData","description":"The ID of the deal which is associated with the entity","properties":{"id":{"type":"integer","description":"The ID of the deal associated with the entity"},"name":{"type":"string","description":"The name of the deal associated with the entity"},"status":{"type":"string","description":"The status of the deal associated with the entity"}}}]},"s_ro_deal":{"type":"object","properties":{"deal":{"type":"object","properties":{"DEAL_ID":{"$ref":"#/components/schemas/s_basic_deal_id"}}}}},"s_related_objects_3E_U":{"allOf":[{"$ref":"#/components/schemas/s_ro_user"},{"$ref":"#/components/schemas/s_ro_person"},{"$ref":"#/components/schemas/s_ro_organization"},{"$ref":"#/components/schemas/s_ro_deal"}]},"s_attr_id_deleted_list":{"type":"object","title":"deletedListID","properties":{"id":{"type":"array","description":"Array of all the IDs of the deleted items.","items":{"type":"integer"}}}},"s_attr_id_deleted":{"type":"object","title":"deletedID","properties":{"id":{"type":"integer","description":"The ID of the deleted item."}}},"s_attr_field_options":{"type":"object","properties":{"options":{"type":"array","nullable":true,"items":{"type":"object"},"description":"The options of the field. When there are no options, `null` is returned.  When `field_type` is either `set` or `enum`, possible options must be supplied as a JSON-encoded sequential array of objects. All active items must be supplied and already existing items must have their ID supplied. New items only require a label. Example:  `[{\\"id\\":123,\\"label\\":\\"Existing Item\\"},{\\"label\\":\\"New Item\\"}]`"}}},"s_attr_field_name":{"type":"object","properties":{"name":{"type":"string","description":"The name of the field"}}},"s_fields_create":{"allOf":[{"$ref":"#/components/schemas/s_attr_field_options"},{"$ref":"#/components/schemas/s_attr_field_name"},{"type":"object","description":"Entity\'s Add Operation Field Schema","required":["name"],"properties":{"add_visible_flag":{"type":"boolean","default":true,"description":"Whether the field is available in the \'add new\' modal or not (in the web app)"}}}]},"s_field_type":{"type":"object","required":["field_type"],"properties":{"field_type":{"allOf":[{"type":"string","enum":["date","daterange","double","enum","monetary","org","person","phone","set","text","time","timerange","user","varchar"],"description":"The type of the  field <table>\\n  <tr>\\n      <th>Value</th>\\n      <th>Description</th>\\n  </tr>\\n  <tr>\\n      <td>`date`</td>\\n      <td>Date (format YYYY-MM-DD)\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>`daterange`</td>\\n      <td>Date-range\\n        field (has a start date and end date value, both YYYY-MM-DD)\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>`double`</td>\\n      <td>Numeric value\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>`enum`</td>\\n      <td>Options\\n        field with a single possible chosen option\\n      </td>\\n  </tr>\\n  <tr></tr>\\n  <tr>\\n      <td>`monetary`</td>\\n      <td>Monetary\\n        field (has a numeric value and a currency value)\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>`org`</td>\\n      <td>Organization\\n        field (contains an organization ID which is stored on the same\\n        account)\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>`person`</td>\\n      <td>Person\\n        field (contains a person ID which is stored on the same\\n        account)\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>`phone`</td>\\n      <td>Phone field (up to 255 numbers and/or characters)\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>`set`</td>\\n      <td>Options\\n        field with a possibility of having multiple chosen\\n        options\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>`text`</td>\\n      <td>Long\\n        text (up to 65k characters)\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>`time`</td>\\n      <td>Time field (format HH:MM:SS)\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>`timerange`</td>\\n      <td>Time-range\\n        field (has a start time and end time value, both HH:MM:SS)\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>`user`</td>\\n      <td>User\\n        field (contains a user ID of another Fintesk user)\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>`varchar`</td>\\n      <td>Text (up to 255 characters)\\n      </td>\\n  </tr>\\n \\n\\n</table>"}]}}},"s_attr_field_order_nbr":{"type":"object","properties":{"order_nbr":{"type":"integer","description":"The position (index) of the Item. First order (`order_nbr=0`) is the default."}}},"s_field":{"allOf":[{"$ref":"#/components/schemas/s_fields_create"},{"$ref":"#/components/schemas/s_field_type"},{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_attr_field_order_nbr"},{"type":"object","description":"Entity\'s Field Schema","properties":{"id":{"type":"integer","description":"The ID of the field. Value is `null` in case of subfields."},"key":{"type":"string","description":"The key of the field. For custom fields this is generated upon creation."},"edit_flag":{"type":"boolean","description":"Whether or not the field and metadata is editable"},"index_visible_flag":{"type":"boolean","description":"Not used"},"details_visible_flag":{"type":"boolean","description":"Not used"},"important_flag":{"type":"boolean","description":"Whether or not the field is marked as important"},"bulk_edit_allowed":{"type":"boolean","description":"Whether or not the field of an item can be edited in bulk"},"searchable_flag":{"type":"boolean","description":"Whether or not items can be searched by this field"},"filtering_allowed":{"type":"boolean","description":"Whether or not items can be filtered by this field"},"sortable_flag":{"type":"boolean","description":"Whether or not items can be sorted by this field"},"mandatory_flag":{"type":"boolean","description":"Whether or not the field is mandatory"},"is_subfield":{"type":"boolean","description":"Whether or not the field is a subfield of another field. Only present if field is subfield."},"subfields":{"type":"array","items":{"type":"object"},"description":"The subfields of the field. Only present when the field has subfields."}}}]},"s_attr_activity_type_id":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the activity type"}}},"s_activity_type_put":{"allOf":[{"$ref":"#/components/schemas/s_attr_field_order_nbr"},{"type":"object","properties":{"name":{"type":"string","description":"The name of the activity type"},"icon_key":{"type":"string","description":"Icon graphic to use for representing this activity type","enum":["task","email","meeting","deadline","call","lunch","calendar","downarrow","document","smartphone","camera","scissors","cogs","bubble","uparrow","checkbox","signpost","shuffle","addressbook","linegraph","picture","car","world","search","clip","sound","brush","key","padlock","pricetag","suitcase","finish","plane","loop","wifi","truck","cart","bulb","bell","presentation"]},"color":{"type":"string","description":"A designated color for the activity type in 6-character HEX format (e.g. `FFFFFF` for white, `000000` for black)"}}}]},"s_activity_type":{"allOf":[{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_attr_activity_type_id"},{"type":"object","properties":{"key_string":{"type":"string","description":"A string that is generated by the API based on the given name of the activity type upon creation"},"is_custom_flag":{"type":"boolean","description":"Whether the activity type is a custom one or not"}}},{"$ref":"#/components/schemas/s_activity_type_put"}]},"s_attr_currency_id":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the currency"}}},"s_currency":{"type":"array","description":"The array of currencies","items":{"allOf":[{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_attr_currency_id"},{"type":"object","properties":{"code":{"type":"string","description":"The code of the currency"},"name":{"type":"string","description":"The name of the currency"},"decimal_points":{"type":"integer","description":"The amount of decimal points of the currency"},"symbol":{"type":"string","description":"The symbol of the currency"},"is_custom_flag":{"type":"boolean","description":"Whether the currency is a custom one or not"}}}]}},"s_attr_deal_id":{"type":"object","properties":{"id":{"type":"string","description":"The ID of the deal"}}},"s_basic_user_id_w_value":{"title":"userDataWithId","allOf":[{"description":"The user who is associated with the entity"},{"$ref":"#/components/schemas/s_basic_user_id"},{"type":"object","properties":{"value":{"type":"integer","description":"The ID of the user associated with the entity"}}}]},"s_basic_person_w_value":{"title":"personDataWithId","allOf":[{"description":"The person who is associated with the Entity"},{"$ref":"#/components/schemas/s_basic_person"},{"type":"object","properties":{"value":{"type":"integer","description":"The ID of the person associated with the Entity"}}}]},"s_basic_organization_w_value":{"title":"organizationDataWithId","allOf":[{"description":"The organization who is associated with the Entity"},{"$ref":"#/components/schemas/s_basic_organization"},{"type":"object","properties":{"value":{"type":"integer","description":"The ID of the organization associated with the Entity"}}}]},"s_deal_non_strict_objects":{"allOf":[{"$ref":"#/components/schemas/s_attr_deal_id"},{"type":"object","title":"dealNonStrict","properties":{"creator_user_id":{"allOf":[{"description":"The User who created the deal"},{"$ref":"#/components/schemas/s_basic_user_id_w_value"}]},"user_id":{"allOf":[{"description":"The user who is associated with the deal"},{"$ref":"#/components/schemas/s_basic_user_id_w_value"}]},"person_id":{"allOf":[{"description":"The person who is associated with the deal"},{"$ref":"#/components/schemas/s_basic_person_w_value"}]},"org_id":{"allOf":[{"description":"The organization who is associated with the deal"},{"$ref":"#/components/schemas/s_basic_organization_w_value"}]}}}]},"s_deal_next_activity_info":{"type":"object","properties":{"next_activity_date":{"type":"string","nullable":true,"description":"The date of the next activity associated with the deal"},"next_activity_time":{"type":"string","nullable":true,"description":"The time of the next activity associated with the deal"},"next_activity_id":{"type":"integer","nullable":true,"description":"The ID of the next activity associated with the deal"},"next_activity_subject":{"type":"string","description":"The subject of the next activity associated with the deal"},"next_activity_type":{"type":"string","description":"The type of the next activity associated with the deal"},"next_activity_duration":{"type":"string","description":"The duration of the next activity associated with the deal"},"next_activity_note":{"type":"string","description":"The note of the next activity associated with the deal"}}},"s_deal_last_activity_info":{"type":"object","properties":{"last_activity_id":{"type":"integer","nullable":true,"description":"The ID of the last activity associated with the deal"},"last_activity_date":{"type":"string","nullable":true,"description":"The date of the last activity associated with the deal"}}},"s_deals_activity_info":{"allOf":[{"$ref":"#/components/schemas/s_deal_next_activity_info"},{"$ref":"#/components/schemas/s_deal_last_activity_info"}]},"s_attr_deal_title":{"type":"object","title":"dealTitleParam","properties":{"name":{"type":"string","description":"The name of the deal"}}},"s_mailbox_last_incoming_mail_time":{"type":"object","properties":{"last_incoming_mail_time":{"type":"string","description":"The date and time of the last incoming email associated with the Item"}}},"s_mailbox_last_outgoing_mail_time":{"type":"object","properties":{"last_outgoing_mail_time":{"type":"string","description":"The date and time of the last outgoing email associated with the Item"}}},"s_attr_deal_status":{"type":"object","properties":{"status":{"type":"string","description":"The status of the deal"}}},"s_deals_get_basic":{"allOf":[{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_attr_deal_title"},{"$ref":"#/components/schemas/s_mailbox_last_incoming_mail_time"},{"$ref":"#/components/schemas/s_mailbox_last_outgoing_mail_time"},{"$ref":"#/components/schemas/s_attr_deal_pipeline_id"},{"$ref":"#/components/schemas/s_attr_deal_stage_id"},{"$ref":"#/components/schemas/s_attr_deal_status"},{"$ref":"#/components/schemas/s_attr_deal_currency"},{"$ref":"#/components/schemas/s_attr_deal_value"},{"title":"getDealBasic","type":"object","properties":{"stage_change_time":{"type":"string","description":"The last updated date and time of the deal stage"},"probability":{"type":"number","nullable":true,"description":"The success probability percentage of the deal"},"lost_reason":{"type":"string","nullable":true,"description":"The reason for losing the deal"},"close_time":{"type":"string","nullable":true,"description":"The date and time of closing the deal"},"won_time":{"type":"string","description":"The date and time of changing the deal status as won"},"first_won_time":{"type":"string","description":"The date and time of the first time changing the deal status as won"},"lost_time":{"type":"string","description":"The date and time of changing the deal status as lost"},"expected_close_date":{"type":"string","format":"date","description":"The expected close date of the deal"}}}]},"s_attr_deal_person_hidden":{"type":"object","properties":{"person_hidden":{"type":"boolean","description":"If the person that is associated with the deal is hidden or not"}}},"s_attr_deal_weighted_value_formatted":{"type":"object","properties":{"weighted_value_formatted":{"type":"string","description":"The weighted_value formatted with selected currency. E.g. US$500"}}},"s_attr_deal_weighted_value":{"type":"object","properties":{"weighted_value":{"type":"number","description":"Probability times deal value. Probability can either be deal probability or if not set, then stage probability."}}},"s_deals_get_redundant":{"allOf":[{"$ref":"#/components/schemas/s_attr_deal_person_hidden"},{"$ref":"#/components/schemas/s_attr_organization_org_name"},{"$ref":"#/components/schemas/s_attr_user_owner_name"},{"$ref":"#/components/schemas/s_attr_person_person_name"},{"$ref":"#/components/schemas/s_attr_deal_weighted_value_formatted"},{"$ref":"#/components/schemas/s_attr_deal_weighted_value"},{"type":"object","title":"getDealRedundant","properties":{"stage_order_nbr":{"type":"integer","description":"The order number of the deal stage associated with the deal"},"value_formatted":{"type":"string","description":"The deal value formatted with selected currency. E.g. US$500"},"weighted_value_currency":{"type":"string","description":"The currency associated with the deal"},"rotten_time":{"type":"string","nullable":true,"description":"The date and time of changing the deal status as rotten"}}}]},"s_deal_get_base":{"allOf":[{"$ref":"#/components/schemas/s_deals_activity_info"},{"$ref":"#/components/schemas/s_deals_get_basic"},{"$ref":"#/components/schemas/s_deals_get_redundant"}]},"s_deal_non_strict":{"title":"dealNonStrict","allOf":[{"$ref":"#/components/schemas/s_deal_non_strict_objects"},{"$ref":"#/components/schemas/s_deal_get_base"}]},"s_attr_stage_name":{"type":"object","properties":{"name":{"type":"string","description":"The name of the stage"}}},"s_attr_stage_id":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the stage"}}},"s_stage_base":{"allOf":[{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_attr_field_order_nbr"},{"$ref":"#/components/schemas/s_attr_deal_pipeline_id"},{"$ref":"#/components/schemas/s_attr_stage_name"},{"$ref":"#/components/schemas/s_attr_stage_id"},{"type":"object","title":"stageBase"}]},"s_pipeline_attr_deal_probability":{"type":"object","properties":{"deal_probability":{"allOf":[{"title":"numberBoolean","type":"number","enum":[0,1]}],"description":"Whether deal probability is disabled or enabled for this pipeline"}}},"s_attr_pipeline_name":{"type":"object","properties":{"name":{"type":"string","description":"The name of the pipeline"}}},"s_attr_pipeline_id":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the pipeline"}}},"s_pipeline_base":{"allOf":[{"$ref":"#/components/schemas/s_attr_field_order_nbr"},{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_pipeline_attr_deal_probability"},{"$ref":"#/components/schemas/s_attr_pipeline_name"},{"$ref":"#/components/schemas/s_attr_pipeline_id"},{"type":"object","title":"basePipeline","description":"The pipeline object"}]},"s_related_objects_2E_U_S_P":{"allOf":[{"$ref":"#/components/schemas/s_ro_user"},{"$ref":"#/components/schemas/s_ro_person"},{"$ref":"#/components/schemas/s_ro_organization"},{"type":"object","properties":{"stage":{"$ref":"#/components/schemas/s_stage_base"},"pipeline":{"$ref":"#/components/schemas/s_pipeline_base"}}}]},"s_deal_request_cru_channel":{"title":"cruDealRequestChannel","type":"object","properties":{"origin_id":{"type":"string","nullable":true,"description":"The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this deal. If omitted, `origin_id` will be set to null."},"channel":{"type":"integer","nullable":true,"description":"The ID of Marketing channel this deal was created from. Provided value must be one of the channels configured for your company. You can fetch allowed values with  [GET /v1/dealFields](../../fintesk/api/v1#tag/DealFields/operation/getDealField) If omitted, channel will be set to null."},"channel_id":{"type":"string","nullable":true,"description":"The optional ID to further distinguish the Marketing channel. If omitted, `channel_id` will be set to null."}}},"s_attr_add_time_request":{"title":"addTimeRequest","type":"object","properties":{"add_time":{"type":"string","description":"The optional creation date & time of the Item in UTC. Can be set in the past or in the future. Requires admin user API token. Format: YYYY-MM-DD HH:MM:SS"}}},"s_deal_request_cru":{"allOf":[{"$ref":"#/components/schemas/s_deal_request_cru_channel"},{"$ref":"#/components/schemas/s_attr_add_time_request"},{"title":"cruDealParameters","type":"object","properties":{"value":{"type":"string","description":"The value of the deal. If omitted,  value will be set to 0."},"currency":{"type":"string","description":"The currency of the deal. Accepts a 3-character currency code. Adding a new Deal:  if omitted, currency will be set to the default currency of the authorized user."},"user_id":{"type":"integer","description":"The ID of the user which will be the owner of the created deal. Adding a new Deal:  If not provided, the user making the request will be used."},"person_id":{"type":"integer","description":"The ID of a person which this deal will be linked to. If the person does not exist yet, it needs to be created first. Adding a new Deal:  This property is required unless `org_id` is specified."},"org_id":{"type":"integer","description":"The ID of an organization which this deal will be linked to. If the organization does not exist yet, it needs to be created first. Adding a new Deal: This property is required unless `person_id` is specified."},"pipeline_id":{"type":"integer","description":"The ID of the pipeline this deal will be added to. By default, the deal will be added to the first stage of the specified pipeline. Please note that `pipeline_id` and `stage_id` should not be used together as `pipeline_id` will be ignored."},"stage_id":{"type":"integer","description":"The ID of the stage this deal will be added to. Please note that a pipeline will be assigned automatically based on the `stage_id`. Adding a new Deal: If omitted, the deal will be placed in the first stage of the default pipeline."},"status":{"type":"string","enum":["open","won","lost","deleted"],"description":"open = Open, won = Won, lost = Lost, deleted = Deleted. Adding a new Deal: If omitted, status will be set to open."}}}]},"s_deal_request_cru_basic":{"title":"basicDeal","type":"object","properties":{"won_time":{"type":"string","description":"The optional date and time of changing the deal status as won in UTC. Format: YYYY-MM-DD HH:MM:SS. Can be set only when deal `status` is already Won. Can not be used together with `lost_time`."},"lost_time":{"type":"string","description":"The optional date and time of changing the deal status as lost in UTC. Format: YYYY-MM-DD HH:MM:SS. Can be set only when deal `status` is already Lost. Can not be used together with `won_time`."},"close_time":{"type":"string","nullable":true,"description":"The optional date and time of closing the deal in UTC. Format: YYYY-MM-DD HH:MM:SS."},"expected_close_date":{"type":"string","format":"date","description":"The expected close date of the deal. In ISO 8601 format: YYYY-MM-DD."},"probability":{"type":"number","description":"The success probability percentage of the deal. Used/shown only when `deal_probability` for the pipeline of the deal is enabled."},"lost_reason":{"type":"string","description":"The optional message about why the deal was lost (to be used when status = lost)"}}},"s_search_result_score":{"type":"object","properties":{"result_score":{"type":"number","description":"Search result relevancy"}}},"s_search_item_base":{"allOf":[{"type":"object","title":"baseSearchResults","properties":{"id":{"type":"integer","description":"The ID of the Entity"},"type":{"type":"string","description":"The type of the Entity\'s item"},"name":{"type":"string","description":"The name of the Entity"},"owner":{"allOf":[{"$ref":"#/components/schemas/s_attr_user_id"}]},"custom_fields":{"type":"array","items":{"type":"string"},"description":"The custom fields"}}}]},"s_search_item_field_notes":{"type":"object","title":"itemSearchResultFieldNotes","properties":{"notes":{"type":"array","description":"An array of notes","items":{"type":"string"}}}},"s_search_item_field_organization":{"type":"object","title":"itemSearchResultFieldOrganization","properties":{"organization":{"type":"object","nullable":true,"properties":{"id":{"type":"integer","description":"The ID of the organization the deal is associated with"},"name":{"type":"string","description":"The name of the organization the deal is associated with"}}}}},"s_search_item_field_person":{"type":"object","title":"itemSearchResultFieldPerson","properties":{"person":{"type":"object","nullable":true,"properties":{"id":{"type":"integer","description":"The ID of the person the deal is associated with"},"name":{"type":"string","description":"The name of the person the deal is associated with"}}}}},"s_search_item_deal":{"allOf":[{"$ref":"#/components/schemas/s_search_item_base"},{"$ref":"#/components/schemas/s_search_item_field_notes"},{"$ref":"#/components/schemas/s_search_item_field_organization"},{"$ref":"#/components/schemas/s_search_item_field_person"},{"$ref":"#/components/schemas/s_attr_deal_title"},{"$ref":"#/components/schemas/s_attr_deal_status"},{"$ref":"#/components/schemas/s_attr_deal_currency"},{"$ref":"#/components/schemas/s_attr_deal_value"},{"type":"object","title":"itemDealSearchResults","properties":{"stage":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the stage of the deal"},"name":{"type":"string","description":"The name of the stage of the deal"}}}}}]},"s_deals_summary_total_count":{"type":"object","properties":{"total_count":{"type":"integer","description":"The total number of deals"}}},"s_deals_summary_values_total":{"type":"object","description":"The total values of the deals grouped by deal currency","properties":{"value":{"type":"number","description":"The total value of deals in the deal currency group"},"count":{"type":"integer","description":"The number of deals in the deal currency group"},"value_converted":{"type":"number","description":"The total value of deals converted into the company default currency"},"value_formatted":{"type":"string","description":"The total value of deals formatted with deal currency. E.g. €50"},"value_converted_formatted":{"type":"string","description":"The value_converted formatted with deal currency. E.g. US$50.10"}}},"s_deals_summary_weighted_values_total":{"type":"object","description":"The total weighted values of the deals grouped by deal currency. The weighted value is calculated as probability times deal value.","properties":{"value":{"type":"number","description":"The total weighted value of the deals in the deal currency group"},"count":{"type":"integer","description":"The number of deals in the deal currency group"},"value_formatted":{"type":"string","description":"The total weighted value of the deals formatted with deal currency. E.g. €50"}}},"s_deals_summary":{"allOf":[{"$ref":"#/components/schemas/s_deals_summary_total_count"},{"type":"object","description":"The summary of deals","properties":{"values_total":{"$ref":"#/components/schemas/s_deals_summary_values_total"},"weighted_values_total":{"$ref":"#/components/schemas/s_deals_summary_weighted_values_total"},"total_currency_converted_value":{"type":"number","description":"The total value of deals converted into the company default currency"},"total_weighted_currency_converted_value":{"type":"number","description":"The total weighted value of deals converted into the company default currency"},"total_currency_converted_value_formatted":{"type":"string","description":"The total converted value of deals formatted with the company default currency. E.g. US$5,100.96"},"total_weighted_currency_converted_value_formatted":{"type":"string","description":"The total weighted value of deals formatted with the company default currency. E.g. US$5,100.96"}}}]},"s_attr_user_user_id":{"type":"object","properties":{"user_id":{"type":"string","description":"The ID of the user"}}},"s_deal_strict_ids":{"allOf":[{"$ref":"#/components/schemas/s_attr_created_by_user_id"},{"$ref":"#/components/schemas/s_attr_deal_id"},{"$ref":"#/components/schemas/s_attr_user_user_id"},{"$ref":"#/components/schemas/s_attr_org_id"},{"type":"object","title":"dealStrictIds","properties":{"person_id":{"type":"integer","description":"The ID of the person associated with the deal"}}}]},"s_deal_strict":{"title":"dealStrict","allOf":[{"$ref":"#/components/schemas/s_deal_strict_ids"},{"$ref":"#/components/schemas/s_deal_get_base"}]},"s_deals_timeline_grouped":{"type":"object","description":"Open and won deals grouped into periods by defined interval, amount and date-type dealField (`field_key`)","properties":{"period_start":{"type":"string","description":"The start date and time of the period"},"period_end":{"type":"string","description":"The end date and time of the period"},"deals":{"type":"array","items":{"$ref":"#/components/schemas/s_deal_strict"}},"totals":{"type":"object","description":"The total values of deals for the given period","properties":{"count":{"type":"integer","description":"The number of deals for the given period"},"values":{"type":"object","description":"The total values of deals grouped by deal currency"},"weighted_values":{"type":"object","description":"The total weighted values of deals for the given period grouped by deal currency. The weighted value of a deal is calculated as probability times deal value."},"open_count":{"type":"integer","description":"The number of open deals for the given period"},"open_values":{"type":"object","description":"The total values of open deals for the given period grouped by deal currency"},"weighted_open_values":{"type":"object","description":"The total weighted values of open deals for the given period grouped by deal currency. The weighted value of a deal is calculated as probability times deal value."},"won_count":{"type":"integer","description":"The number of won deals for the given period"},"won_values":{"type":"object","description":"The total values of won deals for the given period grouped by deal currency"}}}}},"s_deal_get_extended":{"type":"object","properties":{"average_time_to_won":{"type":"object","description":"The average time to win the deal","properties":{"y":{"type":"integer","description":"Years"},"m":{"type":"integer","description":"Months"},"d":{"type":"integer","description":"Days"},"h":{"type":"integer","description":"Hours"},"i":{"type":"integer","description":"Minutes"},"s":{"type":"integer","description":"Seconds"},"total_seconds":{"type":"integer","description":"The total time in seconds"}},"example":{"y":0,"m":0,"d":0,"h":0,"i":20,"s":48,"total_seconds":1249}},"average_stage_progress":{"type":"number","description":"The average of the deal stage progression"},"age":{"type":"object","description":"The lifetime of the deal","properties":{"y":{"type":"integer","description":"Years"},"m":{"type":"integer","description":"Months"},"d":{"type":"integer","description":"Days"},"h":{"type":"integer","description":"Hours"},"i":{"type":"integer","description":"Minutes"},"s":{"type":"integer","description":"Seconds"},"total_seconds":{"type":"integer","description":"The total time in seconds"}}},"stay_in_pipeline_stages":{"type":"object","description":"The details of the duration of the deal being in each stage of the pipeline","properties":{"times_in_stages":{"type":"object","description":"The number of seconds a deal has been in each stage of the pipeline"},"order_of_stages":{"type":"array","description":"The order of the deal progression through the pipeline stages","items":{"type":"integer"}}}},"last_activity":{"type":"object","nullable":true,"description":"The details of the last activity associated with the deal"},"next_activity":{"type":"object","nullable":true,"description":"The details of the next activity associated with the deal"}}},"s_deal":{"title":"dealNonStrictWithDetails","allOf":[{"title":"dealNonStrict","allOf":[{"$ref":"#/components/schemas/s_deal_non_strict_objects"},{"$ref":"#/components/schemas/s_deal_get_base"}]},{"$ref":"#/components/schemas/s_deal_get_extended"}]},"s_person_item_arrays":{"type":"object","title":"personItemArraysEmailAndPhone","properties":{"phone":{"type":"array","description":"A phone number supplied as a string or an array of phone objects related to the person. The structure of the array is as follows: `[{ \\"value\\": \\"12345\\", \\"primary\\": \\"true\\", \\"label\\": \\"mobile\\" }]`. Please note that only `value` is required.","items":{"$ref":"#/components/schemas/s_person_item_phone_array"}},"email":{"type":"array","description":"An email address as a string or an array of email objects related to the person.  The structure of the array is as follows:  `[{ \\"value\\": \\"mail@example.com\\", \\"primary\\": \\"true\\", \\"label\\": \\"main\\" }]`.  Please note that only `value` is required.","items":{"$ref":"#/components/schemas/s_person_item_email_array"}}}},"s_person_redundant":{"type":"object","title":"personRedundant","allOf":[{"$ref":"#/components/schemas/s_attr_organization_org_name"},{"$ref":"#/components/schemas/s_attr_person_person_name"},{"$ref":"#/components/schemas/s_attr_user_owner_name"}]},"s_attr_first_char":{"type":"object","properties":{"first_char":{"type":"string","description":"The first character of the entity name"}}},"s_attr_person_id":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the person"}}},"s_attr_label":{"type":"object","properties":{"label":{"type":"string","description":"The label or multiple labels assigned to the entity"}}},"s_person_item":{"type":"object","title":"personItem","allOf":[{"$ref":"#/components/schemas/s_person_item_arrays"},{"$ref":"#/components/schemas/s_basic_company_id"},{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_person_redundant"},{"$ref":"#/components/schemas/s_attr_first_char"},{"$ref":"#/components/schemas/s_attr_person_id"},{"$ref":"#/components/schemas/s_attr_label"}]},"s_attr_person_name":{"type":"object","properties":{"name":{"type":"string","description":"The name of the person"}}},"s_person_full_name":{"allOf":[{"$ref":"#/components/schemas/s_attr_person_name"},{"type":"object","properties":{"first_name":{"type":"string","description":"The first name of the person"},"last_name":{"type":"string","description":"The last name of the person"}}}]},"s_person_count_email_deal_and_activity_info":[{"type":"object","title":"personCountEmailDealAndActivityInfo","allOf":[{"$ref":"./s_person_count_and_email_info.yaml"},{"$ref":"../../Deals/schemas/s_deal_count_and_activity_info.yaml"}]}],"s_person_additional_info":{"type":"object","title":"additionalPersonInfo","allOf":[{"type":"object","title":"personNameInfoWithOrgAndOwnerId","allOf":[{"$ref":"#/components/schemas/s_person_full_name"},{"type":"object","properties":{"owner_id":{"allOf":[{"description":"The User who is associated with the person"},{"$ref":"#/components/schemas/s_basic_user_id_w_value"}]},"org_id":{"title":"relationshipOrganizationInfoItemWithActiveFlag","allOf":[{"description":"The Organization who is associated with the person"},{"title":"relationshipOrganizationInfoItem","allOf":[{"$ref":"#/components/schemas/s_basic_organization_w_value"},{"$ref":"#/components/schemas/s_attr_active_flag"}]}]}}}]},{"$ref":"#/components/schemas/s_person_count_email_deal_and_activity_info"}]},"s_related_objects_O_U":{"allOf":[{"$ref":"#/components/schemas/s_ro_user"},{"$ref":"#/components/schemas/s_ro_person"}]},"prod_attr_product_id":{"type":"object","properties":{"product_id":{"type":"integer","description":"The ID of the product"}}},"prod_attr_duration_unit":{"type":"object","properties":{"duration_unit":{"type":"string","description":"The unit duration of the product","allOf":[{"title":"dealProductUnitDuration","type":"string","enum":["hourly","daily","weekly","monthly","yearly"]}]}}},"prod_attr_tax":{"type":"object","properties":{"tax":{"type":"number","description":"The tax percentage","default":0}}},"s_r_deal_product_basic":{"allOf":[{"$ref":"#/components/schemas/prod_attr_product_id"},{"$ref":"#/components/schemas/prod_attr_duration_unit"},{"$ref":"#/components/schemas/prod_attr_tax"},{"type":"object","title":"dealProductBasicInternal"}]},"dealprod_attr_id":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the deal-product (the ID of the product attached to the deal)"}}},"prod_attr_name":{"type":"object","properties":{"name":{"type":"string","description":"The name of the product"}}},"dealprod_attr_deal_id":{"type":"object","properties":{"deal_id":{"type":"integer","description":"The ID of the deal"}}},"dealprod_attr_sum":{"type":"object","properties":{"sum":{"type":"number","description":"The sum of all the products attached to the deal"}}},"dealprod_attr_currency":{"type":"object","properties":{"currency":{"type":"string","description":"The currency associated with the deal product"}}},"dealprod_attr_last_edit":{"type":"object","properties":{"last_edit":{"type":"string","description":"The date and time when the deal product was last edited"}}},"s_deal_product_basic":{"allOf":[{"$ref":"#/components/schemas/s_basic_company_id"},{"type":"object","title":"dealProductBasicCompany"},{"$ref":"#/components/schemas/s_r_deal_product_basic"},{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"type":"object","title":"dealProductExtended"},{"$ref":"#/components/schemas/dealprod_attr_id"},{"$ref":"#/components/schemas/prod_attr_name"},{"$ref":"#/components/schemas/dealprod_attr_deal_id"},{"$ref":"#/components/schemas/dealprod_attr_sum"},{"$ref":"#/components/schemas/dealprod_attr_currency"},{"$ref":"#/components/schemas/dealprod_attr_last_edit"}]},"prod_attr_discount":{"type":"object","properties":{"discount":{"type":"number","default":0,"description":"The value of the discount. The `discount_type` field can be used to specify whether the value is an amount or a percentage"}}},"prod_attr_discount_type":{"type":"object","properties":{"discount_type":{"type":"string","enum":["percentage","amount"],"default":"percentage","description":"The type of the discount\'s value"}}},"prod_attr_product_variation_id":{"type":"object","properties":{"product_variation_id":{"type":"integer","nullable":true,"description":"The ID of the product variation. When omitted, no variation will be used"}}},"prod_attr_duration":{"type":"object","properties":{"duration":{"type":"integer","description":"The duration of the product","default":1}}},"prod_attr_quantity":{"type":"object","properties":{"quantity":{"type":"integer","description":"How many items of this product will be added to the deal"}}},"prod_attr_item_price":{"type":"object","properties":{"item_price":{"type":"number","description":"The price at which this product will be added to the deal"}}},"prod_attr_comments":{"type":"object","properties":{"comments":{"type":"string","description":"A textual comment associated with this product-deal attachment"}}},"prod_attr_tax_method":{"type":"object","properties":{"tax_method":{"type":"string","enum":["exclusive","inclusive","none"],"description":"The tax option to be applied to the products. \\nWhen using `inclusive`, the tax percentage will already be included in the price. \\nWhen using `exclusive`, the tax will not be included in the price. \\nWhen using `none`, no tax will be added. \\nUse the `tax` field for defining the tax percentage amount. \\nBy default, the user setting value for  tax options will be used. \\nChanging this in one product affects the rest of the  products attached to the deal"}}},"prod_attr_enabled_flag":{"type":"object","properties":{"enabled_flag":{"type":"boolean","default":true,"description":"Whether the product is enabled or not. This makes it possible to add products to a deal with a specific price and discount criteria, but keep them disabled, which refrains them from being included in the deal value calculation. When omitted, the product will be marked as enabled by default"}}},"s_r_deal_product_extended":{"allOf":[{"type":"object","title":"dealProductExtendedInternal"},{"$ref":"#/components/schemas/prod_attr_discount"},{"$ref":"#/components/schemas/prod_attr_discount_type"},{"$ref":"#/components/schemas/prod_attr_product_variation_id"},{"$ref":"#/components/schemas/prod_attr_duration"},{"$ref":"#/components/schemas/prod_attr_quantity"},{"$ref":"#/components/schemas/prod_attr_item_price"},{"$ref":"#/components/schemas/prod_attr_comments"},{"$ref":"#/components/schemas/prod_attr_tax_method"},{"$ref":"#/components/schemas/prod_attr_enabled_flag"}]},"prod_attr_code":{"type":"object","properties":{"code":{"type":"string","description":"The product code"}}},"prod_attr_prices":{"type":"object","properties":{"prices":{"type":"array","items":{"type":"object"},"description":"An array of objects, each containing:  `currency` (string),  `price` (number),  `cost` (number, optional), `overhead_cost` (number, optional). \\nNote that there can only be one price per product per currency.  When `prices` is omitted altogether,  a default price of 0 and a default currency based  on the company\'s currency will be assigned."}}},"prod_attr_unit":{"type":"object","properties":{"unit":{"type":"string","description":"The unit in which this product is sold"}}},"prod_attr_selectable":{"type":"object","properties":{"selectable":{"type":"boolean","description":"Whether this product is selected in deals or not","default":true}}},"prod_attr_id":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the product"}}},"s_product_w_owner_obj":{"type":"object","title":"baseProductResponse","allOf":[{"$ref":"#/components/schemas/prod_attr_name"},{"$ref":"#/components/schemas/s_attr_active_flag"},{"$ref":"#/components/schemas/prod_attr_code"},{"$ref":"#/components/schemas/prod_attr_prices"},{"$ref":"#/components/schemas/prod_attr_unit"},{"$ref":"#/components/schemas/prod_attr_tax"},{"$ref":"#/components/schemas/prod_attr_selectable"},{"$ref":"#/components/schemas/prod_attr_id"},{"type":"object","properties":{"owner_id":{"allOf":[{"description":"Information about the user who owns the product"},{"$ref":"#/components/schemas/s_basic_user_id_w_value"}]}}}]},"s_deal_product_extended":{"allOf":[{"$ref":"#/components/schemas/s_deal_product_basic"},{"$ref":"#/components/schemas/s_r_deal_product_extended"},{"$ref":"#/components/schemas/s_attr_field_order_nbr"},{"type":"object","properties":{"sum_formatted":{"type":"string","description":"The formatted sum of the product"},"quantity_formatted":{"type":"string","description":"The formatted quantity of the product"},"product":{"$ref":"#/components/schemas/s_product_w_owner_obj"}}}]},"s_deal_product_totals":{"type":"object","title":"dealProductTotals","properties":{"products_quantity_total":{"type":"integer","description":"The total quantity of the products"},"products_sum_total":{"type":"integer","description":"The total sum of the products"},"products_quantity_total_formatted":{"type":"string","description":"The total formatted quantity of the products"},"products_sum_total_formatted":{"type":"string","description":"The total formatted sum of the products"}}},"s_related_objects_USER":{"allOf":[{"$ref":"#/components/schemas/s_ro_user"}]},"s_i_product_request_basic":{"allOf":[{"$ref":"#/components/schemas/prod_attr_product_id"},{"$ref":"#/components/schemas/prod_attr_duration_unit"},{"$ref":"#/components/schemas/prod_attr_tax"},{"type":"object","title":"dealProductRequestBasic"}]},"s_i_product_request_extended":{"allOf":[{"$ref":"#/components/schemas/prod_attr_duration"},{"$ref":"#/components/schemas/prod_attr_discount"},{"$ref":"#/components/schemas/prod_attr_discount_type"},{"$ref":"#/components/schemas/prod_attr_product_variation_id"},{"$ref":"#/components/schemas/prod_attr_tax_method"},{"$ref":"#/components/schemas/prod_attr_enabled_flag"},{"$ref":"#/components/schemas/prod_attr_item_price"},{"$ref":"#/components/schemas/prod_attr_quantity"},{"$ref":"#/components/schemas/prod_attr_comments"},{"type":"object","title":"dealProductRequestExtended"}]},"s_deal_product_request":{"type":"object","title":"basicDealProductRequest","allOf":[{"$ref":"#/components/schemas/s_i_product_request_basic"},{"$ref":"#/components/schemas/s_i_product_request_extended"}]},"s_product_response":{"type":"object","title":"basicDealProductResponse","allOf":[{"$ref":"#/components/schemas/s_r_deal_product_basic"},{"$ref":"#/components/schemas/s_r_deal_product_extended"}]},"prod_attr_product_attachment_id":{"type":"object","properties":{"product_attachment_id":{"type":"integer","description":"The ID of the deal-product (the ID of the product attached to the deal)"}}},"s_field_post_body":{"allOf":[{"$ref":"#/components/schemas/s_fields_create"},{"$ref":"#/components/schemas/s_field_type"}]},"s_field_put_body":{"allOf":[{"$ref":"#/components/schemas/s_fields_create"}]},"s_field_response_delete_id":{"allOf":[{"$ref":"#/components/schemas/s_attr_id_deleted"}]},"s_filter_visible":{"allOf":[{"type":"object","title":"filterVisible"}]},"s_attr_filter_name":{"type":"object","properties":{"name":{"type":"string","description":"The name of the filter"}}},"s_attr_filter_id":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the filter"}}},"s_filter_base":{"allOf":[{"$ref":"#/components/schemas/s_filter_visible"},{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_attr_filter_name"},{"$ref":"#/components/schemas/s_attr_filter_id"},{"$ref":"#/components/schemas/s_attr_user_user_id"},{"type":"object","description":"The filter object","properties":{"type":{"type":"string","enum":["deals","org","persons","products","activity"],"description":"The type of the item"}}}]},"s_filter_request":{"allOf":[{"$ref":"#/components/schemas/s_attr_filter_name"},{"type":"object","title":"FilterRequest","properties":{"conditions":{"type":"object","description":"The conditions of the filter as a JSON object. \\nPlease note that a maximum of 16 conditions is allowed per filter and `date` values must be supplied in the `YYYY-MM-DD` format.\\nIt requires a minimum structure as follows: `{\\"glue\\":\\"and\\",\\"conditions\\":\\n  [{\\n    \\"glue\\":\\"and\\",\\n    \\"conditions\\":\\n      [CONDITION_OBJECTS]\\n    },\\n    {\\"glue\\":\\"or\\",\\n    \\"conditions\\":\\n      [CONDITION_OBJECTS]\\n    }]\\n}`. Replace `CONDITION_OBJECTS` with JSON objects of the following structure: \\n  `{\\"object\\":\\"\\",\\n    \\"field_id\\":\\"\\",\\n    \\"operator\\":\\"\\",\\n    \\"value\\":\\"\\", \\n    \\"extra_value\\":\\"\\"\\n  }` \\nor leave the array empty. \\nDepending on the object type you should use another API endpoint to get `field_id`. \\nThere are five types of objects you can choose from:  `\\"person\\"`,  `\\"deal\\"`, `\\"organization\\"`,  `\\"product\\"`,  `\\"activity\\"`  and you can use these types of operators depending on what type of a field you have:  `\\"IS NOT NULL\\"`,  `\\"IS NULL\\"`,  `\\"<=\\"`, `\\">=\\"`, `\\"<\\"`, `\\">\\"`,  `\\"!=\\"`, `\\"=\\"`,  `\\"LIKE \'$%\'\\"`, `\\"LIKE \'%$%\'\\"`, `\\"NOT LIKE \'$%\'\\"`. \\nTo get a better understanding of how filters work try creating them directly from the Fintesk application."}}}]},"s_filter_request_add":{"allOf":[{"type":"object","title":"addFilterRequestRequired","required":["name","conditions","type"]},{"$ref":"#/components/schemas/s_filter_request"},{"type":"object","title":"addFilterRequestType","properties":{"type":{"type":"string","allOf":[{"type":"string","enum":["deals","org","persons","products","activity"]}],"description":"The type of filter to create"}}}]},"s_filter_conditions":{"description":"The filter conditions","type":"object","properties":{"temporary_flag":{"type":"boolean","description":"If the created filter is temporary or not"},"conditions":{"type":"object","description":"The created filter conditions object"}}},"s_filter_w_conditions":{"title":"filterWithConditions","allOf":[{"$ref":"#/components/schemas/s_filter_base"},{"$ref":"#/components/schemas/s_filter_conditions"}]},"s_filter_request_upd":{"allOf":[{"type":"object","title":"updateFilterRequestRequired","required":["conditions"]},{"$ref":"#/components/schemas/s_filter_request"}]},"s_note_request_content":{"type":"object","title":"noteContent","properties":{"content":{"type":"string","description":"The content of the note in HTML format. Subject to sanitization on the back-end."}}},"s_note_response_basic":{"allOf":[{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_attr_user_user_id"},{"type":"object","title":"noteResponseBasic"},{"$ref":"#/components/schemas/s_note_request_content"}]},"s_note_pinned_response":{"type":"object","properties":{"pinned_to_deal_flag":{"type":"boolean","description":"If true, the results are filtered by note to deal pinning state"},"pinned_to_organization_flag":{"type":"boolean","description":"If true, the results are filtered by note to organization pinning state"},"pinned_to_person_flag":{"type":"boolean","description":"If true, the results are filtered by note to person pinning state"}}},"s_attr_note_id":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the note"}}},"s_attr_note_deal_title":{"type":"object","description":"The deal this note is attached to","properties":{"name":{"type":"string","description":"The name of the deal this note is attached to"}}},"s_attr_organization_name":{"type":"object","properties":{"name":{"type":"string","description":"The name of the organization"}}},"s_attr_user_icon_url":{"type":"object","properties":{"icon_url":{"type":"string","nullable":true,"description":"The URL of the note creator avatar picture"}}},"s_note_response_objects":{"allOf":[{"$ref":"#/components/schemas/s_note_pinned_response"},{"$ref":"#/components/schemas/s_attr_person_id_ref"},{"$ref":"#/components/schemas/s_attr_deal_id_ref"},{"$ref":"#/components/schemas/s_attr_org_id"},{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_attr_note_id"},{"type":"object","title":"noteResponseObjects","properties":{"deal":{"$ref":"#/components/schemas/s_attr_note_deal_title"},"organization":{"allOf":[{"$ref":"#/components/schemas/s_attr_organization_name"},{"type":"object","description":"The organization the note is attached to"}]},"person":{"allOf":[{"$ref":"#/components/schemas/s_person_full_name"},{"type":"object","description":"The person the note is attached to"}]},"user":{"allOf":[{"$ref":"#/components/schemas/s_attr_user_icon_url"},{"$ref":"#/components/schemas/s_attr_user_email"},{"type":"object","description":"The user who created the note","properties":{"is_you":{"type":"boolean","description":"Whether the note is created by you or not"},"name":{"type":"string","description":"The name of the note creator"}}}]}}}]},"s_note_w_objects":{"allOf":[{"$ref":"#/components/schemas/s_note_response_basic"},{"$ref":"#/components/schemas/s_note_response_objects"}]},"s_note_request_ids":{"type":"object","title":"noteRequestReferenceIds","properties":{"deal_id":{"type":"integer","description":"The ID of the deal the note will be attached to. This property is required unless one of (`person_id/org_id`) is specified."},"person_id":{"type":"integer","description":"The ID of the person the note will be attached to. This property is required unless one of (`deal_id/org_id`) is specified."},"org_id":{"type":"integer","description":"The ID of the organization the note will be attached  to. This property is required unless one of (`deal_id/person_id`) is specified."}}},"s_note_pinned_request":{"type":"object","properties":{"pinned_to_deal_flag":{"allOf":[{"title":"numberBoolean","type":"number","enum":[0,1]}],"description":"If set, the results are filtered by note to deal pinning state (`deal_id` is also required)"},"pinned_to_organization_flag":{"allOf":[{"title":"numberBoolean","type":"number","enum":[0,1]}],"description":"If set, the results are filtered by note to organization pinning state (`org_id` is also required)"},"pinned_to_person_flag":{"allOf":[{"title":"numberBoolean","type":"number","enum":[0,1]}],"description":"If set, the results are filtered by note to person pinning state (`person_id` is also required)"}}},"s_note_request_pin":{"allOf":[{"$ref":"#/components/schemas/s_attr_add_time_request"},{"$ref":"#/components/schemas/s_note_pinned_request"},{"type":"object","title":"noteRequestPin","properties":{"user_id":{"type":"integer","description":"The ID of the user who will be marked as the author of the note. Only an admin can change the author."}}}]},"s_note_request":{"type":"object","title":"noteRequest","allOf":[{"$ref":"#/components/schemas/s_note_request_content"},{"$ref":"#/components/schemas/s_note_request_ids"},{"$ref":"#/components/schemas/s_note_request_pin"}]},"s_note_response_comment":{"allOf":[{"type":"object","title":"noteResponseComment","properties":{"uuid":{"type":"string","format":"uuid","description":"The ID of the note"},"object_id":{"type":"string","description":"The ID of the object that the comment is attached to, will be the id of the note"},"object_type":{"type":"string","description":"The type of object that the comment is attached to, will be \\"note\\""},"updater_id":{"type":"integer","description":"The ID of the user who last updated the comment"}}},{"$ref":"#/components/schemas/s_basic_company_id"}]},"s_note_w_comment":{"allOf":[{"$ref":"#/components/schemas/s_note_response_basic"},{"$ref":"#/components/schemas/s_note_response_comment"}]},"s_related_picture_id":{"type":"object","description":"The ID of the picture","allOf":[{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"allOf":[{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the picture associated with the item"}}},{"type":"object","properties":{"item_type":{"type":"string","description":"The type of item the picture is related to"},"item_id":{"type":"integer","description":"The ID of related item"},"added_by_user_id":{"type":"integer","description":"The ID of the user who added the picture"},"pictures":{"type":"object","properties":{"128":{"type":"string","description":"The URL of the 128*128 picture"},"512":{"type":"string","description":"The URL of the 512*512 picture"}}}}}]}]},"s_organization_picture_id":{"type":"object","title":"organizationPictureId","properties":{"picture_id":{"$ref":"#/components/schemas/s_related_picture_id"}}},"s_organization_redundant":{"allOf":[{"$ref":"#/components/schemas/s_attr_user_owner_name"},{"type":"object","title":"organizationRedundant"}]},"s_attr_organization_label":{"allOf":[{"type":"object","title":"organizationLabel"}]},"s_attr_organization_id":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the organization"}}},"s_organization_address":{"allOf":[{"$ref":"#/components/schemas/s_attr_organization_address"},{"type":"object","title":"organizationAddressInfo","properties":{"country_code":{"type":"string","nullable":true,"description":"The country code of the organization"},"address_subpremise":{"type":"string","description":"The sub-premise of the organization location"},"address_street_number":{"type":"string","description":"The street number of the organization location"},"address_route":{"type":"string","description":"The route of the organization location"},"address_sublocality":{"type":"string","description":"The sub-locality of the organization location"},"address_locality":{"type":"string","description":"The locality of the organization location"},"address_admin_area_level_1":{"type":"string","description":"The level 1 admin area of the organization location"},"address_admin_area_level_2":{"type":"string","description":"The level 2 admin area of the organization location"},"address_country":{"type":"string","description":"The country of the organization location"},"address_postal_code":{"type":"string","description":"The postal code of the organization location"},"address_formatted_address":{"type":"string","description":"The formatted organization location"}}}]},"s_organization_count_and_address_info":{"type":"object","title":"organizationCountAndAddressInfo","allOf":[{"$ref":"#/components/schemas/s_organization_address"}]},"s_deal_count_and_activity_info":{"type":"object","title":"dealsCountAndActivityInfo","allOf":[{"$ref":"#/components/schemas/s_deals_activity_info"}]},"s_organization_base":{"type":"object","title":"baseOrganizationItem","allOf":[{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_attr_organization_address"},{"$ref":"#/components/schemas/s_organization_picture_id"},{"$ref":"#/components/schemas/s_organization_redundant"},{"$ref":"#/components/schemas/s_attr_organization_label"},{"$ref":"#/components/schemas/s_basic_company_id"},{"$ref":"#/components/schemas/s_attr_first_char"},{"$ref":"#/components/schemas/s_attr_organization_name"},{"$ref":"#/components/schemas/s_attr_organization_id"},{"type":"object","properties":{"owner_id":{"allOf":[{"description":"The User who is associated with the organization"},{"$ref":"#/components/schemas/s_basic_user_id_w_value"}]}}},{"type":"object","title":"additionalBaseOrganizationItemInfo","allOf":[{"$ref":"#/components/schemas/s_organization_count_and_address_info"},{"$ref":"#/components/schemas/s_deal_count_and_activity_info"}]}]},"s_related_objects_O_U_Pic":{"allOf":[{"$ref":"#/components/schemas/s_ro_user"},{"$ref":"#/components/schemas/s_ro_person"},{"type":"object","properties":{"picture":{"type":"object","description":"The picture that is associated with the item","properties":{"PICTURE_ID":{"$ref":"#/components/schemas/s_related_picture_id"}}}}}]},"s_organization_w_edit_name":{"title":"baseOrganizationItemWithEditNameFlag","allOf":[{"$ref":"#/components/schemas/s_organization_base"}]},"s_search_item_organization":{"allOf":[{"$ref":"#/components/schemas/s_search_item_base"},{"$ref":"#/components/schemas/s_attr_organization_address"},{"type":"object","title":"itemOrganizationSearchResults","properties":{"notes":{"type":"array","description":"An array of notes","items":{"type":"string"}}}}]},"s_organization_activity_object":{"type":"object","title":"organizationActivityObject","properties":{"last_activity":{"type":"object","nullable":true,"description":"Please refer to response schema of  [Activity](../../fintesk/api/v1#tag/Activities/operation/getActivity)"},"next_activity":{"type":"object","nullable":true,"description":"Please refer to response schema of  [Activity](../../fintesk/api/v1#tag/Activities/operation/getActivity)"}}},"s_organization_item":{"title":"organizationItem","allOf":[{"$ref":"#/components/schemas/s_organization_w_edit_name"},{"$ref":"#/components/schemas/s_organization_activity_object"}]},"s_organization_item_follower":{"allOf":[{"type":"object","title":"organizationFollower"}]},"s_attr_product_id_ref":{"type":"object","properties":{"product_id":{"description":"The ID of the product this Item is associated with","type":"integer"}}},"s_attr_activity_id_ref":{"type":"object","properties":{"activity_id":{"description":"The ID of the activity this Item is associated with","type":"integer"}}},"s_attr_user_id_ref":{"type":"object","properties":{"user_id":{"type":"integer","description":"The ID of the user this Item is associated with"}}},"s_file_reference":{"allOf":[{"$ref":"#/components/schemas/s_attr_person_id_ref"},{"$ref":"#/components/schemas/s_attr_deal_id_ref"},{"$ref":"#/components/schemas/s_attr_org_id"},{"$ref":"#/components/schemas/s_attr_product_id_ref"},{"$ref":"#/components/schemas/s_attr_activity_id_ref"},{"$ref":"#/components/schemas/s_attr_user_id_ref"},{"type":"object","title":"fileReferences"}]},"prod_attr_product_name":{"type":"object","title":"productProductName","properties":{"product_name":{"type":"string","description":"The name of the product associated with the entity"}}},"s_file_redundant":{"allOf":[{"$ref":"#/components/schemas/s_attr_organization_org_name"},{"$ref":"#/components/schemas/s_attr_person_person_name"},{"$ref":"#/components/schemas/s_attr_deal_deal_title"},{"$ref":"#/components/schemas/s_attr_organization_org_name"},{"$ref":"#/components/schemas/prod_attr_product_name"},{"type":"object","title":"fileRedundant"}]},"s_file_bucket":{"type":"object","title":"fileBucket","properties":{"url":{"type":"string","description":"The URL of the download file"},"file_name":{"type":"string","description":"The original name of the file"},"file_size":{"type":"integer","description":"The size of the file"},"inline_flag":{"type":"boolean","description":"Whether the file was uploaded as inline or not"},"remote_location":{"type":"string","description":"The location type to send the file to. Only googledrive is supported at the moment."},"remote_id":{"type":"string","description":"The ID of the remote item"},"cid":{"type":"string","description":"The ID of the inline attachment"},"s3_bucket":{"type":"string","description":"The location of the cloud storage"}}},"s_attr_file_id":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the file"}}},"s_file":{"allOf":[{"$ref":"#/components/schemas/s_file_reference"},{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_file_redundant"},{"$ref":"#/components/schemas/s_file_bucket"},{"$ref":"#/components/schemas/s_attr_file_id"},{"type":"object","description":"The file data","properties":{"name":{"type":"string","description":"The visible name of the file"},"description":{"type":"string","description":"The description of the file"}}}]},"s_person_request":{"allOf":[{"$ref":"#/components/schemas/s_person_item_arrays"},{"$ref":"#/components/schemas/s_attr_person_name"},{"$ref":"#/components/schemas/s_attr_add_time_request"},{"$ref":"#/components/schemas/s_attr_org_id"},{"title":"basicPersonRequest","type":"object","properties":{"owner_id":{"type":"integer","description":"The ID of the user who will be marked as the owner of this person.  When omitted, the authorized user ID will be used."}}}]},"s_search_item_person":{"allOf":[{"$ref":"#/components/schemas/s_search_item_base"},{"$ref":"#/components/schemas/s_search_item_field_notes"},{"$ref":"#/components/schemas/s_search_item_field_organization"},{"type":"object","title":"itemPersonSearchResults","properties":{"phones":{"type":"array","description":"An array of phone numbers","items":{"type":"string"}},"emails":{"type":"array","description":"An array of email addresses","items":{"type":"string"}}}}]},"prod_attr_owner_id":{"type":"object","title":"owner_id","properties":{"owner_id":{"type":"integer","description":"The ID of the user who will be marked as the owner of this product. When omitted, the authorized user ID will be used"}}},"prod_attr_description":{"type":"object","properties":{"description":{"type":"string","description":"The description of the product"}}},"prod_attr_category":{"type":"object","properties":{"category":{"type":"string","description":"The category of the product"}}},"prod_attr_files_count":{"type":"object","properties":{"files_count":{"type":"integer","description":"The count of files"}}},"prod_attr_first_char":{"allOf":[{"$ref":"#/components/schemas/s_attr_first_char"}]},"s_product_base":{"allOf":[{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_basic_company_id"},{"$ref":"#/components/schemas/prod_attr_id"},{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/prod_attr_owner_id"},{"$ref":"#/components/schemas/prod_attr_name"},{"$ref":"#/components/schemas/prod_attr_tax"},{"$ref":"#/components/schemas/prod_attr_code"},{"$ref":"#/components/schemas/prod_attr_description"},{"$ref":"#/components/schemas/prod_attr_unit"},{"$ref":"#/components/schemas/prod_attr_category"},{"$ref":"#/components/schemas/prod_attr_selectable"},{"$ref":"#/components/schemas/prod_attr_files_count"},{"$ref":"#/components/schemas/prod_attr_first_char"}]},"s_product_base_w_deal_id":{"allOf":[{"$ref":"#/components/schemas/s_product_base"},{"$ref":"#/components/schemas/dealprod_attr_deal_id"}]},"s_person_products":{"type":"object","properties":{"DEAL_ID":{"type":"object","properties":{"deal":{"properties":{"allOf":[{"$ref":"../../_components/schemas_entities/s_attr_person_id_ref.yaml"},{"$ref":"../../_components/schemas_entities/s_attr_org_id.yaml"},{"$ref":"../../_components/schemas_entities/s_attr_user_id_ref.yaml"},{"$ref":"../../Deals/schemas/s_deals_activity_info.yaml"},{"$ref":"../../Deals/schemas/s_deals_get_basic.yaml"},{"$ref":"../../_components/schemas_entities/s_basic_company_id.yaml"},{"$ref":"../../Deals/schemas/s_attr_deal_id.yaml"},{"type":"object","properties":{"first_add_time":{"type":"string","description":"The first creation date and time of the deal"}}}],"product":{"$ref":"#/components/schemas/s_product_base_w_deal_id"}}}}}}},"s_pipeline_base_w_selected_flag":{"type":"object","title":"basePipelineWithSelectedFlag","allOf":[{"$ref":"#/components/schemas/s_pipeline_base"},{"type":"object","properties":{"selected":{"type":"boolean","description":"A boolean that shows if the pipeline is selected from a filter or not"}}}]},"s_pipeline_request":{"allOf":[{"$ref":"#/components/schemas/s_attr_field_order_nbr"},{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_pipeline_attr_deal_probability"},{"$ref":"#/components/schemas/s_attr_pipeline_name"},{"type":"object","title":"pipelineRequest"}]},"s_product_request":{"allOf":[{"$ref":"#/components/schemas/prod_attr_code"},{"$ref":"#/components/schemas/prod_attr_prices"},{"$ref":"#/components/schemas/prod_attr_unit"},{"$ref":"#/components/schemas/prod_attr_tax"},{"$ref":"#/components/schemas/prod_attr_selectable"},{"$ref":"#/components/schemas/s_attr_active_flag"},{"title":"productRequest","type":"object"},{"$ref":"#/components/schemas/prod_attr_owner_id"}]},"s_product_request_crud":{"type":"object","title":"updateProductRequest","allOf":[{"$ref":"#/components/schemas/s_product_request"},{"$ref":"#/components/schemas/prod_attr_name"}]},"s_fail_response":{"title":"failResponse","type":"object","properties":{"success":{"type":"boolean","description":"If the response is successful or not"},"error":{"type":"string","description":"The error message"},"errorCode":{"type":"integer","description":"The response error code"}}},"s_attr_item_id":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the Item"}}},"s_item_activity":{"allOf":[{"$ref":"#/components/schemas/s_attr_item_id"},{"type":"object","title":"activity","properties":{"item":{"type":"string","enum":["activity"]},"data":{"title":"activityResponseObject","allOf":[{"$ref":"#/components/schemas/s_activity_extended"},{"$ref":"#/components/schemas/s_activity"}]}}}]},"s_item_activity_type":{"allOf":[{"$ref":"#/components/schemas/s_attr_item_id"},{"type":"object","title":"activityType","properties":{"item":{"type":"string","enum":["activityType"]},"data":{"$ref":"#/components/schemas/s_activity_type"}}}]},"s_item_deal":{"allOf":[{"$ref":"#/components/schemas/s_attr_item_id"},{"type":"object","title":"deal","properties":{"item":{"type":"string","enum":["deal"]},"data":{"$ref":"#/components/schemas/s_deal_strict"}}}]},"s_item_file":{"allOf":[{"$ref":"#/components/schemas/s_attr_item_id"},{"type":"object","title":"file","properties":{"item":{"type":"string","enum":["file"]},"data":{"$ref":"#/components/schemas/s_file"}}}]},"s_item_filter":{"allOf":[{"$ref":"#/components/schemas/s_attr_item_id"},{"type":"object","title":"filter","properties":{"item":{"type":"string","enum":["filter"]},"data":{"$ref":"#/components/schemas/s_filter_base"}}}]},"s_item_note":{"allOf":[{"$ref":"#/components/schemas/s_attr_item_id"},{"type":"object","title":"note","properties":{"item":{"type":"string","enum":["note"]},"data":{"$ref":"#/components/schemas/s_note_w_objects"}}}]},"s_recents_merge_person_info":{"type":"object","title":"mergePersonItem","allOf":[{"$ref":"#/components/schemas/s_person_item"},{"type":"object","title":"additionalMergePersonInfo","allOf":["../../Persons/schemas/s_recents_person_name_count_and_email_info_with_ids.yaml","../../Persons/schemas/s_recents_merge_person_deal_related_info.yaml"]}]},"s_item_person":{"allOf":[{"$ref":"#/components/schemas/s_attr_item_id"},{"type":"object","title":"person","properties":{"item":{"type":"string","enum":["person"]},"data":{"$ref":"#/components/schemas/s_recents_merge_person_info"}}}]},"s_item_organization":{"allOf":[{"$ref":"#/components/schemas/s_attr_item_id"},{"type":"object","title":"organization","properties":{"item":{"type":"string","enum":["organization"]},"data":{"$ref":"#/components/schemas/s_organization_base"}}}]},"s_item_pipeline":{"allOf":[{"$ref":"#/components/schemas/s_attr_item_id"},{"type":"object","title":"pipeline","properties":{"item":{"type":"string","enum":["pipeline"]},"data":{"$ref":"#/components/schemas/s_pipeline_base"}}}]},"s_product_base_w_prices":{"allOf":[{"$ref":"#/components/schemas/s_product_base"},{"$ref":"#/components/schemas/prod_attr_prices"}]},"s_item_product":{"allOf":[{"$ref":"#/components/schemas/s_attr_item_id"},{"type":"object","title":"product","properties":{"item":{"type":"string","enum":["product"]},"data":{"$ref":"#/components/schemas/s_product_base_w_prices"}}}]},"s_item_stage":{"allOf":[{"$ref":"#/components/schemas/s_attr_item_id"},{"type":"object","title":"stage","properties":{"item":{"type":"string","enum":["stage"]},"data":{"$ref":"#/components/schemas/s_stage_base"}}}]},"s_user_locale":{"type":"object","title":"userTimezone","properties":{"timezone_name":{"type":"string","description":"The user timezone name"},"timezone_offset":{"type":"string","description":"The user timezone offset"},"locale":{"type":"string","description":"The user locale"},"lang":{"type":"integer","description":"The user language ID"}}},"s_attr_user_role_id":{"type":"object","properties":{"role_id":{"type":"integer","description":"The ID of the role the user was added to"}}},"s_user":{"allOf":[{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_user_locale"},{"$ref":"#/components/schemas/s_attr_user_email"},{"$ref":"#/components/schemas/s_attr_user_role_id"},{"$ref":"#/components/schemas/s_attr_user_icon_url"},{"$ref":"#/components/schemas/s_attr_user_name"},{"$ref":"#/components/schemas/s_attr_user_id"},{"type":"object","title":"baseUser","properties":{"default_currency":{"type":"string","description":"The user default currency"},"phone":{"type":"string","nullable":true,"description":"The user phone"},"last_login":{"type":"string","description":"The last login date and time of the user. Format: YYYY-MM-DD HH:MM:SS"},"is_you":{"type":"boolean","description":"Boolean that indicates if the requested user is the same which is logged in (in this case, always true)"}}}]},"s_item_user":{"allOf":[{"$ref":"#/components/schemas/s_attr_item_id"},{"type":"object","title":"user","properties":{"item":{"type":"string","enum":["user"]},"data":{"$ref":"#/components/schemas/s_user"}}}]},"s_attr_role_name":{"type":"object","properties":{"name":{"type":"string","description":"The name of the role"}}},"s_attr_role_parent_role_id":{"type":"object","properties":{"parent_role_id":{"type":"integer","description":"The ID of the parent role"}}},"s_role_base_request":{"allOf":[{"$ref":"#/components/schemas/s_attr_role_name"},{"$ref":"#/components/schemas/s_attr_role_parent_role_id"},{"type":"object","title":"baseRoleRequest"}]},"s_attr_role_id":{"type":"object","properties":{"id":{"type":"string","description":"The ID of the role"}}},"s_role_subrole_counts":{"allOf":[{"$ref":"#/components/schemas/s_attr_role_id"},{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"type":"object","properties":{"assignment_count":{"type":"string","description":"The number of users assigned to this role"},"sub_role_count":{"type":"string","description":"The number of sub-roles"}}}]},"s_role_subrole":{"allOf":[{"type":"object","title":"subRole","description":"The details of the sub-role"},{"$ref":"#/components/schemas/s_role_base_request"},{"$ref":"#/components/schemas/s_role_subrole_counts"}]},"s_role_fullrole":{"title":"fullRole","allOf":[{"$ref":"#/components/schemas/s_role_subrole"},{"type":"object","properties":{"level":{"type":"integer","description":"The level of role in the role hierarchy"}}}]},"s_attr_id_created":{"type":"object","title":"createdID","properties":{"id":{"type":"integer","description":"The ID of the created item."}}},"s_role_settings_default_visibility":{"description":"The settings for the role","type":"object","properties":{"deal_default_visibility":{"type":"number","description":"The default visibility level of the deals for the role"},"org_default_visibility":{"type":"number","description":"The default visibility level of the organizations for the role"},"person_default_visibility":{"type":"number","description":"The default visibility level of the persons for the role"},"product_default_visibility":{"type":"number","description":"The default visibility level of the products for the role"},"deal_access_level":{"type":"number","description":"The access level of the deals for the role (only for default role)"},"org_access_level":{"type":"number","description":"The access level of the organizations for the role (only for default role)"},"person_access_level":{"type":"number","description":"The access level of the persons for the role (only for default role)"},"product_access_level":{"type":"number","description":"The access level of the products for the role (only for default role)"}}},"s_attr_id_updated":{"type":"object","title":"updatedID","properties":{"id":{"type":"integer","description":"The ID of the updated item."}}},"s_role_assignment":{"title":"roleAssignment","allOf":[{"$ref":"#/components/schemas/s_role_base_request"},{"$ref":"#/components/schemas/s_attr_user_role_id"},{"$ref":"#/components/schemas/s_attr_user_user_id"},{"type":"object","properties":{"active_flag":{"type":"boolean","description":"Whether the role is active or not"},"type":{"type":"string","description":"The assignment type"}}}],"description":"The assignment data of the role"},"s_role_setting_post":{"title":"addOrUpdateRoleSettingRequest","type":"object","required":["setting_key","value"],"properties":{"setting_key":{"type":"string","enum":["deal_default_visibility","org_default_visibility","person_default_visibility","product_default_visibility"]},"value":{"type":"integer","enum":[1,3,5,7],"description":"Possible values for the `default_visibility` setting depending on the subscription plan: <br> <table class=\'role-setting\'>\\n  <caption>\\n    <b>Essential / Advanced plan</b>\\n  </caption>\\n  <tr>\\n    <th>\\n      <b>Value</b>\\n    </th>\\n    <th>\\n      <b>Description</b>\\n    </th>\\n  </tr>\\n  <tr>\\n    <td>`1`</td>\\n    <td>Owner & Followers</td>\\n  </tr>\\n  <tr>\\n    <td>`3`</td>\\n    <td>Entire company</td>\\n  </tr>\\n</table> <br>\\n  <table class=\'role-setting\'>\\n    <caption>\\n      <b>Professional / Enterprise plan</b>\\n    </caption>\\n    <tr>\\n      <th>\\n        <b>Value</b>\\n      </th>\\n      <th>\\n        <b>Description</b>\\n      </th>\\n    </tr>\\n    <tr>\\n      <td>`1`</td>\\n      <td>Owner only</td>\\n    </tr>\\n    <tr>\\n      <td>`3`</td>\\n      <td>Owner&#39;s visibility group</td>\\n    </tr>\\n    <tr>\\n      <td>`5`</td>\\n      <td>Owner&#39;s visibility group and sub-groups</td>\\n    </tr>\\n    <tr>\\n      <td>`7`</td>\\n      <td>Entire company</td>\\n    </tr>\\n  </table>\\n  <br> Read more about visibility  groups \\n  <a href=\'https://support.pipedrive.com/en/article/visibility-groups\'>here</a>."}}},"s_role_pipelines":{"type":"object","properties":{"pipeline_ids":{"type":"array","items":{"type":"number","description":"The ID of the pipeline"},"description":"Either visible or hidden pipeline ids"},"visible":{"type":"boolean","description":"Whether visible or hidden pipeline ids were returned"}},"description":"The response data"},"s_attr_role_visible_pipeline_ids":{"type":"object","properties":{"visible_pipeline_ids":{"type":"object","description":"The pipeline IDs to make the pipelines visible (add) and/or hidden (remove) for the specified role.  It requires the following JSON structure:  `{ \\"add\\": \\"[1]\\", \\"remove\\": \\"[3,4]\\" }`."}}},"s_stage_pipeline_attr":{"type":"object","properties":{"pipeline_name":{"type":"string","description":"The name of the pipeline"},"pipeline_deal_probability":{"type":"boolean","description":"The pipeline deal probability. When `true`, overrides the stage probability."}}},"s_stage_attr_deal_probability":{"type":"object","properties":{"deal_probability":{"type":"integer","description":"The success probability percentage of the deal. Used/shown when the deal weighted values are used."}}},"s_stage_deal_attr":{"allOf":[{"$ref":"#/components/schemas/s_stage_attr_deal_probability"},{"type":"object","title":"stageRotten","properties":{"rotten_flag":{"type":"boolean","description":"Whether deals in this stage can become rotten"},"rotten_days":{"type":"integer","description":"The number of days the deals not updated in this stage would become rotten. Applies only if the `rotten_flag` is set."}}}]},"s_stage":{"title":"stageResponse","allOf":[{"$ref":"#/components/schemas/s_stage_base"},{"$ref":"#/components/schemas/s_stage_pipeline_attr"},{"$ref":"#/components/schemas/s_stage_deal_attr"}]},"s_stage_request_basic":{"allOf":[{"$ref":"#/components/schemas/s_attr_deal_pipeline_id"},{"$ref":"#/components/schemas/s_stage_attr_deal_probability"},{"$ref":"#/components/schemas/s_attr_stage_name"},{"type":"object","title":"stageBasicRequest","properties":{"rotten_flag":{"type":"boolean","description":"Whether deals in this stage can become rotten"},"rotten_days":{"type":"integer","description":"The number of days the deals not updated in this stage would become rotten. Applies only if the `rotten_flag` is set."}}}]},"s_attr_deal_summary_count":{"type":"object","properties":{"count":{"type":"integer","description":"Deals count per currency"}}},"s_attr_deal_summary_value":{"type":"object","properties":{"value":{"type":"integer","description":"Deals value per currency"}}},"s_deal_summary":{"type":"object","title":"dealSummary","properties":{"deals_summary":{"type":"object","description":"Deals summary","properties":{"per_stages":{"type":"object","description":"The stage objects containing deals currency information","properties":{"STAGE_ID":{"type":"object","description":"The currency summaries per stage. This parameter is dynamic and  changes according to `stage_id` value.","properties":{"CURRENCY_ID":{"allOf":[{"$ref":"#/components/schemas/s_attr_deal_weighted_value_formatted"},{"$ref":"#/components/schemas/s_attr_deal_weighted_value"},{"$ref":"#/components/schemas/s_attr_deal_summary_count"},{"$ref":"#/components/schemas/s_attr_deal_summary_value"},{"type":"object","description":"The currency summary. This parameter is dynamic and  changes according to `currency_id` value.","properties":{"value_formatted":{"type":"string","description":"Deals value formatted per currency"}}}]}}}}},"per_currency":{"type":"object","description":"The currency count summary","properties":{"CURRENCY_ID":{"type":"integer","description":"Deals count per currency. This parameter is dynamic and changes  according to `currency_id` value."}}},"total_count":{"type":"integer","description":"Deals count"},"per_currency_full":{"type":"object","description":"Full currency summaries","properties":{"CURRENCY_ID":{"allOf":[{"$ref":"#/components/schemas/s_attr_deal_summary_count"},{"$ref":"#/components/schemas/s_attr_deal_summary_value"},{"type":"object","description":"The currency summary. This parameter is dynamic and changes  according to `currency_id` value."}]}}}}}}},"s_stage_request_w_order_nbr":{"title":"stageWOrderNbr","allOf":[{"$ref":"#/components/schemas/s_stage_request_basic"},{"type":"object","properties":{"order_nbr":{"type":"integer","description":"An order number for this stage. Order numbers should be used to order the stages in the pipeline."}}}]},"s_user_access":{"type":"object","title":"userAccess","properties":{"access":{"type":"array","items":{"type":"object","properties":{"app":{"type":"string","enum":["sales","global","account_settings"]},"admin":{"type":"boolean"},"permission_set_id":{"type":"string"}},"required":["app"],"description":"The access given to the user. Each item in the array represents access to a specific app. Optionally may include either admin flag or permission set ID to specify which access to give within the app. If both are omitted, the default access for the corresponding app will be used. It requires structure as follows: `[{ app: \'sales\', permission_set_id: \'62cc4d7f-4038-4352-abf3-a8c1c822b631\' }, { app: \'global\', admin: true }, { app: \'account_settings\' }]`\\n","default":[{"app":"sales"}]}}}},"s_user_company":{"allOf":[{"$ref":"#/components/schemas/s_basic_company_id"},{"type":"object","title":"userCompany","properties":{"company_name":{"type":"string","description":"The user company name"},"company_domain":{"type":"string","description":"The user company domain"},"company_country":{"type":"string","description":"The user company country"},"company_industry":{"type":"string","description":"The user company industry"},"language":{"type":"object","description":"The user language details","properties":{"language_code":{"type":"string","description":"The language code. E.g. en"},"country_code":{"type":"string","description":"The country code. E.g. US"}}}}}]},"s_user_w_company":{"title":"userWithCompany","allOf":[{"$ref":"#/components/schemas/s_user"},{"$ref":"#/components/schemas/s_user_company"}]}}}}}},"docusaurus-theme-redoc":{"theme-redoc":{"lightTheme":{"typography":{"fontFamily":"var(--ifm-font-family-base)","fontSize":"var(--ifm-font-size-base)","lineHeight":"var(--ifm-line-height-base)","fontWeightLight":"var(--ifm-font-weight-light)","fontWeightRegular":"var(--ifm-font-weight-base)","fontWeightBold":"var(--ifm-font-weight-bold)","headings":{"fontFamily":"var(--ifm-heading-font-family)","fontWeight":"var(--ifm-heading-font-weight)","lineHeight":"var(--ifm-heading-line-height)"},"code":{"fontFamily":"var(--ifm-font-family-monospace)","lineHeight":"var(--ifm-pre-line-height)"}},"sidebar":{"width":"300px","backgroundColor":"#ffffff"},"rightPanel":{"backgroundColor":"#303846"},"colors":{"primary":{"main":"#1890ff"}},"theme":{"prism":{"additionalLanguages":["scala"]}}},"darkTheme":{"typography":{"fontFamily":"var(--ifm-font-family-base)","fontSize":"var(--ifm-font-size-base)","lineHeight":"var(--ifm-line-height-base)","fontWeightLight":"var(--ifm-font-weight-light)","fontWeightRegular":"var(--ifm-font-weight-base)","fontWeightBold":"var(--ifm-font-weight-bold)","headings":{"fontFamily":"var(--ifm-heading-font-family)","fontWeight":"var(--ifm-heading-font-weight)","lineHeight":"var(--ifm-heading-line-height)"},"code":{"fontFamily":"var(--ifm-font-family-monospace)","lineHeight":"var(--ifm-pre-line-height)"}},"sidebar":{"width":"300px","backgroundColor":"rgb(24, 25, 26)","textColor":"#f5f6f7","arrow":{"color":"#f5f6f7"}},"colors":{"text":{"primary":"#f5f6f7","secondary":"rgba(255, 255, 255, 1)"},"gray":{"50":"#FAFAFA","100":"#F5F5F5"},"border":{"dark":"#ffffff","light":"rgba(0,0,0, 0.1)"},"primary":{"main":"#1890ff"}},"schema":{"nestedBackground":"rgb(24, 25, 26)","typeNameColor":"rgba(255, 255, 255, 1)","typeTitleColor":"rgba(255, 255, 255, 1)"},"theme":{"prism":{"additionalLanguages":["scala"]}}},"options":{"scrollYOffset":"nav.navbar","expandSingleSchemaField":true,"menuToggle":true,"suppressWarnings":true}}},"docusaurus-plugin-google-tag-manager":{"default":{"containerId":"GTM-MFMP7WDH","id":"default"}},"@orama/plugin-docusaurus-v3":{"default":{"oramaMode":"oss","oramaDocs":[{"title":"What happens to my billing when I add a user in Fintesk?","content":"<p>&lt;!-- ../../billing/billing-information/what-happens-to-my-billing-when-i-add-a-user-in-fintesk.md --&gt;</p>\\n<p>&lt;!-- # What happens to my billing when I add a user in Fintesk? --&gt;</p>\\n<p>When you invite a user to join your Fintesk account and give them <a href=\\"../../kb/users-and-permissions/global-user-management\\">&quot;deals app access&quot;</a>, that new user will occupy a seat in your Fintesk account.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202023-03-20%20at%2013.55.53.png\\" alt=\\"1\\"> --&gt;</p>\\n<ul>\\n<li>\\n<p><strong>If you add a new user and already have an open seat in your account,</strong> then that user will occupy that open seat. In this case, nothing in the account\'s billing information will change.</p>\\n</li>\\n<li>\\n<p><strong>If you do not have an open seat in your account</strong>, adding a user will increase the billed seat count in your subscription. This means you will be billed immediately after the seat has been added to your account. The charge you see will be a prorated charge reflecting the time remaining in your current subscription cycle.</p>\\n</li>\\n</ul>\\n<p>For example, if your monthly <strong>Advanced plan</strong> billing cycle started on March 5th and you add an extra seat on March 20th, you will be charged on March 20th the prorated amount of the time left of the current cycle for your extra seat. On April 5th, you will be billed the total amount for the users on the monthly Advanced plan.</p>\\n<p>You will see these changes and your billing update in your checkout summary.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202023-03-20%20at%2016.43.09.png\\" alt=\\"1\\"> --&gt;</p>\\n<p>Learn more about the difference between a billed seat and a Fintesk user in <a href=\\"../../kb/getting-started/what-is-the-difference-between-a-user-and-a-seat\\">this article</a> and find more information on pricing on our <a href=\\"https://fintesk.com/es/precios/?utm_source=fintesk-docs\\">pricing page</a>.</p>\\n","section":"What happens to my billing when I add a user in Fintesk?","version":"current","path":"/billing/billing-information/what-happens-to-my-billing-when-i-add-a-user-in-fintesk","category":"default"},{"title":"What happens to my billing when I change my billing frequency?","content":":::tip\\nNote: This action is only available to users with billing access set up through User Management.\\n:::\\nAny Fintesk user with billing access can opt to change between paying on a monthly cycle or an annual cycle at any point in the billing cycle.\\nThe change will take effect at the beginning of the next billing cycle. The new invoice will also be issued at the beginning of the next billing cycle when the next renewal invoice is issued.\\nFurther subscription changes made before the end of the current billing cycle may override the scheduled billing frequency change.\\n\\n","section":"What happens to my billing when I change my billing frequency?","version":"current","path":"/billing/billing-information/what-happens-to-my-billing-when-i-change-my-billing-frequency#what-happens-to-my-billing-when-i-change-my-billing-frequency","category":"default"},{"title":"Monthly to annual","content":"If you change from monthly to annual billing, the changes will take effect at the beginning of the next billing cycle.\\nExample:\\nA user is on a monthly billing cycle renewed on January 1 and switches from monthly billing to annual billing on January 15.\\nThe user will be on the monthly billing cycle for the rest of the billing period and be charged for the annual billing subscription on February 1.\\n<!--\\nWhile the change is pending, you will see a banner at the top of your billing overview page specifying the scheduled update. -->\\n\\n","section":"What happens to my billing when I change my billing frequency?","version":"current","path":"/billing/billing-information/what-happens-to-my-billing-when-i-change-my-billing-frequency#monthly-to-annual","category":"default"},{"title":"Annual to monthly","content":"If you change from annual to monthly billing, the changes will take effect from the next renewal date.\\nExample:\\nA user is on an annual billing plan renewed on January 1 and switches to monthly billing on June 30.\\nThe user will keep the annual billing cycle with the associated discount for the rest of the billing period and be charged for the monthly billing subscription on January 1 (of the following year).\\n<!-- While this change is pending, you will see a banner at the top of your billing overview page specifying the scheduled update. -->\\n","section":"What happens to my billing when I change my billing frequency?","version":"current","path":"/billing/billing-information/what-happens-to-my-billing-when-i-change-my-billing-frequency#annual-to-monthly","category":"default"},{"title":"Upgrading plans","content":"If you are upgrading plans, the new plan will apply immediately and you will receive a credit note and an invoice. The credit note will be for the balance remaining in the current period of the original plan.\\nYou will then receive an invoice charging for the new plan for the remainder of the billing cycle. The balance of the credit note will be applied fully to the invoice for your new plan.\\nExample:\\nA user on the Advanced plan billed monthly switches to the Professional plan halfway through the billing cycle.\\nCredit note:\\nA credit note for the remaining time (2 weeks) in the monthly cycle for the Advanced plan\\nInvoice:\\nAn invoice for the Professional plan for the remaining time (2 weeks) in the billing cycle. The balance of the credit note will be applied as payment to partially pay this invoice.\\n\\n","section":"What happens to my billing when I change my Fintesk subscription plan?","version":"current","path":"/billing/billing-information/what-happens-to-my-billing-when-i-change-my-fintesk-subscription-plan#upgrading-plans","category":"default"},{"title":"Downgrading plans","content":"If you are downgrading plans, the changes will take effect at the beginning of the next billing cycle, when the next renewal invoice is issued.\\nFurther subscription changes made before the end of the current billing cycle may override the scheduled one.\\nExample:\\nA user on the Professional plan billed monthly switches to the Advanced plan halfway through the billing cycle\\nThe user will be on the Professional plan for the rest of the billing cycle and be charged for the new plan at the beginning of the new cycle\\n<!-- While the change is pending, you’ll see a banner at the top of your billing overview page specifying the scheduled update.\\n-->\\n","section":"What happens to my billing when I change my Fintesk subscription plan?","version":"current","path":"/billing/billing-information/what-happens-to-my-billing-when-i-change-my-fintesk-subscription-plan#downgrading-plans","category":"default"},{"title":"What happens to my billing when I deactivate a user in Fintesk?","content":"<p>&lt;!-- ../../billing/billing-information/what-happens-to-my-billing-when-i-deactivate-a-user-in-fintesk.md --&gt;</p>\\n<p>&lt;!-- # What happens to my billing when I deactivate a user in Fintesk? --&gt;</p>\\n<p>:::tip\\n<strong>Note:</strong> This action is only available to users with <strong>Account Settings</strong> access.\\n:::</p>\\n<p>When you <a href=\\"../../kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user\\">deactivate a user</a>, you will see a pop-up with the information assigned to that user, as well as the option to remove that unused seat.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202023-03-14%20at%2012.05.34.png\\" alt=\\"1\\"> --&gt;</p>\\n<ul>\\n<li><strong>If you remove this unused seat</strong>, the changes will take effect at the beginning of your next billing cycle. If you fill the seats with new users before this date, the seats won\'t be removed.</li>\\n<li><strong>If you do not remove this unused seat</strong>, the seat will still exist in your account and billing remains unchanged.</li>\\n</ul>\\n<p>If you want to remove seats from your account after deactivating users in the past, go to your billing section and click on &quot;<strong>Manage seats</strong>&quot;.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202023-03-14%20at%2011.48.56.png\\" alt=\\"1\\"> --&gt;</p>\\n<p>Then, choose the desired number of seats. The changes for seat downgrade will take effect at the beginning of your next billing cycle. If you fill the seats with new users before this date, the seats won\'t be removed from your billing.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202023-03-14%20at%2011.50.36.png\\" alt=\\"1\\"> --&gt;</p>\\n","section":"What happens to my billing when I deactivate a user in Fintesk?","version":"current","path":"/billing/billing-information/what-happens-to-my-billing-when-i-deactivate-a-user-in-fintesk","category":"default"},{"title":"How can I switch to a different fintesk plan or change my billing frequency?","content":"<p>&lt;!-- billing/your-fintesk-subscription-plan/how-can-i-switch-to-a-different-fintesk-plan-or-change-my-billing-frequency.md --&gt;</p>\\n<p>&lt;!-- # How can I switch to a different Fintesk plan or change my billing frequency? --&gt;</p>\\n<p>:::tip\\n<strong>Note:</strong> This action is only available to users with <strong>account settings</strong> access.\\n:::</p>\\n<p>&lt;!-- If you would like to switch to a different Fintesk plan or change your billing frequency, you can easily do so at any time in your billing cycle by going to your <a href=\\"https://app.pipedrive.com/settings/subscription\\">Billing tab</a> and clicking on “<strong>Manage subscription</strong>”. --&gt;</p>\\n<p>If you would like to switch to a different Fintesk plan or change your billing frequency, you can easily do so at any time in your billing cycle by going to your <strong>Billing tab</strong> and clicking on “<strong>Manage subscription</strong>”.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202023-05-05%20at%2013.48.37.png\\" alt=\\"1\\"> --&gt;</p>\\n<p>From here, you will see the option to toggle between the plans or switch between <strong>Monthly</strong> or <strong>Annual</strong> billing cycles.</p>\\n<p>Click on “<strong>Continue</strong>“ (if you are on free trial) or “<strong>Proceed to checkout</strong>“ (if you are already paying) to confirm your change.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/billing%20select%20plans.png\\" alt=\\"1\\"> --&gt;</p>\\n<p>Your billing may be updated to reflect the changes you made.</p>\\n<p>You can read about what happens to your billing when you switch to a different Fintesk plan <a href=\\"../../billing/billing-information/what-happens-to-my-billing-when-i-change-my-fintesk-subscription-plan\\">in this article</a> and what happens to your billing when you change billing frequencies <a href=\\"../../billing/billing-information/what-happens-to-my-billing-when-i-change-my-billing-frequency\\">in this article</a>.</p>\\n","section":"How can I switch to a different fintesk plan or change my billing frequency?","version":"current","path":"/billing/your-fintesk-subscription-plan/how-can-i-switch-to-a-different-fintesk-plan-or-change-my-billing-frequency","category":"default"},{"title":"Features available on each plan","content":":::tip\\nNote: The number of open deals, custom fields and reports you can have depends on the plan you’re on. Learn more in this article.\\n:::\\n<table>\\n<tr>\\n<td>Feature</td>\\n<td>Free</td>\\n<td>Essential</td>\\n<td>Advanced</td>\\n<td>Professional</td>\\n</tr>\\n<tr>\\n<td>Pipeline view</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Multiple pipelines</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Customizable pipelines, fields and activities</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>All-in-one detail views</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Deal rotting</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Activities and activity logging</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<!-- <tr>\\n<td>Pipeline-specific custom fields</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n</tr> -->\\n<tr>\\n<td>\\n:::info [Cooming soon]\\nMerge duplicates\\n:::\\n</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Products</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Email support</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Chat support</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Phone support</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>Onboarding</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td></td>\\n</tr>\\n<!-- <tr>\\n<td>Email templates</td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Email open and click tracking</td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Important fields</td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Group emailing</td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Scheduled emails</td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Recurring products</td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Required fields</td>\\n<td></td>\\n<td></td>\\n<td> </td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Contacts timeline</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Revenue Forecast report</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Deal Forecasting</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>Teams</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>3 teams</td>\\nSigue incrementando los teams en planes superiores 3,15, ilimitado\\n</tr> -->\\n<!-- <tr>\\n<td>Custom permission sets</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>2 sets</td>\\nSigue incrementando los sets en planes superiores 2, 10, ilimitado\\n</tr> -->\\n<!-- <tr>\\n<td>Custom visibility groups</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>3 groups</td>\\nSigue incrementando los sets en planes superiores 3, 15, ilimitado\\n</tr> -->\\n<!-- <tr>\\n<td>Calendar View for activities</td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>Marketplace with 350+ apps and integrations</td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>Contact, Calendar and Google Drive sync</td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>Top-rated iOS and Android apps</td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>Sales Assistant</td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>\\nActivity invite\\n:::info\\nNote: Active calendar sync is required to send activity invites.\\n:::\\n</td>\\n<td>Branded</td>\\n<td>Branded</td>\\n<td>Unbranded</td>\\n<td>Unbranded</td>\\n</tr> -->\\n<!-- <tr>\\n<td>Insights reporting</td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>Insights dashboard</td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>SSO/SAML</td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>Smart Bcc</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>Security dashboard</td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>AI SmartApp recommendations</td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>AI-powered Marketplace search</td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>Email sync with all major providers</td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>Scheduler</td>\\n<td></td>\\n<td></td>\\n<td>✔️ One general availability link</td>\\n<td>✔️ Unlimited general availability links</td>\\n</tr> -->\\n<!-- <tr>\\n<td>Smart Contact Data</td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Automations</td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Smart Docs</td>\\n<td></td>\\n<td>Paid add-on</td>\\n<td>Paid add-on</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Custom fields in Insights</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>eSignatures</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Multiple Insights dashboards</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>AI email creation</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>AI email summarization</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>AI Sales Assistant</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Projects</td>\\n<td></td>\\n<td>Paid add-on</td>\\n<td>Paid add-on</td>\\n<td>Paid add-on</td>\\n</tr>\\n<tr>\\n<td>Security rules</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>Security alerts</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td></td>\\n</tr> -->\\n</table>\\n\\n","section":"What features do the Fintesk plans have","version":"current","path":"/billing/your-fintesk-subscription-plan/what-features-do-the-fintesk-plans-have#features-available-on-each-plan","category":"default"},{"title":"Add-on features","content":"Fintesk will be offering a number of add-on features that are available on any plan for an additional cost.\\n<!-- You can click on any of the feature names below to read more information about them. -->\\n<!-- LeadBooster add-on: -->\\n<!-- - Chatbot – allows your customers to better qualify themselves as potential customers of your company directly from your website. -->\\n<!-- - Live Chat – live chat functionality added to your Chatbot playbook flow that will allow you to engage directly with your website visitors and personalize your lead qualification process. -->\\n<!-- - Web Forms – Create your own personalized, embeddable forms for your website to collect your website visitors’ information and funnel them into Fintesk as deals or leads. -->\\n<!-- - Prospector – An outbound lead generation tool that will allow you to search for and gather high-quality leads based on set criteria. -->\\n<!-- - Scheduler – Unlimited “General availability” links -->\\n<!-- Separate add-ons: -->\\n<!-- - Web Visitors – Allows you to track visitor activity on your website to track and identify the companies who are most engaged with your website and most likely to turn into customers. -->\\n<!-- - Smart Docs – Comes with any Professional or higher subscription. However, it can also be used as an add-on for Essential or Advanced plans. -->\\n<!-- - Projects – Comes with any Power or higher subscription. Lets you manage post-sales activities for your deals, so you can continue to interact with and set objectives for closed, as well as open deals.\\nCampaigns – Lets you create beautiful email marketing templates, engage your customers and manage all of your data directly in your Fintesk account. -->\\n","section":"What features do the Fintesk plans have","version":"current","path":"/billing/your-fintesk-subscription-plan/what-features-do-the-fintesk-plans-have#add-on-features","category":"default"},{"title":"Changes to the API","content":"Fintesk’s API together with our Developer Platform is constantly evolving to cover additional product functionality. By introducing changes to the API, we aim to enhance your API experience by adding new features and functionality.\\nDo take note that from time to time, we may introduce breaking changes in order to improve the API. Read on to find out how we communicate changes and what types of changes we introduce.\\n:::info\\nAll changes to the Fintesk API are announced via our Changelog. Make sure to subscribe to stay up to date!\\n:::\\n:::warning\\nOccasionally, we announce new API endpoints in the Beta version with the goal of gathering customer feedback. Please note that Beta endpoints may be subject to breaking changes.\\n:::\\n\\n","section":"Changes to the API","version":"current","path":"/developers/core-api-concepts/changes-to-the-api","category":"default"},{"title":"Types of changes","content":"\\n\\nChanges to the Fintesk API can be divided into breaking and non-breaking changes.\\nA breaking change is a backward incompatible change that may require updating your app.\\nA non-breaking change is typically a new addition to the API that can be implemented at your own pace and choosing.\\n:::warning\\nWe aim to announce breaking changes via our Changelog at least 60 days in advance to give you adequate time to adopt the changes.\\n:::\\nBreaking changes\\nNon-breaking changes\\n\\n\\n\\n\\nRemoving a resource\\nAdding a new endpoint\\n\\n\\nRemoving an endpoint\\nAdding a new optional parameter\\n\\n\\nRemoving a parameter\\nAdding a new response field\\n\\n\\nRemoving a response field\\nChanging the order of response fields\\n\\n\\nModifying an endpoint’s URI\\nChanging an error message\\n\\n\\nModifying the name of a parameter or field\\nFixing an HTTP response code\\n\\n\\nModifying required parameters\\n\\n\\n\\nAdding a required parameter\\n\\n\\n\\nChanging the data type of an existing field or parameter\\n\\n\\n\\nReducing API limits\\n\\n\\n\\nRestricting OAuth scopes\\n\\n\\n\\nIntroducing a new validation\\n","section":"Changes to the API","version":"current","path":"/developers/core-api-concepts/changes-to-the-api#types-of-changes","category":"default"},{"title":"About the Fintesk API","content":":::tip\\nAn application programming interface (API) is a set of functionalities that a service owner provides so team\'s member can use its features and/or build software applications. An API details how a user makes requests and the responses they receive in return.\\n:::\\n<!-- Fintesk is a sales CRM with an intuitive RESTful API and webhooks, to help you build [an app]. -->\\nFintesk is a sales CRM with an intuitive RESTful API, to help you build [an app].\\n\\n","section":"About the Fintesk API","version":"current","path":"/developers/core-api-concepts/core-api-concepts-about-fintesk-api","category":"default"},{"title":"Fintesk RESTful API","content":"\\n\\nOur Fintesk RESTful API Reference can be accessed via our API, where you will find a list of endpoints and their descriptions.\\n<!-- Calls to our API are validated against an API token or an access_token when using OAuth 2.0.  -->\\nOur API supports UTF-8 for character encoding.\\n<!-- Learn how to find and use the api_token with the practical task here. -->\\n\\nFintesk Entity Relationship Diagram (ERD)\\n<!-- ### Webhooks\\n\\nWebhooks enable you to obtain real-time, programmatic notifications from Fintesk regarding changes to your data as they happen. Instead of pulling information via our API, webhooks will push information to your endpoint.\\nYou can create webhooks via the web app and our API. You can create a webhook programmatically by making a POST request to the webhook’s endpoint. Fintesk will then send a notification when an event is triggered (e.g., a new lead is added) as an HTTP post with a JSON body to the endpoint(s) you have specified. Find out more about webhooks here. -->\\n\\n","section":"About the Fintesk API","version":"current","path":"/developers/core-api-concepts/core-api-concepts-about-fintesk-api#fintesk-restful-api","category":"default"},{"title":"How Fintesk API works","content":"\\n\\n:::tip\\nDo take note that entity/entities may be called “item/items” or “type of item/items” for the end user in the Fintesk web.\\n<!-- and mobile app. -->\\n:::\\n<!-- At the base of your Fintesk account is a customer relationship management (CRM) database of your sales pipeline, processes and relationships. As organizing sales data is essential for sales activities, Fintesk helps to organize and link your data together for better visibility through the core and adjacent entities. -->\\nAt the base of your Fintesk account is a customer relationship management (CRM) database of your sales pipeline, processes and relationships. As organizing sales data is essential for sales activities, Fintesk helps to organize and link your data together for better visibility through the core and adjacent entities.\\n","section":"About the Fintesk API","version":"current","path":"/developers/core-api-concepts/core-api-concepts-about-fintesk-api#how-fintesk-api-works","category":"default"},{"title":"Core entities","content":"\\nWithin the Fintesk API, we have core entities that consist of multiple endpoints. These core entities represent a larger area inside Fintesk and can be found in navbar menu in the Fintesk web app. Tied to them are adjacent entities that contain supplementary information relevant to the core entities.\\n\\nFintesk core entities ERD\\nThe ERD above shows how core entities are connected within Fintesk.\\n<!-- - As leads can be converted to deals, they are sometimes used in place of each other. For example, in the case of activities, an activity can be associated with either a lead or a deal. This goes the same for products. -->\\nFor example, in the case of activities, an activity can be associated with a deal. This goes the same for products.\\nPersons and organizations are considered contacts and are often grouped together.\\n<!-- Mailbox, found in the Mail tab of the Fintesk web app, is the email control hub inside Fintesk that stores all the emails a user decides to keep a record of. Mail is tracked and associated with persons and deals through Fintesk’s email sync and Smart Bcc features. -->\\n[Entity] Fields endpoints allow you to obtain the near-complete schema of the respective core entities. You can add, update and delete main and custom fields through these adjacent entities.\\n<!-- Read on to discover how leads, deals, persons and organizations (contacts), activities, products and users are further connected to other core and adjacent entities. -->\\nRead on to discover how deals, persons and organizations (contacts), activities, products and users are further connected to other core and adjacent entities.\\n","section":"About the Fintesk API","version":"current","path":"/developers/core-api-concepts/core-api-concepts-about-fintesk-api#core-entities","category":"default"},{"title":"Deals","content":"\\n\\nDeals ERD\\n<!-- https://developers.pipedrive.com/developers/create-a-deal-pipedrive-api -->\\n<!-- TODO: agregar los API guias para cada entdidad -->\\n[Deals] are ongoing transactions pursued with a person or an organization. It’s tracked and processed through the Stages of a pipeline until it’s won or lost. Deals can be converted from leads via the Fintesk web app.\\n<!-- In Fintesk, deals contain all actions taken towards closing a sale, for example, activities, and notes and files, and have their own custom fields (DealFields). Products and subscriptions can also be attached to deals. -->\\nIn Fintesk, deals contain all actions taken towards closing a sale, for example, activities, and notes, and have their own custom fields (DealFields). Products can also be attached to deals.\\nA deal can be linked with either a person or organization (contacts) but it must always have one contact linked with them. As a deal is associated with a contact, it will pull all information from the linked contact and, likewise, associate all actions performed on the deal with the linked contact.\\n","section":"About the Fintesk API","version":"current","path":"/developers/core-api-concepts/core-api-concepts-about-fintesk-api#deals","category":"default"},{"title":"Persons & organizations (contacts)","content":"\\n\\nPersons & organizations (contacts) ERD\\n<!-- TODO: agregar los API guias para cada entdidad -->\\nPersons are the specific customers of the sales process, while [organizations] are the companies that the persons work at. Persons and organizations are considered contacts and they rest in one centralized hub in the Fintesk web app. The ERD above depicts how different core and adjacent entities can either relate to contacts as a whole or persons/organizations specifically.\\nBoth persons and organizations can have activities, notes and files attached to them and their respective main fields and custom fields (PersonFields and OrganizationFields).\\n<!-- Emails (Mailbox) and products can only be linked to persons while  -->\\nOrganizationRelationships can only be linked to organizations.\\nKey aspects of Persons and organizations (contacts):\\nA person can only be linked to one organization\\n<!-- - A lead or a deal must always have a person or an organization linked to it -->\\nA deal must always have a person or an organization linked to it\\nBoth persons and organizations can have multiple deals open for them at the same time\\n","section":"About the Fintesk API","version":"current","path":"/developers/core-api-concepts/core-api-concepts-about-fintesk-api#persons--organizations-contacts","category":"default"},{"title":"Activities","content":"\\n\\nActivities ERD\\n<!-- TODO: agregar los API guias para cada entdidad -->\\n[Activities] are any actions a user does towards the closing of a sale. There are different types of activities (ActivityTypes) that can be performed, e.g. a phone call, a meeting or a task. You can have custom activity types and custom fields (ActivityFields) for activities. Users can schedule activities in relation to a person, an organization or a deal.\\nKey aspects of activities:\\nAssociating an activity with a deal will also associate the activity with the person and/or organization linked to the deal\\n<!-- - Currently, Files can only be added to activities via the API -->\\n","section":"About the Fintesk API","version":"current","path":"/developers/core-api-concepts/core-api-concepts-about-fintesk-api#activities","category":"default"},{"title":"Products","content":"\\n\\nProducts ERD\\n<!-- TODO: agregar los API guias para cada entdidad -->\\n[Products] are goods and/or services that your company deals with. Products can have their own custom fields (ProductFields) and be attached to deals. Persons (contacts) can be added as participants and users can be added as followers for a product.\\n<!-- Files can also be added to products. -->\\n","section":"About the Fintesk API","version":"current","path":"/developers/core-api-concepts/core-api-concepts-about-fintesk-api#products","category":"default"},{"title":"Users","content":"\\n\\nUsers ERD\\nA Company within fintesk comprises Users who may be grouped into teams. The ERD above depicts how different core and adjacent entities can relate to a company as a whole or users/teams specifically.\\n<!-- Goals may be related to a company, a team and/or a user.  -->\\nUsers and teams can have their own specific PermissionSets and Roles, which are a part of the visibility groups’ feature. Users can also have their own UserSettings.\\n<!-- and UserConnections. -->\\n<!-- 2 main types of webhooks can be created: webhooks related to a company and webhooks for apps. When querying webhooks, a user can obtain the webhooks they’ve created, while apps can only see and delete webhooks that have the type set as type= \'application\'. -->\\n","section":"About the Fintesk API","version":"current","path":"/developers/core-api-concepts/core-api-concepts-about-fintesk-api#users","category":"default"},{"title":"Custom fields","content":"Custom fields allow you to add additional data to your Fintesk account that isn\'t included by default. Each deal, organization, person, and product item can contain custom fields. We have 16 different field types available, each with its own uses.\\n\\n","section":"Custom fields","version":"current","path":"/developers/core-api-concepts/core-api-concepts-custom-fields","category":"default"},{"title":"Creating a custom field","content":"\\n\\n<!-- TODO: crear esta pagina -->\\n<!-- See our creating a new custom field tutorial to add a custom field programmatically. -->\\nMethod\\nURL\\nUseful for\\n\\n\\n\\n\\nPOST\\n/dealFields\\nAdding a new deal field.\\n\\n\\nPOST\\n/organizationFields\\nAdding a new organization field\\n\\n\\nPOST\\n/personFields\\nAdding a new person field\\n\\n\\nPOST\\n/productFields\\nAdding a new product field\\n:::tip\\nNote that custom fields cannot be duplicated to multiple different Fintesk accounts. You can add the custom fields with the same name and field type to different accounts but they\'ll have different values for key parameters referenced in our API.\\n:::\\n\\n","section":"Custom fields","version":"current","path":"/developers/core-api-concepts/core-api-concepts-custom-fields#creating-a-custom-field","category":"default"},{"title":"Naming a custom field","content":"\\n\\nAll custom fields are referenced as randomly generated 24-character hashes in the dataset, for example, 671a4610084c309cd93e5939 - it may look like our office cat walked across the laptop, but this actually is a key for a custom field in our API dataset.\\n:::warning\\nThese 24-character custom fields (for example, 671a4610084c309cd93e5939) are not shown in our API Reference as they differ for each Fintesk account, but they can be seen in the API requests and responses as well as used in the requests when adding new items or updating existing ones.\\n:::\\nYou can’t rename the reference of the custom field (the field API key), but you can rename the name of a custom field that’s visible to the User.\\nInside Fintesk, you can find the API key of a field by going to Settings > Data fields and choosing the entity (deal/person/organization/product). When you hover over the row of a custom field, a three-dot menu appears on the right-hand side. From there, choose Copy API key.\\n<!-- TODO: hacer el documento cuando tengak API keys -->\\n<!--\\nFinding the API key of a custom field -->\\n","section":"Custom fields","version":"current","path":"/developers/core-api-concepts/core-api-concepts-custom-fields#naming-a-custom-field","category":"default"},{"title":"{#}","content":"<!--\\n","section":"Custom fields","version":"current","path":"/developers/core-api-concepts/core-api-concepts-custom-fields#undefined","category":"default"},{"title":"Referencing a custom field","content":"\\n\\nHere’s how you use an example key for a custom field in an example POST request to /deals (make sure you replace the example key with yours before making the request):\\n<?php $api_token = \'Your API token goes here\';\\n\\n$deal = array (\\n    \'title\' => \'New deal with a custom field\',\\n    \'value\' => \'500\',\\n    \'currency\' => \'USD\',\\n    \'671a4610084c309cd93e5939\' => \'A new field value for an existing example custom field key\'\\n);\\n\\n$url = \'https://companydomain.pipedrive.com/api/v1/deals?api_token=\' . $api_token;\\n$ch = curl_init();\\ncurl_setopt($ch, CURLOPT_URL, $url);\\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\\ncurl_setopt($ch, CURLOPT_POST, true);\\ncurl_setopt($ch, CURLOPT_POSTFIELDS, $deal);\\n$output = curl_exec($ch);\\ncurl_close($ch);\\n\\n$result = json_decode($output, true);\\n// Check if an ID came back, if did print it out\\nif (!empty($result[\'data\'][\'id\']))\\n{ echo \'Deal was added successfully!\' . PHP_EOL; }\\nEach custom field type corresponds to a specific data format. To determine in which format you need to submit data into a custom field, make a GET request for the same kind of object and check the format of the value of that field. You can find the list of field_type in the table below.\\n-->\\n\\n","section":"Custom fields","version":"current","path":"/developers/core-api-concepts/core-api-concepts-custom-fields#referencing-a-custom-field","category":"default"},{"title":"Updating a custom field","content":"\\n\\n<!-- TODO: hacer el documento -->\\n<!-- See our updating custom fields’ values tutorial to update a custom field programmatically. -->\\nMethod\\nURL\\nUseful for\\n\\n\\n\\n\\nPUT\\n/dealFields/{id}\\nUpdating a Deal field.\\n\\n\\nPUT\\n/organizationFields/{id}\\nUpdating an organization field\\n\\n\\nPUT\\n/personFields/{id}\\nUpdating a person field\\n\\n\\nPUT\\n/productFields/{id}\\nUpdating a product field\\n\\n","section":"Custom fields","version":"current","path":"/developers/core-api-concepts/core-api-concepts-custom-fields#updating-a-custom-field","category":"default"},{"title":"Deleting a custom field","content":"\\n\\n:::warning\\nWe don\'t recommend deleting a custom field, because it might permanently remove all data. In case you do delete by mistake, there\'s a chance that you can get it back by contacting our awesome support team.\\n:::\\n<!-- TODO: hacer el documento -->\\n<!-- See our deleting a custom field tutorial to delete a custom field programmatically. -->\\nMethod\\nURL\\nUseful for\\n\\n\\n\\n\\nDELETE\\n/dealFields/{id}\\nMarking a deal field as deleted.\\n\\n\\nDELETE\\n/organizationFields/{id}\\nMarking an organization field as deleted\\n\\n\\nDELETE\\n/personFields/{id}\\nMarking a person field as deleted\\n\\n\\nDELETE\\n/productFields/{id}\\nMarking a product field as deleted\\nAfter a custom field is deleted, it will no longer appear in API responses. All POST requests mentioning a custom field will ignore it.\\n\\n","section":"Custom fields","version":"current","path":"/developers/core-api-concepts/core-api-concepts-custom-fields#deleting-a-custom-field","category":"default"},{"title":"Types of custom fields","content":"\\n\\nSee below the 16 different types of custom fields available:\\nType\\nfield_type\\nDescription\\nUseful for\\nAdditional info\\n\\n\\n\\n\\nText\\nVarcharField\\nThe text field is used to store texts up to 255 characters\\nBilling addresses, (short) comments, email addresses\\n\\n\\n\\nLarge text\\nTextField\\nThe large text field is used to store texts longer than usual\\nComments, descriptions\\n\\n\\n\\nNumerical\\nNumberField\\nThe numeric field is used to store data such as the amount of commission or other custom numerical data\\nCommission, priority level\\nThe value should be numeric with a maximum precision (decimal places) of 16. If a number exceeds the maximum precision, it will stay without the full precision.\\n\\n\\nMonetary\\nMonetaryField\\nThe monetary field is used to store data such as the amount of commission\\nCommission, amounts\\nThe currency of the field will match the user’s default currency setting unless specified otherwise in the request. The format of the field is determined by the user’s locale.\\n\\n\\nMultiple options\\nMultipleChoiceField\\nThe multiple options field lets you predefine a list of values to choose from. Multiple option fields can have a max of 10,000 options per field.\\nIndustry type, competitors, region\\n\\n\\n\\nSingle option\\nChoiceField\\nThe single option field lets you predefine a list of values out of which one can be selected.Single option fields can have a max of 10,000 options per field.\\nLead type, category, industry\\n\\n\\n\\nUser\\nUserField\\nThe user field can contain one user amongst users of your Fintesk account*\\nTech contacts, previous deal owners\\n\\n\\n\\nOrganization\\nOrganizationField\\nThe organization field can contain one organization out of all the organizations stored on your Fintesk account*\\nRelated parties, partner organizations\\n\\n\\n\\nPerson\\nPersonField\\nThe person field can contain one person out of all the contacts stored on your Fintesk account*\\nRelated parties, tech contacts\\n\\n\\n\\nPhone\\nPhonesField\\nA phone number field can contain a phone number (naturally) or a Skype Name with a click-to-call functionality\\nSkype names, phone numbers\\nNo auto-formatting\\n\\n\\nTime\\nTimeField\\nThe time field is used to store times, picked from a handy inline time picker\\nDelivery times, lunchtime\\n\\n\\n\\nTime range\\nTimeRangeField\\nThe time range field is used to store time ranges picked from a handy inline time picker\\nOffice hours, the best time to contact\\n\\n\\n\\nDate\\nDateField\\nDate field is used to store dates picked from a handy inline calendar\\nDelivery dates, deadlines\\nThe format of the field is determined by the user’s locale\\n\\n\\nDate range\\nDateRangeField\\nThe date range field is used to store date ranges picked from a handy inline calendar\\nEvent dates, completion estimates\\n:::info\\nComing soon\\nAddress\\nAddressField\\nAddress field is used to store addresses\\nEvent places, office locations (when separate from business address)\\nThe address field can hold all parts of address components – including City, tate, Zip Code, and Country – so there’s no need to create separate address fields for each address component. You can use Google Maps autocomplete textfield to enter addresses and visualize them on a map. You’ll also be able to filter items based on specific address criteria.\\n\\n\\nAutocomplete\\nVarcharField\\nThe text field is used to store texts up to 255 characters and can autocomplete from the text previously inserted into this field\\n\\nCustom options (e.g., tagging), email addresses\\n\\n\\n:::\\n* Doesn’t link the item with the user, person, or organization for statistics or any other form of ownership or relation, but can be used for filtering.\\n\\n","section":"Custom fields","version":"current","path":"/developers/core-api-concepts/core-api-concepts-custom-fields#types-of-custom-fields","category":"default"},{"title":"How to find out if a field is a custom field","content":"\\n\\nThe system_flag parameter in the response body of an entity’s fields can be used to identify if the field is a custom field:\\ntrue – a custom field\\nfalse – Fintesk default field\\n{\\n  \\"_id\\": \\"671a460f084c309cd93e58c4\\",\\n\\n  \\"active_flag\\": true,\\n  \\"add_deal_modal_visible_flag\\": false,\\n  \\"add_organization_modal_visible_flag\\": false,\\n  \\"add_person_modal_visible_flag\\": false,\\n  \\"add_product_modal_visible_flag\\": false,\\n  \\"add_time\\": \\"2024-10-24 13:05:19\\",\\n  \\"add_visible_flag\\": false,\\n  \\"alias\\": \\"next_activity_subject\\",\\n  \\"allow_bulk_edit_flag\\": false,\\n  \\"allow_filtering_flag\\": false,\\n  \\"allow_select_column_flag\\": false,\\n  \\"complex_flag\\": false,\\n  \\"created_by_user_id\\": \\"671a460f084c309cd93e5848\\",\\n  \\"delete_flag\\": false,\\n  \\"details_visible_flag\\": false,\\n  \\"edit_flag\\": false,\\n  \\"entity_id\\": \\"671a460f084c309cd93e584b\\",\\n  \\"entity_key\\": \\"Deals\\",\\n  \\"entity_referenced\\": null,\\n  \\"field_type_class\\": \\"TextField\\",\\n  \\"field_type_id\\": \\"671a460f084c309cd93e5855\\",\\n  \\"flow_flag\\": false,\\n  \\"help_text\\": \\"This field can have 255 characters at maximun\\",\\n  \\"importable_flag\\": false,\\n  \\"important_flag\\": false,\\n  \\"internal_id\\": 91,\\n  \\"key\\": \\"next_activity_subject\\",\\n  \\"last_updated_by_user_id\\": \\"671a460f084c309cd93e5848\\",\\n  \\"link\\": null,\\n  \\"mandatory_flag\\": false,\\n  \\"name\\": \\"next_activity_subject\\",\\n  \\"options\\": [],\\n  \\"order_nbr\\": 4,\\n  \\"owner_id\\": \\"671a460f084c309cd93e5848\\",\\n  \\"search_field\\": null,\\n  \\"searchable_flag\\": false,\\n  \\"sort_field\\": \\"next_activity_subject\\",\\n  \\"sortable_flag\\": true,\\n  \\"subfield_flag\\": false,\\n  \\"subfields\\": [],\\n  \\"system_flag\\": true,\\n  \\"update_time\\": \\"2024-10-24 13:05:18\\",\\n  \\"visible_in_exports_flag\\": false\\n}\\n","section":"Custom fields","version":"current","path":"/developers/core-api-concepts/core-api-concepts-custom-fields#how-to-find-out-if-a-field-is-a-custom-field","category":"default"},{"title":"Date format","content":"All dates and times received by the API will be in ISO 8601 format 2019-01-22 08:55:59 (would be the same as 2019-01-22T08:55:59).\\n:::warning\\nAll times received by the API will be in UTC timezone.\\n:::\\nThe times that are sent to the API should also be converted to the UTC timezone before being sent.\\n","section":"Date format","version":"current","path":"/developers/core-api-concepts/core-api-concepts-date-format","category":"default"},{"title":"HTTP status codes","content":"Here\'s a list of the status codes used in Fintesk:\\nStatus Code\\nName\\nDescription\\n\\n\\n\\n\\n200\\nOK\\nRequest fulfilled\\n\\n\\n201\\nCreated\\nNew resource created\\n\\n\\n400\\nBad Request\\nRequest not understood\\n\\n\\n401\\nUnauthorized\\nInvalid API token\\n\\n\\n402\\nPayment Required\\nCompany account is not open (possible reason: trial expired, payment details not entered)\\n\\n\\n403\\nForbidden\\nRequest not allowed. User account has reached a limit for an entity.\\n\\n\\n404\\nNot Found\\nResource unavailable\\n\\n\\n405\\nMethod not allowed\\nIncorrect request method\\n\\n\\n410\\nGone\\nOld resource permanently unavailable\\n\\n\\n415\\nUnsupported Media Type\\nFeature is not enabled\\n\\n\\n422\\nUnprocessable Entity\\nWebhooks limit reached\\n\\n\\n429\\nToo Many Requests\\n[Rate limit] has been exceeded\\n\\n\\n500\\nInternal Server Error\\nGeneric server error\\n\\n\\n501\\nNot Implemented\\nNon-existent functionality\\n\\n\\n503\\nService Unavailable\\nScheduled maintenance\\n","section":"HTTP status codes","version":"current","path":"/developers/core-api-concepts/core-api-concepts-http-status-codes","category":"default"},{"title":"Pagination","content":"Fintesk offers pagination for most of our API’s list and item collection endpoints.\\n","section":"Pagination","version":"current","path":"/developers/core-api-concepts/core-api-concepts-pagination","category":"default"},{"title":"Offset pagination","content":"\\n\\nWith the rest of our GET endpoints, we offer offset-based pagination. The parameters that control this type of pagination are start_page and limit_by, indicating the desired offset and the number of items to be returned per page.\\n<!-- -->\\n<!-- -->\\n\\n\\n\\n\\nstart_page (integer)\\nPagination start. If omitted, the default value is 0.\\n\\n\\nlimit_by (integer)\\nThe number of items shown per page. If not provided, 50 items will be returned.\\nExample request for the GET /v1/activities endpoint:\\nGET https://api.fintesk.com/v1/activities?start=0&limit=100\\nWithin the response’s additional_data object, a pagination object will be returned. The additional_data.pagination object will contain the given start_page and limit_by values, as well as the more_items_in_collection flag, indicating whether more items can be fetched after the current batch.\\nIf more items can be fetched, the next_start field, which can be used for specifying the next offset pointer, will also be returned.\\nThe maximum limit_by value is 500.\\nExample response:\\n{\\n  \\"success\\": true,\\n  \\"data\\": [{\\n    … // returned activities’ data\\n  }],\\n  \\"additional_data\\": {\\n    \\"pagination\\": {\\n      \\"start\\": 0,\\n      \\"limit\\": 10,\\n      \\"more_items_in_collection\\": true,\\n      \\"next_start\\": 10\\n    }\\n  }\\n}\\n","section":"Pagination","version":"current","path":"/developers/core-api-concepts/core-api-concepts-pagination#offset-pagination","category":"default"},{"title":"Requests","content":":::tip\\nAll requests to the Fintesk API must be made over SSL (https, not http).\\n:::\\nWe recommend using JSON body format when performing API requests. To do a proper JSON-formatted request, ensure you provide Content-Type: application/json in HTTP request headers. Our API supports UTF-8 for character encoding.\\nFor the POST method, regular form-encoded body format is also supported but you may experience quirks related to a lack of data types. Our API uses the HTTP verbs for each action:\\nMethod\\nDescription\\n\\n\\n\\n\\nGET\\nUsed for retrieving resources\\n\\n\\nPOST\\nUsed for creating resources\\n\\n\\nPUT\\nUsed for replacing resources or collections\\n\\n\\nPATCH\\nUsed for updating some parts of a resource\\n\\n\\nDELETE\\nUsed for deleting resources\\n\\n","section":"Requests","version":"current","path":"/developers/core-api-concepts/core-api-concepts-requests","category":"default"},{"title":"URL naming","content":"\\n\\nOur API uses a straightforward URL naming convention.\\nEach request must be made to the API endpoint https://api.fintesk.com/lc_erp/v1, followed by the type of object in a plural form, for example, https://api.fintesk.com/lc_erp/v1/deals\\nWhen one item is being asked, and such a method exists, the ID of the item must be appended to the URL, for example https://api.fintesk.com/lc_erp/v1/deals/abc\\nWhen asking for sub-objects of an object, append that to the ID of the master object, for example, https://api.fintesk.com/lc_erp/v1/deals/2/activities\\n<!-- - The API token must be provided as part of the query string for all requests using the api_token variable, for example https://api.fintesk.com/lc_erp/v1/deals/2?api_token=659c9fddb16335e48cc67114694b52074e812e03 -->\\n<!-- We advise everyone to use {COMPANYDOMAIN}.pipedrive.com for faster requests as it helps us to better determine which data center your request should go to. -->\\n\\n","section":"Requests","version":"current","path":"/developers/core-api-concepts/core-api-concepts-requests#url-naming","category":"default"},{"title":"Field selector","content":"\\n\\nWhen asking for a collection/list of objects, you can pass in a field selector to indicate which fields you would like to fetch per each object. Most endpoints in our API reference support this, but not all.\\n<!-- The field selector is supported in requests done with OAuth and requests done with the api_token.  -->\\nFor example, you may only want to fetch a deal\'s ID, title, value, and currency when asking the deals list – this can be done by using the following syntax:\\nRequest with OAuth 2.0:\\nGET https://api.fintesk.com/lc_erp/v1/deals:(id,title,value,currency)\\n<!--\\nRequest with api_token:\\nGET https://api.fintesk.com/lc_erp/v1/deals:(id,title,value,currency)?api_token=659c9fddb16335e48cc67114694b52074e812e03\\n``` -->\\n<!-- https://developers.pipedrive.com/tutorials/update-custom-field-pipedrive-api?step=1 -->\\n<!-- You can also see the field selector being used in our [updating custom fields\' values](/docs/updating-custom-field-value#pass-field-selectors) tutorial. -->\\n","section":"Requests","version":"current","path":"/developers/core-api-concepts/core-api-concepts-requests#field-selector","category":"default"},{"title":"Getting started","content":":::tip\\nCheck out our Changelog for the latest changes regarding our Developer Platform.\\n:::\\nFintesk is a sales CRM with an intuitive RESTful API. You can use our API to create public or private apps\\n<!-- using OAuth 2.0 and integrations via API token. -->\\n\\n","section":"Getting started","version":"current","path":"/developers/overview/getting-started","category":"default"},{"title":"Create an account","content":"\\n\\nTesting in a risk-free account. sign up for one now.\\n\\n<!-- ## Learn about the Fintesk API\\n-->\\n\\n<!--\\nLet\'s walk through the basics of the Fintesk API. Try it out here or use Fintesk\'s API in Postman or Insomnia and continue learning with our API tutorials and app tutorials. -->\\n:::tip\\nDidn\'t find what you were looking for? Let us know!\\nTell us about what you\'re looking for or inform us about the missing article\\n<!-- via the little smiling feedback button in the bottom right-hand corner. -->\\n:::\\n","section":"Getting started","version":"current","path":"/developers/overview/getting-started#create-an-account","category":"default"},{"title":"Fintesk API - V2","content":"<p>import ApiDocMdx from \'@theme/ApiDocMdx\';</p>\\n<p>&lt;ApiDocMdx id=&quot;fintesk-v1&quot; /&gt;</p>\\n","section":"Fintesk API - V2","version":"current","path":"/fintesk/api-v1","category":"default"},{"title":"Changelog","content":"<p>&lt;!-- fintesk/changelog.md --&gt;</p>\\n","section":"Changelog","version":"current","path":"/fintesk/changelog","category":"default"},{"title":"Where to find it","content":"You can find your activities by clicking the icon on the top-left navigation menu:\\n\\n\\n","section":"Activities","version":"current","path":"/kb/activities#where-to-find-it","category":"default"},{"title":"Adding activities","content":":::tip\\nNote: You can set up an activity as a call, meeting, task, deadline, email, or lunch type by default, but you can also create custom activity types for activities specific to your company’s needs.\\n:::\\nThere are several places in Fintesk where activities can be created.\\nIn the pipeline view of the deals tab:\\nClick on a deal’s activity icon in the pipeline view of the deals tab.\\nIn the detail view of any deal, person or organization:\\nClick on the activity tab to link an activity directly to that item.\\n:::tip\\nNote: If you want to learn how to add activities in bulk, check out this article.\\n:::\\n\\n","section":"Activities","version":"current","path":"/kb/activities#adding-activities","category":"default"},{"title":"Scheduling an activity","content":"The Schedule an activity prompt presents your entire day’s agenda on the right, next to the necessary fields to schedule your next activity.\\nThis helps you to schedule your activities efficiently, prevent double booking and reschedule your existing activities as needed.\\n\\nIn the Schedule an activity prompt, you can fill in the following activity details:\\nSubject – Name of your activity\\nType – Default or custom activity type\\nTime, date and duration – When and how long the activity is\\n(Coming Soon) Note – A description of your activity. This is private and only visible within your Fintesk account.\\n<!-- - Busy/Free – Activities are set to \\"Free\\" by default. If an activity is set to “Busy,” your customers can’t book that time slot through any Scheduler links. -->\\nA few other notable activity fields:\\nLast activity date – shows the date of the last activity that was marked as done\\nNext activity date – shows the date of the next activity you scheduled that isn’t marked as done yet\\nUpdate time – The date of the last update made on an item (a new activity created, a field updated, moving stages etc.)\\n<!-- Description – Additional details about the activity that will be synced to your external calendar. Unlike the note added to your activity, the description is publicly visible to any guests added to the activity. -->\\n\\n","section":"Activities","version":"current","path":"/kb/activities#scheduling-an-activity","category":"default"},{"title":"Linking deals and contacts","content":"In the Schedule an activity window, you can enter the owner, as well as the deal, organization and person contact you want to link to the activity.\\nWhen an activity is linked to an item, it appears on the item’s detail page.\\n\\nLinked deal – An activity linked to only a deal is automatically linked to the contact person and organization linked to that deal.\\nLinked person/s (participants) – An activity linked to a person contact is automatically linked to that person’s organization.\\nLinked organization – An activity linked to an organization isn’t automatically linked to its deals or persons contacts, since there can be multiple deals and persons contacts linked to each organization.\\n\\n","section":"Activities","version":"current","path":"/kb/activities#linking-deals-and-contacts","category":"default"},{"title":"Completing activities","content":"Here\'s a few things to know about completing activities:\\n<!-- or calendar view -->\\nYou can mark them as done in the activities list, as well as the detail pages of your linked items\\n<!-- - and the contacts timeline view. -->\\nAn activity’s marked as done time field is updated when the activity is marked as done.\\nThe due date field will always show the time and date the activity was originally scheduled for.\\nWhile you can manually edit the due date field of an activity – even retroactively – the marked as done field always reflects the time that activity was marked as done.\\n\\nYou can read more about activity marked as done logic in this article.\\n<!-- :::tip\\nNote: If you’re just getting started with Fintesk, check out our “Never forget a follow-up” Fintesk Academy course.\\n::: -->\\n<!-- --- -->\\n<!-- TODO: agregar la posibilidad de borrar (SOFT en frontend) -->\\n<!--\\n","section":"Activities","version":"current","path":"/kb/activities#completing-activities","category":"default"},{"title":"Deleting activities","content":"Activities can be deleted from both your calendar and list view.\\nTo delete an activity from your list view, select one or multiple activities from the left side margin, then click the trash can icon:\\n\\nTo delete an activity from your calendar view, select the activity and click the trash can icon:\\n-->\\n","section":"Activities","version":"current","path":"/kb/activities#deleting-activities","category":"default"},{"title":"Calendar view","content":"\\nThe calendar view always shows the activities by the scheduled due date, regardless of when they were marked as done.\\n\\nIn the above example, all three activities have been marked as done (shown by the green checkmarks on the right side,) but their position hasn’t changed. -->\\n\\n","section":"Activity \\"marked as done\\" logic","version":"current","path":"/kb/activities/activity-marked-as-done-logic#calendar-view","category":"default"},{"title":"List view","content":"You can view and sort in the activities list view based on marked as done time.\\nUse the gear icon in the top right corner to edit your list view columns, then select marked as \\"done time” and “save.”\\n\\n<!-- TODO: meter el estilo gris y tachado para las actividades DONE -->\\n<!-- TODO: revisar done_time y done_by_user, parece que no estan funcionando bien -->\\n:::info\\nComing Soon: You can see the done time for any relevant activity, and sort by which were completed more or less recently by clicking the bar at the top of the column.\\n:::\\n<!--  -->\\n\\n","section":"Activity \\"marked as done\\" logic","version":"current","path":"/kb/activities/activity-marked-as-done-logic#list-view","category":"default"},{"title":"Detail view","content":"In the detail view of an item, linked activities are ordered by their due date, which is visible under the title of any activity in an item’s history.\\n\\n<!-- TODO: agregar tooltip con la fecha entera por mas que diga today -->\\n:::tip\\nNote: “Marked as done time” data is unavailable in the activity\'s detail view.\\n:::\\n","section":"Activity \\"marked as done\\" logic","version":"current","path":"/kb/activities/activity-marked-as-done-logic#detail-view","category":"default"},{"title":"Creating custom activity types","content":"<p>&lt;!-- ../../kb/activities/creating-custom-activity-types.md --&gt;</p>\\n<p>&lt;!-- # Creating custom activity types --&gt;</p>\\n<p>Fintesk comes with a basic set of activity <strong>types</strong>, but what if you need activities that are more specific to your company and its needs?</p>\\n<p>:::tip\\n<strong>Note:</strong> This action is only available to admin users.\\n:::</p>\\n<p>Luckily, you can create custom activity types with their own icon to be able to make Fintesk more specific to your business.</p>\\n<p>To create a new activity type in Fintesk:</p>\\n<ul>\\n<li>Go to <strong>Settings &gt; Company settings &gt; <a href=\\"https://app.fintesk.com/settings/company-settings#activities?utm_source=fintesk-docs\\">Activities</a></strong>. All your activity types are listed on this screen.</li>\\n<li>Click the “<strong>+ Activity type</strong>“ button to add a new activity type.</li>\\n<li>Choose an icon and name for your new activity type and click “<strong>Save</strong>“.</li>\\n</ul>\\n<p><img src=\\"../../kb/activities/creating-custom-activity-types/01.jpg\\" alt=\\"01\\"></p>\\n","section":"Creating custom activity types","version":"current","path":"/kb/activities/creating-custom-activity-types","category":"default"},{"title":"Adding activities in bulk with new items","content":":::tip\\nNote: Check out our sample spreadsheets if you need help setting your spreadsheet up before importing.\\n:::\\nWhen you import new items (contacts, deals, activities, etc.) using a spreadsheet, those items are linked.\\n\\nThat means if you import new contacts and activities, the activities will be linked to the new contacts.\\n:::tip\\nNote: To add activities in bulk without linking them to other items, import a spreadsheet with only activity data.\\n:::\\n\\n","section":"How can I create activities in bulk?","version":"current","path":"/kb/activities/how-can-i-create-activities-in-bulk#adding-activities-in-bulk-with-new-items","category":"default"},{"title":"Adding activities in bulk for existing items","content":"To add activities in bulk and link them to existing items, you’ll need the Fintesk System ID function for importing.\\nTo obtain the IDs for your existing items, use the gear icon in your list view to select the “ID” field, then click “Save.”\\n\\nOnce that column is visible, export the filter results to a spreadsheet:\\n\\nThen add the necessary activity data into the exported spreadsheet and reimport that spreadsheet back into your Fintesk account.\\n\\nMap the activity fields accordingly, and once finished, you’ll have a new activity linked to each item you exported.\\n","section":"How can I create activities in bulk?","version":"current","path":"/kb/activities/how-can-i-create-activities-in-bulk#adding-activities-in-bulk-for-existing-items","category":"default"},{"title":"Filtering by activity type","content":"<!-- :::tip\\nNote: If an activity-type icon is blue, that type is being filtered for. If the icon is grey, it’s being filtered out.\\n::: -->\\nYou can filter out default or custom activity types by clicking on them in the top right corner of your list view.\\n\\nYou can select “All” to add or remove every activity-type filter. If you want to filter for a single activity type, click “All” to filter out every activity type, then select the one you want to filter for.\\n:::tip\\nNote: You must be an admin user or a regular user with the assigned permission to create custom activity types.\\n:::\\n\\n","section":"How can I filter my activities in the list view?","version":"current","path":"/kb/activities/how-can-i-filter-my-activities-in-the-list-view#filtering-by-activity-type","category":"default"},{"title":"Filtering by owner","content":":::tip\\nNote: A filter for “Everyone” shows the activities owned by every user in the account.\\n:::\\n<!-- TODO: falta implementar  -->\\n<!-- excluding those blocked by visibility settings. -->\\nTo filter activities by owner, click the filter drop-down in the top-right corner of your list view and select “Owners”.\\n\\nFrom there, you can select any user listed and use them for your filter.\\n\\n<!-- :::tip\\nNote: If you don’t have visibility of a linked deal or contact, you won’t have visibility of the linked activity.\\n::: -->\\n\\n","section":"How can I filter my activities in the list view?","version":"current","path":"/kb/activities/how-can-i-filter-my-activities-in-the-list-view#filtering-by-owner","category":"default"},{"title":"Filtering by due-date","content":"On the right side of your activities list view, you can filter by fixed time periods or a custom date range using “Select period.”\\n\\n:::tip\\nNote: You can learn how to filter for activities that you’ve already marked as done using this guide.\\n:::\\n","section":"How can I filter my activities in the list view?","version":"current","path":"/kb/activities/how-can-i-filter-my-activities-in-the-list-view#filtering-by-due-date","category":"default"},{"title":"How can I link my activities with multiple contact persons?","content":"<p>&lt;!-- ../../kb/activities/how-can-i-link-my-activities-with-multiple-contact-persons.md --&gt;</p>\\n<p>You can link multiple person contacts to an activity by adding them in the <strong>person</strong> section of the activity detail view.</p>\\n<p>&lt;!-- # How can I link my activities with multiple contact persons? --&gt;</p>\\n<p>:::tip\\n<strong>Note:</strong> An activity can only have one linked deal or organization. However, there is no limit to the number of linked person an activity can have.\\n:::</p>\\n<p><img src=\\"../../kb/activities/how-can-i-link-my-activities-with-multiple-contact-persons/01.jpg\\" alt=\\"01\\"></p>\\n<p>:::tip\\n<strong>Note:</strong> If a Fintesk contact is added, the activity will be linked to them and appear in their person detail view.\\n:::</p>\\n<p>&lt;!-- You can also send email notifications about an activity to contacts, both in and out of Fintesk, by adding them as <strong>guests.</strong></p>\\n<p><img src=\\"https://kb-cms.pipedriveassets.com/activities%20guest.jpg\\" alt=\\"1\\"></p>\\n<p>:::tip\\n<strong>Note:</strong> If a Fintesk contact is added as a guest, the activity won’t be linked to them or appear in their person detail view.\\n::: --&gt;</p>\\n","section":"How can I link my activities with multiple contact persons?","version":"current","path":"/kb/activities/how-can-i-link-my-activities-with-multiple-contact-persons","category":"default"},{"title":"How can I see done activities?","content":"You can view completed activities in the list view of the activities tab by first applying a filter with the condition Activity > Done > is > Done.\\n\\n<!-- Then, apply a pre-set or custom time filter to see the activities done within the selected time frame. -->\\n<!--  -->\\nIf you want to view all completed activities, regardless of the time frame it was completed in, you can apply the filter Activity > Marked as done time > is not empty.\\n\\n","section":"How can I see done activities?","version":"current","path":"/kb/activities/how-can-i-see-done-activities","category":"default"},{"title":"Creating a custom currency","content":"Go to Company settings > Currencies and click “Add Custom currency” to create a new currency.\\n\\nEnter the name and symbol for your currency, and Fintesk will assign a unique code to it.\\nYou can also specify the decimal value (i.e. ฿0.30048000 or $125.17.)\\n\\nWhen you’ve provided all of the relevant information, click “Save.”\\n<!-- Note: You can click “Get a different code” to generate a new code, but you can’t enter a code manually. -->\\n\\n","section":"How can I create a custom currency?","version":"current","path":"/kb/company-settings/how-can-i-create-a-custom-currency#creating-a-custom-currency","category":"default"},{"title":"Viewing and changing your custom currency","content":"You can see your custom currency in several places in your Fintesk account:\\nDeals and product add modals\\nDetail views\\n<!-- - Webforms and automations -->\\nIn the add deal modal, you can choose any currency to calculate that deal’s value.\\n\\nIn the deal detail view, click the pencil icon next to your deal value to edit your currency.\\n\\nThen use the dropdown menu to choose your desired currency and click ”Save.“\\nOr in any custom currency field from an entity.\\n\\nYou can also view your custom currency from the currency tab in your settings. Custom currencies always appear above the default currencies in this view.\\n\\n\\n","section":"How can I create a custom currency?","version":"current","path":"/kb/company-settings/how-can-i-create-a-custom-currency#viewing-and-changing-your-custom-currency","category":"default"},{"title":"Deactivating and reactivating custom currencies","content":"To deactivate a custom currency, go to your currencies tab and click, search the currency in the table, and select Deactivate.\\n\\nYou can also reactivate a currency by clicking the tab ”Deactivated“ to open your list of deactivated currencies, search the currency in the table, and then ”Reactivate\\".\\n\\n\\n","section":"How can I create a custom currency?","version":"current","path":"/kb/company-settings/how-can-i-create-a-custom-currency#deactivating-and-reactivating-custom-currencies","category":"default"},{"title":"Changing custom currency to default","content":"Go to Settings > Personal preferences > Account and find the default currency dropdown.\\n\\nFrom there, select your custom currency and click Update data”.\\n","section":"How can I create a custom currency?","version":"current","path":"/kb/company-settings/how-can-i-create-a-custom-currency#changing-custom-currency-to-default","category":"default"},{"title":"How can I enable predefined lost reasons?","content":"<p>&lt;!-- ../../kb/company-settings/how-can-i-enable-predefined-lost-reasons.md --&gt;</p>\\n<p>&lt;!-- # How can I enable predefined lost reasons? --&gt;</p>\\n<p>As a default, Fintesk operates with freeform lost reasons. This means that each user is able to write down their specific understanding of why the deal in question had to be marked as <strong>lost</strong>.</p>\\n<p>:::tip\\n<strong>Note:</strong> This action is only available to deals admin users.\\n:::</p>\\n<p>If you’d prefer to set specific, predefined reasons for your users to select from instead, you can enable that within your account by going to <strong>Company settings &gt; <a href=\\"https://app.fintesk.com/settings/company_settings#lost_reasons?utm_source=fintesk-docs\\">Lost reasons</a></strong>.</p>\\n<p>To enable predefined reasons:</p>\\n<ul>\\n<li>Click on the “<strong>Add Lost reason</strong>” button</li>\\n<li>Type out the predefined lost reason you would like to add to your account</li>\\n<li>Click the &quot;<strong>Save</strong>&quot; button</li>\\n</ul>\\n<p><img src=\\"../../kb/company-settings/how-can-i-enable-predefined-lost-reasons/lr01.jpeg\\" alt=\\"lr01\\"></p>\\n<p>When saved, the predefined lost reason will appear below. Clicking on it will allow you to edit or deactivated it.</p>\\n<p><img src=\\"../../kb/company-settings/how-can-i-enable-predefined-lost-reasons/lr02.jpeg\\" alt=\\"lr02\\"></p>\\n<p>&lt;!-- You’ll also be presented with an option to allow for freeform lost reasons alongside your predefined options.</p>\\n<p><img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202024-04-16%20at%2014.39.14.png\\" alt=\\"1\\"></p>\\n<p>This way, your users could still provide freeform lost reasons in situations where the lost reason differs from the list of predefined lost reasons programmed by the admin user.</p>\\n<p><img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202024-04-16%20at%2014.43.37.png\\" alt=\\"1\\">--&gt;</p>\\n<p>To use your predefined lost reasons, simply mark a deal in your Fintesk account as <strong>lost</strong>.</p>\\n<p>In the <strong>“Mark as lost”</strong> prompt, you’ll see a dropdown section under lost reason instead of the fillable text form. Click the dropdown prompt to scroll through a list of your predefined lost reasons and select one.</p>\\n<p>After selecting your predefined lost reason – and including any extra comments you may have – click the <strong>“Mark as lost”</strong> button.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202024-04-16%20at%2014.47.57.png\\" alt=\\"1\\"> --&gt;</p>\\n<p>Once done, that predefined lost reason will appear in the <strong>detail view</strong> of that now <strong>lost</strong> deal.</p>\\n<p>These predefined lost reasons can also be tracked in the same way as the freeform lost reasons, through both the <strong>list view</strong> of the <strong>deals</strong> of your Fintesk account.</p>\\n","section":"How can I enable predefined lost reasons?","version":"current","path":"/kb/company-settings/how-can-i-enable-predefined-lost-reasons","category":"default"},{"title":"Freeform lost reasons","content":"are provided by any user marking a deal as lost\\nallow a user to provide their insight as to why the deal did not proceed\\n","section":"Lost reasons","version":"current","path":"/kb/company-settings/lost-reasons#freeform-lost-reasons","category":"default"},{"title":"Predefined lost reasons","content":"are programmed by an admin user as a list for other users to choose from\\ncan be chosen from this list when a deal is marked as lost, allowing for consistent and effective information about why a deal did not proceed\\nBoth of these options allow you to provide additional comments about why that specific deal was marked as lost.\\nThese comments are placed in the lost deal as a note so that you can always refer back to the specific information regarding why that deal was marked as lost.\\n\\n","section":"Lost reasons","version":"current","path":"/kb/company-settings/lost-reasons#predefined-lost-reasons","category":"default"},{"title":"Using lost reasons","content":":::tip\\nNote: By default, Fintesk is set to use freeform lost reasons. Learn how to enable predefined lost reasons in this article.\\n:::\\nTo use your lost reasons, simply mark a deal in your Fintesk account as lost. You\'ll see a prompt asking for a reason for marking that deal as lost in your account.\\n\\nProvide your insight as to why the deal was lost – including any extra comments you may have – and click the \\"Mark as lost\\" button.\\nThe status of the deal will be changed to lost, and that provided lost reason will be made visible in the details section of that deal\'s detail view.\\n<!-- If you provided other comments in the provided section, those comments will be saved as a note, viewable in the detail view of that deal.\\n\\n-->\\nIf you provided other comments in the provided section, those comments will be saved, viewable in the list view of that deal.\\n\\n","section":"Lost reasons","version":"current","path":"/kb/company-settings/lost-reasons#using-lost-reasons","category":"default"},{"title":"Tracking lost reasons","content":"Using this documented lost reason information, you can get an idea for trends within your sales – like if a certain category of customers is not likely to finish a sale around a certain time of the year, or if a competitor is beginning to poach away some of your customers.\\nTo get an immediate idea of your lost reasons:\\nGo to the deals tab of your Fintesk account and then to the list view.\\nUsing the filter button, find the lost deals within your Fintesk account.\\nWhen displaying those lost deals, click on the gear icon on the right side of the Fintesk app.\\nSelect the lost reason column to display in your list view, and click \\"Save\\".\\nWith that lost reason column now displayed, you should see the reasons provided for why each specific deal was marked as lost.\\n\\n","section":"Lost reasons","version":"current","path":"/kb/company-settings/lost-reasons#tracking-lost-reasons","category":"default"},{"title":"Contact detail view","content":"At first glance, the contact detail view offers a lot of information, including the section on the right where you can:\\nWrite notes\\nCreate new activities\\n<!-- Learn more about Smart Docs -->\\n\\n\\n","section":"Contact detail view","version":"current","path":"/kb/contacts/contact-detail-view#contact-detail-view","category":"default"},{"title":"Sidebar","content":"<!-- Note: For a more detailed guide about detail view sidebar management, check out [this article.]\\n(../../kb/detail-view/detail-view-sidebar)\\nThe sidebar section contains a wealth of pertinent information, which can be separated into two sections. -->\\n","section":"Contact detail view","version":"current","path":"/kb/contacts/contact-detail-view#sidebar","category":"default"},{"title":"General data","content":"Your sidebar has several sections that offer a general overview of your contact’s data.\\nSummary – always has the same pieces of information: label(s) -coming soon-, email address, phone number and linked organization/person\\nDetails – you can choose any available fields, both default and custom, to display here\\nOverview – shows the activities created for the contact, as well as which users have interacted with it\\n\\n","section":"Contact detail view","version":"current","path":"/kb/contacts/contact-detail-view#general-data","category":"default"},{"title":"Linked items","content":"<!-- You can also find any linked leads, deals, contacts and projects in your sidebar. -->\\nYou can also find any linked deals, contacts and organizations in your sidebar.\\n\\n\\n","section":"Contact detail view","version":"current","path":"/kb/contacts/contact-detail-view#linked-items","category":"default"},{"title":"Changelog","content":"Under the History of your item, you can select the Changelog.\\n\\nThis gives you a detailed list of updates made to your contact, including when these changes were made and by which user.\\n\\n","section":"Contact detail view","version":"current","path":"/kb/contacts/contact-detail-view#changelog","category":"default"},{"title":"Hover cards","content":"In the detail view, you can hover your cursor over certain items and see a card with that item’s data.\\n\\n\\n","section":"Contact detail view","version":"current","path":"/kb/contacts/contact-detail-view#hover-cards","category":"default"},{"title":"History","content":"This section includes any updates made to a contact and is divided into sections for easy filtering.\\n\\n","section":"Contact detail view","version":"current","path":"/kb/contacts/contact-detail-view#history","category":"default"},{"title":"Persons","content":"Person contacts are the individual customers that you sell to from Fintesk.\\nThey’re the backbone of the sales process, and related information like scheduled activities and emails is tracked in that person’s detail view.\\n\\nThings to keep in mind about person:\\nThey’re your customers and contain email addresses and phone numbers.\\nThey can be linked to an organization.\\nThey can be linked to multiple deals at the same time.\\n:::tip\\nNote: You can create custom fields to add data for your contacts that isn’t covered by Fintesk’s default fields.\\n:::\\n\\n","section":"Contacts-> persons and organizations","version":"current","path":"/kb/contacts/contacts-persons-and-organizations#persons","category":"default"},{"title":"Organizations","content":"Organizations are businesses or collections of contacts, and like person, you can find their relevant details and linked information in the detail view.\\n\\nThings to keep in mind about organizations:\\nThey’re the companies your person contacts work for and contain information like a mailing address or industry information.\\nThey can be linked to multiple person.\\nThey can have multiple deals open for them at the same time.\\nThey can be related to other organizations (coming soon).\\n:::tip\\nNote: A person or organization can have multiple deals linked to them, but a deal can only be linked to one person or organization at a time.\\n:::\\n\\n","section":"Contacts-> persons and organizations","version":"current","path":"/kb/contacts/contacts-persons-and-organizations#organizations","category":"default"},{"title":"How to add contacts","content":"Persons and organizations can be added to your Fintesk account in several ways:\\nIn the “Add deal” dialog box, you can create a new contact by adding a name not linked to an existing contact.\\n\\nIn the list view of your persons or organizations tab, you can create new contacts with the “+ Add Person” or “+ Add Organization” buttons.\\n\\n\\n<!-- - In an organization’s detail view, you can add a new person using the “+” button in the persons section.\\n-->\\n:::tip\\nNote: For more information about how to link persons and organizations together, you can look at this article.\\n:::\\n<!--\\n","section":"Contacts-> persons and organizations","version":"current","path":"/kb/contacts/contacts-persons-and-organizations#how-to-add-contacts","category":"default"},{"title":"Labeling contacts","content":"Your Fintesk contacts can be categorized using the contact labels feature.\\n\\nYou can add existing labels to contacts, or create new labels using the “+ Add new label” option.\\n:::tip\\nNote: Multiple labels can be added to a single person or organization. For more information about labeling, check out this article.\\n::: -->\\n","section":"Contacts-> persons and organizations","version":"current","path":"/kb/contacts/contacts-persons-and-organizations#labeling-contacts","category":"default"},{"title":"Creating a person or organization custom field","content":"To create a custom field for your deals, go to Company settings > Data fields and select ”+ Add Custom field“ under Deal.\\n<!-- Lead/deal. -->\\n\\nType in a name for your field, select ”Person“ or ”Organization“ for your field type and click ”Save.“\\n\\nYou should see your new field listed under custom fields.\\n\\n:::tip\\nNote: For more information about custom fields and the related settings, check out this guide.\\n:::\\n\\n","section":"How can I add related persons or organizations to a deal?","version":"current","path":"/kb/contacts/how-can-i-add-related-persons-or-organizations-to-a-deal#creating-a-person-or-organization-custom-field","category":"default"},{"title":"Using your custom field","content":":::tip\\nNote: A person or organization custom field allows for one contact to be added. If you want to add multiple related persons or organizations to your deals, you need to create multiple custom fields.\\n:::\\nOnce you’ve created your custom field, go to a deal’s detail view and click the pencil icon to the right of the field.\\n\\nType in the first few letters of your person or organization’s name, and it will auto-populate. If a contact with that name doesn’t exist in your account, you can create one using the field.\\n\\n","section":"How can I add related persons or organizations to a deal?","version":"current","path":"/kb/contacts/how-can-i-add-related-persons-or-organizations-to-a-deal#using-your-custom-field","category":"default"},{"title":"Linking an organization to a person","content":"To link an organization to a person, go to a person contact\'s detail view and click on \\"+Link an organization\\" under the organization card.\\n\\nYou can then search for an organization in your company Fintesk account and click on it, which will take you to the \\"Link this organization\\" option.\\nIf there is no organization with the name you searched, you will be prompted to create a new organization.\\n\\n\\n<!-- ## Adding a new person to an organization\\nTo link an existing person to an organization, go to the detail view of an organization and click on the \\"+\\" icon in the persons sidebar section. You will be prompted with the Link a person modal, where you can enter the name of your person contact.\\n\\n:::tip\\nNote: If a person with the name you typed in doesn\'t exist, you can use the \\"+Add\\" option to create a new person contact.\\n:::\\n--- -->\\n","section":"Linking persons and organizations","version":"current","path":"/kb/contacts/linking-persons-and-organizations#linking-an-organization-to-a-person","category":"default"},{"title":"Updating the linked organization","content":"To unlink, switch, or update the fields of a contact person\'s linked organization, go to the contact person\'s detail page and click on the \\"...\\" icon in the organization card.\\n\\n\\n","section":"Linking persons and organizations","version":"current","path":"/kb/contacts/linking-persons-and-organizations#updating-the-linked-organization","category":"default"},{"title":"Linking a deal to a contact","content":"<!-- Both persons and organizations can be linked to a Deal through the detail view, using either the \\"+\\" option in the [sidebar section](../../ES DRAFT AUN), or the \\"Link\\" option in the person and organization sections: -->\\nBoth persons and organizations can be linked to a Deal through the detail view, using either the \\"+\\" option in the sidebar section, or the \\"Link\\" option in the person and organization sections:\\n\\nWith either method, you will be asked to type in the name of the contact you want to link. If the contact already exists in your database, you will be able to link it to your deal. If a contact with that name does not exist yet, you will have the option to create a new contact.\\n\\nYou can also link contacts to your deals by going to your list view, hovering your cursor over a person or organization space, and clicking the pencil icon.\\n\\n","section":"Linking persons and organizations","version":"current","path":"/kb/contacts/linking-persons-and-organizations#linking-a-deal-to-a-contact","category":"default"},{"title":"Adding custom fields","content":"<!-- :::tip\\nNote: Not sure where to add your custom field? Learn more about how your data is organized in this article.\\n::: -->\\n:::tip\\nNote: Not sure where to add your custom field? Learn more about how your data is organized in this article.\\n:::\\nGo to Settings > Company > Data fields, and click “Add custom field“. The field can be added under Deal, Person, Organization or Product.\\nIn the window that appears, name the field and select the type of field you wish to create. Fintesk offers a variety of custom field types that can easily be customized according to the information you need for your data.\\n\\nYou can learn about the types of custom fields available in this article.\\n\\n<!--  -->\\n","section":"Custom fields","version":"current","path":"/kb/data-fields/custom-fields#adding-custom-fields","category":"default"},{"title":"Field properties","content":"When adding a custom field, you can choose the places where the field is shown in Fintesk.\\n<!-- - Always visible in detail view (pinned)\\nThe custom field always appears in the item’s detail view, whether or not a value is added. -->\\nAppears in add view\\nThe custom field always appears in that item’s “Add new” dialog.\\nAppears in detail view\\nThe custom field always appears in that item’s Detail View. For example, maybe\\nyou only want to add a field for working only with our API.\\n<!-- - **Appears in project detail view\\n**The custom field always appears in a project\'s detail view, whether or not a value is added. -->\\n<!-- - Pipeline (for lead/deal custom fields only)\\nYou can hide some fields from specific pipelines and unclutter the deal detail view. -->\\n<!-- :::tip\\nNote: Pipeline-specific custom fields are only available for Professional and higher plans.\\n::: -->\\n<!-- ### Quality rules\\nRequired fields\\nMark fields as required to ensure your team enters crucial deal data. If a required field is empty, users won\'t be able to save the deal and will see a reminder in already existing deals.\\nImportant fields\\nMarks a field as “important” in all or specific pipelines and stages. You can read more about important fields in this article. -->\\n<!-- ### Where else can I add custom fields?\\nCustom fields can also be added in the detail view of an item by going to Details > Customize fields > +Add a new field.\\n\\n--- -->\\n","section":"Custom fields","version":"current","path":"/kb/data-fields/custom-fields#field-properties","category":"default"},{"title":"Viewing your custom fields","content":"You can add, view, or delete custom field values in the following places within Fintesk.\\nIn the detail view:\\nIn the detail view, any custom fields can be found in the DETAILS section.\\nIn the list view:\\nClick on the gear icon to the right of the table and select the custom field in the “Choose columns” section. Click “Save” to make that custom field column visible in the list view\\nIn the Add new dialog:\\nIf the “Show in add new dialog” option is marked as “Yes,” the custom field will appear in the “Add new” modals.\\nIn the Import function:\\nWhen importing a spreadsheet into Fintesk, your custom fields can be mapped to columns in your spreadsheet. You can also add custom fields directly from the mapping page.\\nRead more about importing in this article.\\n\\n","section":"Custom fields","version":"current","path":"/kb/data-fields/custom-fields#viewing-your-custom-fields","category":"default"},{"title":"Updating your custom fields","content":"To change your custom fields, go to Settings > Company > Data fields and click the \\"...” button next to your custom field.\\n\\nEdit\\nYou can change the custom field name, field properties for your custom field at any time. The custom field type cannot be changed once it has been created.\\n\\n\\nDelete\\nDeleting your custom field will delete the field and its existing data from your Fintesk account.\\n\\n\\nCopy API key\\nYou can copy your custom field’s API key. For more information on how to use the API, you can look at our API documentation.\\n<!-- **You can change the custom field name, field properties and important fields for your custom field at any time. The custom field type cannot be changed once it has been created. -->\\n<!--\\nReorder\\nYou can change the order your custom fields are displayed in. After clicking on “Reorder“, you will be prompted with a window where you can change the order of fields. The changes will be applied to the Add new view and detail view.\\n\\n-->\\n<!--\\n","section":"Custom fields","version":"current","path":"/kb/data-fields/custom-fields#updating-your-custom-fields","category":"default"},{"title":"Custom field grouping","content":"You can organize your custom fields into groups, making it easier to find the field you need.\\nTo add a new custom field group, click ”+ Field group“ while creating or editing a custom field.\\n\\nAfter you create your group, you can see it in your data fields.\\n\\nYou can view your fields in groups or in a standard list view.\\n-->\\n","section":"Custom fields","version":"current","path":"/kb/data-fields/custom-fields#custom-field-grouping","category":"default"},{"title":"Custom fields","content":"One of the main characteristics of Fintesk is the customizable approach to managing your sales processes and operations. The type of information you gather from customers can vary depending on your business and industry – that’s why we offer the option to create custom fields.\\n\\nThese fields are viewable in the detail view, list view, and Add New dialog. Learn more about adding and configuring these fields in our custom fields article.\\n<!-- :::tip\\nNote: Formulas and pipeline-specific custom fields are only available for Professional and Enterprise users. The number of custom fields you can have depends on which plan you are on. Learn more about usage limits in this article.\\n::: -->\\n\\n","section":"Data fields in Fintesk","version":"current","path":"/kb/data-fields/data-fields-in-fintesk#custom-fields","category":"default"},{"title":"Default fields","content":"Default fields are already built into your Fintesk account when you create it. They are typically used for relevant customer information like names, emails or phone numbers – when a relevant field does not exist, a custom field can be created.\\n<!-- You can find the default fields section right below the custom fields section.\\n-->\\n:::tip\\nNote: Default fields cannot be deleted.\\n:::\\nThese fields are viewable in the detail view, list view. The name or type of default fields cannot be edited.\\n<!-- TODO: agregar esta clasificacion y posibilidad de modificar cuando este grouping -->\\n<!-- , but the quality rules can. -->\\n<!--  -->\\n:::tip\\nNote: The instant messengers, post addresses, notes, birthday/dates of birth and job title fields don\'t exist by default in Fintesk. But you can add it via custom fields.\\n<!-- They are only created for contact persons when you set up your contact sync. You can learn more about contact sync in this article. -->\\n:::\\n\\n","section":"Data fields in Fintesk","version":"current","path":"/kb/data-fields/data-fields-in-fintesk#default-fields","category":"default"},{"title":"System fields","content":"System fields are also already built into your Fintesk account. These fields are part of the Fintesk interface. The information they contain is not filled inside the detail view or Add New dialog, as it is filled manually or automatically through a different feature or menu (for example, the date when an item was created or the number of emails you exchanged with a contact).\\nYou can find the system fields section right below.\\n<!-- the default fields section. -->\\n\\n:::tip\\nNote: System fields cannot be edited or deleted.\\n:::\\nThese fields are always visible when mapping your imports, and they are helpful to update data into Fintesk with spreadsheets.\\n","section":"Data fields in Fintesk","version":"current","path":"/kb/data-fields/data-fields-in-fintesk#system-fields","category":"default"},{"title":"Which fields can I add?","content":"The ability to add a data field to an Add item modal will depend on what kind of field you are trying to add and where you are trying to add it.\\nAdd deal prompt\\nAdd person prompt\\nAdd organization prompt\\nAdd product prompt\\n\\n\\n\\n\\ndeal data field\\n✔️\\n\\n\\n\\n\\n\\nPerson data field\\n✔️\\n✔️\\n\\n\\n\\n\\nOrganization data field\\n✔️\\n✔️\\n✔️\\n\\n\\n\\nProduct data field\\n\\n\\n\\n✔️\\n","section":"How can I add data fields to an add deal, contact, or product modal?","version":"current","path":"/kb/data-fields/how-can-i-add-data-fields-to-an-add-deal-contact-or-product-modal#which-fields-can-i-add","category":"default"},{"title":"Types of custom fields","content":"There are fourteen (at the moment) different types of custom fields, with different kinds of information you can add to your deals, persons, organizations, or products.\\n<!-- There are sixteen different types of custom fields, with different kinds of information you can add to your deals, persons, organizations, or products. -->\\n<!-- information you can add to your leads, deals, contacts, projects or products. -->\\n<table>\\n<tr>\\n<td>Field name</td>\\n<td>What it’s for</td>\\n<td>Common uses</td>\\n</tr>\\n<tr>\\n<td>Text</td>\\n<td>Notes, URLs or other text</td>\\n<td>Secondary email addresses, (short) comments, job titles</td>\\n</tr>\\n<tr>\\n<td>Large text</td>\\n<td>Longer notes</td>\\n<td>Longer comments, descriptions</td>\\n</tr>\\n<tr>\\n<td>Single option</td>\\n<td>List of predefined options where only one can be selected (Maximum 500 options)</td>\\n<td>Category, industry, job title</td>\\n</tr>\\n<tr>\\n<td>Multiple options</td>\\n<td>List of predefined options where multiple items can be selected (Maximum 500 options)</td>\\n<td>Industry, region, competitors, job title, item status</td>\\n</tr>\\n<tr>\\n<td>Numerical</td>\\n<td>Numerical data</td>\\n<td>Priority level, numbered ranking, units requested</td>\\n</tr>\\n<tr>\\n<td>Monetary</td>\\n<td>Numerical data prefixed with a currency symbol.</td>\\n<td>Commission, estimates, costs</td>\\n</tr>\\n<tr>\\n<td>User</td>\\n<td>Tag a Fintesk user from your Fintesk account</td>\\n<td>Previous or secondary deal or contact owners, users related to the larger project</td>\\n</tr>\\n<tr>\\n<td>Organization</td>\\n<td>Tag an organization from your Fintesk database.</td>\\n<td>Related or secondary parties, partner organizations, holding companies</td>\\n</tr>\\n<tr>\\n<td>Person</td>\\n<td>Tag a person from your Fintesk database.</td>\\n<td>Related or secondary person contact</td>\\n</tr>\\n<tr>\\n<td>Phone</td>\\n<td>Enter a phone number</td>\\n<td>Secondary Skype names, secondary phone numbers, primary phone number for linked item (deal, org.)</td>\\n</tr>\\n<tr>\\n<td>Time</td>\\n<td>Specific time chosen from a time drop-down. Time format will match your default time zone format.</td>\\n<td>Delivery time, lunchtime</td>\\n</tr>\\n<tr>\\n<td>Time Range</td>\\n<td>Range of time chosen from a time drop-down. Time format will match your default time zone format.</td>\\n<td>Office hours, best time to contact</td>\\n</tr>\\n<tr>\\n<td>Date</td>\\n<td>Specific date chosen from a drop-down calendar</td>\\n<td>Delivery date, deadlines</td>\\n</tr>\\n<tr>\\n<td>Date Range</td>\\n<td>Range of dates chosen from a drop-down calendar</td>\\n<td>Event dates, completion estimates, holidays</td>\\n</tr>\\n</table>\\n<!-- | Address          | Stores full addresses using autocomplete from Google Maps.                                                | Event places, secondary office locations (when separate from business address)                    | -->\\n\\n","section":"What types of custom fields are there?","version":"current","path":"/kb/data-fields/what-types-of-custom-fields-are-there#types-of-custom-fields","category":"default"},{"title":"Things to keep in mind","content":"User, organization, and person-type custom fields will click through to the item entered in those values.\\nPersons in Fintesk already have a default phone field, but a phone-type custom field can be added under other items (organizations, deals, etc.).\\nOrganizations in Fintesk already have a default address field, but an address-type custom field can be added under other items (deals, persons, etc.)\\nWhen adding a value in a person or organization field, if a contact with that name doesn’t already exist in your account, a new one will be created\\nThe currency of a monetary field will match your default currency setting unless otherwise specified.\\n<!-- - Numerical and monetary fields for deals can also have formulas added to them. You can learn more about formula fields in this article. -->\\n<!-- - Text fields can be used for URLs, and clicking a URL in a text field will redirect you to that webpage -->\\n<!-- - Address custom fields behave like the default address fields under organizations, including subfields and the “Show on Map” feature. -->\\n","section":"What types of custom fields are there?","version":"current","path":"/kb/data-fields/what-types-of-custom-fields-are-there#things-to-keep-in-mind","category":"default"},{"title":"Adding deals in bulk","content":"<p>&lt;!-- ## Adding deals in bulk --&gt;</p>\\n<p>:::tip\\n<strong>Note:</strong> The number of open deals you can have depends on which plan you are on. You can learn more about usage limits in <a href=\\"../../kb/personal-settings/usage-limits-in-fintesk\\">this article</a>.\\n:::</p>\\n<p>There are two methods to add deals in bulk to Fintesk and both are through <a href=\\"../../kb/importing-data/importing-data-into-fintesk-with-spreadsheets\\">importing</a>.</p>\\n<hr>\\n<p><strong>If you don\'t have contact persons or organizations added to your company account:</strong></p>\\n<p>Import them with a spreadsheet, adding all details as possible such as contact person or organization, deal value, follow-up activities, etc.</p>\\n<p>You can find our sample import spreadsheets on <a href=\\"../../kb/importing-data/importing-sample-import-spreadsheets\\">this page</a>.</p>\\n<p>:::tip\\n<strong>Note:</strong> Deals must have either a contact person or organization linked.\\n:::</p>\\n<hr>\\n<p><strong>If you already have contact persons or organizations added to your company account and wish to add deals for them in bulk:</strong></p>\\n<p>We suggest utilizing the <a href=\\"../../kb/importing-data/updating-fintesk-data-with-a-spreadsheet\\">Fintesk System ID function when importing a spreadsheet</a>.</p>\\n<p>To acquire a spreadsheet containing the necessary person or organization IDs, go to the <a href=\\"../../kb/list-view\\">list view</a> and use the gear icon to make the appropriate <strong>Fintesk System ID</strong> field visible.</p>\\n<p>Once that field is visible, <a href=\\"../../kb/exporting-data/exporting-data-from-fintesk\\">export</a> the filter results to a spreadsheet, provide the necessary deal information and <a href=\\"../../kb/importing-data/importing-data-into-fintesk-with-spreadsheets\\">import</a> that spreadsheet back into your Fintesk account.</p>\\n<p>:::tip\\n<strong>Note:</strong> Exporting from the list view is only available to admin users and regular users with permissions.\\n:::</p>\\n","section":"Adding deals in bulk","version":"current","path":"/kb/deals/adding-deals-in-bulk","category":"default"},{"title":"The deal detail view","content":"Clicking on a deal opens its detail view, where you can see any linked contacts, products, or activities.\\n\\nHere are a few things to keep in mind about deals:\\nDeals can be linked to a person, or organization. Any changes made to a linked item are also reflected in the deal.\\nActivities and products can both be linked to a deal.\\nDeals track all events and movements that take place throughout your sales process (or any process involved).\\nDeals can be imported from a CSV or XLS file.\\n<!-- - Deals can be imported from a previous CRM or  -->\\n\\n","section":"Deals-> what they are and how to add them","version":"current","path":"/kb/deals/deals-what-they-are-and-how-to-add-them#the-deal-detail-view","category":"default"},{"title":"Adding one deal at a time","content":"There are a variety of ways you can add a new deal to your Fintesk account.\\n","section":"Deals-> what they are and how to add them","version":"current","path":"/kb/deals/deals-what-they-are-and-how-to-add-them#adding-one-deal-at-a-time","category":"default"},{"title":"The “+ Deal” button","content":"<!-- This button is found in your pipeline view, forecast view and deal list view. -->\\nThis button is found in your pipeline view and deal list view.\\n\\n<!-- You can also find it in your project detail view.\\n-->\\n","section":"Deals-> what they are and how to add them","version":"current","path":"/kb/deals/deals-what-they-are-and-how-to-add-them#the--deal-button","category":"default"},{"title":"The \\"+\\" button","content":"This option is located in your person or organization detail view under the deals section.\\n\\n:::tip\\nNote: To add a deal in this manner, the deal sidebar section must be visible.\\n<!-- To learn how to manage your sidebar sections, check out [this article]\\n(../../kb/detail-view/detail-view-sidebar). -->\\n:::\\n","section":"Deals-> what they are and how to add them","version":"current","path":"/kb/deals/deals-what-they-are-and-how-to-add-them#the--button","category":"default"},{"title":"The “Add new deal” button","content":"This option can be found in your person or organization detail view.\\n\\n<!-- It can also be found in your email tab.\\n\\nIf you have an existing deal you want to link to the email, select “Link to existing.” -->\\n\\n","section":"Deals-> what they are and how to add them","version":"current","path":"/kb/deals/deals-what-they-are-and-how-to-add-them#the-add-new-deal-button","category":"default"},{"title":"Adding deals in bulk","content":":::tip\\nNote: To learn about importing data into your Fintesk account, look at this in-depth guide.\\n:::\\nYou can add multiple deals at the same time using the importing process.\\nStart by going to “...”> Import data.\\n<!--  -->\\n\\nMake sure you have a column for deal name in the spreadsheet you’re importing, and map it to the field of the same name in Fintesk.\\n<!--  -->\\n\\n:::tip\\nNote: We offer sample spreadsheets with data you can use to practice the importing process, which you can find on this page.\\n:::\\n","section":"Deals-> what they are and how to add them","version":"current","path":"/kb/deals/deals-what-they-are-and-how-to-add-them#adding-deals-in-bulk","category":"default"},{"title":"Detail view","content":"Click the pencil icon to the right of your linked contact in the detail view summary, then delete the existing contact and type in the name of your new one.\\n\\nIf that contact doesn’t exist in your account, you’ll see the option to “Add [new contact name] as new contact.”\\n\\nAfter that, hit “Save” and a window will open where you can fill out your new contact’s basic information.\\n\\nOnce you click “Save” in the contact creator, the new contact will be linked to your deal.\\n","section":"Editing the contact linked to a deal","version":"current","path":"/kb/deals/editing-the-contact-linked-to-a-deal#detail-view","category":"default"},{"title":"List view","content":"From your deal list view, you can change a linked contact by hovering over it and clicking the pencil icon.\\n\\nThen delete the existing contact and type the name of the new one. If it doesn’t exist, you can add it as a new contact.\\n\\nAfter you choose your new contact, click “Save”.\\n\\n","section":"Editing the contact linked to a deal","version":"current","path":"/kb/deals/editing-the-contact-linked-to-a-deal#list-view","category":"default"},{"title":"Detail view","content":"Click the pencil icon next to your linked contact, delete the existing contact and type in the desired one.\\n\\nStarting at two letters, you’ll see a dropdown of options that best match what you’ve typed in. When you see the contact you want, click on it and “Save”.\\n\\n","section":"Editing the contact linked to a deal","version":"current","path":"/kb/deals/editing-the-contact-linked-to-a-deal#detail-view-1","category":"default"},{"title":"List view","content":"From your deal list view, you can change a linked contact by hovering over it and clicking the pencil icon.\\n\\nThen type the name of your preferred contact, and if it already exists in Fintesk, you can select it from the dropdown.\\n\\nAfter you choose your new contact, hit “Save”.\\n\\n","section":"Editing the contact linked to a deal","version":"current","path":"/kb/deals/editing-the-contact-linked-to-a-deal#list-view-1","category":"default"},{"title":"Renaming a contact","content":":::tip\\nNote: To rename a contact, you need to edit under the person or organization sidebar sections, not the summary section.\\n:::\\n<!-- To rename a linked contact, hover your cursor over the contact and click the pencil icon. -->\\nTo rename a linked contact, hover your cursor over the contact and click to going to person contact view.\\n\\n<!-- Then type in your desired changes, and select “Rename.” -->\\nClick the name, then type in your desired changes, and select Save”. Your contact will be updated in the deal view also.\\n\\n","section":"Editing the contact linked to a deal","version":"current","path":"/kb/deals/editing-the-contact-linked-to-a-deal#renaming-a-contact","category":"default"},{"title":"Pre-defined filters","content":"You can select a pre-defined filter for won, lost or deleted deals by clicking the filter dropdown in the top right corner and selecting the desired filter.\\n\\n<!--  -->\\nIf you are unable to find these filters, you can create new ones with the same conditions.\\n","section":"Filtering for my won, lost, or deleted deals","version":"current","path":"/kb/deals/filtering-for-my-won-lost-or-deleted-deals#pre-defined-filters","category":"default"},{"title":"Adding a new filter","content":"To create a filter, go to the filter dropdown and select “Add new filter”.\\n<!--  -->\\n\\nUse these conditions to see all of your won, lost and deleted deals:\\n<!--  -->\\n\\nOr you can filter for one of those conditions at a time:\\n<!--  -->\\n\\n\\n","section":"Filtering for my won, lost, or deleted deals","version":"current","path":"/kb/deals/filtering-for-my-won-lost-or-deleted-deals#adding-a-new-filter","category":"default"},{"title":"Filtering in the list view","content":"Since filters are shared between the pipeline and list views, the same pre-defined and custom filters from your pipeline view are available in the list view.\\n<!--  -->\\n\\nIf you want the same results in the list view that you saw in your pipeline view, specify the pipeline that you want to see data for.\\n<!--  -->\\n\\n:::tip\\nNote: To learn more about what you can accomplish with filtering, check out this article.\\n:::\\n","section":"Filtering for my won, lost, or deleted deals","version":"current","path":"/kb/deals/filtering-for-my-won-lost-or-deleted-deals#filtering-in-the-list-view","category":"default"},{"title":"How can I move a deal to another pipeline?","content":"<p>&lt;!-- ../../kb/deals/how-can-i-move-a-deal-to-another-pipeline.md --&gt;</p>\\n<p>There are different locations in Fintesk where a deal can be moved to another pipeline.</p>\\n<p>&lt;!-- ## How can I move a deal to another pipeline? --&gt;</p>\\n<p>:::tip\\n<strong>Note:</strong> You can learn more about deals and how best to manage them in <a href=\\"../../kb/deals/deals-what-they-are-and-how-to-add-them\\">this article</a>.\\n:::</p>\\n<ul>\\n<li>\\n<p>Pipeline view\\n<img src=\\"../../kb/deals/how-can-i-move-a-deal-to-another-pipeline/m01.gif\\" alt=\\"m01\\">\\n&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screen%20Capture%20on%202023-05-04%20at%2011-24-39.gif\\" alt=\\"1\\"> --&gt;</p>\\n</li>\\n<li>\\n<p>List view, where previously adding the columns <strong>Stage</strong>, then select the stage that belongs to the desired pipeline where you want to put it.\\n&lt;!-- - List view (by selecting at least one deal, then using the <a href=\\"../../kb/list-view/bulk-editing-and-filtering\\">bulk edit</a> tool.) --&gt;\\n<img src=\\"../../kb/deals/how-can-i-move-a-deal-to-another-pipeline/m02.gif\\" alt=\\"m02\\">\\n&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/move%20deal%201.jpg\\" alt=\\"1\\"> --&gt;</p>\\n</li>\\n</ul>\\n<p>&lt;!-- - Detail view</p>\\n<p><img src=\\"https://kb-cms.pipedriveassets.com/Screen%20Capture%20on%202023-05-04%20at%2011-40-50.gif\\" alt=\\"1\\"> --&gt;</p>\\n<p>&lt;!-- :::tip\\n<strong>Note:</strong> When you move a deal to another pipeline, it no longer shows up in reports for the previous pipeline.\\n::: --&gt;</p>\\n","section":"How can I move a deal to another pipeline?","version":"current","path":"/kb/deals/how-can-i-move-a-deal-to-another-pipeline","category":"default"},{"title":"Restoring leads in bulk","content":"If you\'d like to restore more than one deleted deal, we suggest first filtering to find deleted deals in your Fintesk account.\\n\\nWhen done, use the bulk edit functionality to select all of the deals you would like to restore. In the bulk edit panel that appears, find the \\"Status\\" field, select \\"Edit current value...\\" and then select \\"Open\\".\\n\\nClick the \\"Edit deals\\" button to save these status changes. -->\\n","section":"How can I restore deleted deals?","version":"current","path":"/kb/deals/how-can-i-restore-deleted-deals#restoring-leads-in-bulk","category":"default"},{"title":"Deal detail view","content":"In the deal detail view, you can find information regarding that deal, including deal status and any linked contacts.\\n<!--  -->\\n\\n","section":"Deal detail view","version":"current","path":"/kb/detail-view/deal-detail-view#deal-detail-view","category":"default"},{"title":"Progress bar","content":"\\nIn the deal\'s detail view, you will find the deal progress bar, showing you what pipeline stage the deal is currently at.\\n<!-- and the number of days it took to complete each stage. -->\\n\\n<!--  -->\\nThe deal progress bar will allow you to understand the progress of your deal and provide insight into which of your stages may require more attention.\\n<!-- Learn more about deal management -->\\n\\n","section":"Deal detail view","version":"current","path":"/kb/detail-view/deal-detail-view#progress-bar","category":"default"},{"title":"Sidebar","content":"The sidebar in the detail view features the information you have added to your deal.\\n<!-- If you are using multiple Marketplace apps in your workflow, our App Panels feature allows you to add specific apps to the sidebar. -->\\n","section":"Deal detail view","version":"current","path":"/kb/detail-view/deal-detail-view#sidebar","category":"default"},{"title":"Summary","content":"The summary is the first section within the sidebar and contains the core details of your deals, such as:\\nValue and products\\nLabel (coming soon)\\nProbability (coming soon)\\nExpected close date\\nThe contact person\\nThe organization linked to the deal\\n<!--  -->\\nThe summary is always displayed at the top of the sidebar.\\n\\n","section":"Deal detail view","version":"current","path":"/kb/detail-view/deal-detail-view#summary","category":"default"},{"title":"Changelog","content":"When in the detail view of a deal, you can click on the Changelog function to view any change made to that item, sorted by date.\\n<!--  -->\\nThese changes will also include stage changes, value, label and contact updates, as well as changes to the expected closed date and default and custom field updates.\\n\\n","section":"Deal detail view","version":"current","path":"/kb/detail-view/deal-detail-view#changelog","category":"default"},{"title":"Hover cards","content":"When you hover over the contact name, organization name, or Fintesk user in the deal detail view, you will see a popup card containing details related to that item.\\nDeal owner\\n\\n<!--  -->\\n\\n\\nPerson\\n\\n<!--  -->\\nOrganization\\n<!--  -->\\n\\n<!-- ## History\\nThis section includes all the items that have been added and uploaded to the deal.\\nYou can navigate through the tabs to filter specific items like notes, activities, emails exchanged, files, etc.\\n-->\\n","section":"Deal detail view","version":"current","path":"/kb/detail-view/deal-detail-view#hover-cards","category":"default"},{"title":"Deal detail view","content":"In the deal detail view, you will see any specific information regarding that deal, including deal status and any linked contacts.\\n\\n<!--  -->\\nIn the detail view of a deal, you will see the deal progress bar, showing you what pipeline stage the deal is currently in.\\n<!-- as well as how many days it has spent in each stage. -->\\n<!--  -->\\nThe deal progress bar will allow you to understand the progress of your deal and provide insight into which of your stages may need more attention.\\n<!-- :::tip\\nNote: The deal detail view is currently being revamped. If you don\'t see this version in your account, you might want to check the new deal detail view in this article.\\n::: -->\\n\\n","section":"Detail view","version":"current","path":"/kb/detail-view#deal-detail-view","category":"default"},{"title":"Contact detail view","content":"The detail view of a person shows data about that person, such as that person\'s email address or phone number.\\n<!-- It may also contain any contact label information provided about that customer. -->\\n\\n<!--  -->\\nThe detail view of an organization displays information specific to that organization, like a street address, or any custom field information you have added to that item in your account.\\n<!-- It will also display the assigned contact label. -->\\n\\n<!--  -->\\n\\n","section":"Detail view","version":"current","path":"/kb/detail-view#contact-detail-view","category":"default"},{"title":"Changelog","content":"When in the detail view of an item in Fintesk, you can click on the \\"CHANGELOG\\" function to view any change made to that item, sorted by date. These changes will also include updates made to any default or custom fields of that item.\\n<!--  -->\\nPersons – The changelog information will display when that contact was added to Fintesk, what deals have been made in their name and what organization they may be linked to.\\nOrganizations – You will see when persons have been added to your organization or when deals have been linked to this organization.\\n\\n","section":"Detail view","version":"current","path":"/kb/detail-view#changelog","category":"default"},{"title":"Hovercards","content":"When you hover over a deal name, contact name, organization name, or Fintesk user in the detail view, you will see a popup card containing details related to that item.\\nFintesk user (as item owner, follower, or participant)\\n\\n<!--  -->\\n\\n\\nOrganization\\n\\n<!--  -->\\n\\n\\nPerson\\n\\n<!--  -->\\n","section":"Detail view","version":"current","path":"/kb/detail-view#hovercards","category":"default"},{"title":"Adding a note","content":":::tip\\nNote: Each note size can be 100 KB maximum and you can have up to 3 notes per deal (in the free plan, limit vary depending the plan), person or organization. If a note exceeds the 100 KB size you can broken down the note into multiple notes.\\n:::\\nTo add a note to an item, go to the detail view and click ”Notes“ in the top right corner.\\n<!--  -->\\n\\nBasic text features can be found at the bottom of the window and include:\\nBolding\\nUnderlining\\nItalicizing\\nBullet listing\\nNumber listing\\nIndentation (left or right)\\nYou can also click the link button to embed a link into the text in your note.\\n<!--  -->\\n\\n:::tip\\nNote: Text that has a link embedded with appear blue, and you can click on the words to open the embedded link.\\n:::\\n\\n<!-- ## Additional notes features\\n:::tip\\nNote: Additional notes features are not available for activities.\\n:::\\nOn top of the basic editing features for notes, you can also add images and @mention other users in your account.\\nTo add an image to your note, click the image icon and select the desired picture.\\n\\nYou can also use the “@“ symbol to mention another user. Users mentioned receive a notification and they can leave comments on the note.\\n\\nWhen you’ve finished editing your note, click ”Save.“\\n:::tip\\nNote: When using the mentions feature, you can either click the ”@“ symbol or use the at key on your keyboard.\\n::: -->\\n\\n","section":"How can I add notes?","version":"current","path":"/kb/detail-view/how-can-i-add-notes-to-a-deal-or-contact#adding-a-note","category":"default"},{"title":"Saving and searching for the note","content":"Once you’ve saved the note, it’ll be added under the DONE section of your detail view.\\n<!--  -->\\n\\nClick the ”...“ to edit, pin or delete the note. When a note is pinned, it remains at the top of the detail view but can still be found under DONE.\\n<!--  -->\\n\\n<!-- You can also search for keywords from your note to find the linked item.\\n-->\\n","section":"How can I add notes?","version":"current","path":"/kb/detail-view/how-can-i-add-notes-to-a-deal-or-contact#saving-and-searching-for-the-note","category":"default"},{"title":"Changing the name of an item","content":"When in the detail view of contact or deal in Fintesk, click on the name to begin editing. Once you have added the new name, click ”Save” to update your item.\\n<!--  -->\\n\\n","section":"Updating items in the detail view","version":"current","path":"/kb/detail-view/updating-items-in-the-detail-view#changing-the-name-of-an-item","category":"default"},{"title":"Updating default and custom fields","content":"Any default or custom fields can also be updated in the detail view by clicking on the pencil icon or hovering over the field you want to update.\\n<!--  -->\\n\\n<!-- You can manage your detail view sidebar to have more control over the information displayed. -->\\n","section":"Updating items in the detail view","version":"current","path":"/kb/detail-view/updating-items-in-the-detail-view#updating-default-and-custom-fields","category":"default"},{"title":"Changing the value of the deal","content":"When in the deal detail view, click on the value to begin editing. Once your new value is added, click ”Save” for the value to be updated.\\n<!--  -->\\n\\nIf the deal has products added, you will need to adjust the number of products and the value will be calculated automatically.\\n\\n","section":"Updating items in the detail view","version":"current","path":"/kb/detail-view/updating-items-in-the-detail-view#changing-the-value-of-the-deal","category":"default"},{"title":"Deleting and restoring items","content":":::tip\\nNote: Only admin users have the ability to delete or restore contacts in Fintesk.\\n:::\\nBy default, only admin users in Fintesk can delete deals. If you do not see the option to delete a deal, we would recommend reaching out to the admin user in your account to enable this.\\n<!-- permission. -->\\nIf you do have permission to delete deals in the account, you can do so by clicking the ”...” button and selecting the ”Delete” option from the dropdown menu.\\n<!--  -->\\nIf you wish to restore a deleted deal, simply click on ”Reopen”.\\n<!--  -->\\nIf you wish to restore a deleted contact, click on the ”...” button and select the ”Restore” option.\\n<!--  -->\\nIf you receive the error message ”This item could not be updated” when editing data in your account, the item may have been deleted. You will need to restore this item in order to update it.\\n\\n<!--\\n","section":"Updating items in the detail view","version":"current","path":"/kb/detail-view/updating-items-in-the-detail-view#deleting-and-restoring-items","category":"default"},{"title":"Merging items in the detail view","content":"Admin users have the ability to merge deals or contacts in Fintesk by default. If you do not see the option to merge an item, we would recommend reaching out to the admin user in your account to enable this permission.\\nIf you have permission to merge items in Fintesk, you can do so by clicking the ”...” button and selecting ”Merge” option from the dropdown menu.\\n\\nYou will be prompted to search for the item you would like to merge with. After selecting the item, you will have the option to select one set of values to preserve in the case of conflict.\\nYou can then preview your merged item to complete the process.\\n\\nIf you have multiple duplicate items in your account that you would like to merge, you learn about our merge duplicates feature. -->\\n","section":"Updating items in the detail view","version":"current","path":"/kb/detail-view/updating-items-in-the-detail-view#merging-items-in-the-detail-view","category":"default"},{"title":"Exporting from the detail view","content":"Note: Only deals can be exported from the detail view.\\nGo to a deal’s detail view and click on the “...” (more) icon > Export as XLS in the top right corner. The spreadsheet will include deal details and any linked person or organization data.\\n-->\\n\\n","section":"Exporting from the detail view","version":"current","path":"/kb/exporting-data/exporting-data-from-fintesk#exporting-from-the-detail-view","category":"default"},{"title":"Exporting from the list view","content":":::tip\\nNote: Only global admins and regular users with the correct permission set enabled can export from the list or detail views.\\n:::\\nYou can export custom reports on your deals, organizations, or other items in Fintesk from the list view. First, go to the list view of an item and filter for the specific data you want to export.\\nFor example, to export lost deals, select the filter “All lost deals“ to only pull up deals that fit the criteria.\\n<!--  -->\\n\\nOnce you have the filter, select the data fields you want to export by editing your list view columns. You can choose from deal, person and organization fields, mixing and matching data from all three to get your perfect combination.\\n<!--  -->\\n\\nThen click the three dots in the top right of the screen and select “Export filter results“.\\n<!--  -->\\n\\n\\n<!--\\n","section":"Exporting from the detail view","version":"current","path":"/kb/exporting-data/exporting-data-from-fintesk#exporting-from-the-list-view","category":"default"},{"title":"Exporting from “Export data”","content":"Note: Only full admin users (deals and global) have the ability to use the Export data option.\\nYou can also export your data by going to Tools and apps > Export data.\\n\\nSelect the type of data you want to export and click on either “**CSV“** or “**Excel**”. Your export file will appear in the “**Generated exports“** list. To download the file, click on the cloud icon in the “**Available until**“ column.\\n\\nNote: Activities, notes and files linked to deals and contacts must be exported separately.\\nNote: Files stored in Google Drive are not exported in global export, and the download URL of the file can only be used by admin users.\\n\\n","section":"Exporting from the detail view","version":"current","path":"/kb/exporting-data/exporting-data-from-fintesk#exporting-from-export-data","category":"default"},{"title":"Exporting from Insights","content":"There are two ways you can export data from your Insights tool.\\n","section":"Exporting from the detail view","version":"current","path":"/kb/exporting-data/exporting-data-from-fintesk#exporting-from-insights","category":"default"},{"title":"Exporting charts","content":"To export a report, goal, or dashboard, click the “Export” dropdown in the top right corner, and select one of the available file types:\\n\\nThis will give you a file containing the charts, title and any filters applied.\\n","section":"Exporting from the detail view","version":"current","path":"/kb/exporting-data/exporting-data-from-fintesk#exporting-charts","category":"default"},{"title":"Exporting to spreadsheets","content":"You can export the table view of your report as a spreadsheet by clicking the “Export” button above the table.\\n\\n\\n","section":"Exporting from the detail view","version":"current","path":"/kb/exporting-data/exporting-data-from-fintesk#exporting-to-spreadsheets","category":"default"},{"title":"Exporting from “Users and access”","content":"Note: Only users with \\"account settings access\\" can export the company user list from the “Users and access” tab.\\nYou can export users’ app access data by going to Manage users > Users and access.\\nThis data includes:\\nUser name\\nEmail\\nLast login time\\nPermission sets\\nVisibility groups\\n-->\\n","section":"Exporting from the detail view","version":"current","path":"/kb/exporting-data/exporting-data-from-fintesk#exporting-from-users-and-access","category":"default"},{"title":"Filtering","content":"In Fintesk, you can use filters to see specific data in your account. You can even mix different item fields within a filter to make full use of the connections and custom fields you’ve created in Fintesk.\\n<!--  -->\\n\\n","section":"Filtering","version":"current","path":"/kb/filtering/","category":"default"},{"title":"Creating a filter","content":"You can find the “+ Add new filter” button by clicking the filter drop-down in the top right corner of your:\\nDeals list view\\nContacts (person or organization) list view\\nActivities list view\\nProducts list view\\n<!--  -->\\n\\nWhen you add a new filter, you’ll see a window where you can click “Add condition” to select your filter criteria:\\n<!--  -->\\n\\nYou can also add a filter name or define the visibility for the filter set, then click “Save” when you’re done to display the filter results.\\n\\n","section":"Filtering","version":"current","path":"/kb/filtering#creating-a-filter","category":"default"},{"title":"Filter conditions","content":":::tip\\nNote: For more examples of how you can use the filter tool, check out this article.\\n:::\\nThere are two types of filter conditions you can add: ALL and ANY\\nEvery ALL condition must be met, or an item won’t be displayed in your filter results\\nAt least one ANY condition must be met, along with any ALL conditions\\nFor example, in this first filter, there are two competing conditions in the ALL section:\\n<!--  -->\\n\\nSince a person can’t have two owners, this will yield no filter results.\\n<!--  -->\\n\\nBut if you move those same conditions into the ANY section:\\n<!--  -->\\n\\nYour results will consist of persons owned by either of those users.\\n<!--  -->\\n\\n:::tip\\nNote: While the maximum number of filter conditions is 16, we recommend using up to nine conditions to maintain optimal loading speed.\\n:::\\n\\n","section":"Filtering","version":"current","path":"/kb/filtering#filter-conditions","category":"default"},{"title":"Clearing and deleting filters","content":":::tip\\nNote: “Everyone” refers to ownership, meaning items owned by every user will be visible.\\n:::\\nTo clear out any existing filters, click on the filters drop-down and switch to Owners > Everyone:\\n<!--  -->\\nTo delete a filter, click the pencil icon when hovering over a filter, then select the “Delete” option:\\n<!--  -->\\n\\n","section":"Filtering","version":"current","path":"/kb/filtering#clearing-and-deleting-filters","category":"default"},{"title":"See only won and lost deals","content":"\\n<!--  -->\\nTo see both won and lost deals, make sure to use ANY conditions, rather than ALL. Adding both conditions to the ALL section will yield zero results, since a deal cannot be won and lost at the same time.\\n\\n<!-- ## See deals created before this month\\n\\nThis filter will show you any deal created prior to the current month. This means the filter results will change as time passes, since \\"this month\\" is a relative time selection.\\n\\n","section":"Filters-> common uses","version":"current","path":"/kb/filtering/filters-common-uses#see-only-won-and-lost-deals","category":"default"},{"title":"See contacts with linked deals","content":"\\nThere are two important things to note about this filter:\\nThis filter is being run for organizations, however you can run an identical filter for persons as well\\nThis filter only applies to open deals, meaning additional conditions would be needed to see won, lost, or deleted deals\\n\\n","section":"Filters-> common uses","version":"current","path":"/kb/filtering/filters-common-uses#see-contacts-with-linked-deals","category":"default"},{"title":"Filter for rotten deals","content":"Knowing which deals are rotten can help you keep your pipelines productive. To filter for rotten deals, use these conditions:\\n-->\\n\\n<!-- ## Filter by a specific label\\n\\nOne vital thing to remember is that deals, and contacts all have their own dedicated labels. However, you can still filter for other labels, even if you are not in that item\'s list. For example:\\n\\nIn this case, the filter is for organizations with a deal containing the specified deal label. -->\\n\\n<!-- ## See contacts with open deals\\n\\nThis filter will show any organization in your database with at least one open deal linked to it. While the above filter doesn\'t show won and lost deals, they can be included as well:\\n\\n:::tip\\nNote: Selecting the ANY section means only one of the conditions must be met in order for the organization to be shown as a filter result.\\n::: -->\\n\\n","section":"Filters-> common uses","version":"current","path":"/kb/filtering/filters-common-uses#filter-for-rotten-deals","category":"default"},{"title":"See persons with an email address","content":"\\n<!--  -->\\nThis filter will show you any person in your account with a value added to the Email field.\\n<!-- If you would like to see persons with emails sent, you can use this filter:\\n\\n -->\\n","section":"Filters-> common uses","version":"current","path":"/kb/filtering/filters-common-uses#see-persons-with-an-email-address","category":"default"},{"title":"# {#}","content":"One-way sync – A sync connection that transfers data from one data source to another.\\nTwo-way sync – A sync connection that transfers data between two data sources.\\n2FA – An additional log-in requirement (aside from the username/password) designed to add an extra layer of account security.\\n\\n","section":"Fintesk glossary","version":"current","path":"/kb/getting-started/fintesk-glossary#undefined","category":"default"},{"title":"A","content":"Account - Companies with at least one won deal.\\n<!-- The first time an organization has a linked deal marked as won, an account will be created for that organization. -->\\nAccount settings – Refers to company billing, security, settings and user management. Access to these settings comes with an admin account, however, this access can also be removed via user management.\\nActivities – Represent any scheduled action on your part towards the closing (winning) of a deal. You can schedule them with your persons, organizations, or deals. (e.g., meeting, task, etc.)\\n\\nNotable activity fields include:\\n\\nLast activity date – This will show you the date of the last activity that was marked as done.\\nNext activity date – This will show you the date of the next activity you scheduled but that is not marked as done yet.\\nUpdate time – The date of the last update made on the item, it could be a new activity created, a field that was updated, basically any change.\\n\\n\\n\\n\\nAdmin user – A user who has full access to all of the tools, data and features within a given Fintesk account.\\n<!-- However, a user can be made an admin without account settings (via user management). -->\\nAPI – Abbreviation for \\"application programming interface.\\" API can connect other tools and services to your Fintesk account; however, it requires technical knowledge.\\nAPI token – Represents a unique identifier, permitting access to the API services.\\n<!-- - Attendee – One or more contact who have received and accepted invitations to a meeting (e.g., Scheduler attendees) -->\\nAutomation – uses a trigger and action to perform background tasks without the user having to implement them directly. (ex. Create a deal > add a label.)\\n\\n","section":"Fintesk glossary","version":"current","path":"/kb/getting-started/fintesk-glossary#a","category":"default"},{"title":"B","content":"<!-- :::info [Cooming soon]\\nBcc – Stands for Blind Carbon Copy. When you place email addresses in the Bcc field of a message, those addresses are invisible to the recipients of the email. Can be used to forward emails to other recipients without making the original recipient aware.\\n::: -->\\nBeta – Refers to a testing phase prior to public release, where a feature is released to a limited number of users for the purpose of seeing how the feature operates and assessing whether further adjustments are needed.\\nBilling – The section of an account where you can view current subscription information like cost and billing frequency, as well as previous invoices. You can also find information about how to close your account or purchase add-ons there.\\nBrowser console – Logs network requests, JavaScript, CSS, as well as security errors, warnings and messages explicitly logged by JavaScript code. May be requested by support agents when diagnosing slowness or error messages.\\nB2B – Stands for “Business-to-business” and refers to transactions or business conducted between companies, rather than between a company and an individual consumer.\\n\\n","section":"Fintesk glossary","version":"current","path":"/kb/getting-started/fintesk-glossary#b","category":"default"},{"title":"C","content":"Call (activity) – An activity type used as a placeholder for a scheduled call.\\n\\n\\nClosed – An account’s status after the cancellation process has been completed and the remaining time on the most recently paid invoice passed.\\n\\n\\nCloud storage – When data is stored digitally via a second-party online storage provider (e.g., Google Drive).\\n\\n\\nCompany account — the company account is the collective of users, where billing is charged. (e.g., Fabrizzio is a user in the Fintesk company)\\n\\n\\nContact – Refers to a person or organization in Fintesk.\\n\\n\\nCRM – stands for “Customer Relationship Management”.\\n\\n\\nCustom Field – A field created in Fintesk outside of preexisting default/system fields, which can be used for adding and tracking data. There are a variety of custom field types that can be used.\\n<!-- , and if you’re on a Professional or Enterprise plan, these custom fields can be used for reporting. -->\\n\\n","section":"Fintesk glossary","version":"current","path":"/kb/getting-started/fintesk-glossary#c","category":"default"},{"title":"D","content":"Data field – Refers to both default/system fields and custom fields in Fintesk. In most cases, you can refer to data fields as just “fields”.\\nData migration – the movement of data into a new database without a continual sync (i.e. spreadsheet imports.)\\nDeal - In Fintesk, the ongoing transaction you are pursuing with a person or organization is tracked as a deal, which is processed through the stages of your pipeline until it is either WON or LOST.\\nDefault field – Default fields are built into your Fintesk account when you create it and they are typically used for basic customer information like Name, email, or Phone number.\\nDirect cost – Within the scope of the Products feature, direct cost refers to the price of developing or producing the registered product in question.\\nDone – Means that an activity has been completed. It\'s one of two possible statuses for an activity, the other being \\"to-do.\\"\\n\\n","section":"Fintesk glossary","version":"current","path":"/kb/getting-started/fintesk-glossary#d","category":"default"},{"title":"E","content":"Export – Copying data out of your Fintesk account (either into a spreadsheet or into another program like Mailchimp).\\n\\n","section":"Fintesk glossary","version":"current","path":"/kb/getting-started/fintesk-glossary#e","category":"default"},{"title":"F","content":"Field – See \\"Data field\\"\\nFile Format – Specific file format, based on file extension. For example, CSV, GIF, ZIP.\\nFile type – Purpose of the file, which is usually a group of various file formats (i.e. images, audio, database.)\\nFuture – Used to categorize activities that have their set dates at any time in the future.\\n\\n<!-- ### G -->\\n<!-- :::info [Cooming soon]\\nGroup email – An email message that is being sent to multiple email addresses at the same time. Fintesk will apply a small delay between each message in order to prevent errors and to prevent abuse scenarios.\\n::: -->\\n<!-- - Guest – see \\"Attendee\\". -->\\n\\n<!-- ### H -->\\n<!-- - HAR file – The HTTP Archive format, or HAR, is a file that tracks all interactions between a web browser and a website. -->\\n\\n","section":"Fintesk glossary","version":"current","path":"/kb/getting-started/fintesk-glossary#f","category":"default"},{"title":"I","content":"<!-- :::info [Cooming soon]\\nImportant fields – Important fields are given additional attention and brought into focus for the user. By definition, important fields are intended to be filled as a higher priority but are not required unless specified. Both default and custom fields can be marked as important.\\n::: -->\\n\\n\\nInvalid – Used to indicate a file or another item is somehow broken or incorrect. For example, a password may be invalid, an uploaded file may be unusable because it’s invalid (corrupted), etc.\\n\\n\\nInvite – In reference to users, an email sent to a prospective user\'s email address, offering them a seat to occupy in a Fintesk account.\\n\\n","section":"Fintesk glossary","version":"current","path":"/kb/getting-started/fintesk-glossary#i","category":"default"},{"title":"K","content":"Knowledge Base – The place where we keep all our help articles, belongs under the Help Center umbrella.\\n\\n","section":"Fintesk glossary","version":"current","path":"/kb/getting-started/fintesk-glossary#k","category":"default"},{"title":"L","content":":::info [Cooming soon]\\nLabel – Predefined and customizable tags that can be attached to various Fintesk items either manually or automatically. Labels allow for quick visual and textual recognition of item status or type and also allow for better sorting.\\n:::\\nLimit – There is a limited number of (countable) items you can have at once. But the limit just looks at the current count of something, so, deleting items will give you more room until the limit (i.e., usage limits)\\n\\n","section":"Fintesk glossary","version":"current","path":"/kb/getting-started/fintesk-glossary#l","category":"default"},{"title":"M","content":"Meeting – An activity type that the user can schedule by using the activities feature. The meeting is intended to represent an actual, physical meeting between the user and their client.\\n\\n","section":"Fintesk glossary","version":"current","path":"/kb/getting-started/fintesk-glossary#m","category":"default"},{"title":"N","content":"Notes – Text added to a detail view, which is presented toward the top for visibility purposes.\\n<!-- - Notes cannot be added via automation -->\\n<!-- , however, they can be added in bulk via import. -->\\n\\n","section":"Fintesk glossary","version":"current","path":"/kb/getting-started/fintesk-glossary#n","category":"default"},{"title":"O","content":"Organization – A contact that represents a real-life organization, business or otherwise. Can be used to link multiple person together under one shared organization (see linking person and organizations).\\nOverdue – Used for activities that have their completion date set for any time in the past and which have not been marked as done yet.\\n<!-- Deals with overdue activities will be sorted toward the top of the pipeline view (more information in this article). -->\\n\\n","section":"Fintesk glossary","version":"current","path":"/kb/getting-started/fintesk-glossary#o","category":"default"},{"title":"P","content":"<!-- - Permitted – When an email address falls within a list of approved IP addresses from which emails may be received through a provider (also called a whitelist). Email addresses can be permitted manually if emails being sent to or from you are being bounced due to security protocols. -->\\nPerson – within the Fintesk vocabulary references a contact person, which is a registered set of data that represents a human contact.\\n\\n\\nPlan – refers to your subscription level. Our available plans are: Essential, Advanced and Professional.\\n\\n\\nPrice variation – When toggled to active, price variation allows the addition of multiple price points for a registered product in the database. This is useful when operating with multiple currencies for the same product or variable price points that fall outside of units.\\n\\n\\nProduct code – Refers to the optional, user-specified code, given to any product registered using the Products feature. It is used for sorting and database purposes but is not assigned automatically when a new product is created (different to our system ID).\\n\\n<!--\\n","section":"Fintesk glossary","version":"current","path":"/kb/getting-started/fintesk-glossary#p","category":"default"},{"title":"Q","content":"Quick help – Panel that opens in the app when the user clicks on the question mark in the upper right corner. -->\\n\\n","section":"Fintesk glossary","version":"current","path":"/kb/getting-started/fintesk-glossary#q","category":"default"},{"title":"R","content":"<!-- - Recurring payment – Refers to any payment that is intended to be repeated over the course of a schedule (usually based on a monthly or annual schedule). -->\\nRelated organizations - when two or more organizations are linked to one another\\n<!-- - Required field – A defined field attribute that marks either default or custom fields as required, meaning the field is not optional and must be given a value in order to store Fintesk objects. -->\\n\\n","section":"Fintesk glossary","version":"current","path":"/kb/getting-started/fintesk-glossary#r","category":"default"},{"title":"S","content":"SaaS – abbreviation for \\"software as a service\\".\\nScheduled – This word is used within the context of activities for any activity that has been assigned a completion date and time.\\n<!-- - May also be used for emails or campaigns. -->\\n<!-- - Single sign-on (SSO) – An account with SSO enabled means you only have to create one set of logins for your users. -->\\n\\n","section":"Fintesk glossary","version":"current","path":"/kb/getting-started/fintesk-glossary#s","category":"default"},{"title":"T","content":"To-do – One of two possible statuses for an activity (the other being \\"Done.\\") This status means the activity has not yet been completed.\\n<!-- - Two-factor authentication – see \\"2FA\\" -->\\n\\n","section":"Fintesk glossary","version":"current","path":"/kb/getting-started/fintesk-glossary#t","category":"default"},{"title":"U","content":"Unit – Within the scope of the Products feature, “unit“ refers to the default unit of a registered product. Unit can be anything from the amount of items, dimensions of items, etc. The defined unit and unit price in combination form the basis of the value calculation when adding products to deals (i.e., 1 unit at $5 each, which means adding one unit of the product to a deal gives the deal a value of $5).\\nUnit price – Within the scope of the Products feature, the unit price refers to the exact price of each sold unit.\\nUsage limits — limits on the number of open deals, custom fields a user may create. Limits are based on your existing plan, and you can find more information about that here.\\nUser account — A user account is where an individual user logs in and performs tasks (e.g., Pedro is a user in the Pascal company)\\n\\n","section":"Fintesk glossary","version":"current","path":"/kb/getting-started/fintesk-glossary#u","category":"default"},{"title":"Z","content":":::info [Cooming soon]\\n<!-- - Zapier – One of the many services we offer integrations with, Zapier can be used to automate processes and actions between Fintesk and other services or tools. -->\\nZapier – One of the many services we offer integrations with, Zapier can be used to automate processes and actions between Fintesk and other services or tools.\\n:::\\n","section":"Fintesk glossary","version":"current","path":"/kb/getting-started/fintesk-glossary#z","category":"default"},{"title":"Fintesk user vs. company account","content":"<p>&lt;!-- ../../kb/getting-started/fintesk-user-vs-company-account.md --&gt;</p>\\n<p>&lt;!-- ## Fintesk user vs. company account --&gt;</p>\\n<p>When a Fintesk account is created, both a user account and a company account are created.</p>\\n<p>The user account is a specific user – e.g., Bombo Fica – who accesses Fintesk using their login credentials.</p>\\n<p>The company account – e.g., Cocoleruz. – is the database of information that the users access within Fintesk, and can contain many different users.</p>\\n","section":"Fintesk user vs. company account","version":"current","path":"/kb/getting-started/fintesk-user-vs-company-account","category":"default"},{"title":"How can I delete items in Fintesk?","content":"<p>&lt;!-- ../../kb/getting-started/how-can-i-delete-items-in-fintesk.md --&gt;</p>\\n<p>&lt;!-- # Deleting items in Fintesk --&gt;</p>\\n<p>Depending on the situation, you may need to delete items in Fintesk in many different ways. We\'ve built several different means to delete items in Fintesk and to help address any situation.</p>\\n<p>To delete from the <strong>detail view</strong> of an item in Fintesk:</p>\\n<ul>\\n<li>Click on the name of the deal, person, or organization to go to that item\'s <strong>detail view</strong>.</li>\\n<li>Click on the &quot;<strong>...</strong>&quot; found to the upper right of the Fintesk app.</li>\\n<li>Select the &quot;<strong>Delete&quot;</strong> option found there.</li>\\n<li>In the prompt that appears, confirm that you wish to delete this item.</li>\\n</ul>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202022-09-27%20at%2015.01.17.png\\" alt=\\"1\\"> --&gt;</p>\\n<p><img src=\\"../../kb/getting-started/how-can-i-delete-items-in-fintesk/hii01.jpeg\\" alt=\\"hii01\\"></p>\\n<p>To delete a deal from the <strong>pipeline view</strong> of your deals tab:</p>\\n<ul>\\n<li>Go to your deals tab and click on the <strong>pipeline view</strong>.</li>\\n<li>Click on the deal you wish to delete and drag it to the bottom of your screen in the Fintesk app.</li>\\n<li>When hovering over the <strong>DELETE</strong> button, release your mouse click.</li>\\n</ul>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/delete%20deals%20in%20pipeline.gif\\" alt=\\"1\\"> --&gt;</p>\\n<p><img src=\\"../../kb/getting-started/how-can-i-delete-items-in-fintesk/hii02.gif\\" alt=\\"hii02\\"></p>\\n<p>&lt;!--\\nTo delete a selection of items from the <strong>list view</strong>:</p>\\n<ul>\\n<li>Go to the Fintesk tab of the item(s) you wish to delete – such as deals, activities, persons, or organizations.</li>\\n<li>Using the checkboxes on the left side of the Fintesk app, select the items you wish to delete.</li>\\n<li>Click on the <strong>trash can</strong> icon that appears above the list view.</li>\\n<li>In the prompt that appears, confirm that you wish to delete those items.</li>\\n</ul>\\n<p><img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202022-09-27%20at%2015.04.11.png\\" alt=\\"1\\"></p>\\n<p>:::tip\\n<strong>Note:</strong> Deleting an item in Fintesk will delete other items linked to it (e.g., if a deal is deleted, activities linked to that deal will be deleted). Admins can restore deleted items within 30 days after deletion, the linked items will be restored as well. After 30 days the items are permanently deleted and cannot be accessed or restored.\\n::: --&gt;</p>\\n<p>&lt;!-- # Deleting items in Fintesk</p>\\n<p>:::tip\\n<strong>Note:</strong> This action is only available to users with the correct permissions enabled.\\n:::</p>\\n<p>Maintaining an effective Fintesk database can sometimes mean cleaning out data. However, we recognize that not every user should have the ability to delete potentially valuable information from your account.</p>\\n<p>To allow you to keep your data secure, the ability to delete in Fintesk is an option that can be enabled for certain user groups in <a href=\\"../../kb/users-and-permissions/permission-sets\\">permission sets</a>.</p>\\n<p>As a user with account settings, if you would like to adjust permissions regarding the deletion of deals or activities for certain users in your Fintesk account, you can do so by going to <strong>Settings &gt; Manage users &gt; <a href=\\"https://app.fintesk.com/settings/company_settings#permissions\\">Permission sets</a></strong> and adjusting those options to your preference.</p>\\n<p><img src=\\"https://kb-cms.pipedriveassets.com/Markup%20on%202022-09-27%20at%2014%3A55%3A47.png\\" alt=\\"1\\"></p>\\n<p>:::tip\\n<strong>Note:</strong> If you do not see an option to be able to delete a person or organization, you don\'t have admin settings. If you do not see the option to delete a deal or activity, then your admin user has not enabled this permission.\\n::: --&gt;</p>\\n<p>&lt;!-- --- --&gt;</p>\\n","section":"How can I delete items in Fintesk?","version":"current","path":"/kb/getting-started/how-can-i-delete-items-in-fintesk","category":"default"},{"title":"Deals","content":"\\n<!--  -->\\n\\nOngoing transactions you’re pursuing with persons or organizations in Fintesk are tracked as deals, which are processed through the stages of your pipeline until they’re either won or lost.\\nDeals contain all of the actions taken while closing a sale. Deals will also pull all the information from the person or organization they’re associated with, which you can find in the detail view of that deal. In this article, you can read more about deals in Fintesk.\\nDeals can be linked to a person and organizations. They can also have products added to them.\\nDeals track all events and movements that take place throughout your sales process.\\nSince a deal is connected to a contact, any actions you perform on the deal will also be reflected in the person/organization linked to it.\\nDeals can be imported from a CSV or XLS file.\\n<!-- - Deals can be imported from a previous CRM or a CSV or XLS file. -->\\n<!-- - The progress of the deals in your account is tracked as progress in your account. -->\\n\\n","section":"How is Fintesk data organized?","version":"current","path":"#deals","category":"default"},{"title":"Persons (contacts)","content":"<!--  -->\\n\\nPersons contacts are the specific customers you’re selling to, and any information relating to each contact such as scheduled activities or emails will be tracked in the detail view of that person.\\nPersons contacts can be linked to one organization.\\nThey can have multiple deals open for them at the same time.\\n<!-- - They can be synced with your contact provider or imported from a CSV or XLS file. -->\\nThey can be imported from a CSV or XLS file.\\n<!-- imported from a previous CRM, -->\\n\\n","section":"How is Fintesk data organized?","version":"current","path":"#persons-contacts","category":"default"},{"title":"Organizations (contacts)","content":"<!--  -->\\n\\nOrganizations are the companies where contacts work. All persons related to an organization will be listed in its detail view, along with any notes or activities linked to any person, deals related to the organization.\\nOrganizations contain information like a mailing address or industry information.\\nYou can link multiple persons, deals to your organizations.\\n<!-- - Organizations can be synced with your contact provider, imported from a previous CRM, or imported from a CSV or XLS file. -->\\nOrganizations can be imported from a CSV or XLS file.\\n\\n","section":"How is Fintesk data organized?","version":"current","path":"#organizations-contacts","category":"default"},{"title":"Activities","content":"<!--  -->\\n\\nAn activity represents any action taken toward closing a sale. It can be a phone call, a lunch meeting, or any other event you schedule with a contact. You can schedule activities in relation to a person, organization, or deal. You can read this article for more information on activities in Fintesk.\\nActivities can be linked to a person, organization, o deal.\\nAssociating an activity with a deal will also associate the activity with the linked person and/or organization.\\n<!-- - Activities can be imported from a previous CRM or a CSV or XLS file. -->\\nActivities can be imported from a CSV or XLS file.\\n","section":"How is Fintesk data organized?","version":"current","path":"#activities","category":"default"},{"title":"Products","content":":::info\\nNote: For more information about price variations, check out this article\\n:::\\n<!--  -->\\n\\nProducts are items or services you sell or trade, and are often linked to ongoing deals. Products have specific fields like product code, price and tax.\\n\\n","section":"How is Fintesk data organized?","version":"current","path":"#products","category":"default"},{"title":"Data relationships","content":"Here’s a basic rundown of how the different data types relate.\\n<table>\\n<tr>\\n<td>Contacts</td>\\n<td>negocios/actividades</td>\\n<td>Contacts are those you conduct deals and schedule activities with, as well as send emails to. They can be represented as individual contact (i.e Bombo Fica) or collective organizations (i.e The Not Co)</td>\\n</tr>\\n<tr>\\n<td>Activities</td>\\n<td>negocios/contactos</td>\\n<td>Activities can be linked to a lead, deal, or contact, but it’s not required as they can also be created without being linked to other data.</td>\\n</tr>\\n</table>\\n|\\n:::info\\nNote: Learn more about Fintesk terms and relationships in our glossary.\\n:::\\n","section":"How is Fintesk data organized?","version":"current","path":"#data-relationships","category":"default"},{"title":"Navigating Fintesk","content":"Pressing the number keys associated with each tab in the primary navigation will bring you right to that specific portion of Fintesk.\\n<!-- Hover over the tab in the primary navigation sidebar to see what number you should press to be taken straight to that page. -->\\n<!--  -->\\n\\n\\n","section":"Fintesk interface","version":"current","path":"/kb/getting-started/interface-in-fintesk#navigating-fintesk","category":"default"},{"title":"Keyboard shortcuts","content":"You can use shortcuts to perform quick actions in Fintesk.\\n","section":"Fintesk interface","version":"current","path":"/kb/getting-started/interface-in-fintesk#keyboard-shortcuts","category":"default"},{"title":"General shortcuts","content":"<!-- | Action                                              | Shortcut |\\n| :------------------------------------------------------ | :----------- |\\n| Go to primary navigation item                           | 1 to 8   |\\n| Go to last primary menu item (“More” overflow menu) | 9          |\\n| Search Fintesk                                          | /          |\\n| Toggle secondary navigation                             | [ or ]   |\\n| Open quick add menu                                     | . or +   | -->\\nAction\\nShortcut\\n\\n\\n\\n\\nOpen quick add menu\\n.\\n","section":"Fintesk interface","version":"current","path":"/kb/getting-started/interface-in-fintesk#general-shortcuts","category":"default"},{"title":"Add items shortcuts","content":"To add a new item, you can click on the + sign at the top of the page, or else click your full stop button on your keyboard (.).\\n<!-- or plus sign (+). -->\\n<!--  -->\\n\\nEvery item in Fintesk has its own shortcut. Pressing the keys associated in the Quick menu section will immediately open the Add new dialog for the intended item, which is useful for a large number of tasks, such as quickly adding a note to a contact that calls you unexpectedly.\\nItem\\nShortcut\\n\\n\\n\\n\\nDeal\\nD\\n\\n\\nActivity\\nA\\n\\n\\nPerson\\nP\\n\\n\\nOrganization\\nO\\n\\n\\nProduct\\nR\\n<!-- | Note         | N          | -->\\n\\n<!--\\n","section":"Fintesk interface","version":"current","path":"/kb/getting-started/interface-in-fintesk#add-items-shortcuts","category":"default"},{"title":"Customizing Fintesk","content":"To customize your Fintesk interface, go to Personal preferences > Interface preferences.\\n\\nHere you’ll be able to:\\nChange the appearance and select between light or dark mode for your Fintesk interface\\nEnable and disable the keyboard shortcuts\\nSet a default landing page\\nChoose up to ten icons to appear on the left navigation bar\\n\\n:::tip\\n[Note:] Customization settings are user-specific and not shared across the company.\\n::: -->\\n","section":"Fintesk interface","version":"current","path":"/kb/getting-started/interface-in-fintesk#customizing-fintesk","category":"default"},{"title":"Organization vs. company account","content":"<p>&lt;!-- ../../kb/getting-started/organization-vs-company-account.md --&gt;</p>\\n<p>&lt;!-- # Organization vs. company account --&gt;</p>\\n<p>When a Fintesk account is created, both a user account and a company account are created.</p>\\n<p>That company account is <strong>your</strong> company, and you can invite your work colleagues to join you as <a href=\\"../../kb/users-and-permissions/users\\">users</a> to access the same database.</p>\\n<p>However, you do not have to create a brand new company account in order to use Fintesk. If you know someone who already has an account, they can invite you to join their company.</p>\\n<p>&lt;!-- If you are invited, the access you have to data and account privileges will be decided by the company owner or other users with <strong><a href=\\"../../kb/users-and-permissions/global-user-management\\">User Management</a></strong> access. --&gt;</p>\\n<p>If you are invited, the access you have to data and account privileges will be decided by the company owner or other users.</p>\\n<p>:::tip\\n<strong>Note</strong>: If you do not have access to <strong>User Management</strong>, or do not know what user type you are, please contact your account admin.\\n:::</p>\\n","section":"Organization vs. company account","version":"current","path":"/kb/getting-started/organization-vs-company-account","category":"default"},{"title":"Searching directly by item","content":"Type an entry into the search bar to see a dropdown of all items relevant to your search entry. You can filter by item type to narrow your search results.\\n<!--  -->\\n\\nYou can search for your Fintesk data by the following data fields:\\nDeals\\nNames, notes, custom fields\\nPersons\\nName, phone number, email address, notes and custom fields\\nOrganizations\\nName, address, notes and custom fields\\nActivities\\nName, notes, description\\nProducts\\nName, code and custom fields\\n<!-- - **Files and attachments\\n**Name -->\\n:::tip\\n[Note:] Regular users can only search for their own activities, while admin users can search for all user´s activities.\\n:::\\n\\n","section":"Finding what you need","version":"current","path":"/kb/getting-started/search-finding-what-you-need#searching-directly-by-item","category":"default"},{"title":"Searching by linked items","content":"The search will also bring up any items linked to what you searched for.\\nFor example, if your search matches a deal, you\'ll also see any persons and organizations linked to it.\\n<!--\\n -->\\n\\nIf your search matches a person, you’ll see any deals linked to that item.\\n<!-- :::tip\\nNote: Users without a projects seat enabled can\'t search by projects or see the Projects category in the search options.\\n::: -->\\n\\n","section":"Finding what you need","version":"current","path":"/kb/getting-started/search-finding-what-you-need#searching-by-linked-items","category":"default"},{"title":"Searching by custom fields","content":"You can search by values under text, large text, numerical, monetary, autocomplete, phone and address type custom fields.\\nWhen searching for the custom field value, the relevant item will appear in the search results.\\n<!--  -->\\n\\n\\n<!--\\n","section":"Finding what you need","version":"current","path":"/kb/getting-started/search-finding-what-you-need#searching-by-custom-fields","category":"default"},{"title":"Searching by notes","content":"Keywords from your notes can be searched for if you\'ve written them under deals, contacts, leads or activities.\\nWhen searching for notes, the relevant item will appear in the search results.\\n-->\\n\\n","section":"Finding what you need","version":"current","path":"/kb/getting-started/search-finding-what-you-need#searching-by-notes","category":"default"},{"title":"Finding more information","content":"Most search results have secondary links under them.\\nHovering your mouse over a result shows another window with more information. Clicking an item (deal, person, or organization) takes you to the detail view of that specific item.\\nFor example: If there is a deal that is connected to a person and organization, you can see more information about the linked contacts by hovering your mouse over them.\\n<!--  -->\\n\\n\\n<!--\\n","section":"Finding what you need","version":"current","path":"/kb/getting-started/search-finding-what-you-need#finding-more-information","category":"default"},{"title":"Recent items in search","content":"Before you type in the search box, you can see your recently searched keywords and viewed items.\\n\\nRecent keywords are the keywords that you typed in the search bar.\\nRecently viewed items are items that you’ve just created, viewed or edited. -->\\n","section":"Finding what you need","version":"current","path":"/kb/getting-started/search-finding-what-you-need#recent-items-in-search","category":"default"},{"title":"What is the difference between a user and a seat?","content":"<p>&lt;!-- ../../kb/getting-started/what-is-the-difference-between-a-user-and-a-seat.md --&gt;</p>\\n<p>&lt;!-- ## What is the difference between a user and a seat? --&gt;</p>\\n<p>In Fintesk, your subscription is calculated by the number of <strong>seats</strong> you have in your account. An active (or invited) <strong>user</strong> will always take up one seat once they have been added to Fintesk, but it is possible to have empty seats if users have been deactivated or not added yet.</p>\\n<p>We separate users and seats in Fintesk to make it easier to deactivate and replace users without creating any immediate changes in your subscription.</p>\\n<ul>\\n<li><strong>Seat –</strong> The number of possible active users in your account. You will be billed by the number of seats you have. Extra seats can be removed by going to your <strong><a href=\\"https://app.fintesk.com/settings/company_settings#subscription\\">Billing tab</a></strong>.</li>\\n<li><strong>User –</strong> The users you have added to your Fintesk account. You can have fewer active users than seats, but you will still be charged by the number of seats in your account. You can manage your users by going to <strong>Company &gt; <a href=\\"https://app.fintesk.com/settings/company/manage-users?utm_source=fintesk-docs\\">Manage users</a></strong>.</li>\\n</ul>\\n<p>We recommend filling in any free seats with users or removing unused seats you are not planning to fill so you don\'t end up paying for more than you use.</p>\\n<p>:::tip\\n[<strong>Note:</strong>] All the seats added to your account will be on the plan that is already being billed.\\n:::</p>\\n<p><strong>What happens to my billing when I deactivate a user?</strong></p>\\n<p>When you <a href=\\"../../kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user\\">deactivate</a> a user in your company account, you will be given the option to keep or remove the seat.</p>\\n<p>If you keep the seat, you can easily replace the deactivated user with a new user without any updates to your billing. If you choose to remove the seat, the changes will take effect in your subscription at the beginning of the next billing cycle.</p>\\n<p>Learn more about what happens to a user when it is deactivated in <a href=\\"../../kb/users-and-permissions/what-happens-when-a-user-gets-deactivated\\">this article</a>.</p>\\n","section":"What is the difference between a user and a seat?","version":"current","path":"/kb/getting-started/what-is-the-difference-between-a-user-and-a-seat","category":"default"},{"title":"Getting started","content":"Before any exporting, make sure the new custom field with the correct type has been created in your account, so the old custom field information has somewhere to move to.\\nTo create a custom field, go to Settings > Custom fields and select the category of custom field you wish to add to Fintesk.\\n:::tip\\nNote: While you are in the Custom fields settings page, it may be a good idea to edit the name of the existing custom field to include the word “old” to avoid any confusion during the updating process.\\n:::\\n\\n","section":"Changing the field type of a custom field","version":"current","path":"/kb/importing-data/changing-the-field-type-of-a-custom-field#getting-started","category":"default"},{"title":"Exporting your data","content":"To get started with your export, you can go to the deals, persons, or organization list view the custom field is under. You will need to include the following columns in your list view:\\nName\\nOld custom field\\nNew custom field\\nItem ID (deal, person or organization)\\n:::tip\\nNote: In the screenshots below, the values under the “Example text custom field” under deals will be moved over to the newly created “Example single option custom field” under deals.\\n:::\\n<!--  -->\\n\\nOnce you have these four columns applied in your list view, you can then export the list to a spreadsheet.\\nIn the exported spreadsheet, you will then have to copy and paste all of the values under the old custom field into the cells under the new custom field. This will allow the new custom field to be “updated” with the information from the old custom field when you re-import your spreadsheet.\\n<!--  -->\\n\\n\\n","section":"Changing the field type of a custom field","version":"current","path":"/kb/importing-data/changing-the-field-type-of-a-custom-field#exporting-your-data","category":"default"},{"title":"Importing your updated data","content":"Once you save the updated spreadsheet, you can then import the spreadsheet back into Fintesk by clicking the \\"...\\" in the bottom left of your screen, then selecting Import data > From a spreadsheet. You can learn more about importing here.\\nWhen you get to the mapping step of your import, it’s important to make sure all of the columns in your spreadsheet are mapped to the correct field in your Fintesk account.\\n<!--  -->\\n\\nOnce everything is mapped, you can hit the \\"Next\\" button to proceed with your import.\\n<!--  -->\\n\\nOnce you confirm the information has successfully been transferred over from the old custom field to the new custom field, you can delete the old one.\\n","section":"Changing the field type of a custom field","version":"current","path":"/kb/importing-data/changing-the-field-type-of-a-custom-field#importing-your-updated-data","category":"default"},{"title":"Mapping in Fintesk","content":"Once you import your spreadsheet, if Fintesk can identify the format of your dates without any confusion, no action is needed. If Fintesk can\'t identify the format of your dates, it will prompt you to specify your spreadsheet\'s formatting.\\n<!--  -->\\n\\n<!--  -->\\n\\n\\n","section":"How can I format dates to import into Fintesk?","version":"current","path":"/kb/importing-data/how-can-i-format-dates-to-import-into-fintesk#mapping-in-fintesk","category":"default"},{"title":"How to format your columns in excel","content":"Spreadsheets can have their cells formatted for special types of data. Often, you may receive a spreadsheet that\'s already formatted, or you may have to format your own data. Here\'s how to edit the format of your columns in Excel:\\nRight-click the head of your column > Format Cells > Choose your desired format.\\n<!--  -->\\n\\n","section":"How can I format dates to import into Fintesk?","version":"current","path":"/kb/importing-data/how-can-i-format-dates-to-import-into-fintesk#how-to-format-your-columns-in-excel","category":"default"},{"title":"Starting your import","content":":::tip\\nNote: If you don‘t have a spreadsheet to work from, we provide sample spreadsheets that you can access on this page.\\n:::\\nTo initiate a spreadsheet import, go to Tools and apps > Import data > From a spreadsheet.\\n<!--  -->\\n\\n\\n","section":"Import fields","version":"current","path":"/kb/importing-data/import-fields#starting-your-import","category":"default"},{"title":"How fields are organized","content":"In the import window, there are seven data categories that represent your available field types.\\nPerson\\nOrganization\\nDeal\\nActivity\\nNote\\nProduct\\n<!--  -->\\n\\nIn each field type category, the fields are listed alphabetically (including custom fields.)\\n<!--  -->\\n\\n\\n","section":"Import fields","version":"current","path":"/kb/importing-data/import-fields#how-fields-are-organized","category":"default"},{"title":"Default fields","content":"<!-- :::tip\\nNote: Project data can‘t be imported currently.\\n::: -->\\nFor deals, persons, organizations and products, the available default fields for import can be found in the data fields section of your settings under each category.\\n<!--  -->\\n\\n","section":"Import fields","version":"current","path":"/kb/importing-data/import-fields#default-fields","category":"default"},{"title":"Activities","content":"Activities don‘t appear in the data fields section of your account, but you can see the available import fields in the import mapping screen.\\n<!--  -->\\n\\n<!-- Note fields can also be found in the import mapping screen.\\n-->\\n\\n","section":"Import fields","version":"current","path":"/kb/importing-data/import-fields#activities","category":"default"},{"title":"Custom fields","content":":::tip\\nNote: Activities and notes don’t have custom fields available. For more information about custom fields, check out this article.\\n:::\\nIn addition to default fields, custom fields can be mapped when importing data into your Fintesk account.\\n<!--  -->\\n\\n","section":"Import fields","version":"current","path":"/kb/importing-data/import-fields#custom-fields","category":"default"},{"title":"Mapping multiple option fields","content":":::tip\\nNote: To map a multiple option field, you will first need to make sure the multiple option type custom field is already created in your Fintesk account. You can learn more about custom fields in this article.\\n:::\\nIn order to import a multiple option field, there is an extra step for you to map. When you have mapped the field itself (\\"Group Number\\" in the example below), click on it to expand and see the individual mapping of each field option from your spreadsheet.\\n<!--  -->\\nCheck to see if the options from your spreadsheet have been mapped correctly to the custom field options in Fintesk. If they weren\'t mapped correctly, click and drag the correct options to their corresponding options from the spreadsheet.\\n\\n<!-- ## Mapping addresses\\nThere are two possible ways to include addresses in your spreadsheet when importing an organization\'s address field or an address type custom field. -->\\n<!--\\nAddress fields in separate columns\\nWhen creating your spreadsheet, you can add your address with the different address fields separated into different columns.\\n\\nThen, when mapping your fields, you can select the individual address fields from Fintesk and match them with the fields in your spreadsheet.\\n-->\\n<!--\\nAddress in one field\\nAlternatively, you can add your address to one field, separating your items with a comma.\\n\\nIn this case, you can map the general address field to your spreadsheet column.\\n-->\\n<!-- Fintesk will attempt to geolocate your addresses using Google\'s Geolocation API. Please be aware that not all addresses will definitely be geolocated. You can learn more about how Google addresses should be formatted here. When addresses are geolocated in Fintesk, they will appear in our Show on Map feature. -->\\n\\n","section":"Importing-> advanced mapping","version":"current","path":"/kb/importing-data/importing-advanced-mapping#mapping-multiple-option-fields","category":"default"},{"title":"Mapping phone numbers","content":"When importing your contact\'s phone number, you have the option to select the phone label you want to map to Fintesk. If you have multiple phone numbers for a contact, you can map the phone field multiple times.\\nFor example, if you would like to import contacts with a personal mobile phone number as well as a work phone, you can do so by adding the numbers in separate columns.\\n<!--  -->\\nWhen mapping, you can click and drag the phone field multiple times. Once it has been mapped, click on the pencil icon to assign a label to that phone number type.\\n<!--  -->\\nYou can choose to label your phone numbers as Work, Home, Mobile, or Other.\\n","section":"Importing-> advanced mapping","version":"current","path":"/kb/importing-data/importing-advanced-mapping#mapping-phone-numbers","category":"default"},{"title":"Getting ready for an import","content":"Before you import, consider the data you’re adding to Fintesk and format your spreadsheet accordingly.\\nAre you trying to import a list of contacts (persons and organizations?)\\nDo you want to import contacts and create an open deal for each one?\\nDo you want to import contacts, open deals, and create activities for those deals?\\nDo you want to import contacts, open deals with activities, and attach notes?\\nOr open new deals for contacts that already exist in Fintesk?\\nSome spreadsheet formatting tips:\\nRemove formulas – Use a fresh spreadsheet without any formulas. If you have a spreadsheet that uses formulas or data-linking to generate the contents of a cell, copy the data from your spreadsheet into a fresh sheet without the formulas.\\nOne tab per spreadsheet – Your spreadsheet should only have one tab containing data. If your spreadsheet has more than one tab, copy and paste the tabs into individual files and import them one at a time.\\nNo special symbols – Your spreadsheet can’t have symbols for numeric or monetary fields. For example, a column for deal value should just include the number “100” and not the symbol “$100”.\\nSpreadsheet size limit – There is no maximum limit on the number of spreadsheet columns, but the maximum file size is 50MB, with a limit of 50,000 rows per spreadsheet.\\n\\n","section":"Importing data into Fintesk with spreadsheets","version":"current","path":"/kb/importing-data/importing-data-into-fintesk-with-spreadsheets#getting-ready-for-an-import","category":"default"},{"title":"Mandatory fields","content":"When importing data to Fintesk from a spreadsheet, include the mandatory fields for each item. Each mandatory field needs a separate column in your spreadsheet mapped to the corresponding field in Fintesk.\\n:::tip\\nNote: If you don’t import your data with the mandatory fields, it will create no items, and a skip file will be generated.\\n:::\\n<table>\\n<tbody>\\n<tr>\\n<td>\\nTo import\\n</td>\\n<td>\\nYou need these mandatory fields\\n</td>\\n</tr>\\n<tr>\\n<td>\\nDeals\\n</td>\\n<td>\\nAny deal field\\nPerson name OR organization name\\n(deal title recommended)\\n</td>\\n</tr>\\n<tr>\\n<td>\\nPersons\\n</td>\\n<td>\\nPerson name\\n:::tip\\nNote: Email and phone are recommended for avoiding duplicates\\n:::\\n</td>\\n</tr>\\n<tr>\\n<td>\\nOrganization\\n</td>\\n<td>\\nOrganization name\\n:::tip\\nNote: Address is recommended for avoiding duplicates\\n:::\\n</td>\\n</tr>\\n<tr>\\n<td>\\nProducts\\n</td>\\n<td>\\nProduct name\\n:::tip\\nNote: Product Code is recommended for avoiding duplicates\\n:::\\n</td>\\n</tr>\\n<tr>\\n<td>\\nNotes\\n</td>\\n<td>\\nContent\\nDeal, contact (person or organization) information\\n</td>\\n</tr>\\n<tr>\\n<td>\\nActivities\\n</td>\\n<td>\\nAny activity field\\n</td>\\n</tr>\\n</tbody>\\n</table>\\n<!-- You can read more about mandatory fields for importing in this article. -->\\n\\n","section":"Importing data into Fintesk with spreadsheets","version":"current","path":"/kb/importing-data/importing-data-into-fintesk-with-spreadsheets#mandatory-fields","category":"default"},{"title":"Custom fields","content":"If your spreadsheet has data for deals or contacts that isn’t covered by default fields, add a custom field before importing so your data has somewhere to be mapped.\\nFor example, “job title” is not a default field in Fintesk. To include this information in your import, create a custom person field, then map the spreadsheet column to the newly created field. We recommend a text or single option field.\\nYou can also create custom fields during the mapping stage of your import. Learn more about custom fields in this article.\\n<!--  -->\\n\\n\\n","section":"Importing data into Fintesk with spreadsheets","version":"current","path":"/kb/importing-data/importing-data-into-fintesk-with-spreadsheets#custom-fields","category":"default"},{"title":"Step 1: Upload your file","content":"Go to “...” (More)> Import data > From a spreadsheet. Click \'From a spreadsheet\' and select the file you intend to import. Fintesk supports Excel (.xls and .xlsx) and .csv files.\\n<!--  -->\\n\\n","section":"Importing data into Fintesk with spreadsheets","version":"current","path":"/kb/importing-data/importing-data-into-fintesk-with-spreadsheets#step-1-upload-your-file","category":"default"},{"title":"Step 2: Mapping","content":"To import your data to Fintesk, map each column in your spreadsheet to the relevant icon and field in the mapping step. You can hover over the icon to see what type of data it refers to in Fintesk.\\nThe auto-recognition feature will automatically match the column header to the fields in Fintesk. Any unrecognized fields must be dragged from the Fintesk fields (right) to their appropriate spreadsheet columns (left). Use the search bar to find Fintesk field names more easily.\\n<!--  -->\\n\\n:::tip\\nNote: You can learn more about mapping in this article or advanced mapping in this article.\\n:::\\nOnce you are finished mapping, click “Next.”\\n","section":"Importing data into Fintesk with spreadsheets","version":"current","path":"/kb/importing-data/importing-data-into-fintesk-with-spreadsheets#step-2-mapping","category":"default"},{"title":"Step 3: Preview and finish","content":"In the next window, choose what to do if duplicates are found in your spreadsheet. If Fintesk detects a duplicate record in your spreadsheet or Fintesk data, it will consolidate this into one entry. You can learn more about how Fintesk detects duplicates during importing in this article.\\n<!--  -->\\n\\nThis page also shows a preview of your data after the import.\\n<!--  -->\\n\\nOnce you’ve previewed your import, select “Start import.”\\n\\n","section":"Importing data into Fintesk with spreadsheets","version":"current","path":"/kb/importing-data/importing-data-into-fintesk-with-spreadsheets#step-3-preview-and-finish","category":"default"},{"title":"After your import","content":"After your import, you will see a confirmation page with an overview of the imported data.\\n<!-- \\n -->\\n<!-- ### What is a “skip file?”\\nAny items imported incorrectly are put together in a Skip file, which includes the row where the complication occurred and the reason why.\\nFor example, if you import a list of persons and don’t include a mandatory field (e.g., person name), that row of information will be skipped. Fintesk will then take that row and organize it in a Skip file.\\nYou can download the Skip File at any time to review these errors and make the needed changes directly in the spreadsheet, then import the Skip File into Fintesk to complete your import. This ensures all of your data makes it into the system.\\n\\nYour skip file will look like this:\\n\\nYou can learn more about why data is skipped in this article. -->\\n\\n<!-- ## How do I revert an import?\\n:::tip\\nNote: Only global admin users can revert imports.\\n:::\\nA spreadsheet import can be reverted within 48 hours of its initial import with the revert button provided in your import history.\\n\\nNote: If the revert button is unavailable, let our support team know and they will assist you. -->\\n","section":"Importing data into Fintesk with spreadsheets","version":"current","path":"/kb/importing-data/importing-data-into-fintesk-with-spreadsheets#after-your-import","category":"default"},{"title":"Deals","content":"Every deal in Fintesk needs to have either a contact person or organization linked to it. To import a deal, you will need to add at least one deal field and any of the following in your spreadsheet:\\nPerson name\\nOrganization name\\nWe recommend including the deal name field, but it’s not mandatory. If you don’t include a deal name, the deal will automatically take the name of the contact that it is imported with.\\n<!--  -->\\n\\n<!--  -->\\n\\n","section":"Importing-> mandatory fields","version":"current","path":"/kb/importing-data/importing-mandatory-fields#deals","category":"default"},{"title":"What other fields can I include with my deals import?","content":"You can also include the following deal fields:\\nOwner\\nStage\\nValue\\nExpected close date\\nAny custom fields\\nIf you are importing a historic deal or a deal that has already been closed, you can use the following fields:\\nWon time\\nLost time\\nStatus\\n:::tip\\nNote: To import a deal, you don\'t necessarily need to have a deal name in your spreadsheet. If you want to create deals for each person or organization, you just need to create an empty column in your spreadsheet for the deal names. Make sure this empty column is mapped to the Deal-Name field.\\n:::\\nWhen imported, the deal\'s titles will automatically take the name of the organization. If there is no organization, it will take the name of the contact person.\\n\\n","section":"Importing-> mandatory fields","version":"current","path":"/kb/importing-data/importing-mandatory-fields#what-other-fields-can-i-include-with-my-deals-import","category":"default"},{"title":"Contacts: persons and organizations","content":"When importing persons or organizations, only the name is mandatory for successful contact creation. However, it is recommended to add more fields to better identify your contact and avoid duplications from being created. Learn more about how Fintesk detects duplicates during importing in this article.\\nFor persons, add the following to prevent duplicates from being created:\\nemail address\\nPhone number\\nFor organizations, include the following to prevent duplicates from being created:\\nAddress\\nOrganizations and persons can be created separately, but we recommend importing them together to automatically link them.\\n<!--  -->\\n\\n<!--  -->\\n\\n:::tip\\nNote: Red in the above images represents a mandatory field.\\n:::\\n\\n","section":"Importing-> mandatory fields","version":"current","path":"/kb/importing-data/importing-mandatory-fields#contacts-persons-and-organizations","category":"default"},{"title":"Products","content":"To import a product, you will just need the product name in your spreadsheet.\\n<!--  -->\\n\\n<!--  -->\\n\\n","section":"Importing-> mandatory fields","version":"current","path":"/kb/importing-data/importing-mandatory-fields#products","category":"default"},{"title":"What other fields can I include with my product import?","content":"You can also include other product fields such as price, currency, description and any custom fields.\\n:::tip\\nNote: Currently it is not possible to link products to deals through an import. You can only link a product to a deal when your data has already been imported into Fintesk.\\n:::\\n\\n<!--\\n","section":"Importing-> mandatory fields","version":"current","path":"/kb/importing-data/importing-mandatory-fields#what-other-fields-can-i-include-with-my-product-import","category":"default"},{"title":"Notes","content":"Notes can be added under deals, persons, organizations, activities and leads, and cannot exist by themselves. When importing a note, you have to also include information of one of the following (and their mandatory fields):\\nOrganization\\nPerson\\nDeal\\nLead\\n\\nWhat are other note fields I can include?\\nYou can add the following fields for notes:\\nNote creation date\\nNote update date -->\\n\\n","section":"Importing-> mandatory fields","version":"current","path":"/kb/importing-data/importing-mandatory-fields#notes","category":"default"},{"title":"Activity","content":"For the time being, activities don\'t have any mandatory fields. However, it is recommended to include information such as the subject, due date, type and assigned to user, as well as any linked deals, or contacts.\\n<!--  -->\\n\\n<!--  -->\\nIf your activity has already been completed, you can include the following historical fields:\\nDone time\\nMarked as done time\\n","section":"Importing-> mandatory fields","version":"current","path":"/kb/importing-data/importing-mandatory-fields#activity","category":"default"},{"title":"Item icons","content":"In order to import your data to Fintesk correctly, you will need to map each field with the relevant icons for your items to import. Each item type is represented by an item icon when importing.\\nFor example, all of your person-related fields have to be mapped to fields under the \\"Person\\" item icon in order for them to show up properly linked to your contacts.\\n<!--  -->\\n\\nPerson type fields\\n<!--  -->\\n\\nOrganization type fields\\n<!--  -->\\n\\nDeal type fields\\n<!--  -->\\n\\nActivity type fields\\n<!--  -->\\n\\n<!-- - Note type fields\\n\\n-->\\nProduct type fields\\n<!--  -->\\n\\n<!-- - Lead type fields\\n -->\\nClick on the icons to select the correct type of fields when mapping.\\n<!--  -->\\n\\n\\n","section":"Importing-> mapping your fields","version":"current","path":"/kb/importing-data/importing-mapping-your-fields#item-icons","category":"default"},{"title":"Mapping your fields","content":":::tip\\nNote: Not all of your fields will be mapped automatically, so you will need to map some fields manually. It is always recommended to double-check your mapping before moving to the next step to prevent any incorrect mapping.\\n:::\\nOnce you have your spreadsheet set up and imported, you can then begin mapping your fields. Below you can see a sample from a spreadsheet.\\n<!--  -->\\n\\nWhen mapping, select the icon of the field type you wish to map. Then click and drag that field to the left-hand side of the page and match it to your spreadsheet columns. You will see the data from the first row of your import, so you can check that spreadsheet is read correctly by Fintesk.\\n<!--  -->\\n\\nYou can find more information on advanced mapping, such as mapping multiple option fields in this article.\\n","section":"Importing-> mapping your fields","version":"current","path":"/kb/importing-data/importing-mapping-your-fields#mapping-your-fields","category":"default"},{"title":"Importing-> sample import spreadsheets","content":"<p>&lt;!-- ../../kb/importing-data/importing-sample-import-spreadsheets.md --&gt;</p>\\n<p>&lt;!-- # Importing: sample import spreadsheets --&gt;</p>\\n<p>If you need assistance with your Fintesk <a href=\\"../../kb/importing-data/importing-data-into-fintesk-with-spreadsheets\\">data import</a>, you may wish to begin with a template document to see how best to proceed.</p>\\n<p>:::tip\\n<strong>Note:</strong> For information on how to import spreadsheet data into Fintesk, check out <a href=\\"../../kb/importing-data/importing-data-into-fintesk-with-spreadsheets\\">this guide</a>.\\n:::</p>\\n<p>The spreadsheet attached to this article, <strong>Fintesk sample data</strong>, provides excellent visual cues and important reference information to get you started using Fintesk.</p>\\n<p>The columns in the sample spreadsheet are color-coded, and provide descriptions of the different fields, making the column headers easy to recognize in the mapping section of Fintesk\'s importing function.</p>\\n<p>You can populate your own data into this spreadsheet, or use it to gain insight regarding where to map the different Fintesk fields in your own spreadsheet\'s columns.</p>\\n<ul>\\n<li><a href=\\"../../kb/importing-data/importing-sample-import-spreadsheets/ejemplo_data_v5.xlsx\\">Download Fintesk sample data.xlsx file</a>\\n&lt;!-- - <a href=\\"https://kb-cms.pipedriveassets.com/pipedrive_sample_data.xlsx\\">Download Fintesk sample data.xlsx file</a> --&gt;\\n&lt;!-- - <a href=\\"https://kb-cms.pipedriveassets.com/pipedrive_sample_data%20-%20Sheet1.csv\\">Download Fintesk sample data.csv file</a> --&gt;</li>\\n</ul>\\n","section":"Importing-> sample import spreadsheets","version":"current","path":"/kb/importing-data/importing-sample-import-spreadsheets","category":"default"},{"title":"Importing and exporting your data","content":"\\n:::tip\\nNote: This action is only available to admin users or regular users with the correct permission enabled.\\n:::\\nThe other way of moving your data to a different company account in Fintesk would be to export the relevant data from your Fintesk account to a spreadsheet and import it into the other company account.\\nWhen exporting your data, it’s important to keep the mandatory fields that Fintesk will need when mapping during importing in mind, in order to successfully create the new items in your other Fintesk account. To see what fields are mandatory for importing data into your Fintesk account, click here.\\nOnce you have your data exported to a spreadsheet, you can then import this spreadsheet to the other Fintesk company account and start working right where you left off.\\n","section":"Transferring data to a different Fintesk company account","version":"current","path":"/kb/importing-data/transferring-data-to-a-different-fintesk-company-account#importing-and-exporting-your-data","category":"default"},{"title":"Fintesk System ID feature","content":"Within Fintesk, every item – deal, person, organization, activity, product, note – is assigned a unique ID upon creation. You can find this ID in the URL of the detail view of each item, or you can add it as a column in the list view.\\n\\n<!-- :::tip\\nNote: If you are attempting to merge duplicates in your account, you may be interested in the Merge Duplicates feature within Fintesk. Learn more about merging duplicates in this article.\\n::: -->\\n\\n","section":"Updating Fintesk data with a spreadsheet","version":"current","path":"/kb/importing-data/updating-fintesk-data-with-a-spreadsheet#fintesk-system-id-feature","category":"default"},{"title":"Which IDs and fields should I use?","content":"To update your items (deals, persons, organizations, products, etc.), it\'s necessary to include the Fintesk System ID and any other fields you\'d like to update.\\nFor example, let’s say that you want to change the values, stage and ownership of existing deals. You need to export a list with the ID column plus the Value, Stage Name and Owner columns.\\n\\nNote that you can export other columns for reference, like the name. However, any changes that you make in those columns will be overwritten when you import.\\n","section":"Updating Fintesk data with a spreadsheet","version":"current","path":"/kb/importing-data/updating-fintesk-data-with-a-spreadsheet#which-ids-and-fields-should-i-use","category":"default"},{"title":"How do I get the Fintesk System IDs in the list view?","content":"To make the ID column visible in the list view, click the gear icon to open the \\"Choose columns\\" section, search and select the desired ID field and click \\"Save\\".\\n\\n:::tip\\nNote: You can get deal, person and organization IDs inside the list view of the deals tab. However, if you have contacts with no associated deals, they will not show up in the list view of the deals tab. You will then have to use the list view of the contacts tab to get those IDs.\\n:::\\n<!-- You can create a filter to narrow down the list  -->\\nYou can create a filter to narrow down the list\\nto only items you want to update. When the list view is configured to display your Fintesk System ID fields, export the list here:\\n\\n\\n","section":"Updating Fintesk data with a spreadsheet","version":"current","path":"/kb/importing-data/updating-fintesk-data-with-a-spreadsheet#how-do-i-get-the-fintesk-system-ids-in-the-list-view","category":"default"},{"title":"Importing your data","content":"Once exported, make all necessary changes to the data within the spreadsheet. Here is one example of what your spreadsheet would look like when you export it before the changes:\\n\\nAnd here is an example of the same spreadsheet with changes made to it. Keep in mind that the ID fields don’t need to be changed. You only need to change the information that needs to be updated in Fintesk.\\n\\nThen, import the spreadsheet to Fintesk and map the corresponding ID fields to their columns.\\n\\nWhen all the fields are mapped, click on “Next” and finish the import. The Fintesk System ID will automatically update your database with your new information, as Fintesk will know which elements you are updating based on the Fintesk System ID.\\n:::tip\\nNote: If you receive an error when attempting to import a spreadsheet, the issue may stem from your spreadsheet: the maximum file size is limited to 50MB, with a maximum limit of 50,000 rows. You can learn more about importing errors in this article.\\n:::\\n","section":"Updating Fintesk data with a spreadsheet","version":"current","path":"/kb/importing-data/updating-fintesk-data-with-a-spreadsheet#importing-your-data","category":"default"},{"title":"Why do my imported currency values appear as \\"0\\"?","content":"<p>&lt;!-- ## Why do my imported currency values appear as &quot;0&quot;? --&gt;</p>\\n<p>When importing from spreadsheets, make sure all monetary values (for default fields such as deal value, and for any custom fields where you have currencies) are formatted as numbers <strong>without</strong> currency symbols (so as 1000000000 as opposed to $1000000000).</p>\\n<p>If numbers include currency symbols, the Fintesk import system won’t detect them properly and thus all values will be formatted as ”0”.</p>\\n<p>If you’ve already imported and are facing this issue, the best course of action is to revert your import, remove the currency symbols from the spreadsheet you’re importing and import again.</p>\\n","section":"Why do my imported currency values appear as \\"0\\"?","version":"current","path":"/kb/importing-data/why-do-my-imported-currency-values-appear-as-0","category":"default"},{"title":"Adding columns to your list view","content":":::tip\\nNote: Deal, person and organization fields are available to use as columns.\\n:::\\nClick the gear icon in the top right corner of the list view and select which fields you want as columns.\\nWhen finished, click “Save”.\\n<!--  -->\\n\\nYour new column(s) will appear in the next available spot to the right of your existing columns.\\n<!--  -->\\n\\n\\n<!--\\n","section":"Customizing the columns in the list view","version":"current","path":"/kb/list-view/customizing-the-columns-in-the-list-view#adding-columns-to-your-list-view","category":"default"},{"title":"Reordering your columns","content":"You can change where a column is located by holding your cursor down and dragging it to your preferred spot.\\n\\nYou can also change the width of your columns by holding the cursor down and moving the margins on either side. -->\\n","section":"Customizing the columns in the list view","version":"current","path":"/kb/list-view/customizing-the-columns-in-the-list-view#reordering-your-columns","category":"default"},{"title":"Where to find it","content":"You can find an item’s system ID in two places.\\n","section":"Fintesk System IDs","version":"current","path":"/kb/list-view/fintesk-system-ids#where-to-find-it","category":"default"},{"title":"The URL after opening an item","content":"When you open the detail view of an item, that item’s ID is the last number in your browser’s URL.\\n<!--  -->\\n\\n","section":"Fintesk System IDs","version":"current","path":"/kb/list-view/fintesk-system-ids#the-url-after-opening-an-item","category":"default"},{"title":"The list view","content":"You can also find the IDs for your items using the list view.\\nClick the gear icon and select ID > Save.\\n<!--  -->\\n\\nYour IDs will appear as a column and in the visible section of your column settings.\\n<!--  -->\\n\\n\\n","section":"Fintesk System IDs","version":"current","path":"/kb/list-view/fintesk-system-ids#the-list-view","category":"default"},{"title":"What are they for","content":":::tip\\nNote: For a guide to updating your data using system IDs and spreadsheets, check out this article.\\n:::\\nThe primary purpose of system IDs is organization. Having a number that corresponds to each piece of data makes it easier to organize and find it.\\nHowever, there are other ways to use IDs.\\n","section":"Fintesk System IDs","version":"current","path":"/kb/list-view/fintesk-system-ids#what-are-they-for","category":"default"},{"title":"Updating data in bulk","content":"If you want to update a lot of data all at once, you can do so using system IDs.\\nWe have an article that explains the process in detail, but basically:\\ninclude the ID field when you export a spreadsheet\\nmake the desired changes to the spreadsheet\\nreimport that spreadsheet\\nThe existing data in your account corresponding to the exported IDs will be updated.\\n","section":"Fintesk System IDs","version":"current","path":"/kb/list-view/fintesk-system-ids#updating-data-in-bulk","category":"default"},{"title":"Integration functions","content":"Some third-party apps like Zapier have options to update specific items automatically, and using system IDs is an effective way to identify which items you want to change.\\nThis can be especially useful if, for example, you have multiple items with the same or similar names.\\n","section":"Fintesk System IDs","version":"current","path":"/kb/list-view/fintesk-system-ids#integration-functions","category":"default"},{"title":"How can I add or remove columns in the list view?","content":"<p>&lt;!-- ../../kb/list-view/how-can-i-add-or-remove-columns-in-the-list-view.md --&gt;</p>\\n<p>&lt;!-- # How can I add or remove columns in the list view? --&gt;</p>\\n<p>To choose which columns are visible in the <strong>list view</strong> table, click on the <strong>gear icon</strong> at the top right corner of the list view table and – using the checkboxes shown – select which columns you would like to be shown.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screen_Shot_2020-08-28_at_3.57.23_PM.png\\" alt=\\"1\\"> --&gt;</p>\\n<p><img src=\\"../../kb/list-view/how-can-i-add-or-remove-columns-in-the-list-view/hciar01.jpeg\\" alt=\\"hciar01\\"></p>\\n<p>When finished, click <strong>&quot;Save&quot;</strong> to update your list view.</p>\\n","section":"How can I add or remove columns in the list view?","version":"current","path":"/kb/list-view/how-can-i-add-or-remove-columns-in-the-list-view","category":"default"},{"title":"How can I edit a field in the list view?","content":"<p>&lt;!-- # How can I edit a field in the list view? --&gt;</p>\\n<p>In the list view of Fintesk, you can edit a field by hovering your mouse over the field in question and clicking on the pencil icon that appears.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screen_Shot_2020-08-28_at_3.58.45_PM.png\\" alt=\\"1\\"> --&gt;</p>\\n<p><img src=\\"../../kb/list-view/how-can-i-edit-a-field-in-the-list-view/hcief01.jpeg\\" alt=\\"hcief01\\">\\n<img src=\\"../../kb/list-view/how-can-i-edit-a-field-in-the-list-view/hcief02.jpeg\\" alt=\\"hcief02\\"></p>\\n<p>Once the pencil icon is clicked, you will be able to provide new information to go into that field.</p>\\n","section":"How can I edit a field in the list view?","version":"current","path":"/kb/list-view/how-can-i-edit-a-field-in-the-list-view","category":"default"},{"title":"Saving your list view columns","content":"To save the configuration of your list view columns, start by opening the filter dropdown in your list view and selecting a filter.\\n<!--  -->\\n\\nAfter you’ve selected your filter, check the box for “Save selected columns with the filter” then click “Save”.\\n<!--  -->\\n\\nNow, when you or another user opens that filter, the list view columns you had when it was saved will be opened as well.\\n\\n<!--\\n","section":"How can I set default columns for all my users in the list view?","version":"current","path":"/kb/list-view/how-can-i-set-default-columns-for-all-my-users-in-the-list-view#saving-your-list-view-columns","category":"default"},{"title":"Sharing your filter","content":"To share a filter with the rest of your account’s users, change the filter’s visibility to “Shared.”\\n\\nIf a filter is set to shared and “Save selected columns with the filter” is checked, other users can open your filter and the list view columns it was saved with. -->\\n","section":"How can I set default columns for all my users in the list view?","version":"current","path":"/kb/list-view/how-can-i-set-default-columns-for-all-my-users-in-the-list-view#sharing-your-filter","category":"default"},{"title":"What can I do in the list view?","content":"The list view supports several actions:\\n","section":"List view","version":"current","path":"/kb/list-view#what-can-i-do-in-the-list-view","category":"default"},{"title":"Adding items","content":"Use the “+ Add [item]” button at the top of your list view to add new items.\\n<!--  -->\\n\\n:::tip\\nNote: The above example is from the deal list view and shows the “+ Add Deal” button, which is used to add new deals.\\n:::\\n","section":"List view","version":"current","path":"/kb/list-view#adding-items","category":"default"},{"title":"Filtering","content":"Click the dropdown menu in the top right corner to add or apply existing filters to your list view.\\n<!--  -->\\n\\n","section":"List view","version":"current","path":"/kb/list-view#filtering","category":"default"},{"title":"Changing columns","content":"Click the gear icon on the right side of the screen to adjust the visible columns in your list view.\\n<!--  -->\\n\\n:::tip\\nNote: For more information about changing your list view columns, check out this guide.\\n:::\\n","section":"List view","version":"current","path":"/kb/list-view#changing-columns","category":"default"},{"title":"Editing field values","content":"If you hover over a field in the deal, person, organization, activity or product list view, you can click the pencil icon to edit that field’s value.\\n<!--  -->\\n:::tip\\nNote: Some fields, like activity “add time,” can’t be edited through the list view.\\n:::\\n\\n","section":"List view","version":"current","path":"/kb/list-view#editing-field-values","category":"default"},{"title":"Hovercards in the list view","content":":::tip\\nNote: You can click on a person or organization in a hovercard to see the item’s detail view.\\n:::\\nIf you hover your cursor over a person, organization or deal in the list view, a card will open up and show the item’s basic information.\\nPersons – The card has the person’s name, email, phone and linked organization.\\n<!--  -->\\n\\nOrganizations – The card has the organization’s name, address and linked person.\\n<!--  -->\\n\\n<!-- - Deals – The card has the deal title, value, linked person or organization, expected close date and current pipeline and stage. -->\\nDeals – The card has the deal title, value, linked person or organization and current pipeline and stage.\\n<!-- -  -->\\n","section":"List view","version":"current","path":"/kb/list-view#hovercards-in-the-list-view","category":"default"},{"title":"Fintesk Settings","content":"<!-- :::tip\\nNote: For information about how your data is organized in Fintesk, check out this article.\\n::: -->\\n:::tip\\nNote: For information about how your data is organized in Fintesk, check out this article.\\n:::\\nNavigating your Fintesk account includes knowing where to find your settings and what you can find there.\\n\\n","section":"Fintesk Settings","version":"current","path":"/kb/personal-settings/fintesk-settings","category":"default"},{"title":"Finding your settings","content":"To find your settings, click on the picture in the top right corner of your Fintesk window and click ”Company settings.”\\n<!--  -->\\n\\nYour settings are divided into two sections: Company settings and Personal preferences.\\n\\n","section":"Fintesk Settings","version":"current","path":"/kb/personal-settings/fintesk-settings#finding-your-settings","category":"default"},{"title":"Company settings","content":"Your company settings are divided into four sections:\\n<!-- - General – choose your company name and domain -->\\nActivities – create and manage activity types, as well as toggle the “show activity“ pop-up\\nCurrencies – view the existing currencies on your account and create new ones\\nLost reasons – view and create custom lost reasons\\n<!--  -->\\n\\nThese settings are focused on things that affect all of the users in your account, so you need account settings access to make changes here.\\n\\n","section":"Fintesk Settings","version":"current","path":"/kb/personal-settings/fintesk-settings#company-settings","category":"default"},{"title":"Personal preferences","content":"Your personal preferences are broken down into three sections, where only one is working right now:\\nAccount – basic information for your individual user experience, like your linked email, language and preferred currency\\n<!-- - Your companies – shows any other Fintesk companies you’re added to (using the same login email) -->\\n<!-- - API – copy your unique API key or generate a new one -->\\n<!--  -->\\n\\n<!-- These settings are specific to your account, so things like your login email and API key should be kept private for security reasons. -->\\nThese settings are specific to your account, so things like your login email should be kept private for security reasons.\\n","section":"Fintesk Settings","version":"current","path":"/kb/personal-settings/fintesk-settings#personal-preferences","category":"default"},{"title":"To change your Fintesk password","content":"Go to Settings > Password and login > Change password.\\nIn the “Current password” field, provide the current login password for your Fintesk user account.\\nIn the “New password” and ”Confirm password” fields, provide your desired password credentials.\\nClick the “Change password” button to save your new password.\\n<!--  -->\\n\\n\\n","section":"How can I change or reset my password?","version":"current","path":"/kb/personal-settings/how-can-i-change-or-reset-my-password#to-change-your-fintesk-password","category":"default"},{"title":"To reset your Fintesk password","content":"If you’re attempting to log in and don’t recall your login password, simply click the “Forgot your password?” option listed in the password box.\\nIf you’re currently logged into Fintesk but still don’t recall your current password credentials, you’ll need to first log out of your account.\\n<!--  -->\\n\\nFrom there, simply enter your email address, and click “Get a new password”. You’ll receive a password reset email at the provided email address.\\nIf you don’t receive a password reset email within a few minutes, you may have put in an email address that is not associated with a Fintesk user account. We suggest trying again, with your known login email address.\\n","section":"How can I change or reset my password?","version":"current","path":"/kb/personal-settings/how-can-i-change-or-reset-my-password#to-reset-your-fintesk-password","category":"default"},{"title":"Deleting items","content":":::tip\\nNote: We recommend exporting data you plan to remove prior to deletion, so it can be added back into your account later on if needed.\\n:::\\nThe most effective way to free up space in your account is to delete data that isn’t necessary anymore. You can delete individual items in their detail views, or in bulk using the list view.\\nDeleting with the detail view\\n:::tip\\nNote: Activities can’t be deleted using the detail view.\\n:::\\n<!-- To delete a single item in Fintesk (lead, deal, contact, product, project,) go to the detail view and click ”...“ > Delete. -->\\nTo delete a single item in Fintesk (deal, contact, product) go to the detail view and click ”...“ > Delete.\\n<!--  -->\\n\\n<!-- Deleting with the list view\\nIf you want to delete an activity, or delete items in bulk, go to your list view and select the items you want to delete then click the trash can icon.\\n\\nYou can create and apply filters in the list view if you want to specify which items to delete, rather than selecting them individually. -->\\n\\n","section":"How can I clean up my account and free up space?","version":"current","path":"/kb/personal-settings/how-can-i-free-up-space#deleting-items","category":"default"},{"title":"Deleting custom fields","content":":::tip\\nNote: We recommend limiting redundancies when creating custom fields to optimize storage, like creating multiple custom fields under the same name for different items (i.e. a ”source“ field for both deals and persons.)\\n:::\\nCustom fields are impacted by usage limits, so knowing how to delete them is important for storage management.\\n","section":"How can I clean up my account and free up space?","version":"current","path":"/kb/personal-settings/how-can-i-free-up-space#deleting-custom-fields","category":"default"},{"title":"Custom fields","content":"Go to Settings > Data fields, find the desired field and click ”...“ > Delete.\\n<!--  -->\\n\\n\\n","section":"How can I clean up my account and free up space?","version":"current","path":"/kb/personal-settings/how-can-i-free-up-space#custom-fields","category":"default"},{"title":"Managing deals","content":"There are some actions available for deals related to data management that other items don’t have.\\nThis can be important, especially since the number of open deals you can have is impacted by usage limits.\\n<!-- Converting deals to leads\\n:::tip\\nNote: The Rotting feature is a great way to see which deals have been stagnating in your pipeline, and potentially need to be moved to your Leads inbox. For more information about that tool, check out this article.\\n:::\\nIf you have an excess of open deals in your account and need to remove some to make room for new deals, you can move those deals into your Leads inbox.\\n\\nYou can do this in two ways:\\nfrom the deal detail view\\n\\nfrom the list view\\n\\n:::tip\\nNote: You can convert up to 100 deals at a time.\\n::: -->\\n","section":"How can I clean up my account and free up space?","version":"current","path":"/kb/personal-settings/how-can-i-free-up-space#managing-deals","category":"default"},{"title":"Reopening deals","content":":::tip\\nNote: Deleted deals can be recovered for 30 days after initial deletion.\\n:::\\nIf you’ve deleted deals and want to add them back into your account, start by applying the filter for all deleted deals.\\n<!--  -->\\n\\nThen select the desired deal and, in the detail view, click ”Reopen.“\\n<!--  -->\\n\\n","section":"How can I clean up my account and free up space?","version":"current","path":"/kb/personal-settings/how-can-i-free-up-space#reopening-deals","category":"default"},{"title":"Deal status","content":":::tip\\nNote: By default, the \\"pipeline view\\" only displays open deals. However, you can apply filters to your \\"pipeline view\\" to display won and lost deals as well. For more information about filtering in Fintesk, check out this guide.\\n:::\\nKeeping won and lost deals open affects your reports and statistics since they’re counted toward your deal storage.\\nIf your deals were already won or lost, we recommend marking them accordingly. You can do this:\\n<!-- in two different ways: -->\\nDetail view\\n<!--  -->\\n\\n<!-- - List view\\n-->\\n\\n","section":"How can I clean up my account and free up space?","version":"current","path":"/kb/personal-settings/how-can-i-free-up-space#deal-status","category":"default"},{"title":"Notes","content":"You can use notes in place of custom fields to save space as well.\\nFor example, rather than creating a text custom field for client description, you can add that information as a note.\\n<!--  -->\\n\\n:::tip\\nNote: You can export your notes whenever you need them. Learn more about exporting notes in this article.\\n:::\\n","section":"How can I clean up my account and free up space?","version":"current","path":"/kb/personal-settings/how-can-i-free-up-space#notes","category":"default"},{"title":"Usage limits per plan","content":"<table>\\n<tr>\\n<td></td>\\n<td>Free</td>\\n<td>Essential</td>\\n<td>Advanced</td>\\n<td>Professional</td>\\n</tr>\\n<tr>\\n<td>Open deals (per company)</td>\\n<td>100</td>\\n<td>500</td>\\n<td>1,000</td>\\n<td>10,000</td>\\n</tr>\\n<tr>\\n<td>Custom fields (per company)</td>\\n<td>10</td>\\n<td>30</td>\\n<td>50</td>\\n<td>100</td>\\n</tr>\\n<!-- <tr>\\n<td>Custom visibility groups (per company)</td>\\n<td></td>\\n<td>N/A</td>\\n<td>N/A</td>\\n<td>3</td>\\n</tr>\\n<tr>\\n<td>Custom permission sets (per company)</td>\\n<td></td>\\n<td>N/A</td>\\n<td>N/A</td>\\n<td>2</td>\\n</tr>\\n<tr>\\n<td>Teams (per company)</td>\\n<td></td>\\n<td>N/A</td>\\n<td>N/A</td>\\n<td>3</td>\\n</tr> -->\\n</table>\\n<!-- <table>\\n<tr>\\n<td></td>\\n<td>Free</td>\\n<td>Essential</td>\\n<td>Advanced</td>\\n<td>Professional</td>\\n<td>Power</td>\\n<td>Enterprise</td>\\n</tr>\\n<tr>\\n<td>Open deals (per company)</td>\\n<td></td>\\n<td>3,000</td>\\n<td>10,000</td>\\n<td>100,000</td>\\n<td>200,000</td>\\n<td>Unlimited</td>\\n</tr>\\n<tr>\\n<td>Custom fields (per company)</td>\\n<td></td>\\n<td>30</td>\\n<td>100</td>\\n<td>300</td>\\n<td>500</td>\\n<td>Unlimited</td>\\n</tr>\\n<tr>\\n<td>Insights reports (per user)</td>\\n<td></td>\\n<td>15</td>\\n<td>30</td>\\n<td>150</td>\\n<td>250</td>\\n<td>Unlimited</td>\\n</tr>\\n<tr>\\n<td>Custom visibility groups (per company)</td>\\n<td></td>\\n<td>N/A</td>\\n<td>N/A</td>\\n<td>3</td>\\n<td>15</td>\\n<td>Unlimited</td>\\n</tr>\\n<tr>\\n<td>Custom permission sets (per company)</td>\\n<td></td>\\n<td>N/A</td>\\n<td>N/A</td>\\n<td>2</td>\\n<td>10</td>\\n<td>Unlimited</td>\\n</tr>\\n<tr>\\n<td>Teams (per company)</td>\\n<td></td>\\n<td>N/A</td>\\n<td>N/A</td>\\n<td>3</td>\\n<td>15</td>\\n<td>Unlimited</td>\\n</tr>\\n<tr>\\n<td>Automations (active per user)</td>\\n<td></td>\\n<td>N/A</td>\\n<td>30</td>\\n<td>60</td>\\n<td>90</td>\\n<td>180</td>\\n</tr>\\n<tr>\\n<td>Multiple email sync (per user)</td>\\n<td></td>\\n<td>N/A</td>\\n<td>1 email account</td>\\n<td>2 email accounts</td>\\n<td>3 email accounts</td>\\n<td>5 email accounts</td>\\n</tr>\\n</table> -->\\n:::info\\nNote: An open deal refers to a deal that has not been won, lost, or deleted.\\n<!-- Report limits are per user and. -->\\nOpen deal and custom fields limits are per company.\\n:::\\n<!--\\n","section":"Usage limits in Fintesk","version":"current","path":"/kb/personal-settings/usage-limits-in-fintesk#usage-limits-per-plan","category":"default"},{"title":"Automations tool","content":"Some features of the Automations tool also depend on the plan you’re on.\\n<table>\\n<tr>\\n<td>Advanced</td>\\n<td>Professional</td>\\n<td>Power</td>\\n<td>Enterprise</td>\\n</tr>\\n<tr>\\n<td>30 active automations per user</td>\\n<td>60 active automations per user</td>\\n<td>90 active automations per user</td>\\n<td>100 active automations per user</td>\\n</tr>\\n<tr>\\n<td>10 actions per automation</td>\\n<td>10 actions per automation</td>\\n<td>10 actions per automations</td>\\n<td>10 actions per automation</td>\\n</tr>\\n<tr>\\n<td>3 delays per automation</td>\\n<td>10 delays per automation</td>\\n<td>10 delays per automations</td>\\n<td>10 delays per automation</td>\\n</tr>\\n<tr>\\n<td>Total Time Limit: 90 days</td>\\n<td>Total Time Limit: 90 days</td>\\n<td>Total Time Limit: 90 days</td>\\n<td>Total Time Limit: 90 days</td>\\n</tr>\\n</table> -->\\n\\n<!--\\n","section":"Usage limits in Fintesk","version":"current","path":"/kb/personal-settings/usage-limits-in-fintesk#automations-tool","category":"default"},{"title":"How can I view my usage?","content":"You can view your usage details by going to Settings > Company > Usage.\\n\\nYou’ll be notified in-app and by email when you reach 80% and 100% of a limit. -->\\n\\n","section":"Usage limits in Fintesk","version":"current","path":"/kb/personal-settings/usage-limits-in-fintesk#how-can-i-view-my-usage","category":"default"},{"title":"What happens when I’ve reached usage limits?","content":"<!-- Fintesk won’t delete any of your data when you’re over a limit. However, you’ll be blocked from manually adding more of the exceeded data until you free up space or upgrade to a higher plan. -->\\nFintesk won’t delete any of your data when you’re over a limit. However, you’ll be blocked from manually adding more of the exceeded data until you free up space or upgrade to a higher plan.\\n<!--  -->\\n<!-- When you’re at an open deal limit, excess deals created by automations, LeadBooster (Chatbot or Web Forms), public API, or during an import will instead be sent to your deals waitlist or import skip file, respectively. Both of these can be re-imported when there is more space in your account. -->\\nWhen you’re at an open deal limit, excess deals created by public API, or during an import will instead be sent to import skip file. These deals can be re-imported when there is more space in your account.\\n<!-- Note: Deals that have been on the waitlist for one year will be automatically deleted. -->\\nLearn more about how to free up space in your account in this article.\\n<!-- Note: Usage limits are also applied to the number of total workflows you can have active in your account. For more information about these limits, read this article. -->\\n","section":"Usage limits in Fintesk","version":"current","path":"/kb/personal-settings/usage-limits-in-fintesk#what-happens-when-ive-reached-usage-limits","category":"default"},{"title":"How can I delete a deal in the pipeline view?","content":"<p>&lt;!-- ../../kb/pipeline-view/how-can-i-delete-a-deal-in-the-pipeline-view.md --&gt;</p>\\n<p>To delete a deal in the <strong>pipeline view</strong>, click and hold the deal you wish to delete and drag it to the <strong>“Delete”</strong> button at the bottom of the screen.</p>\\n<p>&lt;!-- :::tip\\n<strong>Note:</strong> You must be a deal admin or a regular user with the correct permission to delete deals in Fintesk. Account settings admins can provide permission for other users to delete deals by going to <strong>Settings &gt; Manage users &gt;</strong> <a href=\\"https://app.fintesk.com/settings/company_settings#permissions\\">Permission sets</a> and enabling the “<strong>Delete deals</strong>” option.\\n::: --&gt;\\n&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screen%20Capture%20on%202023-04-20%20at%2007-51-16.gif\\" alt=\\"1\\"> --&gt;</p>\\n<p><img src=\\"../../kb/pipeline-view/how-can-i-delete-a-deal-in-the-pipeline-view/hcida01.gif\\" alt=\\"hcida01\\"></p>\\n<p>:::tip\\n<strong>Note:</strong> Deleted items can be reopened up to 30 days after deletion. After 30 days, the items are permanently deleted and can\'t be accessed or reopened. Learn more about deleting items in Fintesk in <a href=\\"../../kb/getting-started/how-can-i-delete-items-in-fintesk\\">this article</a>.\\n:::</p>\\n","section":"How can I delete a deal in the pipeline view?","version":"current","path":"/kb/pipeline-view/how-can-i-delete-a-deal-in-the-pipeline-view","category":"default"},{"title":"How can I see deals in a different pipeline?","content":"<p>&lt;!-- ../../kb/pipeline-view/how-can-i-see-deals-in-a-different-pipeline.md --&gt;</p>\\n<p>&lt;!-- # How can I see deals in a different pipeline? --&gt;</p>\\n<p>To view another pipeline in your Fintesk account, click the dropdown menu and select the pipeline you want you view.</p>\\n<p>:::tip\\n<strong>Note:</strong> Regular users can only see pipelines they’ve been given access to in <strong><a href=\\"https://app.fintesk.com/settings/company/manage-users#visibility-groups?utm_source=fintesk-docs\\">Visibility groups</a></strong>.\\n:::</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screen%20Capture%20on%202023-04-27%20at%2015-15-49.gif\\" alt=\\"1\\"> --&gt;</p>\\n<p><img src=\\"../../kb/pipeline-view/how-can-i-see-deals-in-a-different-pipeline/hcisd01.gif\\" alt=\\"hcisd01\\"></p>\\n","section":"How can I see deals in a different pipeline?","version":"current","path":"/kb/pipeline-view/how-can-i-see-deals-in-a-different-pipeline","category":"default"},{"title":"Pipeline view","content":"<p>&lt;!-- ../../kb/pipeline-view/the-pipeline-view.md --&gt;</p>\\n<p>&lt;!-- # Pipeline view --&gt;</p>\\n<p>Fintesk helps you keep track of your deal progress by providing you with information about your deals based on what pipeline stage they occupy in your <strong>pipeline view</strong>.</p>\\n<p>The pipeline stages are defined by an admin user in the company Fintesk account. You can learn more about customizing your stages in <a href=\\"../../kb/pipelines/how-can-i-customize-my-pipeline-stages\\">this article</a>.</p>\\n<p><img src=\\"../../kb/pipeline-view/the-pipeline-view/tpv02.png\\" alt=\\"tpv02\\">\\n<img src=\\"../../kb/pipeline-view/the-pipeline-view/tpv01.jpeg\\" alt=\\"tpv01\\"></p>\\n<p>The pipeline view displays the deals owned by specific users. To filter for the deals owned by a specific user and understand their progress, click on the filter button – &quot;Everyone&quot; in the above screenshot – and select a user.</p>\\n<p>To better understand the state of the deals in your pipeline view, we suggest using the <strong><a href=\\"../../kb/pipeline-view/the-rotting-feature\\">Rotting feature</a></strong>.</p>\\n<p>&lt;!-- If you are just getting started with Fintesk, you can check out our &quot;<strong>Organize your sales data</strong>&quot; <a href=\\"https://www.pipedrive.com/academy/courses/organize-your-sales-data?ref=kb_article\\">Fintesk Academy course</a>. --&gt;</p>\\n","section":"Pipeline view","version":"current","path":"/kb/pipeline-view/","category":"default"},{"title":"Setting up the Rotting feature","content":"<!-- Note: Check out our “Never forget a follow-up” Academy course if you’re just getting started with Fintesk. -->\\n<!--  -->\\nTo define rotting periods for your pipeline stages:\\nGo to the pipeline view and hit the “pencil” icon.\\n<!--  -->\\nClick the “Rotting in (days)” toggle. Define the number of inactive days after which a deal in this stage is considered rotten. Click the “Save changes” in the upper right.\\n<!--  -->\\n\\n\\n","section":"The Rotting feature","version":"current","path":"/kb/pipeline-view/the-rotting-feature#setting-up-the-rotting-feature","category":"default"},{"title":"My deals are rotten! What do I do?","content":"You’ll know a deal has gone rotten by the red color on the deal tile in your pipeline view.\\n<!--  -->\\nIf your deal is rotten, you can restore it by:\\nScheduling a new activity for the deal\\nEditing any details of the deal, such as custom fields, expected close date, value, etc.\\n\\n","section":"The Rotting feature","version":"current","path":"/kb/pipeline-view/the-rotting-feature#my-deals-are-rotten-what-do-i-do","category":"default"},{"title":"Will future activities make deals go rotten?","content":"The Rotting feature does not look at the next activity date, so any deal that has an activity scheduled far into the future can still go rotten.\\nIn this situation, rethink what you consider for stages and activities in your company’s Fintesk account:\\nIf you set an extended rotting time (ex. 20 days) to accommodate activities far into the future, it can impact short-term goals and productivity\\nLikewise, if you set shorter rotting times, it can be difficult to manage and sort deals where the activities are due in the future\\nOne helpful strategy can be to create multiple pipelines or stages based on how soon you want certain activities completed or deals closed.\\n:::tip\\nNote: For more information about creating multiple pipelines you can check out this article, or read this piece for information about creating new stages.\\n:::\\n","section":"The Rotting feature","version":"current","path":"/kb/pipeline-view/the-rotting-feature#will-future-activities-make-deals-go-rotten","category":"default"},{"title":"How can I add a stage to my pipeline?","content":"<p>&lt;!-- ../../kb/pipelines/how-can-i-add-a-stage-to-my-pipeline.md --&gt;</p>\\n<p>&lt;!-- # How can I add a stage to my pipeline? --&gt;</p>\\n<p>To add a new stage to your pipeline, click the <strong>pencil</strong> icon next to your pipeline’s name or hover your cursor over a pipeline after opening the dropdown.</p>\\n<p>:::tip\\n<strong>Note:</strong> This action is only available to deal admin users or regular users with the required permission.\\n:::</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/add%20new%20stage%204.jpg\\" alt=\\"1\\"> --&gt;</p>\\n<p><img src=\\"../../kb/pipelines/how-can-i-add-a-stage-to-my-pipeline/hcias01.jpeg\\" alt=\\"hcias01\\"></p>\\n<p>Then click the <strong>“+”</strong> between any two stages to add a new one in that location.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/add%20stage%201.jpg\\" alt=\\"1\\"> --&gt;</p>\\n<p><img src=\\"../../kb/pipelines/how-can-i-add-a-stage-to-my-pipeline/hcias02.jpeg\\" alt=\\"hcias02\\"></p>\\n<p>You’ll see a new stage in the location you chose, where you can edit the name, probability and rotting settings.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/add%20stage%204.jpg\\" alt=\\"1\\"> --&gt;</p>\\n<p><img src=\\"../../kb/pipelines/how-can-i-add-a-stage-to-my-pipeline/hcias03.jpeg\\" alt=\\"hcias03\\"></p>\\n","section":"How can I add a stage to my pipeline?","version":"current","path":"/kb/pipelines/how-can-i-add-a-stage-to-my-pipeline","category":"default"},{"title":"Tips on how to come up with stages for your company","content":"Use the past indefinite tense Ex. “Meeting Agreed” instead of just “Meeting”.\\n\\n\\nCreate stages that correspond to the customers’ buying process What would their buying process look like, What has to happen in order for them to buy from you?\\n\\n\\nRevise your stages later If some stages seem confusing, you can rename them, delete them or add new ones for clarity.\\n<!-- :::tip\\nNote: Learn the nine essential sales stages for effective sales cycle management in this blog post.\\n::: -->\\n\\n","section":"How can I customize my pipeline stages?","version":"current","path":"/kb/pipelines/how-can-i-customize-my-pipeline-stages#tips-on-how-to-come-up-with-stages-for-your-company","category":"default"},{"title":"How to edit your pipeline stages","content":"Go to the pipeline view and click the pencil icon to the right of the pipeline name.\\n<!--  -->\\n\\nFrom here, you can edit stage attributes like name, probability and rotting days.\\n<!--  -->\\n\\nYou can also add a new stage using the “+” or delete a stage by clicking “Delete Stage” at the bottom of the screen.\\n<!--  -->\\n\\n","section":"How can I customize my pipeline stages?","version":"current","path":"/kb/pipelines/how-can-i-customize-my-pipeline-stages#how-to-edit-your-pipeline-stages","category":"default"},{"title":"To add a new pipeline to your Fintesk account:","content":":::tip\\nNote: There is currently no limit on the number of pipelines you can add to your account.\\n:::\\nTo create a pipeline:\\nLearn more about pipeline management software\\nGo to the pipeline view and click on the pipeline dropdown.\\nClick “+ New pipeline”.\\n<!--  -->\\nThe pipeline is then added to your account and you can now start editing its stages. Once the stages are to your specification, hit “Save“.\\n<!--  -->\\n\\n\\n","section":"How can I have multiple pipelines?","version":"current","path":"/kb/pipelines/how-can-i-have-multiple-pipelines#to-add-a-new-pipeline-to-your-fintesk-account","category":"default"},{"title":"When should I use multiple pipelines?","content":"Using multiple pipelines can be quite useful in certain situations. For instance:\\nYou may be a company that offers different kinds of products that may need their own proprietary stages during the closure of a deal.\\nYou may have both a product as well as a service that you sell in your company. The service could easily have a longer pipeline.\\nYou can have pipeline-specific custom fields, to keep your processes and information well categorized.\\nIt\'s not suggested for:\\nCategorizing your deals by location or industry type (or anything else) if the stages are the same. We suggest using custom fields instead.\\nSeparating deals by a salesperson. That is already done automatically by Fintesk through the owner field.\\n<!-- - To track the delivery of sold items after they’re won. Instead, you can use the Projects feature. -->\\nIn this way, you will have a chance to see the entire pipeline in one view, but you can also create filters to see any segment of the pipeline that you wish.\\n:::tip\\nNote: It’s not possible to get a combined view of all pipelines, even if the stage names are the same. Within the Fintesk database, those pipelines and stages are still separated.\\n:::\\n","section":"How can I have multiple pipelines?","version":"current","path":"/kb/pipelines/how-can-i-have-multiple-pipelines#when-should-i-use-multiple-pipelines","category":"default"},{"title":"Can I add extra fields to the \\"Add new product\\" modal?","content":"<p>&lt;!-- ../../kb/products/can-i-add-extra-fields-to-the-add-new-product-modal.md --&gt;</p>\\n<p>&lt;!-- # Can I add extra fields to the &quot;Add new product&quot; modal? --&gt;</p>\\n<p>&lt;!-- <strong>Note:</strong> The <strong>Products</strong> feature is one of the many useful features of Fintesk’s Advanced, Professional and Enterprise plans. To learn how to switch plans, click <a href=\\"billing/your-fintesk-subscription-plan/how-can-i-switch-to-a-different-fintesk-plan-or-change-my-billing-frequency\\">here</a>. --&gt;</p>\\n<p>If you would like to have any of your custom product fields appear in the <strong>Add new product</strong> modal, go to <strong>Company Settings &gt; Data fields &gt; <a href=\\"https://app.fintesk.com/settings/company/fields#table_column/edit/products?utm_source=fintesk-docs\\">Product</a></strong> and click on the field you would like to appear in the <strong>Add new dialog</strong>. You can then tick the &quot;<strong>Appears in &quot;Add&quot; view</strong>&quot; option and the field will be accessible when adding a new product to Fintesk.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screen_Capture_on_2020-09-01_at_15-43-31.gif\\" alt=\\"1\\"> --&gt;</p>\\n<p><img src=\\"../../kb/products/can-i-add-extra-fields-to-the-add-new-product-modal/ciaef01.gif\\" alt=\\"ciaef01\\"></p>\\n","section":"Can I add extra fields to the \\"Add new product\\" modal?","version":"current","path":"/kb/products/can-i-add-extra-fields-to-the-add-new-product-modal","category":"default"},{"title":"Can I have one product in different price variations?","content":"You can create different price points for the same product with our Price variations feature. This feature can also be used as a way to create general variations for the same product, as you can create product variations with different names, unit prices, currencies and costs per unit.\\nVariations can be configured from the detail view of the product in question.\\n<!--  -->\\nOnce you add a variation of the product, you will be able to select this variation when linking this product to a deal.\\n<!--  -->\\n\\n","section":"Can I have one product in different price variations?","version":"current","path":"/kb/products/can-i-have-one-product-in-different-price-variations","category":"default"},{"title":"Can I import products and automatically link them to deals?","content":"<p>&lt;!-- ../../kb/products/can-i-import-products-and-automatically-link-them-to-deals.md --&gt;</p>\\n<p>&lt;!-- # Can I import products and automatically link them to deals? --&gt;</p>\\n<p>While you can <a href=\\"../../kb/importing-data/importing-data-into-fintesk-with-spreadsheets\\">import</a> a list of <a href=\\"../../kb/products\\">products</a> into Fintesk, unfortunately, you cannot attach these products to deals through the import process.</p>\\n<p>Currently, this can only be done manually, or through our <a href=\\"../../fintesk/api/v1\\">API</a> if you are a skilled developer or have dedicated engineering staff at your disposal.</p>\\n","section":"Can I import products and automatically link them to deals?","version":"current","path":"/kb/products/can-i-import-products-and-automatically-link-them-to-deals","category":"default"},{"title":"Adding products to deals","content":"<!-- You can add products directly to deals in the products list view by clicking on the checkbox next to a product and then clicking on the “Attach to deal” button.\\nYou can select more than one product if you want to bulk-add products to a deal.\\n-->\\nIn the window that appears, enter the title of the deal that you want to link your product to. The price and currency will default to the price you have saved in your product, but you can customize this to another currency and price before linking it to the deal.\\n<!--  -->\\n\\n:::tip\\nNote: Any custom prices created in this window will only apply for that deal and not be saved as a price entry in the product’s detail/list view.\\n:::\\nClick on ”Add product” to attach more than one product to the chosen deal at a time.\\nYou can delete products from the deal by clicking on the trash bin icon on the right-hand side of each entry.\\n<!--  -->\\n\\nAnother way of linking products to deals is by clicking on ”+ Products” to any deal’s detail view.\\n<!--  -->\\n\\n\\n","section":"How can I link products to a deal?","version":"current","path":"/kb/products/how-can-i-link-products-to-a-deal#adding-products-to-deals","category":"default"},{"title":"Tax options","content":"\\n:::tip\\nNote: Any tax values must be added manually, either in the product details or in the Add products window of the deal.\\n:::\\n","section":"How can I link products to a deal?","version":"current","path":"/kb/products/how-can-i-link-products-to-a-deal#tax-options","category":"default"},{"title":"Tax inclusive","content":"If you select ”Tax inclusive” or \\"Taxes included\\" for your products, the tax percentage will already be included in the price.\\n<!--  -->\\n:::tip\\nNote: The product price and the deal value include tax.\\n:::\\n<!-- Tax exclusive\\nNote: The tax exclusion feature is currently in beta and available to a closed group of users. It will be released to more users at a later date.\\nIf you select ”Tax exclusive” for your products, the tax will **not** be included in the subtotal. The tax percentage you enter into the tax field will be reflected in the total.\\n\\n:::tip\\nNote: The product price and the deal value exclude tax.\\n::: -->\\n","section":"How can I link products to a deal?","version":"current","path":"/kb/products/how-can-i-link-products-to-a-deal#tax-inclusive","category":"default"},{"title":"No tax","content":"If you select ”No tax” or \\"No taxes\\" for your products, no tax will be added to your product total.\\n<!--  -->\\n:::tip\\nNote: Each deal can only have products in one type of currency (e.g., USD or CAD, not both). If you wish to add a variation of the product in the same type of currency, you can look into the Price Variations feature.\\n:::\\n","section":"How can I link products to a deal?","version":"current","path":"/kb/products/how-can-i-link-products-to-a-deal#no-tax","category":"default"},{"title":"Find the Products feature","content":"The Products feature is available in all plans.\\n<!-- and you can enable or disable it by going to Tools and apps > Products. Here, you can also select the default tax setting. -->\\n<!--  -->\\n<!-- Once you enable it, click on the Products icon on the main navigation bar. -->\\nClick on the Products icon on the main navigation bar.\\n<!--  -->\\n\\n\\n","section":"Products","version":"current","path":"/kb/products#find-the-products-feature","category":"default"},{"title":"Add new products","content":"\\nTo add a product to your Fintesk account, go to the Products tab found on the top side of the Fintesk app and click “+ Add Product\\".\\n<!--  -->\\n:::tip\\nNote: “Name” and “Unit price“ are mandatory fields.\\n:::\\nOnce you save the product, you’ll be able to edit these additional fields in your products’ detail view or list view.\\nActive\\nCategory\\nDescription\\nName\\nOwner\\nPrice\\nProduct code\\nTax\\nUnit\\nUnit prices\\nVisibility\\nProduct custom fields\\n<!-- You can also add new products in the “Add deal“ window when adding new deals to your Fintesk account.\\n\\nNote: To add a new category, type the name of your category in the category search box and click on “Add as new category”. You must be a \\"global permissions\\" admin to add categories. -->\\n\\n","section":"Products","version":"current","path":"/kb/products#add-new-products","category":"default"},{"title":"Products list view","content":"In the list view you will be able to see your added products and edit product details directly.\\nYou can filter for products alphabetically in the top left corner of the screen or create custom filters.\\n<!--  -->\\nYou will see product-type fields as an option within your filters. This allows you to narrow down your searches or export your data according to product-specific fields.\\n<!--  -->\\n\\n<!-- To bulk edit your products, you can click on the checkboxes to the left of your products and select the field you want to edit in the bulk edit panel that appears on the right side.\\n-->\\n<!-- To delete products, select your products and click on the trash can icon that appears at the top of the Products page. -->\\n<!--  -->\\n\\n\\n","section":"Products","version":"current","path":"/kb/products#products-list-view","category":"default"},{"title":"Product detail view","content":"\\nIf you click on the product’s name from the products list view, you will be taken to the product’s detail page where you can view and edit information related to your product.\\n<!--  -->\\n\\n","section":"Products","version":"current","path":"/kb/products#product-detail-view","category":"default"},{"title":"Edit the product’s details","content":"To edit the values of the fields, click on the pencil icon in the product details window.\\n<!--  -->\\n\\n<!-- If you want to add product custom fields in this section click on More actions > Customize fields. -->\\n<!-- \\n -->\\n","section":"Products","version":"current","path":"/kb/products#edit-the-products-details","category":"default"},{"title":"View and add product prices","content":"The prices tab will show you all of the price options for that product. Each product can have more than one price listed at a time. To edit or delete any existing product prices, you can hover over the price and click on the pencil or trash can icon.\\n<!--  -->\\n\\nUnit price – The price of each unit sold\\nCost per unit – Cost related to each sold unit of the product\\nDirect cost – Cost related to the development or production of the product\\n:::tip\\nNote: Only the unit price will be displayed in the products list view and detail view. The cost per unit and direct cost fields are purely notational.\\n:::\\nIf you click on the “+ Add Price” button, you can add a new price for your product.\\n<!--  -->\\n:::tip\\nNote: You will only be able to add one price entry for each type of currency.\\n:::\\n<!-- ### View deals linked to the product\\nThe deals tab will give a list of all of the deals that currently have that product linked. You can filter to view by deal status in the row above the list. You can learn how to link products to deals in this article.\\n\\nTo adjust the columns in your deals list, you can click on the gear icon on the right side and adjust your columns accordingly.\\nTo export the list you see to a spreadsheet, you can click on the “Export” button. -->\\n<!-- ### View and upload files\\nIn the files tab, you can see any files that have been uploaded to this product, as well as upload additional files from your device.\\n\\nIf you click on the \\"[...]\\" button you can add a description, download, or delete your file.\\n-->\\n\\n","section":"Products","version":"current","path":"/kb/products#view-and-add-product-prices","category":"default"},{"title":"Product-specific fields","content":"The products feature includes multiple data fields specific to products, which can optimize your experience.\\n<table>\\n<tr>\\n<td>Field name</td>\\n<td>Definition</td>\\n<td>Example</td>\\n</tr>\\n<tr>\\n<td>Price</td>\\n<td>The monetary value assigned to one unit of a product</td>\\n<td>My company sells pants, and the price of blue jeans is $35 a pair.</td>\\n</tr>\\n<tr>\\n<td>Product code</td>\\n<td>A custom code used as shorthand to identify products</td>\\n<td>The product code for blue jeans is 1827.</td>\\n</tr>\\n<tr>\\n<td>Tax %</td>\\n<td>A percentage taken from the total cost of an order and added on as an additional fee</td>\\n<td>The price of jeans is $16, with a 10% tax rate, so the total cost is $17.6</td>\\n</tr>\\n<tr>\\n<td>Unit</td>\\n<td>A measurement or standard amount of physical quantity for a product</td>\\n<td>A pair of jeans represents one unit, but a box of jeans is four units.</td>\\n</tr>\\n<tr>\\n<td>Unit prices</td>\\n<td>The price of a product per unit</td>\\n<td>A box of jeans is $120, and there are four pairs in a box, so the unit price is $30 for a pair, but sold at $40 individually.</td>\\n</tr>\\n</table>\\n\\n<!-- ## Export products\\nNote: This action is only available to users with deals and global admin permissions enabled.\\nYou can export your product catalog and the products linked to deals by going to Tools and apps > Export data.\\nSelect “Products\\" and one of the export options:\\nEntire product catalog\\nOnly products added to deals\\n\\nThen, click on either “CSV“ or “Excel”. Your export file will appear in the “Generated exports“ list. To download the file, click on the cloud icon in the “Available until“ column. -->\\n","section":"Products","version":"current","path":"/kb/products#product-specific-fields","category":"default"},{"title":"Where do I activate or deactivate individual products?","content":"<p>&lt;!-- # Where do I activate or deactivate individual products? --&gt;</p>\\n<p>If you would like to deactivate or activate <strong>Products</strong> in your Fintesk account, you can do so by going into the <strong>detail view</strong> of the specific product and clicking the &quot;<strong>Deactivate</strong>&quot; button found to the right of the screen.</p>\\n<p>&lt;!-- :::tip\\n<strong>Note:</strong> The <strong>Products</strong> feature is one of the many useful features of Fintesk’s Essential, Advanced, Professional and Enterprise plans. To learn how to switch plans, click <a href=\\"billing/your-fintesk-subscription-plan/how-can-i-switch-to-a-different-fintesk-plan-or-change-my-billing-frequency\\">here</a>.\\n::: --&gt;</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screen_Shot_2019-07-31_at_3.48.04_PM.png\\" alt=\\"1\\"> --&gt;</p>\\n<p><img src=\\"../../kb/products/where-do-i-activate-or-deactivate-individual-products/wdia01.jpeg\\" alt=\\"wdia01\\">\\nIf you would like to reactivate any previously-deactivated product, go into the <strong>detail view</strong> of that deactivated product, and click the &quot;<strong>Activate</strong>&quot; button found there.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screen_Shot_2019-07-31_at_3.47.50_PM.png\\" alt=\\"1\\"> --&gt;</p>\\n<p><img src=\\"../../kb/products/where-do-i-activate-or-deactivate-individual-products/wdia02.jpeg\\" alt=\\"wdia02\\"></p>\\n<p>&lt;!-- This can also be done to many products at once, by utilizing the <strong>Bulk edit</strong> functions of the list view within the <strong>Products</strong> feature. --&gt;</p>\\n","section":"Where do I activate or deactivate individual products?","version":"current","path":"/kb/products/where-do-i-activate-or-deactivate-individual-products","category":"default"},{"title":"Can Fintesk be used offline?","content":"<p>&lt;!-- # Can Fintesk be used offline? --&gt;</p>\\n<p>Fintesk doesn\'t have a separate desktop app and can only be used online within a web browser.</p>\\n<p>&lt;!-- However, both the Fintesk iOS and Android mobile apps allow for working offline. --&gt;</p>\\n<p>&lt;!-- Any changes made without an internet connection to the mobile apps will be updated in the Fintesk database once you have connected to the internet again. --&gt;</p>\\n<p>&lt;!-- :::tip\\n<strong>Note</strong>: Offline and online modes can\'t be toggled on mobile apps, they will default to online mode if there is an internet connection available. If your device is connected to the internet but your mobile app is still in offline mode, please contact our <a href=\\"https://fintesk.com/es/soporte/contactanos/?utm_source=fintesk-docs\\">support team</a>.\\n::: --&gt;</p>\\n","section":"Can Fintesk be used offline?","version":"current","path":"/kb/troubleshooting/can-fintesk-be-used-offline","category":"default"},{"title":"How can I take a screenshot?","content":":::tip\\nNote: When taking a screenshot, please be sure to include as much detail as possible, particularly making sure the URL is visible at the top of the screen, the user logged in is visible in the top right corner of the screen and if any filters are applied the filter menu is visible on applicable pages (on the pipeline or list views, for example).\\n:::\\nWhen working with Fintesk, you may need to take a screenshot of a specific question or issue you have within the Fintesk app.\\nIn order to best serve you, we have provided information on how to take screenshots within the operating systems or apps that support Fintesk.\\n:::tip\\nNote: When sending your screenshot to our support team, please paste the image directly into the chat or email. This will save time for you and allow our support team to view your screenshot immediately.\\n:::\\n\\n","section":"How can I take a screenshot?","version":"current","path":"/kb/troubleshooting/how-can-i-take-a-screenshot","category":"default"},{"title":"1. Windows desktop operating systems","content":"To take a screenshot on a Windows desktop operating system, press the \\"Print screen\\" button on your keyboard.\\nThe exact location of this button varies from keyboard to keyboard – and between PC and laptop – but it is usually quite easy to find and is often abbreviated as Print Scrn, Prnt Scrn, or Prt Scrn. With most PC keyboards it can be found on the top row of keys in the row after F12.\\nOnce you have pressed this button, open up the Paint program in Windows. This can be done by searching using the Find program function or by browsing through your Programs list.\\nOnce the Paint program has been opened, press CTRL+V to paste the screenshot within Paint.\\n<!--  -->\\n\\nOnce done, save this pasted screenshot to your computer.\\nTo save, click the \\"Save\\" button under the File menu in the top left of the paint menu.\\n<!--  -->\\n\\nOnce saved, you can attach the saved image to an email and send it over.\\nAlternatively, if your screenshot contains data you do not wish to share, you can crop the picture within the Paint program before sending it.\\nTo do so, first, click the \\"Selection\\" box from the menu at the top of the Paint program.\\n<!--  -->\\n\\nOnce done, draw a box around what you would like to remain in the image, then click \\"Crop\\" from the same menu:\\n<!--  -->\\n\\nThis will remove everything from the image except the area you have selected.\\nKeep in mind that, in some cases, it is very useful for us to see the web address or URL when trying to help you solve certain issues. In those situations, we may ask that the screenshot include that information to help us troubleshoot or diagnose issues.\\n\\n","section":"How can I take a screenshot?","version":"current","path":"/kb/troubleshooting/how-can-i-take-a-screenshot#1-windows-desktop-operating-systems","category":"default"},{"title":"2. macOS desktop operating systems","content":"In order to take a screenshot with a Mac, just press CMD+SHIFT+3.\\nDoing so will save a screenshot of your full screen to your desktop. From there, you can just attach that screen to an email and send it over!\\nAlternatively, if you have some data you do not wish to share with Fintesk, you can take a screenshot of a specific area within your screen.\\nTo highly a specific selection, press CMD+SHIFT+4 and draw a box around the information that you wish to save in your screenshot.\\nKeep in mind that, in some cases, it is very useful for us to see the web address or URL when trying to help you solve certain issues. In those situations, we may ask that the screenshot include that information, to help us troubleshoot or diagnose issues.\\n<!-- ---\\n","section":"How can I take a screenshot?","version":"current","path":"/kb/troubleshooting/how-can-i-take-a-screenshot#2-macos-desktop-operating-systems","category":"default"},{"title":"3. iOS mobile operating systems (iPad/iPhone)","content":"To take a screenshot with your iPhone, press both the Power button on the right side and the Volume Up button on the left at the same time.\\nTo take a screenshot with your iPad, press both the Power button (either at the top or on the side) and the Home button (the round button on the front) at the same time.\\nThe screenshot will then be saved into your Photos gallery and is ready to attach to an email and send to us. You can find it under the \\"All photos\\" folder.\\n\\n","section":"How can I take a screenshot?","version":"current","path":"/kb/troubleshooting/how-can-i-take-a-screenshot#3-ios-mobile-operating-systems-ipadiphone","category":"default"},{"title":"4. Android mobile operating systems","content":"With most Android devices, pressing the Power and Volume Down buttons together will take a screenshot of the contents of the screen.\\nThe screenshot will then be saved into your Photos gallery, ready to be sent to us. The specific folder that the screenshot will be saved in will depend on the device you are using.\\nIf you cannot find the picture – or if pressing Power and Volume Down doesn\'t take a screenshot – it may be best to search the internet for specific instructions for your phone model. -->\\n","section":"How can I take a screenshot?","version":"current","path":"/kb/troubleshooting/how-can-i-take-a-screenshot#4-android-mobile-operating-systems","category":"default"},{"title":"Google Chrome","content":"In a Chrome window, click \\"...\\" > Delete Browsing Data.\\n<!--  -->\\n\\nIn the window that appears, make sure that Cookies and other site data and Cached images and files are selected before hitting Clear data.\\n<!--  -->\\n\\n\\n","section":"How do I clear my browser\'s cache and cookies?","version":"current","path":"/kb/troubleshooting/how-do-i-clear-my-browser-s-cache-and-cookies#google-chrome","category":"default"},{"title":"Firefox","content":"In a Firefox window, click on the bookshelf icon in the top right corner > Settings:\\n<!--  -->\\nthen go to Privacy & Security and scroll down to the Clear data option and click on it:\\n<!--  -->\\n\\n\\n","section":"How do I clear my browser\'s cache and cookies?","version":"current","path":"/kb/troubleshooting/how-do-i-clear-my-browser-s-cache-and-cookies#firefox","category":"default"},{"title":"Safari","content":"In a Safari window, click Safari in the menu bar and go to Preferences:\\n<!--  -->\\n\\nIn the window that appears, select Advanced and then make sure the Show Develop menu box at the bottom is checked:\\n<!--  -->\\n\\nAfter that, find the Develop tab in your menu bar, then select Empty Caches:\\n<!--  -->\\n\\n\\n","section":"How do I clear my browser\'s cache and cookies?","version":"current","path":"/kb/troubleshooting/how-do-i-clear-my-browser-s-cache-and-cookies#safari","category":"default"},{"title":"Internet Explorer","content":":::tip\\nNote: Internet Explorer was retired on June 15th, 2022. While you can still use previous versions, Microsoft recommends upgrading to the Edge browser. For more information, you can check out their article on the topic.\\n:::\\nIn an Internet Explorer window, click on the gear icon in the top right corner and go to Safety > Delete browsing history.\\n<!--  -->\\n\\nIn the window that appears, make sure Preserve Favorites website data is unselected and select \\"Temporary Internet files and website files\\" and \\"Cookies and website data\\". You can then hit \\"Delete\\" to confirm.\\n<!--  -->\\n\\n\\n","section":"How do I clear my browser\'s cache and cookies?","version":"current","path":"/kb/troubleshooting/how-do-i-clear-my-browser-s-cache-and-cookies#internet-explorer","category":"default"},{"title":"If you use Microsoft Edge","content":"In a Microsoft Edge window, click on the more icon (...). After this is selected, click on the History tab > Clear Browsing Data.\\n<!--  -->\\n\\nIn the window that appears, select the \\"Cookies and saved website data\\" and \\"Cached data and files\\" options. You can then click the \\"Clear now\\" button to confirm.\\n<!--  -->\\n\\n\\n","section":"How do I clear my browser\'s cache and cookies?","version":"current","path":"/kb/troubleshooting/how-do-i-clear-my-browser-s-cache-and-cookies#if-you-use-microsoft-edge","category":"default"},{"title":"Clearing cache for one page","content":"Sometimes you need to clear backend data due to performance issues, but you will not want to delete all of that data from your browser.\\nTo clear cache for a single webpage, start by navigating to the \\"...\\" in the top right corner of your browser, then select More Tools > Developer Tools:\\n<!--  -->\\n\\nThis will open up your Inspect menu, from which you can select the console tab. Once selected, keep the console tab open, and right-click the refresh icon in the top left of your web page.\\nThis will reveal the option to Empty Cache and Hard Reload:\\n<!--  -->\\n\\n:::tip\\nNote: This method for cache resetting is specific to Google Chrome.\\n:::\\n","section":"How do I clear my browser\'s cache and cookies?","version":"current","path":"/kb/troubleshooting/how-do-i-clear-my-browser-s-cache-and-cookies#clearing-cache-for-one-page","category":"default"},{"title":"Browser console information","content":"The browser console provides information on webpage errors that may not have been seen on the Fintesk end.\\nTo open the browser console on most browsers, you can:\\nRight-click your mouse\\nClick “Inspect/Inspect Element”\\nClick “Console”\\nIf there are page errors, they’ll appear in red and should be included in any screenshots you provide for the support team. Fintesk doesn’t provide source maps (console warnings in yellow), so please hide them.\\nFor additional information on how to open your browser console, check out this link.\\n<!--  -->\\n:::tip\\nNote: Please ensure the Console tab is selected when taking the screenshot.\\n:::\\n\\n","section":"How do I open my browser console?","version":"current","path":"/kb/troubleshooting/how-do-i-open-my-browser-console#browser-console-information","category":"default"},{"title":"Browser network information","content":"Browser network information highlights any internet connection issues causing errors.\\nTo open your network tab on most browsers, you can:\\nRight-click your mouse\\nClick “Inspect/Inspect Element”\\nClick “Network”\\nAfter switching to the Network tab, reload the page to record the activity in the network log before taking the screenshot.\\n<!--  -->\\nWhen taking a screenshot of the browser network tab, please capture any errors that appear.\\n","section":"How do I open my browser console?","version":"current","path":"/kb/troubleshooting/how-do-i-open-my-browser-console#browser-network-information","category":"default"},{"title":"For general troubleshooting","content":"\\nClear the cache and cookies of your browser.\\nTest to see if the issue persists in an incognito window and other browsers.\\nReach out to support here.\\n\\n","section":"Troubleshooting-> Fintesk web app","version":"current","path":"/kb/troubleshooting/troubleshooting-fintesk-web-app#for-general-troubleshooting","category":"default"},{"title":"If Fintesk is being slow","content":"Refresh the page of your browser.\\nLog in and log out of your Fintesk account.\\nMake sure your browser is updated to the latest version. You can see if you are on the latest version of your browser here.\\nClear the cache and cookies of your browser.\\nLog in to Fintesk with another browser. You can read about what browsers work best with Fintesk in this article.\\nConnect your computer to another network. This will rule out any network issues that could be causing the slowness.\\nLog in to Fintesk on another computer. This will rule out any device issues that could be causing the slowness.\\n\\n","section":"Troubleshooting-> Fintesk web app","version":"current","path":"/kb/troubleshooting/troubleshooting-fintesk-web-app#if-fintesk-is-being-slow","category":"default"},{"title":"If your data appears to be missing","content":"Check to see if you have any filters applied to your Fintesk account.\\n<!-- \\n -->\\n\\n<!-- - Clear out Pipeline View filters and select the correct pipeline:\\n -->\\n\\n\\nClear the cache and cookies of your browser.\\n\\n\\nCheck to see if any browser extensions are interacting with Fintesk. By logging in to Fintesk with an incognito window, you will be able to see if one of your extensions is causing any issues.\\nIf you are still having issues with your Fintesk account, reach out to our support team here.\\n","section":"Troubleshooting-> Fintesk web app","version":"current","path":"/kb/troubleshooting/troubleshooting-fintesk-web-app#if-your-data-appears-to-be-missing","category":"default"},{"title":"Which browser is best for Fintesk?","content":"<p>&lt;!-- ../../kb/troubleshooting/which-browser-is-best-for-fintesk.md --&gt;</p>\\n<p>&lt;!-- # Which browser is best for Fintesk? --&gt;</p>\\n<p><a href=\\"https://www.google.com/chrome/\\">Google Chrome</a> and <a href=\\"https://www.microsoft.com/en-us/edge\\">Edge</a> will provide the best experiences when using Fintesk. We recommend staying away from common default browsers, such as Internet Explorer and Safari, as they may cause performance issues.</p>\\n<p>It\'s important to make sure your browser is on the latest version for optimal rendering. You can view the following documentation to learn how to update the recommended browsers:</p>\\n<ul>\\n<li><a href=\\"https://support.google.com/chrome/answer/95414?co=GENIE.Platform%3DDesktop&amp;hl=en\\">Google Chrome</a></li>\\n<li><a href=\\"https://support.microsoft.com/en-us/topic/microsoft-edge-update-settings-af8aaca2-1b69-4870-94fe-18822dbb7ef1\\">Edge</a></li>\\n</ul>\\n","section":"Which browser is best for Fintesk?","version":"current","path":"/kb/troubleshooting/which-browser-is-best-for-fintesk","category":"default"},{"title":"Global User Management","content":"Fintesk\'s Global User Management gives you control over the access rights that users have, under five specific categories: Deals app, \\"Global Permissions\\", and \\"Account Settings\\".\\n\\n","section":"Global User Management","version":"current","path":"/kb/users-and-permissions/global-user-management","category":"default"},{"title":"Access rights","content":"To view the access rights of users in your account, go to Company Settings > Manage Users\\n<!-- and, to the right of each user\'s name, you will see five subheaders representing each category. -->\\nThe access rights for each category are the following:\\n<!-- -  – Admin access\\n– Regular user access\\n\\n\\n – No access -->\\n\\n\\nAdmin access\\n\\n\\nRegular user access\\n\\n\\nNo access\\nTo change access for a user, click on “...\\" to the far right of the user, then select Edit access rights.\\n<!--  -->\\nThis will open up the Access rights panel, where you will see the options you have for assigning access or editing permissions.\\nYou can click on the blue check boxes to give access, or use the available drop-down menu to edit the existing permissions.\\n<!--  -->\\nOnce you have made your desired changes, click the green Edit button at the bottom of the panel and Confirm the changes.\\n\\n","section":"Global User Management","version":"current","path":"/kb/users-and-permissions/global-user-management#access-rights","category":"default"},{"title":"Deals app","content":"\\"Deals access\\" allows you to use Fintesk’s core sales functionality.\\nBy having access to deals, you’ll have access to your pipeline, deals, contacts and all related features. Within deals, users are assigned visibility groups and permission sets to control what they can see and do in the account.\\n\\"Deals access\\" requires a paid seat in your account. Any user added with \\"deals access\\" will be assigned a permission set.\\n<!-- and visibility group. -->\\n<!--  -->\\nUsers with \\"deals access\\" will have access to our deals section with the pipeline.\\n<!-- , as well as our Leads Inbox. -->\\n<!-- --- -->\\n<!-- ## Projects app\\nThis category grants access to project management features and their data. This category requires \\"deals app access\\" enabled.\\n\\nNote: Project management is currently free to test in beta to a closed group of users and will be released to more users at a later date. After the beta period ends it will require an additional subscription. -->\\n<!-- --- -->\\n<!-- ## Campaigns app\\nAllow your users to send stunning email campaigns by enabling access to this feature. This category requires \\"Deals app access\\" enabled.\\n-->\\n<!--\\nNote: Campaigns by Fintesk is available as a paid add-on. -->\\n\\n","section":"Global User Management","version":"current","path":"/kb/users-and-permissions/global-user-management#deals-app","category":"default"},{"title":"Global permissions","content":"<!-- This category grants permission to the rest of the shared functionalities (such as contacts, Insights, activities, workflow automations, importing, etc.) to enhance the cross-product experience. -->\\nThis category grants permission to the rest of the shared functionalities (such as contacts, activities, importing, etc.) to enhance the cross-product experience.\\n\\"Global permissions\\" are automatically applied if the user selected has access to at least one app.\\n<!--  -->\\n\\n","section":"Global User Management","version":"current","path":"/kb/users-and-permissions/global-user-management#global-permissions","category":"default"},{"title":"Account settings","content":"\\"Account settings\\" access rights give you the ability to view and edit your company billing details, security settings, company settings, user management and personal settings.\\n<!--  -->\\n<!-- Note: Users with \\"account settings\\" only will not have access to deals, so they will not see deals, leads, pipelines and other core features of Fintesk in the web app and won’t be able to login to the mobile app. -->\\n:::tip\\nNote: Users with \\"account settings\\" only will not have access to deals, so they will not see deals, pipelines and other core features of Fintesk in the web app.\\n:::\\nIf the \\"deals access\\" is not enabled, the \\"account settings\\" user will have a free seat in the account.\\nIf you would like to assign \\"deals access\\" to a user with \\"account settings\\" access, you can do so by enabling both access types for that user. Please be aware that, as you’re adding \\"deals access\\", you’ll be adding a seat to your subscription.\\n","section":"Global User Management","version":"current","path":"/kb/users-and-permissions/global-user-management#account-settings","category":"default"},{"title":"To invite new users","content":"Go to Settings > Manage Users > Users. From here, you can add other member\'s team to your account by clicking the “+ Add Users” button, found on the right side of the screen.\\n<!--  -->\\n\\nThe “Add users” box will then open, where you can enter the email address of the person you wish to add and click “Preview.” To add multiple users, submit their email addresses separated by commas.\\n<!--  -->\\n\\n<!-- If you select a user in the preview, you will see the Edit Access panel, where you can choose the permissions for your prospective user. -->\\n\\n","section":"How can I add a user?","version":"current","path":"/kb/users-and-permissions/how-can-i-add-a-user#to-invite-new-users","category":"default"},{"title":"After you invite new users","content":"If your invited user hasn’t accepted your invitation, it can be canceled or resent.\\nClick on the Invited tab, select any pending invitations, then select the cancel or resend options.\\n<!-- You can also edit permissions for prospective users from this screen. -->\\n<!--  -->\\n\\nIf your invited users:\\nHaven’t signed up for Fintesk before, they’ll receive an invitation email from Fintesk. This email link will allow them to set their password and sign into the company Fintesk account that you’ve invited them to join.\\n<!-- - Have signed up for Fintesk before and are still members of another Fintesk account, they’ll receive an email notification that they’ve been added to your account. They’ll use the same login credentials they’ve already set and can switch between the companies using the “Switch company” option in the upper-right corner of the app. -->\\n<!--  -->\\n:::tip\\nNote: Fintesk is billed by the number of active seats in the company Fintesk account. Adding a user will increase the cost of your Fintesk subscription if doing so increases the number of seats in the account.\\n:::\\n","section":"How can I add a user?","version":"current","path":"/kb/users-and-permissions/how-can-i-add-a-user#after-you-invite-new-users","category":"default"},{"title":"Deactivating a user","content":"To deactivate a user from Fintesk, go to Settings > Manage users > Users and access. To the right-hand side of each user, you’ll see a “...“. Click on the “Deactivate“ option to deactivate the user you want to remove from your Fintesk account.\\nWhen you deactivate a user, you’ll also see the data that is currently owned by that user so that you can reassign the items if necessary. You’ll also see a reminder to remove any unused seats.\\n<!--  -->\\n\\n\\n","section":"How can I deactivate, reactivate or delete a user?","version":"current","path":"/kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user#deactivating-a-user","category":"default"},{"title":"Removing unused seats","content":"If you opt to remove unused seats during user deactivation, you’ll need to confirm the change in the billing checkout.\\nYou can learn about the difference between a billed seat and a Fintesk user in this article.\\n<!-- \\n -->\\nIf you remove this unused seat, you’ll no longer have an active seat to add a user to. You’ll be billed for the decreased seat amount from your next invoice date. You can learn about the difference between a billed seat and a Fintesk user in this article.\\nIf you don’t remove this unused seat, then that seat still exists in your account and billing remains unchanged. This allows you to add another user to replace the deactivated user easily without having to process multiple billing transactions.\\n:::tip\\nNote: Fintesk billing is based on active seats. Deactivating users only reduces the costs of your Fintesk subscription if the seat numbers decrease. You can read more about the billing process in this article.\\n:::\\n\\n","section":"How can I deactivate, reactivate or delete a user?","version":"current","path":"/kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user#removing-unused-seats","category":"default"},{"title":"Reactivating a user","content":"Any deactivated user can be reactivated by going to the Deactivated tab and clicking “Reactivate” next to the target user.\\n<!--  -->\\n\\n","section":"How can I deactivate, reactivate or delete a user?","version":"current","path":"/kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user#reactivating-a-user","category":"default"},{"title":"Changes in active seat count","content":"If an open seat exists, reactivated users fill it without affecting the billing\\nIf reactivating a user adds a new seat to your account, your billed seat count will increase, billing you immediately for that new seat\\nYou can read more about this billing process in this article.\\n\\n<!--\\n","section":"How can I deactivate, reactivate or delete a user?","version":"current","path":"/kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user#changes-in-active-seat-count","category":"default"},{"title":"Deleting a user","content":"If you need to remove the name and email address of a deactivated user, you can permanently delete it.\\n:::tip\\nNote: Once a user is deleted, it can’t be reactivated.\\n:::\\nTo delete a user, go to the Deactivated tab and click “Delete user” next to the target user. -->\\n<!--  -->\\n<!--  -->\\n<!--\\nUpon user deletion:\\nThe user’s name, email are completely removed from your company account. Instead, you’ll see the name (deleted user) or (deleted user, IDxxxxxxxx).\\nAll leads, deals and contacts the deleted user owns remain in your company account and are still assigned to the deleted user, unless the ownership is transferred during deletion.\\n:::tip\\nNote: We highly recommend transferring item ownership before the user is deleted, as you’ll no longer be able to select the deactivated user in filters. As an alternative, you can create a filter with conditions where the owner is not any of the other users.\\n::: -->\\n<!-- Learn about the other items the deleted user could be part of in this article. -->\\n","section":"How can I deactivate, reactivate or delete a user?","version":"current","path":"/kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user#deleting-a-user","category":"default"},{"title":"How can I replace users in my Fintesk company account?","content":"<p>&lt;!-- ../../kb/users-and-permissions/how-can-i-replace-users-in-my-pipedrive-company-account.md --&gt;</p>\\n<p>&lt;!-- # How can I replace users in my Fintesk company account? --&gt;</p>\\n<p>:::tip\\n<strong>Note</strong>: This action is only available to users with <strong>account settings</strong> access.\\n:::</p>\\n<p>&lt;!-- When an existing Fintesk user switches to another team or leaves the company, you may want to replace them with a new user. --&gt;</p>\\n<p>When an existing Fintesk user leaves the company, you may want to replace them with a new user.</p>\\n<p>For security purposes, the best way to do this would be to <a href=\\"../../kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user\\">deactivate the old user</a> so they no longer have access and then <a href=\\"../../kb/users-and-permissions/how-can-i-add-a-user\\">add a new user</a> to your Fintesk account.</p>\\n<p>You can do both by going to <strong><a href=\\"https://app.fintesk.com/settings/company/manage-users?utm_source=fintesk-docs\\">Manage users</a></strong> and then, after clicking on <strong>“...”</strong> next to the user you’d like to deactivate, select <strong>“Deactivate”</strong>.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202023-10-10%20at%2011.15.46.png\\" alt=\\"1\\"> --&gt;</p>\\n<p><img src=\\"../../kb/users-and-permissions/how-can-i-replace-users-in-my-fintesk-company-account/hciru01.jpeg\\" alt=\\"hciru01\\"></p>\\n<p>To add a new user, click on <strong>“+”</strong> on the right-hand side to add a new user to your account.</p>\\n<p>&lt;!-- ## What if I want to transfer data from the deactivated user to the new user?</p>\\n<p>Once you deactivate a user, you may find that this user had owned deals or contacts that now need to be reassigned to the new user or another active user. You can easily reassign the items by following <a href=\\"../../kb/filtering/viewing-and-reassigning-the-data-of-a-deactivated-user\\">this article</a>. Transferring data in this way will allow you to choose exactly what needs to be reassigned and prevent any confidential information from being shared. --&gt;</p>\\n","section":"How can I replace users in my Fintesk company account?","version":"current","path":"/kb/users-and-permissions/how-can-i-replace-users-in-my-fintesk-company-account","category":"default"},{"title":"Updating your own user information","content":"\\n:::tip\\nNote: Users can only update their own user information regardless of permissions.\\n:::\\nTo update your user information, go to Personal Preferences > Account.\\nHere, you can update the following information:\\nFirst Name\\nLast Name\\nDefault currency\\n<!-- - Picture -->\\n<!-- - Login email -->\\n<!-- - Timezone (this is updated automatically to match your computer timezone) -->\\n<!-- - Date/number format -->\\n<!-- - Language -->\\n<!--  -->\\n\\nYou can also change your password by going to Password > Password and login.\\n\\n","section":"Updating user information","version":"current","path":"/kb/users-and-permissions/updating-user-information#updating-your-own-user-information","category":"default"},{"title":"Updating other user\'s information","content":"<!-- :::tip\\nNote: If you want to give a user \\"account settings access\\", please read this article.\\n::: -->\\nUsers with account settings access can perform the following actions for regular users and other admins.\\n<!-- - Edit permission sets -->\\nAdd and deactivate users\\nYou can make these changes by going to Company Settings > Manage users > “...” > Edit access rights.\\n<!--  -->\\n\\n","section":"Updating user information","version":"current","path":"/kb/users-and-permissions/updating-user-information#updating-other-users-information","category":"default"},{"title":"Can an admin user update the login information of other users?","content":"For security and privacy reasons, an admin user can’t update the name, login email or password of any other user, admin or regular.\\nIn Fintesk, one user can belong to multiple companies (coming soon) with one set of login credentials, so we want to ensure that other users can’t access or change that information.\\n","section":"Updating user information","version":"current","path":"/kb/users-and-permissions/updating-user-information#can-an-admin-user-update-the-login-information-of-other-users","category":"default"},{"title":"What if I want to replace a user?","content":"The best way to replace a user in Fintesk is to deactivate the existing user and add a new one for the new team member.\\n<!-- :::tip\\nNote: For a guide on transferring previously owned items to a new user, check out this article.\\n::: -->\\n","section":"Updating user information","version":"current","path":"/kb/users-and-permissions/updating-user-information#what-if-i-want-to-replace-a-user","category":"default"},{"title":"Active","content":"The user is currently enrolled with the Fintesk account and has access\\n","section":"Users","version":"current","path":"/kb/users-and-permissions/users#active","category":"default"},{"title":"Invited","content":"An invite has been sent to the email address, but a new user has not yet been enrolled.\\n","section":"Users","version":"current","path":"/kb/users-and-permissions/users#invited","category":"default"},{"title":"Deactivated","content":"The user has been disabled and the user no longer has access to the company Fintesk\'s account.\\nIf a user has been invited to join the account but has not accepted, you can cancel their Fintesk invite link under the invited tab.\\nYou can learn more about adding new users in this article.\\n","section":"Users","version":"current","path":"/kb/users-and-permissions/users#deactivated","category":"default"},{"title":"What is a \\"regular user\\"?","content":"<p>&lt;!-- ../../kb/users-and-permissions/what-is-a-regular-user.md --&gt;</p>\\n<p>&lt;!-- # What is a &quot;regular/agent user&quot;? --&gt;</p>\\n<p>When navigating the <strong>Manage Users</strong> page, you might notice that your permissions are set to regular.</p>\\n<p>Users with <strong>regular</strong> access in deals and &quot;global permissions&quot; have the permissions which were given to them when they were invited into their Fintesk company account.</p>\\n<p>Based on the chosen options in that permission set, the user may have limited access to viewing and changing certain items in the Fintesk account.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202023-02-27%20at%2018.11.45.png\\" alt=\\"1\\"> --&gt;</p>\\n","section":"What is a \\"regular user\\"?","version":"current","path":"/kb/users-and-permissions/what-is-a-regular-user","category":"default"},{"title":"Who is the admin user of my account?","content":"<p>&lt;!-- ...kb/users-and-permissions/who-is-the-admin-user-of-my-account --&gt;\\n&lt;!-- # Who is the admin user of my account? --&gt;</p>\\n<p>The admin user with &quot;account settings access&quot; is the first user that set up the account and the users that they assigned admin status since then.</p>\\n<p>If you are not sure who the admin user is on your account, for security reasons and to maintain user privacy, our support agents cannot answer this question for you. Unfortunately, there is no possibility for our support team to share this information with you.</p>\\n<p>In this case, one possibility would be for you to check the user that your invitation email to Fintesk arrived from. In many cases, this user will still be the admin user.</p>\\n<p>Otherwise, you will need to contact your manager, supervisor, IT admin, or colleagues to find out who is the admin user on the account.</p>\\n<p>:::tip\\n<strong>Note</strong>: The original creator of the account will be given account settings admin status, however this status can be removed or given to other users.</p>\\n<p>&lt;!-- You can check out <a href=\\"../../kb/users-and-permissions/global-user-management\\">this article</a> for more information about user management. --&gt;</p>\\n<p>:::</p>\\n","section":"Who is the admin user of my account?","version":"current","path":"/kb/users-and-permissions/who-is-the-admin-user-of-my-account","category":"default"},{"title":"Data Processing Addendum (“DPA”)","content":"Last updated: November 27, 2025\\nThis DPA is entered into by and between:\\nThe entity or person defined as “Client” under the Terms (“Client”) and,\\nFintesk (meaning the legal entity with which the Client has a contractual relationship according to the Terms, “Fintesk”).\\nThe Client and Fintesk are also referred to as a “Party” and collectively as the “Parties”.\\nThis DPA forms part of and is subject to the Fintesk Terms of Service, available at (“Terms”). This DPA shall take effect upon Client’s acceptance, or other execution, of the Terms and shall continue in accordance with the provisions set out herein.\\n","section":"Data Processing Addendum (“DPA”)","version":"current","path":"/privacy/dpa","category":"default"},{"title":"1. Background","content":"1.1 The Client has agreed to the Terms, according to which Fintesk has agreed to provide certain services to Client (“Services”).\\n1.2 When providing the Services, Fintesk may collect, gain access to, or otherwise Process Personal Data of individuals (Data Subjects) on behalf of Client. Unless otherwise agreed to between the Parties, Client will be the Data Controller (Responsable del Tratamiento) and Fintesk will be the Data Processor (Encargado del Tratamiento) of such Personal Data.\\n1.3 This DPA specifies the data protection obligations of the Parties under the Terms. It applies to all activities performed by Fintesk in connection with the Terms in which Fintesk, its staff, or a third party acting on behalf of Fintesk comes into contact with Personal Data as a Data Processor on behalf of the Client.\\n1.4 The DPA is based on the provisions of Law No. 21,719, on the protection of personal data, and the definitions contained therein.\\n1.5 If there is a conflict between the terms of the Terms and those of this DPA, the provisions of this DPA will prevail.\\n","section":"Data Processing Addendum (“DPA”)","version":"current","path":"/privacy/dpa#1-background","category":"default"},{"title":"2. Definitions","content":"2.1 All capitalized terms used herein and not otherwise defined herein, shall have the meaning ascribed to such term in the Terms.\\n2.2 “Data Controller” (Responsable del Tratamiento) means the natural or legal person, public authority, agency or other body which, alone or jointly with others, determines the purposes and means of the Processing of Personal Data.\\n2.3 “Data Processor” (Encargado del Tratamiento) means a natural or legal person, public authority, agency or other body which Processes Personal Data on behalf of the Data Controller.\\n2.4 “Data Protection Laws” means all applicable worldwide legislation relating to data protection and privacy which applies to the respective Party in the role of Processing Personal Data in question under the Terms, in each case as amended.\\n2.5 “Data Subject” (Interesado) means the individual to whom Personal Data relates.\\n2.6 “Instructions” means the written, documented instructions issued by Client to Fintesk, including by using the Services, and directing the same to perform a specific or general action with regard to Personal Data (including, but not limited to, deleting or making available).\\n2.7 “Personal Data” means any information relating to an identified or identifiable individual (Data Subject) where such information is contained within Client Data and is recognized as personal data under Data Protection Laws.\\n2.8 “Personal Data Breach” means a breach of security leading to the accidental or unlawful destruction, loss, alteration, unauthorized disclosure of, or access to, Personal Data transmitted, stored or otherwise Processed by Fintesk and/or its Sub-Processors. Personal Data Breach will not include unsuccessful attempts or activities that do not compromise the security of Personal Data (pings, port scans, denial of service attacks, etc.).\\n2.9 “Processing” means any operation or set of operations which is performed on Personal Data, encompassing the collection, recording, organization, storage, adaptation, retrieval, use, disclosure, restriction or erasure.\\n2.10 “Sub-Processor” (Subencargado) means any Data Processor engaged by Fintesk to assist in fulfilling its obligations with respect to the provision of the Services.\\n2.11 “Third Country” means any country outside of Chile that does not provide recognized adequate protection.\\n","section":"Data Processing Addendum (“DPA”)","version":"current","path":"/privacy/dpa#2-definitions","category":"default"},{"title":"3. Details of Processing","content":"3.1 Purpose of Processing. Subject to Section 5.1, Fintesk will Process Personal Data only for the purpose of providing and maintaining the Services. Fintesk will follow reasonable Instructions from the Client that do not conflict with this DPA or the laws.\\n3.2 Nature of Processing. Fintesk is a cloud-based SaaS CRM tool. Personal Data will be subject to storage and other Processing necessary to provide and maintain the Services and disclosure according to the Terms or law.\\n3.3 Controller Instructions. The Terms together with the Client’s use of the Services constitute the Client’s complete and final Instructions. Additional Instructions require prior written agreement.\\n3.4 Categories of Data Subjects. Fintesk has no control over the categories, but they usually include: directors, employees, interns, contractors, job applicants, customers, suppliers, and business contacts of the Client.\\n3.5 Categories and Nature of Personal Data. Will generally include: Name, address, email, phone number, customer history, IP addresses, free-text notes and other data entered by Client. The Parties do not anticipate the Processing of Sensitive Information.\\n","section":"Data Processing Addendum (“DPA”)","version":"current","path":"/privacy/dpa#3-details-of-processing","category":"default"},{"title":"4. Client’s Obligations","content":"4.1 Compliance with Laws. Client will be responsible for complying with all requirements under Data Protection Laws in their use of the Services and in their Instructions to Fintesk. Fintesk has no obligation to assess Client Data to identify specific legal requirements.\\n4.2 Specific Responsibilities. Client accepts that they will be solely responsible for:\\n4.2.1 The accuracy, quality, and legality of Personal Data.\\n4.2.2 Complying with transparency and lawfulness requirements (notifications and consents, including marketing).\\n4.2.3 Ensuring Client has the right to transfer or provide access to the Personal Data to Fintesk.\\n4.2.4 Ensuring that Instructions comply with applicable laws.\\n4.2.5 Complying with laws applicable to emails or content managed through the Services.\\n4.3 Client will inform Fintesk without undue delay if Client is not able to comply with its responsibilities.\\n","section":"Data Processing Addendum (“DPA”)","version":"current","path":"/privacy/dpa#4-clients-obligations","category":"default"},{"title":"5. Fintesk’s Obligations","content":"5.1 Scope of Processing. Fintesk commits to Processing Personal Data only based on documented Instructions.\\n5.2 Confidentiality. Fintesk will ensure that authorized persons have committed themselves to confidentiality.\\n5.3 Qualified Personnel. Fintesk will use qualified personnel with data protection training.\\n5.4 Instructions to Personnel. Fintesk will oblige its personnel to Process Personal Data only in accordance with the Terms and Instructions.\\n5.5 Notification of Violation (Instructions). Fintesk will notify Client if Fintesk is of the opinion that an Instruction is in violation of Data Protection Laws.\\n5.6 Notification of Personal Data Breach and Cooperation. Fintesk will notify Client without undue delay (with a targeted notification time of no greater than 72 business hours) after becoming aware of a Personal Data Breach and will assist Client in fulfilling its statutory obligations.\\n5.7 Third Parties. Fintesk will keep confidential and will not make available any Personal Data to any third party except in accordance with the Terms or as required by applicable law.\\n5.8 Data Subjects’ Requests. Fintesk will support Client by implementing appropriate technical and organizational measures in fulfilling the rights of the Data Subject. If a Data Subject contacts Fintesk directly, Fintesk will instruct the Data Subject to contact the Data Controller.\\n5.9 Security. Fintesk will assist Client in the fulfillment of its obligations.\\n5.10 Cooperation with Authorities. Fintesk will cooperate with the relevant supervisory authorities.\\n5.11 Deletion and Return. Upon termination of Services, Fintesk will delete or return Personal Data according to Instructions. If Client does not give Instructions, Fintesk will delete the data as follows:\\nContents of closed Accounts: ~180 days.\\nContents of closed Free Trial Accounts: ~60 days.\\nCopias de seguridad (backups): ~90 days.\\n5.12 Data Protection Impact Assessment. Fintesk will provide reasonable assistance with data protection impact assessments.\\n","section":"Data Processing Addendum (“DPA”)","version":"current","path":"/privacy/dpa#5-fintesks-obligations","category":"default"},{"title":"6. Sub-Processors","content":"6.1 General Authorization. Client grants Fintesk a general authorization to engage Sub-Processors.\\n6.2 Authorized Sub-Processors. Listed in www.pipedrive.com/subprocessors.\\n6.3 Notification of Changes. Fintesk will notify Client prior to the appointment of any new Sub-Processor via email. Client may object within ten (10) calendar days by sending an email to privacidad@fintesk.com.\\n6.4 Objection. If Client objects, Fintesk will recommend changes. If it cannot be resolved within 30 days, Client may terminate the affected Services and receive a pro-rata refund.\\n6.5 Conditions for Engagement. Fintesk will ensure agreements with Sub-Processors that impose similar, and in no way less protective, obligations than as set out in this DPA, and will ensure an adequate level of protection for transfers to Third Countries.\\n6.6 Responsibility. Fintesk shall be fully responsible to Client for any violations of this DPA by the Sub-Processors.\\n","section":"Data Processing Addendum (“DPA”)","version":"current","path":"/privacy/dpa#6-sub-processors","category":"default"},{"title":"7. Place of Data Processing and Data Transfers","content":"7.1 Places of Processing. Client accepts that Fintesk may access and Process Personal Data on a global basis, including transfers to affiliates and Sub-Processors in their jurisdictions.\\n7.2 Compliance. Each Party will ensure such transfers are made in compliance with the Data Protection Laws of Chile.\\n7.3 Transfers subject to the Swiss DPA. For transfers subject to the Swiss DPA, references to the GDPR in the SCCs are to be understood as references to the Swiss DPA and the authority is the Swiss Federal Data Protection and Information Commissioner.\\n7.4 Transfers from Brazil. If applicable, the Parties will comply with the Brazil Standard Contractual Clauses, incorporated into this DPA. Fintesk is the Importer and Client is the Exporter.\\n7.5 Transfers within Fintesk. Fintesk has concluded an Intra Group Data Transfer Agreement (IGDTA) and Fintesk Inc. is a registered entity of the EU-U.S. Data Privacy Framework.\\n","section":"Data Processing Addendum (“DPA”)","version":"current","path":"/privacy/dpa#7-place-of-data-processing-and-data-transfers","category":"default"},{"title":"8. Technical and Organizational Measures","content":"Fintesk will implement appropriate technical and organizational security measures to ensure a level of security appropriate to the risk (in accordance with Law No. 21,719), described in Annex 2.\\n","section":"Data Processing Addendum (“DPA”)","version":"current","path":"/privacy/dpa#8-technical-and-organizational-measures","category":"default"},{"title":"9. Audits","content":"Fintesk will grant to Client rights of access and information to verify compliance, upon written request. Client may determine compliance via an on-site audit once a year, subject to confidentiality and reimbursement of costs at Fintesk’s then-current professional services rates (see Annex 2 of this DPA).\\n","section":"Data Processing Addendum (“DPA”)","version":"current","path":"/privacy/dpa#9-audits","category":"default"},{"title":"10. Liability","content":"The Parties’ obligations or breach thereof under this DPA shall be subject to the limitations on liability set forth in the Terms.\\n","section":"Data Processing Addendum (“DPA”)","version":"current","path":"/privacy/dpa#10-liability","category":"default"},{"title":"11. Miscellaneous","content":"11.1 Governing Law. The law indicated in the Terms.\\n11.2 Changes. Fintesk may make modifications to this DPA to comply with laws, regulatory orders, or new practices. Continued use of the Services constitutes Client’s acceptance.\\n","section":"Data Processing Addendum (“DPA”)","version":"current","path":"/privacy/dpa#11-miscellaneous","category":"default"},{"title":"Annex 2 – Technical and Organizational Measures","content":"Description of the technical and organizational security measures implemented by Fintesk:\\n","section":"Data Processing Addendum (“DPA”)","version":"current","path":"/privacy/dpa#annex-2--technical-and-organizational-measures","category":"default"},{"title":"1. Pseudonymization and Encryption","content":"Data at rest: Encrypted with AES-256.\\nData in transit: Use of HSTS via TLS (HTTPS).\\n","section":"Data Processing Addendum (“DPA”)","version":"current","path":"/privacy/dpa#1-pseudonymization-and-encryption","category":"default"},{"title":"2. Confidentiality, Integrity, and Availability","content":"Incident Management:\\n\\nDedicated 24x7 on-call function for immediate response.\\nFormal procedure for security events and post-mortem analysis.\\n\\n\\nResilience:\\n\\nBusiness continuity and disaster recovery plan.\\nBackups stored off-site and tested.\\n\\n\\nRedundancy:\\n\\nGlobally redundant and scalable Infrastructure (IaaS).\\nHigh availability in all components.\\n","section":"Data Processing Addendum (“DPA”)","version":"current","path":"/privacy/dpa#2-confidentiality-integrity-and-availability","category":"default"},{"title":"3. Regular Testing and Evaluation","content":"Annual vulnerability scans.\\nAnnual penetration tests performed internally.\\n","section":"Data Processing Addendum (“DPA”)","version":"current","path":"/privacy/dpa#3-regular-testing-and-evaluation","category":"default"},{"title":"4. Identification and Authorization","content":"Access control (Just-in-Time, least privilege).\\nStrong password policy.\\nIdentity lifecycle management and automatic session expiration.\\n","section":"Data Processing Addendum (“DPA”)","version":"current","path":"/privacy/dpa#4-identification-and-authorization","category":"default"},{"title":"5. Protection during Transmission","content":"Encryption of data-in-transit, firewalls (WAF, cloud-native), IPS.\\nMonitoring for compromise attempts.\\n","section":"Data Processing Addendum (“DPA”)","version":"current","path":"/privacy/dpa#5-protection-during-transmission","category":"default"},{"title":"6. Protection during Storage","content":"Endpoint intrusion detection.\\nPhysical security in facilities.\\nSecrets management (keys).\\nSecurity training for employees.\\nSoftware updates and patches.\\nLogical separation of client instances.\\n","section":"Data Processing Addendum (“DPA”)","version":"current","path":"/privacy/dpa#6-protection-during-storage","category":"default"},{"title":"7. Physical Security","content":"AWS facilities protected in accordance with their security protocols (see aws.amazon.com/compliance).\\n","section":"Data Processing Addendum (“DPA”)","version":"current","path":"/privacy/dpa#7-physical-security","category":"default"},{"title":"8. Configuration Management","content":"Continuous automation for deployment.\\nIntegration testing.\\nProcess for critical emergency fixes.\\n","section":"Data Processing Addendum (“DPA”)","version":"current","path":"/privacy/dpa#8-configuration-management","category":"default"},{"title":"9. IT Governance and Security","content":"Information security and vendor risk management program.\\nSecurity-by-design reviews.\\nEmail filters and phishing exercises.\\nInternal disciplinary actions.\\n","section":"Data Processing Addendum (“DPA”)","version":"current","path":"/privacy/dpa#9-it-governance-and-security","category":"default"},{"title":"10. Minimization and Retention","content":"Collection limited to processing purposes.\\nDeletion/return of data upon termination of services.\\nRetention according to privacy policy.\\n","section":"Data Processing Addendum (“DPA”)","version":"current","path":"/privacy/dpa#10-minimization-and-retention","category":"default"},{"title":"11. Portability and Erasure","content":"Self-service features to export or delete Client Data.\\n","section":"Data Processing Addendum (“DPA”)","version":"current","path":"/privacy/dpa#11-portability-and-erasure","category":"default"},{"title":"12. Data Separation","content":"Access separation by application and user.\\nDatabase tables normalized and separated by module.\\nInterfaces designed for specific purposes.\\n","section":"Data Processing Addendum (“DPA”)","version":"current","path":"/privacy/dpa#12-data-separation","category":"default"},{"title":"13. Artificial Intelligence (AI/ML)","content":"Training for teams on secure use of AI.\\nLegal, Privacy, and Security review of AI/ML use cases.\\n","section":"Data Processing Addendum (“DPA”)","version":"current","path":"/privacy/dpa#13-artificial-intelligence-aiml","category":"default"},{"title":"Introduction","content":"Fintesk may use sub-processors to support the provision of services ordered by a Client. This page provides important information about the identity, location, and role of each sub-processor, as well as the type of data they process.\\n","section":"Fintesk Data Sub-processors","version":"current","path":"/privacy/fintesk-data-sub-processors#introduction","category":"default"},{"title":"Infrastructure and Hosting","content":"These providers are fundamental to the basic operation and security of the platform.\\nSub-processor\\nEntity Country\\nTransfer Mechanism\\nApplicable Service\\nType of Personal Data\\n\\n\\n\\n\\nDigitalOcean LLC\\nUSA\\nDPA\\nHosting and CDN services in Europe and the USA (depending on Client location).\\nAll Client Data stored, as defined in the Terms of Service.\\n\\n\\nCloudflare, Inc.\\nUSA\\nDPA\\nContent distribution, security, abuse prevention, and DNS services.\\nEnd-User or Agent IP address.\\n","section":"Fintesk Data Sub-processors","version":"current","path":"/privacy/fintesk-data-sub-processors#infrastructure-and-hosting","category":"default"},{"title":"Feature Specific Providers","content":"These providers enable optional or specific features within Fintesk.\\nSub-processor\\nEntity Country\\nTransfer Mechanism\\nApplicable Service\\nType of Personal Data\\n\\n\\n\\n\\nMessagebird UK Ltd.\\nUnited Kingdom\\nDPA\\nProvider for the Live Chat feature in LeadBooster.\\nEncrypted conversations sent through the Live Chat feature.\\n\\n\\nGoogle LLC\\nUSA\\nDPA\\nProvider for AI features (email summarization, generation, data analysis).\\nAll Client Data that the Client chooses to process in AI-powered features.\\n\\n\\nMailgun Technologies, Inc\\nUSA\\nDPA\\nProvider for the Simple Email feature\\nEmails sent using the feature.\\n","section":"Fintesk Data Sub-processors","version":"current","path":"/privacy/fintesk-data-sub-processors#feature-specific-providers","category":"default"},{"title":"Customer Support Services","content":"Sub-processors involved when you request technical support.\\nSub-processor\\nEntity Country\\nTransfer Mechanism\\nApplicable Service\\nType of Personal Data\\n\\n\\n\\n\\nSplashtop Inc.\\nUSA\\nDPA\\nScreen sharing and co-browsing to resolve issues.\\nData that the Client chooses to share during screen sharing sessions.\\n","section":"Fintesk Data Sub-processors","version":"current","path":"/privacy/fintesk-data-sub-processors#customer-support-services","category":"default"},{"title":"2. Fintesk Affiliate Sub-processors","content":"The Fintesk group does not have affiliate sub-processors.\\n","section":"Fintesk Data Sub-processors","version":"current","path":"/privacy/fintesk-data-sub-processors#2-fintesk-affiliate-sub-processors","category":"default"},{"title":"3. Data Hosting Locations","content":"Fintesk currently hosts its data in the following AWS regions:\\nUS East\\nUS West\\n","section":"Fintesk Data Sub-processors","version":"current","path":"/privacy/fintesk-data-sub-processors#3-data-hosting-locations","category":"default"},{"title":"Data Center Assignment","content":"To optimize performance and compliance, new sign-ups are primarily hosted in:\\nUSA\\nNote: Due to external conditions (such as IP mappings), company accounts can be hosted in data centers different from the default ones. To confirm the exact location of your company\'s data, please contact the Support team.\\n","section":"Fintesk Data Sub-processors","version":"current","path":"/privacy/fintesk-data-sub-processors#data-center-assignment","category":"default"},{"title":"1. Definitions","content":"“Customer” means a customer of Fintesk.\\n“Customer Data” means personal data, reports, addresses, and other files, folders, or documents in electronic form that a User of the Service stores within the Service.\\n“Personal Data” means any information relating to an identified or identifiable natural person.\\n“Public Area” means the area of the Site that can be accessed both by Users and Visitors, without needing to log in.\\n“Restricted Area” means the area of the Site that can be accessed only by Users, and where access requires logging in.\\n“User” means an employee, agent, or representative of a Customer, who primarily uses the restricted areas of the Site for the purpose of accessing the Service in such capacity.\\n“Visitor” means an individual other than a User, who uses the public area, but has no access to the restricted areas of the Site or Service.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#1-definitions","category":"default"},{"title":"2. Roles and Responsibilities","content":"Fintesk is the controller of your Personal Data, as described in this Privacy Notice, unless otherwise stated.\\nPlease note that this Privacy Notice does not apply to the extent that we process Personal Data in the role of a processor (or in a similar role, such as a “service provider” in certain jurisdictions) on behalf of our Customers, including where we offer to our Customers various cloud products and/or services, through which our Customers (and/or their affiliates) connect their own websites and applications to our hosted platform, sell or offer their own products and/or services, send electronic communications to other individuals, or collect, use, share, or process Personal Data via our cloud products and/or services.\\nIn such cases, Fintesk does not own, control, or direct the use of any of the Customer Data stored or processed by a Customer or User via the Service. Only the Customer or Users are entitled to access, retrieve, and direct the use of such Customer Data. The Customer or the User is the data controller under the Regulation for any Customer Data containing Personal Data.\\nFor detailed privacy information applicable to situations where a Fintesk Customer (and/or an affiliate of a Customer) is the controller using Fintesk\'s cloud products and services, please contact the respective Customer directly. We are not responsible for the privacy or data security practices of our Customers, which may differ from those set forth in this Privacy Notice. If not stated otherwise in this Privacy Notice or in a separate disclosure, we process such Personal Data in the role of a processor or service provider on behalf of a Customer (and/or its affiliates), who is the responsible controller of the Personal Data.\\nIf your Personal Data has been submitted to us by or on behalf of a Fintesk Customer and you wish to exercise any rights you may have under applicable data protection laws, please inquire with the applicable Customer directly.\\nFintesk is not aware of what Customer Data is actually stored or made available by a Customer or User to the Service and does not directly access such Customer Data except as authorized by the Customer, or as necessary to provide Services to the Customer and its Users.\\nExcept as provided in this Privacy Notice, Fintesk does not cause Customer Data containing Personal Data stored in connection with the Services to be transferred or otherwise made available to third parties, except to third-party Sub-processors who may process such data on behalf of Fintesk in connection with Fintesk’s provision of Services to Customers.\\nFintesk is not responsible for the content of the Personal Data contained in the Customer Data or other information stored on its servers (or its sub-processors’ servers) at the discretion of the Customer or User, nor is Fintesk responsible for the manner in which the Customer or User collects, handles disclosure, distributes, or otherwise processes such information.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#2-roles-and-responsibilities","category":"default"},{"title":"3. The Information We Collect","content":"We collect different types of information from or through the Service.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#3-the-information-we-collect","category":"default"},{"title":"3.1 Information You Provide Directly to Fintesk","content":"Account Registration: When you sign up for an account to access one or more of our services, we ask for information such as your name, contact number, email address, company name, and country to complete the account registration process. You may also provide us with more information such as your photo, time zone, and language, but we do not require that information to register for an account.\\nEvent Registrations and Other Form Submissions: We record information that you submit when you (i) register for any event, including webinars or seminars, (ii) subscribe to our newsletter or any other mailing list, (iii) submit a form to download any product, whitepaper, or other materials, (iv) participate in contests or respond to surveys, or (v) submit a form to request customer support or to contact Fintesk for any other purpose.\\nPayment Processing: When you buy something from us, we ask you to provide your name, contact information, and credit card information or other payment account information. When you submit your card information, we store the name and address of the cardholder, the expiry date, and the last four digits of the credit card number. We do not store the actual credit card number. For quick processing of future payments, if you have given us your approval, we may store your credit card information or other payment information in an encrypted format on the secure servers of our Payment Gateway Service Providers.\\nTestimonials: When you authorize us to post testimonials about our products and services on websites, we may include your name and other personal information in the testimonial. You will be given the opportunity to review and approve the testimonial before we post it. If you wish to update or delete your testimonial, you can contact us at privacidad@fintesk.com.\\nInteractions with Fintesk: We may record, analyze, and use your interactions with us, including email, telephone, and chat conversations with our sales and customer support professionals, for improving our interactions with you and other customers.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#31-information-you-provide-directly-to-fintesk","category":"default"},{"title":"3.2 Information Collected by Customers","content":"A Customer or User may store or upload Customer Data into the Service. Fintesk has no direct relationship with the individuals whose Personal Data it hosts as part of Customer Data. Each Customer is responsible for providing notice to its customers and third parties concerning the purpose for which Customer collects their Personal Data and how this Personal Data is processed in or through the Service as part of Customer Data.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#32-information-collected-by-customers","category":"default"},{"title":"3.3 Information Collected Automatically","content":"Browser, Device, and Server Information: When you visit our websites, we collect information that web browsers, mobile devices, and servers make available, such as the internet protocol address, browser type, language preference, time zone, referring URL, date and time of access, operating system, mobile device manufacturer, and mobile network information. We include these in our log files to understand more about visitors to our websites.\\nInformation from Cookies and Tracking Technologies: We use temporary and permanent cookies to identify users of our services and to enhance user experience. We embed unique identifiers in our products to track usage of the products. We also use cookies, tags, scripts, and other similar technologies to identify visitors, track website navigation, gather demographic information about visitors and users, understand email campaign effectiveness, and for targeted visitor and user engagement by tracking your activities on our websites.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#33-information-collected-automatically","category":"default"},{"title":"3.4 Information We Collect from Third Parties","content":"User Registrations via Federated Authentication Service Providers: You can log in to Fintesk using supported federated authentication service providers such as LinkedIn, Microsoft, and Google. These services will authenticate your identity and give you the option to share certain personal information with us, such as your name and email address. You should check your privacy settings on each Integrated Service to understand what information that Integrated Service makes available to us, and make changes as appropriate. Please review each Integrated Service’s terms of use and privacy policies carefully before using their services and connecting to our Service.\\nReferrals: If someone has referred any of our products or services to you through any of our referral programs, that person may have provided us with your name, email address, and other personal information. You may contact us at privacidad@fintesk.com to request that we remove your information from our database. If you provide us information about another person, or if another person gives us your information, we will only use that information for the specific reason for which it was provided to us.\\nInformation from our Reselling Partners and Service Providers: If you contact any of our reselling partners, or otherwise express interest in any of our products or services to them, the reselling partner may pass your name, email address, company name, and other information to Fintesk. If you register for or attend an event that is sponsored by Fintesk, the event organizer may share your information with us. Fintesk may also receive information about you from review sites if you comment on any review of our products and services, and from other third-party service providers that we engage for marketing our products and services.\\nInformation We Collect and Process When You Integrate the Service with Third Parties: You may connect third-party integrations to your Fintesk account, which may ask for certain permissions to access data or send information to or from your Fintesk account. It is your responsibility to review any third-party integrations you authorize. We may collect information about what types of integrations you use in your Fintesk account. Any permission(s) granted by you grants these third parties access to your data, which may include (but is not limited to) granting third-party applications access to view, store, and modify your Fintesk account data. We are not responsible for the practices of third-party integrations, so please carefully review the permissions you grant to third-party applications.\\nInformation from Social Media Sites and Other Publicly Available Sources: When you provide feedback or reviews about our products, interact with us on marketplaces, review sites, or social media sites such as Facebook, Twitter, LinkedIn, and Instagram through posts, comments, questions, and other interactions, we may collect such publicly available information, including profile information, to allow us to connect with you, improve our products, better understand user reactions and issues, or to reproduce and publish your feedback on our websites. We must tell you that once collected, this information may remain with us even if you delete it from these sites. Fintesk may also add and update information about you, from other publicly available sources.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#34-information-we-collect-from-third-parties","category":"default"},{"title":"4. How We Use the Information We Collect","content":"We use the information we collect in various ways to provide the Service and operate our business, including the following:\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#4-how-we-use-the-information-we-collect","category":"default"},{"title":"4.1 Operations","content":"We use the information – other than Customer Data – to operate, maintain, enhance, and provide all features of the Service.\\nTo set up and maintain your account, and to do all other things required for providing our services, such as enabling collaboration, providing website and mail hosting, and backing up and restoring your data;\\nTo provide customer support, and to analyze and improve our interactions with customers;\\nTo detect and prevent fraudulent transactions and other illegal activities, to report spam, and to protect the rights and interests of Fintesk, Fintesk’s users, third parties, and the public.\\nWe process Customer Data solely in accordance with the instructions provided by the applicable Customer or User.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#41-operations","category":"default"},{"title":"4.2 Improvements","content":"We use the information:\\nTo understand how users use our products and services, to monitor and prevent problems, and to improve our products and services;\\nTo analyze trends, administer our websites, and track visitor navigations on our websites to understand what visitors are looking for and to better help them;\\nIf for this purpose Fintesk is required to process Customer Data, then the data will only be used in an anonymized or aggregated form.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#42-improvements","category":"default"},{"title":"4.3 Communications","content":"In addition to the purposes mentioned above, we may use your information for the following purposes:\\nTo communicate with you (such as through email) about products and materials you have downloaded and services you have signed up for, changes to this Privacy Notice, changes to the Terms of Service, or important notices;\\nTo keep you posted on new products and services, upcoming events, offers, promotions, and other information that we think will be of interest to you;\\nTo ask you to participate in surveys, or to solicit feedback on our products and services.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#43-communications","category":"default"},{"title":"4.4 Analytics","content":"To update, expand, and analyze our records, identify new customers, and provide products and services that may be of interest to you;\\nTo monitor and improve marketing campaigns and make suggestions relevant to the user.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#44-analytics","category":"default"},{"title":"4.5 Legal Bases for Processing Personal Data","content":"We collect and process information about you only where we have a legal basis or bases for doing so under applicable laws. The legal bases depend on the products and services that your organization has purchased from Fintesk, how such products and services are used, and how you choose to interact and communicate with Fintesk’s websites and systems, and if you attend Fintesk events.\\nThis means we collect and use your Personal Data only where:\\nWe need it to operate and provide you with our products and services, provide customer support and personalized features, and to protect the safety and security of our products and services;\\nIt satisfies a legitimate interest of Fintesk (which is not overridden by your data protection interests and rights), such as for research and development, to market and promote our products and services, and to protect our legal rights and interests;\\nYou give us consent to do so for a specific purpose; or\\nWe need to comply with a legal obligation.\\nWhere we rely on legitimate interests to process your Personal Data, you have the right to object to that processing as described below in the “Your Choices” section. In response to your objection, we will stop processing your information for the relevant purposes unless we have compelling grounds in the circumstances or the processing is necessary in the context of legal claims. Fintesk may also process other information that constitutes your Personal Data for direct marketing purposes, and you have a right to object to Fintesk’s use of your Personal Data for this purpose at any time.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#45-legal-bases-for-processing-personal-data","category":"default"},{"title":"4.6 Additional Limits on Use of Your Google User Data","content":"Notwithstanding anything else in this Privacy Notice, if you provide Fintesk access to your Google data (e.g., when you enable the email sync feature with your Google account), Fintesk’s use of that data will be subject to these additional restrictions:\\nFintesk will only use access to read, write, modify, or control Gmail message bodies (including attachments), metadata, headers, and settings to provide a web email client that allows users to compose, send, read, and process emails and will not transfer this Gmail data to others unless doing so is necessary to provide and improve these features, comply with applicable law, or as part of a merger, acquisition, or sale of assets.\\nFintesk will not use this Gmail data for serving advertisements.\\nFintesk will not allow humans to read this data unless we have your affirmative agreement for specific messages, doing so is necessary for security purposes such as investigating abuse, to comply with applicable law, or for Fintesk\'s internal operations and even then only when the data have been aggregated and anonymized.\\nFintesk\'s use of information received, and Fintesk\'s transfer of information to any other app, from Google APIs will adhere to Google API Services User Data Policy, including the Limited Use requirements.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#46-additional-limits-on-use-of-your-google-user-data","category":"default"},{"title":"5. Who We Disclose Information To","content":"Except as described in this Privacy Notice, we will not intentionally disclose the Personal Data or Customer Data that we collect or store on the Service to third parties without the consent of the applicable Visitor, User, or Customer. We may disclose information to third parties if you consent to us doing so, as well as in the following circumstances:\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#5-who-we-disclose-information-to","category":"default"},{"title":"5.1 Unrestricted Information","content":"Any information that you voluntarily choose to include in a Public Area of the Service, such as a public profile page, will be available to any Visitor or User who has access to that content.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#51-unrestricted-information","category":"default"},{"title":"5.2 Other Users in Your Company Account","content":"Certain information about your usage of the Fintesk Services is available to the administrators of your Fintesk Account and, depending on the settings chosen by the Users of the Account, also to other Users for the purpose of providing the Fintesk Services.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#52-other-users-in-your-company-account","category":"default"},{"title":"5.3 Service Providers","content":"We work with third-party service providers who provide website, application development, hosting, maintenance, and other services for us. These third parties may have access to, or process Personal Data or Customer Data as part of providing those services for us. We limit the information provided to these service providers to that which is reasonably necessary for them to perform their functions, and our contracts with them require them to maintain the confidentiality of such information.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#53-service-providers","category":"default"},{"title":"5.4 Fintesk Communities and Other User Generated Content","content":"We make available various community forums and self-help support materials, as well as blogs and other means for you to post information on our websites. This information you post is publicly available information that you choose to disclose and may be read, collected, and processed by others who visit these websites. Except for the username (which may be your real name) and the details you choose to include in your profile, the categories of data disclosed in these circumstances will depend on the information you choose to provide. Your posts and certain profile information may remain even after you terminate your Fintesk account. We urge you to consider the sensitivity of any information you may disclose in this way. We will correct or delete any information you have posted on the websites if you so request, as described below in Section 10 “Your Choices”. In some cases, we may not be able to remove your information, in which case we will let you know if we are unable to do so and why.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#54-fintesk-communities-and-other-user-generated-content","category":"default"},{"title":"5.5 Social Media","content":"Fintesk websites may use social media features, such as the Facebook “like” button, the LinkedIn and Twitter “share” features, and other similar widgets (“Social Media Features”). Such Social Media Features may give you the option to post information about your activities on a website to a profile page of yours provided by a third-party social media network in order to share content with others within your network. Social Media Features are either hosted by the respective social media network or hosted directly on our websites. To the extent the Social Media Features are hosted by the respective social media networks and you click through to these from our website, the latter may receive information showing that you have visited our website. If you are logged in to your social media account, it is possible that the respective social media network can link your visit to our websites with your social media profile. Your interactions with Social Media Features are governed by the privacy policies (and any other applicable terms) of the respective companies that provide the relevant Social Media Features.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#55-social-media","category":"default"},{"title":"5.6 Advertising and Marketing","content":"We partner with third-party ad networks to display advertising on our website or to manage our advertising on other sites. Our ad network partner uses cookies to collect information about your activities on this and other websites to provide you targeted advertising based upon your interests. If you wish to not have this information used for the purpose of serving you targeted ads, you may opt-out by using these services: networkadvertising or aboutads (or if located in the European Union, by clicking here: youronlinechoices). Please note this does not prevent you from being served advertising, you will continue to receive generic ads.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#56-advertising-and-marketing","category":"default"},{"title":"5.7 Business Partners","content":"We may share data with trusted Fintesk partners to contact you based on your request to receive such communications, help us perform statistical analysis, provide sales support, or provide customer support. Partners are prohibited from using your Personal Data except for these purposes, and they are required to maintain the confidentiality of your data. We partner with trusted third parties to provide content that we think may be relevant to you. When you engage with these partners, we will tell you who we are sharing data with and provide a link to the partner’s privacy policy so you can learn how to opt-out of the partner’s communications. These partners are required to adhere to our privacy and data protection policies. For more information on our partner program, please see this page. If you do not want us to share your personal data with these companies, please contact our partner team at partners@fintesk.com.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#57-business-partners","category":"default"},{"title":"5.8 Non-Personally Identifiable Information","content":"We may make certain automatically-collected, aggregated, or otherwise non-personally-identifiable information available to third parties for various purposes, including (i) compliance with various reporting obligations; (ii) for business or marketing purposes; or (iii) to assist such parties in understanding our Customers’, Users’, and Visitors’ interests, habits, and usage patterns for certain programs, content, services, and/or functionality available through the Service, all of the foregoing being subject to additional limits on use of your data as set forth in this Privacy Notice.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#58-non-personally-identifiable-information","category":"default"},{"title":"5.9 Law Enforcement, Legal Process and Compliance","content":"We may disclose Personal Data or other information if required to do so by law or in the good-faith belief that such action is necessary to comply with applicable laws, in response to a facially valid court order, judicial or other government subpoena or warrant, or to otherwise cooperate with law enforcement or other governmental agencies. We also reserve the right to disclose Personal Data or other information that we believe, in good faith, is appropriate or necessary to (i) take precautions against liability, (ii) protect ourselves or others from fraudulent, abusive, or unlawful uses or activity, (iii) investigate and defend ourselves against any third-party claims or allegations, (iv) protect the security or integrity of the Service and any facilities or equipment used to make the Service available, or (v) protect our property or other legal rights, enforce our contracts, or the rights, property, or safety of others.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#59-law-enforcement-legal-process-and-compliance","category":"default"},{"title":"5.10 Change of Ownership","content":"Information about Users and Visitors, including Personal Data, may be disclosed and otherwise transferred to an acquirer, successor, or assignee as part of any merger, acquisition, debt financing, sale of assets, or similar transaction, as well as in the event of an insolvency, bankruptcy, or receivership in which information is transferred to one or more third parties as one of our business assets and only if the recipient of the User or Visitor Data commits to a Privacy Policy that has terms substantially consistent with this Privacy Notice.\\nCustomer Data may be physically or electronically transferred to an acquirer, successor, or assignee as part of any merger, acquisition, debt financing, sale of assets, or similar transaction, as well as in the event of an insolvency, bankruptcy, or receivership in which information is transferred to one or more third parties as one of our business assets, for the sole purpose of continuing the operation of the Service, and only if the recipient of the Customer Data commits to a Privacy Policy that has terms substantially consistent with this Privacy Notice.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#510-change-of-ownership","category":"default"},{"title":"6. Data Security","content":"At Fintesk, we take data security very seriously. We have taken steps to implement appropriate administrative, technical, and physical safeguards to prevent unauthorized access, use, modification, disclosure, or destruction of the information you entrust to us. However, no security system is perfect, and due to the inherent nature of the Internet, we cannot guarantee that data, including Personal Data, is absolutely safe from intrusion or other unauthorized access by others. You are responsible for protecting your password(s) and other authentication factors, as well as maintaining the security of your devices. If you believe your Personal Data has been compromised, please contact us as set forth in the “How to Contact Us” section. If we learn of a security systems breach, we will inform you and the authorities of the occurrence of the breach in accordance with applicable law.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#6-data-security","category":"default"},{"title":"7. International Data Transfers","content":"Fintesk may transfer your Personal Data to countries other than the one in which you live, including transfers to the United States. To the extent that Personal Data is transferred abroad, Fintesk will ensure compliance with the requirements of the applicable laws in the respective jurisdiction in line with Fintesk’s obligations.\\nIn particular, we offer the following safeguards if Fintesk transfers Personal Data from jurisdictions with differing data protection laws:\\nEuropean Commission Standard Contractual Clauses. Fintesk uses Standard Contractual Clauses approved by the European Commission (and the equivalent standard contractual clauses for the UK where appropriate) for transfers to countries not subject to an adequacy decision by the European Commission or your local legislature or regulator.\\nPrivacy Shield. Fintesk participates in and complies with the EU-U.S. Privacy Shield Framework as set forth by the U.S. Department of Commerce regarding the collection, use, and retention of personal information from individuals in the European Union. Pursuant to the Privacy Shield Framework Principles, Fintesk commits to resolve complaints about our collection or use of your personal information. European Union individuals with inquiries or complaints regarding our privacy protection policy should first contact Fintesk\'s Data Protection Officer at privacidad@fintesk.com. Fintesk has further committed to cooperate with the panel established by the EU data protection authorities (DPAs) with regard to unresolved Privacy Shield Framework complaints concerning human resources data and non-human resources data transferred from the European Union. In any matters relating to the EU-U.S. Privacy Shield Framework, Fintesk is subject to the investigatory and enforcement powers of the Federal Trade Commission (FTC). Under certain conditions, more fully described on the Privacy Shield website at How-to-Submit-a-Complaint, you may invoke binding arbitration when other dispute resolution procedures have been exhausted.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#7-international-data-transfers","category":"default"},{"title":"8. Privacy of Minors and Children","content":"Protecting the privacy of young children is especially important. Our Service is not directed to or intended for children under 18, and we do not knowingly collect Personal Data from children under 18. If you are under 18 years of age, then please do not use or access the Service at any time or in any manner. If we learn that Personal Data has been collected on the Service from persons under 18 years of age and without verifiable parental consent, we will take the appropriate steps to delete this information. If you are a parent or guardian and discover that your child under 18 years of age has obtained an Account on the Service, then you may alert us at privacidad@fintesk.com and request that we delete that child’s/minor’s Personal Data from our systems.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#8-privacy-of-minors-and-children","category":"default"},{"title":"9. Data Retention","content":"We will retain your Personal Data for a period of time that is consistent with the original purpose of the data collection, or as necessary to comply with our legal obligations, resolve disputes, and enforce our agreements. When we no longer have a legitimate need to process your information, we will delete or anonymize your information from our active databases. We will also securely store the information and isolate it from further processing on backup discs until deletion is possible.\\nFor the Fintesk CRM service:\\nThe content of closed accounts is deleted within 6 months of the date of closure;\\nThe content of closed Free Trial Accounts is deleted within 30 days of the date of closure;\\nServer archive backups are kept for 3 months.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#9-data-retention","category":"default"},{"title":"10.1 Your Rights with Respect to Information We Hold About You as a Controller","content":"Right of Access: You have the right to know what data we hold about you (if any).\\nRight to Rectification: You have the right to request correction of your Personal Data if it is inaccurate or incomplete.\\nRight to Erasure: You have the right, under certain conditions, to request the deletion of your Personal Data, including in situations where the processing of your Personal Data is no longer necessary for the purposes for which it was collected, or if the processing of your Personal Data was based on your consent and you wish to withdraw your consent, and there are no other grounds for processing your Personal Data.\\nRight to Restriction of Processing: You may also have the right to request that we restrict the use of your information in certain circumstances, such as when you have objected to our use of your data but we need to verify whether we have overriding legitimate grounds to use it.\\nRight to Data Portability: You have the right to transfer your information to a third party in a structured, commonly used, and machine-readable format, in circumstances where the information is processed with your consent or by automated means.\\nRight to Object: You have the right to object to the use of your information in certain circumstances, such as the use of your personal information for marketing.\\nRight to Complain: You have the right to lodge a complaint with the relevant supervisory authority if you have any complaints about the way we collect, use, or share your information. This right may not be available to you if there is no supervisory authority dealing with data protection in your country.\\nWe respect your privacy rights and provide you with reasonable access to the Personal Data that you may have provided through your use of the Services. If you wish to access or amend any other Personal Data we hold about you, or to request that we delete or transfer any information about you that we have obtained from an Integrated Service, you may contact us as set forth in the “How to Contact Us” section. At your request, we will have any reference to you deleted or blocked in our database.\\nAdditionally:\\nYou may update, correct, or delete your Account information and preferences at any time by accessing your Account settings page on the Service. Please note that while any changes you make will be reflected in active user databases instantly or within a reasonable period of time, we may retain all information you submit for backups, archiving, prevention of fraud and abuse, analytics, satisfaction of legal obligations, or where we otherwise reasonably believe that we have a legitimate reason to do so.\\nYou may decline to share certain Personal Data with us, in which case we may not be able to provide to you some of the features and functionality of the Service.\\nOptional Information: You can choose not to provide optional profile information, such as your photo. You can also delete or change your optional profile information. You can always choose not to fill in non-mandatory fields when you submit any form linked to our websites.\\nAt any time, you may object to the processing of your Personal Data, on legitimate grounds, except if otherwise permitted by applicable law. If you believe your right to privacy granted by applicable data protection laws has been infringed upon, please contact Fintesk’s Data Protection Officer at privacidad@fintesk.com.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#101-your-rights-with-respect-to-information-we-hold-about-you-as-a-controller","category":"default"},{"title":"10.2 Navigation Information","content":"You may opt out of the collection of navigation information about your visit to the Site by Google Analytics by using the Google Analytics Opt-out feature. You can disable browser cookies before visiting our websites. However, if you do so, you may not be able to use certain features of the websites properly.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#102-navigation-information","category":"default"},{"title":"10.3 Opting Out of Commercial Communications","content":"You may opt out of receiving newsletters and other non-essential messages by using the “unsubscribe” function included in all such messages or by sending an email to the address provided in the “How to Contact Us” section. Please note that you will continue to receive essential notices and emails, such as account notification emails (password change, renewal reminders, etc.), security incident alerts, security and privacy update notifications, and essential transaction and payment related emails. Users can view and modify settings relating to the nature and frequency of promotional communications that they receive from us by accessing the “Account Functionality” tab on the Service.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#103-opting-out-of-commercial-communications","category":"default"},{"title":"10.4 Information Processed on Behalf of a Fintesk Customer","content":"Fintesk has no direct relationship with the Customer’s customers or a third party whose Personal Data it may process on behalf of a Customer. An individual who seeks access, or who seeks to correct, amend, delete inaccurate data or withdraw consent for further contact should direct his query to the Customer or User they deal with directly.\\nFintesk Customers can delete, amend, or block access to any Personal Data within the Fintesk application or by contacting Fintesk Support.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#104-information-processed-on-behalf-of-a-fintesk-customer","category":"default"},{"title":"11. Do Not Track (DNT) Requests","content":"Some Internet browsers have enabled “Do Not Track” (DNT) features, which send a signal (called a DNT signal) to the websites you visit indicating that you do not wish to be tracked. Currently, there is no standard that governs what websites can or should do when they receive these signals. For now, we do not take action in response to these signals.\\nIn the meantime, you can opt out of receiving interest-based advertising from ad networks by visiting the following websites: http://www.aboutads.info/consumers and http://www.networkadvertising.org. This will opt you out of many, but not all, of the interest-based advertising activities in which we or third parties engage. The choices you make may be specific to the browser and device. If you delete your cookies or use a different browser or a different computer or device, you may need to update your opt-out choices.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#11-do-not-track-dnt-requests","category":"default"},{"title":"12. Changes and Updates to this Privacy Notice","content":"Please revisit this page periodically to stay aware of any changes to this Privacy Notice, which we may update from time to time. If we modify the Privacy Notice, we will make it available through the Service, indicate the date of the latest revision, and comply with applicable law. Your continued use of the Service after the revised Privacy Notice has become effective indicates that you have read, understood, and agreed to the current version of the Notice.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#12-changes-and-updates-to-this-privacy-notice","category":"default"},{"title":"13. How to Contact Us","content":"Please contact us with any questions or comments about this Notice, your Personal Data, our use and disclosure practices, or your consent choices by email at privacidad@fintesk.com. If you have any concerns or complaints about this Notice or your Personal Data, you may contact Fintesk’s Data Protection Officer (DPO) by email at privacidad@fintesk.com.\\n","section":"Privacy Notice – Fintesk","version":"current","path":"/privacy#13-how-to-contact-us","category":"default"},{"title":"Fintesk Terms of Service","content":"Fintesk Services are offered to the Customer subject to their acceptance, without modification, of these Terms of Service and any future modifications thereof, and the procedures that may be published periodically or made available to the Customer on or through the Fintesk Services. When a Customer uses Fintesk Services, these Terms form a legally binding contract between the Customer and Fintesk. If you are entering into these Terms on behalf of an entity, such as your employer or the company you work for, you represent and warrant that you have the legal authority to represent and bind such Customer, in which case the terms “you,” “your,” “customer,” or a related capitalized term herein shall refer to such Customer.\\nIF YOU ARE USING YOUR EMPLOYER\'S OR AN ENTITY\'S EMAIL ADDRESS TO REGISTER FOR FINTESK SERVICES, PLEASE NOTE THAT YOU ARE CONSIDERED AN AUTHORIZED REPRESENTATIVE OR AGENT OF YOUR EMPLOYER OR AN ENTITY (AS APPLICABLE).\\nThese Terms are a contract governing the use of Fintesk Services by Customers and consist of the following:\\nMaster Terms\\nSupplemental Terms\\nPrivacy Notice\\nIf you register for a Free Trial of the Platform, the applicable provisions of the Terms will govern that Free Trial.\\nPLEASE READ THESE TERMS CAREFULLY. BY REGISTERING, ACCESSING, BROWSING, AND OTHERWISE USING FINTESK SERVICES, YOU ACKNOWLEDGE THAT YOU HAVE READ, UNDERSTOOD, AND AGREE TO BE BOUND BY THESE TERMS. IF YOU DO NOT AGREE TO BE BOUND BY THESE TERMS, DO NOT ACCESS, BROWSE, OR OTHERWISE USE FINTESK SERVICES.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#fintesk-terms-of-service","category":"default"},{"title":"1.1 Definitions","content":"“Account” refers to the primary means for accessing and using Fintesk Services, subject to payment of a Fee designated in the selected Plan.\\n“Administrator” means a User(s) of an Account to whom the Customer has granted special authorization to manage the Customer\'s Account.\\n“Affiliates” refers to any legal entity that controls or owns more than 50% of the outstanding shares or securities of such entity, that is controlled by or under common control of a party.\\n“Beta Service” refers to any functionality of Fintesk Services that is in development or has not been commercially released as a final product and that Fintesk has made available to the Customer for testing and evaluation.\\n“Customer” refers to a natural or legal person or entity that has accepted these Terms with Fintesk through the use of Fintesk Services.\\n“Customer Data” refers to data and documents of any kind (images, spreadsheets, text files, etc.) and any other digital data and information, that is subject to the Platform, or that the Customer has otherwise inserted into the Platform and for which Fintesk is a “processor” (as defined in the Privacy Notice). Customer Data shall not contain Sensitive Information.\\n“Content” refers to any data and information available through Fintesk Services or contained within the structure of Fintesk Services, including, but not limited to, articles, documents, brochures, presentations, photographs, images, audiovisual works, other informational materials, and any comments.\\n“Credentials” refers to all usernames, passwords, and other access credentials created or assigned to the Customer and each of its designated Users for the use of Fintesk Services.\\n“Feature” refers to a function or set of functions providing a particular capability within Fintesk Services as determined by Fintesk and as governed by applicable Supplemental Terms.\\n“Fee” refers to the regular payment for using Fintesk Services through an active Account.\\n“Feedback” refers to any comments, bug reports, feedback, suggestions, or modifications to Fintesk Services that the Customer or a User provides to Fintesk.\\n“Free Trial” refers to temporary access for the purpose of testing any part of Fintesk Services or Features in accordance with any selected Plan without paying a Fee.\\n“Master Terms” refers to these basic legal and commercial terms that apply to the Customer\'s use of Fintesk Services.\\n“Non-Fintesk Application” refers to a web-based, mobile, offline, or other software application functionality that interacts with Fintesk Services, which is provided by the Customer or a third party. Non-Fintesk Applications, other than those obtained or provided by the Customer, will be identifiable as such.\\n“Fintesk” means, as the context requires, Fintesk SpA., LibroContable SpA, or any other of its Affiliates.\\n“Fintesk Materials” refers to the visual interfaces, graphics, design, systems, methods, information, computer code, software, services, “look and feel”, organization, compilation of Content, code, data, and all other elements of Fintesk Services.\\n“Fintesk Services” refers to the Website, Content, Fintesk Materials, the Platform, and all other content, services, and/or products, and Features/Characteristics, available on or through the Platform.\\n“Plan” refers to various criteria related to the use, functionality, and cost of a particular Fintesk Service and on which the Fee is based.\\n“Plan Term” refers to the period of use of Fintesk Services by the Customer commencing on the date of payment of the Fee corresponding to the associated Plan and ending on the expiration date of the Plan.\\n“Platform” refers to Fintesk\'s application for Customer Relationship Management, including associated Features or Characteristics.\\n“Privacy Notice” refers to the notice, as set forth at Privacy, describing how Fintesk collects, receives, uses, stores, shares, transfers, and processes “Customer Data” in connection with how the Customer uses Fintesk Services. It also describes the Customer\'s choices regarding use, as well as the Customer\'s rights of access and correction of their “Customer Data”.\\n“Renewal Date” means the date on which the Customer\'s Plan will automatically renew on an annual or monthly basis, depending on the Customer\'s Plan.\\n“Reseller” refers to a third-party entity that (i) purchases Fintesk Services from Fintesk and resells such Fintesk Services to Customers, (ii) bills such Customers directly, and (iii) provides such Customers with customer support related to Fintesk Services.\\n“Sensitive Information” means credit or debit card numbers; financial account numbers or wire transfer instructions; government-issued identification numbers (such as Social Security numbers, passport numbers), biometric information, personal health information (or other information protected under any applicable health data protection laws), personal information of children protected under any child data protection laws, and any other information or combinations of information that fall within the definition of “special categories of data” under any applicable laws related to privacy and data protection.\\n“Sub-processor” refers to any third party, as set forth herein, that Fintesk uses in the provision of Fintesk Services.\\n“Supplemental Terms” means the terms, as set forth herein, applicable to the Customer\'s use of a particular Feature or any third-party service and which form part of the Terms.\\n“Terms” means these Terms of Service and consists of the Master Terms, applicable Supplemental Terms, and the Privacy Notice.\\n“User” refers to an entity or person granted authorized rights and privileges to use the Account on behalf of a Customer.\\n“Website” refers to the compilation of all web documents (including images, php, and html files) available via Fintesk.com, its subdomains, or domains with identical names under other top-level domains and owned by Fintesk.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#11-definitions","category":"default"},{"title":"2. MODIFICATIONS TO THE TERMS","content":"Fintesk reserves the right, at its sole discretion, to change, modify, add, or remove any portion of the Terms from time to time. Notification of such modifications may be published on or through the Platform or Fintesk Services. The Customer\'s continued use of Fintesk Services constitutes their acceptance of these Terms and any arising modifications.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#2-modifications-to-the-terms","category":"default"},{"title":"3.1 Use of Fintesk Services","content":"Subject to these Terms and applicable Supplemental Terms, and payment of the applicable Fee, Fintesk grants the Customer and its Users a non-exclusive, non-transferable, and non-sublicensable license to use Fintesk Services to:\\ncollect, store, and organize Customer Data;\\nmodify and delete Customer Data; and\\ncustomize standard Features or the functionality of Fintesk Services.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#31-use-of-fintesk-services","category":"default"},{"title":"3.2 Modifications to Fintesk Services","content":"Fintesk reserves the right to modify Fintesk Services or any part or element thereof from time to time without prior notice, including, among others:\\nRebranding, repackaging, or changing the price (including adjustments to current Fees that will apply on the next Plan renewal date) of Fintesk Services at its sole discretion;\\nCeasing to provide or discontinuing the development of any particular Fintesk Service, Feature, or part or element of the Platform, temporarily or permanently;\\ntaking necessary measures to preserve Fintesk\'s rights regarding any use of Fintesk Services that may reasonably be interpreted as a violation of Fintesk\'s intellectual property rights, distribution of Internet viruses, worms, Trojan horses, malware, and other destructive activities or illegal activities.\\nAs applicable, the Customer may be notified of such modifications upon logging into the Account.\\nIf the Customer does not accept a modification, the Customer must notify Fintesk or the Reseller (if the Customer purchased access to Fintesk Services from a Reseller) before the effective date of the modification, and the Customer\'s Account will terminate on the effective date of the modification. However, the Customer\'s continued use of Fintesk Services, or any part or element thereof, after the effective date of a modification will indicate their consent to the modifications. Fintesk shall not be liable to the Customer or any third party for any modification, suspension, or discontinuation of Fintesk Services, or any part or element thereof.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#32-modifications-to-fintesk-services","category":"default"},{"title":"3.3 Credentials","content":"The Customer is responsible for maintaining the confidentiality of all Credentials and is solely responsible for all activities that occur with such Credentials. These Credentials must not be shared or used by multiple people but may be reassigned to a new User replacing a former User who has ceased working (or has changed job roles) and no longer uses Fintesk Services. Fintesk reserves the right to terminate any User Credential that Fintesk reasonably determines may have been used by an unauthorized third party or in an unauthorized manner, as determined solely by Fintesk, and will immediately notify the Customer of such termination.\\nThe Customer must immediately notify Fintesk:\\nof any disclosure, loss, or actual or suspected unauthorized use of any Credential;\\nof a User\'s departure from the Customer\'s organization;\\nof a change in a User\'s role within the Customer\'s organization; or\\nof any termination of a User\'s right for any reason.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#33-credentials","category":"default"},{"title":"3.4 Changing Plans","content":"The Customer may upgrade or downgrade a current Plan at any time by selecting a new Plan from the collection of Plans defined by Fintesk. In such a case, the Customer\'s credit card on file with Fintesk will be automatically charged a Fee for the next payment interval at the rate stipulated in the new Plan. If the Customer chooses to upgrade their Plan, the unused portion of any prepaid Fee will be applied to the Fee of the upgraded Plan. If, after the commencement of a Plan Term, the Customer chooses to downgrade their Plan, this may cause the loss of Features, functionality, Account capacity, as well as the loss of Customer Data. No prepaid or outstanding Fee will be refunded to the Customer for the price difference between Plans in the event the Customer decides to downgrade after the commencement of the Plan Term.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#34-changing-plans","category":"default"},{"title":"3.5 Customer Account Management","content":"The Customer acknowledges retaining administrative control over whom it grants access to Customer Data hosted on Fintesk Services. The Customer may specify a User to be the billing owner and, depending on the Plan, one or more Users to be Administrators to manage their account, and Fintesk is entitled to rely on communications from an Administrator when servicing the Customer\'s Account. Customer Administrators may have the ability to access, monitor, use, and/or export Customer Data.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#35-customer-account-management","category":"default"},{"title":"3.6 Technical Support","content":"Fintesk will provide reasonable technical support to the Customer and its Users through the following options, as described below, as soon as reasonably possible.\\nChat: available to all users, through their Fintesk account\\nPhone: users of certain plans may request a callback from support through their Fintesk account\\nIf you have trouble logging in or do not have a Fintesk account, you can contact us at contacto@fintesk.com.\\nNotwithstanding the foregoing, for any Fintesk Service purchased from a Reseller, first-line technical support will be provided by the Reseller and not by Fintesk.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#36-technical-support","category":"default"},{"title":"3.7 User Verification","content":"The Customer understands and agrees that we may require them to provide information that may be used to confirm their identity and help ensure the security of their Account and/or User. In the event that the Customer loses access to an Account or requests information about an Account, we reserve the right to request from the Customer any verification we deem necessary before restoring access or providing information about such Account.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#37-user-verification","category":"default"},{"title":"3.8 Features","content":"Fintesk may, from time to time, make Features available through Fintesk Services, which may be subject to Supplemental Terms. The Customer\'s use of any such Features is subject to the applicable Supplemental Terms.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#38-features","category":"default"},{"title":"3.9 Free Trial","content":"A new Customer may be entitled to a Free Trial and is not required to provide any credit card or payment information during the Free Trial period. Upon expiration of the free trial period, the account will be automatically deactivated. To avoid deactivation or reactivate the Account, the Customer must select a Plan and pay the Fee for the first payment interval of the Plan. If the Customer does not pay the Fee for the first payment interval within 2 weeks after the expiration of the Free Trial period, Fintesk has the right to permanently delete the Account, including all Customer Data. In addition to the current collection of Plans, Fintesk may offer special discounts and promotions, from time to time, at Fintesk\'s sole discretion, which may be subject to additional terms and conditions.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#39-free-trial","category":"default"},{"title":"3.10 Beta Services","content":"Fintesk may offer Customers certain Features for testing and evaluation purposes referred to as Beta Services. Fintesk reserves the right to discontinue fully or partially, at any time and from time to time, temporarily or permanently, any of the Beta Services, with or without prior notice to the Customer. The Customer agrees that Fintesk shall not be liable to the Customer or any third party for any damages related to, arising from the Customer\'s use of Beta Services, or caused by the modification, suspension, or discontinuation of any of the Beta Services, for any reason.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#310-beta-services","category":"default"},{"title":"3.11 Non-Fintesk Applications","content":"Fintesk or third parties may make non-Fintesk third-party applications available. If the Customer chooses to acquire a non-Fintesk application, the terms and conditions regarding their use or receipt of the non-Fintesk application are between the Customer and the provider of those non-Fintesk applications, and any data exchange between the Customer and such third-party provider is solely between the Customer and the applicable provider. Any questions, concerns, or disputes arising based on the Customer\'s use of non-Fintesk applications should be addressed with the provider of such non-Fintesk application and not with Fintesk. Fintesk does not warrant or support or maintain non-Fintesk applications, whether Fintesk designates them as “certified” or not. Fintesk is not responsible for any disclosure, modification, or deletion of Customer Data resulting from access by such non-Fintesk application or its provider.\\nIntegration with non-Fintesk applications. Fintesk Services may contain Features and functions designed to interoperate with non-Fintesk applications. However, Fintesk cannot guarantee the continued availability of such Features or functionalities, and may cease providing them without prior notice and without entitling the Customer to any refund, credit, or other compensation, if, for example and without limitation, the provider of a non-Fintesk service ceases to make the non-Fintesk application available for interoperation with the corresponding Features or functionalities in a manner acceptable to Fintesk.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#311-non-fintesk-applications","category":"default"},{"title":"4.1 Prohibited Activities","content":"The Customer and its Users may use Fintesk Services, and any part or element thereof, only within the scope, with the means, and for the purposes identified in these Terms and applicable law. By way of example, neither the Customer nor any User may:\\nuse Fintesk Services or any part or element thereof to commit a crime, infringe any applicable law, or entice or invite others to carry out such illegal actions;\\ncopy, duplicate, distribute, modify, adapt, hack, create derivative works, reverse engineer, or decompile Fintesk Services or any part or element thereof, or attempt to extract the source code thereof, unless (i) expressly permitted by applicable law and (ii) to the extent that Fintesk is not authorized by applicable law to exclude or limit the foregoing rights;\\nprovide false, inaccurate, or misleading information;\\nact in a defamatory, libelous, threatening, or harassing manner towards Fintesk; or\\nuse Fintesk Services or any part or element thereof unless they have agreed to be bound by these Terms.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#41-prohibited-activities","category":"default"},{"title":"4.2 Uses Requiring Fintesk\'s Consent","content":"The Customer or any User may not, without Fintesk\'s prior express written consent:\\nsell, resell, lease, license, sublicense, distribute, provide, reveal, disclose, exploit, or otherwise grant access or make Fintesk Services available to third parties, in whole or in part, unless such third parties are Users of the same Customer; or\\nuse Fintesk Services, or any part or element thereof, in a scope, with means, or for purposes other than those for which its functionality was designed.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#42-uses-requiring-fintesks-consent","category":"default"},{"title":"4.3 Trade Control Compliance","content":"The Customer, any User, Reseller, or agent (“Third Party”) represents, warrants, agrees, and accepts that, with respect to Fintesk Services:\\nThe Third Party has complied and will comply, and will cause its directors, officers, employees, and agents to comply with the economic, trade, and financial sanctions laws and regulations of the United States, the European Union, and any other trade sanctions administered by the Office of Foreign Assets Control (“OFAC”) of the U.S. Department of the Treasury and the U.S. Department of State (collectively, “Sanctions”), and the laws and regulations of the U.S., the EU, and other applicable countries related to export controls, including those administered by the U.S. Departments of Commerce and State (collectively, “Trade Controls”).\\nThe Third Party will not take any action, directly or indirectly, that could cause Fintesk or any of its Affiliates, or any of their respective officers, directors, employees, or representatives, to violate any Sanction or Trade Control.\\nNeither the Third Party nor any of its officers or directors, employees, and any agent or other representative acting on its behalf (i) has been or is designated on any list of restricted or blocked persons related to sanctions or exports, including designation on OFAC\'s List of Specially Designated Nationals and Blocked Persons or OFAC\'s Sectoral Sanctions Identifications List, (ii) is located in, organized under the laws of, or resides in any country or territory that is the subject of sanctions or embargoes by any government authority, including, but not limited to, Cuba, Iran, Syria, North Korea, Venezuela, and the Crimea Region of Ukraine, (iii) is or has been owned or controlled by more than 50% by any person or persons described in clause (i) or (ii) (collectively with (i) and (ii), a “Restricted Person”), or (iv) has provided or will provide Fintesk Services to any person described in clauses (i)-(iii).\\nThe Third Party will immediately notify Fintesk if the Third Party or any staff member employed or affiliated with a Third Party: (i) commits an actual or potential breach of Sanctions or Trade Controls in connection with Fintesk Services, or (ii) becomes a Restricted Person.\\nFintesk, at its sole discretion, shall have the right to immediately terminate access to or use of Fintesk Services without notice or liability to the Third Party, if the Third Party, or any person employed or affiliated with a Third Party, takes any action in violation of the provisions described in this Section 4 or if Fintesk determines, at its sole discretion, that the continued use of Fintesk Services by the Third Party could violate Sanctions or Trade Controls.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#43-trade-control-compliance","category":"default"},{"title":"5.1. Provision of Fintesk Services","content":"Fintesk (a) will make Fintesk Services, Content, and Customer Data available to the Customer pursuant to these Terms, (b) will provide support as described in Section 3.6 for Fintesk Services to the Customer at no additional charge, (c) will use commercially reasonable efforts to make Fintesk Services available 24 hours a day, 7 days a week, except for: (i) planned downtime (of which Fintesk will give advance electronic notice), and (ii) any unavailability caused by circumstances beyond Fintesk\'s reasonable control, including, for example, an act of Force Majeure, act of government, flood, fire, earthquake, civil unrest, act of terror, pandemic, strike or other labor problem, Internet service provider failure or delay, or denial of service attack. Fintesk may use Sub-processors to provide Fintesk Services. Fintesk will use all commercially reasonable efforts to ensure that data transfers to Sub-processors comply with applicable requirements for the processing of Customer Data by Customers and will provide information about such data transfers in these Terms for the Customer\'s consideration. For additional information on such transfers with Sub-processors, please refer to Fintesk\'s Privacy Notice and the current list of Sub-processors.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#51-provision-of-fintesk-services","category":"default"},{"title":"5.2. Customer Data Protection","content":"Fintesk will maintain administrative, physical, and technical safeguards to protect the security, confidentiality, and integrity of Customer Data. Those safeguards will include, among others, measures to prevent unauthorized access, use, modification, or disclosure of Customer Data. Furthermore, Fintesk will only access, use, modify, or otherwise disclose Customer Data: (a) to provide Fintesk Services and prevent or address service or technical problems, (b) as required by law in accordance with Section 7.6 (Mandatory Disclosure) below, (c) as expressly permitted by the Customer or User in writing.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#52-customer-data-protection","category":"default"},{"title":"6. FEES/PAYMENT","content":"The provisions of this Section 6 apply only if the Customer accesses Fintesk Services directly from Fintesk. If the Customer purchases access to Fintesk Services through a Reseller, the payment terms will be set forth in the Customer\'s agreement with such Reseller.\\nUse of Fintesk Services, other than through a Free Trial, is subject to a Fee. Upon registering for an Account, the Customer must select a Plan. Different fees apply to different Plans. The applicable Fee is charged in advance on a monthly or annual basis. Fintesk reserves the right to modify the Fees for any Plan, at its reasonable discretion, at any time after the commencement of the Plan Term, with at least one month\'s prior notice to the Customer; such modification will not take effect until the commencement of any Plan immediately following the Plan Term in which Fintesk notified the Customer of the modification.\\nThe Customer authorizes Fintesk to automatically charge the Customer the applicable Fees starting on the Renewal Date, unless the Plan has been terminated or canceled in accordance with these Terms. If a Customer wishes to reduce the number of Users, they must do so before the Renewal Date. Customers may cancel their Plan at any time as described below; however, they must do so before the Renewal Date to avoid billing of the Fees for the next Plan Term. If the Customer chooses to cancel their Plan during the Plan Term, the Customer may use the Service until the end of the Customer\'s then-current Plan Term, but will not be refunded the most recently charged Fees (or previous ones).\\nAll fees are non-refundable. For clarity, there are no refunds or credits for periods in which the Customer did not use an activated Account, used it only partially, deactivated the Account, or canceled these Terms during an ongoing payment interval, or when an Account is terminated or suspended by Fintesk in accordance with Section 13.\\nAll Fees exclude all applicable taxes, levies, or duties under any applicable law, unless stated otherwise herein. The customer is solely responsible for payment of such taxes, levies, or duties.\\nIn the event the Customer fails to pay all Fees due within 29 days of the invoice date, Fintesk will suspend all access to the Customer\'s Account. The Customer will have 180 days to provide an authorized payment method to reactivate a subscription and their Account; otherwise, Fintesk has the right to permanently delete the Account, including all Customer Data contained therein.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#6-feespayment","category":"default"},{"title":"6.1 Payment Card Authorization","content":"Fintesk (LibroContable SpA) and its Affiliates may request pre-authorization of the Customer\'s payment card account prior to the purchase of Fintesk Services to verify that the payment card is valid and has the necessary funds or available credit to cover any purchase. The Customer agrees to approve such card pre-authorization and pay the amounts of a Plan described on the Website, and authorizes Fintesk to charge all Fees to such card account. The customer agrees to provide Fintesk with updated information regarding their payment card account upon Fintesk\'s request and at any time the information previously provided is no longer valid.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#61-payment-card-authorization","category":"default"},{"title":"6.2 Direct Debit Payments","content":"If the Customer agrees, Fintesk may choose for the Customer to complete a bank debit mandate to enable bank debit payments. In such cases, Fintesk will comply with all applicable national rules and regulations related to direct debit payments.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#62-direct-debit-payments","category":"default"},{"title":"6.3 Payment Service Providers","content":"Fintesk uses Flow to process Customer bank debit payments. More information on how Flow processes Customer personal data and Customer data protection rights, including the Customer\'s right to object, is available at Flow.cl\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#63-payment-service-providers","category":"default"},{"title":"6.4 Electronic Invoice","content":"If Fintesk has not requested pre-authorization of the Customer\'s payment card, then, before the end of each payment interval, an electronic invoice will be issued to the Customer for payment of the Fee for the next payment interval. The customer must pay the invoice before the due date indicated on the invoice.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#64-electronic-invoice","category":"default"},{"title":"6.5 Late Payment Charges","content":"In the event of a delay in any payment, Fintesk may require the Customer to pay interest on the delay (late payment penalty) for the period such payment is overdue. The late payment interest rate shall be 1% per month or the maximum permitted by local law, whichever is greater.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#65-late-payment-charges","category":"default"},{"title":"6.6 Right of Set-off","content":"In addition to other rights and remedies Fintesk may have, if legally permitted, Fintesk may set off any payment obligation to the Customer that Fintesk may incur under the Terms against any fees owed to Fintesk and not yet paid by the Customer under the Terms, or any other agreement between the Customer and Fintesk.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#66-right-of-set-off","category":"default"},{"title":"7.1 Rights to Customer Data","content":"Regarding Customer Data, the Customer affirms, represents, and warrants that:\\n(i) the Customer owns their Customer Data or has the licenses, rights, consents, and permissions necessary to use and authorize Fintesk to display or use the Customer Data under all patents, trademarks, copyrights, trade secrets, or other proprietary rights in their Customer Data in a manner consistent with the intended Features of Fintesk Services and these Terms, and to grant the rights and license set forth in these Terms, and\\n(ii) the Customer Data, or Fintesk\'s or any Fintesk licensee\'s use of such Customer Data pursuant to these Terms, does not:\\n(a) infringe, violate, or misappropriate any third-party right, including copyright, trademark, patent, trade secret, moral right, right of privacy, right of publicity, or any other intellectual property or proprietary right;\\n(b) violate any applicable law or regulation anywhere in the world; or\\n(c) require obtaining a license or paying fees and/or royalties by Fintesk to a third party for the provision of any Fintesk Service the Customer has chosen for Fintesk to perform or for the exercise of any right granted in these Terms, unless expressly agreed otherwise by the Customer and Fintesk.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#71-rights-to-customer-data","category":"default"},{"title":"7.2 Uploading Customer Data to Fintesk Services","content":"The Customer is solely responsible for their own Customer Data and the consequences of posting it on or through the Fintesk Service.\\nIf the Customer uploads Customer Data to Fintesk Services, such Customer Data and any processing of such Customer Data must comply with these Terms and applicable law.\\nAll rights, title, and interest in and to Customer Data belong to the Customer or their respective owners (including Users, individuals, and organizations), whether posted and/or uploaded by the Customer or made available on or through Fintesk Services.\\nBy uploading Customer Data to Fintesk Services, the Customer authorizes Fintesk to process the Customer Data.\\nThe customer is responsible for ensuring that:\\nThe Customer and any of the Users associated with the Account do not create, transmit, display, or otherwise make available Customer Data that violates these Terms, the rights of Fintesk, other customers or users of Fintesk Services, or individuals or organizations;\\nthe Customer Data is not harmful (e.g., viruses, worms, malware, and other destructive codes), offensive, threatening, abusive, harassing, tortious, defamatory, vulgar, obscene, invasive of another\'s privacy, hateful, or illegal; and\\nThe Customer and all Users associated with the Account have the necessary rights to use the Customer Data, including inserting it into Fintesk Services and processing it through the Account.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#72-uploading-customer-data-to-fintesk-services","category":"default"},{"title":"7.3 No Responsibility for Customer Data","content":"Fintesk does not guarantee any accuracy regarding the information contained in Customer Data and recommends that the Customer carefully consider what they transmit, submit, or post via Fintesk Services. The Customer understands that all information contained in Customer Data is the sole responsibility of the person from whom such Customer Data originated. This means that the Customer, and not Fintesk, is entirely responsible for all Customer Data that is uploaded, posted, transmitted, or otherwise made available via Fintesk Services, by the Customer or their Users, as well as for any corrective action taken by Fintesk or other Customers or Users as a result of such Customer Data.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#73-no-responsibility-for-customer-data","category":"default"},{"title":"7.4 Sensitive Information and Illicit Customer Data","content":"The Customer shall not use the Fintesk Service in any way to process:\\n(a) Sensitive Information or\\n(b) Customer Data that, in any way, is prohibited by law or violates these Terms.\\nFintesk is not obligated to pre-screen, monitor, or filter Customer Data, or its processing by the Customer, to determine if it is Sensitive Information or illegal in nature.\\nHowever, if Fintesk, at its sole discretion, has reason to believe that the Customer is processing any illegal Customer Data or Sensitive Information, or if the action of its processing is illegal in nature, Fintesk has the right to:\\n(a) notify the Customer of such illegal Customer Data or Sensitive Information;\\n(b) deny its use on Fintesk Services;\\n(c) demand that the Customer bring their use of Fintesk Services into compliance with these Terms and applicable law;\\n(d) temporarily or permanently delete illegal Customer Data or Sensitive Information from Fintesk Services, restrict access to it, or remove it.\\nIf Fintesk is presented with convincing evidence that the Customer Data is not Sensitive Information or illegal, Fintesk may, at its sole discretion, restore such Customer Data or Sensitive Information, which was previously removed from Fintesk Services or Account or access to which was restricted.\\nFintesk services are not designed to comply with industry-specific regulations such as the Health Insurance Portability and Accountability Act (HIPAA) or the Federal Information Security Management Act (FISMA). As such, the Customer may not use Fintesk Services where their communications would be subject to such laws. Furthermore, the Customer may not use Fintesk Services in a manner that violates the Gramm-Leach-Bliley Act (GLBA).\\nTHE CUSTOMER ACKNOWLEDGES THAT FINTESK SERVICES HAVE NOT BEEN DESIGNED TO PROCESS OR MANAGE SENSITIVE INFORMATION AND, ACCORDINGLY, THE CUSTOMER AGREES NOT TO USE FINTESK SERVICES TO COLLECT, MANAGE, OR PROCESS SENSITIVE INFORMATION. FINTESK SHALL NOT HAVE, AND FINTESK SPECIFICALLY DISCLAIMS, ANY LIABILITY THAT MAY RESULT FROM THE CUSTOMER\'S USE OF FINTESK SERVICES TO COLLECT, PROCESS, OR MANAGE SENSITIVE INFORMATION.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#74-sensitive-information-and-illicit-customer-data","category":"default"},{"title":"7.5 Fintesk\'s Rights to Customer Data","content":"Fintesk may use Customer Data in an aggregated or anonymized format for research, educational, and other similar purposes. Fintesk may not use or publicly display Customer Data without the Customer\'s written consent and respects the Customer\'s right to exclusive ownership of Customer Data.\\nUnless specifically permitted by the Customer and otherwise set forth herein, the Customer\'s use of Fintesk Services does not grant Fintesk the license to use, reproduce, adapt, modify, publish, or distribute Customer Data created by the Customer or stored in the Customer\'s Account for commercial, marketing, or any similar purpose.\\nThe Customer expressly grants Fintesk the right to use and analyze aggregated system activity data associated with the use of Fintesk Services by the Customer and its Users for the purpose of optimizing, improving, or enhancing the way Fintesk Services operate, and to create new Features and functions in connection with Fintesk Services at Fintesk\'s sole discretion.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#75-fintesks-rights-to-customer-data","category":"default"},{"title":"7.6 Mandatory Disclosures","content":"Fintesk strives to comply with all laws, and reserves the right to remove any Customer Data from the Platform upon receiving a compliant takedown notice, including court orders or notices.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#76-mandatory-disclosures","category":"default"},{"title":"8. PRIVACY","content":"Fintesk\'s Privacy Notice is available at security-and-privacy Seguridad y privacidad\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#8-privacy","category":"default"},{"title":"9.1 Fintesk Intellectual Property Rights","content":"Fintesk Services, the Platform, Fintesk Materials, Fintesk trade names and trademarks, and any intellectual property associated therewith are, solely and exclusively, owned and operated by Fintesk, its Affiliates, or their respective third-party providers and hosting partners.\\nFintesk materials are protected by copyright, trade dress, patent, trade secret, and trademark laws, international conventions and treaties, and all other intellectual property and proprietary rights laws.\\nExcept as set forth in these Terms, the Customer\'s use of Fintesk Services and Fintesk Materials, and any part or element, does not grant the Customer any ownership right or intellectual property rights therein.\\nAny commercial or promotional distribution, publication, or exploitation of Fintesk Materials is strictly prohibited unless the Customer has received prior express written permission from Fintesk or the applicable rights holder.\\nThe Customer may not use Fintesk trade names and trademarks in any way that disparages Fintesk or its products or services, or portrays Fintesk in a false, competitively adverse, or poor manner.\\nFintesk reserves all rights to Fintesk Services, the Platform, Fintesk Materials, and Fintesk trade names and trademarks not expressly granted in the Terms.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#91-fintesk-intellectual-property-rights","category":"default"},{"title":"9.2 Content","content":"Subject to these Terms and payment of the applicable Fee, Fintesk grants the Customer and its Users a non-exclusive, non-transferable, and non-sublicensable license to download a single copy of any part of the Content solely for their personal, non-commercial use.\\nThe Customer shall not remove copyright and proprietary notices that are included in any part of the Content.\\nThe Customer expressly acknowledges that they do not acquire any ownership rights by downloading any copyrighted material from or through the Platform or Fintesk Services.\\nThe Customer shall not copy, distribute, or publish any Content or any information obtained or derived therefrom, except as expressly permitted by Fintesk.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#92-content","category":"default"},{"title":"9.3 Feedback","content":"If a Customer or a User provides Feedback to Fintesk, Fintesk shall be entitled to use such Feedback at its discretion, including, but not limited to, incorporating such suggested changes into Fintesk Services.\\nHereby, the Customer or User grants Fintesk a perpetual, irrevocable, non-exclusive, royalty-free license under all rights necessary to incorporate, publish, reproduce, distribute, modify, adapt, prepare derivative works, publicly display, publicly perform, exploit, and use Feedback for any purpose.\\nFintesk shall have the right to modify or remove any Feedback provided in public areas of the Website that Fintesk considers, at its sole discretion, harmful, offensive, threatening, abusive, harassing, tortious, defamatory, vulgar, obscene, invasive of another\'s privacy, hateful, or illegal.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#93-feedback","category":"default"},{"title":"10. DISCLAIMERS; NO WARRANTY","content":"UNLESS FINTESK EXPRESSLY STATES OTHERWISE, FINTESK SERVICES, FINTESK MATERIAL, THE PLATFORM, AND ANY CONTENT OR FEATURES AVAILABLE IN CONJUNCTION WITH OR THROUGH FINTESK SERVICES ARE PROVIDED “AS IS” AND “AS AVAILABLE” WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED. TO THE MAXIMUM EXTENT PERMITTED PURSUANT TO APPLICABLE LAW, FINTESK AND ITS AFFILIATES DISCLAIM ALL LEGAL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT OF PROPRIETARY RIGHTS, ACCURACY, PRECISION, AND RELIABILITY.\\nUNLESS FINTESK EXPRESSLY STATES OTHERWISE, FINTESK AND ITS AFFILIATES DO NOT WARRANT THAT FINTESK SERVICES AND ANY CONTENT OR FEATURES AVAILABLE IN CONJUNCTION WITH OR THROUGH FINTESK SERVICES WILL BE UNINTERRUPTED OR ERROR-FREE, THAT DEFECTS WILL BE CORRECTED, OR THAT FINTESK SERVICES AND ANY CONTENT OR FEATURES AVAILABLE IN CONJUNCTION WITH FINTESK SERVICES OR VIA FINTESK SERVICES OR THE PLATFORM THAT MAKES THEM AVAILABLE ARE FREE OF VIRUSES OR OTHER HARMFUL COMPONENTS.\\nUNLESS FINTESK EXPRESSLY STATES OTHERWISE, FINTESK AND ITS AFFILIATES DO NOT WARRANT OR MAKE ANY REPRESENTATION REGARDING THE USE OR THE RESULTS OF THE USE OF THE PLATFORM, FINTESK SERVICES, FINTESK MATERIALS, OR ANY WEBSITE, IN TERMS OF CORRECTNESS, ACCURACY, RELIABILITY, OR OTHERWISE.\\nIF THE LAWS OF CERTAIN COUNTRIES AND STATES DO NOT ALLOW LIMITATIONS ON IMPLIED WARRANTIES OR THE EXCLUSION OR LIMITATION OF CERTAIN DAMAGES, SOME OR ALL OF THE ABOVE DISCLAIMERS, EXCLUSIONS, OR LIMITATIONS, SET FORTH IN THIS SECTION 10, MAY NOT APPLY TO FINTESK, AND THE CUSTOMER MAY HAVE ADDITIONAL RIGHTS AS SET FORTH BY LAW.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#10-disclaimers-no-warranty","category":"default"},{"title":"11. INDEMNIFICATION","content":"The Customer agrees to defend, indemnify, and hold harmless FINTESK and its Affiliates, and their respective directors, officers, employees, and agents, from any claim, loss, damage, liability, including attorney\'s fees, arising from the use or misuse of FINTESK Services, FINTESK Materials, representations made to FINTESK, its Affiliates and/or third parties, violation of these Terms, violation of the rights of any other person or entity, or any breach of the foregoing representations, warranties, and covenants. FINTESK reserves the right, at its expense, to assume the exclusive defense and control of any matter for which the Customer is required to indemnify FINTESK, and the Customer agrees to cooperate with such defense of these claims.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#11-indemnification","category":"default"},{"title":"12.1 No Liability","content":"Fintesk shall not be liable to the Customer or User for consequences arising from:\\nany modification of these Terms, modification of Fintesk Services, Fintesk Material, use of the Account by the Customer or any part or element thereof, including, but not limited to, any error, permanent or temporary interruption, discontinuation, suspension, or other type of unavailability of Fintesk Services or Fintesk Materials;\\ndeletion, corruption, or failure to store Customer Data;\\nuse of Customer Data by the Customer or any of the Users associated with the Account;\\nupgrade or downgrade of a current Plan by the Customer;\\nany disclosure, loss, or unauthorized use of login credentials of the Customer or any User due to the Customer failing to keep them confidential;\\nthe Customer\'s use of the Account or Fintesk Services by means of web browsers other than those accepted or supported by Fintesk;\\nthe application of any remedy against the Customer or Users by Fintesk; for example, if the Customer or User has committed a crime or infringed applicable law when using Fintesk Services or any part or element thereof;\\ndifferences between technologies and platforms used for access; for example, if certain Features, functions, parts, or elements of Fintesk Services are designed for use on a personal or laptop computer and do not work on a mobile platform or tablet;\\nFintesk\'s application of the remedies described in these Terms, even if the reasonable grounds or legal basis for the application of these remedies were subsequently found to be unfounded or invalid.\\nFurthermore, Fintesk and its Affiliates shall not be liable to the Customer for any claim by any user, person, organization, or third parties against the Customer arising from the fact that the Customer fails to:\\nprovide Fintesk with accurate information about the Customer, Users, or the Account;\\nnotify Fintesk of any reason why a User does not have the right to use the Account on behalf of the Customer;\\nprovide any Fintesk Service or Feature they have agreed to provide to any person or organization (whether such failure arises as a result of Fintesk\'s negligence, breach of these Terms, or otherwise);\\nensure the legality of Customer Data;\\nobtain necessary rights to use Customer Data; or\\ncomply with any of the restrictions described in these Terms.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#121-no-liability","category":"default"},{"title":"12.2 Limitation of Liability","content":"IN NO EVENT SHALL THE TOTAL LIABILITY OF FINTESK AND ITS AFFILIATES ARISING OUT OF OR RELATED TO THESE TERMS, WHETHER REGARDING A SINGLE OCCURRENCE OR A SERIES OF OCCURRENCES, EXCEED THE TOTAL AMOUNT PAID BY THE CUSTOMER HEREUNDER FOR THE SPECIFIC FINTESK SERVICES THAT GAVE RISE TO THE LIABILITY IN THE SIX MONTHS PRECEDING THE FIRST INCIDENT FROM WHICH THE LIABILITY AROSE. THE FOREGOING LIMITATION WILL APPLY WHETHER AN ACTION IS FOR NEGLIGENCE, CONTRACT OR TORT, MISREPRESENTATION, OR OTHERWISE, AND REGARDLESS OF THE THEORY OF LIABILITY, BUT WILL NOT LIMIT THE CUSTOMER\'S PAYMENT OBLIGATIONS SET FORTH IN SECTION 5 “FEES/PAYMENT”.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#122-limitation-of-liability","category":"default"},{"title":"12.3 Exclusion of Consequential and Related Damages","content":"EXCEPT FOR THE CUSTOMER\'S INDEMNIFICATION OBLIGATIONS SET FORTH IN SECTION 11 “INDEMNIFICATION”, IN NO EVENT SHALL EITHER PARTY OR ITS AFFILIATES HAVE ANY LIABILITY ARISING OUT OF OR RELATED TO THESE TERMS FOR LOSS OF PROFITS, REVENUE, GOODWILL, OR INDIRECT, SPECIAL, INCIDENTAL, CONSEQUENTIAL, COVER, BUSINESS INTERRUPTION, OR PUNITIVE DAMAGES, WHETHER AN ACTION FOR CONTRACT OR TORT AND REGARDLESS OF THE THEORY OF LIABILITY, EVEN IF A PARTY OR ITS AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES OR IF A PARTY OR ITS AFFILIATES HAVE BEEN ADVISED THAT THE REMEDY OTHERWISE FAILS OF ITS ESSENTIAL PURPOSE. THE FOREGOING DISCLAIMER WILL NOT APPLY TO THE EXTENT PROHIBITED BY LAW.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#123-exclusion-of-consequential-and-related-damages","category":"default"},{"title":"13.1 For Convenience","content":"These Terms and/or the Customer\'s access to Fintesk Services may be terminated for convenience in the following situations;\\nby the Customer at any time:\\n\\n(i) by clicking the cancellation link on the Website,\\n(ii) by revoking the billing agreement in their PayPal profile, if the Customer is paying for the Fintesk Service with a PayPal account; or\\n(iii) by means agreed between the Customer and the Reseller, if the Customer pays for the Fintesk Service through a Reseller;\\n\\n\\nby Fintesk upon the decision to end the provision of any part of Fintesk Services, any Feature, and/or close any part of the Platform;\\nby Fintesk at any stage and for any reason, provided that Fintesk provides a prorated refund of any unused Fee for the remainder of the Term; or\\nimmediately by either party, if liquidation or insolvency proceedings are commenced against the other party or a negotiated arrangement with the other party\'s creditors is concluded or an assignment is made on behalf of the other party for the benefit of creditors.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#131-for-convenience","category":"default"},{"title":"13.2 For Default","content":"These Terms and/or the Customer\'s access to Fintesk Services may be terminated for default by written notice to the other party as indicated in Section 15.6 “Notice”:\\nby either party in the event of a breach of these Terms by the other party, if the breach has not been cured within 30 days of receiving notice from the non-breaching party;\\nimmediately by either party if the other party breaches its obligations, as applicable under Sections 4 “Restrictions”, 7 “Customer Data/Sensitive Information”, 9 “Intellectual Property Rights”, or 11 “Indemnification”; or\\nby Fintesk with immediate effect if:\\n\\n(i) the Customer\'s use of Fintesk Services is suspected, at Fintesk\'s sole discretion, to be illegal activity,\\n(ii) requests made by law enforcement, a court order, or other government agencies for such termination, or\\n(iii) if the Customer\'s use of Fintesk Services endangers the property of others, the Website, or the Platform.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#132-for-default","category":"default"},{"title":"13.3 Effect of Termination","content":"Upon termination of these Terms and/or the Customer\'s access to Fintesk Services for any reason:\\nFintesk will deactivate and permanently delete the Account and all Customer Data in Fintesk Services within 6 months after the effective date of termination of these Terms and/or the Customer\'s access to Fintesk Services. If the Customer has specifically requested an earlier deletion of the Account and all Customer Data, Fintesk will comply with such request within 1 month of receiving such request.\\nThe customer must:\\n\\ncease using and prevent further use of Fintesk Services, including, but not limited to, the Platform;\\npay amounts owed to Fintesk under these Terms; and\\nrelease any liability incurred by the Customer under these Terms prior to termination.\\n\\n\\nExcept as otherwise set forth herein, in no event will the Customer receive a refund of Fees paid in advance hereunder.\\nThe following provisions will survive the termination of these Terms: Sections 1, 2, 4, 6, 7-9, 11, 12, 14, and 15.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#133-effect-of-termination","category":"default"},{"title":"13.4 Suspension","content":"Fintesk has the right to suspend access to all or part of the Fintesk Service or an Account, including removal of Content, at any time and for any period of time, for:\\n(i) breach or suspected breach of these Terms,\\n(ii) legal obligations\\n(iii) bandwidth usage by the Customer or its Users of the Fintesk Service, any Feature, or functionality is significantly excessive relative to other users of the Fintesk Service, or to protect the integrity, operability, and security of the Fintesk Service, effective immediately, with or without prior notice.\\nUnless prohibited by law or legal process, or to prevent imminent harm to the Fintesk Service or any third party, Fintesk generally provides notice in the form of a banner or email prior to such suspension.\\nFintesk, at its discretion and in good faith, will tailor any suspension as necessary to preserve the integrity, operability, and security of the Fintesk Service.\\nFor any such suspension, Fintesk will make the sole determination as to any credit or refund of prepaid Fees by the Customer.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#134-suspension","category":"default"},{"title":"14.1 Fintesk Contracting Entity","content":"The Fintesk entity with which the Customer contracts under these Terms depends on the Customer\'s domicile. Fintesk determines the Customer\'s domicile based on the country indicated in the Customer\'s billing address. For Free Trials, Fintesk determines the Customer\'s domicile based on the location indicated by the Customer\'s IP address.\\nBy accepting these Terms or using Fintesk Services, the Customer is contracting with the Fintesk entity indicated:\\nLibroContable SpA (Fintesk)\\nEmail: contacto@fintesk.com\\nAddress: Dr. Manuel Barros Borgoño 71, office 1105.\\nProvidencia, Santiago, Chile.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#141-fintesk-contracting-entity","category":"default"},{"title":"14.2 Arbitration/Applicable Law and Jurisdiction","content":"In the event of a dispute, controversy, or claim arising out of or in relation to these Terms, including, but not limited to, the formation, validity, breach, or termination thereof, the parties will attempt to resolve the matter amicably in mutual negotiations. In the event that a mutually acceptable resolution cannot be reached within a reasonable time, either party shall be entitled to seek all available remedies, including legal remedies subject to the terms and conditions set forth below.\\nNotwithstanding the foregoing and subject to the terms and conditions set forth below, either party may seek injunctive relief regarding any disputed matter to the extent possible under applicable law.\\nIn the event that an amicable settlement is not possible between the parties, the dispute shall be finally resolved by arbitration as designated herein, subject to the terms and conditions set forth below.\\nThe United Nations Convention on Contracts for the International Sale of Goods (Vienna Convention of 1980) shall not apply to these Terms.\\nAny matter related to these Terms that is not expressly or implicitly resolved by the provisions contained in these Terms shall be governed and interpreted in accordance with the following:\\nFor Customers not specifically referred to in these Terms, all disputes or controversies arising out of or in relation to the Terms, including any question regarding their existence, validity, or termination, shall be resolved under the common domicile of the City of Santiago and where both the Customer and Fintesk agree to submit to the judicial authorities that the law determines as competent to resolve the controversy arising between the parties, in the manner and under the parameters established in the corresponding legislation.\\nArbitration shall be initiated by a request for arbitration from either party, delivered to the other party.\\nThe request for arbitration shall state the nature of the claim(s) and the relief sought.\\nExcept as specifically limited otherwise in these Terms, the arbitral tribunal shall have the power to grant any remedy or relief it deems appropriate, whether provisional or final, including, but not limited to, injunctive relief and any measure ordered by the arbitral tribunal, to the extent permitted by applicable law, shall be deemed a final award on the subject matter of the measures and shall be enforceable as such.\\nEach party retains the right to apply to any court of competent jurisdiction for provisional and/or interim measures, including pre-arbitral attachments or injunctions, and such request shall not be deemed incompatible with the arbitration agreement or a waiver of the right to arbitrate.\\nThe parties and members of the arbitral tribunal shall maintain the confidentiality of the existence and content of the arbitration proceedings and any ruling or award, except\\n(i) to the extent that disclosure is required of a party to fulfill a legal duty, protect or pursue a legal right, or enforce or challenge an award in bona fide legal proceedings before a state court or other judicial authority,\\n(ii) with the consent of all parties,\\n(iii) when necessary for the preparation or presentation of a claim or defense in this arbitration,\\n(iv) when such information is already in the public domain except as a result of a breach of this clause, or\\n(v) by order of the arbitral tribunal upon request of one of the parties.\\nThe arbitral tribunal may include in its award an allocation to any of the parties of costs and expenses, including attorney\'s fees, that the arbitral tribunal deems reasonable.\\nAny award of the arbitral tribunal shall be final and binding on the parties. Enforcement of any award may be sought in any court of competent jurisdiction.\\nFor all purposes of these Terms, the parties agree to\\n(a) exclusive jurisdiction and venue in the county of Santiago, Chile and\\n(b) the laws of Chile as applicable law, without giving effect to any conflict of laws principles.\\nUse of Fintesk Services is not authorized in any jurisdiction that does not give effect to all provisions of these Terms, including, without limitation, this section.\\nNotwithstanding the foregoing, the Customer and Fintesk agree that nothing contained herein shall be construed as a waiver, exclusion, or limitation of either party\'s right to (i) undertake enforcement actions through appropriate federal, state, or local agencies where such actions are available, (ii) seek injunctive relief in a court of law, or (iii) file a lawsuit in a court of law to address intellectual property infringement claims.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#142-arbitrationapplicable-law-and-jurisdiction","category":"default"},{"title":"15.1 Relationship of the Parties","content":"The parties shall act solely as independent contractors. These Terms shall not be construed as creating an agency, partnership, joint venture, fiduciary duty, or any other form of legal association between the Customer and Fintesk, and the Customer shall not represent otherwise, whether expressly, implicitly, apparently, or otherwise. These Terms are not for the benefit of third parties.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#151-relationship-of-the-parties","category":"default"},{"title":"15.2 Severability","content":"If any term, condition, or provision of these Terms is held to be invalid, unenforceable, or illegal in whole or in part for any reason, that provision shall apply to the maximum extent permitted to achieve the intent of the parties. The validity and enforceability of the remaining terms, conditions, or provisions, or parts thereof, shall not be affected.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#152-severability","category":"default"},{"title":"15.3 Entire Agreement","content":"These Terms constitute the entire agreement between the Customer and Fintesk regarding the Customer\'s use of Fintesk Services, Fintesk Materials, and the Platform and supersede all prior and contemporary agreements, proposals, or representations, written or oral, regarding its subject matter.\\nExcept as otherwise provided herein, no modification, amendment, or waiver of any provision of these Terms shall be effective unless made in writing and signed by the party against whom the modification, amendment, or waiver is asserted.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#153-entire-agreement","category":"default"},{"title":"15.4 Assignment","content":"The customer may not, directly or indirectly, in whole or in part, by operation of law or otherwise, assign or transfer these Terms or delegate any of their rights and/or obligations under these Terms without Fintesk\'s prior written consent.\\nAny attempt at assignment, transfer, or delegation without such prior written consent shall be void and unenforceable.\\nNotwithstanding the foregoing, the Customer, or their permitted successors or assigns, may assign or transfer these Terms or delegate any right or obligation hereunder without consent:\\n(1) to any entity controlled by, or under common control with the Customer, or their permitted successors or assigns; or\\n(2) in connection with a merger, reorganization, transfer, sale of assets or product lines, or change of control or ownership of the Customer, or their permitted successors or assigns.\\nFintesk may freely assign or transfer these Terms or delegate any of its rights and/or obligations under these Terms without restriction.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#154-assignment","category":"default"},{"title":"15.5 No Waiver","content":"Failure by either party to exercise or enforce any provision or any of its rights under these Terms shall not be deemed a waiver of future application of that or any other provision or right.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#155-no-waiver","category":"default"},{"title":"15.6 Notices","content":"Except as otherwise specified in the Terms, all notices related to the Terms shall be in writing and shall be effective as of\\n(a) personal delivery,\\n(b) the second business day after mailing, or\\n(c), except for termination notices or an indemnifiable claim, which shall be clearly identifiable as “Legal Notices”, on the day of their sending by email.\\nNotices related to billing the Customer will be sent to the corresponding billing contact designated by the Customer via email.\\nAll other notices to the Customer will be addressed to the corresponding Customer system administrator designated by the Customer.\\n","section":"Fintesk Terms of Service","version":"current","path":"/tos/terms-of-service#156-notices","category":"default"},{"title":"El Desafío Generalizado de los Leads de Baja Calidad en el Marketing Digital","content":"La preocupación inicial del usuario pone de manifiesto un problema común en el ámbito del marketing digital: la atracción de un gran volumen de prospectos que, en última instancia, no se traducen en ventas concretas.\\n<!-- truncate -->\\nGenerar una buena cantidad de leads no es lo más importante, sino, de manera crítica, en su calidad y su grado de alineación con la oferta y el público objetivo de la empresa.\\nRevisaremos estrategias para no solo aumentar el número de consultas, sino, lo que es más importante, asegurar que dichas consultas provengan de prospectos genuinamente interesados y calificados.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/blog/estrategias-para-atraer-leads-de-alta-calidad#el-desafío-generalizado-de-los-leads-de-baja-calidad-en-el-marketing-digital","category":"blogs"},{"title":"Entendiendo la Calidad de los Leads: Definiendo Prospectos Valiosos para su Negocio","content":"Lo que constituye un \\"lead de alta calidad\\" varía en función del negocio específico, su público objetivo y sus ofertas particulares.\\nUn \\"lead basura\\" es aquel que no cumple ni siquiera con los requisitos mínimos (por ejemplo, una consulta minorista para un negocio mayorista).\\nEs importante destacar que un lead que finalmente no realiza una compra no es necesariamente un \\"lead basura\\", sino más bien un prospecto no convertido.\\nLa definición clara de un Perfil de Cliente Ideal(ICP) resulta crucial para distinguir entre leads de alta y baja calidad. Los \\"leads basura\\" se relacionan directamente con desviaciones de este perfil ideal (tipo de compra incorrecto, ubicación incorrecta, cantidad incorrecta, falta de presupuesto). Por lo tanto, un ICP bien definido actúa como el punto de referencia para la calidad de los leads.\\nAdemás, la percepción de \\"lead basura\\" puede ser subjetiva y verse influenciada por el porcentaje de leads de baja calidad en relación con el volumen total (consulta inicial). Incluso un pequeño número de leads no deseados puede generar una sensación de saturación y frustración. Por ello, las empresas necesitan realizar un seguimiento y analizar la proporción de los diferentes tipos de leads para obtener una comprensión realista de su calidad general.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/blog/estrategias-para-atraer-leads-de-alta-calidad#entendiendo-la-calidad-de-los-leads-definiendo-prospectos-valiosos-para-su-negocio","category":"blogs"},{"title":"El Impacto Perjudicial de los \\"Leads Basura\\": Costos, Eficiencia y Moral del Equipo","content":"El procesamiento de leads de baja calidad consume tiempo y recursos valiosos de los equipos de ventas y marketing.\\nEsto puede acarrear una disminución de la productividad, un desperdicio de esfuerzo y tasas de conversión más bajas.\\nTambién puede afectar negativamente la moral del equipo, ya que los representantes de ventas pueden sentirse frustrados por la falta de prospectos calificados.\\nCentrarse en la calidad de los leads por encima de la cantidad puede mejorar significativamente el retorno de la inversión (ROI) de los esfuerzos de marketing, al reducir los recursos desperdiciados en prospectos no calificados.\\nEl Costo por Lead (CPL) es una métrica clave para evaluar la eficiencia de las campañas de Marketing.\\nSi un gran porcentaje de los leads son \\"basura\\", el CPL efectivo para los leads calificados aumenta, lo que disminuye el ROI.\\nUn porcentaje significativo de los leads nunca se convierte en ventas, lo que implica una inversión desperdiciada si esos leads fueron de baja calidad desde el principio.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/blog/estrategias-para-atraer-leads-de-alta-calidad#el-impacto-perjudicial-de-los-leads-basura-costos-eficiencia-y-moral-del-equipo","category":"blogs"},{"title":"Refinando la Segmentación y el Targeting de Audiencia en Plataformas Digitales","content":"Diferentes canales de publicidad atraen a distintos tipos de audiencias con diferentes niveles de calificación.\\nPor ejemplo, Google Ads podría generar menos leads, pero estos podrían estar más calificados, en comparación con Meta (Facebook/Instagram), que podría generar un mayor volumen, pero requerir un mayor filtrado.\\nMeta permite la optimización para leads de \\"Mayor Intención\\", lo que sugiere un enfoque en usuarios con mayor probabilidad de conversión.\\nSe debería considerar el uso de canales menos obvios que podrían generar una mejor calidad si Google Ads resulta demasiado competitivo o costoso puede ser una estrategia acertada.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/blog/estrategias-para-atraer-leads-de-alta-calidad#refinando-la-segmentación-y-el-targeting-de-audiencia-en-plataformas-digitales","category":"blogs"},{"title":"Creando Textos de Anuncios Atractivos y Calificados","content":"El mensaje transmitido en los anuncios puede actuar como un filtro.\\nLos elementos creativos de los anuncios deben ser llamativos y utilizar mensajes claros y potentes llamados a la acción (CTA) para atraer el tipo de atención adecuado.\\nEl texto del anuncio debe articular claramente la propuesta de valor y el cliente ideal para la oferta.\\nTambién debería incluir sutilmente criterios de calificación (por ejemplo, \\"Para empresas con más de 50 empleados\\").\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/blog/estrategias-para-atraer-leads-de-alta-calidad#creando-textos-de-anuncios-atractivos-y-calificados","category":"blogs"},{"title":"Optimizando las Páginas de Destino (landing pages) para aumentar la Conversión","content":"Las páginas de destino deben optimizarse para la captura de leads y diseñarse para las conversiones.\\nLos formularios en las páginas de destino deben ser sencillos y fáciles de completar para evitar el abandono.\\nLa información solicitada en el formulario desempeña un papel crucial en la calificación inicial de los leads.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/blog/estrategias-para-atraer-leads-de-alta-calidad#optimizando-las-páginas-de-destino-landing-pages-para-aumentar-la-conversión","category":"blogs"},{"title":"Aprovechando Estrategias Específicas de Canal (Google Ads, Meta, etc.)","content":"Como se mencionó anteriormente, los diferentes canales tienen diferentes fortalezas y debilidades en términos de calidad y volumen de leads.\\nGoogle Ads, cuando se realiza correctamente, genera leads de mayor calidad debido a la intención de búsqueda de los usuarios.\\nMeta (Facebook, Instagram) puede proporcionar un mayor volumen de leads, pero puede requerir un filtrado más riguroso.\\nTambién se deben considerar otros canales relevantes, como por ejemplo LinkedIn para leads B2B.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/blog/estrategias-para-atraer-leads-de-alta-calidad#aprovechando-estrategias-específicas-de-canal-google-ads-meta-etc","category":"blogs"},{"title":"Implementando Preguntas de Calificación Efectivas en los Formularios de Captura de Leads","content":"Idealmente lograr un filtrado en tres etapas, siendo la primera dentro de la propia campaña.\\nLas preguntas de calificación en los formularios son una táctica clave en esta etapa.\\nFormular preguntas de calificación en los formularios de captura de leads es una forma directa de filtrar a los usuarios no interesados o no calificados.\\nEsto permite a las empresas recopilar información crucial desde el principio.\\nEjemplos de preguntas de calificación:\\n\\"¿Cuál es su sector?\\" (para filtrar por sectores relevantes).\\n\\"¿Cuál es su cargo en la empresa?\\" (para identificar a los responsables de la toma de decisiones).\\n\\"¿Cuántos empleados tiene su empresa?\\" (para filtrar por tamaño de la empresa).\\n\\"¿Es usted el responsable de la toma de decisiones?\\".\\n\\"¿Es usted responsable del presupuesto de compra?\\".\\nLos formularios pueden incluir campos de \\"filtro\\" para calificar directamente a los leads en función de criterios como el sector, el cargo o los ingresos.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/blog/estrategias-para-atraer-leads-de-alta-calidad#implementando-preguntas-de-calificación-efectivas-en-los-formularios-de-captura-de-leads","category":"blogs"},{"title":"Utilizando Chatbots para la Selección Inicial de Leads","content":"Filtrado después de que el lead ha llegado.\\nLos chatbots pueden desempeñar un papel importante en este proceso.\\nLos chatbots pueden ser una tecnología eficaz para capturar leads y calificarlos simultáneamente a través del marketing conversacional.\\nLos chatbots utilizan el marketing conversacional para extraer datos de los visitantes y determinar la calidad del lead antes de pasarlo a ventas.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/blog/estrategias-para-atraer-leads-de-alta-calidad#utilizando-chatbots-para-la-selección-inicial-de-leads","category":"blogs"},{"title":"Desarrollando Procesos Manuales de Revisión de Leads","content":"También es bastante usado, siguiendo el filtrado después de que el lead haya llegado, el realizar una calificación manual basada en la lectura de la información proporcionada por el lead (por ejemplo, tamaño de la empresa, necesidades).\\nEsto implica que un agente (humano) revise la información del lead y realice una evaluación inicial de su calidad. Esto puede resultar especialmente útil para los leads generados a través de canales donde el filtrado automatizado es menos efectivo.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/blog/estrategias-para-atraer-leads-de-alta-calidad#desarrollando-procesos-manuales-de-revisión-de-leads","category":"blogs"},{"title":"Aprovechando Sistemas Automatizados de Puntuación de Leads","content":"Existe la posibilidad de utilizar la automatización para filtrar leads.\\nLa implementación de un sistema de puntuación de leads permite el etiquetado y la priorización automáticos de los leads en función de criterios predefinidos.\\nLa puntuación de leads es una metodología complementaria al Lead Nurturing, que se aplica a campañas de Email Marketing en una estrategia de Inbound Marketing y permite clasificar el grado de interés de un lead y su nivel de preparación para la compra.\\nLa puntuación de leads puede considerar datos explícitos (información proporcionada en los formularios) y datos implícitos (comportamiento del lead, como visitas al sitio web o aperturas de correos electrónicos).\\nEl software CRM a menudo incluye funciones para la puntuación automática de leads.\\nLos leads que alcanzan un cierto umbral de puntuación pueden pasarse automáticamente al equipo de ventas, mientras que los leads con puntuaciones más bajas pueden ser objeto de un mayor seguimiento.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/blog/estrategias-para-atraer-leads-de-alta-calidad#aprovechando-sistemas-automatizados-de-puntuación-de-leads","category":"blogs"},{"title":"El Papel Estratégico del Software CRM en la Gestión y Calificación de Leads","content":"Es recomendable el uso de un CRM para trabajar en ventas y categorizar manualmente los leads por los siguientes motivos:\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/blog/estrategias-para-atraer-leads-de-alta-calidad#el-papel-estratégico-del-software-crm-en-la-gestión-y-calificación-de-leads","category":"blogs"},{"title":"Centralización de Datos de Leads y Seguimiento de Interacciones","content":"Los sistemas CRM sirven como un repositorio central para todos los datos de los leads, lo que permite una visión integral de cada prospecto y sus interacciones con la empresa. Esto ayuda a evitar silos de datos y garantiza que tanto los equipos de marketing como los de ventas tengan acceso a la misma información.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/blog/estrategias-para-atraer-leads-de-alta-calidad#centralización-de-datos-de-leads-y-seguimiento-de-interacciones","category":"blogs"},{"title":"Implementación de Puntuación y Etiquetado Automatizados de Leads","content":"Muchos sistemas CRM ofrecen funciones automatizadas de puntuación de leads. También pueden etiquetar automáticamente los leads en función de diversos criterios (por ejemplo, fuente, datos demográficos, nivel de participación).\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/blog/estrategias-para-atraer-leads-de-alta-calidad#implementación-de-puntuación-y-etiquetado-automatizados-de-leads","category":"blogs"},{"title":"Facilitando la Alineación entre Ventas y Marketing","content":"Las plataformas CRM pueden mejorar la alineación entre los equipos de ventas y marketing al proporcionar una visión compartida del embudo de leads y facilitar la retroalimentación sobre la calidad de los leads. Esto garantiza que los esfuerzos de marketing se centren en generar los tipos de leads que el equipo de ventas puede convertir eficazmente.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/blog/estrategias-para-atraer-leads-de-alta-calidad#facilitando-la-alineación-entre-ventas-y-marketing","category":"blogs"},{"title":"Nutrición de Leads para Mejorar la Calidad y la Conversión","content":"Es importante realizar el procesamiento correcto de los leads, incluso si inicialmente se consideran \\"basura\\" (por ejemplo, manteniéndolos en la base de datos de contactos).\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/blog/estrategias-para-atraer-leads-de-alta-calidad#nutrición-de-leads-para-mejorar-la-calidad-y-la-conversión","category":"blogs"},{"title":"Desarrollo de Estrategias de Contenido Dirigido para Diferentes Etapas del Lead","content":"La nutrición de leads implica proporcionar contenido relevante y valioso a los prospectos en diferentes etapas del recorrido del comprador para construir relaciones y guiarlos hacia una compra. El contenido puede incluir publicaciones de blog, libros electrónicos, seminarios web, estudios de casos y más. La creación de contenido alineado con cada etapa del embudo de marketing (conciencia, consideración, acción) resulta crucial para una nutrición de leads eficaz.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/blog/estrategias-para-atraer-leads-de-alta-calidad#desarrollo-de-estrategias-de-contenido-dirigido-para-diferentes-etapas-del-lead","category":"blogs"},{"title":"Personalización de la Comunicación para Aumentar la Participación","content":"La personalización del email marketing y otras comunicaciones basadas en los datos y el comportamiento de los leads puede aumentar significativamente las tasas de participación y conversión. Esto puede implicar el uso de contenido dinámico en los correos electrónicos y la segmentación de las listas en función de diversos criterios.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/blog/estrategias-para-atraer-leads-de-alta-calidad#personalización-de-la-comunicación-para-aumentar-la-participación","category":"blogs"},{"title":"Implementación de la Puntuación de Leads para Identificar Prospectos Listos para la Venta","content":"Los esfuerzos de nutrición de leads deben realizar un seguimiento continuo de la participación de los leads y actualizar sus puntuaciones en consecuencia.\\nLos leads con altas puntuaciones de participación tienen más probabilidades de estar listos para la venta.\\nLa puntuación de leads ayuda a identificar qué leads nutridos están mostrando fuertes señales de compra y deben ser priorizados por el equipo de ventas. Incluso los \\"leads basura\\" podrían volverse valiosos en el futuro si sus circunstancias cambian, por lo que mantenerlos en una base de datos y nutrirlos adecuadamente puede resultar beneficioso (consulta inicial).\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/blog/estrategias-para-atraer-leads-de-alta-calidad#implementación-de-la-puntuación-de-leads-para-identificar-prospectos-listos-para-la-venta","category":"blogs"},{"title":"Midiendo el Éxito de los Esfuerzos para Mejorar la Calidad de los Leads","content":"En otro artículo estaremos ahondando en las siguientes métricas, pero por el momento las mencionaremos.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/blog/estrategias-para-atraer-leads-de-alta-calidad#midiendo-el-éxito-de-los-esfuerzos-para-mejorar-la-calidad-de-los-leads","category":"blogs"},{"title":"Indicadores Clave de Rendimiento (KPIs)","content":"Tasas de Conversión: Seguimiento del porcentaje de leads que se convierten en oportunidades calificadas y, en última instancia, en clientes.\\nCosto por Lead (CPL): Monitoreo del costo promedio de adquisición de un lead, con un enfoque en el CPL para los leads calificados.\\nDuración del Ciclo de Ventas: Medición del tiempo que tarda un lead en avanzar a través del embudo de ventas y convertirse en cliente. Una mejor calidad de los leads debería idealmente acortar el ciclo de ventas.\\nMétricas de Participación de los Leads: Seguimiento de las tasas de apertura de correos electrónicos, las tasas de clics, las visitas al sitio web y las descargas de contenido para evaluar el interés y la calidad de los leads.\\nRetroalimentación del Equipo de Ventas: Solicitud periódica de retroalimentación del equipo de ventas sobre la calidad de los leads que están recibiendo.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/blog/estrategias-para-atraer-leads-de-alta-calidad#indicadores-clave-de-rendimiento-kpis","category":"blogs"},{"title":"Utilización de Herramientas de Análisis para el Seguimiento y la Elaboración de Informes","content":"Plataformas como Google Analytics y los paneles de análisis de las plataformas de publicidad (por ejemplo, Meta Ads Manager) proporcionan datos valiosos para el seguimiento del rendimiento de la generación de leads.\\nLos sistemas CRM también ofrecen funciones de informes para analizar la calidad de los leads y las métricas de conversión.\\nUn porcentaje significativo de los profesionales del marketing evalúan la calidad de sus leads, lo que destaca su importancia como métrica.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/blog/estrategias-para-atraer-leads-de-alta-calidad#utilización-de-herramientas-de-análisis-para-el-seguimiento-y-la-elaboración-de-informes","category":"blogs"},{"title":"Implementando un Enfoque Holístico para Atraer y Gestionar Leads de Alta Calidad en sus Campañas de Marketing Digital","content":"Atraer leads de alta calidad y gestionar eficazmente los de baja calidad requiere un enfoque multifacético que integre estrategia, tácticas y tecnología. Las empresas de la Región Metropolitana de Santiago deberían centrarse en:\\nDefinir claramente su perfil de cliente ideal.\\nOptimizar su segmentación de audiencia y los mensajes de sus anuncios en las plataformas digitales relevantes.\\nImplementar preguntas de calificación y chatbots para la selección inicial de leads.\\nAprovechar el software CRM para la gestión centralizada de leads y la puntuación automatizada.\\nDesarrollar estrategias de nutrición de leads para involucrar y calificar a los prospectos a lo largo del tiempo.\\nMonitorear y analizar continuamente los indicadores clave de rendimiento para perfeccionar sus esfuerzos de generación de leads.\\nAl adoptar estas mejores prácticas, las empresas pueden reducir significativamente el volúmen de los \\"leads basura\\" y centrar sus recursos en interactuar con los prospectos que tienen más probabilidades de convertirse en clientes valiosos, impulsando en última instancia el crecimiento de las ventas.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/blog/estrategias-para-atraer-leads-de-alta-calidad#implementando-un-enfoque-holístico-para-atraer-y-gestionar-leads-de-alta-calidad-en-sus-campañas-de-marketing-digital","category":"blogs"},{"title":"2. La Ventaja Estratégica: Por qué un CRM supera la Gestión de Ventas Tradicional","content":"La adopción de un sistema CRM ofrece una serie de ventajas estratégicas significativas en comparación con los métodos tradicionales de gestión de ventas, como el uso de hojas de cálculo o software de gestión básico.\\nEficiencia y Productividad: Los sistemas CRM mejoran la eficiencia y la productividad al automatizar tareas repetitivas como la entrada de datos, lo que permite a los equipos de ventas concentrarse en la actividad principal de vender. Funciones como los seguimientos y recordatorios automatizados aseguran una interacción oportuna con clientes potenciales y existentes. El acceso centralizado a los datos también ahorra tiempo al eliminar la necesidad de buscar información en múltiples plataformas.\\nGestión de Datos Mejorada: Un CRM proporciona una plataforma centralizada para almacenar y organizar todos los datos relacionados con los clientes, creando una \\"única fuente de verdad\\". Esto ofrece una visión integral de las interacciones con los clientes, el historial de compras y las preferencias en un solo lugar. Esto contrasta con los desafíos de administrar datos en hojas de cálculo dispersas, lo que puede generar imprecisiones y pérdida de información.\\nRelaciones con los Clientes Más Sólidas: El CRM facilita la comunicación personalizada al proporcionar información sobre las necesidades y el historial de los clientes. Permite rastrear las interacciones con los clientes a través de múltiples canales, lo que garantiza una experiencia coherente y adaptada. Además, el CRM ayuda a identificar y nutrir clientes potenciales, lo que lleva a mejores tasas de conversión y una mayor lealtad del cliente.\\nPotencial de Escalabilidad y Crecimiento: Los sistemas CRM están diseñados para crecer con la empresa, permitiendo la adición de más usuarios y funciones según sea necesario. Esto contrasta con las limitaciones de métodos tradicionales como Excel, que se vuelven cada vez más difíciles de manejar a medida que la empresa se expande. El CRM puede ayudar a las empresas a adaptar sus procesos para dar cabida al crecimiento y administrar bases de datos de clientes más grandes.\\nInformes y Análisis Robustos: El software CRM ofrece herramientas para analizar los datos de los clientes, identificar tendencias y generar informes sobre el rendimiento de las ventas y el comportamiento del cliente. Estos conocimientos pueden ayudar a las empresas a tomar decisiones basadas en datos para optimizar sus estrategias de ventas y marketing. También permite rastrear los indicadores clave de rendimiento (KPI) y monitorear el desempeño del equipo en relación con los objetivos de ventas.\\nLa adopción de un CRM representa un cambio fundamental en la forma en que las empresas abordan la interacción con el cliente, facilitando una estrategia centrada en el cliente que prioriza la construcción de relaciones a largo plazo.\\nLos métodos tradicionales a menudo carecen de la sofisticación para capturar y analizar los matices de las interacciones con los clientes.\\nEl CRM proporciona el marco y las herramientas para comprender profundamente el comportamiento del cliente, lo que permite a las empresas anticipar las necesidades y personalizar las experiencias, cruciales para fomentar la lealtad en el mercado actual.\\nLas capacidades de automatización del CRM van más allá de la simple gestión de tareas; capacitan a los equipos de ventas para que se concentren en actividades estratégicas que impactan directamente en la generación de ingresos.\\nAl reducir las cargas administrativas, el CRM permite a los profesionales de ventas dedicar más tiempo a construir una buena relación con los clientes, comprender sus puntos débiles y adaptar las soluciones. Este cambio de enfoque puede conducir a mayores tasas de cierre y una mejor satisfacción del cliente.\\n","section":"Cómo elegir el CRM o Software de Gestión de Ventas Adecuado para su Empresa","version":"current","path":"/blog/como-elegir-el-crm-o-software-de-gestion-de-ventas-adecuado-para-su-empresa#2-la-ventaja-estratégica-por-qué-un-crm-supera-la-gestión-de-ventas-tradicional","category":"blogs"},{"title":"4. Sentando las Bases: La Criticidad de la Implementación del CRM","content":"Una implementación de CRM exitosa es fundamental para la adopción por parte de los usuarios y para obtener los beneficios previstos del software. Una implementación deficiente puede llevar a una subutilización del sistema y a un retorno de la inversión negativo.\\nEs esencial una estrategia bien definida y objetivos comerciales claros para guiar el proceso de implementación.\\nAuto-Implementación: La auto-implementación se refiere al proceso en el que la empresa se encarga internamente de la configuración y puesta en marcha del CRM. Entre las posibles ventajas se encuentran un mayor control sobre el sistema y posibles ahorros iniciales en los costos. Sin embargo, también existen posibles desventajas, como la necesidad de experiencia técnica interna, la naturaleza laboriosa del proceso en tiempo y recursos, y el riesgo de errores o retrasos. La auto-implementación puede ser adecuada para empresas con equipos de TI dedicados y requisitos de CRM más sencillos.\\nImplementación Incluida en el Costo del Software: Algunos proveedores de CRM, especialmente aquellos dirigidos a las pequeñas y medianas empresas (PYMES), ofrecen asistencia para la implementación como parte de su paquete de software. Las posibles ventajas incluyen el acceso a la orientación de expertos y un proceso de configuración más fluido. Las posibles desventajas pueden incluir limitaciones en la personalización o el nivel de soporte proporcionado. Esta opción puede ser particularmente beneficiosa para las empresas más pequeñas con recursos técnicos limitados.\\nContratación de Consultores Externos: Las empresas también pueden optar por contratar consultores de CRM externos para gestionar el proceso de implementación. Entre las posibles ventajas se encuentran el acceso a experiencia especializada, mejores prácticas y tiempos de implementación más rápidos. Las posibles desventajas incluyen el costo adicional y la necesidad de seleccionar cuidadosamente a un consultor que comprenda las necesidades específicas de la empresa. Esta opción puede ser adecuada para organizaciones más grandes con requisitos de CRM complejos o aquellas que carecen de experiencia interna.\\nLa decisión de cómo implementar un sistema CRM es estratégica y tiene implicaciones significativas para el éxito del proyecto y el costo general.\\nLas PYMES, en particular, deben sopesar cuidadosamente las ventajas y desventajas entre control, costo y experiencia al elegir un enfoque de implementación. La auto-implementación puede parecer rentable inicialmente, pero la falta de experiencia puede llevar a errores y retrasos costosos.\\nPor el contrario, si bien la contratación de consultores ofrece orientación experta, el gasto puede ser prohibitivo para las empresas más pequeñas.\\nLos proveedores de CRM que incluyen la implementación pueden lograr un equilibrio, pero el nivel de soporte puede variar. Muchos de los sistemas que incluyen la implementación u ofrecen guías de auto-implementación sencillas suelen ser las opciones más viables. Esto resalta la importancia de la facilidad de uso y el soporte fácilmente disponible para las PYMES, las cuales suelen tener recursos limitados y es posible que no cuenten con personal de TI dedicado para implementaciones complejas.\\nPor lo tanto, los sistemas CRM que son intuitivos de configurar y ofrecen soporte u orientación integrados tienen más probabilidades de ser adoptados con éxito y proporcionar valor rápidamente.\\n","section":"Cómo elegir el CRM o Software de Gestión de Ventas Adecuado para su Empresa","version":"current","path":"/blog/como-elegir-el-crm-o-software-de-gestion-de-ventas-adecuado-para-su-empresa#4-sentando-las-bases-la-criticidad-de-la-implementación-del-crm","category":"blogs"},{"title":"5. Construyendo un Ecosistema Conectado: La Importancia de la Integración del CRM","content":"La integración de un sistema CRM con otras aplicaciones empresariales cruciales es vital para garantizar la precisión de los datos, optimizar los flujos de trabajo y mejorar las operaciones comerciales generales.\\nIntegración con Sistemas ERP: La integración del CRM con los sistemas de planificación de recursos empresariales (ERP) permite un flujo de datos continuo entre las funciones de front-office (ventas, marketing) y back-office (operaciones, finanzas). Esto ofrece beneficios como una mayor precisión de los datos, una mejor visibilidad en toda la empresa, un procesamiento de pedidos optimizado y una mejor gestión del inventario. Los puntos de datos comunes que se integran entre los sistemas CRM y ERP incluyen la información de contacto del cliente, el historial de pedidos y los detalles de precios.\\nIntegración con Plataformas de Automatización de Marketing: La integración del CRM con plataformas de automatización de marketing permite a las empresas optimizar la generación de leads, nutrir a los prospectos y personalizar las campañas de marketing. Esto conduce a una mejor gestión de leads, mensajes dirigidos, una mejor segmentación de clientes y un mejor seguimiento del ROI de marketing.\\nIntegración con Herramientas de Comunicación por Correo Electrónico: La integración del CRM con plataformas de correo electrónico como Gmail u Outlook permite un seguimiento continuo de la correspondencia por correo electrónico con contactos y clientes potenciales. Esto ofrece beneficios como una mejor gestión de la comunicación, un fácil acceso al historial de correo electrónico y la capacidad de enviar correos electrónicos personalizados directamente desde el CRM. Algunos sistemas CRM también ofrecen plantillas de correo electrónico y funciones de marketing por correo electrónico.\\nOtras Integraciones: Los sistemas CRM también pueden integrarse con plataformas de redes sociales, software de servicio al cliente, software de contabilidad y herramientas de colaboración. El objetivo general de estas integraciones es crear una visión unificada del cliente y optimizar los procesos comerciales.\\nLa integración del CRM es crucial para romper los silos de datos dentro de una organización y garantizar que los diferentes departamentos tengan una visión coherente y actualizada de la información del cliente.\\nEsta perspectiva unificada es esencial para brindar una experiencia de cliente perfecta en todos los puntos de contacto. Cuando el CRM se integra con otros sistemas empresariales, los datos fluyen automáticamente entre las plataformas, eliminando la necesidad de ingresar datos manualmente y reduciendo el riesgo de errores.\\nEsta sincronización en tiempo real garantiza que los equipos de ventas, marketing y servicio al cliente trabajen con la misma información, lo que lleva a interacciones con los clientes más coordinadas y efectivas.\\nLas integraciones específicas que una empresa debe priorizar dependen de sus necesidades únicas y de las otras herramientas de software que utiliza actualmente.\\nLas PYMES deben centrarse en las integraciones que abordan sus desafíos más apremiantes, como la optimización de la gestión de leads o la mejora de la comunicación con los clientes.\\nSi bien existe una amplia gama de integraciones disponibles, no todas son relevantes para todas las empresas.\\nLas PYMES deben identificar los procesos clave que desean optimizar y elegir sistemas CRM que ofrezcan una integración perfecta con las herramientas que utilizan para esos procesos.\\nPor ejemplo, una empresa de comercio electrónico probablemente priorizaría la integración con su plataforma de tienda en línea.\\n","section":"Cómo elegir el CRM o Software de Gestión de Ventas Adecuado para su Empresa","version":"current","path":"/blog/como-elegir-el-crm-o-software-de-gestion-de-ventas-adecuado-para-su-empresa#5-construyendo-un-ecosistema-conectado-la-importancia-de-la-integración-del-crm","category":"blogs"},{"title":"7. Funcionalidades Centrales: Funciones Esenciales de CRM para una Gestión de Ventas Eficaz","content":"Un sistema CRM eficaz debe ofrecer una variedad de funcionalidades básicas para facilitar la gestión de ventas y mejorar las relaciones con los clientes.\\nGestión de Contactos y Cuentas: Esta es una función fundamental para almacenar y organizar información detallada sobre contactos individuales y las empresas a las que pertenecen. Permite rastrear el historial de comunicación, las preferencias y las interacciones clave para cada contacto y cuenta. Las capacidades de segmentación para categorizar contactos y cuentas en función de diversos criterios también son esenciales.\\nSeguimiento de Clientes Potenciales y Oportunidades: Las funciones para capturar, calificar y rastrear clientes potenciales a lo largo del proceso de ventas son cruciales. El CRM ayuda a gestionar las oportunidades, incluido el seguimiento de las etapas del acuerdo, los ingresos potenciales y la probabilidad de cierre. Algunos sistemas CRM también ofrecen funcionalidades de puntuación y asignación de clientes potenciales.\\nVisualización del Embudo de Ventas: Una representación visual del embudo de ventas permite a los equipos de ventas ver el estado de los acuerdos en cada etapa. Las funciones de gestión del embudo ayudan a identificar cuellos de botella, pronosticar ventas y gestionar las actividades de ventas de manera eficaz. El embudo de ventas también debe poder personalizarse para que coincida con el proceso de ventas específico de la empresa.\\nAutomatización del Flujo de Trabajo: El CRM permite la automatización de tareas y procesos repetitivos, lo que mejora la eficiencia y libera tiempo para los equipos de ventas. Los ejemplos de flujos de trabajo automatizados incluyen el envío de correos electrónicos de seguimiento, la programación de tareas y la actualización de las etapas de los acuerdos. Los usuarios también deben poder configurar reglas y activadores personalizados para acciones automatizadas.\\nInformes y Análisis: Las herramientas de informes y análisis son esenciales para obtener información sobre el rendimiento de las ventas, el comportamiento del cliente y las tendencias comerciales generales. Esto incluye la disponibilidad de informes predefinidos y personalizables, paneles de control y funciones de previsión de ventas. La capacidad de rastrear métricas clave e indicadores clave de rendimiento (KPI) para monitorear el progreso hacia los objetivos de ventas también es importante.\\nIntegración de Correo Electrónico: La integración del correo electrónico permite a los equipos de ventas conectar sus cuentas de correo electrónico con el CRM, lo que les permite rastrear la correspondencia por correo electrónico y enviar correos electrónicos directamente desde el sistema. Las funciones como las plantillas de correo electrónico, el seguimiento de correo electrónico (tasas de apertura y clics) y la capacidad de vincular correos electrónicos a contactos y acuerdos específicos mejoran la productividad. La integración con aplicaciones de calendario para programar reuniones y citas también es beneficiosa.\\nSi bien los diferentes sistemas CRM ofrecen una amplia gama de funciones, estas funcionalidades básicas son esenciales para cualquier empresa que busque gestionar eficazmente sus procesos de ventas y relaciones con los clientes.\\nLas PYMES deben priorizar las plataformas CRM que ofrezcan versiones sólidas y fáciles de usar de estas funciones clave.\\nSin una sólida gestión de contactos y clientes potenciales, las empresas tendrán dificultades para organizar sus datos de clientes.\\nUna visión clara del embudo de ventas es crucial para rastrear el progreso e identificar áreas de mejora.\\nLas capacidades de automatización ahorran tiempo y garantizan la coherencia, mientras que los informes y el análisis proporcionan información valiosa para la toma de decisiones.\\nLa integración perfecta del correo electrónico mejora la comunicación y la productividad.\\nLas necesidades específicas de una PYME dictarán la importancia relativa de cada una de estas funcionalidades básicas. Por ejemplo, una empresa con un gran volumen de clientes potenciales podría priorizar las funciones sólidas de gestión de clientes potenciales, mientras que una empresa centrada en las relaciones a largo plazo con los clientes podría enfatizar la gestión de contactos y el seguimiento de la comunicación.\\nLas PYMES deben identificar sus principales objetivos de ventas y elegir un CRM que sobresalga en las funcionalidades que son más críticas para lograr esos objetivos. Una evaluación exhaustiva de su proceso de ventas actual y sus puntos débiles ayudará a determinar sus necesidades específicas.\\n","section":"Cómo elegir el CRM o Software de Gestión de Ventas Adecuado para su Empresa","version":"current","path":"/blog/como-elegir-el-crm-o-software-de-gestion-de-ventas-adecuado-para-su-empresa#7-funcionalidades-centrales-funciones-esenciales-de-crm-para-una-gestión-de-ventas-eficaz","category":"blogs"},{"title":"9. Tomando la Decisión Correcta: Una Guía Paso a Paso para Seleccionar su CRM Ideal","content":"Elegir el sistema CRM adecuado requiere un enfoque sistemático que tenga en cuenta las necesidades y objetivos específicos de su empresa.\\nDefina sus Objetivos y Necesidades Comerciales: Articule claramente lo que su empresa espera lograr con un sistema CRM. ¿Su objetivo es mejorar la generación de leads, aumentar las ventas, mejorar el servicio al cliente u optimizar los procesos internos?. Evalúe su proceso de ventas actual e identifique los puntos débiles que un CRM podría abordar.\\nEvalúe sus Requisitos Funcionales: Enumere las funciones y funcionalidades específicas que necesita en un CRM en función de sus objetivos y procesos. Considere las funciones esenciales como la gestión de contactos, el seguimiento de leads, la gestión de embudos, la automatización, los informes y las necesidades de integración. Priorice las funciones imprescindibles frente a las funciones deseables para reducir las opciones.\\nEvalúe las Opciones de Precios e Implementación: Revise cuidadosamente los modelos de precios de los diferentes proveedores de CRM, considerando los costos base, las tarifas por usuario, los límites de contacto y los niveles de funciones. Evalúe el costo total de propiedad, incluida la implementación, la capacitación y el soporte continuo. Considere su enfoque de implementación preferido (auto-implementación, incluida o de terceros) y sus costos y beneficios asociados.\\nComprenda sus Necesidades de Integración: Asegúrese de que el CRM elegido se integre perfectamente con otros sistemas comerciales que ya utiliza su empresa. Identifique las integraciones críticas, como ERP, automatización de marketing, correo electrónico o software de contabilidad. Consulte el sitio web del proveedor de CRM o el mercado de aplicaciones para conocer las integraciones disponibles.\\nAproveche los Períodos de Prueba Gratuitos: Aproveche los períodos de prueba gratuitos que ofrecen los proveedores de CRM para probar la facilidad de uso y la idoneidad de la plataforma para su empresa. Involucre al equipo de ventas y a otros usuarios potenciales en el proceso de prueba para recopilar comentarios. Utilice el período de prueba para explorar las funciones y funcionalidades clave relevantes para las necesidades de su empresa.\\nSeleccionar el CRM adecuado es un proceso que requiere una comprensión profunda de las necesidades y objetivos específicos de la empresa. Apresurarse a tomar una decisión sin una comprensión clara de los requisitos puede llevar a elegir un sistema que sea insuficiente o demasiado complejo y costoso.\\nUn enfoque sistemático, que comience con la definición de objetivos y la asignación de requisitos funcionales, garantizará que el CRM elegido se alinee con las prioridades estratégicas de la empresa y proporcione las herramientas necesarias para mejorar la gestión de ventas y las relaciones con los clientes.\\nLos períodos de prueba gratuitos son oportunidades invaluables para que las empresas experimenten una plataforma CRM de primera mano y evalúen su usabilidad y su ajuste dentro de sus flujos de trabajo existentes.\\nInvolucrar activamente a los usuarios potenciales en el proceso de prueba es crucial para garantizar la aceptación y maximizar las posibilidades de una adopción exitosa del CRM.\\nLos comentarios de los usuarios durante los períodos de prueba pueden revelar información práctica sobre la facilidad de uso, la relevancia de las funciones y cualquier desafío potencial que pueda surgir durante la implementación real. Esta información es esencial para tomar una decisión informada y seleccionar un CRM que satisfaga las necesidades de todo el equipo.\\n","section":"Cómo elegir el CRM o Software de Gestión de Ventas Adecuado para su Empresa","version":"current","path":"/blog/como-elegir-el-crm-o-software-de-gestion-de-ventas-adecuado-para-su-empresa#9-tomando-la-decisión-correcta-una-guía-paso-a-paso-para-seleccionar-su-crm-ideal","category":"blogs"},{"title":"10. Empoderando su Empresa con la Solución CRM Adecuada","content":"Elegir el software CRM adecuado es una decisión fundamental que puede afectar significativamente el crecimiento y el éxito de su empresa. Al considerar cuidadosamente los factores descritos en esta guía, puede seleccionar una solución que no solo satisfaga sus necesidades actuales sino que también respalde su crecimiento futuro.\\nLos sistemas CRM ofrecen una ventaja estratégica sobre los métodos tradicionales al mejorar la eficiencia, mejorar la gestión de datos, fortalecer las relaciones con los clientes, permitir la escalabilidad y proporcionar información valiosa a través de informes y análisis sólidos.\\nUna implementación bien planificada y una integración perfecta con otros sistemas comerciales son esenciales para maximizar los beneficios de su inversión en CRM y empoderará a su empresa, mejorará la satisfacción del cliente e impulsará el éxito a largo plazo en el dinámico mercado actual.\\nTe recomendamos leer:\\nCómo elegir el CRM o Software de Gestión de Ventas Adecuado para su Empresa\\nUn Análisis Más Detallado, Software CRM Popular en el Mercado Estadounidense\\n","section":"Cómo elegir el CRM o Software de Gestión de Ventas Adecuado para su Empresa","version":"current","path":"/blog/como-elegir-el-crm-o-software-de-gestion-de-ventas-adecuado-para-su-empresa#10-empoderando-su-empresa-con-la-solución-crm-adecuada","category":"blogs"},{"title":"3. Decodificando el Costo: Entendiendo los Modelos de Precios de CRM en la Nube","content":"Los modelos de precios para el software CRM moderno basado en la nube varían, pero la mayoría siguen ciertas estructuras comunes.\\nComprender estos modelos es esencial para que las empresas puedan evaluar con precisión el costo de un CRM y elegir un plan que se ajuste a su presupuesto y necesidades.\\nPrecios Basados en Suscripción: La mayoría de los CRM modernos basados en la nube operan con un modelo de suscripción, donde las empresas pagan una tarifa mensual o anual para usar el software. Este modelo ofrece flexibilidad y escalabilidad, lo que lo hace adecuado para empresas de diversos tamaños. El costo a menudo está determinado por la cantidad de usuarios que requieren acceso al sistema.\\nCostos de Plan Base: Otros proveedores ofrecen un plan base con una tarifa mensual o anual fija que incluye un conjunto de funciones principales. Estos planes base pueden incluir un cierto número de usuarios, y los usuarios adicionales incurren en cargos adicionales.\\nTarifas por Usuario: Además del costo del plan base, estos proveedores de CRM suelen cobrar una tarifa adicional por cada usuario que necesita acceder al sistema. Este precio por usuario permite a las empresas escalar el uso de su CRM en línea con el tamaño de su equipo.\\nCargos Basados en la Cantidad de Contactos: Algunos proveedores de CRM también pueden cobrar en función de la cantidad de contactos o clientes potenciales almacenados en el sistema. Este modelo de precios puede afectar a las empresas con grandes bases de datos de clientes potenciales.\\nCargos Basados en Funciones y Niveles: Otros proveedores de CRM ofrecen diferentes niveles de precios con distintos niveles de funciones y funcionalidades. Los planes básicos ofrecen funciones esenciales, mientras que los planes de nivel superior incluyen capacidades más avanzadas, como automatización de marketing o análisis avanzado. El panorama de precios para los CRM basados en la nube es diverso y requiere una cuidadosa consideración de varios factores más allá del costo base.\\nLas empresas deben anticipar su crecimiento en términos de usuarios y contactos, así como sus requisitos de funciones en evolución, para elegir un modelo de precios que siga siendo rentable a largo plazo.\\nSi bien el modelo de suscripción ofrece flexibilidad, el costo acumulado con el tiempo puede ser significativo. Comprender los matices de las tarifas por usuario, los límites de contacto y los niveles basados en funciones es crucial para evitar gastos inesperados a medida que la empresa escala.\\nLa tendencia hacia los precios escalonados refleja un esfuerzo de los proveedores de CRM para atender a una gama más amplia de empresas con diferentes necesidades y presupuestos.\\nSin embargo, también requiere una evaluación exhaustiva de las funciones incluidas en cada nivel para garantizar que el plan elegido proporcione las funcionalidades necesarias sin pagar en exceso por capacidades no utilizadas.\\nLas empresas deben mapear sus requisitos específicos con las funciones que se ofrecen en cada nivel de precios. Una comparación detallada de las ofertas de diferentes proveedores a precios similares puede revelar diferencias significativas en funcionalidad y valor.\\n","section":"Un Análisis Más Detallado, Software CRM Popular en el Mercado Estadounidense","version":"current","path":"/blog/software-crm-popular-en-el-mercado-estadounidense#3-decodificando-el-costo-entendiendo-los-modelos-de-precios-de-crm-en-la-nube","category":"blogs"},{"title":"6. Navegando por el Panorama: Complejidad y Curva de Aprendizaje de los Sistemas CRM","content":"La complejidad y la curva de aprendizaje de los sistemas CRM pueden variar significativamente entre las diferentes plataformas, lo que afecta su idoneidad para las PYMES.\\nVarios factores contribuyen a la complejidad de un CRM, incluida la cantidad de funciones que ofrece, el diseño de la interfaz de usuario, las opciones de personalización y la disponibilidad de recursos de capacitación.\\n<!-- truncate -->\\nSalesforce: Salesforce es una plataforma CRM potente y altamente personalizable que atiende a empresas de todos los tamaños. Sin embargo, puede presentar una curva de aprendizaje más pronunciada, especialmente para las PYMES, debido a su amplia gama de funciones y opciones de personalización.\\nZoho CRM: Zoho CRM es una plataforma versátil y rentable que ofrece una amplia gama de funciones para ventas, marketing y atención al cliente. Si bien es fácil de usar, puede tener una curva de aprendizaje ligeramente más pronunciada en comparación con otras CRM, especialmente para los usuarios que no están familiarizados con los sistemas CRM. Zoho CRM es altamente personalizable, lo que puede ser una ventaja, pero también puede contribuir a su complejidad.\\nFreshworks CRM (Freshsales): Freshworks CRM es un CRM de ventas impulsado por IA diseñado para ser fácil de usar, con un enfoque en la automatización de ventas y un proceso de ventas optimizado. Ofrece una interfaz intuitiva y un proceso de configuración rápido, lo que lo hace accesible para los usuarios de CRM por primera vez. Si bien generalmente es fácil de usar, algunos usuarios pueden encontrar que ciertas funciones avanzadas tienen una curva de aprendizaje.\\nEl \\"mejor\\" CRM para una PYME no es necesariamente el que tiene más funciones, sino el que logra el equilibrio adecuado entre funcionalidad y facilidad de uso.\\nUn CRM complejo con una curva de aprendizaje pronunciada puede generar frustración y subutilización, lo que anula sus beneficios potenciales.\\nLas PYMES suelen tener tiempo y recursos limitados para una capacitación extensa. Un CRM con una interfaz intuitiva y materiales de soporte fácilmente disponibles probablemente verá tasas de adopción más altas y ofrecerá un retorno de la inversión más rápido.\\nLos diferentes niveles de complejidad y curvas de aprendizaje entre los diferentes sistemas CRM sugieren que las empresas deben evaluar cuidadosamente su experiencia técnica interna y el tiempo que están dispuestas a invertir en capacitación al tomar una decisión.\\nUn CRM más simple podría ser preferible para las empresas con personal técnico limitado o aquellas que son nuevas en CRM.\\nLas empresas deben considerar realizar pruebas de diferentes plataformas CRM para evaluar su facilidad de uso desde la perspectiva de sus usuarios reales.\\nLos comentarios del equipo de ventas y otras partes interesadas relevantes pueden ser invaluables para elegir un CRM que se alinee con su nivel de comodidad y conjunto de habilidades.\\n","section":"Un Análisis Más Detallado, Software CRM Popular en el Mercado Estadounidense","version":"current","path":"/blog/software-crm-popular-en-el-mercado-estadounidense#6-navegando-por-el-panorama-complejidad-y-curva-de-aprendizaje-de-los-sistemas-crm","category":"blogs"},{"title":"8. Un Análisis Más Detallado: Software CRM Popular en el Mercado Estadounidense","content":"A continuación, se presenta una descripción general de las plataformas CRM populares en el mercado estadounidense, con un enfoque en su descripción, facilidad de uso para las PYMES, estructura de precios e información clave de las reseñas de los usuarios.\\nSalesforce\\n\\nDescripción: Salesforce es una plataforma CRM líder basada en la nube, conocida por sus amplias capacidades de personalización y una amplia gama de funciones para empresas de todos los tamaños. Ofrece soluciones para equipos de ventas, servicio, marketing, comercio y TI.\\nFacilidad de Uso y Curva de Aprendizaje para las PYMES: Si bien es potente, Salesforce puede tener una curva de aprendizaje más pronunciada, especialmente para las pequeñas y medianas empresas, debido a su gran cantidad de funciones y opciones de personalización. Estructura de Precios: Salesforce ofrece varios planes de precios, con Starter Suite para pequeñas empresas a partir de $25 por usuario al mes (facturado anualmente). Otros planes como Professional, Enterprise y Unlimited ofrecen niveles crecientes de funciones y personalización a precios más altos. Los complementos para funcionalidades específicas pueden aumentar aún más el costo.\\nInformación Clave de las Reseñas de los Usuarios (G2, Capterra): Los usuarios aprecian su capacidad para integrarse con varias otras aplicaciones comerciales y su escalabilidad. Sin embargo, también se señala con frecuencia como más caro que muchas alternativas y con una curva de aprendizaje más pronunciada, particularmente para principiantes. La atención al cliente generalmente es bien considerada, especialmente para los planes de nivel superior.\\n\\n\\nHubSpot\\n\\nDescripción: HubSpot CRM es conocido por su interfaz fácil de usar y su facilidad de uso, lo que lo hace particularmente adecuado para integraciones de ventas y marketing. Está diseñado teniendo en cuenta la experiencia del usuario, lo que facilita su adopción y escalabilidad por parte de las PYMES sin necesidad de equipos técnicos dedicados. Facilidad de Uso y Curva de Aprendizaje para las PYMES: HubSpot CRM está diseñado pensando en la facilidad de uso para las pequeñas y medianas empresas. Su interfaz se describe como intuitiva y fácil de usar, lo que facilita su adopción y escalabilidad por parte de las PYMES sin necesidad de equipos técnicos dedicados. La plataforma ofrece herramientas de arrastrar y soltar, paneles limpios y requiere una configuración mínima, lo que la hace accesible incluso para usuarios sin conocimientos técnicos.\\nEstructura de Precios: HubSpot CRM ofrece un plan gratuito con funciones esenciales, lo que lo convierte en una excelente opción para las pequeñas empresas que están comenzando. Sus planes de pago comienzan en $15 por usuario al mes para el plan Starter. Los planes Professional y Enterprise ofrecen funciones más avanzadas a precios más altos. HubSpot es conocido por su modelo de precios transparente, pero los costos pueden aumentar a medida que las empresas escalan y requieren funciones más avanzadas o más contactos de marketing.\\nInformación Clave de las Reseñas de los Usuarios (G2, Capterra): Si bien el plan gratuito es muy generoso, algunas funciones avanzadas y límites más altos requieren planes de pago, que pueden resultar costosos para las empresas en crecimiento.\\n\\n\\nZoho CRM\\n\\nDescripción: Zoho CRM es una plataforma versátil y rentable que ofrece una amplia gama de funciones para ventas, marketing y atención al cliente. Está diseñado para ayudar a las empresas a convertir más clientes potenciales, construir relaciones duraderas con los clientes y lograr un crecimiento resistente a través de IA contextual y una interfaz de usuario intuitiva. Zoho CRM atiende a empresas de todos los tamaños e industrias, desde pequeñas empresas hasta grandes empresas.\\nFacilidad de Uso y Curva de Aprendizaje para las PYMES: Zoho CRM está diseñado para ser fácil de usar, con una interfaz limpia e intuitiva. Ofrece una configuración sencilla y proporciona guías útiles para ayudar a los usuarios a comenzar. Si bien la plataforma ofrece una gran cantidad de funciones, lo que puede requerir algo de tiempo para dominar todo, su diseño organizado y limpio simplifica la experiencia del usuario. Zoho también ofrece Bigin by Zoho CRM, que está diseñado específicamente para pequeñas empresas, lo que sugiere un enfoque en la facilidad de uso para las PYMES.\\nEstructura de Precios: Zoho CRM ofrece una variedad de planes de precios para adaptarse a diferentes necesidades y presupuestos. Su plan gratuito admite hasta 3 usuarios, lo que lo convierte en una excelente opción para pequeñas empresas o nuevas empresas. Los planes de pago comienzan en $14 por usuario al mes (facturado anualmente) para el plan Estándar y ofrecen funciones y capacidades cada vez más avanzadas a precios más altos. Zoho también ofrece contratos mensuales flexibles sin períodos de bloqueo y sin costos ocultos, lo que lo hace atractivo para las PYMES que buscan soluciones rentables y adaptables.\\nInformación Clave de las Reseñas de los Usuarios (G2, Capterra): Si bien la plataforma generalmente se considera fácil de usar, algunos usuarios han notado que dominar todas sus funciones puede llevar tiempo. La atención al cliente ha recibido críticas mixtas, y algunos usuarios informan problemas de coherencia y tiempos de respuesta lentos.\\n\\n\\nFreshworks CRM (Freshsales)\\n\\nDescripción: Freshsales, de Freshworks, es un CRM de ventas impulsado por IA diseñado para ayudar a las empresas a vender de forma más inteligente y cerrar acuerdos más rápido. Su objetivo es agilizar el proceso de ventas y mejorar la productividad. Freshsales forma parte de Freshworks Suite, que ofrece soluciones para ventas, marketing y atención al cliente. Facilidad de Uso y Curva de Aprendizaje para las PYMES: Freshsales es conocido por su interfaz fácil de usar, especialmente teniendo en cuenta su amplia funcionalidad. La configuración se describe como rápida y sencilla, lo que sugiere una curva de aprendizaje poco profunda para la mayoría de los propietarios de negocios y sus equipos. Estructura de Precios: Freshsales ofrece una variedad de planes de precios, que incluyen un plan gratuito para hasta 3 usuarios con funciones esenciales. Los planes de pago comienzan en $15 por usuario al mes para el plan Growth (facturado anualmente) y ofrecen funciones y capacidades cada vez más avanzadas a precios más altos. Freshsales también ofrece una prueba gratuita de 21 días para que las empresas prueben la plataforma.\\nInformación Clave de las Reseñas de los Usuarios (G2, Capterra): Algunos usuarios han notado que la plataforma puede tener una curva de aprendizaje ligeramente más pronunciada que otras..\\nTabla 1: Comparación de Modelos de Precios para Software CRM Popular Basado en la Nube\\nPlataforma CRM\\nPrecio Inicial (por usuario/mes, facturado anualmente)\\nFunciones Clave en el Plan Básico\\nModelo de Precios\\nPosibles Costos Adicionales\\n\\n\\n\\n\\nSalesforce\\n$25\\nGestión de leads, gestión de cuentas y oportunidades\\nPor usuario\\nUsuarios adicionales, funciones avanzadas, complementos\\n\\n\\nHubSpot\\n$15\\nGestión de contactos, seguimiento de acuerdos, email marketing\\nPor usuario, niveles\\nContactos de marketing adicionales, funciones profesionales\\n\\n\\nZoho CRM\\n$12\\nGestión de leads, gestión de contactos, gestión de acuerdos\\nPor usuario, niveles\\nUsuarios adicionales, almacenamiento, funciones avanzadas\\n\\n\\nFreshworks CRM\\n$15\\nGestión de contactos y cuentas, gestión de acuerdos\\nPor usuario, niveles\\nUsuarios adicionales, funciones profesionales y empresariales\\nTabla 2: Evaluación de la Facilidad de Uso y la Curva de Aprendizaje para Plataformas CRM Populares (para PYMES)\\nPlataforma CRM\\nInterfaz de Usuario (Valoración)\\nCurva de Aprendizaje (Valoración)\\nDisponibilidad de Recursos de Capacitación\\nIdoneidad General para PYMES (Valoración)\\nConclusiones Clave de las Reseñas de los Usuarios (Facilidad de Uso)\\n\\n\\n\\n\\nSalesforce\\nCompleja\\nPronunciada\\nTrailhead, guías, soporte\\nMenos Adecuado\\nInterfaz potente pero puede ser abrumadora para principiantes.\\n\\n\\nHubSpot\\nMuy Intuitiva\\nMínima\\nHubSpot Academy, base de conocimientos, soporte\\nMuy Adecuado\\nInterfaz limpia y fácil de navegar, intuitiva incluso para no técnicos.\\n\\n\\nZoho CRM\\nIntuitiva\\nModerada\\nGuías, tutoriales, base de conocimientos, foros\\nAdecuado\\nDiseño organizado y limpio, pero dominar todas las funciones lleva tiempo.\\n\\n\\nFreshworks CRM\\nIntuitiva\\nModerada\\nBase de conocimientos, tutoriales, soporte\\nAdecuado\\nInterfaz intuitiva, pero la profundidad de las funciones puede ser abrumadora inicialmente.\\nTabla 3: Comparación de Funciones Esenciales de CRM Entre Plataformas Populares\\nPlataforma CRM\\nGestión de Contactos y Cuentas\\nSeguimiento de Clientes Potenciales y Oportunidades\\nVisualización del Embudo de Ventas\\nAutomatización del Flujo de Trabajo\\nInformes y Análisis\\nIntegración de Correo Electrónico\\n\\n\\n\\n\\nSalesforce\\nSí (Profundo)\\nSí (Sofisticado)\\nSí (Personalizable)\\nSí (Potente)\\nSí (Avanzado)\\nSí (Completo)\\n\\n\\nHubSpot\\nSí (Completo)\\nSí (Completo)\\nSí (Visual)\\nSí (Sencillo)\\nSí (Completo)\\nSí (Completo)\\n\\n\\nZoho CRM\\nSí (Completo)\\nSí (Completo)\\nSí (Personalizable)\\nSí (Personalizable)\\nSí (Completo)\\nSí (Completo)\\n\\n\\nFreshworks CRM\\nSí (Completo)\\nSí (Completo)\\nSí (Visual)\\nSí (Completo)\\nSí (Completo)\\nSí (Completo)\\nTe recomendamos leer:\\nCómo elegir el CRM o Software de Gestión de Ventas Adecuado para su Empresa\\nUn Análisis Más Detallado, Software CRM Popular en el Mercado Estadounidense\\n","section":"Un Análisis Más Detallado, Software CRM Popular en el Mercado Estadounidense","version":"current","path":"/blog/software-crm-popular-en-el-mercado-estadounidense#8-un-análisis-más-detallado-software-crm-popular-en-el-mercado-estadounidense","category":"blogs"},{"title":"6.1. Eficacia","content":"Los sistemas CRM ofrecen inherentemente un mayor grado de eficacia en la gestión de la nutrición y el seguimiento de leads en comparación con Excel.\\n<!-- truncate -->\\nEl repositorio de datos centralizado dentro de un CRM permite una comprensión integral de cada lead, facilitando una comunicación altamente personalizada que aborda sus necesidades específicas y su etapa en el recorrido del comprador.\\nFunciones como la puntuación de leads mejoran aún más la eficacia al permitir que los equipos de ventas prioricen sus esfuerzos en los prospectos más prometedores.\\nAdemás, las capacidades de automatización del CRM garantizan un seguimiento constante y oportuno, nutriendo a los leads a través de secuencias y recordatorios predefinidos, lo que aumenta significativamente la probabilidad de conversión.\\nEn contraste, las limitaciones de Excel en personalización, automatización y seguimiento oportuno a menudo resultan en un enfoque menos específico y más manual para la gestión de leads, lo que podría llevar a la pérdida de oportunidades y a una nutrición menos eficaz.\\nLas funcionalidades diseñadas de los sistemas CRM abordan directamente los requisitos básicos para una nutrición y un seguimiento de leads exitosos, lo que lleva a tasas de participación y conversión más altas en comparación con los métodos manuales y menos específicos que se emplean típicamente con Excel.\\n","section":"Comparación de la Eficacia y la Eficiencia de CRM Versus Excel en la Gestión de Procesos de Nutrición y Seguimiento de Leads","version":"current","path":"/blog/comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel#61-eficacia","category":"blogs"},{"title":"6.2. Eficiencia","content":"En términos de eficiencia, los sistemas CRM proporcionan una clara ventaja sobre Excel en la gestión de los procesos de nutrición y seguimiento de leads.\\nLa automatización de tareas repetitivas pero cruciales, como la entrada de datos, el envío de correos electrónicos de seguimiento y la programación de recordatorios, reduce significativamente la carga administrativa de los equipos de ventas y marketing, liberando su tiempo para que se centren en actividades más estratégicas.\\nEl acceso centralizado a los datos de los leads dentro de un CRM también agiliza los flujos de trabajo al reducir el tiempo dedicado a buscar información y proporcionar una visión general rápida y completa de todas las interacciones con los leads.\\nPor el contrario, la gestión de la nutrición y el seguimiento de leads en Excel a menudo se caracteriza por la entrada manual de datos que consume mucho tiempo, la falta de recordatorios automatizados para las acciones críticas de seguimiento y las dificultades en la colaboración del equipo, todo lo cual contribuye a ineficiencias significativas.\\nLas capacidades de automatización y la gestión centralizada de datos de los sistemas CRM permiten a los equipos manejar mayores volúmenes de leads con menos esfuerzo manual y un menor riesgo de errores, lo que resulta en un enfoque mucho más eficiente para la gestión de leads.\\n","section":"Comparación de la Eficacia y la Eficiencia de CRM Versus Excel en la Gestión de Procesos de Nutrición y Seguimiento de Leads","version":"current","path":"/blog/comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel#62-eficiencia","category":"blogs"},{"title":"6.3. Tabla: Comparación de Eficacia y Eficiencia","content":"Característica\\nSistema CRM\\nExcel\\n\\n\\n\\n\\nEficacia\\nAlta: Nutrición y seguimiento personalizados, oportunos y dirigidos.\\nBaja a Media: Capacidades limitadas de personalización y segmentación.\\n\\n\\nAutomatización\\nAlta: Automatiza seguimientos, recordatorios, entrada de datos, puntuación de leads.\\nBaja: Procesos principalmente manuales.\\n\\n\\nGestión de Datos\\nCentralizada, única fuente de verdad, fácil acceso y actualizaciones.\\nDescentralizada, potencial de inconsistencias, difícil de gestionar grandes datos.\\n\\n\\nColaboración\\nFluida, colaboración en tiempo real entre equipos.\\nLimitada, propensa a problemas de control de versiones.\\n\\n\\nInformes y Análisis\\nInformes y paneles de control avanzados y personalizables para obtener información sobre el rendimiento.\\nAnálisis básico basado en gráficos y fórmulas, requiere mucho tiempo.\\n\\n\\nEscalabilidad\\nAlta: Diseñado para crecer con la empresa.\\nBaja: Se vuelve engorroso e ineficiente con el crecimiento.\\n\\n\\nEficiencia\\nAlta: Ahorra tiempo, reduce errores manuales, agiliza los flujos de trabajo.\\nBaja: Tareas manuales que consumen tiempo, propensas a errores.\\n7. Funciones y Funcionalidades Específicas Dentro de las Plataformas CRM Beneficiosas para la Nutrición y el Seguimiento de Leads en Comparación con Excel\\n","section":"Comparación de la Eficacia y la Eficiencia de CRM Versus Excel en la Gestión de Procesos de Nutrición y Seguimiento de Leads","version":"current","path":"/blog/comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel#63-tabla-comparación-de-eficacia-y-eficiencia","category":"blogs"},{"title":"7.1. Puntuación y Calificación de Leads","content":"Los sistemas CRM a menudo incorporan sofisticadas funcionalidades de puntuación de leads que asignan automáticamente puntos a los leads en función de su información demográfica, su interacción con los materiales de marketing y su comportamiento en el sitio web de una empresa u otras plataformas digitales.\\nEste proceso de puntuación automatizado ayuda a los equipos de ventas a identificar rápidamente qué leads son los más prometedores y están listos para la venta, lo que les permite priorizar sus esfuerzos de contacto en consecuencia.\\nEn contraste, la calificación de leads en Excel suele ser un proceso manual y subjetivo, que depende de que los representantes de ventas individuales evalúen el potencial de un lead en función de información limitada y su propio juicio.\\nLa naturaleza objetiva y la automatización de la puntuación de leads dentro de un CRM proporcionan una forma más consistente y eficiente de identificar leads de alto potencial.\\n","section":"Comparación de la Eficacia y la Eficiencia de CRM Versus Excel en la Gestión de Procesos de Nutrición y Seguimiento de Leads","version":"current","path":"/blog/comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel#71-puntuación-y-calificación-de-leads","category":"blogs"},{"title":"7.2. Flujos de Trabajo y Secuencias Automatizadas","content":"Las plataformas CRM permiten a los usuarios diseñar e implementar flujos de trabajo y secuencias de seguimiento automatizadas que se activan por acciones o hitos específicos de los leads.\\nPor ejemplo, un lead que descarga un recurso (ppt, guía, etc) específico podría recibir automáticamente una serie de correos electrónicos dirigidos durante los siguientes días o semanas.\\nEstas secuencias automatizadas garantizan que los leads reciban una comunicación oportuna y relevante sin requerir la intervención manual del equipo de ventas o marketing.\\nExcel carece de la capacidad de crear tales procesos de seguimiento automatizados y basados en el comportamiento, lo que requiere la programación y ejecución manual de cada comunicación, lo que puede llevar mucho tiempo y ser propenso a omisiones.\\n","section":"Comparación de la Eficacia y la Eficiencia de CRM Versus Excel en la Gestión de Procesos de Nutrición y Seguimiento de Leads","version":"current","path":"/blog/comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel#72-flujos-de-trabajo-y-secuencias-automatizadas","category":"blogs"},{"title":"7.3. Integración y Seguimiento del Correo Electrónico","content":"Muchos sistemas CRM ofrecen una integración perfecta con las plataformas de correo electrónico populares, lo que permite a los usuarios enviar y rastrear correos electrónicos directamente desde la interfaz del CRM.\\nEsta integración a menudo incluye funciones como plantillas de correo electrónico prediseñadas que se pueden personalizar con información específica del lead, la capacidad de programar el envío de correos electrónicos en los momentos óptimos y el seguimiento de las aperturas y los clics de los correos electrónicos para evaluar la participación del lead.\\nEste nivel de gestión e información del correo electrónico no está disponible cuando se utiliza Excel, donde la comunicación por correo electrónico se maneja típicamente por separado, lo que dificulta el seguimiento de qué correos electrónicos se han enviado, su contenido y la interacción del destinatario con ellos.\\n","section":"Comparación de la Eficacia y la Eficiencia de CRM Versus Excel en la Gestión de Procesos de Nutrición y Seguimiento de Leads","version":"current","path":"/blog/comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel#73-integración-y-seguimiento-del-correo-electrónico","category":"blogs"},{"title":"7.4. Gestión de Campañas","content":"Las plataformas CRM a menudo proporcionan herramientas robustas de gestión de campañas que permiten a las empresas crear, ejecutar y rastrear campañas de nutrición de leads a través de múltiples canales, incluyendo correo electrónico, redes sociales y marketing de contenidos.\\nEstas funciones permiten a las empresas segmentar sus leads en grupos específicos para mensajes dirigidos, automatizar la entrega de contenido relevante y supervisar el rendimiento de sus campañas en términos de participación y tasas de conversión.La gestión de campañas multicanal y el seguimiento preciso de su eficacia son significativamente más desafiantes y menos eficientes cuando se depende únicamente de Excel, que carece de las herramientas integradas para la creación, automatización y análisis del rendimiento de las campañas.\\n","section":"Comparación de la Eficacia y la Eficiencia de CRM Versus Excel en la Gestión de Procesos de Nutrición y Seguimiento de Leads","version":"current","path":"/blog/comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel#74-gestión-de-campañas","category":"blogs"},{"title":"7.5. Paneles de Control e Informes y Análisis","content":"Los sistemas CRM suelen incluir paneles de control de informes intuitivos y herramientas de análisis personalizables que proporcionan una visión clara y visual de las métricas clave de nutrición y seguimiento de leads.\\nLos usuarios pueden rastrear fácilmente los KPI críticos, como las tasas de conversión de leads en diferentes etapas del embudo, los niveles generales de participación con los esfuerzos de nutrición, la duración promedio del ciclo de ventas y el rendimiento de los representantes de ventas individuales.\\nEstos paneles de control e informes proporcionan información práctica que permite a las empresas comprender qué está funcionando bien e identificar áreas de mejora en sus estrategias de gestión de leads.\\nLa generación de informes similares, completos y dinámicos en Excel requiere una manipulación manual significativa de los datos y habilidades avanzadas en hojas de cálculo.\\n","section":"Comparación de la Eficacia y la Eficiencia de CRM Versus Excel en la Gestión de Procesos de Nutrición y Seguimiento de Leads","version":"current","path":"/blog/comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel#75-paneles-de-control-e-informes-y-análisis","category":"blogs"},{"title":"7.6. Gestión de Contactos y Actividades","content":"Los sistemas CRM están diseñados para proporcionar una visión de 360 grados de cada lead, centralizando toda la información de contacto relevante, un historial cronológico de cada interacción (incluyendo correos electrónicos, llamadas, reuniones y visitas al sitio web) y detalles de cualquier actividad de seguimiento programada.\\nLos representantes de ventas pueden registrar fácilmente todas sus interacciones con un lead, asegurando que se mantenga un registro completo y accesible para todo el equipo.\\nEsta gestión integral de contactos y actividades ayuda a construir contexto para futuras interacciones y garantiza un enfoque más personalizado e informado para la nutrición y el seguimiento de leads.\\nEn contraste, la gestión de la información de contacto y el seguimiento de las actividades en Excel a menudo resulta en registros fragmentados e incompletos, lo que dificulta el mantenimiento de una comprensión holística del recorrido y la participación de cada lead.\\nTe recomendamos leer:\\nCRM vs Excel, Un Análisis Comparativo para la Nutrición y el Seguimiento de Leads en Ventas\\nLas Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads\\nComparación de la Eficacia y la Eficiencia de CRM Versus Excel\\nLas Desventajas de Usar Excel para la Nutrición y el Seguimiento de Leads\\nIndicadores Clave de Rendimiento (KPI) para Medir el Éxito\\n","section":"Comparación de la Eficacia y la Eficiencia de CRM Versus Excel en la Gestión de Procesos de Nutrición y Seguimiento de Leads","version":"current","path":"/blog/comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel#76-gestión-de-contactos-y-actividades","category":"blogs"},{"title":"2. Introducción","content":"La capacidad de nutrir eficazmente a los leads y realizar un seguimiento constante de los clientes potenciales es primordial para convertir a los prospectos en clientes leales y lograr un crecimiento de ingresos sostenible para cualquier negocio.\\nDos herramientas comunes utilizadas por las organizaciones para gestionar estos procesos críticos son los sistemas de Gestión de Relaciones con los Clientes (CRM) y Microsoft Excel.\\nLos sistemas CRM son soluciones de software diseñadas específicamente para gestionar y analizar las interacciones y los datos de los clientes a lo largo de su ciclo de vida, con el objetivo de mejorar las relaciones comerciales.\\nExcel, por otro lado, es un programa de hojas de cálculo ampliamente utilizado, destinado principalmente a la organización y el análisis de datos.\\nBuscaremos proporcionar una comparación detallada de los sistemas CRM y Excel en el contexto de la nutrición y el seguimiento de leads dentro de las ventas. Examinar las ventajas y desventajas de cada herramienta, destacar funcionalidades específicas, identificar indicadores clave de rendimiento relevantes y analizar escenarios de uso adecuados, proporcionando así la información necesaria para tomar decisiones informadas sobre qué herramienta se alinea mejor con sus necesidades y objetivos específicos para optimizar sus estrategias de gestión de leads.\\n","section":"CRM vs Excel, Un Análisis Comparativo para la Nutrición y el Seguimiento de Leads en Ventas","version":"current","path":"/blog/crm-vs-excel-un-analisis-comparativo#2-introducción","category":"blogs"},{"title":"3.1. Definición de la Nutrición de Leads en Ventas","content":"La nutrición de leads, dentro del ámbito de las ventas, se entiende como el proceso estratégico de cultivar relaciones con clientes potenciales que han expresado algún nivel de interés en los productos o servicios de una empresa, pero que aún no están listos para realizar una compra.\\nEsto implica una comprensión profunda de las necesidades y los desafíos del cliente potencial, junto con la provisión constante de información y recursos valiosos adaptados a su etapa específica en el proceso de compra.\\nEl objetivo fundamental de la nutrición de leads es construir confianza y credibilidad, mejorar el conocimiento de la marca y mantener una conexión significativa con los prospectos hasta que estén suficientemente informados y motivados para convertirse en clientes de pago.\\nEsto no es un evento singular, sino más bien un viaje cuidadosamente orquestado y de múltiples etapas que abarca tanto el embudo de marketing como el de ventas.\\nLa nutrición eficaz de leads enfatiza el desarrollo de una relación a largo plazo al abordar de manera proactiva los puntos débiles del cliente potencial y ofrecer soluciones, en lugar de centrarse únicamente en ganancias transaccionales inmediatas.\\nEste compromiso sostenido y personalizado es crucial para fomentar la lealtad del cliente y, en última instancia, impulsar el crecimiento de los ingresos.\\n","section":"CRM vs Excel, Un Análisis Comparativo para la Nutrición y el Seguimiento de Leads en Ventas","version":"current","path":"/blog/crm-vs-excel-un-analisis-comparativo#31-definición-de-la-nutrición-de-leads-en-ventas","category":"blogs"},{"title":"3.2. Definición del Seguimiento de Leads en Ventas","content":"El seguimiento de leads en ventas se refiere al proceso sistemático de contactar a individuos o entidades que han mostrado un interés inicial en las ofertas de una empresa o que han participado en alguna forma de interacción, como enviar una consulta o descargar una guía o algún recurso.\\nEl objetivo principal del seguimiento de leads es mantener el compromiso del prospecto con el proceso de ventas y continuar nutriendo la relación hasta que esté preparado para tomar una decisión de compra.\\nUn seguimiento de leads exitoso se caracteriza por varios elementos clave, incluyendo una respuesta oportuna a las consultas iniciales, un enfoque personalizado que reconoce las necesidades específicas del prospecto y la provisión de valor continuo en cada interacción.\\nRequiere un delicado equilibrio entre el contacto constante y el respeto por el tiempo y las preferencias de comunicación del prospecto, asegurando la persistencia sin volverse intrusivo.\\nUn seguimiento de leads eficaz es una secuencia estratégica de acciones diseñadas para guiar a los clientes potenciales a través del proceso de toma de decisiones, proporcionando información relevante, abordando sus inquietudes y generando confianza en la capacidad de la empresa para satisfacer sus necesidades.\\n","section":"CRM vs Excel, Un Análisis Comparativo para la Nutrición y el Seguimiento de Leads en Ventas","version":"current","path":"/blog/crm-vs-excel-un-analisis-comparativo#32-definición-del-seguimiento-de-leads-en-ventas","category":"blogs"},{"title":"3.3. Relación Entre la Nutrición y el Seguimiento de Leads","content":"El seguimiento de leads funciona como un componente táctico crítico dentro del marco estratégico general de la nutrición de leads. Mientras que la nutrición de leads abarca el esfuerzo más amplio de construir y mantener relaciones con clientes potenciales a lo largo de todo su recorrido, el seguimiento de leads se centra en las interacciones y comunicaciones específicas e individuales diseñadas para hacer avanzar al lead a través del ciclo de ventas.El seguimiento de leads luego ejecuta las acciones necesarias en cada una de estas etapas, asegurando que la comunicación sea oportuna, relevante y contribuya a los objetivos generales de nutrición.\\nEstos dos conceptos están intrínsecamente ligados y se refuerzan mutuamente; una nutrición eficaz proporciona el contexto y la estrategia para las actividades de seguimiento, mientras que un seguimiento constante y valioso es esencial para una nutrición de leads exitosa y, en última instancia, para la conversión de ventas.\\nTe recomendamos leer:\\nCRM vs Excel, Un Análisis Comparativo para la Nutrición y el Seguimiento de Leads en Ventas\\nLas Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads\\nComparación de la Eficacia y la Eficiencia de CRM Versus Excel\\nLas Desventajas de Usar Excel para la Nutrición y el Seguimiento de Leads\\nIndicadores Clave de Rendimiento (KPI) para Medir el Éxito\\n","section":"CRM vs Excel, Un Análisis Comparativo para la Nutrición y el Seguimiento de Leads en Ventas","version":"current","path":"/blog/crm-vs-excel-un-analisis-comparativo#33-relación-entre-la-nutrición-y-el-seguimiento-de-leads","category":"blogs"},{"title":"8.1. KPIs Medibles con CRM","content":"Los sistemas CRM ofrecen la capacidad de rastrear y medir con precisión varios indicadores clave de rendimiento (KPI) que son cruciales para evaluar el éxito de los esfuerzos de nutrición y seguimiento de leads.\\n<!-- truncate -->\\nLa Tasa de Conversión, que representa el porcentaje de leads que finalmente se convierten en clientes de pago, es un KPI fundamental que se puede rastrear fácilmente dentro de un CRM a medida que los leads avanzan por el embudo de ventas.\\nUna Puntuación de Compromiso del Lead, a menudo calculada automáticamente por el CRM en función de las interacciones de un lead con las actividades de marketing y ventas, proporciona una indicación numérica de su nivel de interés.\\nPara las campañas de nutrición basadas en correo electrónico, la Tasa de Clics (CTR) y la Tasa de Apertura revelan la eficacia del contenido del correo electrónico para captar la atención e interés de los leads.\\nLa Duración del Ciclo de Ventas, que es el tiempo que tarda un lead en pasar del punto de contacto inicial a un acuerdo cerrado, también se puede medir con precisión dentro de un CRM mediante el seguimiento de las diversas etapas del proceso de ventas.\\nAdemás, los datos del CRM permiten calcular el Costo por Adquisición (CPA), que representa el costo de adquirir un nuevo cliente a través de iniciativas de nutrición y seguimiento de leads, y el Retorno de la Inversión (ROI) de las Campañas de Nutrición de Leads, que compara los ingresos generados por los leads nutridos con los gastos incurridos en la ejecución de esas campañas.\\nLos sistemas CRM pueden rastrear la Eficacia de la Fuente del Lead, identificando qué canales o fuentes están generando los leads de mayor calidad y más convertibles.\\n","section":"Indicadores Clave de Rendimiento (KPI) para Medir el Éxito de la Nutrición y el Seguimiento de Leads","version":"current","path":"/blog/indicadores-clave-de-rendimiento-kpi-para-medir-el-exito#81-kpis-medibles-con-crm","category":"blogs"},{"title":"8.2. KPIs Difíciles o Imposibles de Medir con Precisión con Excel","content":"Si bien el seguimiento básico del estado del lead y la conversión final se pueden registrar manualmente en Excel, la obtención de mediciones precisas y escalables para varios indicadores clave de rendimiento es significativamente desafiante o incluso imposible. Por ejemplo, una Puntuación de Compromiso del Lead que refleje una visión holística de las interacciones de un lead a través de varios puntos de contacto requiere capacidades de seguimiento automatizadas de las que carece Excel.\\nDe manera similar, métricas como la Tasa de Clics y la Tasa de Apertura para los correos electrónicos enviados como parte de las campañas de nutrición no son medibles dentro de Excel, ya que no tiene funciones integradas de integración o seguimiento de correo electrónico.\\nEl seguimiento preciso de la Duración del Ciclo de Ventas para un gran número de leads en Excel, con marcas de tiempo detalladas para cada etapa, es propenso a errores e ineficiencias debido a la naturaleza manual de la entrada y las actualizaciones de datos.\\nEl cálculo del Costo por Adquisición (CPA) y el Retorno de la Inversión (ROI) de las Campañas de Nutrición de Leads en Excel también es problemático, ya que requiere vincular los gastos de marketing a conversiones de leads específicas, un proceso que necesita capacidades de integración no disponibles en el software de hojas de cálculo estándar.\\nSi bien la fuente del lead se puede anotar manualmente en una hoja de Excel, realizar un análisis detallado de la Eficacia de la Fuente del Lead en un conjunto de datos sustancial y correlacionarlo con las métricas de conversión es una tarea engorrosa y propensa a errores sin las funciones automatizadas de seguimiento e informes de un CRM.\\n","section":"Indicadores Clave de Rendimiento (KPI) para Medir el Éxito de la Nutrición y el Seguimiento de Leads","version":"current","path":"/blog/indicadores-clave-de-rendimiento-kpi-para-medir-el-exito#82-kpis-difíciles-o-imposibles-de-medir-con-precisión-con-excel","category":"blogs"},{"title":"8.3. Tabla: Capacidades de Medición de KPIs","content":"KPI\\nMedible con CRM\\nMedible con Excel (con precisión/escalabilidad)\\n\\n\\n\\n\\nTasa de Conversión\\nSí\\nSí (con un esfuerzo manual significativo)\\n\\n\\nPuntuación de Compromiso del Lead\\nSí\\nNo\\n\\n\\nCTR y Tasa de Apertura de Correo Electrónico\\nSí\\nNo\\n\\n\\nDuración del Ciclo de Ventas\\nSí\\nDifícil\\n\\n\\nCosto por Adquisición (CPA)\\nSí\\nNo\\n\\n\\nROI de Campañas\\nSí\\nNo\\n\\n\\nEficacia de la Fuente del Lead\\nSí\\nDifícil\\n","section":"Indicadores Clave de Rendimiento (KPI) para Medir el Éxito de la Nutrición y el Seguimiento de Leads","version":"current","path":"/blog/indicadores-clave-de-rendimiento-kpi-para-medir-el-exito#83-tabla-capacidades-de-medición-de-kpis","category":"blogs"},{"title":"9. Mejores Prácticas para la Nutrición y el Seguimiento de Leads Utilizando un Sistema CRM","content":"Para maximizar la eficacia de los esfuerzos de nutrición y seguimiento de leads utilizando un sistema CRM, se deben implementar varias mejores prácticas.\\nEn primer lugar, es crucial Definir su Perfil de Cliente Ideal (ICP) para obtener una comprensión clara de las características de su público objetivo, lo que le permitirá adaptar sus estrategias de nutrición y seguimiento de manera eficaz.\\nEn segundo lugar, Segmentar los Leads en función de diversos criterios, como la demografía, el comportamiento, los intereses y su posición en el recorrido del comprador, para asegurarse de que está entregando contenido y mensajes personalizados que resuenan con cada grupo.\\nComprender y Mapear el Recorrido del Comprador también es esencial; esto implica identificar las diferentes etapas por las que pasa un lead antes de realizar una compra y crear contenido y puntos de contacto relevantes para cada etapa.\\nCrear Contenido Dirigido y Valioso que aborde las necesidades y los puntos débiles específicos de sus leads en cada etapa de su recorrido es primordial para generar confianza y guiarlos hacia la conversión.\\nPersonalizar su Comunicación aprovechando los datos disponibles en su CRM para adaptar los correos electrónicos, los mensajes y las ofertas a los leads individuales hará que se sientan más valorados y comprendidos, lo que aumentará el compromiso con la marca.\\nLa implementación de Flujos de Trabajo Automatizados para tareas repetitivas como el envío de correos electrónicos de seguimiento y la programación de recordatorios garantiza un compromiso oportuno y coherente sin esfuerzo manual.\\nLa utilización de un sistema de Puntuación de Leads ayuda a identificar y priorizar los leads más prometedores para el contacto de ventas, maximizando la eficiencia y el potencial de conversión.\\nTambién es fundamental Realizar un Seguimiento Oportuno después de la consulta o interacción inicial de un lead para demostrar capacidad de respuesta y valorar su interés.\\nInteractuar con los leads a través de Múltiples Canales como correo electrónico, redes sociales y llamadas telefónicas, en función de sus preferencias y comportamiento, también puede mejorar el compromiso.\\nRastrear y Analizar Continuamente sus Resultados mediante la supervisión de los KPI clave de nutrición y seguimiento de leads dentro de su CRM le ayudará a identificar qué estrategias son eficaces y dónde se necesitan mejoras.\\nGarantizar la Alineación Entre los Esfuerzos de Ventas y Marketing en las definiciones, los procesos y los objetivos de los leads es crucial para una estrategia de gestión de leads fluida y eficaz. Y en función de los datos de rendimiento que recopile, es importante Optimizar Continuamente sus Estrategias para mejorar tanto la eficacia como la eficiencia de sus procesos de nutrición y seguimiento de leads.\\n","section":"Indicadores Clave de Rendimiento (KPI) para Medir el Éxito de la Nutrición y el Seguimiento de Leads","version":"current","path":"/blog/indicadores-clave-de-rendimiento-kpi-para-medir-el-exito#9-mejores-prácticas-para-la-nutrición-y-el-seguimiento-de-leads-utilizando-un-sistema-crm","category":"blogs"},{"title":"10. Análisis de Escenarios Donde el Uso de un CRM es Más Adecuado que Excel para la Nutrición y el Seguimiento de Leads","content":"En varios escenarios, las capacidades de un sistema CRM lo convierten en una opción significativamente más adecuada que Excel para gestionar los procesos de nutrición y seguimiento de leads. Cuando las empresas experimentan Equipos de Ventas en Crecimiento y Aumento de los Volúmenes de Leads, la gestión centralizada de datos, las funciones de automatización y las herramientas de colaboración que ofrece un CRM se vuelven esenciales para mantener la organización y garantizar que no se pasen por alto leads.\\nExcel a menudo se vuelve engorroso y difícil de gestionar en tales condiciones. Para las empresas con Ciclos de Ventas Complejos con Múltiples Puntos de Contacto, la automatización del flujo de trabajo, la integración del correo electrónico y el seguimiento detallado de las interacciones de un CRM son cruciales para mantener a los leads comprometidos y guiarlos a través de las diversas etapas del proceso de compra. Excel carece de la sofisticación para manejar eficientemente este nivel de complejidad.\\nCuando existe una Necesidad de Informes y Análisis Detallados para obtener información sobre el rendimiento de la nutrición y el seguimiento de leads, optimizar las estrategias y medir el ROI, las capacidades avanzadas de informes y análisis de un CRM proporcionan una clara ventaja sobre las funcionalidades básicas de Excel.\\nSi una empresa tiene un Requisito de Integración Perfecta con Otros Sistemas Empresariales, como plataformas de automatización de marketing, servicios de marketing por correo electrónico y sistemas de atención al cliente, las capacidades de integración de un CRM ofrecen un flujo de trabajo optimizado y eficiente que Excel no puede replicar.\\nEn industrias donde existe un Énfasis en la Seguridad y el Cumplimiento de los Datos, los sistemas CRM ofrecen funciones de seguridad robustas y pistas de auditoría que faltan en Excel, lo que convierte al CRM en la opción más segura y compatible para proteger la información confidencial de los clientes.\\nPara los equipos de ventas que requieren Accesibilidad Móvil a la información de los leads mientras están en movimiento, los sistemas CRM con aplicaciones móviles dedicadas proporcionan una ventaja significativa sobre Excel, que típicamente requiere acceso de escritorio.\\n","section":"Indicadores Clave de Rendimiento (KPI) para Medir el Éxito de la Nutrición y el Seguimiento de Leads","version":"current","path":"/blog/indicadores-clave-de-rendimiento-kpi-para-medir-el-exito#10-análisis-de-escenarios-donde-el-uso-de-un-crm-es-más-adecuado-que-excel-para-la-nutrición-y-el-seguimiento-de-leads","category":"blogs"},{"title":"11. Conclusión","content":"Si bien Microsoft Excel puede servir como una herramienta inicial y básica para gestionar los datos de los clientes y algunos aspectos de la nutrición y el seguimiento de leads, particularmente para empresas muy pequeñas con procesos sencillos, presenta limitaciones significativas que dificultan la eficacia y la eficiencia a medida que las empresas crecen y sus necesidades se vuelven más complejas.\\nLos sistemas CRM, por otro lado, están diseñados específicamente para abordar los requisitos multifacéticos de la gestión moderna de leads. Las fortalezas de las plataformas CRM en áreas como la automatización de tareas, la gestión centralizada de datos, las capacidades de personalización mejoradas, los informes y análisis robustos, la integración perfecta con otras herramientas empresariales y la escalabilidad los convierten en una solución mucho más eficaz y eficiente para nutrir leads y realizar un seguimiento de los clientes potenciales.\\nLas limitaciones inherentes de Excel, incluyendo su susceptibilidad a errores humanos, la falta de datos en tiempo real, la colaboración ineficiente y las características de seguridad inadecuadas, lo hacen menos adecuado para las empresas que buscan optimizar sus procesos de ventas y construir relaciones sólidas y duraderas con los clientes.\\nPor lo tanto, si bien Excel podría ofrecer un punto de entrada de bajo costo, las empresas que se toman en serio la maximización de sus tasas de conversión de leads, la mejora del compromiso del cliente y el logro de un crecimiento sostenible encontrarán que invertir en un sistema CRM es la decisión más estratégica y, en última instancia, más gratificante para gestionar sus esfuerzos de nutrición y seguimiento de leads.\\nElegir las herramientas adecuadas para optimizar los procesos de ventas es crucial para alcanzar los objetivos empresariales en el panorama competitivo actual.\\nTe recomendamos leer:\\nCRM vs Excel, Un Análisis Comparativo para la Nutrición y el Seguimiento de Leads en Ventas\\nLas Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads\\nComparación de la Eficacia y la Eficiencia de CRM Versus Excel\\nLas Desventajas de Usar Excel para la Nutrición y el Seguimiento de Leads\\nIndicadores Clave de Rendimiento (KPI) para Medir el Éxito\\n","section":"Indicadores Clave de Rendimiento (KPI) para Medir el Éxito de la Nutrición y el Seguimiento de Leads","version":"current","path":"/blog/indicadores-clave-de-rendimiento-kpi-para-medir-el-exito#11-conclusión","category":"blogs"},{"title":"5.1. Propenso a Errores Humanos","content":"Uno de los inconvenientes fundamentales de depender de Microsoft Excel para la nutrición y el seguimiento de leads es su inherente susceptibilidad a errores humanos.La naturaleza manual de la entrada de datos en las hojas de cálculo significa que los errores como las erratas, las fórmulas incorrectas o las eliminaciones accidentales se cometen fácilmente, lo que puede llevar a imprecisiones en el seguimiento y el análisis de las ventas.\\n<!-- truncate -->\\nA diferencia de los sistemas CRM que a menudo incorporan funciones automatizadas de validación de datos y detección de errores, Excel carece de estas salvaguardias.\\nEstas imprecisiones pueden tener consecuencias significativas, lo que lleva a decisiones comerciales erróneas, oportunidades de seguimiento perdidas y, en última instancia, un proceso de nutrición de leads menos eficaz.\\nLa dependencia de los procesos manuales aumenta el riesgo de inconsistencias y errores, lo que dificulta el mantenimiento de una visión fiable y precisa de los datos de los leads.\\n","section":"Las Desventajas de Usar Excel para la Nutrición y el Seguimiento de Leads","version":"current","path":"/blog/las-desventajas-de-usar-excel-para-la-nutricion-y-el-seguimiento-de-leads#51-propenso-a-errores-humanos","category":"blogs"},{"title":"5.2. Falta de Datos en Tiempo Real","content":"Las hojas de cálculo de Excel normalmente no ofrecen actualizaciones de datos en tiempo real, lo que puede ser una limitación significativa en el entorno dinámico de las ventas.\\nLa información contenida en una hoja de Excel es estática y solo refleja los datos en el momento del último guardado. En ciclos de ventas rápidos donde el estado y la participación de los leads pueden cambiar rápidamente, esta falta de visibilidad en tiempo real puede llevar a que se utilice información desactualizada para las decisiones críticas de seguimiento.\\nLos equipos de ventas podrían no estar al tanto de la actividad reciente de los leads o de los cambios en sus necesidades, lo que resultaría en comunicaciones inoportunas o irrelevantes.\\nEste retraso en los datos puede dificultar la capacidad de proporcionar una nutrición oportuna y eficaz, lo que podría llevar a la pérdida de oportunidades a medida que los competidores con información más actualizada obtienen una ventaja.\\n","section":"Las Desventajas de Usar Excel para la Nutrición y el Seguimiento de Leads","version":"current","path":"/blog/las-desventajas-de-usar-excel-para-la-nutricion-y-el-seguimiento-de-leads#52-falta-de-datos-en-tiempo-real","category":"blogs"},{"title":"5.3. Colaboración Ineficiente","content":"Excel NO está diseñado para ser una herramienta de colaboración de la misma manera que los sistemas CRM modernos.\\nCuando varios miembros del equipo necesitan acceder y actualizar la misma información de leads simultáneamente, Excel puede volverse ineficiente y propenso a conflictos.\\nPueden surgir problemas como problemas de control de versiones, sobrescrituras accidentales de datos y dificultades para rastrear quién realizó qué cambios, lo que lleva a confusión y posible pérdida de datos.\\nEsta falta de colaboración fluida en tiempo real puede obstaculizar la productividad de los equipos de ventas y marketing, lo que dificulta el mantenimiento de un enfoque unificado y coherente para los esfuerzos de nutrición y seguimiento de leads.\\n","section":"Las Desventajas de Usar Excel para la Nutrición y el Seguimiento de Leads","version":"current","path":"/blog/las-desventajas-de-usar-excel-para-la-nutricion-y-el-seguimiento-de-leads#53-colaboración-ineficiente","category":"blogs"},{"title":"5.4. Funciones Limitadas de Gestión de Leads","content":"Excel carece de las funciones y funcionalidades especializadas que son esenciales para una gestión eficaz de leads, especialmente a gran escala.\\nA diferencia de los sistemas CRM que están diseñados específicamente para gestionar todo el ciclo de vida de los leads, el marco básico de Excel no admite inherentemente procesos cruciales como los seguimientos automatizados basados en el comportamiento de los leads, la puntuación sistemática de leads para priorizar los prospectos o la integración perfecta con las plataformas de automatización de marketing.\\nEstas limitaciones pueden resultar en la pérdida de oportunidades a medida que los equipos de ventas luchan por nutrir los leads de manera eficiente e identificar a aquellos que están más listos para convertirse.\\nLa ausencia de herramientas dedicadas a la gestión de leads dificulta la implementación de estrategias de nutrición sofisticadas y el seguimiento de su eficacia.\\n","section":"Las Desventajas de Usar Excel para la Nutrición y el Seguimiento de Leads","version":"current","path":"/blog/las-desventajas-de-usar-excel-para-la-nutricion-y-el-seguimiento-de-leads#54-funciones-limitadas-de-gestión-de-leads","category":"blogs"},{"title":"5.5. Informes y Análisis Inadecuados","content":"Si bien Excel ofrece algunas capacidades básicas para el análisis de datos y la creación de gráficos, sus funcionalidades de informes y análisis son considerablemente menos robustas y fáciles de usar en comparación con las que se encuentran en los sistemas CRM dedicados.\\nGenerar informes significativos y reveladores sobre el rendimiento de la nutrición y el seguimiento de leads en Excel a menudo requiere un esfuerzo manual significativo, incluyendo la creación de fórmulas complejas y la manipulación de grandes conjuntos de datos.\\nEsto puede llevar mucho tiempo y puede no proporcionar el mismo nivel de detalle o automatización que los informes predefinidos y personalizables disponibles en las plataformas CRM.\\nLa falta de análisis avanzado dificulta que las empresas que utilizan Excel obtengan una comprensión profunda de la eficacia de su gestión de leads, identifiquen tendencias y tomen decisiones basadas en datos para optimizar sus estrategias.\\n","section":"Las Desventajas de Usar Excel para la Nutrición y el Seguimiento de Leads","version":"current","path":"/blog/las-desventajas-de-usar-excel-para-la-nutricion-y-el-seguimiento-de-leads#55-informes-y-análisis-inadecuados","category":"blogs"},{"title":"5.6. Problemas de Seguridad","content":"El uso de Excel para almacenar y gestionar datos confidenciales de clientes y leads puede plantear importantes problemas de seguridad.\\nLos archivos de Excel suelen carecer del cifrado de datos robusto y de los mecanismos sofisticados de control de acceso que se encuentran en los sistemas CRM.\\nEsto los hace más vulnerables a las violaciones de seguridad, al acceso no autorizado y a la exposición accidental de datos, especialmente si los archivos se comparten por correo electrónico o soluciones de almacenamiento en la nube menos seguras.\\nPara las empresas que manejan información confidencial de los clientes, depender únicamente de Excel para la nutrición y el seguimiento de leads puede representar un riesgo considerable para la privacidad y la seguridad de los datos, lo que podría generar problemas de cumplimiento y daños a la reputación.\\n","section":"Las Desventajas de Usar Excel para la Nutrición y el Seguimiento de Leads","version":"current","path":"/blog/las-desventajas-de-usar-excel-para-la-nutricion-y-el-seguimiento-de-leads#56-problemas-de-seguridad","category":"blogs"},{"title":"5.7. Falta de Automatización","content":"Una limitación importante de Excel en el contexto de la nutrición y el seguimiento de leads es la ausencia general de funciones de automatización integradas.\\nTareas como el envío de correos electrónicos de seguimiento automatizados, la programación de recordatorios para las actividades de ventas y la actualización de los estados de los leads suelen requerir la intervención manual en Excel.\\nEsta falta de automatización puede llevar mucho tiempo y ser ineficiente, especialmente cuando se trata de un gran volumen de leads. Sin flujos de trabajo automatizados, los equipos de ventas y marketing deben gestionar manualmente cada paso del proceso de nutrición y seguimiento, lo que aumenta el riesgo de que se pasen por alto o se retrasen las tareas. Esto puede obstaculizar significativamente la productividad y reducir la eficacia general de los esfuerzos de gestión de leads.\\n","section":"Las Desventajas de Usar Excel para la Nutrición y el Seguimiento de Leads","version":"current","path":"/blog/las-desventajas-de-usar-excel-para-la-nutricion-y-el-seguimiento-de-leads#57-falta-de-automatización","category":"blogs"},{"title":"5.8. Limitaciones de Escalabilidad","content":"A medida que las empresas crecen y aumenta el número de leads que necesitan gestionar, Excel a menudo demuestra ser una solución con una escalabilidad limitada.\\nEl manejo de grandes conjuntos de datos en Excel puede generar problemas de rendimiento, como tiempos de carga lentos y un mayor riesgo de bloqueos o corrupción de datos.\\nLa gestión de extensas listas de leads, el seguimiento de sus interacciones y la generación de informes pueden volverse cada vez más engorrosos e ineficientes a medida que crece el volumen de datos.\\nEsta falta de escalabilidad hace que Excel sea una solución a largo plazo menos viable para las empresas que anticipan un crecimiento en su base de clientes y en sus esfuerzos de generación de leads.\\nLos sistemas CRM, por otro lado, están diseñados específicamente para manejar grandes volúmenes de datos y escalar con las necesidades cambiantes de la empresa.\\nTe recomendamos leer:\\nCRM vs Excel, Un Análisis Comparativo para la Nutrición y el Seguimiento de Leads en Ventas\\nLas Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads\\nComparación de la Eficacia y la Eficiencia de CRM Versus Excel\\nLas Desventajas de Usar Excel para la Nutrición y el Seguimiento de Leads\\nIndicadores Clave de Rendimiento (KPI) para Medir el Éxito\\n","section":"Las Desventajas de Usar Excel para la Nutrición y el Seguimiento de Leads","version":"current","path":"/blog/las-desventajas-de-usar-excel-para-la-nutricion-y-el-seguimiento-de-leads#58-limitaciones-de-escalabilidad","category":"blogs"},{"title":"4.1. Gestión Centralizada de Datos","content":"Uno de los beneficios más significativos de emplear un sistema CRM para la nutrición y el seguimiento de leads es su capacidad para consolidar toda la información pertinente de leads y clientes en una única base de datos de fácil acceso.\\n<!-- truncate -->\\nEste repositorio centralizado actúa como una única fuente de verdad, proporcionando una visión integral de cada interacción, preferencia e historial de compras asociado con cada lead.\\nAl eliminar los silos de datos fragmentados que a menudo existen en diferentes departamentos u hojas de cálculo, un sistema CRM garantiza que tanto los equipos de ventas como los de marketing tengan acceso inmediato a la información más actualizada.\\nEsta perspectiva holística permite a los equipos interactuar con los leads de una manera más informada y personalizada, fomentando relaciones más sólidas y mejorando la eficacia de los esfuerzos de nutrición y seguimiento.\\nLa capacidad de recuperar rápidamente el historial y las preferencias de un lead permite una comunicación adaptada que resuena con sus necesidades específicas y su etapa en el proceso de compra.\\n","section":"Las Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads","version":"current","path":"/blog/las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads#41-gestión-centralizada-de-datos","category":"blogs"},{"title":"4.2. Automatización de Tareas","content":"Los sistemas CRM ofrecen sólidas capacidades de automatización que agilizan significativamente los procesos de nutrición y seguimiento de leads.\\nEstas plataformas pueden automatizar una amplia gama de tareas, incluyendo el envío de correos electrónicos de seguimiento personalizados basados en activadores o programaciones predefinidas, el establecimiento de recordatorios para que los representantes de ventas realicen un contacto oportuno y la actualización automática de los estados de los leads a medida que avanzan por el embudo de ventas.\\nEsta automatización no solo ahorra tiempo valioso a los equipos de ventas y marketing, sino que también minimiza el riesgo de error humano y garantiza un compromiso constante con los leads en los puntos de contacto cruciales.\\nAdemás, muchos sistemas CRM pueden automatizar la captura inicial de leads de diversas fuentes, como formularios de sitios web, consultas por correo electrónico e interacciones en redes sociales, asegurando que no se pase por alto ninguna oportunidad potencial.\\nAl automatizar estas tareas administrativas rutinarias, los sistemas CRM permiten a los profesionales de ventas y marketing dedicar más tiempo y recursos a actividades estratégicas como la construcción de relaciones y el cierre de acuerdos.\\n","section":"Las Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads","version":"current","path":"/blog/las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads#42-automatización-de-tareas","category":"blogs"},{"title":"4.3. Mejora de la Calificación y Puntuación de Leads","content":"Muchos sistemas CRM incorporan sofisticadas funciones de puntuación de leads que permiten a las empresas identificar y priorizar los leads más prometedores en función de una variedad de criterios predefinidos.\\nEstos criterios pueden incluir la interacción de un lead con materiales de marketing (como visitas al sitio web, descargas de contenido y clics en correos electrónicos), información demográfica y necesidades o intereses expresados.\\nEl sistema CRM asigna automáticamente una puntuación a cada lead en función de estos factores, proporcionando a los equipos de ventas una indicación clara de qué prospectos tienen más probabilidades de convertirse.\\nEste enfoque basado en datos permite a los representantes de ventas centrar sus esfuerzos en los leads con una mayor probabilidad de éxito, optimizando así su tiempo y recursos.\\nAdemás, los sistemas CRM pueden rastrear el comportamiento y las interacciones de un lead a lo largo del tiempo, ofreciendo información valiosa sobre su nivel de interés y su disposición a tomar una decisión de compra.\\n","section":"Las Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads","version":"current","path":"/blog/las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads#43-mejora-de-la-calificación-y-puntuación-de-leads","category":"blogs"},{"title":"4.4. Personalización y Comunicación Mejoradas","content":"Las plataformas CRM permiten a las empresas personalizar su comunicación con los leads a un nivel granular.\\nAl permitir la segmentación de leads en función de diversos atributos, como la demografía, la industria, los intereses específicos o la etapa en el recorrido del comprador, los sistemas CRM permiten a los equipos de ventas y marketing adaptar sus mensajes y contenido para que resuenen con las necesidades únicas de diferentes segmentos de leads.\\nEste enfoque personalizado, que puede incluir dirigirse a los leads por su nombre y hacer referencia a sus intereses específicos o interacciones pasadas, mejora significativamente el compromiso y ayuda a construir una relación más sólida.\\nAdemás, los sistemas CRM mantienen un registro completo de todo el historial de comunicación con cada lead, proporcionando un contexto valioso para cada interacción y asegurando que los representantes de ventas tengan una comprensión completa de la progresión de la relación.\\n","section":"Las Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads","version":"current","path":"/blog/las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads#44-personalización-y-comunicación-mejoradas","category":"blogs"},{"title":"4.5. Mejora de la Colaboración Entre los Equipos de Ventas y Marketing","content":"Los sistemas CRM sirven como una herramienta central que facilita la comunicación y la colaboración fluidas entre los equipos de ventas y marketing.\\nAl proporcionar a ambos equipos una visión compartida de todos los datos, actividades y progreso de los leads, las plataformas CRM garantizan la alineación en los procesos de gestión de leads y facilitan una transición más fluida de los leads calificados del marketing a las ventas.Esta visibilidad compartida elimina posibles malentendidos y garantiza que ambos equipos trabajen hacia objetivos comunes en la nutrición y conversión de leads.\\nLos equipos de marketing pueden aprovechar los datos del CRM para comprender mejor qué campañas están generando los leads más calificados, mientras que los equipos de ventas pueden proporcionar comentarios sobre la calidad de los leads recibidos, lo que permite una optimización continua de la estrategia general de gestión de leads. Esta colaboración mejorada fomenta un enfoque más unificado y eficaz para interactuar con los clientes potenciales.\\n","section":"Las Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads","version":"current","path":"/blog/las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads#45-mejora-de-la-colaboración-entre-los-equipos-de-ventas-y-marketing","category":"blogs"},{"title":"4.6. Escalabilidad","content":"Los sistemas CRM están intrínsecamente diseñados para escalar junto con el crecimiento de una empresa, capaces de adaptarse a volúmenes crecientes de leads, datos de clientes y actividad de usuarios.\\nA medida que una empresa se expande y sus procesos de ventas se vuelven más intrincados, las plataformas CRM pueden adaptarse para manejar una mayor complejidad y dar soporte a equipos más grandes.\\nEsta escalabilidad garantiza que los procesos de nutrición y seguimiento de leads sigan siendo eficientes y eficaces incluso a medida que la empresa evoluciona.\\nA diferencia de las soluciones basadas en hojas de cálculo, que pueden volverse engorrosas y propensas a errores al tratar con grandes conjuntos de datos, los sistemas CRM están construidos con arquitecturas robustas que pueden gestionar un crecimiento significativo en el volumen y la complejidad de los leads sin comprometer el rendimiento.\\nEsto convierte al CRM en una solución sostenible y preparada para el futuro para las empresas con aspiraciones de expansión.\\n","section":"Las Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads","version":"current","path":"/blog/las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads#46-escalabilidad","category":"blogs"},{"title":"4.7. Informes y Análisis","content":"Los sistemas CRM ofrecen potentes funcionalidades de informes y análisis que proporcionan información invaluable sobre la eficacia de las estrategias de nutrición y seguimiento de leads.\\nLas empresas pueden aprovechar estas capacidades para rastrear indicadores clave de rendimiento (KPI) como las tasas de conversión de leads, los niveles de participación con las campañas de nutrición, la duración promedio del ciclo de ventas y la eficacia de diferentes fuentes de leads.\\nMuchas plataformas CRM ofrecen paneles de control personalizables que proporcionan una representación visual de estas métricas, lo que permite a las partes interesadas obtener una visión general rápida y completa del rendimiento.\\nEstas funciones de informes y análisis permiten la toma de decisiones basada en datos, lo que permite a las empresas identificar qué estrategias están funcionando eficazmente y dónde se pueden realizar mejoras para optimizar sus procesos de nutrición y seguimiento de leads.\\n","section":"Las Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads","version":"current","path":"/blog/las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads#47-informes-y-análisis","category":"blogs"},{"title":"4.8. Integración con Otras Herramientas","content":"Una ventaja significativa de los sistemas CRM es su capacidad para integrarse sin problemas con una amplia gama de otras herramientas y plataformas empresariales.\\nEsto puede incluir la integración con plataformas de marketing por correo electrónico para ejecutar y rastrear campañas de nutrición, software de automatización de marketing para flujos de trabajo de gestión de leads más sofisticados, plataformas de participación de ventas para mejorar las actividades de seguimiento e incluso sistemas de atención al cliente para garantizar una experiencia de cliente unificada.\\nEstas integraciones crean un ecosistema más conectado y eficiente, lo que permite un flujo fluido de datos y acciones entre diferentes funciones empresariales. Por ejemplo, los leads capturados a través de los esfuerzos de marketing pueden ingresarse automáticamente en el CRM, y sus interacciones posteriores pueden activar secuencias de seguimiento automatizadas gestionadas dentro de la plataforma de participación de ventas.\\nEsta interconexión mejora la eficacia general de los esfuerzos de nutrición y seguimiento de leads al proporcionar una visión holística del recorrido del cliente y agilizar los flujos de trabajo.\\n","section":"Las Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads","version":"current","path":"/blog/las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads#48-integración-con-otras-herramientas","category":"blogs"},{"title":"4.9. Mejora de la Experiencia del Cliente","content":"Al facilitar la comunicación personalizada y oportuna, y al proporcionar una comprensión integral del recorrido de cada lead, los sistemas CRM contribuyen en última instancia a una experiencia del cliente mejorada.\\nCuando las empresas pueden rastrear y gestionar eficazmente sus interacciones con clientes potenciales, están mejor equipadas para anticipar sus necesidades, proporcionar información relevante y ofrecer soluciones personalizadas.\\nEste nivel de atención y personalización hace que los leads se sientan valorados y comprendidos, fomentando relaciones más sólidas y aumentando la probabilidad de conversión.\\nUna experiencia positiva y atractiva a lo largo del proceso de nutrición y seguimiento de leads puede mejorar significativamente la satisfacción del cliente y generar lealtad a largo plazo, lo que en última instancia beneficia a la empresa a través de mayores ventas y referencias positivas de boca en boca.\\nTe recomendamos leer:\\nCRM vs Excel, Un Análisis Comparativo para la Nutrición y el Seguimiento de Leads en Ventas\\nLas Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads\\nComparación de la Eficacia y la Eficiencia de CRM Versus Excel\\nLas Desventajas de Usar Excel para la Nutrición y el Seguimiento de Leads\\nIndicadores Clave de Rendimiento (KPI) para Medir el Éxito\\n","section":"Las Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads","version":"current","path":"/blog/las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads#49-mejora-de-la-experiencia-del-cliente","category":"blogs"},{"title":"VIII. Estudios de Caso del Mundo Real: Historias de Éxito en la Optimización de la Tasa de Conversión.","content":"Numerosas empresas han implementado con éxito estrategias para mejorar las tasas de conversión en sus embudos de marketing y ventas, proporcionando valiosas lecciones para otros.\\nEn la etapa de Conciencia, Tom\'s Planner, una empresa de software de gestión de proyectos en línea, aumentó las inscripciones en un 44% simplemente agregando un formulario de inscripción directamente en su página de inicio junto a la imagen del producto, minimizando los pasos requeridos para que los usuarios creen una cuenta.\\nGoing, una empresa de ofertas de viajes, mejoró su tasa de inicio de prueba en un 104% mes a mes al optimizar su página de destino mediante pruebas A/B y centrarse en propuestas de valor claras.\\nPara la etapa de Consideración, Archive Social aumentó su tasa de clics en un 68% al probar y mejorar la visibilidad de la llamada a la acción principal en su página de inicio.\\nBear Mattress aprovechó estratégicamente las oportunidades de venta cruzada en las páginas de detalles de sus productos de colchones al incorporar imágenes en miniatura, texto centrado en el visitante y ofertas rediseñadas, lo que resultó en un aumento del 16% en los ingresos.\\nEn las etapas de Decisión/Conversión, Walmart Canadá logró un aumento del 20% en las conversiones generales en todos los dispositivos y un aumento del 98% en los pedidos móviles al simplificar la experiencia del usuario de su sitio web y eliminar elementos innecesarios.\\nFlos USA abordó las bajas tasas de conversión de pago realizando análisis de comportamiento exhaustivos e implementando cambios específicos en sus páginas de productos, como actualizar la opción \\"Elegir acabado\\" con muestras de color, lo que llevó a un notable aumento del 125% en las tasas de pago.\\nEn términos de Defensa, PUMA desarrolló una estrategia de defensa del cliente que resultó en un ROI de 6 veces al promover programas de referencia en puntos de contacto clave y adaptar los mensajes a diferentes audiencias a través de pruebas A/B.\\nEstos estudios de caso subrayan la importancia de comprender el comportamiento del usuario, probar diferentes enfoques y centrarse en proporcionar valor y una experiencia fluida en cada etapa del embudo.\\nDemuestran que incluso los cambios aparentemente pequeños, cuando se basan en datos y conocimientos del cliente, pueden conducir a mejoras significativas en las tasas de conversión y el éxito empresarial general.\\n","section":"Alineando Marketing y Ventas para una Conversión Óptima","version":"current","path":"/blog/alineando-marketing-y-ventas-para-una-conversion-optima#viii-estudios-de-caso-del-mundo-real-historias-de-éxito-en-la-optimización-de-la-tasa-de-conversión","category":"blogs"},{"title":"IX. Tendencias Futuras en la Conversión del Embudo de Marketing y Ventas (2024-2025).","content":"El panorama de la conversión del embudo de marketing y ventas está en constante evolución, impulsado por los avances tecnológicos y los cambios en los comportamientos del consumidor. Varias tendencias clave están preparadas para dar forma a las estrategias de optimización en 2024 y 2025.\\nLa inteligencia artificial (IA) y el análisis predictivo están impulsando cada vez más los esfuerzos de personalización, permitiendo a las empresas crear experiencias hiper-personalizadas basadas en el comportamiento y la intención del usuario.\\nCon la evolución de las regulaciones de privacidad de datos, se está poniendo un mayor énfasis en las estrategias, donde las empresas recopilan datos directamente de los consumidores para impulsar sus esfuerzos de marketing. El contenido interactivo y “comprable” está ganando terreno en cada etapa del embudo, ofreciendo experiencias inmersivas y permitiendo compras directas.\\nLa automatización de correo electrónico y SMS impulsada por IA se está volviendo más sofisticada, permitiendo mensajes altamente dirigidos y personalizados basados en el comportamiento del usuario en tiempo real.\\nEl auge de la búsqueda por voz y el SEO impulsado por IA está remodelando la forma en que los consumidores descubren la información, lo que requiere la optimización para estos nuevos canales.\\nReconociendo que la retención es la nueva adquisición, las marcas se están centrando cada vez más en estrategias de marketing de fidelización y retención para aumentar el valor de vida del cliente.\\nLas tecnologías de IA generativa se están adoptando para diversos aspectos de la CRO, incluyendo la síntesis de registros de pruebas, el resaltado de hallazgos clave e incluso la sugerencia de pasos futuros.\\nAprovechar la prueba social a través de contenido generado por el usuario, reseñas y testimonios sigue siendo una tendencia poderosa para generar confianza e impulsar las conversiones.\\nGarantizar la limpieza e integridad de los datos se está volviendo cada vez más importante para un análisis preciso y una optimización efectiva.\\nLas empresas están profundizando en la investigación del comportamiento de los visitantes para obtener una comprensión más profunda de las motivaciones y los puntos débiles del usuario.\\nLa optimización para experiencias multicanal será crucial a medida que los consumidores interactúen con las marcas a través de diversos puntos de contacto.\\nLas empresas están explorando los beneficios de diversificar los canales de medios pagados y centrarse en la optimización del proceso de clientes potenciales a ventas mediante el seguimiento de métricas del embudo más profundas.\\nPara aprovechar estas tendencias emergentes, las empresas deben invertir en herramientas de automatización de marketing impulsadas por IA para personalizar los puntos de contacto en todo el embudo y priorizar la recopilación de datos de primera parte a través de experiencias interactivas.\\nLa optimización del contenido para motores de búsqueda impulsados por IA y la incorporación de contenido de video y comprable mejorarán la participación y la conversión.\\nCentrarse en tácticas de marketing de retención y monitorear y adaptarse continuamente al panorama digital en evolución será crucial para el éxito sostenido.\\n","section":"Alineando Marketing y Ventas para una Conversión Óptima","version":"current","path":"/blog/alineando-marketing-y-ventas-para-una-conversion-optima#ix-tendencias-futuras-en-la-conversión-del-embudo-de-marketing-y-ventas-2024-2025","category":"blogs"},{"title":"X. Conclusión: Perspectivas Clave y una Hoja de Ruta para la Mejora Continua de la Conversión.","content":"Mejorar las tasas de conversión en todo el embudo de marketing y ventas es un proceso continuo que requiere un enfoque holístico, basado en datos y centrado en el cliente.\\nAl comprender los matices de cada etapa del embudo, realizar un seguimiento diligente de los indicadores clave de rendimiento e implementar estrategias dirigidas para la optimización, las empresas pueden mejorar significativamente su capacidad para convertir prospectos en clientes leales y defensores de la marca.\\nLa identificación y eliminación de cuellos de botella, junto con una priorización estratégica de los esfuerzos de optimización, garantiza que los recursos se centren en las áreas que producirán el mayor impacto.\\nEl poder de un enfoque integrado, que alinea los equipos de marketing y ventas, fomenta un recorrido del cliente fluido y consistente que genera confianza e impulsa las conversiones. Los estudios de caso del mundo real destacados en este informe demuestran resultados tangibles que se pueden lograr a través de una optimización efectiva de la tasa de conversión.\\nDe cara al futuro, mantenerse informado y adaptarse a las tendencias futuras en tecnología y comportamiento del consumidor será esencial para mantener una ventaja competitiva. La hoja de ruta para la mejora continua de la conversión implica un compromiso con el monitoreo continuo, las pruebas rigurosas y la voluntad de refinar las estrategias basadas en datos y comentarios de los clientes.\\nEn última instancia, al colocar al cliente en el centro de todos los esfuerzos y esforzarse por satisfacer sus necesidades en cada etapa del embudo, las empresas pueden desbloquear un crecimiento sostenible y construir relaciones duraderas.\\nTe recomendamos leer:\\nMejora de las Tasas de Conversión a Través del Embudo de Marketing y Ventas\\nEstrategias Accionables para Mejorar las Tasas de Conversión en Cada Etapa del Embudo\\nAlineando Marketing y Ventas para una Conversión Óptima\\n","section":"Alineando Marketing y Ventas para una Conversión Óptima","version":"current","path":"/blog/alineando-marketing-y-ventas-para-una-conversion-optima#x-conclusión-perspectivas-clave-y-una-hoja-de-ruta-para-la-mejora-continua-de-la-conversión","category":"blogs"},{"title":"V. Identificación y Eliminación de Cuellos de Botella y Puntos Débiles en su Embudo de Conversión.","content":"La identificación y el tratamiento de los cuellos de botella y los puntos débiles dentro del embudo de conversión es crucial para maximizar la eficacia de las ventas y lograr un crecimiento óptimo.\\nUn cuello de botella se produce cuando los clientes potenciales se \\"atascan\\" en una etapa particular y no avanzan más, lo que indica un problema que debe resolverse. Se pueden emplear varios métodos para identificar estas áreas de fricción.\\nUno de los enfoques más eficaces es analizar las tasas de conversión en cada etapa del embudo. Al monitorear el porcentaje de leads que pasan con éxito de una etapa a la siguiente, puede identificar dónde se producen las caídas significativas. Por ejemplo, un gran número de leads que entran en la etapa de conciencia pero una baja tasa de conversión a la etapa de interés podría sugerir problemas con el mensaje inicial o la segmentación. Del mismo modo, una gran caída entre las etapas de consideración y decisión podría indicar que los prospectos no están encontrando la información o la tranquilidad que necesitan para finalizar una compra.\\nRevisar la calidad de los leads en cada nivel es otro paso importante. Los leads de baja calidad tienen menos probabilidades de convertirse y pueden obstruir el embudo, creando un cuello de botella. Al evaluar las características y el compromiso de los leads en diferentes etapas, puede identificar si existen problemas con sus procesos de generación, segmentación o calificación de leads. Las herramientas de análisis de ventas, como Fintesk, pueden proporcionar datos e información valiosos sobre el rendimiento del embudo, incluidas las tasas de conversión, la velocidad de los acuerdos o negocios y la atribución de ingresos, lo que ayuda a identificar dónde se atascan los leads.\\nInteractuar directamente con los clientes a través de encuestas y análisis de comentarios también puede revelar cuellos de botella. Los comentarios de los clientes pueden resaltar los puntos débiles, los obstáculos y las razones por las que los prospectos podrían no estar avanzando más en el embudo. Abordar estos problemas puede mejorar significativamente la satisfacción del cliente y eliminar los cuellos de botella.\\nAdemás, evaluar la eficacia de sus procesos de nutrición y seguimiento de leads es esencial. Si los leads se estancan en una determinada etapa, podría indicar la necesidad de mejorar la frecuencia, la calidad y la personalización de su comunicación. Asegurar un seguimiento rápido y relevante es crucial para mantener a los leads comprometidos.\\nAgilizar la alineación de ventas y marketing es vital para un flujo fluido de leads a través del embudo. La falta de alineación entre estos equipos puede generar una comunicación deficiente, prioridades contradictorias y, en última instancia, cuellos de botella.\\nUna mejor cooperación, objetivos compartidos y un circuito de retroalimentación constante entre ventas y marketing pueden optimizar todo el proceso de ventas. Las herramientas de análisis de sitios web (como el gratuito google analytics) se pueden utilizar para rastrear el comportamiento del usuario e identificar puntos específicos donde los usuarios abandonan el embudo.\\nEl análisis de métricas como la tasa de rebote, el tiempo en la página y las páginas de salida puede proporcionar pistas sobre posibles problemas de usabilidad o lagunas de contenido.\\nLos mapas de calor y las repeticiones de sesión (como hotjar) ofrecen información cualitativa sobre cómo los usuarios interactúan con su sitio web, revelando áreas de frustración, confusión o distracción que podrían estar obstaculizando la conversión.\\nEl monitoreo del tiempo dedicado por los clientes en cada etapa también puede indicar posibles cuellos de botella. Un tiempo inusualmente largo dedicado a una etapa en particular podría sugerir que los usuarios tienen dificultades para encontrar la información que necesitan o que enfrentan dificultades para continuar.\\nOtros signos de puntos débiles en el embudo de ventas incluyen ciclos de ventas largos sin progreso visible, bajas tasas de conversión de lead a cliente y un alto volumen de leads de baja calidad.\\nEl análisis de los informes del embudo de ventas puede proporcionar una visión general completa de estas métricas, destacando las etapas con bajas tasas de conversión o un alto estancamiento de leads.\\nLa implementación de un sistema de puntuación de leads CRM puede ayudar a priorizar los leads prometedores y garantizar que los esfuerzos de ventas se centren en las conversiones más probables.\\nLa revisión periódica del embudo de ventas para una posible optimización y la garantía de que los clientes comprendan completamente la propuesta de valor de su oferta también son pasos cruciales para identificar y eliminar los cuellos de botella.\\nFinalmente, es esencial validar sus fuentes de datos y realizar investigaciones exhaustivas de la causa raíz cuando se observan cambios o caídas significativas en el rendimiento del embudo.\\n","section":"Estrategias Accionables para Mejorar las Tasas de Conversión en Cada Etapa del Embudo","version":"current","path":"/blog/estrategias-para-mejorar-las-tasas-de-conversion-en-cada-etapa-del-embudo#v-identificación-y-eliminación-de-cuellos-de-botella-y-puntos-débiles-en-su-embudo-de-conversión","category":"blogs"},{"title":"VI. Priorización de los Esfuerzos de Optimización de la Conversión para un Máximo Impacto.","content":"Con tiempo y recursos limitados, es esencial priorizar los esfuerzos de optimización de la conversión para garantizar el mayor retorno. Varios marcos de priorización pueden ayudar a las empresas a tomar decisiones informadas sobre dónde enfocar sus esfuerzos de optimización.\\nEl marco ICE (Impacto, Confianza, Facilidad) implica calificar cada idea de optimización en función de su impacto estimado, su confianza en lograr ese impacto y la facilidad de implementación. La multiplicación de estas puntuaciones proporciona una puntuación ICE general, lo que permite la comparación y la priorización.\\nDel mismo modo, el marco PIE (Potencial, Importancia, Facilidad) clasifica las pruebas en función del potencial de mejora, la importancia de la página o el tráfico y la facilidad de implementación.\\nEl marco RICE (Alcance, Impacto, Confianza, Esfuerzo) amplía esto al considerar también el alcance de la mejora potencial, proporcionando una evaluación más completa.\\nLa Matriz de Impacto vs. Esfuerzo ofrece un enfoque visual para la priorización, trazando las tareas en función de su impacto potencial y el esfuerzo requerido para su finalización.\\nEste marco ayuda a identificar \\"victorias rápidas\\" (alto impacto, bajo esfuerzo), \\"grandes apuestas\\" (alto impacto, alto esfuerzo), \\"rellenos\\" (bajo impacto, bajo esfuerzo) y \\"sumideros de dinero\\" (bajo impacto, alto esfuerzo).\\nIndependientemente del marco elegido (existen varios para clasificar las oportunidades de mejora), es crucial priorizar los esfuerzos en función del impacto potencial en las tasas de conversión, la facilidad de implementación de los cambios y la alineación con los objetivos comerciales generales.\\nA menudo se recomienda comenzar con las \\"oportunidades fáciles\\" que pueden generar resultados rápidos con un mínimo esfuerzo para generar impulso y demostrar el valor de la optimización de la tasa de conversión.\\nLa selección del marco más apropiado dependerá del contexto específico, los datos disponibles y los objetivos del programa de optimización. Una combinación de análisis de datos cuantitativos e información cualitativa del cliente debe guiar este proceso de priorización.\\nTe recomendamos leer:\\nMejora de las Tasas de Conversión a Través del Embudo de Marketing y Ventas\\nEstrategias Accionables para Mejorar las Tasas de Conversión en Cada Etapa del Embudo\\nAlineando Marketing y Ventas para una Conversión Óptima\\n","section":"Estrategias Accionables para Mejorar las Tasas de Conversión en Cada Etapa del Embudo","version":"current","path":"/blog/estrategias-para-mejorar-las-tasas-de-conversion-en-cada-etapa-del-embudo#vi-priorización-de-los-esfuerzos-de-optimización-de-la-conversión-para-un-máximo-impacto","category":"blogs"},{"title":"Entendiendo el Viaje del Cliente.","content":"El embudo de marketing y ventas, ilustra el camino teórico que sigue un cliente desde su primera interacción con una marca hasta la etapa final de lealtad y defensa.\\nComprender este viaje es fundamental para optimizar las tasas de conversión en cada punto de contacto.\\nEl embudo típicamente comienza con la etapa de Conciencia. Aquí, el objetivo principal es hacer que los clientes potenciales conozcan una marca, sus productos o sus servicios. Esta exposición inicial puede ocurrir a través de varios canales, como redes sociales, marketing de contenidos o publicidad.\\nA medida que los prospectos se vuelven conscientes de una marca, ingresan a las etapas de Interés y Consideración. Durante esta fase, los consumidores buscan activamente información sobre la marca y sus ofertas, evaluando si estas podrían satisfacer sus necesidades o resolver sus problemas.\\nComparan diferentes opciones y comienzan a formarse una opinión sobre el valor potencial de una solución en particular.\\nMuy relacionada está la etapa de Deseo o Evaluación, donde el cliente ha identificado una necesidad y está considerando soluciones específicas, potencialmente con un presupuesto en mente. Están yendo más allá del interés general y comenzando a imaginarse a sí mismos usando el producto o servicio.\\nLa etapa de Intención, a veces considerada una fase separada o un puente entre la consideración y la acción, significa que el prospecto está mostrando un claro deseo de adquirir la oferta.\\nEl punto crucial de la transacción ocurre en la etapa de Conversión, Decisión o Acción. Aquí es donde el prospecto toma la decisión final de comprar el producto o servicio, convirtiéndose en cliente. Sin embargo, el viaje no termina aquí.\\nLa experiencia posterior a la compra es fundamental para fomentar la Lealtad y la Retención. El enfoque cambia a la construcción de relaciones a largo plazo, asegurando la satisfacción del cliente y fomentando las compras repetidas.\\nLa etapa final, Defensa, se alcanza cuando los clientes satisfechos y leales se convierten en promotores del negocio, recomendándolo a otros.\\nEs importante reconocer que si bien este modelo proporciona un marco general, el número específico y la definición de las etapas pueden variar según el negocio en particular y su proceso de ventas.\\nComprender la mentalidad y las necesidades de los clientes en cada una de estas etapas es esencial para desarrollar estrategias específicas para mejorar las tasas de conversión.\\nLa visión lineal tradicional del embudo se complementa cada vez más con una comprensión más dinámica del viaje del cliente, donde las personas pueden interactuar a través de múltiples canales y potencialmente revisar o incluso omitir ciertas etapas.\\n","section":"Mejora de las Tasas de Conversión a Través del Embudo de Marketing y Ventas","version":"current","path":"/blog/mejora-de-las-tasas-de-conversion-a-traves-del-embudo-de-marketing-y-ventas#entendiendo-el-viaje-del-cliente","category":"blogs"},{"title":"Indicadores Clave de Rendimiento (KPIs) para Medir la Conversión en las Etapas del Embudo.","content":"Para optimizar eficazmente el embudo de marketing y ventas, es crucial realizar un seguimiento de los indicadores clave de rendimiento (KPI) en cada etapa.\\nEstas métricas proporcionan información valiosa sobre el rendimiento del embudo, lo que permite a las empresas identificar áreas de fortaleza y debilidad y medir el impacto de los esfuerzos de optimización.\\nEn la etapa de Conciencia, las métricas clave incluyen el tráfico del sitio web, que indica el número de clientes potenciales que visitan sus plataformas en línea, y la participación en redes sociales, que refleja cómo los usuarios interactúan con su marca en los canales de redes sociales. Las menciones de marca rastrean con qué frecuencia se discute su marca en línea, mientras que el alcance y las impresiones miden el alcance de la visibilidad de su marca. Los visitantes únicos proporcionan un recuento de los visitantes por primera vez, y el crecimiento de fans y seguidores indica la expansión de su audiencia en redes sociales. El seguimiento de la clasificación de palabras clave de búsqueda de marca ayuda a evaluar su visibilidad en los resultados de los motores de búsqueda. Para el contenido de video, el porcentaje de visualizaciones de video y la tasa de finalización de video son importantes. El rendimiento de la publicidad se puede medir mediante el costo por mil impresiones (CPM) y el costo por clic (CPC). Finalmente, la tasa de rebote en las páginas de destino puede indicar la relevancia y el compromiso de su contenido inicial.\\nPasando a las etapas de Interés y Consideración, los KPI relevantes incluyen el tiempo dedicado al sitio/página y las páginas vistas, que reflejan el nivel de compromiso con su contenido. Las descargas de contenido indican interés en recursos más profundos, y la tasa de generación de leads mide la eficacia con la que está capturando información de clientes potenciales. La tasa de participación en las redes sociales (compartidos, comentarios, me gusta, menciones) muestra el nivel de interacción con su contenido. Los registros de correo electrónico construyen su canal de comunicación directa, y las reseñas de clientes proporcionan prueba social. Para las empresas de comercio electrónico, la tasa de adición al carrito señala la intención de compra. La calidad del lead evalúa la probabilidad de que los leads se conviertan. Los visitantes recurrentes, la tasa de carrito a detalle y el uso de la búsqueda del sitio ofrecen más información sobre el comportamiento y la intención del usuario. Métricas adicionales como la tasa de enfoque, el comportamiento de múltiples clics, la rotación de dispositivos y los patrones de lectura pueden proporcionar una comprensión granular del compromiso del usuario.\\nLas etapas de Conversión, Decisión o Acción son críticas para medir el éxito de su embudo. La tasa de conversión (CVR) es la medida más directa de cuántos prospectos se están convirtiendo en clientes. El costo por adquisición (CPA) y el costo por lead (CPL) ayudan a evaluar la eficiencia de su gasto en marketing. Las ventas y los ingresos son los indicadores definitivos del rendimiento financiero, mientras que el retorno de la inversión publicitaria (ROAS) mide los ingresos generados por cada dólar gastado en publicidad. El valor promedio del pedido (AOV) y el valor promedio del contrato reflejan el valor de cada transacción. El análisis de los pedidos de clientes nuevos versus recurrentes y los ingresos por producto proporciona información sobre la adquisición de clientes y el rendimiento del producto. Los ingresos por visitante (RPV) vinculan el tráfico del sitio web con la generación de ingresos. Para los equipos de ventas, métricas como la tasa de conversión de leads calificados para ventas (SQL) a oportunidad, la tasa de conversión de lead a cliente, la tasa de conversión de lead a reunión, la tasa de abandono del embudo, la relación de oportunidad a ganancia, el tamaño promedio del acuerdo, la velocidad del pipeline de ventas son esenciales.\\nDespués de la compra, en las etapas de Lealtad y Retención, los KPI clave incluyen la satisfacción del cliente (CSAT), las tasas de retención y el sentimiento del cliente. La tasa de recompra (RPR) y el valor de vida del cliente (CLV) indican el valor a largo plazo de sus clientes. La tasa de abandono mide la pérdida de clientes, mientras que el promedio de días entre transacciones y la tasa de retención de clientes general reflejan la lealtad del cliente.\\nFinalmente, en la etapa de Defensa, el Net Promoter Score (NPS) mide la lealtad del cliente y la probabilidad de recomendación, junto con el número de referencias, menciones en redes sociales y calificaciones de reseñas.\\nAl monitorear consistentemente estos KPI, las empresas pueden obtener una comprensión integral del rendimiento de su embudo de marketing y ventas, realizar un seguimiento del progreso hacia sus objetivos e identificar áreas específicas que requieren optimización.\\nEl análisis combinado de estas métricas puede revelar información más profunda sobre el comportamiento del cliente y la eficacia de diversas estrategias.\\nPor ejemplo, un alto volumen de tráfico en el sitio web en la etapa de conciencia, junto con una baja tasa de generación de leads, podría sugerir que el contenido no está resonando con el público objetivo o que el llamado a la acción no es convincente.\\nPor el contrario, una sólida tasa de conversión de lead a cliente pero una alta tasa de abandono podrían indicar problemas con la experiencia del cliente posterior a la compra.\\nDada la cantidad de métricas existentes no recomendamos implementar todas en un solo paso, sino seleccionar, en primera instancia una (1) por cada etapa y luego a medida que se tiene un mayor entendimiento de las métricas implementadas ir avanzando en implementar otras.\\n","section":"Mejora de las Tasas de Conversión a Través del Embudo de Marketing y Ventas","version":"current","path":"/blog/mejora-de-las-tasas-de-conversion-a-traves-del-embudo-de-marketing-y-ventas#indicadores-clave-de-rendimiento-kpis-para-medir-la-conversión-en-las-etapas-del-embudo","category":"blogs"},{"title":"Indicadores Clave de Rendimiento (KPIs) para Medir la Conversión en las Etapas del Embudo","content":"Etapa del Embudo\\nIndicadores Clave de Rendimiento (KPIs)\\n\\n\\n\\n\\nConciencia\\nTráfico del sitio web, participación en redes sociales, menciones de marca, alcance, impresiones, crecimiento de fans y seguidores, clasificación de palabras clave de búsqueda de marca, porcentaje de visualizaciones de video, tasa de finalización de video, costo por mil impresiones (CPM), costo por clic (CPC), tasa de rebote, visitantes únicos\\n\\n\\nInterés y Consideración\\nTiempo dedicado al sitio/página, páginas vistas, descargas de contenido, tasa de generación de leads, tasa de participación en redes sociales (compartidos, comentarios, me gusta, menciones), registros de correo electrónico, reseñas de clientes, tasa de adición al carrito, calidad del lead, visitantes recurrentes, tasa de carrito a detalle, uso de la búsqueda del sitio, tasa de enfoque, comportamiento de múltiples clics, rotación de dispositivos, patrones de lectura\\n\\n\\nConversión, Decisión o Acción\\nTasa de conversión (CVR), costo por adquisición (CPA), costo por lead (CPL), ventas, ingresos, retorno de la inversión publicitaria (ROAS), valor promedio del pedido (AOV), valor promedio del contrato, pedidos de clientes nuevos versus recurrentes, ingresos por producto, ingresos por visitante (RPV), tasa de conversión de leads calificados para ventas (SQL) a oportunidad, tasa de conversión de lead a cliente, tasa de conversión de lead a reunión, tasa de abandono del embudo, relación de oportunidad a ganancia, tamaño promedio del acuerdo, velocidad del pipeline de ventas, tasa de calificación de leads\\n\\n\\nLealtad y Retención\\nSatisfacción del cliente (CSAT), tasas de retención, sentimiento del cliente, tasa de recompra (RPR), valor de vida del cliente (CLV), tasa de abandono, promedio de días entre transacciones, tasa de retención de clientes\\n\\n\\nDefensa\\nNet Promoter Score (NPS), referencias, menciones en redes sociales, calificaciones de reseñas\\nTe recomendamos leer:\\nMejora de las Tasas de Conversión a Través del Embudo de Marketing y Ventas\\nEstrategias Accionables para Mejorar las Tasas de Conversión en Cada Etapa del Embudo\\nAlineando Marketing y Ventas para una Conversión Óptima\\n","section":"Mejora de las Tasas de Conversión a Través del Embudo de Marketing y Ventas","version":"current","path":"/blog/mejora-de-las-tasas-de-conversion-a-traves-del-embudo-de-marketing-y-ventas#indicadores-clave-de-rendimiento-kpis-para-medir-la-conversión-en-las-etapas-del-embudo-1","category":"blogs"},{"title":"Markdown page example","content":"You don\'t need React to write simple standalone pages.\\n","section":"Markdown page example","version":"current","path":"/markdown-page","category":"pages"}],"availableVersions":["current"],"docsInstances":["default"],"plugins":{"analytics":{"enabled":true}},"id":"default"}}}')
;// CONCATENATED MODULE: ./.docusaurus/i18n.json
var i18n_namespaceObject = JSON.parse('{"defaultLocale":"en","locales":["en","es"],"path":"i18n","currentLocale":"en","localeConfigs":{"en":{"label":"English","direction":"ltr","htmlLang":"en","calendar":"gregory","path":"en","translate":true,"url":"https://docs.fintesk.com","baseUrl":"/"},"es":{"label":"Español","direction":"ltr","htmlLang":"es","calendar":"gregory","path":"es","translate":true,"url":"https://docs.fintesk.com","baseUrl":"/es/"}}}')
// EXTERNAL MODULE: ./.docusaurus/codeTranslations.json
var codeTranslations = __webpack_require__(22654);
;// CONCATENATED MODULE: ./.docusaurus/site-metadata.json
var site_metadata_namespaceObject = JSON.parse('{"docusaurusVersion":"3.9.2","siteVersion":"0.0.1","pluginVersions":{"docusaurus-plugin-css-cascade-layers":{"type":"package","name":"@docusaurus/plugin-css-cascade-layers","version":"3.9.2"},"docusaurus-plugin-content-docs":{"type":"package","name":"@docusaurus/plugin-content-docs","version":"3.9.2"},"docusaurus-plugin-content-blog":{"type":"package","name":"@docusaurus/plugin-content-blog","version":"3.9.2"},"docusaurus-plugin-content-pages":{"type":"package","name":"@docusaurus/plugin-content-pages","version":"3.9.2"},"docusaurus-plugin-sitemap":{"type":"package","name":"@docusaurus/plugin-sitemap","version":"3.9.2"},"docusaurus-plugin-svgr":{"type":"package","name":"@docusaurus/plugin-svgr","version":"3.9.2"},"docusaurus-plugin-redoc":{"type":"package","name":"docusaurus-plugin-redoc","version":"2.2.2"},"docusaurus-theme-classic":{"type":"package","name":"@docusaurus/theme-classic","version":"3.9.2"},"docusaurus-theme-redoc":{"type":"package","name":"docusaurus-theme-redoc","version":"2.2.2"},"docusaurus-plugin-google-tag-manager":{"type":"package","name":"@docusaurus/plugin-google-tag-manager","version":"3.9.2"},"@orama/plugin-docusaurus-v3":{"type":"package","name":"@orama/plugin-docusaurus-v3","version":"3.1.16"}}}')
;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/docusaurusContext.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 






// Static value on purpose: don't make it dynamic!
// Using context is still useful for testability reasons.
const contextValue = {
    siteConfig: docusaurus_config/* ["default"] */.A,
    siteMetadata: site_metadata_namespaceObject,
    globalData: globalData_namespaceObject,
    i18n: i18n_namespaceObject,
    codeTranslations: codeTranslations
};
const Context = /*#__PURE__*/ react.createContext(contextValue);
function DocusaurusContextProvider({ children }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(Context.Provider, {
        value: contextValue,
        children: children
    });
}


}),
9526: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (BrowserOnly)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _docusaurus_useIsBrowser__rspack_import_2 = __webpack_require__(19863);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


// Similar comp to the one described here:
// https://www.joshwcomeau.com/react/the-perils-of-rehydration/#abstractions
function BrowserOnly({ children, fallback }) {
    const isBrowser = (0,_docusaurus_useIsBrowser__rspack_import_2/* ["default"] */.A)();
    if (isBrowser) {
        if (typeof children !== 'function' && "production" === 'development') {}
        return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(react_jsx_runtime__rspack_import_0.Fragment, {
            children: children?.()
        });
    }
    return fallback ?? null;
}


}),
11701: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ ErrorBoundary)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(74848);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/ExecutionEnvironment.js
var ExecutionEnvironment = __webpack_require__(91289);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/Head.js
var Head = __webpack_require__(53572);
// EXTERNAL MODULE: ./node_modules/@docusaurus/utils-common/lib/index.js
var lib = __webpack_require__(5248);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Layout/index.js + 170 modules
var Layout = __webpack_require__(16099);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/routeContext.js
var routeContext = __webpack_require__(97574);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/theme-fallback/Error/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ // Should we translate theme-fallback?
/* eslint-disable @docusaurus/no-untranslated-text */ 






function ErrorDisplay({ error, tryAgain }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
        style: {
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'center',
            alignItems: 'flex-start',
            minHeight: '100vh',
            width: '100%',
            maxWidth: '80ch',
            fontSize: '20px',
            margin: '0 auto',
            padding: '1rem'
        },
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsx)("h1", {
                style: {
                    fontSize: '3rem'
                },
                children: "This page crashed"
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)("button", {
                type: "button",
                onClick: tryAgain,
                style: {
                    margin: '1rem 0',
                    fontSize: '2rem',
                    cursor: 'pointer',
                    borderRadius: 20,
                    padding: '1rem'
                },
                children: "Try again"
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(ErrorBoundaryError, {
                error: error
            })
        ]
    });
}
function ErrorBoundaryError({ error }) {
    const causalChain = (0,lib.getErrorCausalChain)(error);
    const fullMessage = causalChain.map((e)=>e.message).join('\n\nCause:\n');
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("p", {
        style: {
            whiteSpace: 'pre-wrap'
        },
        children: fullMessage
    });
}
// A bit hacky: we need to add an artificial RouteContextProvider here
// The goal is to be able to render the error inside the theme layout
// Without this, our theme classic would crash due to lack of route context
// See also https://github.com/facebook/docusaurus/pull/9852
function ErrorRouteContextProvider({ children }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(routeContext/* .RouteContextProvider */.W, {
        value: {
            plugin: {
                name: 'docusaurus-core-error-boundary',
                id: 'default'
            }
        },
        children: children
    });
}
function Error({ error, tryAgain }) {
    // We wrap the error in its own error boundary because the layout can actually
    // throw too... Only the ErrorDisplay component is simple enough to be
    // considered safe to never throw
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(ErrorRouteContextProvider, {
        children: /*#__PURE__*/ (0,jsx_runtime.jsxs)(ErrorBoundary, {
            // Note: we display the original error here, not the error that we
            // captured in this extra error boundary
            fallback: ()=>/*#__PURE__*/ (0,jsx_runtime.jsx)(ErrorDisplay, {
                    error: error,
                    tryAgain: tryAgain
                }),
            children: [
                /*#__PURE__*/ (0,jsx_runtime.jsx)(Head/* ["default"] */.A, {
                    children: /*#__PURE__*/ (0,jsx_runtime.jsx)("title", {
                        children: "Page Error"
                    })
                }),
                /*#__PURE__*/ (0,jsx_runtime.jsx)(Layout/* ["default"] */.A, {
                    children: /*#__PURE__*/ (0,jsx_runtime.jsx)(ErrorDisplay, {
                        error: error,
                        tryAgain: tryAgain
                    })
                })
            ]
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/exports/ErrorBoundary.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



// eslint-disable-next-line react/function-component-definition
const DefaultFallback = (params)=>/*#__PURE__*/ (0,jsx_runtime.jsx)(Error, {
        ...params
    });
class ErrorBoundary extends react.Component {
    constructor(props){
        super(props);
        this.state = {
            error: null
        };
    }
    componentDidCatch(error) {
        // Catch errors in any components below and re-render with error message
        if (ExecutionEnvironment["default"].canUseDOM) {
            this.setState({
                error
            });
        }
    }
    render() {
        const { children } = this.props;
        const { error } = this.state;
        if (error) {
            const fallbackParams = {
                error,
                tryAgain: ()=>this.setState({
                        error: null
                    })
            };
            const fallback = this.props.fallback ?? DefaultFallback;
            return fallback(fallbackParams);
        }
        // See https://github.com/facebook/docusaurus/issues/6337#issuecomment-1012913647
        return children ?? null;
    }
}


}),
91289: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  "default": () => (__rspack_default_export)
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ const canUseDOM = typeof window !== 'undefined' && 'document' in window && 'createElement' in window.document;
const ExecutionEnvironment = {
    canUseDOM,
    // window.attachEvent is IE-specific; it's very likely Docusaurus won't work
    // on IE anyway.
    canUseEventListeners: canUseDOM && ('addEventListener' in window || 'attachEvent' in window),
    canUseIntersectionObserver: canUseDOM && 'IntersectionObserver' in window,
    canUseViewport: canUseDOM && 'screen' in window
};
/* export default */ const __rspack_default_export = (ExecutionEnvironment);


}),
53572: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (Head)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var react_helmet_async__rspack_import_2 = __webpack_require__(80545);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


function Head(props) {
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(react_helmet_async__rspack_import_2/* .Helmet */.mg, {
        ...props
    });
}


}),
95310: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (__rspack_default_export)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var react_router_dom__rspack_import_8 = __webpack_require__(54625);
/* import */ var _docusaurus_utils_common__rspack_import_7 = __webpack_require__(5248);
/* import */ var _useDocusaurusContext__rspack_import_2 = __webpack_require__(10898);
/* import */ var _isInternalUrl__rspack_import_6 = __webpack_require__(58310);
/* import */ var _ExecutionEnvironment__rspack_import_3 = __webpack_require__(91289);
/* import */ var _useBrokenLinks__rspack_import_4 = __webpack_require__(55916);
/* import */ var _useBaseUrl__rspack_import_5 = __webpack_require__(66497);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 








// TODO all this wouldn't be necessary if we used ReactRouter basename feature
// We don't automatically add base urls to all links,
// only the "safe" ones, starting with / (like /docs/introduction)
// this is because useBaseUrl() actually transforms relative links
// like "introduction" to "/baseUrl/introduction" => bad behavior to fix
const shouldAddBaseUrlAutomatically = (to)=>to.startsWith('/');
function Link({ isNavLink, to, href, activeClassName, isActive, 'data-noBrokenLinkCheck': noBrokenLinkCheck, autoAddBaseUrl = true, ...props }, forwardedRef) {
    const { siteConfig } = (0,_useDocusaurusContext__rspack_import_2/* ["default"] */.A)();
    const { trailingSlash, baseUrl } = siteConfig;
    const router = siteConfig.future.experimental_router;
    const { withBaseUrl } = (0,_useBaseUrl__rspack_import_5/* .useBaseUrlUtils */.hH)();
    const brokenLinks = (0,_useBrokenLinks__rspack_import_4/* ["default"] */.A)();
    const innerRef = (0,react__rspack_import_1.useRef)(null);
    (0,react__rspack_import_1.useImperativeHandle)(forwardedRef, ()=>innerRef.current);
    // IMPORTANT: using to or href should not change anything
    // For example, MDX links will ALWAYS give us the href props
    // Using one prop or the other should not be used to distinguish
    // internal links (/docs/myDoc) from external links (https://github.com)
    const targetLinkUnprefixed = to || href;
    function maybeAddBaseUrl(str) {
        return autoAddBaseUrl && shouldAddBaseUrlAutomatically(str) ? withBaseUrl(str) : str;
    }
    const isInternal = (0,_isInternalUrl__rspack_import_6/* ["default"] */.A)(targetLinkUnprefixed);
    // pathname:// is a special "protocol" we use to tell Docusaurus link
    // that a link is not "internal" and that we shouldn't use history.push()
    // this is not ideal but a good enough escape hatch for now
    // see https://github.com/facebook/docusaurus/issues/3309
    // note: we want baseUrl to be appended (see issue for details)
    // TODO read routes and automatically detect internal/external links?
    const targetLinkWithoutPathnameProtocol = targetLinkUnprefixed?.replace('pathname://', '');
    // TODO we should use ReactRouter basename feature instead!
    // Automatically apply base url in links that start with /
    let targetLink = typeof targetLinkWithoutPathnameProtocol !== 'undefined' ? maybeAddBaseUrl(targetLinkWithoutPathnameProtocol) : undefined;
    // TODO find a way to solve this problem properly
    // Fix edge case when useBaseUrl is used on a link
    // "./" is useful for images and other resources
    // But we don't need it for <Link>
    // unfortunately we can't really make the difference :/
    if (router === 'hash' && targetLink?.startsWith('./')) {
        targetLink = targetLink?.slice(1);
    }
    if (targetLink && isInternal) {
        targetLink = (0,_docusaurus_utils_common__rspack_import_7.applyTrailingSlash)(targetLink, {
            trailingSlash,
            baseUrl
        });
    }
    const preloaded = (0,react__rspack_import_1.useRef)(false);
    const LinkComponent = isNavLink ? react_router_dom__rspack_import_8/* .NavLink */.k2 : react_router_dom__rspack_import_8/* .Link */.N_;
    const IOSupported = _ExecutionEnvironment__rspack_import_3["default"].canUseIntersectionObserver;
    const ioRef = (0,react__rspack_import_1.useRef)();
    const handleRef = (el)=>{
        innerRef.current = el;
        if (IOSupported && el && isInternal) {
            // If IO supported and element reference found, set up Observer.
            ioRef.current = new window.IntersectionObserver((entries)=>{
                entries.forEach((entry)=>{
                    if (el === entry.target) {
                        // If element is in viewport, stop observing and run callback.
                        // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
                        if (entry.isIntersecting || entry.intersectionRatio > 0) {
                            ioRef.current.unobserve(el);
                            ioRef.current.disconnect();
                            if (targetLink != null) {
                                window.docusaurus.prefetch(targetLink);
                            }
                        }
                    }
                });
            });
            // Add element to the observer.
            ioRef.current.observe(el);
        }
    };
    const onInteractionEnter = ()=>{
        if (!preloaded.current && targetLink != null) {
            window.docusaurus.preload(targetLink);
            preloaded.current = true;
        }
    };
    (0,react__rspack_import_1.useEffect)(()=>{
        // If IO is not supported. We prefetch by default (only once).
        if (!IOSupported && isInternal && _ExecutionEnvironment__rspack_import_3["default"].canUseDOM) {
            if (targetLink != null) {
                window.docusaurus.prefetch(targetLink);
            }
        }
        // When unmounting, stop intersection observer from watching.
        return ()=>{
            if (IOSupported && ioRef.current) {
                ioRef.current.disconnect();
            }
        };
    }, [
        ioRef,
        targetLink,
        IOSupported,
        isInternal
    ]);
    // It is simple local anchor link targeting current page?
    const isAnchorLink = targetLink?.startsWith('#') ?? false;
    // See also RR logic:
    // https://github.com/remix-run/react-router/blob/v5/packages/react-router-dom/modules/Link.js#L47
    const hasInternalTarget = !props.target || props.target === '_self';
    // Should we use a regular <a> tag instead of React-Router Link component?
    const isRegularHtmlLink = !targetLink || !isInternal || !hasInternalTarget || // When using the hash router, we can't use the regular <a> link for anchors
    // We need to use React Router to navigate to /#/pathname/#anchor
    // And not /#anchor
    // See also https://github.com/facebook/docusaurus/pull/10311
    isAnchorLink && router !== 'hash';
    if (!noBrokenLinkCheck && (isAnchorLink || !isRegularHtmlLink)) {
        brokenLinks.collectLink(targetLink);
    }
    if (props.id) {
        brokenLinks.collectAnchor(props.id);
    }
    // These props are only added in unit tests to assert/capture the type of link
    const testOnlyProps =  false ? 0 : {};
    return isRegularHtmlLink ? // eslint-disable-next-line jsx-a11y/anchor-has-content, @docusaurus/no-html-links
    /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("a", {
        ref: innerRef,
        href: targetLink,
        ...targetLinkUnprefixed && !isInternal && {
            target: '_blank',
            rel: 'noopener noreferrer'
        },
        ...props,
        ...testOnlyProps
    }) : /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(LinkComponent, {
        ...props,
        onMouseEnter: onInteractionEnter,
        onTouchStart: onInteractionEnter,
        innerRef: handleRef,
        to: targetLink,
        ...isNavLink && {
            isActive,
            activeClassName
        },
        ...testOnlyProps
    });
}
/* export default */ const __rspack_default_export = (/*#__PURE__*/react__rspack_import_1.forwardRef(Link));


}),
30568: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ Translate),
  T: () => (/* binding */ translate)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(74848);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/exports/Interpolate.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

function interpolate(text, values) {
    // eslint-disable-next-line prefer-named-capture-group
    const segments = text.split(/(\{\w+\})/).map((seg, index)=>{
        // Odd indices (1, 3, 5...) of the segments are (potentially) interpolatable
        if (index % 2 === 1) {
            const value = values?.[seg.slice(1, -1)];
            if (value !== undefined) {
                return value;
            }
        // No match: add warning? There's no way to "escape" interpolation though
        }
        return seg;
    });
    if (segments.some((seg)=>/*#__PURE__*/ (0,react.isValidElement)(seg))) {
        return segments.map((seg, index)=>/*#__PURE__*/ (0,react.isValidElement)(seg) ? /*#__PURE__*/ react.cloneElement(seg, {
                key: index
            }) : seg).filter((seg)=>seg !== '');
    }
    return segments.join('');
}
function Interpolate({ children, values }) {
    if (typeof children !== 'string') {
        throw new Error(`The Docusaurus <Interpolate> component only accept simple string values. Received: ${/*#__PURE__*/ isValidElement(children) ? 'React element' : typeof children}`);
    }
    return /*#__PURE__*/ _jsx(_Fragment, {
        children: interpolate(children, values)
    });
}

// EXTERNAL MODULE: ./.docusaurus/codeTranslations.json
var codeTranslations = __webpack_require__(22654);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/exports/Translate.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


// Can't read it from context, due to exposing imperative API

function getLocalizedMessage({ id, message }) {
    if (typeof id === 'undefined' && typeof message === 'undefined') {
        throw new Error('Docusaurus translation declarations must have at least a translation id or a default translation message');
    }
    return codeTranslations[id ?? message] ?? message ?? id;
}
// Imperative translation API is useful for some edge-cases:
// - translating page titles (meta)
// - translating string props (input placeholders, image alt, aria labels...)
function translate({ message, id }, values) {
    const localizedMessage = getLocalizedMessage({
        message,
        id
    });
    return interpolate(localizedMessage, values);
}
// Maybe we'll want to improve this component with additional features
// Like toggling a translation mode that adds a little translation button near
// the text?
function Translate({ children, id, values }) {
    if (children && typeof children !== 'string') {
        console.warn('Illegal <Translate> children', children);
        throw new Error('The Docusaurus <Translate> component only accept simple string values');
    }
    const localizedMessage = getLocalizedMessage({
        message: children,
        id
    });
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
        children: interpolate(localizedMessage, values)
    });
}


}),
68977: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  W: () => (DEFAULT_PLUGIN_ID)
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ // Constants used on the client-side: duplicated from server-side code
const DEFAULT_PLUGIN_ID = 'default';


}),
58310: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (isInternalUrl),
  z: () => (hasProtocol)
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ function hasProtocol(url) {
    return /^(?:\w*:|\/\/)/.test(url);
}
function isInternalUrl(url) {
    return typeof url !== 'undefined' && !hasProtocol(url);
}


}),
66497: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  Ay: () => (useBaseUrl),
  hH: () => (useBaseUrlUtils)
});
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var _useDocusaurusContext__rspack_import_1 = __webpack_require__(10898);
/* import */ var _isInternalUrl__rspack_import_2 = __webpack_require__(58310);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


function addBaseUrl({ siteUrl, baseUrl, url, options: { forcePrependBaseUrl = false, absolute = false } = {}, router }) {
    // It never makes sense to add base url to a local anchor url, or one with a
    // protocol
    if (!url || url.startsWith('#') || (0,_isInternalUrl__rspack_import_2/* .hasProtocol */.z)(url)) {
        return url;
    }
    // TODO hash router + /baseUrl/ is unlikely to work well in all situations
    // This will support most cases, but not all
    // See https://github.com/facebook/docusaurus/pull/9859
    if (router === 'hash') {
        return url.startsWith('/') ? `.${url}` : `./${url}`;
    }
    if (forcePrependBaseUrl) {
        return baseUrl + url.replace(/^\//, '');
    }
    // /baseUrl -> /baseUrl/
    // https://github.com/facebook/docusaurus/issues/6315
    if (url === baseUrl.replace(/\/$/, '')) {
        return baseUrl;
    }
    // We should avoid adding the baseurl twice if it's already there
    const shouldAddBaseUrl = !url.startsWith(baseUrl);
    const basePath = shouldAddBaseUrl ? baseUrl + url.replace(/^\//, '') : url;
    return absolute ? siteUrl + basePath : basePath;
}
function useBaseUrlUtils() {
    const { siteConfig } = (0,_useDocusaurusContext__rspack_import_1/* ["default"] */.A)();
    const { baseUrl, url: siteUrl } = siteConfig;
    const router = siteConfig.future.experimental_router;
    const withBaseUrl = (0,react__rspack_import_0.useCallback)((url, options)=>addBaseUrl({
            siteUrl,
            baseUrl,
            url,
            options,
            router
        }), [
        siteUrl,
        baseUrl,
        router
    ]);
    return {
        withBaseUrl
    };
}
function useBaseUrl(url, options = {}) {
    const { withBaseUrl } = useBaseUrlUtils();
    return withBaseUrl(url, options);
}


}),
55916: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ useBrokenLinks)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(74848);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/BrokenLinksContext.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

const createStatefulBrokenLinks = ()=>{
    // Set to dedup, as it's not useful to collect multiple times the same value
    const allAnchors = new Set();
    const allLinks = new Set();
    return {
        collectAnchor: (anchor)=>{
            typeof anchor !== 'undefined' && allAnchors.add(anchor);
        },
        collectLink: (link)=>{
            typeof link !== 'undefined' && allLinks.add(link);
        },
        getCollectedAnchors: ()=>[
                ...allAnchors
            ],
        getCollectedLinks: ()=>[
                ...allLinks
            ]
    };
};
const Context = /*#__PURE__*/ react.createContext({
    collectAnchor: ()=>{
    // No-op for client
    },
    collectLink: ()=>{
    // No-op for client
    }
});
const useBrokenLinksContext = ()=>(0,react.useContext)(Context);
function BrokenLinksProvider({ children, brokenLinks }) {
    return /*#__PURE__*/ _jsx(Context.Provider, {
        value: brokenLinks,
        children: children
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/exports/useBrokenLinks.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 
function useBrokenLinks() {
    return useBrokenLinksContext();
}


}),
10898: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (useDocusaurusContext)
});
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var _docusaurusContext__rspack_import_1 = __webpack_require__(93587);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

function useDocusaurusContext() {
    return (0,react__rspack_import_0.useContext)(_docusaurusContext__rspack_import_1/* .Context */.o);
}


}),
99044: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  P_: () => (usePluginData),
  kh: () => (useAllPluginInstancesData)
});
/* import */ var _useDocusaurusContext__rspack_import_0 = __webpack_require__(10898);
/* import */ var _constants__rspack_import_1 = __webpack_require__(68977);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

function useGlobalData() {
    const { globalData } = (0,_useDocusaurusContext__rspack_import_0/* ["default"] */.A)();
    return globalData;
}
function useAllPluginInstancesData(pluginName, options = {}) {
    const globalData = useGlobalData();
    const pluginGlobalData = globalData[pluginName];
    if (!pluginGlobalData && options.failfast) {
        throw new Error(`Docusaurus plugin global data not found for "${pluginName}" plugin.`);
    }
    return pluginGlobalData;
}
function usePluginData(pluginName, pluginId = _constants__rspack_import_1/* .DEFAULT_PLUGIN_ID */.W, options = {}) {
    const pluginGlobalData = useAllPluginInstancesData(pluginName);
    const pluginInstanceGlobalData = pluginGlobalData?.[pluginId];
    if (!pluginInstanceGlobalData && options.failfast) {
        throw new Error(`Docusaurus plugin global data not found for "${pluginName}" plugin with id "${pluginId}".`);
    }
    return pluginInstanceGlobalData;
}


}),
19863: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (useIsBrowser)
});
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var _browserContext__rspack_import_1 = __webpack_require__(91173);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

function useIsBrowser() {
    return (0,react__rspack_import_0.useContext)(_browserContext__rspack_import_1/* .Context */.o);
}


}),
99989: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (__rspack_default_export)
});
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var _ExecutionEnvironment__rspack_import_1 = __webpack_require__(91289);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

/**
 * This hook is like `useLayoutEffect`, but without the SSR warning.
 * It seems hacky but it's used in many React libs (Redux, Formik...).
 * Also mentioned here: https://github.com/facebook/react/issues/16956
 *
 * It is useful when you need to update a ref as soon as possible after a React
 * render (before `useEffect`).
 *
 * TODO should become unnecessary in React v19?
 * https://github.com/facebook/react/pull/26395
 * This was added in core with Docusaurus v3 but kept undocumented on purpose
 */ const useIsomorphicLayoutEffect = _ExecutionEnvironment__rspack_import_1["default"].canUseDOM ? react__rspack_import_0.useLayoutEffect : react__rspack_import_0.useEffect;
/* export default */ const __rspack_default_export = (useIsomorphicLayoutEffect);


}),
78491: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (useRouteContext)
});
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var _routeContext__rspack_import_1 = __webpack_require__(97574);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

function useRouteContext() {
    const context = react__rspack_import_0.useContext(_routeContext__rspack_import_1/* .Context */.o);
    if (!context) {
        throw new Error('Unexpected: no Docusaurus route context found');
    }
    return context;
}


}),
27665: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (flat)
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ const isTree = (x)=>typeof x === 'object' && !!x && Object.keys(x).length > 0;
/**
 * Takes a tree, and flattens it into a map of keyPath -> value.
 *
 * ```js
 * flat({ a: { b: 1 } }) === { "a.b": 1 };
 * flat({ a: [1, 2] }) === { "a.0": 1, "a.1": 2 };
 * ```
 */ function flat(target) {
    const delimiter = '.';
    const output = {};
    function dfs(object, prefix) {
        Object.entries(object).forEach(([key, value])=>{
            const newKey = prefix ? `${prefix}${delimiter}${key}` : key;
            if (isTree(value)) {
                dfs(value, newKey);
            } else {
                output[newKey] = value;
            }
        });
    }
    dfs(target);
    return output;
}


}),
97574: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  W: () => (RouteContextProvider),
  o: () => (Context)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

const Context = /*#__PURE__*/ react__rspack_import_1.createContext(null);
function mergeContexts({ parent, value }) {
    if (!parent) {
        if (!value) {
            throw new Error('Unexpected: no Docusaurus route context found');
        } else if (!('plugin' in value)) {
            throw new Error('Unexpected: Docusaurus topmost route context has no `plugin` attribute');
        }
        return value;
    }
    // TODO deep merge this
    const data = {
        ...parent.data,
        ...value?.data
    };
    return {
        // Nested routes are not supposed to override plugin attribute
        plugin: parent.plugin,
        data
    };
}
function RouteContextProvider({ children, value }) {
    const parent = react__rspack_import_1.useContext(Context);
    const mergedValue = (0,react__rspack_import_1.useMemo)(()=>mergeContexts({
            parent,
            value
        }), [
        parent,
        value
    ]);
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(Context.Provider, {
        value: mergedValue,
        children: children
    });
}


}),
42086: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  VQ: () => (DocsPreferredVersionContextProvider),
  XK: () => (useDocsPreferredVersionByPluginId),
  g1: () => (useDocsPreferredVersion)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _docusaurus_plugin_content_docs_client__rspack_import_4 = __webpack_require__(88209);
/* import */ var _docusaurus_constants__rspack_import_6 = __webpack_require__(68977);
/* import */ var _docusaurus_theme_common__rspack_import_3 = __webpack_require__(61022);
/* import */ var _docusaurus_theme_common_internal__rspack_import_2 = __webpack_require__(41367);
/* import */ var _docusaurus_theme_common_internal__rspack_import_5 = __webpack_require__(52260);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 





const storageKey = (pluginId)=>`docs-preferred-version-${pluginId}`;
const DocsPreferredVersionStorage = {
    save: (pluginId, persistence, versionName)=>{
        (0,_docusaurus_theme_common_internal__rspack_import_2/* .createStorageSlot */.Wf)(storageKey(pluginId), {
            persistence
        }).set(versionName);
    },
    read: (pluginId, persistence)=>(0,_docusaurus_theme_common_internal__rspack_import_2/* .createStorageSlot */.Wf)(storageKey(pluginId), {
            persistence
        }).get(),
    clear: (pluginId, persistence)=>{
        (0,_docusaurus_theme_common_internal__rspack_import_2/* .createStorageSlot */.Wf)(storageKey(pluginId), {
            persistence
        }).del();
    }
};
/**
 * Initial state is always null as we can't read local storage from node SSR
 */ const getInitialState = (pluginIds)=>Object.fromEntries(pluginIds.map((id)=>[
            id,
            {
                preferredVersionName: null
            }
        ]));
/**
 * Read storage for all docs plugins, assigning each doc plugin a preferred
 * version (if found)
 */ function readStorageState({ pluginIds, versionPersistence, allDocsData }) {
    /**
     * The storage value we read might be stale, and belong to a version that does
     * not exist in the site anymore. In such case, we remove the storage value to
     * avoid downstream errors.
     */ function restorePluginState(pluginId) {
        const preferredVersionNameUnsafe = DocsPreferredVersionStorage.read(pluginId, versionPersistence);
        const pluginData = allDocsData[pluginId];
        const versionExists = pluginData.versions.some((version)=>version.name === preferredVersionNameUnsafe);
        if (versionExists) {
            return {
                preferredVersionName: preferredVersionNameUnsafe
            };
        }
        DocsPreferredVersionStorage.clear(pluginId, versionPersistence);
        return {
            preferredVersionName: null
        };
    }
    return Object.fromEntries(pluginIds.map((id)=>[
            id,
            restorePluginState(id)
        ]));
}
function useVersionPersistence() {
    return (0,_docusaurus_theme_common__rspack_import_3/* .useThemeConfig */.p)().docs.versionPersistence;
}
const Context = /*#__PURE__*/ react__rspack_import_1.createContext(null);
function useContextValue() {
    const allDocsData = (0,_docusaurus_plugin_content_docs_client__rspack_import_4/* .useAllDocsData */.Gy)();
    const versionPersistence = useVersionPersistence();
    const pluginIds = (0,react__rspack_import_1.useMemo)(()=>Object.keys(allDocsData), [
        allDocsData
    ]);
    // Initial state is empty, as we can't read browser storage in node/SSR
    const [state, setState] = (0,react__rspack_import_1.useState)(()=>getInitialState(pluginIds));
    // On mount, we set the state read from browser storage
    (0,react__rspack_import_1.useEffect)(()=>{
        setState(readStorageState({
            allDocsData,
            versionPersistence,
            pluginIds
        }));
    }, [
        allDocsData,
        versionPersistence,
        pluginIds
    ]);
    // The API that we expose to consumer hooks (memo for constant object)
    const api = (0,react__rspack_import_1.useMemo)(()=>{
        function savePreferredVersion(pluginId, versionName) {
            DocsPreferredVersionStorage.save(pluginId, versionPersistence, versionName);
            setState((s)=>({
                    ...s,
                    [pluginId]: {
                        preferredVersionName: versionName
                    }
                }));
        }
        return {
            savePreferredVersion
        };
    }, [
        versionPersistence
    ]);
    return [
        state,
        api
    ];
}
function DocsPreferredVersionContextProviderUnsafe({ children }) {
    const value = useContextValue();
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(Context.Provider, {
        value: value,
        children: children
    });
}
/**
 * This is a maybe-layer. If the docs plugin is not enabled, this provider is a
 * simple pass-through.
 */ function DocsPreferredVersionContextProvider({ children }) {
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(DocsPreferredVersionContextProviderUnsafe, {
        children: children
    });
}
function useDocsPreferredVersionContext() {
    const value = (0,react__rspack_import_1.useContext)(Context);
    if (!value) {
        throw new _docusaurus_theme_common_internal__rspack_import_5/* .ReactContextError */.dV('DocsPreferredVersionContextProvider');
    }
    return value;
}
/**
 * Returns a read-write interface to a plugin's preferred version. The
 * "preferred version" is defined as the last version that the user visited.
 * For example, if a user is using v3, even when v4 is later published, the user
 * would still be browsing v3 docs when she opens the website next time. Note,
 * the `preferredVersion` attribute will always be `null` before mount.
 */ function useDocsPreferredVersion(pluginId = _docusaurus_constants__rspack_import_6/* .DEFAULT_PLUGIN_ID */.W) {
    const docsData = (0,_docusaurus_plugin_content_docs_client__rspack_import_4/* .useDocsData */.ht)(pluginId);
    const [state, api] = useDocsPreferredVersionContext();
    const { preferredVersionName } = state[pluginId];
    const preferredVersion = docsData.versions.find((version)=>version.name === preferredVersionName) ?? null;
    const savePreferredVersionName = (0,react__rspack_import_1.useCallback)((versionName)=>{
        api.savePreferredVersion(pluginId, versionName);
    }, [
        api,
        pluginId
    ]);
    return {
        preferredVersion,
        savePreferredVersionName
    };
}
function useDocsPreferredVersionByPluginId() {
    const allDocsData = (0,_docusaurus_plugin_content_docs_client__rspack_import_4/* .useAllDocsData */.Gy)();
    const [state] = useDocsPreferredVersionContext();
    function getPluginIdPreferredVersion(pluginId) {
        const docsData = allDocsData[pluginId];
        const { preferredVersionName } = state[pluginId];
        return docsData.versions.find((version)=>version.name === preferredVersionName) ?? null;
    }
    const pluginIds = Object.keys(allDocsData);
    return Object.fromEntries(pluginIds.map((id)=>[
            id,
            getPluginIdPreferredVersion(id)
        ]));
}


}),
7021: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  k: () => (getDocsVersionSearchTag),
  v: () => (useDocsContextualSearchTags)
});
/* import */ var _docusaurus_plugin_content_docs_client__rspack_import_0 = __webpack_require__(88209);
/* import */ var _docsPreferredVersion__rspack_import_1 = __webpack_require__(42086);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

/** The search tag to append as each doc's metadata. */ function getDocsVersionSearchTag(pluginId, versionName) {
    return `docs-${pluginId}-${versionName}`;
}
/**
 * Gets the relevant docs tags to search.
 * This is the logic that powers the contextual search feature.
 *
 * If user is browsing Android 1.4 docs, he'll get presented with:
 * - Android '1.4' docs
 * - iOS 'preferred | latest' docs
 *
 * The result is generic and not coupled to Algolia/DocSearch on purpose.
 */ function useDocsContextualSearchTags() {
    const allDocsData = (0,_docusaurus_plugin_content_docs_client__rspack_import_0/* .useAllDocsData */.Gy)();
    const activePluginAndVersion = (0,_docusaurus_plugin_content_docs_client__rspack_import_0/* .useActivePluginAndVersion */.gk)();
    const docsPreferredVersionByPluginId = (0,_docsPreferredVersion__rspack_import_1/* .useDocsPreferredVersionByPluginId */.XK)();
    // This can't use more specialized hooks because we are mapping over all
    // plugin instances.
    function getDocPluginTags(pluginId) {
        const activeVersion = activePluginAndVersion?.activePlugin.pluginId === pluginId ? activePluginAndVersion.activeVersion : undefined;
        const preferredVersion = docsPreferredVersionByPluginId[pluginId];
        const latestVersion = allDocsData[pluginId].versions.find((v)=>v.isLast);
        const version = activeVersion ?? preferredVersion ?? latestVersion;
        return getDocsVersionSearchTag(pluginId, version.name);
    }
    return [
        ...Object.keys(allDocsData).map(getDocPluginTags)
    ];
}


}),
52473: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  V: () => (DocsSidebarProvider),
  t: () => (useDocsSidebar)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _docusaurus_theme_common_internal__rspack_import_2 = __webpack_require__(52260);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


// Using a Symbol because null is a valid context value (a doc with no sidebar)
// Inspired by https://github.com/jamiebuilds/unstated-next/blob/master/src/unstated-next.tsx
const EmptyContext = Symbol('EmptyContext');
const Context = /*#__PURE__*/ react__rspack_import_1.createContext(EmptyContext);
/**
 * Provide the current sidebar to your children.
 */ function DocsSidebarProvider({ children, name, items }) {
    const stableValue = (0,react__rspack_import_1.useMemo)(()=>name && items ? {
            name,
            items
        } : null, [
        name,
        items
    ]);
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(Context.Provider, {
        value: stableValue,
        children: children
    });
}
/**
 * Gets the sidebar that's currently displayed, or `null` if there isn't one
 */ function useDocsSidebar() {
    const value = (0,react__rspack_import_1.useContext)(Context);
    if (value === EmptyContext) {
        throw new _docusaurus_theme_common_internal__rspack_import_2/* .ReactContextError */.dV('DocsSidebarProvider');
    }
    return value;
}


}),
88260: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  $S: () => (useCurrentSidebarCategory),
  B5: () => (useDocRootMetadata),
  Nr: () => (findFirstSidebarItemLink),
  OF: () => (useSidebarBreadcrumbs),
  QB: () => (useLayoutDoc),
  Vd: () => (useDocsVersionCandidates),
  Y: () => (useVisibleSidebarItems),
  a4: () => (useCurrentSidebarSiblings),
  cC: () => (useDocById),
  d1: () => (filterDocCardListItems),
  fW: () => (useLayoutDocsSidebar),
  w8: () => (isActiveSidebarItem)
});
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var _docusaurus_router__rspack_import_2 = __webpack_require__(56347);
/* import */ var _docusaurus_renderRoutes__rspack_import_8 = __webpack_require__(22831);
/* import */ var _docusaurus_plugin_content_docs_client__rspack_import_5 = __webpack_require__(88209);
/* import */ var _docusaurus_theme_common_internal__rspack_import_4 = __webpack_require__(19209);
/* import */ var _docusaurus_theme_common__rspack_import_7 = __webpack_require__(80618);
/* import */ var _docsPreferredVersion__rspack_import_6 = __webpack_require__(42086);
/* import */ var _docsVersion__rspack_import_1 = __webpack_require__(70921);
/* import */ var _docsSidebar__rspack_import_3 = __webpack_require__(52473);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 








function useDocById(id) {
    const version = (0,_docsVersion__rspack_import_1/* .useDocsVersion */.r)();
    if (!id) {
        return undefined;
    }
    const doc = version.docs[id];
    if (!doc) {
        throw new Error(`no version doc found by id=${id}`);
    }
    return doc;
}
/**
 * Pure function, similar to `Array#find`, but works on the sidebar tree.
 */ function findSidebarCategory(sidebar, predicate) {
    for (const item of sidebar){
        if (item.type === 'category') {
            if (predicate(item)) {
                return item;
            }
            const subItem = findSidebarCategory(item.items, predicate);
            if (subItem) {
                return subItem;
            }
        }
    }
    return undefined;
}
/**
 * Best effort to assign a link to a sidebar category. If the category doesn't
 * have a link itself, we link to the first sub item with a link.
 */ function findFirstSidebarItemCategoryLink(item) {
    if (item.href && !item.linkUnlisted) {
        return item.href;
    }
    for (const subItem of item.items){
        const link = findFirstSidebarItemLink(subItem);
        if (link) {
            return link;
        }
    }
    return undefined;
}
/**
 * Best effort to assign a link to a sidebar item.
 */ function findFirstSidebarItemLink(item) {
    if (item.type === 'link' && !item.unlisted) {
        return item.href;
    }
    if (item.type === 'category') {
        return findFirstSidebarItemCategoryLink(item);
    }
    // Other items types, like "html"
    return undefined;
}
/**
 * Gets the category associated with the current location. Should only be used
 * on category index pages.
 */ function useCurrentSidebarCategory() {
    const { pathname } = (0,_docusaurus_router__rspack_import_2/* .useLocation */.zy)();
    const sidebar = (0,_docsSidebar__rspack_import_3/* .useDocsSidebar */.t)();
    if (!sidebar) {
        throw new Error('Unexpected: cant find current sidebar in context');
    }
    const categoryBreadcrumbs = getSidebarBreadcrumbs({
        sidebarItems: sidebar.items,
        pathname,
        onlyCategories: true
    });
    const deepestCategory = categoryBreadcrumbs.slice(-1)[0];
    if (!deepestCategory) {
        throw new Error(`${pathname} is not associated with a category. useCurrentSidebarCategory() should only be used on category index pages.`);
    }
    return deepestCategory;
}
/**
 * Gets the category associated with the current location. Should only be used
 * on category index pages.
 */ function useCurrentSidebarSiblings() {
    const { pathname } = (0,_docusaurus_router__rspack_import_2/* .useLocation */.zy)();
    const sidebar = (0,_docsSidebar__rspack_import_3/* .useDocsSidebar */.t)();
    if (!sidebar) {
        throw new Error('Unexpected: cant find current sidebar in context');
    }
    const categoryBreadcrumbs = getSidebarBreadcrumbs({
        sidebarItems: sidebar.items,
        pathname,
        onlyCategories: true
    });
    const deepestCategory = categoryBreadcrumbs.slice(-1)[0];
    return deepestCategory?.items ?? sidebar.items;
}
const isActive = (testedPath, activePath)=>typeof testedPath !== 'undefined' && (0,_docusaurus_theme_common_internal__rspack_import_4/* .isSamePath */.ys)(testedPath, activePath);
const containsActiveSidebarItem = (items, activePath)=>items.some((subItem)=>isActiveSidebarItem(subItem, activePath));
/**
 * Checks if a sidebar item should be active, based on the active path.
 */ function isActiveSidebarItem(item, activePath) {
    if (item.type === 'link') {
        return isActive(item.href, activePath);
    }
    if (item.type === 'category') {
        return isActive(item.href, activePath) || containsActiveSidebarItem(item.items, activePath);
    }
    return false;
}
function isVisibleSidebarItem(item, activePath) {
    switch(item.type){
        case 'category':
            return isActiveSidebarItem(item, activePath) || typeof item.href !== 'undefined' && !item.linkUnlisted || item.items.some((subItem)=>isVisibleSidebarItem(subItem, activePath));
        case 'link':
            // An unlisted item remains visible if it is active
            return !item.unlisted || isActiveSidebarItem(item, activePath);
        default:
            return true;
    }
}
function useVisibleSidebarItems(items, activePath) {
    return (0,react__rspack_import_0.useMemo)(()=>items.filter((item)=>isVisibleSidebarItem(item, activePath)), [
        items,
        activePath
    ]);
}
/**
 * Get the sidebar the breadcrumbs for a given pathname
 * Ordered from top to bottom
 */ function getSidebarBreadcrumbs({ sidebarItems, pathname, onlyCategories = false }) {
    const breadcrumbs = [];
    function extract(items) {
        for (const item of items){
            if (item.type === 'category' && ((0,_docusaurus_theme_common_internal__rspack_import_4/* .isSamePath */.ys)(item.href, pathname) || extract(item.items)) || item.type === 'link' && (0,_docusaurus_theme_common_internal__rspack_import_4/* .isSamePath */.ys)(item.href, pathname)) {
                const filtered = onlyCategories && item.type !== 'category';
                if (!filtered) {
                    breadcrumbs.unshift(item);
                }
                return true;
            }
        }
        return false;
    }
    extract(sidebarItems);
    return breadcrumbs;
}
/**
 * Gets the breadcrumbs of the current doc page, based on its sidebar location.
 * Returns `null` if there's no sidebar or breadcrumbs are disabled.
 */ function useSidebarBreadcrumbs() {
    const sidebar = (0,_docsSidebar__rspack_import_3/* .useDocsSidebar */.t)();
    const { pathname } = (0,_docusaurus_router__rspack_import_2/* .useLocation */.zy)();
    const breadcrumbsOption = (0,_docusaurus_plugin_content_docs_client__rspack_import_5/* .useActivePlugin */.vT)()?.pluginData.breadcrumbs;
    if (breadcrumbsOption === false || !sidebar) {
        return null;
    }
    return getSidebarBreadcrumbs({
        sidebarItems: sidebar.items,
        pathname
    });
}
/**
 * "Version candidates" are mostly useful for the layout components, which must
 * be able to work on all pages. For example, if a user has `{ type: "doc",
 * docId: "intro" }` as a navbar item, which version does that refer to? We
 * believe that it could refer to at most three version candidates:
 *
 * 1. The **active version**, the one that the user is currently browsing. See
 * {@link useActiveDocContext}.
 * 2. The **preferred version**, the one that the user last visited. See
 * {@link useDocsPreferredVersion}.
 * 3. The **latest version**, the "default". See {@link useLatestVersion}.
 *
 * @param docsPluginId The plugin ID to get versions from.
 * @returns An array of 1~3 versions with priorities defined above, guaranteed
 * to be unique and non-sparse. Will be memoized, hence stable for deps array.
 */ function useDocsVersionCandidates(docsPluginId) {
    const { activeVersion } = (0,_docusaurus_plugin_content_docs_client__rspack_import_5/* .useActiveDocContext */.zK)(docsPluginId);
    const { preferredVersion } = (0,_docsPreferredVersion__rspack_import_6/* .useDocsPreferredVersion */.g1)(docsPluginId);
    const latestVersion = (0,_docusaurus_plugin_content_docs_client__rspack_import_5/* .useLatestVersion */.r7)(docsPluginId);
    return (0,react__rspack_import_0.useMemo)(()=>(0,_docusaurus_theme_common__rspack_import_7/* .uniq */.sb)([
            activeVersion,
            preferredVersion,
            latestVersion
        ].filter(Boolean)), [
        activeVersion,
        preferredVersion,
        latestVersion
    ]);
}
/**
 * The layout components, like navbar items, must be able to work on all pages,
 * even on non-doc ones where there's no version context, so a sidebar ID could
 * be ambiguous. This hook would always return a sidebar to be linked to. See
 * also {@link useDocsVersionCandidates} for how this selection is done.
 *
 * @throws This hook throws if a sidebar with said ID is not found.
 */ function useLayoutDocsSidebar(sidebarId, docsPluginId) {
    const versions = useDocsVersionCandidates(docsPluginId);
    return (0,react__rspack_import_0.useMemo)(()=>{
        const allSidebars = versions.flatMap((version)=>version.sidebars ? Object.entries(version.sidebars) : []);
        const sidebarEntry = allSidebars.find((sidebar)=>sidebar[0] === sidebarId);
        if (!sidebarEntry) {
            throw new Error(`Can't find any sidebar with id "${sidebarId}" in version${versions.length > 1 ? 's' : ''} ${versions.map((version)=>version.name).join(', ')}".
Available sidebar ids are:
- ${allSidebars.map((entry)=>entry[0]).join('\n- ')}`);
        }
        return sidebarEntry[1];
    }, [
        sidebarId,
        versions
    ]);
}
/**
 * The layout components, like navbar items, must be able to work on all pages,
 * even on non-doc ones where there's no version context, so a doc ID could be
 * ambiguous. This hook would always return a doc to be linked to. See also
 * {@link useDocsVersionCandidates} for how this selection is done.
 *
 * @throws This hook throws if a doc with said ID is not found.
 */ function useLayoutDoc(docId, docsPluginId) {
    const versions = useDocsVersionCandidates(docsPluginId);
    return (0,react__rspack_import_0.useMemo)(()=>{
        const allDocs = versions.flatMap((version)=>version.docs);
        const doc = allDocs.find((versionDoc)=>versionDoc.id === docId);
        if (!doc) {
            const isDraft = versions.flatMap((version)=>version.draftIds).includes(docId);
            // Drafts should be silently filtered instead of throwing
            if (isDraft) {
                return null;
            }
            throw new Error(`Couldn't find any doc with id "${docId}" in version${versions.length > 1 ? 's' : ''} "${versions.map((version)=>version.name).join(', ')}".
Available doc ids are:
- ${(0,_docusaurus_theme_common__rspack_import_7/* .uniq */.sb)(allDocs.map((versionDoc)=>versionDoc.id)).join('\n- ')}`);
        }
        return doc;
    }, [
        docId,
        versions
    ]);
}
// TODO later read version/route directly from context
/**
 * The docs plugin creates nested routes, with the top-level route providing the
 * version metadata, and the subroutes creating individual doc pages. This hook
 * will match the current location against all known sub-routes.
 *
 * @param props The props received by `@theme/DocRoot`
 * @returns The data of the relevant document at the current location, or `null`
 * if no document associated with the current location can be found.
 */ function useDocRootMetadata({ route }) {
    const location = (0,_docusaurus_router__rspack_import_2/* .useLocation */.zy)();
    const versionMetadata = (0,_docsVersion__rspack_import_1/* .useDocsVersion */.r)();
    const docRoutes = route.routes;
    const currentDocRoute = docRoutes.find((docRoute)=>(0,_docusaurus_router__rspack_import_2/* .matchPath */.B6)(location.pathname, docRoute));
    if (!currentDocRoute) {
        return null;
    }
    // For now, the sidebarName is added as route config: not ideal!
    const sidebarName = currentDocRoute.sidebar;
    const sidebarItems = sidebarName ? versionMetadata.docsSidebars[sidebarName] : undefined;
    const docElement = (0,_docusaurus_renderRoutes__rspack_import_8/* .renderRoutes */.v)(docRoutes);
    return {
        docElement,
        sidebarName,
        sidebarItems
    };
}
/**
 * Filter items we don't want to display on the doc card list view
 * @param items
 */ function filterDocCardListItems(items) {
    return items.filter((item)=>{
        const canHaveLink = item.type === 'category' || item.type === 'link';
        if (canHaveLink) {
            return !!findFirstSidebarItemLink(item);
        }
        return true;
    });
}


}),
70921: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  n: () => (DocsVersionProvider),
  r: () => (useDocsVersion)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _docusaurus_theme_common_internal__rspack_import_2 = __webpack_require__(52260);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


const Context = /*#__PURE__*/ react__rspack_import_1.createContext(null);
/**
 * Provide the current version's metadata to your children.
 */ function DocsVersionProvider({ children, version }) {
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(Context.Provider, {
        value: version,
        children: children
    });
}
/**
 * Gets the version metadata of the current doc page.
 */ function useDocsVersion() {
    const version = (0,react__rspack_import_1.useContext)(Context);
    if (version === null) {
        throw new _docusaurus_theme_common_internal__rspack_import_2/* .ReactContextError */.dV('DocsVersionProvider');
    }
    return version;
}


}),
88209: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  gk: () => (/* binding */ useActivePluginAndVersion),
  r7: () => (/* binding */ useLatestVersion),
  $S: () => (/* reexport */ docsUtils/* .useCurrentSidebarCategory */.$S),
  HW: () => (/* binding */ useDocVersionSuggestions),
  zK: () => (/* binding */ useActiveDocContext),
  ir: () => (/* binding */ useActiveVersion),
  vF: () => (/* reexport */ docsSearch/* .useDocsContextualSearchTags */.v),
  vT: () => (/* binding */ useActivePlugin),
  g1: () => (/* reexport */ docsPreferredVersion/* .useDocsPreferredVersion */.g1),
  d1: () => (/* reexport */ docsUtils/* .filterDocCardListItems */.d1),
  jh: () => (/* binding */ useVersions),
  Gy: () => (/* binding */ useAllDocsData),
  ht: () => (/* binding */ useDocsData)
});

// UNUSED EXPORTS: isActiveSidebarItem, useDoc, useDocById, useDocSidebarItemsExpandedState, useDocsSidebar, useDocsVersion, useLayoutDocsSidebar, isVisibleSidebarItem, getDocsVersionSearchTag, useSidebarBreadcrumbs, DocsPreferredVersionContextProvider, DocSidebarItemsExpandedStateProvider, DocsSidebarProvider, useDocsVersionCandidates, useLayoutDoc, useDocsPreferredVersionByPluginId, useVisibleSidebarItems, useDocRootMetadata, useBreadcrumbsStructuredData, findFirstSidebarItemLink, DocsVersionProvider, DocProvider, useCurrentSidebarSiblings, findSidebarCategory

// EXTERNAL MODULE: ./node_modules/react-router/esm/react-router.js
var react_router = __webpack_require__(56347);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/useGlobalData.js
var useGlobalData = __webpack_require__(99044);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/plugin-content-docs/lib/client/docsClientUtils.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 
// This code is not part of the api surface, not in ./theme on purpose
// get the data of the plugin that is currently "active"
// ie the docs of that plugin are currently browsed
// it is useful to support multiple docs plugin instances
function getActivePlugin(allPluginData, pathname, options = {}) {
    const activeEntry = Object.entries(allPluginData)// Route sorting: '/android/foo' should match '/android' instead of '/'
    .sort((a, b)=>b[1].path.localeCompare(a[1].path)).find(([, pluginData])=>!!(0,react_router/* .matchPath */.B6)(pathname, {
            path: pluginData.path,
            exact: false,
            strict: false
        }));
    const activePlugin = activeEntry ? {
        pluginId: activeEntry[0],
        pluginData: activeEntry[1]
    } : undefined;
    if (!activePlugin && options.failfast) {
        throw new Error(`Can't find active docs plugin for "${pathname}" pathname, while it was expected to be found. Maybe you tried to use a docs feature that can only be used on a docs-related page? Existing docs plugin paths are: ${Object.values(allPluginData).map((plugin)=>plugin.path).join(', ')}`);
    }
    return activePlugin;
}
const getLatestVersion = (data)=>data.versions.find((version)=>version.isLast);
function getActiveVersion(data, pathname) {
    // Sort paths so that a match-all version like /docs/* is matched last
    // Otherwise /docs/* would match /docs/1.0.0/* routes
    // This is simplified but similar to the core sortRoutes() logic
    const sortedVersions = [
        ...data.versions
    ].sort((a, b)=>{
        if (a.path === b.path) {
            return 0;
        }
        if (a.path.includes(b.path)) {
            return -1;
        }
        if (b.path.includes(a.path)) {
            return 1;
        }
        return 0;
    });
    return sortedVersions.find((version)=>!!(0,react_router/* .matchPath */.B6)(pathname, {
            path: version.path,
            exact: false,
            strict: false
        }));
}
function getActiveDocContext(data, pathname) {
    const activeVersion = getActiveVersion(data, pathname);
    const activeDoc = activeVersion?.docs.find((doc)=>!!(0,react_router/* .matchPath */.B6)(pathname, {
            path: doc.path,
            exact: true,
            strict: false
        }));
    function getAlternateVersionDocs(docId) {
        const result = {};
        data.versions.forEach((version)=>{
            version.docs.forEach((doc)=>{
                if (doc.id === docId) {
                    result[version.name] = doc;
                }
            });
        });
        return result;
    }
    const alternateVersionDocs = activeDoc ? getAlternateVersionDocs(activeDoc.id) : {};
    return {
        activeVersion,
        activeDoc,
        alternateDocVersions: alternateVersionDocs
    };
}
function getDocVersionSuggestions(data, pathname) {
    const latestVersion = getLatestVersion(data);
    const activeDocContext = getActiveDocContext(data, pathname);
    const latestDocSuggestion = activeDocContext.alternateDocVersions[latestVersion.name];
    return {
        latestDocSuggestion,
        latestVersionSuggestion: latestVersion
    };
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/plugin-content-docs/lib/client/docsUtils.js
var docsUtils = __webpack_require__(88260);
// EXTERNAL MODULE: ./node_modules/@docusaurus/plugin-content-docs/lib/client/docsPreferredVersion.js
var docsPreferredVersion = __webpack_require__(42086);
// EXTERNAL MODULE: ./node_modules/@docusaurus/plugin-content-docs/lib/client/docsSearch.js
var docsSearch = __webpack_require__(7021);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/plugin-content-docs/lib/client/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 











// Important to use a constant object to avoid React useEffect executions etc.
// see https://github.com/facebook/docusaurus/issues/5089
const StableEmptyObject = {};
// In blog-only mode, docs hooks are still used by the theme. We need a fail-
// safe fallback when the docs plugin is not in use
const useAllDocsData = ()=>(0,useGlobalData/* .useAllPluginInstancesData */.kh)('docusaurus-plugin-content-docs') ?? StableEmptyObject;
const useDocsData = (pluginId)=>{
    try {
        return (0,useGlobalData/* .usePluginData */.P_)('docusaurus-plugin-content-docs', pluginId, {
            failfast: true
        });
    } catch (error) {
        throw new Error(`You are using a feature of the Docusaurus docs plugin, but this plugin does not seem to be enabled${pluginId === 'Default' ? '' : ` (pluginId=${pluginId}`}`, {
            cause: error
        });
    }
};
// TODO this feature should be provided by docusaurus core
function useActivePlugin(options = {}) {
    const data = useAllDocsData();
    const { pathname } = (0,react_router/* .useLocation */.zy)();
    return getActivePlugin(data, pathname, options);
}
function useActivePluginAndVersion(options = {}) {
    const activePlugin = useActivePlugin(options);
    const { pathname } = (0,react_router/* .useLocation */.zy)();
    if (!activePlugin) {
        return undefined;
    }
    const activeVersion = getActiveVersion(activePlugin.pluginData, pathname);
    return {
        activePlugin,
        activeVersion
    };
}
/** Versions are returned ordered (most recent first). */ function useVersions(pluginId) {
    const data = useDocsData(pluginId);
    return data.versions;
}
function useLatestVersion(pluginId) {
    const data = useDocsData(pluginId);
    return getLatestVersion(data);
}
/**
 * Returns `undefined` on doc-unrelated pages, because there's no version
 * currently considered as active.
 */ function useActiveVersion(pluginId) {
    const data = useDocsData(pluginId);
    const { pathname } = (0,react_router/* .useLocation */.zy)();
    return getActiveVersion(data, pathname);
}
function useActiveDocContext(pluginId) {
    const data = useDocsData(pluginId);
    const { pathname } = (0,react_router/* .useLocation */.zy)();
    return getActiveDocContext(data, pathname);
}
/**
 * Useful to say "hey, you are not on the latest docs version, please switch"
 */ function useDocVersionSuggestions(pluginId) {
    const data = useDocsData(pluginId);
    const { pathname } = (0,react_router/* .useLocation */.zy)();
    return getDocVersionSuggestions(data, pathname);
}


}),
33678: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  "default": () => (__rspack_default_export)
});
/* import */ var nprogress__rspack_import_0 = __webpack_require__(5947);
/* import */ var nprogress__rspack_import_0_default = /*#__PURE__*/__webpack_require__.n(nprogress__rspack_import_0);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

nprogress__rspack_import_0_default().configure({
    showSpinner: false
});
const delay = 200;
const clientModule = {
    onRouteUpdate ({ location, previousLocation }) {
        if (previousLocation && location.pathname !== previousLocation.pathname) {
            const progressBarTimeout = window.setTimeout(()=>{
                nprogress__rspack_import_0_default().start();
            }, delay);
            return ()=>window.clearTimeout(progressBarTimeout);
        }
        return undefined;
    },
    onRouteDidUpdate () {
        nprogress__rspack_import_0_default().done();
    }
};
/* export default */ const __rspack_default_export = (clientModule);


}),
32489: (function (__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) {
"use strict";

// EXTERNAL MODULE: ./node_modules/prism-react-renderer/dist/index.mjs
var dist = __webpack_require__(71765);
// EXTERNAL MODULE: ./.docusaurus/docusaurus.config.mjs
var docusaurus_config = __webpack_require__(4784);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/prism-include-languages.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 
function prismIncludeLanguages(PrismObject) {
    const { themeConfig: { prism } } = docusaurus_config/* ["default"] */.A;
    const { additionalLanguages } = prism;
    // Prism components work on the Prism instance on the window, while prism-
    // react-renderer uses its own Prism instance. We temporarily mount the
    // instance onto window, import components to enhance it, then remove it to
    // avoid polluting global namespace.
    // You can mutate PrismObject: registering plugins, deleting languages... As
    // long as you don't re-assign it
    const PrismBefore = globalThis.Prism;
    globalThis.Prism = PrismObject;
    additionalLanguages.forEach((lang)=>{
        if (lang === 'php') {
            // eslint-disable-next-line global-require
            __webpack_require__(19700);
        }
        // eslint-disable-next-line global-require, import/no-dynamic-require
        __webpack_require__(75166)(`./prism-${lang}`);
    });
    // Clean up and eventually restore former globalThis.Prism object (if any)
    delete globalThis.Prism;
    if (typeof PrismBefore !== 'undefined') {
        globalThis.Prism = PrismObject;
    }
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/prism-include-languages.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

prismIncludeLanguages(dist/* .Prism */.My);


}),
72072: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (Heading)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var clsx__rspack_import_6 = __webpack_require__(34164);
/* import */ var _docusaurus_Translate__rspack_import_2 = __webpack_require__(30568);
/* import */ var _docusaurus_theme_common__rspack_import_5 = __webpack_require__(34727);
/* import */ var _docusaurus_Link__rspack_import_3 = __webpack_require__(95310);
/* import */ var _docusaurus_useBrokenLinks__rspack_import_4 = __webpack_require__(55916);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 







function Heading({ as: As, id, ...props }) {
    const brokenLinks = (0,_docusaurus_useBrokenLinks__rspack_import_4/* ["default"] */.A)();
    const anchorTargetClassName = (0,_docusaurus_theme_common__rspack_import_5/* .useAnchorTargetClassName */.v)(id);
    // H1 headings do not need an id because they don't appear in the TOC.
    if (As === 'h1' || !id) {
        return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(As, {
            ...props,
            id: undefined
        });
    }
    brokenLinks.collectAnchor(id);
    const anchorTitle = (0,_docusaurus_Translate__rspack_import_2/* .translate */.T)({
        id: 'theme.common.headingLinkTitle',
        message: 'Direct link to {heading}',
        description: 'Title for link to heading'
    }, {
        heading: typeof props.children === 'string' ? props.children : id
    });
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsxs)(As, {
        ...props,
        className: (0,clsx__rspack_import_6/* ["default"] */.A)('anchor', anchorTargetClassName, props.className),
        id: id,
        children: [
            props.children,
            /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(_docusaurus_Link__rspack_import_3/* ["default"] */.A, {
                className: "hash-link",
                to: `#${id}`,
                "aria-label": anchorTitle,
                title: anchorTitle,
                translate: "no",
                children: "​"
            })
        ]
    });
}


}),
37715: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ IconExternalLink)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(74848);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/Translate.js + 1 modules
var Translate = __webpack_require__(30568);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Icon/ExternalLink/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const styles_module = ({"iconExternalLink":"iconExternalLink_nPIU"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Icon/ExternalLink/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



// References symbol in docusaurus-theme-classic/src/inlineSvgSprites.ts
// See why: https://github.com/facebook/docusaurus/issues/5865
const svgSprite = '#theme-svg-external-link';
function IconExternalLink({ width = 13.5, height = 13.5 }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("svg", {
        width: width,
        height: height,
        "aria-label": (0,Translate/* .translate */.T)({
            id: 'theme.IconExternalLink.ariaLabel',
            message: '(opens in new tab)',
            description: 'The ARIA label for the external link icon'
        }),
        className: styles_module.iconExternalLink,
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)("use", {
            href: svgSprite
        })
    });
}


}),
16099: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ Layout)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(74848);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/clsx/dist/clsx.mjs
var clsx = __webpack_require__(34164);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/ErrorBoundary.js + 1 modules
var ErrorBoundary = __webpack_require__(11701);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/metadataUtils.js
var metadataUtils = __webpack_require__(34308);
// EXTERNAL MODULE: ./node_modules/react-router/esm/react-router.js
var react_router = __webpack_require__(56347);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/Translate.js + 1 modules
var Translate = __webpack_require__(30568);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/useLocationChange.js
var useLocationChange = __webpack_require__(98398);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/skipToContentUtils.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




/**
 * The id of the element that should become focused on a page
 * that does not have a <main> html tag.
 * Focusing the Docusaurus Layout children is a reasonable fallback.
 *
 * __ prefix allows search crawlers (Algolia/DocSearch) to ignore anchors
 * https://github.com/facebook/docusaurus/issues/8883#issuecomment-1516328368
 */ const SkipToContentFallbackId = '__docusaurus_skipToContent_fallback';
/**
 * Returns the skip to content element to focus when the link is clicked.
 */ function getSkipToContentTarget() {
    return(// Try to focus the <main> in priority
    // Note: this will only work if JS is enabled
    // See https://github.com/facebook/docusaurus/issues/6411#issuecomment-1284136069
    document.querySelector('main:first-of-type') ?? // Then try to focus the fallback element (usually the Layout children)
    document.getElementById(SkipToContentFallbackId));
}
function programmaticFocus(el) {
    el.setAttribute('tabindex', '-1');
    el.focus();
    el.removeAttribute('tabindex');
}
/** This hook wires the logic for a skip-to-content link. */ function useSkipToContent() {
    const containerRef = (0,react.useRef)(null);
    const { action } = (0,react_router/* .useHistory */.W6)();
    const onClick = (0,react.useCallback)((e)=>{
        e.preventDefault();
        const targetElement = getSkipToContentTarget();
        if (targetElement) {
            programmaticFocus(targetElement);
        }
    }, []);
    // "Reset" focus when navigating.
    // See https://github.com/facebook/docusaurus/pull/8204#issuecomment-1276547558
    (0,useLocationChange/* .useLocationChange */.$)(({ location })=>{
        if (containerRef.current && !location.hash && action === 'PUSH') {
            programmaticFocus(containerRef.current);
        }
    });
    return {
        containerRef,
        onClick
    };
}
const DefaultSkipToContentLabel = (0,Translate/* .translate */.T)({
    id: 'theme.common.skipToMainContent',
    description: 'The skip to content label used for accessibility, allowing to rapidly navigate to main content with keyboard tab/enter navigation',
    message: 'Skip to main content'
});
function SkipToContentLink(props) {
    const linkLabel = props.children ?? DefaultSkipToContentLabel;
    const { containerRef, onClick } = useSkipToContent();
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
        ref: containerRef,
        role: "region",
        "aria-label": DefaultSkipToContentLabel,
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)("a", {
            ...props,
            // Note this is a fallback href in case JS is disabled
            // It has limitations, see https://github.com/facebook/docusaurus/issues/6411#issuecomment-1284136069
            href: `#${SkipToContentFallbackId}`,
            onClick: onClick,
            children: linkLabel
        })
    });
} //# sourceMappingURL=skipToContentUtils.js.map

// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/ThemeClassNames.js
var ThemeClassNames = __webpack_require__(88287);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/hooks/useKeyboardNavigation.js + 1 modules
var useKeyboardNavigation = __webpack_require__(23433);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/SkipToContent/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const styles_module = ({"skipToContent":"skipToContent_fXgn"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/SkipToContent/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



function SkipToContent() {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(SkipToContentLink, {
        className: styles_module.skipToContent
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/useThemeConfig.js
var useThemeConfig = __webpack_require__(61022);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/contexts/announcementBar.js
var contexts_announcementBar = __webpack_require__(63337);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Icon/Close/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

function IconClose({ width = 21, height = 21, color = 'currentColor', strokeWidth = 1.2, className, ...restProps }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("svg", {
        viewBox: "0 0 15 15",
        width: width,
        height: height,
        ...restProps,
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)("g", {
            stroke: color,
            strokeWidth: strokeWidth,
            children: /*#__PURE__*/ (0,jsx_runtime.jsx)("path", {
                d: "M.75.75l13.5 13.5M14.25.75L.75 14.25"
            })
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/AnnouncementBar/CloseButton/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const CloseButton_styles_module = ({"closeButton":"closeButton_CVFx"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/AnnouncementBar/CloseButton/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 





function AnnouncementBarCloseButton(props) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("button", {
        type: "button",
        "aria-label": (0,Translate/* .translate */.T)({
            id: 'theme.AnnouncementBar.closeButtonAriaLabel',
            message: 'Close',
            description: 'The ARIA label for close button of announcement bar'
        }),
        ...props,
        className: (0,clsx/* ["default"] */.A)('clean-btn close', CloseButton_styles_module.closeButton, props.className),
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(IconClose, {
            width: 14,
            height: 14,
            strokeWidth: 3.1
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/AnnouncementBar/Content/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const Content_styles_module = ({"content":"content_knG7"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/AnnouncementBar/Content/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




function AnnouncementBarContent(props) {
    const { announcementBar } = (0,useThemeConfig/* .useThemeConfig */.p)();
    const { content } = announcementBar;
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
        ...props,
        className: (0,clsx/* ["default"] */.A)(Content_styles_module.content, props.className),
        // Developer provided the HTML, so assume it's safe.
        // eslint-disable-next-line react/no-danger
        dangerouslySetInnerHTML: {
            __html: content
        }
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/AnnouncementBar/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const AnnouncementBar_styles_module = ({"announcementBar":"announcementBar_mb4j","announcementBarPlaceholder":"announcementBarPlaceholder_vyr4","announcementBarClose":"announcementBarClose_gvF7","announcementBarContent":"announcementBarContent_xLdY"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/AnnouncementBar/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 







function AnnouncementBar() {
    const { announcementBar } = (0,useThemeConfig/* .useThemeConfig */.p)();
    const { isActive, close } = (0,contexts_announcementBar/* .useAnnouncementBar */.M)();
    if (!isActive) {
        return null;
    }
    const { backgroundColor, textColor, isCloseable } = announcementBar;
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
        className: (0,clsx/* ["default"] */.A)(ThemeClassNames/* .ThemeClassNames.announcementBar.container */.G.announcementBar.container, AnnouncementBar_styles_module.announcementBar),
        style: {
            backgroundColor,
            color: textColor
        },
        role: "banner",
        children: [
            isCloseable && /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
                className: AnnouncementBar_styles_module.announcementBarPlaceholder
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(AnnouncementBarContent, {
                className: AnnouncementBar_styles_module.announcementBarContent
            }),
            isCloseable && /*#__PURE__*/ (0,jsx_runtime.jsx)(AnnouncementBarCloseButton, {
                onClick: close,
                className: AnnouncementBar_styles_module.announcementBarClose
            })
        ]
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/contexts/navbarMobileSidebar.js
var navbarMobileSidebar = __webpack_require__(29965);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/scrollUtils.js
var scrollUtils = __webpack_require__(28584);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/hooks/useHideableNavbar.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


/**
 * Wires the imperative logic of a hideable navbar.
 * @param hideOnScroll If `false`, this hook is basically a no-op.
 */ function useHideableNavbar(hideOnScroll) {
    const [isNavbarVisible, setIsNavbarVisible] = (0,react.useState)(hideOnScroll);
    const isFocusedAnchor = (0,react.useRef)(false);
    const navbarHeight = (0,react.useRef)(0);
    const navbarRef = (0,react.useCallback)((node)=>{
        if (node !== null) {
            navbarHeight.current = node.getBoundingClientRect().height;
        }
    }, []);
    (0,scrollUtils/* .useScrollPosition */.Mq)(({ scrollY: scrollTop }, lastPosition)=>{
        if (!hideOnScroll) {
            return;
        }
        // Needed mostly for handling rubber band scrolling.
        // See https://github.com/facebook/docusaurus/pull/5721
        if (scrollTop < navbarHeight.current) {
            setIsNavbarVisible(true);
            return;
        }
        if (isFocusedAnchor.current) {
            isFocusedAnchor.current = false;
            return;
        }
        const lastScrollTop = lastPosition?.scrollY;
        const documentHeight = document.documentElement.scrollHeight - navbarHeight.current;
        const windowHeight = window.innerHeight;
        if (lastScrollTop && scrollTop >= lastScrollTop) {
            setIsNavbarVisible(false);
        } else if (scrollTop + windowHeight < documentHeight) {
            setIsNavbarVisible(true);
        }
    });
    (0,useLocationChange/* .useLocationChange */.$)((locationChangeEvent)=>{
        if (!hideOnScroll) {
            return;
        }
        // See https://github.com/facebook/docusaurus/pull/8059#issuecomment-1239639480
        const currentHash = locationChangeEvent.location.hash;
        const currentHashAnchor = currentHash ? document.getElementById(currentHash.substring(1)) : undefined;
        if (currentHashAnchor) {
            isFocusedAnchor.current = true;
            setIsNavbarVisible(false);
            return;
        }
        setIsNavbarVisible(true);
    });
    return {
        navbarRef,
        isNavbarVisible
    };
} //# sourceMappingURL=useHideableNavbar.js.map

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/hooks/useLockBodyScroll.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 
/**
 * Side-effect that locks the document body's scroll throughout the lifetime of
 * the containing component. e.g. when the mobile sidebar is expanded.
 */ function useLockBodyScroll(lock = true) {
    (0,react.useEffect)(()=>{
        document.body.style.overflow = lock ? 'hidden' : 'visible';
        return ()=>{
            document.body.style.overflow = 'visible';
        };
    }, [
        lock
    ]);
} //# sourceMappingURL=useLockBodyScroll.js.map

// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/reactUtils.js
var reactUtils = __webpack_require__(52260);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/contexts/navbarSecondaryMenu/content.js
var navbarSecondaryMenu_content = __webpack_require__(17000);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/contexts/navbarSecondaryMenu/display.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




const Context = /*#__PURE__*/ react.createContext(null);
function useContextValue() {
    const mobileSidebar = (0,navbarMobileSidebar/* .useNavbarMobileSidebar */.M)();
    const content = (0,navbarSecondaryMenu_content/* .useNavbarSecondaryMenuContent */.YL)();
    const [shown, setShown] = (0,react.useState)(false);
    const hasContent = content.component !== null;
    const previousHasContent = (0,reactUtils/* .usePrevious */.ZC)(hasContent);
    // When content is become available for the first time (set in useEffect)
    // we set this content to be shown!
    (0,react.useEffect)(()=>{
        const contentBecameAvailable = hasContent && !previousHasContent;
        if (contentBecameAvailable) {
            setShown(true);
        }
    }, [
        hasContent,
        previousHasContent
    ]);
    // On sidebar close, secondary menu is set to be shown on next re-opening
    // (if any secondary menu content available)
    (0,react.useEffect)(()=>{
        if (!hasContent) {
            setShown(false);
            return;
        }
        if (!mobileSidebar.shown) {
            setShown(true);
        }
    }, [
        mobileSidebar.shown,
        hasContent
    ]);
    return (0,react.useMemo)(()=>[
            shown,
            setShown
        ], [
        shown
    ]);
}
/** @internal */ function NavbarSecondaryMenuDisplayProvider({ children }) {
    const value = useContextValue();
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(Context.Provider, {
        value: value,
        children: children
    });
}
function renderElement(content) {
    if (content.component) {
        const Comp = content.component;
        return /*#__PURE__*/ (0,jsx_runtime.jsx)(Comp, {
            ...content.props
        });
    }
    return undefined;
}
/** Wires the logic for rendering the mobile navbar secondary menu. */ function useNavbarSecondaryMenu() {
    const value = (0,react.useContext)(Context);
    if (!value) {
        throw new reactUtils/* .ReactContextError */.dV('NavbarSecondaryMenuDisplayProvider');
    }
    const [shown, setShown] = value;
    const hide = (0,react.useCallback)(()=>setShown(false), [
        setShown
    ]);
    const content = (0,navbarSecondaryMenu_content/* .useNavbarSecondaryMenuContent */.YL)();
    return (0,react.useMemo)(()=>({
            shown,
            hide,
            content: renderElement(content)
        }), [
        hide,
        content,
        shown
    ]);
} //# sourceMappingURL=display.js.map

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/MobileSidebar/Layout/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




// TODO Docusaurus v4: remove temporary inert workaround
//  See https://github.com/facebook/react/issues/17157
//  See https://github.com/radix-ui/themes/pull/509
function inertProps(inert) {
    const isBeforeReact19 = parseInt(react.version.split('.')[0], 10) < 19;
    if (isBeforeReact19) {
        return {
            inert: inert ? '' : undefined
        };
    }
    return {
        inert
    };
}
function NavbarMobileSidebarPanel({ children, inert }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
        className: (0,clsx/* ["default"] */.A)(ThemeClassNames/* .ThemeClassNames.layout.navbar.mobileSidebar.panel */.G.layout.navbar.mobileSidebar.panel, 'navbar-sidebar__item menu'),
        ...inertProps(inert),
        children: children
    });
}
function NavbarMobileSidebarLayout({ header, primaryMenu, secondaryMenu }) {
    const { shown: secondaryMenuShown } = useNavbarSecondaryMenu();
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
        className: (0,clsx/* ["default"] */.A)(ThemeClassNames/* .ThemeClassNames.layout.navbar.mobileSidebar.container */.G.layout.navbar.mobileSidebar.container, 'navbar-sidebar'),
        children: [
            header,
            /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
                className: (0,clsx/* ["default"] */.A)('navbar-sidebar__items', {
                    'navbar-sidebar__items--show-secondary': secondaryMenuShown
                }),
                children: [
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarMobileSidebarPanel, {
                        inert: secondaryMenuShown,
                        children: primaryMenu
                    }),
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarMobileSidebarPanel, {
                        inert: !secondaryMenuShown,
                        children: secondaryMenu
                    })
                ]
            })
        ]
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/contexts/colorMode.js
var contexts_colorMode = __webpack_require__(83941);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/useIsBrowser.js
var useIsBrowser = __webpack_require__(19863);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Icon/LightMode/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

function IconLightMode(props) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("svg", {
        viewBox: "0 0 24 24",
        width: 24,
        height: 24,
        ...props,
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)("path", {
            fill: "currentColor",
            d: "M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Icon/DarkMode/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

function IconDarkMode(props) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("svg", {
        viewBox: "0 0 24 24",
        width: 24,
        height: 24,
        ...props,
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)("path", {
            fill: "currentColor",
            d: "M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Icon/SystemColorMode/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 
function IconSystemColorMode(props) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("svg", {
        viewBox: "0 0 24 24",
        width: 24,
        height: 24,
        ...props,
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)("path", {
            fill: "currentColor",
            d: "m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/ColorModeToggle/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const ColorModeToggle_styles_module = ({"toggle":"toggle_vylO","toggleButton":"toggleButton_gllP","toggleIcon":"toggleIcon_g3eP","systemToggleIcon":"systemToggleIcon_QzmC","lightToggleIcon":"lightToggleIcon_pyhR","darkToggleIcon":"darkToggleIcon_wfgR","toggleButtonDisabled":"toggleButtonDisabled_aARS"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/ColorModeToggle/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 








// The order of color modes is defined here, and can be customized with swizzle
function getNextColorMode(colorMode, respectPrefersColorScheme) {
    // 2-value transition
    if (!respectPrefersColorScheme) {
        return colorMode === 'dark' ? 'light' : 'dark';
    }
    // 3-value transition
    switch(colorMode){
        case null:
            return 'light';
        case 'light':
            return 'dark';
        case 'dark':
            return null;
        default:
            throw new Error(`unexpected color mode ${colorMode}`);
    }
}
function getColorModeLabel(colorMode) {
    switch(colorMode){
        case null:
            return (0,Translate/* .translate */.T)({
                message: 'system mode',
                id: 'theme.colorToggle.ariaLabel.mode.system',
                description: 'The name for the system color mode'
            });
        case 'light':
            return (0,Translate/* .translate */.T)({
                message: 'light mode',
                id: 'theme.colorToggle.ariaLabel.mode.light',
                description: 'The name for the light color mode'
            });
        case 'dark':
            return (0,Translate/* .translate */.T)({
                message: 'dark mode',
                id: 'theme.colorToggle.ariaLabel.mode.dark',
                description: 'The name for the dark color mode'
            });
        default:
            throw new Error(`unexpected color mode ${colorMode}`);
    }
}
function getColorModeAriaLabel(colorMode) {
    return (0,Translate/* .translate */.T)({
        message: 'Switch between dark and light mode (currently {mode})',
        id: 'theme.colorToggle.ariaLabel',
        description: 'The ARIA label for the color mode toggle'
    }, {
        mode: getColorModeLabel(colorMode)
    });
}
function CurrentColorModeIcon() {
    // 3 icons are always rendered for technical reasons
    // We use "data-theme-choice" to render the correct one
    // This must work even before React hydrates
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsx)(IconLightMode, {
                // a18y is handled at the button level,
                // not relying on button content (svg icons)
                "aria-hidden": true,
                className: (0,clsx/* ["default"] */.A)(ColorModeToggle_styles_module.toggleIcon, ColorModeToggle_styles_module.lightToggleIcon)
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(IconDarkMode, {
                "aria-hidden": true,
                className: (0,clsx/* ["default"] */.A)(ColorModeToggle_styles_module.toggleIcon, ColorModeToggle_styles_module.darkToggleIcon)
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(IconSystemColorMode, {
                "aria-hidden": true,
                className: (0,clsx/* ["default"] */.A)(ColorModeToggle_styles_module.toggleIcon, ColorModeToggle_styles_module.systemToggleIcon)
            })
        ]
    });
}
function ColorModeToggle({ className, buttonClassName, respectPrefersColorScheme, value, onChange }) {
    const isBrowser = (0,useIsBrowser/* ["default"] */.A)();
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
        className: (0,clsx/* ["default"] */.A)(ColorModeToggle_styles_module.toggle, className),
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)("button", {
            className: (0,clsx/* ["default"] */.A)('clean-btn', ColorModeToggle_styles_module.toggleButton, !isBrowser && ColorModeToggle_styles_module.toggleButtonDisabled, buttonClassName),
            type: "button",
            onClick: ()=>onChange(getNextColorMode(value, respectPrefersColorScheme)),
            disabled: !isBrowser,
            title: getColorModeLabel(value),
            "aria-label": getColorModeAriaLabel(value),
            children: /*#__PURE__*/ (0,jsx_runtime.jsx)(CurrentColorModeIcon, {})
        })
    });
}
/* export default */ const theme_ColorModeToggle = (/*#__PURE__*/react.memo(ColorModeToggle));

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/ColorModeToggle/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const Navbar_ColorModeToggle_styles_module = ({"darkNavbarColorModeToggle":"darkNavbarColorModeToggle_X3D1"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/ColorModeToggle/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




function NavbarColorModeToggle({ className }) {
    const navbarStyle = (0,useThemeConfig/* .useThemeConfig */.p)().navbar.style;
    const { disableSwitch, respectPrefersColorScheme } = (0,useThemeConfig/* .useThemeConfig */.p)().colorMode;
    const { colorModeChoice, setColorMode } = (0,contexts_colorMode/* .useColorMode */.G)();
    if (disableSwitch) {
        return null;
    }
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(theme_ColorModeToggle, {
        className: className,
        buttonClassName: navbarStyle === 'dark' ? Navbar_ColorModeToggle_styles_module.darkNavbarColorModeToggle : undefined,
        respectPrefersColorScheme: respectPrefersColorScheme,
        value: colorModeChoice,
        onChange: setColorMode
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Logo/index.js
var Logo = __webpack_require__(85153);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/Logo/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


function NavbarLogo() {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(Logo/* ["default"] */.A, {
        className: "navbar__brand",
        imageClassName: "navbar__logo",
        titleClassName: "navbar__title text--truncate"
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/MobileSidebar/Header/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 






function CloseButton() {
    const mobileSidebar = (0,navbarMobileSidebar/* .useNavbarMobileSidebar */.M)();
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("button", {
        type: "button",
        "aria-label": (0,Translate/* .translate */.T)({
            id: 'theme.docs.sidebar.closeSidebarButtonAriaLabel',
            message: 'Close navigation bar',
            description: 'The ARIA label for close button of mobile sidebar'
        }),
        className: "clean-btn navbar-sidebar__close",
        onClick: ()=>mobileSidebar.toggle(),
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(IconClose, {
            color: "var(--ifm-color-emphasis-600)"
        })
    });
}
function NavbarMobileSidebarHeader() {
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
        className: "navbar-sidebar__brand",
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarLogo, {}),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarColorModeToggle, {
                className: "margin-right--md"
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(CloseButton, {})
        ]
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/Link.js
var Link = __webpack_require__(95310);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/useBaseUrl.js
var useBaseUrl = __webpack_require__(66497);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/isInternalUrl.js
var isInternalUrl = __webpack_require__(58310);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/regexpUtils.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ /**
 * Matches a string regex (as provided from the config) against a target in a
 * null-safe fashion, case insensitive and global.
 */ function isRegexpStringMatch(regexAsString, valueToTest) {
    if (typeof regexAsString === 'undefined' || typeof valueToTest === 'undefined') {
        return false;
    }
    return new RegExp(regexAsString, 'gi').test(valueToTest);
} //# sourceMappingURL=regexpUtils.js.map

// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Icon/ExternalLink/index.js + 1 modules
var ExternalLink = __webpack_require__(37715);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/NavbarNavLink.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 






function NavbarNavLink({ activeBasePath, activeBaseRegex, to, href, label, html, isDropdownLink, prependBaseUrlToHref, ...props }) {
    // TODO all this seems hacky
    // {to: 'version'} should probably be forbidden, in favor of {to: '/version'}
    const toUrl = (0,useBaseUrl/* ["default"] */.Ay)(to);
    const activeBaseUrl = (0,useBaseUrl/* ["default"] */.Ay)(activeBasePath);
    const normalizedHref = (0,useBaseUrl/* ["default"] */.Ay)(href, {
        forcePrependBaseUrl: true
    });
    const isExternalLink = label && href && !(0,isInternalUrl/* ["default"] */.A)(href);
    // Link content is set through html XOR label
    const linkContentProps = html ? {
        dangerouslySetInnerHTML: {
            __html: html
        }
    } : {
        children: /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
            children: [
                label,
                isExternalLink && /*#__PURE__*/ (0,jsx_runtime.jsx)(ExternalLink/* ["default"] */.A, {
                    ...isDropdownLink && {
                        width: 12,
                        height: 12
                    }
                })
            ]
        })
    };
    if (href) {
        return /*#__PURE__*/ (0,jsx_runtime.jsx)(Link/* ["default"] */.A, {
            href: prependBaseUrlToHref ? normalizedHref : href,
            ...props,
            ...linkContentProps
        });
    }
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(Link/* ["default"] */.A, {
        to: toUrl,
        isNavLink: true,
        ...(activeBasePath || activeBaseRegex) && {
            isActive: (_match, location)=>activeBaseRegex ? isRegexpStringMatch(activeBaseRegex, location.pathname) : location.pathname.startsWith(activeBaseUrl)
        },
        ...props,
        ...linkContentProps
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/DefaultNavbarItem/Mobile/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



function DefaultNavbarItemMobile({ className, isDropdownItem, ...props }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("li", {
        className: "menu__list-item",
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarNavLink, {
            className: (0,clsx/* ["default"] */.A)('menu__link', className),
            ...props
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/DefaultNavbarItem/Desktop/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



function DefaultNavbarItemDesktop({ className, isDropdownItem = false, ...props }) {
    const element = /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarNavLink, {
        className: (0,clsx/* ["default"] */.A)(isDropdownItem ? 'dropdown__link' : 'navbar__item navbar__link', className),
        isDropdownLink: isDropdownItem,
        ...props
    });
    if (isDropdownItem) {
        return /*#__PURE__*/ (0,jsx_runtime.jsx)("li", {
            children: element
        });
    }
    return element;
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/DefaultNavbarItem/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



function DefaultNavbarItem({ mobile = false, position, ...props }) {
    const Comp = mobile ? DefaultNavbarItemMobile : DefaultNavbarItemDesktop;
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(Comp, {
        ...props,
        activeClassName: props.activeClassName ?? (mobile ? 'menu__link--active' : 'navbar__link--active')
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/components/Collapsible/index.js
var Collapsible = __webpack_require__(39510);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/routesUtils.js
var routesUtils = __webpack_require__(19209);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/useDocusaurusContext.js
var exports_useDocusaurusContext = __webpack_require__(10898);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/useLocalPathname.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

/**
 * Get the pathname of current route, without the optional site baseUrl.
 * - `/docs/myDoc` => `/docs/myDoc`
 * - `/baseUrl/docs/myDoc` => `/docs/myDoc`
 */ function useLocalPathname() {
    const { siteConfig: { baseUrl } } = (0,exports_useDocusaurusContext/* ["default"] */.A)();
    const { pathname } = (0,react_router/* .useLocation */.zy)();
    return pathname.replace(baseUrl, '/');
} //# sourceMappingURL=useLocalPathname.js.map

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/DropdownNavbarItem/Mobile/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const Mobile_styles_module = ({"dropdownNavbarItemMobile":"dropdownNavbarItemMobile_J0Sd"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/DropdownNavbarItem/Mobile/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 









function isItemActive(item, localPathname) {
    if ((0,routesUtils/* .isSamePath */.ys)(item.to, localPathname)) {
        return true;
    }
    if (isRegexpStringMatch(item.activeBaseRegex, localPathname)) {
        return true;
    }
    if (item.activeBasePath && localPathname.startsWith(item.activeBasePath)) {
        return true;
    }
    return false;
}
function containsActiveItems(items, localPathname) {
    return items.some((item)=>isItemActive(item, localPathname));
}
function CollapseButton({ collapsed, onClick }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("button", {
        "aria-label": collapsed ? (0,Translate/* .translate */.T)({
            id: 'theme.navbar.mobileDropdown.collapseButton.expandAriaLabel',
            message: 'Expand the dropdown',
            description: 'The ARIA label of the button to expand the mobile dropdown navbar item'
        }) : (0,Translate/* .translate */.T)({
            id: 'theme.navbar.mobileDropdown.collapseButton.collapseAriaLabel',
            message: 'Collapse the dropdown',
            description: 'The ARIA label of the button to collapse the mobile dropdown navbar item'
        }),
        "aria-expanded": !collapsed,
        type: "button",
        className: "clean-btn menu__caret",
        onClick: onClick
    });
}
function useItemCollapsible({ active }) {
    const { collapsed, toggleCollapsed, setCollapsed } = (0,Collapsible/* .useCollapsible */.u)({
        initialState: ()=>!active
    });
    // Expand if any item active after a navigation
    (0,react.useEffect)(()=>{
        if (active) {
            setCollapsed(false);
        }
    }, [
        active,
        setCollapsed
    ]);
    return {
        collapsed,
        toggleCollapsed
    };
}
function DropdownNavbarItemMobile({ items, className, position, onClick, ...props }) {
    const localPathname = useLocalPathname();
    const isActive = (0,routesUtils/* .isSamePath */.ys)(props.to, localPathname);
    const containsActive = containsActiveItems(items, localPathname);
    const { collapsed, toggleCollapsed } = useItemCollapsible({
        active: isActive || containsActive
    });
    // # hash permits to make the <a> tag focusable in case no link target
    // See https://github.com/facebook/docusaurus/pull/6003
    // There's probably a better solution though...
    const href = props.to ? undefined : '#';
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)("li", {
        className: (0,clsx/* ["default"] */.A)('menu__list-item', {
            'menu__list-item--collapsed': collapsed
        }),
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
                className: (0,clsx/* ["default"] */.A)('menu__list-item-collapsible', {
                    'menu__list-item-collapsible--active': isActive
                }),
                children: [
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarNavLink, {
                        role: "button",
                        className: (0,clsx/* ["default"] */.A)(Mobile_styles_module.dropdownNavbarItemMobile, 'menu__link menu__link--sublist', className),
                        href: href,
                        ...props,
                        onClick: (e)=>{
                            // Prevent navigation when link is "#"
                            if (href === '#') {
                                e.preventDefault();
                            }
                            // Otherwise we let navigation eventually happen, and/or collapse
                            toggleCollapsed();
                        },
                        children: props.children ?? props.label
                    }),
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(CollapseButton, {
                        collapsed: collapsed,
                        onClick: (e)=>{
                            e.preventDefault();
                            toggleCollapsed();
                        }
                    })
                ]
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(Collapsible/* .Collapsible */.N, {
                lazy: true,
                as: "ul",
                className: "menu__list",
                collapsed: collapsed,
                children: items.map((childItemProps, i)=>/*#__PURE__*/ (0,react.createElement)(NavbarItem, {
                        mobile: true,
                        isDropdownItem: true,
                        onClick: onClick,
                        activeClassName: "menu__link--active",
                        ...childItemProps,
                        key: i
                    }))
            })
        ]
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/DropdownNavbarItem/Desktop/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 





function DropdownNavbarItemDesktop({ items, position, className, onClick, ...props }) {
    const dropdownRef = (0,react.useRef)(null);
    const [showDropdown, setShowDropdown] = (0,react.useState)(false);
    (0,react.useEffect)(()=>{
        const handleClickOutside = (event)=>{
            if (!dropdownRef.current || dropdownRef.current.contains(event.target)) {
                return;
            }
            setShowDropdown(false);
        };
        document.addEventListener('mousedown', handleClickOutside);
        document.addEventListener('touchstart', handleClickOutside);
        document.addEventListener('focusin', handleClickOutside);
        return ()=>{
            document.removeEventListener('mousedown', handleClickOutside);
            document.removeEventListener('touchstart', handleClickOutside);
            document.removeEventListener('focusin', handleClickOutside);
        };
    }, [
        dropdownRef
    ]);
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
        ref: dropdownRef,
        className: (0,clsx/* ["default"] */.A)('navbar__item', 'dropdown', 'dropdown--hoverable', {
            'dropdown--right': position === 'right',
            'dropdown--show': showDropdown
        }),
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarNavLink, {
                "aria-haspopup": "true",
                "aria-expanded": showDropdown,
                role: "button",
                // # hash permits to make the <a> tag focusable in case no link target
                // See https://github.com/facebook/docusaurus/pull/6003
                // There's probably a better solution though...
                href: props.to ? undefined : '#',
                className: (0,clsx/* ["default"] */.A)('navbar__link', className),
                ...props,
                onClick: props.to ? undefined : (e)=>e.preventDefault(),
                onKeyDown: (e)=>{
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        setShowDropdown(!showDropdown);
                    }
                },
                children: props.children ?? props.label
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)("ul", {
                className: "dropdown__menu",
                children: items.map((childItemProps, i)=>/*#__PURE__*/ (0,react.createElement)(NavbarItem, {
                        isDropdownItem: true,
                        activeClassName: "dropdown__link--active",
                        ...childItemProps,
                        key: i
                    }))
            })
        ]
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/DropdownNavbarItem/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



function DropdownNavbarItem({ mobile = false, ...props }) {
    const Comp = mobile ? DropdownNavbarItemMobile : DropdownNavbarItemDesktop;
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(Comp, {
        ...props
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/useAlternatePageUtils.js
var useAlternatePageUtils = __webpack_require__(5243);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/historyUtils.js
var historyUtils = __webpack_require__(96629);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Icon/Language/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

function IconLanguage({ width = 20, height = 20, ...props }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("svg", {
        viewBox: "0 0 24 24",
        width: width,
        height: height,
        "aria-hidden": true,
        ...props,
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)("path", {
            fill: "currentColor",
            d: "M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/LocaleDropdownNavbarItem/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const LocaleDropdownNavbarItem_styles_module = ({"iconLanguage":"iconLanguage_nlXk"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/LocaleDropdownNavbarItem/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 








function useLocaleDropdownUtils() {
    const { siteConfig, i18n: { localeConfigs } } = (0,exports_useDocusaurusContext/* ["default"] */.A)();
    const alternatePageUtils = (0,useAlternatePageUtils/* .useAlternatePageUtils */.o)();
    const search = (0,historyUtils/* .useHistorySelector */.Hl)((history)=>history.location.search);
    const hash = (0,historyUtils/* .useHistorySelector */.Hl)((history)=>history.location.hash);
    const getLocaleConfig = (locale)=>{
        const localeConfig = localeConfigs[locale];
        if (!localeConfig) {
            throw new Error(`Docusaurus bug, no locale config found for locale=${locale}`);
        }
        return localeConfig;
    };
    const getBaseURLForLocale = (locale)=>{
        const localeConfig = getLocaleConfig(locale);
        const isSameDomain = localeConfig.url === siteConfig.url;
        if (isSameDomain) {
            // Shorter paths if localized sites are hosted on the same domain
            // This reduces HTML size a bit
            return `pathname://${alternatePageUtils.createUrl({
                locale,
                fullyQualified: false
            })}`;
        }
        return alternatePageUtils.createUrl({
            locale,
            fullyQualified: true
        });
    };
    return {
        getURL: (locale, options)=>{
            // We have 2 query strings because
            // - there's the current one
            // - there's one user can provide through navbar config
            // see https://github.com/facebook/docusaurus/pull/8915
            const finalSearch = (0,historyUtils/* .mergeSearchStrings */.jy)([
                search,
                options.queryString
            ], 'append');
            return `${getBaseURLForLocale(locale)}${finalSearch}${hash}`;
        },
        getLabel: (locale)=>{
            return getLocaleConfig(locale).label;
        },
        getLang: (locale)=>{
            return getLocaleConfig(locale).htmlLang;
        }
    };
}
function LocaleDropdownNavbarItem({ mobile, dropdownItemsBefore, dropdownItemsAfter, queryString, ...props }) {
    const utils = useLocaleDropdownUtils();
    const { i18n: { currentLocale, locales } } = (0,exports_useDocusaurusContext/* ["default"] */.A)();
    const localeItems = locales.map((locale)=>{
        return {
            label: utils.getLabel(locale),
            lang: utils.getLang(locale),
            to: utils.getURL(locale, {
                queryString
            }),
            target: '_self',
            autoAddBaseUrl: false,
            className: // eslint-disable-next-line no-nested-ternary
            locale === currentLocale ? // class name. This cannot be substituted with isActive, because the
            // target URLs contain `pathname://` and therefore are not NavLinks!
            mobile ? 'menu__link--active' : 'dropdown__link--active' : ''
        };
    });
    const items = [
        ...dropdownItemsBefore,
        ...localeItems,
        ...dropdownItemsAfter
    ];
    // Mobile is handled a bit differently
    const dropdownLabel = mobile ? (0,Translate/* .translate */.T)({
        message: 'Languages',
        id: 'theme.navbar.mobileLanguageDropdown.label',
        description: 'The label for the mobile language switcher dropdown'
    }) : utils.getLabel(currentLocale);
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(DropdownNavbarItem, {
        ...props,
        mobile: mobile,
        label: /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
            children: [
                /*#__PURE__*/ (0,jsx_runtime.jsx)(IconLanguage, {
                    className: LocaleDropdownNavbarItem_styles_module.iconLanguage
                }),
                dropdownLabel
            ]
        }),
        items: items
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/BrowserOnly.js
var BrowserOnly = __webpack_require__(9526);
// EXTERNAL MODULE: ./node_modules/@docusaurus/plugin-content-docs/lib/client/index.js + 1 modules
var lib_client = __webpack_require__(88209);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/useGlobalData.js
var useGlobalData = __webpack_require__(99044);
;// CONCATENATED MODULE: ./node_modules/pako/dist/pako.esm.mjs

/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

/* Public constants ==========================================================*/
/* ===========================================================================*/


//const Z_FILTERED          = 1;
//const Z_HUFFMAN_ONLY      = 2;
//const Z_RLE               = 3;
const Z_FIXED$1               = 4;
//const Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
const Z_BINARY              = 0;
const Z_TEXT                = 1;
//const Z_ASCII             = 1; // = Z_TEXT
const Z_UNKNOWN$1             = 2;

/*============================================================================*/


function zero$1(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES    = 2;
/* The three kinds of block type */

const MIN_MATCH$1    = 3;
const MAX_MATCH$1    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

const LENGTH_CODES$1  = 29;
/* number of length codes, not counting the special END_BLOCK code */

const LITERALS$1      = 256;
/* number of literal bytes 0..255 */

const L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;
/* number of Literal or Length codes, including the END_BLOCK code */

const D_CODES$1       = 30;
/* number of distance codes */

const BL_CODES$1      = 19;
/* number of codes used to transfer the bit lengths */

const HEAP_SIZE$1     = 2 * L_CODES$1 + 1;
/* maximum heap size */

const MAX_BITS$1      = 15;
/* All codes must not exceed MAX_BITS bits */

const Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

const MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

const END_BLOCK   = 256;
/* end of block literal code */

const REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

const REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

const REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
const extra_lbits =   /* extra bits for each length code */
  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);

const extra_dbits =   /* extra bits for each distance code */
  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);

const extra_blbits =  /* extra bits for each bit length code */
  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);

const bl_order =
  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

const DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
const static_ltree  = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

const static_dtree  = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

const _dist_code    = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

const _length_code  = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

const base_length   = new Array(LENGTH_CODES$1);
zero$1(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

const base_dist     = new Array(D_CODES$1);
zero$1(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


let static_l_desc;
let static_d_desc;
let static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



const d_code = (dist) => {

  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
const put_short = (s, w) => {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
};


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
const send_bits = (s, value, length) => {

  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
};


const send_code = (s, c, tree) => {

  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
};


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
const bi_reverse = (code, len) => {

  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
const bi_flush = (s) => {

  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
const gen_bitlen = (s, desc) => {
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */

  const tree            = desc.dyn_tree;
  const max_code        = desc.max_code;
  const stree           = desc.stat_desc.static_tree;
  const has_stree       = desc.stat_desc.has_stree;
  const extra           = desc.stat_desc.extra_bits;
  const base            = desc.stat_desc.extra_base;
  const max_length      = desc.stat_desc.max_length;
  let h;              /* heap index */
  let n, m;           /* iterate over the tree elements */
  let bits;           /* bit length */
  let xbits;          /* extra bits */
  let f;              /* frequency */
  let overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Tracev((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Tracev((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
};


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
const gen_codes = (tree, max_code, bl_count) => {
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */

  const next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */
  let code = 0;              /* running code value */
  let bits;                  /* bit index */
  let n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code = (code + bl_count[bits - 1]) << 1;
    next_code[bits] = code;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    let len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
};


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
const tr_static_init = () => {

  let n;        /* iterates over tree elements */
  let bits;     /* bit counter */
  let length;   /* length value */
  let code;     /* code value */
  let dist;     /* distance index */
  const bl_count = new Array(MAX_BITS$1 + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES$1, MAX_BL_BITS);

  //static_init_done = true;
};


/* ===========================================================================
 * Initialize a new block.
 */
const init_block = (s) => {

  let n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES$1;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES$1;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES$1; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
const bi_windup = (s) =>
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
const smaller = (tree, n, m, depth) => {

  const _n2 = n * 2;
  const _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
};

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
const pqdownheap = (s, tree, k) => {
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */

  const v = s.heap[k];
  let j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
};


// inlined manually
// const SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
const compress_block = (s, ltree, dtree) => {
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */

  let dist;           /* distance of matched string */
  let lc;             /* match length or unmatched char (if dist == 0) */
  let sx = 0;         /* running index in sym_buf */
  let code;           /* the code to send */
  let extra;          /* number of extra bits to send */

  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 0xff;
      dist += (s.pending_buf[s.sym_buf + sx++] & 0xff) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and sym_buf is ok: */
      //Assert(s->pending < s->lit_bufsize + sx, "pendingBuf overflow");

    } while (sx < s.sym_next);
  }

  send_code(s, END_BLOCK, ltree);
};


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
const build_tree = (s, desc) => {
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */

  const tree     = desc.dyn_tree;
  const stree    = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems    = desc.stat_desc.elems;
  let n, m;          /* iterate over heap elements */
  let max_code = -1; /* largest code with non zero frequency */
  let node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
};


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
const scan_tree = (s, tree, max_code) => {
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */

  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
const send_tree = (s, tree, max_code) => {
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */

  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
const build_bl_tree = (s) => {

  let max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
};


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
const send_all_trees = (s, lcodes, dcodes, blcodes) => {
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */

  let rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
};


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "block list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "allow list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
const detect_data_type = (s) => {
  /* block_mask is the bit mask of block-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  let block_mask = 0xf3ffc07f;
  let n;

  /* Check for non-textual ("block-listed") bytes. */
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if ((block_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("allow-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "block-listed" or "allow-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
};


let static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
const _tr_init$1 = (s) =>
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
};


/* ===========================================================================
 * Send a stored block
 */
const _tr_stored_block$1 = (s, buf, stored_len, last) => {
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */

  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  bi_windup(s);        /* align on byte boundary */
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
const _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and write out the encoded block.
 */
const _tr_flush_block$1 = (s, buf, stored_len, last) => {
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */

  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  let max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->sym_next / 3));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block$1(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
};

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
const _tr_tally$1 = (s, dist, lc) => {
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */

  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

  return (s.sym_next === s.sym_end);
};

var _tr_init_1  = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1  = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;

var trees = {
	_tr_init: _tr_init_1,
	_tr_stored_block: _tr_stored_block_1,
	_tr_flush_block: _tr_flush_block_1,
	_tr_tally: _tr_tally_1,
	_tr_align: _tr_align_1
};

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const adler32 = (adler, buf, len, pos) => {
  let s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
};


var adler32_1 = adler32;

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
const makeTable = () => {
  let c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
};

// Create table on load. Just 255 signed longs. Not a problem.
const crcTable = new Uint32Array(makeTable());


const crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;

  crc ^= -1;

  for (let i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
};


var crc32_1 = crc32;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var messages = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var constants$2 = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  Z_MEM_ERROR:       -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;




/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;

/*============================================================================*/


const MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
const MAX_WBITS$1 = 15;
/* 32K LZ77 window */
const DEF_MEM_LEVEL = 8;


const LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
const LITERALS      = 256;
/* number of literal bytes 0..255 */
const L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
const D_CODES       = 30;
/* number of distance codes */
const BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
const HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
const MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

const PRESET_DICT = 0x20;

const INIT_STATE    =  42;    /* zlib header -> BUSY_STATE */
//#ifdef GZIP
const GZIP_STATE    =  57;    /* gzip header -> BUSY_STATE | EXTRA_STATE */
//#endif
const EXTRA_STATE   =  69;    /* gzip extra block -> NAME_STATE */
const NAME_STATE    =  73;    /* gzip file name -> COMMENT_STATE */
const COMMENT_STATE =  91;    /* gzip comment -> HCRC_STATE */
const HCRC_STATE    = 103;    /* gzip header CRC -> BUSY_STATE */
const BUSY_STATE    = 113;    /* deflate -> FINISH_STATE */
const FINISH_STATE  = 666;    /* stream complete */

const BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
const BS_BLOCK_DONE     = 2; /* block flush performed */
const BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
const BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

const OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

const pako_esm_err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};

const pako_esm_rank = (f) => {
  return ((f) * 2) - ((f) > 4 ? 9 : 0);
};

const zero = (buf) => {
  let len = buf.length; while (--len >= 0) { buf[len] = 0; }
};

/* ===========================================================================
 * Slide the hash table when sliding the window down (could be avoided with 32
 * bit values at the expense of memory usage). We slide even when level == 0 to
 * keep the hash table consistent if we switch back to level > 0 later.
 */
const slide_hash = (s) => {
  let n, m;
  let p;
  let wsize = s.w_size;

  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = (m >= wsize ? m - wsize : 0);
  } while (--n);
  n = wsize;
//#ifndef FASTEST
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = (m >= wsize ? m - wsize : 0);
    /* If n is not on any hash chain, prev[n] is garbage but
     * its value will never be used.
     */
  } while (--n);
//#endif
};

/* eslint-disable new-cap */
let HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;
// This hash causes less collisions, https://github.com/nodeca/pako/issues/135
// But breaks binary compatibility
//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;
let HASH = HASH_ZLIB;


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output, except for
 * some deflate_stored() output, goes through this function so some
 * applications may wish to modify it to avoid allocating a large
 * strm->next_out buffer and copying into it. (See also read_buf()).
 */
const flush_pending = (strm) => {
  const s = strm.state;

  //_tr_flush_bits(s);
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out  += len;
  s.pending_out  += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending      -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};


const flush_block_only = (s, last) => {
  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};


const put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
const putShortMSB = (s, b) => {

  //  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
};


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
const read_buf = (strm, buf, start, size) => {

  let len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
};


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
const longest_match = (s, cur_match) => {

  let chain_length = s.max_chain_length;      /* max hash chain length */
  let scan = s.strstart; /* current string */
  let match;                       /* matched string */
  let len;                           /* length of current match */
  let best_len = s.prev_length;              /* best match length so far */
  let nice_match = s.nice_match;             /* stop if match long enough */
  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  const _win = s.window; // shortcut

  const wmask = s.w_mask;
  const prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  const strend = s.strstart + MAX_MATCH;
  let scan_end1  = _win[scan + best_len - 1];
  let scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
const fill_window = (s) => {

  const _w_size = s.w_size;
  let n, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    const curr = s.strstart + s.lookahead;
//    let init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
};

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 *
 * In case deflateParams() is used to later switch to a non-zero compression
 * level, s->matches (otherwise unused when storing) keeps track of the number
 * of hash table slides to perform. If s->matches is 1, then one hash table
 * slide will be done when switching. If s->matches is 2, the maximum value
 * allowed here, then the hash table will be cleared, since two or more slides
 * is the same as a clear.
 *
 * deflate_stored() is written to minimize the number of times an input byte is
 * copied. It is most efficient with large input and output buffers, which
 * maximizes the opportunites to have a single copy from next_in to next_out.
 */
const deflate_stored = (s, flush) => {

  /* Smallest worthy block size when not flushing or finishing. By default
   * this is 32K. This can be as small as 507 bytes for memLevel == 1. For
   * large input and output buffers, the stored block size will be larger.
   */
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;

  /* Copy as many min_block or larger stored blocks directly to next_out as
   * possible. If flushing, copy the remaining available input to next_out as
   * stored blocks, if there is enough space.
   */
  let len, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    /* Set len to the maximum size block that we can copy directly with the
     * available input data and output space. Set left to how much of that
     * would be copied from what's left in the window.
     */
    len = 65535/* MAX_STORED */;     /* maximum deflate stored block length */
    have = (s.bi_valid + 42) >> 3;     /* number of header bytes */
    if (s.strm.avail_out < have) {         /* need room for header */
      break;
    }
      /* maximum stored block length that will fit in avail_out: */
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;  /* bytes left in window */
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;   /* limit len to the input */
    }
    if (len > have) {
      len = have;             /* limit len to the output */
    }

    /* If the stored block would be less than min_block in length, or if
     * unable to copy all of the available input when flushing, then try
     * copying to the window and the pending buffer instead. Also don't
     * write an empty block when flushing -- deflate() does that.
     */
    if (len < min_block && ((len === 0 && flush !== Z_FINISH$3) ||
                        flush === Z_NO_FLUSH$2 ||
                        len !== left + s.strm.avail_in)) {
      break;
    }

    /* Make a dummy stored block in pending to get the header bytes,
     * including any pending bits. This also updates the debugging counts.
     */
    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);

    /* Replace the lengths in the dummy stored block with len. */
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;

    /* Write the stored block header bytes. */
    flush_pending(s.strm);

//#ifdef ZLIB_DEBUG
//    /* Update debugging counts for the data about to be copied. */
//    s->compressed_len += len << 3;
//    s->bits_sent += len << 3;
//#endif

    /* Copy uncompressed bytes from the window to next_out. */
    if (left) {
      if (left > len) {
        left = len;
      }
      //zmemcpy(s->strm->next_out, s->window + s->block_start, left);
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }

    /* Copy uncompressed bytes directly from next_in to next_out, updating
     * the check value.
     */
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);

  /* Update the sliding window with the last s->w_size bytes of the copied
   * data, or append all of the copied data to the existing window if less
   * than s->w_size bytes were copied. Also update the number of bytes to
   * insert in the hash tables, in the event that deflateParams() switches to
   * a non-zero compression level.
   */
  used -= s.strm.avail_in;    /* number of input bytes directly copied */
  if (used) {
    /* If any input was used, then no unused input remains in the window,
     * therefore s->block_start == s->strstart.
     */
    if (used >= s.w_size) {  /* supplant the previous history */
      s.matches = 2;     /* clear hash */
      //zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    }
    else {
      if (s.window_size - s.strstart <= used) {
        /* Slide the window down. */
        s.strstart -= s.w_size;
        //zmemcpy(s->window, s->window + s->w_size, s->strstart);
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;   /* add a pending slide_hash() */
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      //zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }

  /* If the last block was written to next_out, then done. */
  if (last) {
    return BS_FINISH_DONE;
  }

  /* If flushing and all input has been consumed, then done. */
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 &&
    s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }

  /* Fill the window with any remaining input. */
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    /* Slide the window down. */
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    //zmemcpy(s->window, s->window + s->w_size, s->strstart);
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;       /* add a pending slide_hash() */
    }
    have += s.w_size;      /* more space now */
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }

  /* There was not enough avail_out to write a complete worthy or flushed
   * stored block to next_out. Write a stored block to pending instead, if we
   * have enough input for a worthy block, or if flushing and there is enough
   * room for the remaining input as a stored block in the pending buffer.
   */
  have = (s.bi_valid + 42) >> 3;     /* number of header bytes */
    /* maximum stored block length that will fit in pending: */
  have = s.pending_buf_size - have > 65535/* MAX_STORED */ ? 65535/* MAX_STORED */ : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block ||
     ((left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 &&
     s.strm.avail_in === 0 && left <= have)) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 &&
         len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }

  /* We've done all we can with the available input and output. */
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};


/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
const deflate_fast = (s, flush) => {

  let hash_head;        /* head of the hash chain */
  let bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
const deflate_slow = (s, flush) => {

  let hash_head;          /* head of hash chain */
  let bflush;              /* set if current block must be flushed */

  let max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
};


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
const deflate_rle = (s, flush) => {

  let bflush;            /* set if current block must be flushed */
  let prev;              /* byte at distance one to match */
  let scan, strend;      /* scan goes up to strend for length of run */

  const _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
const deflate_huff = (s, flush) => {

  let bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {

  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
const lm_init = (s) => {

  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED$2; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.sym_buf = 0;        /* buffer for distances and literals/lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.sym_next = 0;      /* running index in sym_buf */
  this.sym_end = 0;       /* symbol table full when sym_next reaches this */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


/* =========================================================================
 * Check for a valid deflate stream state. Return 0 if ok, 1 if not.
 */
const deflateStateCheck = (strm) => {

  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || (s.status !== INIT_STATE &&
//#ifdef GZIP
                                s.status !== GZIP_STATE &&
//#endif
                                s.status !== EXTRA_STATE &&
                                s.status !== NAME_STATE &&
                                s.status !== COMMENT_STATE &&
                                s.status !== HCRC_STATE &&
                                s.status !== BUSY_STATE &&
                                s.status !== FINISH_STATE)) {
    return 1;
  }
  return 0;
};


const deflateResetKeep = (strm) => {

  if (deflateStateCheck(strm)) {
    return pako_esm_err(strm, Z_STREAM_ERROR$2);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status =
//#ifdef GZIP
    s.wrap === 2 ? GZIP_STATE :
//#endif
    s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};


const deflateReset = (strm) => {

  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};


const deflateSetHeader = (strm, head) => {

  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};


const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {

  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED || (windowBits === 8 && wrap !== 1)) {
    return pako_esm_err(strm, Z_STREAM_ERROR$2);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  const s = new DeflateState();

  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;     /* to pass state test in deflateReset() */

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  /* We overlay pending_buf and sym_buf. This works since the average size
   * for length/distance pairs over any compressed block is assured to be 31
   * bits or less.
   *
   * Analysis: The longest fixed codes are a length code of 8 bits plus 5
   * extra bits, for lengths 131 to 257. The longest fixed distance codes are
   * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest
   * possible fixed-codes length/distance pair is then 31 bits total.
   *
   * sym_buf starts one-fourth of the way into pending_buf. So there are
   * three bytes in sym_buf for every four bytes in pending_buf. Each symbol
   * in sym_buf is three bytes -- two for the distance and one for the
   * literal/length. As each symbol is consumed, the pointer to the next
   * sym_buf value to read moves forward three bytes. From that symbol, up to
   * 31 bits are written to pending_buf. The closest the written pending_buf
   * bits gets to the next sym_buf symbol to read is just before the last
   * code is written. At that time, 31*(n-2) bits have been written, just
   * after 24*(n-2) bits have been consumed from sym_buf. sym_buf starts at
   * 8*n bits into pending_buf. (Note that the symbol buffer fills when n-1
   * symbols are written.) The closest the writing gets to what is unread is
   * then n+14 bits. Here n is lit_bufsize, which is 16384 by default, and
   * can range from 128 to 32768.
   *
   * Therefore, at a minimum, there are 142 bits of space between what is
   * written and what is read in the overlain buffers, so the symbols cannot
   * be overwritten by the compressed data. That space is actually 139 bits,
   * due to the three-bit fixed-code block header.
   *
   * That covers the case where either Z_FIXED is specified, forcing fixed
   * codes, or when the use of fixed codes is chosen, because that choice
   * results in a smaller compressed block than dynamic codes. That latter
   * condition then assures that the above analysis also covers all dynamic
   * blocks. A dynamic-code block will only be chosen to be emitted if it has
   * fewer bits than a fixed-code block would for the same set of symbols.
   * Therefore its average symbol length is assured to be less than 31. So
   * the compressed data for a dynamic block also cannot overwrite the
   * symbols from which it is being constructed.
   */

  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->sym_buf = s->pending_buf + s->lit_bufsize;
  s.sym_buf = s.lit_bufsize;

  //s->sym_end = (s->lit_bufsize - 1) * 3;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  /* We avoid equality with lit_bufsize*3 because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
};

const deflateInit = (strm, level) => {

  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};


/* ========================================================================= */
const deflate$2 = (strm, flush) => {

  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? pako_esm_err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }

  const s = strm.state;

  if (!strm.output ||
      (strm.avail_in !== 0 && !strm.input) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH$3)) {
    return pako_esm_err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }

  const old_flush = s.last_flush;
  s.last_flush = flush;

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK$3;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && pako_esm_rank(flush) <= pako_esm_rank(old_flush) &&
    flush !== Z_FINISH$3) {
    return pako_esm_err(strm, Z_BUF_ERROR$1);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return pako_esm_err(strm, Z_BUF_ERROR$1);
  }

  /* Write the header */
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    /* zlib header */
    let header = (Z_DEFLATED$2 + ((s.w_bits - 8) << 4)) << 8;
    let level_flags = -1;

    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= (level_flags << 6);
    if (s.strstart !== 0) { header |= PRESET_DICT; }
    header += 31 - (header % 31);

    putShortMSB(s, header);

    /* Save the adler32 of the preset dictionary: */
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 0xffff);
    }
    strm.adler = 1; // adler32(0L, Z_NULL, 0);
    s.status = BUSY_STATE;

    /* Compression must start with an empty pending buffer */
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
//#ifdef GZIP
  if (s.status === GZIP_STATE) {
    /* gzip header */
    strm.adler = 0;  //crc32(0L, Z_NULL, 0);
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) { // s->gzhead == Z_NULL
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 :
                  (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                   4 : 0));
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;

      /* Compression must start with an empty pending buffer */
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
    else {
      put_byte(s, (s.gzhead.text ? 1 : 0) +
                  (s.gzhead.hcrc ? 2 : 0) +
                  (!s.gzhead.extra ? 0 : 4) +
                  (!s.gzhead.name ? 0 : 8) +
                  (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 0xff);
      put_byte(s, (s.gzhead.time >> 8) & 0xff);
      put_byte(s, (s.gzhead.time >> 16) & 0xff);
      put_byte(s, (s.gzhead.time >> 24) & 0xff);
      put_byte(s, s.level === 9 ? 2 :
                  (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                   4 : 0));
      put_byte(s, s.gzhead.os & 0xff);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 0xff);
        put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      let beg = s.pending;   /* start of bytes to update crc */
      let left = (s.gzhead.extra.length & 0xffff) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy = s.pending_buf_size - s.pending;
        // zmemcpy(s.pending_buf + s.pending,
        //    s.gzhead.extra + s.gzindex, copy);
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
        s.pending = s.pending_buf_size;
        //--- HCRC_UPDATE(beg) ---//
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        //---//
        s.gzindex += copy;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      // JS specific: s.gzhead.extra may be TypedArray or Array for backward compatibility
      //              TypedArray.slice and TypedArray.from don't exist in IE10-IE11
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      // zmemcpy(s->pending_buf + s->pending,
      //     s->gzhead->extra + s->gzindex, left);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      let beg = s.pending;   /* start of bytes to update crc */
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          //--- HCRC_UPDATE(beg) ---//
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          //---//
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      let beg = s.pending;   /* start of bytes to update crc */
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          //--- HCRC_UPDATE(beg) ---//
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          //---//
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 0xff);
      put_byte(s, (strm.adler >> 8) & 0xff);
      strm.adler = 0; //crc32(0L, Z_NULL, 0);
    }
    s.status = BUSY_STATE;

    /* Compression must start with an empty pending buffer */
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
//#endif

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE)) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) :
                 s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
                 s.strategy === Z_RLE ? deflate_rle(s, flush) :
                 configuration_table[s.level].func(s, flush);

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK$3;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      }
      else if (flush !== Z_BLOCK$1) { /* FULL_FLUSH or SYNC_FLUSH */

        _tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH$1) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK$3;
      }
    }
  }

  if (flush !== Z_FINISH$3) { return Z_OK$3; }
  if (s.wrap <= 0) { return Z_STREAM_END$3; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};


const deflateEnd = (strm) => {

  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }

  const status = strm.state.status;

  strm.state = null;

  return status === BUSY_STATE ? pako_esm_err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
const deflateSetDictionary = (strm, dictionary) => {

  let dictLength = dictionary.length;

  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }

  const s = strm.state;
  const wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};


var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
module.exports.deflateBound = deflateBound;
module.exports.deflateCopy = deflateCopy;
module.exports.deflateGetDictionary = deflateGetDictionary;
module.exports.deflateParams = deflateParams;
module.exports.deflatePending = deflatePending;
module.exports.deflatePrime = deflatePrime;
module.exports.deflateTune = deflateTune;
*/

var deflate_1$2 = {
	deflateInit: deflateInit_1,
	deflateInit2: deflateInit2_1,
	deflateReset: deflateReset_1,
	deflateResetKeep: deflateResetKeep_1,
	deflateSetHeader: deflateSetHeader_1,
	deflate: deflate_2$1,
	deflateEnd: deflateEnd_1,
	deflateSetDictionary: deflateSetDictionary_1,
	deflateInfo: deflateInfo
};

const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};

var pako_esm_assign = function (obj /*from1, from2, from3, ...*/) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// Join array of chunks to single array.
var flattenChunks = (chunks) => {
  // calculate data length
  let len = 0;

  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }

  // join chunks
  const result = new Uint8Array(len);

  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }

  return result;
};

var common = {
	assign: pako_esm_assign,
	flattenChunks: flattenChunks
};

// String encode/decode helpers


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
let STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
var string2buf = (str) => {
  if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }

  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new Uint8Array(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper
const buf2binstring = (buf, len) => {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }

  let result = '';
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};


// convert array to string
var buf2string = (buf, max) => {
  const len = max || buf.length;

  if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }

  let i, out;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  const utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    let c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    let c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = (buf, max) => {

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

var strings = {
	string2buf: string2buf,
	buf2string: buf2string,
	utf8border: utf8border
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

var zstream = ZStream;

const toString$1 = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});

  let opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new zstream();
  this.strm.avail_out = 0;

  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }

  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    let dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = deflate_1$2.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must
 * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
 * buffers and call [[Deflate#onEnd]].
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate$1.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;

  if (this.ended) { return false; }

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    // Make sure avail_out > 6 to avoid repeating markers
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    status = deflate_1$2.deflate(strm, _flush_mode);

    // Ended => flush and finish
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }

    // Flush if out buffer full
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }

    // Flush if requested and has data
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array): output data.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate$1.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate$1.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array
 * - data (Uint8Array|ArrayBuffer|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || messages[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array
 * - data (Uint8Array|ArrayBuffer|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array
 * - data (Uint8Array|ArrayBuffer|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}


var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;

var deflate_1$1 = {
	Deflate: Deflate_1$1,
	deflate: deflate_2,
	deflateRaw: deflateRaw_1$1,
	gzip: gzip_1$1,
	constants: constants$1
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
const BAD$1 = 16209;       /* got a data error -- remain here until reset */
const TYPE$1 = 16191;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
var inffast = function inflate_fast(strm, start) {
  let _in;                    /* local strm.input */
  let last;                   /* have enough input while in < last */
  let _out;                   /* local strm.output */
  let beg;                    /* inflate()'s initial strm.output */
  let end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  let dmax;                   /* maximum distance from zlib header */
//#endif
  let wsize;                  /* window size or zero if not using window */
  let whave;                  /* valid bytes in the window */
  let wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  let s_window;               /* allocated sliding window, if wsize != 0 */
  let hold;                   /* local strm.hold */
  let bits;                   /* local strm.bits */
  let lcode;                  /* local strm.lencode */
  let dcode;                  /* local strm.distcode */
  let lmask;                  /* mask for first level of length codes */
  let dmask;                  /* mask for first level of distance codes */
  let here;                   /* retrieved table entry */
  let op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  let len;                    /* match length, unused bytes */
  let dist;                   /* match distance */
  let from;                   /* where to copy match from */
  let from_source;


  let input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  const state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD$1;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD$1;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD$1;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE$1;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD$1;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;

const lbase = new Uint16Array([ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
]);

const lext = new Uint8Array([ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
]);

const dbase = new Uint16Array([ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
]);

const dext = new Uint8Array([ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
]);

const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>
{
  const bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  let len = 0;               /* a code's length in bits */
  let sym = 0;               /* index of code symbols */
  let min = 0, max = 0;          /* minimum and maximum code lengths */
  let root = 0;              /* number of index bits for root table */
  let curr = 0;              /* number of index bits for current table */
  let drop = 0;              /* code bits to drop for sub-table */
  let left = 0;                   /* number of prefix codes available */
  let used = 0;              /* code entries in table used */
  let huff = 0;              /* Huffman code */
  let incr;              /* for incrementing code, index */
  let fill;              /* index for replicating entries */
  let low;               /* low bits for current root entry */
  let mask;              /* mask for low root bits */
  let next;             /* next available space in table */
  let base = null;     /* base value table to use */
//  let shoextra;    /* extra bits table to use */
  let match;                  /* use base and extra for symbol >= match */
  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  let extra = null;

  let here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES$1) {
    base = extra = work;    /* dummy value--not used */
    match = 20;

  } else if (type === LENS$1) {
    base = lbase;
    extra = lext;
    match = 257;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    match = 0;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
    (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
        (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};


var inftrees = inflate_table;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.






const CODES = 0;
const LENS = 1;
const DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES,
  Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;


/* STATES ====================================================================*/
/* ===========================================================================*/


const    HEAD = 16180;       /* i: waiting for magic header */
const    FLAGS = 16181;      /* i: waiting for method and flags (gzip) */
const    TIME = 16182;       /* i: waiting for modification time (gzip) */
const    OS = 16183;         /* i: waiting for extra flags and operating system (gzip) */
const    EXLEN = 16184;      /* i: waiting for extra length (gzip) */
const    EXTRA = 16185;      /* i: waiting for extra bytes (gzip) */
const    NAME = 16186;       /* i: waiting for end of file name (gzip) */
const    COMMENT = 16187;    /* i: waiting for end of comment (gzip) */
const    HCRC = 16188;       /* i: waiting for header crc (gzip) */
const    DICTID = 16189;    /* i: waiting for dictionary check value */
const    DICT = 16190;      /* waiting for inflateSetDictionary() call */
const        TYPE = 16191;      /* i: waiting for type bits, including last-flag bit */
const        TYPEDO = 16192;    /* i: same, but skip check to exit inflate on new block */
const        STORED = 16193;    /* i: waiting for stored size (length and complement) */
const        COPY_ = 16194;     /* i/o: same as COPY below, but only first time in */
const        COPY = 16195;      /* i/o: waiting for input or output to copy stored block */
const        TABLE = 16196;     /* i: waiting for dynamic block table lengths */
const        LENLENS = 16197;   /* i: waiting for code length code lengths */
const        CODELENS = 16198;  /* i: waiting for length/lit and distance code lengths */
const            LEN_ = 16199;      /* i: same as LEN below, but only first time in */
const            LEN = 16200;       /* i: waiting for length/lit/eob code */
const            LENEXT = 16201;    /* i: waiting for length extra bits */
const            DIST = 16202;      /* i: waiting for distance code */
const            DISTEXT = 16203;   /* i: waiting for distance extra bits */
const            MATCH = 16204;     /* o: waiting for output space to copy string */
const            LIT = 16205;       /* o: waiting for output space to write literal */
const    CHECK = 16206;     /* i: waiting for 32-bit check value */
const    LENGTH = 16207;    /* i: waiting for 32-bit length (gzip) */
const    DONE = 16208;      /* finished check, done -- remain here until reset */
const    BAD = 16209;       /* got a data error -- remain here until reset */
const    MEM = 16210;       /* got an inflate() memory error -- remain here until reset */
const    SYNC = 16211;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

const MAX_WBITS = 15;
/* 32K LZ77 window */
const DEF_WBITS = MAX_WBITS;


const zswap32 = (q) => {

  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
};


function InflateState() {
  this.strm = null;           /* pointer back to this zlib stream */
  this.mode = 0;              /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip,
                                 bit 2 true to validate check value */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib), or
                                 -1 if raw or no header yet */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new Uint16Array(320); /* temporary storage for code lengths */
  this.work = new Uint16Array(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}


const inflateStateCheck = (strm) => {

  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm ||
    state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};


const inflateResetKeep = (strm) => {

  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK$1;
};


const inflateReset = (strm) => {

  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

};


const inflateReset2 = (strm, windowBits) => {
  let wrap;

  /* get the state */
  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
  const state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};


const inflateInit2 = (strm, windowBits) => {

  if (!strm) { return Z_STREAM_ERROR$1; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  const state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.strm = strm;
  state.window = null/*Z_NULL*/;
  state.mode = HEAD;     /* to pass state test in inflateReset2() */
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
};


const inflateInit = (strm) => {

  return inflateInit2(strm, DEF_WBITS);
};


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
let virgin = true;

let lenfix, distfix; // We have no pointers in JS, so keep tables separate


const fixedtables = (state) => {

  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);

    /* literal/length table */
    let sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inftrees(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inftrees(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
const updatewindow = (strm, src, end, copy) => {

  let dist;
  const state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new Uint8Array(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
};


const inflate$2 = (strm, flush) => {

  let state;
  let input, output;          // input/output buffers
  let next;                   /* next input INDEX */
  let put;                    /* next output INDEX */
  let have, left;             /* available input and output */
  let hold;                   /* bit buffer */
  let bits;                   /* bits in bit buffer */
  let _in, _out;              /* save starting available input and output */
  let copy;                   /* number of stored or match bytes to copy */
  let from;                   /* where to copy match bytes from */
  let from_source;
  let here = 0;               /* current decoding table entry */
  let here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //let last;                   /* parent table entry */
  let last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  let len;                    /* length to copy for repeats, bits to drop */
  let ret;                    /* return code */
  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */
  let opts;

  let n; // temporary variable for NEED_BITS

  const order = /* permutation of code lengths */
    new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);


  if (inflateStateCheck(strm) || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR$1;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK$1;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          if (state.wbits === 0) {
            state.wbits = 15;
          }
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        if (len > 15 || len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }

        // !!! pako patch. Force use `options.windowBits` if passed.
        // Required to always use max window size by default.
        state.dmax = 1 << state.wbits;
        //state.dmax = 1 << len;

        state.flags = 0;               /* indicate zlib header */
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if ((state.flags & 0x0200) && (state.wrap & 4)) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if ((state.flags & 0x0200) && (state.wrap & 4)) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32_1(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if ((state.flags & 0x0200) && (state.wrap & 4)) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Uint8Array(state.head.extra_len);
              }
              state.head.extra.set(
                input.subarray(
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  next + copy
                ),
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if ((state.flags & 0x0200) && (state.wrap & 4)) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if ((state.wrap & 4) && hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT$1;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          output.set(input.subarray(next, next + copy), put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inffast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if ((state.wrap & 4) && _out) {
            strm.adler = state.check =
                /*UPDATE_CHECK(state.check, put - _out, _out);*/
                (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.wrap & 4) && (state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if ((state.wrap & 4) && hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END$1;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR$1;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR$1;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR$1;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH$1))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if ((state.wrap & 4) && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};


const inflateEnd = (strm) => {

  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }

  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};


const inflateGetHeader = (strm, head) => {

  /* check state */
  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK$1;
};


const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;

  let state;
  let dictid;
  let ret;

  /* check state */
  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK$1;
};


var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
module.exports.inflateCodesUsed = inflateCodesUsed;
module.exports.inflateCopy = inflateCopy;
module.exports.inflateGetDictionary = inflateGetDictionary;
module.exports.inflateMark = inflateMark;
module.exports.inflatePrime = inflatePrime;
module.exports.inflateSync = inflateSync;
module.exports.inflateSyncPoint = inflateSyncPoint;
module.exports.inflateUndermine = inflateUndermine;
module.exports.inflateValidate = inflateValidate;
*/

var inflate_1$2 = {
	inflateReset: inflateReset_1,
	inflateReset2: inflateReset2_1,
	inflateResetKeep: inflateResetKeep_1,
	inflateInit: inflateInit_1,
	inflateInit2: inflateInit2_1,
	inflate: inflate_2$1,
	inflateEnd: inflateEnd_1,
	inflateGetHeader: inflateGetHeader_1,
	inflateSetDictionary: inflateSetDictionary_1,
	inflateInfo: inflateInfo
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

var gzheader = GZheader;

const pako_esm_toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_FINISH,
  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR
} = constants$2;

/* ===========================================================================*/


/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ''
  }, options || {});

  const opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new zstream();
  this.strm.avail_out = 0;

  let status  = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }

  this.header = new gzheader();

  inflate_1$2.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (pako_esm_toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer): input data
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
 *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
 *   `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. If end of stream detected,
 * [[Inflate#onEnd]] will be called.
 *
 * `flush_mode` is not needed for normal operation, because end of stream
 * detected automatically. You may try to use it for advanced things, but
 * this functionality was not tested.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate$1.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;

  if (this.ended) return false;

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (pako_esm_toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = inflate_1$2.inflate(strm, _flush_mode);

    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);

      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        // Replace code with more verbose
        status = Z_NEED_DICT;
      }
    }

    // Skip snyc markers if more data follows and not raw mode
    while (strm.avail_in > 0 &&
           status === Z_STREAM_END &&
           strm.state.wrap > 0 &&
           data[strm.next_in] !== 0)
    {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }

    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }

    // Remember real `avail_out` value, because we may patch out buffer content
    // to align utf8 strings boundaries.
    last_avail_out = strm.avail_out;

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {

        if (this.options.to === 'string') {

          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail & realign counters
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);

          this.onData(utf8str);

        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }

    // Must repeat iteration if out buffer is full
    if (status === Z_OK && last_avail_out === 0) continue;

    // Finalize if end of stream reached.
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|String): output data. When string output requested,
 *   each chunk will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate$1.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate$1.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako');
 * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
 * let output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err) {
 *   console.log(err);
 * }
 * ```
 **/
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);

  inflator.push(input);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) throw inflator.msg || messages[inflator.err];

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;

var inflate_1$1 = {
	Inflate: Inflate_1$1,
	inflate: inflate_2,
	inflateRaw: inflateRaw_1$1,
	ungzip: ungzip$1,
	constants: constants
};

const { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;

const { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;



var Deflate_1 = (/* unused pure expression or super */ null && (Deflate));
var deflate_1 = (/* unused pure expression or super */ null && (deflate));
var deflateRaw_1 = (/* unused pure expression or super */ null && (deflateRaw));
var gzip_1 = (/* unused pure expression or super */ null && (gzip));
var Inflate_1 = (/* unused pure expression or super */ null && (Inflate));
var inflate_1 = (/* unused pure expression or super */ null && (inflate));
var inflateRaw_1 = (/* unused pure expression or super */ null && (inflateRaw));
var ungzip_1 = ungzip;
var constants_1 = (/* unused pure expression or super */ null && (constants$2));

var pako = (/* unused pure expression or super */ null && ({
	Deflate: Deflate_1,
	deflate: deflate_1,
	deflateRaw: deflateRaw_1,
	gzip: gzip_1,
	Inflate: Inflate_1,
	inflate: inflate_1,
	inflateRaw: inflateRaw_1,
	ungzip: ungzip_1,
	constants: constants_1
}));



;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/tokenizer/languages.js
const STEMMERS = {
    arabic: 'ar',
    armenian: 'am',
    bulgarian: 'bg',
    czech: 'cz',
    danish: 'dk',
    dutch: 'nl',
    english: 'en',
    finnish: 'fi',
    french: 'fr',
    german: 'de',
    greek: 'gr',
    hungarian: 'hu',
    indian: 'in',
    indonesian: 'id',
    irish: 'ie',
    italian: 'it',
    lithuanian: 'lt',
    nepali: 'np',
    norwegian: 'no',
    portuguese: 'pt',
    romanian: 'ro',
    russian: 'ru',
    serbian: 'rs',
    slovenian: 'ru',
    spanish: 'es',
    swedish: 'se',
    tamil: 'ta',
    turkish: 'tr',
    ukrainian: 'uk',
    sanskrit: 'sk'
};
const SPLITTERS = {
    dutch: /[^A-Za-zàèéìòóù0-9_'-]+/gim,
    english: /[^A-Za-zàèéìòóù0-9_'-]+/gim,
    french: /[^a-z0-9äâàéèëêïîöôùüûœç-]+/gim,
    italian: /[^A-Za-zàèéìòóù0-9_'-]+/gim,
    norwegian: /[^a-z0-9_æøåÆØÅäÄöÖüÜ]+/gim,
    portuguese: /[^a-z0-9à-úÀ-Ú]/gim,
    russian: /[^a-z0-9а-яА-ЯёЁ]+/gim,
    spanish: /[^a-z0-9A-Zá-úÁ-ÚñÑüÜ]+/gim,
    swedish: /[^a-z0-9_åÅäÄöÖüÜ-]+/gim,
    german: /[^a-z0-9A-ZäöüÄÖÜß]+/gim,
    finnish: /[^a-z0-9äöÄÖ]+/gim,
    danish: /[^a-z0-9æøåÆØÅ]+/gim,
    hungarian: /[^a-z0-9áéíóöőúüűÁÉÍÓÖŐÚÜŰ]+/gim,
    romanian: /[^a-z0-9ăâîșțĂÂÎȘȚ]+/gim,
    serbian: /[^a-z0-9čćžšđČĆŽŠĐ]+/gim,
    turkish: /[^a-z0-9çÇğĞıİöÖşŞüÜ]+/gim,
    lithuanian: /[^a-z0-9ąčęėįšųūžĄČĘĖĮŠŲŪŽ]+/gim,
    arabic: /[^a-z0-9أ-ي]+/gim,
    nepali: /[^a-z0-9अ-ह]+/gim,
    irish: /[^a-z0-9áéíóúÁÉÍÓÚ]+/gim,
    indian: /[^a-z0-9अ-ह]+/gim,
    armenian: /[^a-z0-9ա-ֆ]+/gim,
    greek: /[^a-z0-9α-ωά-ώ]+/gim,
    indonesian: /[^a-z0-9]+/gim,
    ukrainian: /[^a-z0-9а-яА-ЯіїєІЇЄ]+/gim,
    slovenian: /[^a-z0-9čžšČŽŠ]+/gim,
    bulgarian: /[^a-z0-9а-яА-Я]+/gim,
    tamil: /[^a-z0-9அ-ஹ]+/gim,
    sanskrit: /[^a-z0-9A-Zāīūṛḷṃṁḥśṣṭḍṇṅñḻḹṝ]+/gim,
    czech: /[^A-Z0-9a-zěščřžýáíéúůóťďĚŠČŘŽÝÁÍÉÓÚŮŤĎ-]+/gim
};
const SUPPORTED_LANGUAGES = Object.keys(STEMMERS);
function getLocale(language) {
    return language !== undefined && SUPPORTED_LANGUAGES.includes(language) ? STEMMERS[language] : undefined;
}
//# sourceMappingURL=languages.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/utils.js

const baseId = Date.now().toString().slice(5);
let lastId = 0;
const utils_k = 1024;
const nano = BigInt(1e3);
const milli = BigInt(1e6);
const utils_second = BigInt(1e9);
const isServer = (/* unused pure expression or super */ null && (typeof window === 'undefined'));
/**
 * This value can be increased up to 100_000
 * But i don't know if this value change from nodejs to nodejs
 * So I will keep a safer value here.
 */
const MAX_ARGUMENT_FOR_STACK = 65535;
/**
 * This method is needed to used because of issues like: https://github.com/oramasearch/orama/issues/301
 * that issue is caused because the array that is pushed is huge (>100k)
 *
 * @example
 * ```ts
 * safeArrayPush(myArray, [1, 2])
 * ```
 */
function utils_safeArrayPush(arr, newArr) {
    if (newArr.length < MAX_ARGUMENT_FOR_STACK) {
        Array.prototype.push.apply(arr, newArr);
    }
    else {
        const newArrLength = newArr.length;
        for (let i = 0; i < newArrLength; i += MAX_ARGUMENT_FOR_STACK) {
            Array.prototype.push.apply(arr, newArr.slice(i, i + MAX_ARGUMENT_FOR_STACK));
        }
    }
}
function sprintf(template, ...args) {
    return template.replace(/%(?:(?<position>\d+)\$)?(?<width>-?\d*\.?\d*)(?<type>[dfs])/g, function (...replaceArgs) {
        const groups = replaceArgs[replaceArgs.length - 1];
        const { width: rawWidth, type, position } = groups;
        const replacement = position ? args[Number.parseInt(position) - 1] : args.shift();
        const width = rawWidth === '' ? 0 : Number.parseInt(rawWidth);
        switch (type) {
            case 'd':
                return replacement.toString().padStart(width, '0');
            case 'f': {
                let value = replacement;
                const [padding, precision] = rawWidth.split('.').map((w) => Number.parseFloat(w));
                if (typeof precision === 'number' && precision >= 0) {
                    value = value.toFixed(precision);
                }
                return typeof padding === 'number' && padding >= 0 ? value.toString().padStart(width, '0') : value.toString();
            }
            case 's':
                return width < 0
                    ? replacement.toString().padEnd(-width, ' ')
                    : replacement.toString().padStart(width, ' ');
            default:
                return replacement;
        }
    });
}
function formatBytes(bytes, decimals = 2) {
    if (bytes === 0) {
        return '0 Bytes';
    }
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    const i = Math.floor(Math.log(bytes) / Math.log(utils_k));
    return `${parseFloat((bytes / Math.pow(utils_k, i)).toFixed(dm))} ${sizes[i]}`;
}
function isInsideWebWorker() {
    // @ts-expect-error - WebWorker global scope
    return typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
}
function isInsideNode() {
    return typeof process !== 'undefined' && process.release && process.release.name === 'node';
}
function getNanosecondTimeViaPerformance() {
    return BigInt(Math.floor(performance.now() * 1e6));
}
function utils_formatNanoseconds(value) {
    if (typeof value === 'number') {
        value = BigInt(value);
    }
    if (value < nano) {
        return `${value}ns`;
    }
    else if (value < milli) {
        return `${value / nano}μs`;
    }
    else if (value < utils_second) {
        return `${value / milli}ms`;
    }
    return `${value / utils_second}s`;
}
function utils_getNanosecondsTime() {
    if (isInsideWebWorker()) {
        return getNanosecondTimeViaPerformance();
    }
    if (isInsideNode()) {
        return process.hrtime.bigint();
    }
    if (typeof process !== 'undefined' && typeof process?.hrtime?.bigint === 'function') {
        return process.hrtime.bigint();
    }
    if (typeof performance !== 'undefined') {
        return getNanosecondTimeViaPerformance();
    }
    // @todo: fallback to V8 native method to get microtime
    return BigInt(0);
}
function uniqueId() {
    return `${baseId}-${lastId++}`;
}
function getOwnProperty(object, property) {
    // Checks if `hasOwn` method is defined avoiding errors with older Node.js versions
    if (Object.hasOwn === undefined) {
        return Object.prototype.hasOwnProperty.call(object, property) ? object[property] : undefined;
    }
    return Object.hasOwn(object, property) ? object[property] : undefined;
}
function getTokenFrequency(token, tokens) {
    let count = 0;
    for (const t of tokens) {
        if (t === token) {
            count++;
        }
    }
    return count;
}
function insertSortedValue(arr, el, compareFn = utils_sortTokenScorePredicate) {
    let low = 0;
    let high = arr.length;
    let mid;
    while (low < high) {
        mid = (low + high) >>> 1;
        if (compareFn(el, arr[mid]) < 0) {
            high = mid;
        }
        else {
            low = mid + 1;
        }
    }
    arr.splice(low, 0, el);
    return arr;
}
function utils_sortTokenScorePredicate(a, b) {
    if (b[1] === a[1]) {
        return a[0] - b[0];
    }
    return b[1] - a[1];
}
// Intersection function taken from https://github.com/lovasoa/fast_array_intersect.
// MIT Licensed at the time of writing.
function utils_intersect(arrays) {
    if (arrays.length === 0) {
        return [];
    }
    else if (arrays.length === 1) {
        return arrays[0];
    }
    for (let i = 1; i < arrays.length; i++) {
        if (arrays[i].length < arrays[0].length) {
            const tmp = arrays[0];
            arrays[0] = arrays[i];
            arrays[i] = tmp;
        }
    }
    const set = new Map();
    for (const elem of arrays[0]) {
        set.set(elem, 1);
    }
    for (let i = 1; i < arrays.length; i++) {
        let found = 0;
        for (const elem of arrays[i]) {
            const count = set.get(elem);
            if (count === i) {
                set.set(elem, count + 1);
                found++;
            }
        }
        if (found === 0)
            return [];
    }
    return arrays[0].filter((e) => {
        const count = set.get(e);
        if (count !== undefined)
            set.set(e, 0);
        return count === arrays.length;
    });
}
function utils_getDocumentProperties(doc, paths) {
    const properties = {};
    const pathsLength = paths.length;
    for (let i = 0; i < pathsLength; i++) {
        const path = paths[i];
        const pathTokens = path.split('.');
        let current = doc;
        const pathTokensLength = pathTokens.length;
        for (let j = 0; j < pathTokensLength; j++) {
            current = current[pathTokens[j]];
            // We found an object but we were supposed to be done
            if (typeof current === 'object') {
                if (current !== null &&
                    'lat' in current &&
                    'lon' in current &&
                    typeof current.lat === 'number' &&
                    typeof current.lon === 'number') {
                    current = properties[path] = current;
                    break;
                }
                else if (!Array.isArray(current) && current !== null && j === pathTokensLength - 1) {
                    current = undefined;
                    break;
                }
            }
            else if ((current === null || typeof current !== 'object') && j < pathTokensLength - 1) {
                // We can't recurse anymore but we were supposed to
                current = undefined;
                break;
            }
        }
        if (typeof current !== 'undefined') {
            properties[path] = current;
        }
    }
    return properties;
}
function utils_getNested(obj, path) {
    const props = utils_getDocumentProperties(obj, [path]);
    return props[path];
}
function flattenObject(obj, prefix = '') {
    const result = {};
    for (const key in obj) {
        const prop = `${prefix}${key}`;
        const objKey = obj[key];
        if (typeof objKey === 'object' && objKey !== null) {
            Object.assign(result, flattenObject(objKey, `${prop}.`));
        }
        else {
            result[prop] = objKey;
        }
    }
    return result;
}
const mapDistanceToMeters = {
    cm: 0.01,
    m: 1,
    km: 1000,
    ft: 0.3048,
    yd: 0.9144,
    mi: 1609.344
};
function utils_convertDistanceToMeters(distance, unit) {
    const ratio = mapDistanceToMeters[unit];
    if (ratio === undefined) {
        throw new Error(errors_createError('INVALID_DISTANCE_SUFFIX', distance).message);
    }
    return distance * ratio;
}
function utils_removeVectorsFromHits(searchResult, vectorProperties) {
    searchResult.hits = searchResult.hits.map((result) => ({
        ...result,
        document: {
            ...result.document,
            // Remove embeddings from the result
            ...vectorProperties.reduce((acc, prop) => {
                const path = prop.split('.');
                const lastKey = path.pop();
                let obj = acc;
                for (const key of path) {
                    obj[key] = obj[key] ?? {};
                    obj = obj[key];
                }
                obj[lastKey] = null;
                return acc;
            }, result.document)
        }
    }));
}
function isPromise(obj) {
    return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
}
/**
 * Checks if the provided input is an async function or if the input is an array
 * containing at least one async function.
 *
 * @param func - A single function or an array of functions to check.
 *               Non-function values are ignored.
 * @returns `true` if the input is an async function or an array containing at least
 *          one async function, otherwise `false`.
 */
function utils_isAsyncFunction(func) {
    if (Array.isArray(func)) {
        return func.some((item) => utils_isAsyncFunction(item));
    }
    return func?.constructor?.name === 'AsyncFunction';
}
const withIntersection = 'intersection' in new Set();
function setIntersection(...sets) {
    // Fast path 1
    if (sets.length === 0) {
        return new Set();
    }
    // Fast path 2
    if (sets.length === 1) {
        return sets[0];
    }
    // Fast path 3
    if (sets.length === 2) {
        const set1 = sets[0];
        const set2 = sets[1];
        if (withIntersection) {
            return set1.intersection(set2);
        }
        const result = new Set();
        const base = set1.size < set2.size ? set1 : set2;
        const other = base === set1 ? set2 : set1;
        for (const value of base) {
            if (other.has(value)) {
                result.add(value);
            }
        }
        return result;
    }
    // Slow path
    // Find the smallest set
    const min = {
        index: 0,
        size: sets[0].size
    };
    for (let i = 1; i < sets.length; i++) {
        if (sets[i].size < min.size) {
            min.index = i;
            min.size = sets[i].size;
        }
    }
    if (withIntersection) {
        let base = sets[min.index];
        for (let i = 0; i < sets.length; i++) {
            if (i === min.index) {
                continue;
            }
            base = base.intersection(sets[i]);
        }
        return base;
    }
    // manual implementation:
    // intersect all sets with the smallest set
    const base = sets[min.index];
    for (let i = 0; i < sets.length; i++) {
        if (i === min.index) {
            continue;
        }
        const other = sets[i];
        for (const value of base) {
            if (!other.has(value)) {
                base.delete(value);
            }
        }
    }
    return base;
}
const withUnion = 'union' in new Set();
function setUnion(set1, set2) {
    if (withUnion) {
        if (set1) {
            return set1.union(set2);
        }
        return set2;
    }
    if (!set1) {
        return new Set(set2);
    }
    return new Set([...set1, ...set2]);
}
function setDifference(set1, set2) {
    const result = new Set();
    for (const value of set1) {
        if (!set2.has(value)) {
            result.add(value);
        }
    }
    return result;
}
// This code is taken from https://github.com/davidmarkclements/atomic-sleep, MIT licensed at the time of commit b8149d3ca276c84a54fa8fa1478f9cc79aabc15a.
// All credits go to the original author (David Mark Clements, https://github.com/davidmarkclements).
function sleep(ms) {
    if (typeof SharedArrayBuffer !== 'undefined' && typeof Atomics !== 'undefined') {
        const nil = new Int32Array(new SharedArrayBuffer(4));
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
            if (typeof ms !== 'number' && typeof ms !== 'bigint') {
                throw TypeError('sleep: ms must be a number');
            }
            throw RangeError('sleep: ms must be a number that is greater than 0 but less than Infinity');
        }
        Atomics.wait(nil, 0, 0, Number(ms));
    }
    else {
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
            if (typeof ms !== 'number' && typeof ms !== 'bigint') {
                throw TypeError('sleep: ms must be a number');
            }
            throw RangeError('sleep: ms must be a number that is greater than 0 but less than Infinity');
        }
        const target = Date.now() + Number(ms);
        while (target > Date.now()) {
            /* empty */
        }
    }
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/errors.js


const allLanguages = SUPPORTED_LANGUAGES.join('\n - ');
const errors = {
    NO_LANGUAGE_WITH_CUSTOM_TOKENIZER: 'Do not pass the language option to create when using a custom tokenizer.',
    LANGUAGE_NOT_SUPPORTED: `Language "%s" is not supported.\nSupported languages are:\n - ${allLanguages}`,
    INVALID_STEMMER_FUNCTION_TYPE: `config.stemmer property must be a function.`,
    MISSING_STEMMER: `As of version 1.0.0 @orama/orama does not ship non English stemmers by default. To solve this, please explicitly import and specify the "%s" stemmer from the package @orama/stemmers. See https://docs.orama.com/docs/orama-js/text-analysis/stemming for more information.`,
    CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY: 'Custom stop words array must only contain strings.',
    UNSUPPORTED_COMPONENT: `Unsupported component "%s".`,
    COMPONENT_MUST_BE_FUNCTION: `The component "%s" must be a function.`,
    COMPONENT_MUST_BE_FUNCTION_OR_ARRAY_FUNCTIONS: `The component "%s" must be a function or an array of functions.`,
    INVALID_SCHEMA_TYPE: `Unsupported schema type "%s" at "%s". Expected "string", "boolean" or "number" or array of them.`,
    DOCUMENT_ID_MUST_BE_STRING: `Document id must be of type "string". Got "%s" instead.`,
    DOCUMENT_ALREADY_EXISTS: `A document with id "%s" already exists.`,
    DOCUMENT_DOES_NOT_EXIST: `A document with id "%s" does not exists.`,
    MISSING_DOCUMENT_PROPERTY: `Missing searchable property "%s".`,
    INVALID_DOCUMENT_PROPERTY: `Invalid document property "%s": expected "%s", got "%s"`,
    UNKNOWN_INDEX: `Invalid property name "%s". Expected a wildcard string ("*") or array containing one of the following properties: %s`,
    INVALID_BOOST_VALUE: `Boost value must be a number greater than, or less than 0.`,
    INVALID_FILTER_OPERATION: `You can only use one operation per filter, you requested %d.`,
    SCHEMA_VALIDATION_FAILURE: `Cannot insert document due schema validation failure on "%s" property.`,
    INVALID_SORT_SCHEMA_TYPE: `Unsupported sort schema type "%s" at "%s". Expected "string" or "number".`,
    CANNOT_SORT_BY_ARRAY: `Cannot configure sort for "%s" because it is an array (%s).`,
    UNABLE_TO_SORT_ON_UNKNOWN_FIELD: `Unable to sort on unknown field "%s". Allowed fields: %s`,
    SORT_DISABLED: `Sort is disabled. Please read the documentation at https://docs.orama.com/docs/orama-js for more information.`,
    UNKNOWN_GROUP_BY_PROPERTY: `Unknown groupBy property "%s".`,
    INVALID_GROUP_BY_PROPERTY: `Invalid groupBy property "%s". Allowed types: "%s", but given "%s".`,
    UNKNOWN_FILTER_PROPERTY: `Unknown filter property "%s".`,
    UNKNOWN_VECTOR_PROPERTY: `Unknown vector property "%s". Make sure the property exists in the schema and is configured as a vector.`,
    INVALID_VECTOR_SIZE: `Vector size must be a number greater than 0. Got "%s" instead.`,
    INVALID_VECTOR_VALUE: `Vector value must be a number greater than 0. Got "%s" instead.`,
    INVALID_INPUT_VECTOR: `Property "%s" was declared as a %s-dimensional vector, but got a %s-dimensional vector instead.\nInput vectors must be of the size declared in the schema, as calculating similarity between vectors of different sizes can lead to unexpected results.`,
    WRONG_SEARCH_PROPERTY_TYPE: `Property "%s" is not searchable. Only "string" properties are searchable.`,
    FACET_NOT_SUPPORTED: `Facet doens't support the type "%s".`,
    INVALID_DISTANCE_SUFFIX: `Invalid distance suffix "%s". Valid suffixes are: cm, m, km, mi, yd, ft.`,
    INVALID_SEARCH_MODE: `Invalid search mode "%s". Valid modes are: "fulltext", "vector", "hybrid".`,
    MISSING_VECTOR_AND_SECURE_PROXY: `No vector was provided and no secure proxy was configured. Please provide a vector or configure an Orama Secure Proxy to perform hybrid search.`,
    MISSING_TERM: `"term" is a required parameter when performing hybrid search. Please provide a search term.`,
    INVALID_VECTOR_INPUT: `Invalid "vector" property. Expected an object with "value" and "property" properties, but got "%s" instead.`,
    PLUGIN_CRASHED: `A plugin crashed during initialization. Please check the error message for more information:`,
    PLUGIN_SECURE_PROXY_NOT_FOUND: `Could not find '@orama/secure-proxy-plugin' installed in your Orama instance.\nPlease install it before proceeding with creating an answer session.\nRead more at https://docs.orama.com/docs/orama-js/plugins/plugin-secure-proxy#plugin-secure-proxy\n`,
    PLUGIN_SECURE_PROXY_MISSING_CHAT_MODEL: `Could not find a chat model defined in the secure proxy plugin configuration.\nPlease provide a chat model before proceeding with creating an answer session.\nRead more at https://docs.orama.com/docs/orama-js/plugins/plugin-secure-proxy#plugin-secure-proxy\n`,
    ANSWER_SESSION_LAST_MESSAGE_IS_NOT_ASSISTANT: `The last message in the session is not an assistant message. Cannot regenerate non-assistant messages.`,
    PLUGIN_COMPONENT_CONFLICT: `The component "%s" is already defined. The plugin "%s" is trying to redefine it.`
};
function errors_createError(code, ...args) {
    const error = new Error(sprintf(errors[code] ?? `Unsupported Orama Error code: ${code}`, ...args));
    error.code = code;
    if ('captureStackTrace' in Error.prototype) {
        Error.captureStackTrace(error);
    }
    return error;
}
//# sourceMappingURL=errors.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/defaults.js



function defaults_formatElapsedTime(n) {
    return {
        raw: Number(n),
        formatted: utils_formatNanoseconds(n)
    };
}
function defaults_getDocumentIndexId(doc) {
    if (doc.id) {
        if (typeof doc.id !== 'string') {
            throw errors_createError('DOCUMENT_ID_MUST_BE_STRING', typeof doc.id);
        }
        return doc.id;
    }
    return uniqueId();
}
function defaults_validateSchema(doc, schema) {
    for (const [prop, type] of Object.entries(schema)) {
        const value = doc[prop];
        if (typeof value === 'undefined') {
            continue;
        }
        if (type === 'geopoint' &&
            typeof value === 'object' &&
            typeof value.lon === 'number' &&
            typeof value.lat === 'number') {
            continue;
        }
        if (type === 'enum' && (typeof value === 'string' || typeof value === 'number')) {
            continue;
        }
        if (type === 'enum[]' && Array.isArray(value)) {
            const valueLength = value.length;
            for (let i = 0; i < valueLength; i++) {
                if (typeof value[i] !== 'string' && typeof value[i] !== 'number') {
                    return prop + '.' + i;
                }
            }
            continue;
        }
        if (isVectorType(type)) {
            const vectorSize = getVectorSize(type);
            if (!Array.isArray(value) || value.length !== vectorSize) {
                throw errors_createError('INVALID_INPUT_VECTOR', prop, vectorSize, value.length);
            }
            continue;
        }
        if (isArrayType(type)) {
            if (!Array.isArray(value)) {
                return prop;
            }
            const expectedType = getInnerType(type);
            const valueLength = value.length;
            for (let i = 0; i < valueLength; i++) {
                if (typeof value[i] !== expectedType) {
                    return prop + '.' + i;
                }
            }
            continue;
        }
        if (typeof type === 'object') {
            if (!value || typeof value !== 'object') {
                return prop;
            }
            // using as ResultDocument is not exactly right but trying to be type-safe here is not useful
            const subProp = defaults_validateSchema(value, type);
            if (subProp) {
                return prop + '.' + subProp;
            }
            continue;
        }
        if (typeof value !== type) {
            return prop;
        }
    }
    return undefined;
}
const IS_ARRAY_TYPE = {
    string: false,
    number: false,
    boolean: false,
    enum: false,
    geopoint: false,
    'string[]': true,
    'number[]': true,
    'boolean[]': true,
    'enum[]': true
};
const INNER_TYPE = {
    'string[]': 'string',
    'number[]': 'number',
    'boolean[]': 'boolean',
    'enum[]': 'enum'
};
function isGeoPointType(type) {
    return type === 'geopoint';
}
function isVectorType(type) {
    return typeof type === 'string' && /^vector\[\d+\]$/.test(type);
}
function isArrayType(type) {
    return typeof type === 'string' && IS_ARRAY_TYPE[type];
}
function getInnerType(type) {
    return INNER_TYPE[type];
}
function getVectorSize(type) {
    const size = Number(type.slice(7, -1));
    switch (true) {
        case isNaN(size):
            throw errors_createError('INVALID_VECTOR_VALUE', type);
        case size <= 0:
            throw errors_createError('INVALID_VECTOR_SIZE', type);
        default:
            return size;
    }
}
//# sourceMappingURL=defaults.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/internal-document-id-store.js
function createInternalDocumentIDStore() {
    return {
        idToInternalId: new Map(),
        internalIdToId: [],
        save,
        load
    };
}
function save(store) {
    return {
        internalIdToId: store.internalIdToId
    };
}
function load(orama, raw) {
    const { internalIdToId } = raw;
    orama.internalDocumentIDStore.idToInternalId.clear();
    orama.internalDocumentIDStore.internalIdToId = [];
    const internalIdToIdLength = internalIdToId.length;
    for (let i = 0; i < internalIdToIdLength; i++) {
        const internalIdItem = internalIdToId[i];
        orama.internalDocumentIDStore.idToInternalId.set(internalIdItem, i + 1);
        orama.internalDocumentIDStore.internalIdToId.push(internalIdItem);
    }
}
function internal_document_id_store_getInternalDocumentId(store, id) {
    if (typeof id === 'string') {
        const internalId = store.idToInternalId.get(id);
        if (internalId) {
            return internalId;
        }
        const currentId = store.idToInternalId.size + 1;
        store.idToInternalId.set(id, currentId);
        store.internalIdToId.push(id);
        return currentId;
    }
    if (id > store.internalIdToId.length) {
        return internal_document_id_store_getInternalDocumentId(store, id.toString());
    }
    return id;
}
function internal_document_id_store_getDocumentIdFromInternalId(store, internalId) {
    if (store.internalIdToId.length < internalId) {
        throw new Error(`Invalid internalId ${internalId}`);
    }
    return store.internalIdToId[internalId - 1];
}
//# sourceMappingURL=internal-document-id-store.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/documents-store.js

function create(_, sharedInternalDocumentStore) {
    return {
        sharedInternalDocumentStore,
        docs: {},
        count: 0
    };
}
function get(store, id) {
    const internalId = internal_document_id_store_getInternalDocumentId(store.sharedInternalDocumentStore, id);
    return store.docs[internalId];
}
function getMultiple(store, ids) {
    const idsLength = ids.length;
    const found = Array.from({ length: idsLength });
    for (let i = 0; i < idsLength; i++) {
        const internalId = internal_document_id_store_getInternalDocumentId(store.sharedInternalDocumentStore, ids[i]);
        found[i] = store.docs[internalId];
    }
    return found;
}
function getAll(store) {
    return store.docs;
}
function documents_store_store(store, id, internalId, doc) {
    if (typeof store.docs[internalId] !== 'undefined') {
        return false;
    }
    store.docs[internalId] = doc;
    store.count++;
    return true;
}
function documents_store_remove(store, id) {
    const internalId = internal_document_id_store_getInternalDocumentId(store.sharedInternalDocumentStore, id);
    if (typeof store.docs[internalId] === 'undefined') {
        return false;
    }
    delete store.docs[internalId];
    store.count--;
    return true;
}
function documents_store_count(store) {
    return store.count;
}
function documents_store_load(sharedInternalDocumentStore, raw) {
    const rawDocument = raw;
    return {
        docs: rawDocument.docs,
        count: rawDocument.count,
        sharedInternalDocumentStore
    };
}
function documents_store_save(store) {
    return {
        docs: store.docs,
        count: store.count
    };
}
function createDocumentsStore() {
    return {
        create,
        get,
        getMultiple,
        getAll,
        store: documents_store_store,
        remove: documents_store_remove,
        count: documents_store_count,
        load: documents_store_load,
        save: documents_store_save
    };
}
//# sourceMappingURL=documents-store.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/plugins.js

const AVAILABLE_PLUGIN_HOOKS = [
    'beforeInsert',
    'afterInsert',
    'beforeRemove',
    'afterRemove',
    'beforeUpdate',
    'afterUpdate',
    'beforeUpsert',
    'afterUpsert',
    'beforeSearch',
    'afterSearch',
    'beforeInsertMultiple',
    'afterInsertMultiple',
    'beforeRemoveMultiple',
    'afterRemoveMultiple',
    'beforeUpdateMultiple',
    'afterUpdateMultiple',
    'beforeUpsertMultiple',
    'afterUpsertMultiple',
    'beforeLoad',
    'afterLoad',
    'afterCreate'
];
function getAllPluginsByHook(orama, hook) {
    const pluginsToRun = [];
    const pluginsLength = orama.plugins?.length;
    if (!pluginsLength) {
        return pluginsToRun;
    }
    for (let i = 0; i < pluginsLength; i++) {
        try {
            const plugin = orama.plugins[i];
            if (typeof plugin[hook] === 'function') {
                pluginsToRun.push(plugin[hook]);
            }
        }
        catch (error) {
            console.error('Caught error in getAllPluginsByHook:', error);
            throw errors_createError('PLUGIN_CRASHED');
        }
    }
    return pluginsToRun;
}
//# sourceMappingURL=plugins.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/hooks.js

const OBJECT_COMPONENTS = ['tokenizer', 'index', 'documentsStore', 'sorter', 'pinning'];
const FUNCTION_COMPONENTS = [
    'validateSchema',
    'getDocumentIndexId',
    'getDocumentProperties',
    'formatElapsedTime'
];
const SINGLE_OR_ARRAY_COMPONENTS = (/* unused pure expression or super */ null && ([
/* deprecated with v2.0.0-beta.5 */
]));
function hooks_runSingleHook(hooks, orama, id, doc) {
    const needAsync = hooks.some(utils_isAsyncFunction);
    if (needAsync) {
        return (async () => {
            for (const hook of hooks) {
                await hook(orama, id, doc);
            }
        })();
    }
    else {
        for (const hook of hooks) {
            hook(orama, id, doc);
        }
    }
}
function hooks_runMultipleHook(hooks, orama, docsOrIds) {
    const needAsync = hooks.some(utils_isAsyncFunction);
    if (needAsync) {
        return (async () => {
            for (const hook of hooks) {
                await hook(orama, docsOrIds);
            }
        })();
    }
    else {
        for (const hook of hooks) {
            hook(orama, docsOrIds);
        }
    }
}
function hooks_runAfterSearch(hooks, db, params, language, results) {
    const needAsync = hooks.some(isAsyncFunction);
    if (needAsync) {
        return (async () => {
            for (const hook of hooks) {
                await hook(db, params, language, results);
            }
        })();
    }
    else {
        for (const hook of hooks) {
            hook(db, params, language, results);
        }
    }
}
function hooks_runBeforeSearch(hooks, db, params, language) {
    const needAsync = hooks.some(isAsyncFunction);
    if (needAsync) {
        return (async () => {
            for (const hook of hooks) {
                await hook(db, params, language);
            }
        })();
    }
    else {
        for (const hook of hooks) {
            hook(db, params, language);
        }
    }
}
function runAfterCreate(hooks, db) {
    const needAsync = hooks.some(utils_isAsyncFunction);
    if (needAsync) {
        return (async () => {
            for (const hook of hooks) {
                await hook(db);
            }
        })();
    }
    else {
        for (const hook of hooks) {
            hook(db);
        }
    }
}
//# sourceMappingURL=hooks.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/trees/avl.js
class AVLNode {
    k;
    v;
    l = null;
    r = null;
    h = 1;
    constructor(key, value) {
        this.k = key;
        this.v = new Set(value);
    }
    updateHeight() {
        this.h = Math.max(AVLNode.getHeight(this.l), AVLNode.getHeight(this.r)) + 1;
    }
    static getHeight(node) {
        return node ? node.h : 0;
    }
    getBalanceFactor() {
        return AVLNode.getHeight(this.l) - AVLNode.getHeight(this.r);
    }
    rotateLeft() {
        const newRoot = this.r;
        this.r = newRoot.l;
        newRoot.l = this;
        this.updateHeight();
        newRoot.updateHeight();
        return newRoot;
    }
    rotateRight() {
        const newRoot = this.l;
        this.l = newRoot.r;
        newRoot.r = this;
        this.updateHeight();
        newRoot.updateHeight();
        return newRoot;
    }
    toJSON() {
        return {
            k: this.k,
            v: Array.from(this.v),
            l: this.l ? this.l.toJSON() : null,
            r: this.r ? this.r.toJSON() : null,
            h: this.h
        };
    }
    static fromJSON(json) {
        const node = new AVLNode(json.k, json.v);
        node.l = json.l ? AVLNode.fromJSON(json.l) : null;
        node.r = json.r ? AVLNode.fromJSON(json.r) : null;
        node.h = json.h;
        return node;
    }
}
class AVLTree {
    root = null;
    insertCount = 0;
    constructor(key, value) {
        if (key !== undefined && value !== undefined) {
            this.root = new AVLNode(key, value);
        }
    }
    insert(key, value, rebalanceThreshold = 1000) {
        this.root = this.insertNode(this.root, key, value, rebalanceThreshold);
    }
    insertMultiple(key, value, rebalanceThreshold = 1000) {
        for (const v of value) {
            this.insert(key, v, rebalanceThreshold);
        }
    }
    // Rebalance the tree if the insert count reaches the threshold.
    // This will improve insertion performance since we won't be rebalancing the tree on every insert.
    // When inserting docs using `insertMultiple`, the threshold will be set to the number of docs being inserted.
    // We can force rebalancing the tree by setting the threshold to 1 (default).
    rebalance() {
        if (this.root) {
            this.root = this.rebalanceNode(this.root);
        }
    }
    toJSON() {
        return {
            root: this.root ? this.root.toJSON() : null,
            insertCount: this.insertCount
        };
    }
    static fromJSON(json) {
        const tree = new AVLTree();
        tree.root = json.root ? AVLNode.fromJSON(json.root) : null;
        tree.insertCount = json.insertCount || 0;
        return tree;
    }
    insertNode(node, key, value, rebalanceThreshold) {
        if (node === null) {
            return new AVLNode(key, [value]);
        }
        const path = [];
        let current = node;
        let parent = null;
        while (current !== null) {
            path.push({ parent, node: current });
            if (key < current.k) {
                if (current.l === null) {
                    current.l = new AVLNode(key, [value]);
                    path.push({ parent: current, node: current.l });
                    break;
                }
                else {
                    parent = current;
                    current = current.l;
                }
            }
            else if (key > current.k) {
                if (current.r === null) {
                    current.r = new AVLNode(key, [value]);
                    path.push({ parent: current, node: current.r });
                    break;
                }
                else {
                    parent = current;
                    current = current.r;
                }
            }
            else {
                // Key already exists
                current.v.add(value);
                /*
                if (Array.isArray(current.v)) {
                  if (Array.isArray(value)) {
                    ;(current.v as any[]).push(...(value as V[]))
                  } else {
                    ;(current.v as any[]).push(value)
                  }
                } else {
                  current.v = new Set([value])
                }
                */
                return node;
            }
        }
        // Update heights and rebalance if necessary
        let needRebalance = false;
        if (this.insertCount++ % rebalanceThreshold === 0) {
            needRebalance = true;
        }
        for (let i = path.length - 1; i >= 0; i--) {
            const { parent, node: currentNode } = path[i];
            currentNode.updateHeight();
            if (needRebalance) {
                const rebalancedNode = this.rebalanceNode(currentNode);
                if (parent) {
                    if (parent.l === currentNode) {
                        parent.l = rebalancedNode;
                    }
                    else if (parent.r === currentNode) {
                        parent.r = rebalancedNode;
                    }
                }
                else {
                    // This is the root node
                    node = rebalancedNode;
                }
            }
        }
        return node;
    }
    rebalanceNode(node) {
        const balanceFactor = node.getBalanceFactor();
        if (balanceFactor > 1) {
            // Left heavy
            if (node.l && node.l.getBalanceFactor() >= 0) {
                // Left Left Case
                return node.rotateRight();
            }
            else if (node.l) {
                // Left Right Case
                node.l = node.l.rotateLeft();
                return node.rotateRight();
            }
        }
        if (balanceFactor < -1) {
            // Right heavy
            if (node.r && node.r.getBalanceFactor() <= 0) {
                // Right Right Case
                return node.rotateLeft();
            }
            else if (node.r) {
                // Right Left Case
                node.r = node.r.rotateRight();
                return node.rotateLeft();
            }
        }
        return node;
    }
    find(key) {
        const node = this.findNodeByKey(key);
        return node ? node.v : null;
    }
    contains(key) {
        return this.find(key) !== null;
    }
    getSize() {
        let count = 0;
        const stack = [];
        let current = this.root;
        while (current || stack.length > 0) {
            while (current) {
                stack.push(current);
                current = current.l;
            }
            current = stack.pop();
            count++;
            current = current.r;
        }
        return count;
    }
    isBalanced() {
        if (!this.root)
            return true;
        const stack = [this.root];
        while (stack.length > 0) {
            const node = stack.pop();
            const balanceFactor = node.getBalanceFactor();
            if (Math.abs(balanceFactor) > 1) {
                return false;
            }
            if (node.l)
                stack.push(node.l);
            if (node.r)
                stack.push(node.r);
        }
        return true;
    }
    remove(key) {
        this.root = this.removeNode(this.root, key);
    }
    removeDocument(key, id) {
        const node = this.findNodeByKey(key);
        if (!node) {
            return;
        }
        if (node.v.size === 1) {
            this.root = this.removeNode(this.root, key);
        }
        else {
            node.v = new Set([...node.v.values()].filter((v) => v !== id));
        }
    }
    findNodeByKey(key) {
        let node = this.root;
        while (node) {
            if (key < node.k) {
                node = node.l;
            }
            else if (key > node.k) {
                node = node.r;
            }
            else {
                return node;
            }
        }
        return null;
    }
    removeNode(node, key) {
        if (node === null)
            return null;
        const path = [];
        let current = node;
        while (current !== null && current.k !== key) {
            path.push(current);
            if (key < current.k) {
                current = current.l;
            }
            else {
                current = current.r;
            }
        }
        if (current === null) {
            // Key not found
            return node;
        }
        // Node with only one child or no child
        if (current.l === null || current.r === null) {
            const child = current.l ? current.l : current.r;
            if (path.length === 0) {
                // Node to be deleted is root
                node = child;
            }
            else {
                const parent = path[path.length - 1];
                if (parent.l === current) {
                    parent.l = child;
                }
                else {
                    parent.r = child;
                }
            }
        }
        else {
            // Node with two children: Get the inorder successor
            let successorParent = current;
            let successor = current.r;
            while (successor.l !== null) {
                successorParent = successor;
                successor = successor.l;
            }
            // Copy the successor's content to current node
            current.k = successor.k;
            current.v = successor.v;
            // Delete the successor
            if (successorParent.l === successor) {
                successorParent.l = successor.r;
            }
            else {
                successorParent.r = successor.r;
            }
            current = successorParent;
        }
        // Update heights and rebalance
        path.push(current);
        for (let i = path.length - 1; i >= 0; i--) {
            const currentNode = path[i];
            currentNode.updateHeight();
            const rebalancedNode = this.rebalanceNode(currentNode);
            if (i > 0) {
                const parent = path[i - 1];
                if (parent.l === currentNode) {
                    parent.l = rebalancedNode;
                }
                else if (parent.r === currentNode) {
                    parent.r = rebalancedNode;
                }
            }
            else {
                // Root node
                node = rebalancedNode;
            }
        }
        return node;
    }
    rangeSearch(min, max) {
        const result = new Set();
        const stack = [];
        let current = this.root;
        while (current || stack.length > 0) {
            while (current) {
                stack.push(current);
                current = current.l;
            }
            current = stack.pop();
            if (current.k >= min && current.k <= max) {
                for (const value of current.v) {
                    result.add(value);
                }
            }
            if (current.k > max) {
                break;
            }
            current = current.r;
        }
        return result;
    }
    greaterThan(key, inclusive = false) {
        const result = new Set();
        const stack = [];
        let current = this.root;
        while (current || stack.length > 0) {
            while (current) {
                stack.push(current);
                current = current.r; // Traverse right subtree first
            }
            current = stack.pop();
            if ((inclusive && current.k >= key) || (!inclusive && current.k > key)) {
                for (const value of current.v) {
                    result.add(value);
                }
            }
            else if (current.k <= key) {
                break; // Since we're traversing in descending order, we can break early
            }
            current = current.l;
        }
        return result;
    }
    lessThan(key, inclusive = false) {
        const result = new Set();
        const stack = [];
        let current = this.root;
        while (current || stack.length > 0) {
            while (current) {
                stack.push(current);
                current = current.l;
            }
            current = stack.pop();
            if ((inclusive && current.k <= key) || (!inclusive && current.k < key)) {
                for (const value of current.v) {
                    result.add(value);
                }
            }
            else if (current.k > key) {
                break; // Since we're traversing in ascending order, we can break early
            }
            current = current.r;
        }
        return result;
    }
}
//# sourceMappingURL=avl.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/trees/flat.js
class FlatTree {
    numberToDocumentId;
    constructor() {
        this.numberToDocumentId = new Map();
    }
    insert(key, value) {
        if (this.numberToDocumentId.has(key)) {
            this.numberToDocumentId.get(key).add(value);
        }
        else {
            this.numberToDocumentId.set(key, new Set([value]));
        }
    }
    find(key) {
        const idSet = this.numberToDocumentId.get(key);
        return idSet ? Array.from(idSet) : null;
    }
    remove(key) {
        this.numberToDocumentId.delete(key);
    }
    removeDocument(id, key) {
        const idSet = this.numberToDocumentId.get(key);
        if (idSet) {
            idSet.delete(id);
            if (idSet.size === 0) {
                this.numberToDocumentId.delete(key);
            }
        }
    }
    contains(key) {
        return this.numberToDocumentId.has(key);
    }
    getSize() {
        let size = 0;
        for (const idSet of this.numberToDocumentId.values()) {
            size += idSet.size;
        }
        return size;
    }
    filter(operation) {
        const operationKeys = Object.keys(operation);
        if (operationKeys.length !== 1) {
            throw new Error('Invalid operation');
        }
        const operationType = operationKeys[0];
        switch (operationType) {
            case 'eq': {
                const value = operation[operationType];
                const idSet = this.numberToDocumentId.get(value);
                return idSet ? Array.from(idSet) : [];
            }
            case 'in': {
                const values = operation[operationType];
                const resultSet = new Set();
                for (const value of values) {
                    const idSet = this.numberToDocumentId.get(value);
                    if (idSet) {
                        for (const id of idSet) {
                            resultSet.add(id);
                        }
                    }
                }
                return Array.from(resultSet);
            }
            case 'nin': {
                const excludeValues = new Set(operation[operationType]);
                const resultSet = new Set();
                for (const [key, idSet] of this.numberToDocumentId.entries()) {
                    if (!excludeValues.has(key)) {
                        for (const id of idSet) {
                            resultSet.add(id);
                        }
                    }
                }
                return Array.from(resultSet);
            }
            default:
                throw new Error('Invalid operation');
        }
    }
    filterArr(operation) {
        const operationKeys = Object.keys(operation);
        if (operationKeys.length !== 1) {
            throw new Error('Invalid operation');
        }
        const operationType = operationKeys[0];
        switch (operationType) {
            case 'containsAll': {
                const values = operation[operationType];
                const idSets = values.map((value) => this.numberToDocumentId.get(value) ?? new Set());
                if (idSets.length === 0)
                    return [];
                const intersection = idSets.reduce((prev, curr) => {
                    return new Set([...prev].filter((id) => curr.has(id)));
                });
                return Array.from(intersection);
            }
            case 'containsAny': {
                const values = operation[operationType];
                const idSets = values.map((value) => this.numberToDocumentId.get(value) ?? new Set());
                if (idSets.length === 0)
                    return [];
                const union = idSets.reduce((prev, curr) => {
                    return new Set([...prev, ...curr]);
                });
                return Array.from(union);
            }
            default:
                throw new Error('Invalid operation');
        }
    }
    static fromJSON(json) {
        if (!json.numberToDocumentId) {
            throw new Error('Invalid Flat Tree JSON');
        }
        const tree = new FlatTree();
        for (const [key, ids] of json.numberToDocumentId) {
            tree.numberToDocumentId.set(key, new Set(ids));
        }
        return tree;
    }
    toJSON() {
        return {
            numberToDocumentId: Array.from(this.numberToDocumentId.entries()).map(([key, idSet]) => [key, Array.from(idSet)])
        };
    }
}
//# sourceMappingURL=flat.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/levenshtein.js
/**
 * Inspired by:
 * https://github.com/Yomguithereal/talisman/blob/86ae55cbd040ff021d05e282e0e6c71f2dde21f8/src/metrics/levenshtein.js#L218-L340
 */
function _boundedLevenshtein(term, word, tolerance) {
    // Handle base cases
    if (tolerance < 0)
        return -1;
    if (term === word)
        return 0;
    const m = term.length;
    const n = word.length;
    // Special case for empty strings
    if (m === 0)
        return n <= tolerance ? n : -1;
    if (n === 0)
        return m <= tolerance ? m : -1;
    // term = term.toLowerCase()
    // word = word.toLowerCase()
    const diff = Math.abs(m - n);
    // Special case for prefixes
    // If the searching word starts with the indexed word, return early.
    if (term.startsWith(word)) {
        // We just check if the remaining characters are within the tolerance
        return diff <= tolerance ? diff : -1;
    }
    // If the indexed word starts with the searching word, return early.
    if (word.startsWith(term)) {
        // any prefixed word is within the tolerance
        return 0;
    }
    // If the length difference is greater than the tolerance, return early
    if (diff > tolerance)
        return -1;
    // Initialize the matrix
    const matrix = [];
    for (let i = 0; i <= m; i++) {
        matrix[i] = [i];
        for (let j = 1; j <= n; j++) {
            matrix[i][j] = i === 0 ? j : 0;
        }
    }
    // Fill the matrix
    for (let i = 1; i <= m; i++) {
        let rowMin = Infinity;
        for (let j = 1; j <= n; j++) {
            if (term[i - 1] === word[j - 1]) {
                matrix[i][j] = matrix[i - 1][j - 1];
            }
            else {
                matrix[i][j] = Math.min(matrix[i - 1][j] + 1, // deletion
                matrix[i][j - 1] + 1, // insertion
                matrix[i - 1][j - 1] + 1 // substitution
                );
            }
            rowMin = Math.min(rowMin, matrix[i][j]);
        }
        // Early termination if all values in this row exceed tolerance
        if (rowMin > tolerance) {
            return -1;
        }
    }
    return matrix[m][n] <= tolerance ? matrix[m][n] : -1;
}
/**
 * Computes the Levenshtein distance between two strings (a, b), returning early with -1 if the distance
 * is greater than the given tolerance.
 * It assumes that:
 * - tolerance >= ||a| - |b|| >= 0
 */
function boundedLevenshtein(term, w, tolerance) {
    const distance = _boundedLevenshtein(term, w, tolerance);
    return {
        distance,
        isBounded: distance >= 0
    };
}
// This is only used internally, keep in sync with the previous one
function syncBoundedLevenshtein(term, w, tolerance) {
    const distance = _boundedLevenshtein(term, w, tolerance);
    return {
        distance,
        isBounded: distance >= 0
    };
}
function levenshtein(a, b) {
    /* c8 ignore next 3 */
    if (!a.length) {
        return b.length;
    }
    /* c8 ignore next 3 */
    if (!b.length) {
        return a.length;
    }
    const swap = a;
    if (a.length > b.length) {
        a = b;
        b = swap;
    }
    const row = Array.from({ length: a.length + 1 }, (_, i) => i);
    let val = 0;
    for (let i = 1; i <= b.length; i++) {
        let prev = i;
        for (let j = 1; j <= a.length; j++) {
            if (b[i - 1] === a[j - 1]) {
                val = row[j - 1];
            }
            else {
                val = Math.min(row[j - 1] + 1, Math.min(prev + 1, row[j] + 1));
            }
            row[j - 1] = prev;
            prev = val;
        }
        row[a.length] = prev;
    }
    return row[a.length];
}
//# sourceMappingURL=levenshtein.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/trees/radix.js
/* eslint-disable @typescript-eslint/no-this-alias */


class RadixNode {
    // Node key
    k;
    // Node subword
    s;
    // Node children
    c = new Map();
    // Node documents
    d = new Set();
    // Node end
    e;
    // Node word
    w = '';
    constructor(key, subWord, end) {
        this.k = key;
        this.s = subWord;
        this.e = end;
    }
    updateParent(parent) {
        this.w = parent.w + this.s;
    }
    addDocument(docID) {
        this.d.add(docID);
    }
    removeDocument(docID) {
        return this.d.delete(docID);
    }
    findAllWords(output, term, exact, tolerance) {
        const stack = [this];
        while (stack.length > 0) {
            const node = stack.pop();
            if (node.e) {
                const { w, d: docIDs } = node;
                if (exact && w !== term) {
                    continue;
                }
                // check if _output[w] exists and then add the doc to it
                // always check in own property to prevent access to inherited properties
                // fix https://github.com/oramasearch/orama/issues/137
                if (getOwnProperty(output, w) !== null) {
                    if (tolerance) {
                        const difference = Math.abs(term.length - w.length);
                        if (difference <= tolerance && syncBoundedLevenshtein(term, w, tolerance).isBounded) {
                            output[w] = [];
                        }
                        else {
                            continue;
                        }
                    }
                    else {
                        output[w] = [];
                    }
                }
                // check if _output[w] exists and then add the doc to it
                // always check in own property to prevent access to inherited properties
                // fix https://github.com/oramasearch/orama/issues/137
                if (getOwnProperty(output, w) != null && docIDs.size > 0) {
                    const docs = output[w];
                    for (const docID of docIDs) {
                        if (!docs.includes(docID)) {
                            docs.push(docID);
                        }
                    }
                }
            }
            if (node.c.size > 0) {
                stack.push(...node.c.values());
            }
        }
        return output;
    }
    insert(word, docId) {
        let node = this;
        let i = 0;
        const wordLength = word.length;
        while (i < wordLength) {
            const currentCharacter = word[i];
            const childNode = node.c.get(currentCharacter);
            if (childNode) {
                const edgeLabel = childNode.s;
                const edgeLabelLength = edgeLabel.length;
                let j = 0;
                // Find the common prefix length between edgeLabel and the remaining word
                while (j < edgeLabelLength && i + j < wordLength && edgeLabel[j] === word[i + j]) {
                    j++;
                }
                if (j === edgeLabelLength) {
                    // Edge label fully matches; proceed to the child node
                    node = childNode;
                    i += j;
                    if (i === wordLength) {
                        // The word is a prefix of an existing word
                        if (!childNode.e) {
                            childNode.e = true;
                        }
                        childNode.addDocument(docId);
                        return;
                    }
                    continue;
                }
                // Split the edgeLabel at the common prefix
                const commonPrefix = edgeLabel.slice(0, j);
                const newEdgeLabel = edgeLabel.slice(j);
                const newWordLabel = word.slice(i + j);
                // Create an intermediate node for the common prefix
                const inbetweenNode = new RadixNode(commonPrefix[0], commonPrefix, false);
                node.c.set(commonPrefix[0], inbetweenNode);
                inbetweenNode.updateParent(node);
                // Update the existing childNode
                childNode.s = newEdgeLabel;
                childNode.k = newEdgeLabel[0];
                inbetweenNode.c.set(newEdgeLabel[0], childNode);
                childNode.updateParent(inbetweenNode);
                if (newWordLabel) {
                    // Create a new node for the remaining part of the word
                    const newNode = new RadixNode(newWordLabel[0], newWordLabel, true);
                    newNode.addDocument(docId);
                    inbetweenNode.c.set(newWordLabel[0], newNode);
                    newNode.updateParent(inbetweenNode);
                }
                else {
                    // The word ends at the inbetweenNode
                    inbetweenNode.e = true;
                    inbetweenNode.addDocument(docId);
                }
                return;
            }
            else {
                // No matching child; create a new node
                const newNode = new RadixNode(currentCharacter, word.slice(i), true);
                newNode.addDocument(docId);
                node.c.set(currentCharacter, newNode);
                newNode.updateParent(node);
                return;
            }
        }
        // If we reach here, the word already exists in the tree
        if (!node.e) {
            node.e = true;
        }
        node.addDocument(docId);
    }
    _findLevenshtein(term, index, tolerance, originalTolerance, output) {
        const stack = [{ node: this, index, tolerance }];
        while (stack.length > 0) {
            const { node, index, tolerance } = stack.pop();
            if (node.w.startsWith(term)) {
                node.findAllWords(output, term, false, 0);
                continue;
            }
            if (tolerance < 0) {
                continue;
            }
            if (node.e) {
                const { w, d: docIDs } = node;
                if (w) {
                    if (syncBoundedLevenshtein(term, w, originalTolerance).isBounded) {
                        output[w] = [];
                    }
                    if (getOwnProperty(output, w) !== undefined && docIDs.size > 0) {
                        const docs = new Set(output[w]);
                        for (const docID of docIDs) {
                            docs.add(docID);
                        }
                        output[w] = Array.from(docs);
                    }
                }
            }
            if (index >= term.length) {
                continue;
            }
            const currentChar = term[index];
            // 1. If node has child matching term[index], push { node: childNode, index +1, tolerance }
            if (node.c.has(currentChar)) {
                const childNode = node.c.get(currentChar);
                stack.push({ node: childNode, index: index + 1, tolerance });
            }
            // 2. Push { node, index +1, tolerance -1 } (Delete operation)
            stack.push({ node: node, index: index + 1, tolerance: tolerance - 1 });
            // 3. For each child:
            for (const [character, childNode] of node.c) {
                // a) Insert operation
                stack.push({ node: childNode, index: index, tolerance: tolerance - 1 });
                // b) Substitute operation
                if (character !== currentChar) {
                    stack.push({ node: childNode, index: index + 1, tolerance: tolerance - 1 });
                }
            }
        }
    }
    find(params) {
        const { term, exact, tolerance } = params;
        if (tolerance && !exact) {
            const output = {};
            this._findLevenshtein(term, 0, tolerance, tolerance, output);
            return output;
        }
        else {
            let node = this;
            let i = 0;
            const termLength = term.length;
            while (i < termLength) {
                const character = term[i];
                const childNode = node.c.get(character);
                if (childNode) {
                    const edgeLabel = childNode.s;
                    const edgeLabelLength = edgeLabel.length;
                    let j = 0;
                    // Compare edge label with the term starting from position i
                    while (j < edgeLabelLength && i + j < termLength && edgeLabel[j] === term[i + j]) {
                        j++;
                    }
                    if (j === edgeLabelLength) {
                        // Full match of edge label; proceed to the child node
                        node = childNode;
                        i += j;
                    }
                    else if (i + j === termLength) {
                        // The term ends in the middle of the edge label - FIX: this handles prefix matches like 'p' matching 'phone'
                        // Check if the term matches from the beginning of the edge label
                        if (j === termLength - i) {
                            // Term is a prefix of the edge label
                            if (exact) {
                                // Exact match required but term doesn't end at a node
                                return {};
                            }
                            else {
                                // Partial match; collect words starting from this node
                                const output = {};
                                // Just call findAllWords on the child node to collect all words in this subtree
                                childNode.findAllWords(output, term, exact, tolerance);
                                return output;
                            }
                        }
                        else {
                            // Mismatch found
                            return {};
                        }
                    }
                    else {
                        // Mismatch found
                        return {};
                    }
                }
                else {
                    // No matching child node
                    return {};
                }
            }
            // Term fully matched; collect words starting from this node
            const output = {};
            node.findAllWords(output, term, exact, tolerance);
            return output;
        }
    }
    contains(term) {
        let node = this;
        let i = 0;
        const termLength = term.length;
        while (i < termLength) {
            const character = term[i];
            const childNode = node.c.get(character);
            if (childNode) {
                const edgeLabel = childNode.s;
                const edgeLabelLength = edgeLabel.length;
                let j = 0;
                while (j < edgeLabelLength && i + j < termLength && edgeLabel[j] === term[i + j]) {
                    j++;
                }
                if (j < edgeLabelLength) {
                    return false;
                }
                i += edgeLabelLength;
                node = childNode;
            }
            else {
                return false;
            }
        }
        return true;
    }
    removeWord(term) {
        if (!term) {
            return false;
        }
        let node = this;
        const termLength = term.length;
        const stack = [];
        for (let i = 0; i < termLength; i++) {
            const character = term[i];
            if (node.c.has(character)) {
                const childNode = node.c.get(character);
                stack.push({ parent: node, character });
                i += childNode.s.length - 1;
                node = childNode;
            }
            else {
                return false;
            }
        }
        // Remove documents from the node
        node.d.clear();
        node.e = false;
        // Clean up any nodes that no longer lead to a word
        while (stack.length > 0 && node.c.size === 0 && !node.e && node.d.size === 0) {
            const { parent, character } = stack.pop();
            parent.c.delete(character);
            node = parent;
        }
        return true;
    }
    removeDocumentByWord(term, docID, exact = true) {
        if (!term) {
            return true;
        }
        let node = this;
        const termLength = term.length;
        for (let i = 0; i < termLength; i++) {
            const character = term[i];
            if (node.c.has(character)) {
                const childNode = node.c.get(character);
                i += childNode.s.length - 1;
                node = childNode;
                if (exact && node.w !== term) {
                    // Do nothing if the exact condition is not met.
                }
                else {
                    node.removeDocument(docID);
                }
            }
            else {
                return false;
            }
        }
        return true;
    }
    static getCommonPrefix(a, b) {
        const len = Math.min(a.length, b.length);
        let i = 0;
        while (i < len && a.charCodeAt(i) === b.charCodeAt(i)) {
            i++;
        }
        return a.slice(0, i);
    }
    toJSON() {
        return {
            w: this.w,
            s: this.s,
            e: this.e,
            k: this.k,
            d: Array.from(this.d),
            c: Array.from(this.c?.entries())?.map(([key, node]) => [key, node.toJSON()])
        };
    }
    static fromJSON(json) {
        const node = new RadixNode(json.k, json.s, json.e);
        node.w = json.w;
        node.d = new Set(json.d);
        node.c = new Map(json?.c?.map(([key, nodeJson]) => [key, RadixNode.fromJSON(nodeJson)]) || []);
        return node;
    }
}
class RadixTree extends RadixNode {
    constructor() {
        super('', '', false);
    }
    static fromJSON(json) {
        const tree = new RadixTree();
        tree.w = json.w;
        tree.s = json.s;
        tree.e = json.e;
        tree.k = json.k;
        tree.d = new Set(json.d);
        tree.c = new Map(json?.c?.map(([key, nodeJson]) => [key, RadixNode.fromJSON(nodeJson)]) || []);
        return tree;
    }
    toJSON() {
        return super.toJSON();
    }
}
//# sourceMappingURL=radix.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/trees/bkd.js
const K = 2; // 2D points
const EARTH_RADIUS = 6371e3; // Earth radius in meters
class BKDNode {
    point;
    docIDs;
    left;
    right;
    parent;
    constructor(point, docIDs) {
        this.point = point;
        this.docIDs = new Set(docIDs);
        this.left = null;
        this.right = null;
        this.parent = null;
    }
    toJSON() {
        return {
            point: this.point,
            docIDs: Array.from(this.docIDs),
            left: this.left ? this.left.toJSON() : null,
            right: this.right ? this.right.toJSON() : null
        };
    }
    static fromJSON(json, parent = null) {
        const node = new BKDNode(json.point, json.docIDs);
        node.parent = parent;
        if (json.left) {
            node.left = BKDNode.fromJSON(json.left, node);
        }
        if (json.right) {
            node.right = BKDNode.fromJSON(json.right, node);
        }
        return node;
    }
}
class bkd_BKDTree {
    root;
    nodeMap;
    constructor() {
        this.root = null;
        this.nodeMap = new Map();
    }
    getPointKey(point) {
        return `${point.lon},${point.lat}`;
    }
    insert(point, docIDs) {
        const pointKey = this.getPointKey(point);
        const existingNode = this.nodeMap.get(pointKey);
        if (existingNode) {
            docIDs.forEach((id) => existingNode.docIDs.add(id));
            return;
        }
        const newNode = new BKDNode(point, docIDs);
        this.nodeMap.set(pointKey, newNode);
        if (this.root == null) {
            this.root = newNode;
            return;
        }
        let node = this.root;
        let depth = 0;
        // eslint-disable-next-line no-constant-condition
        while (true) {
            const axis = depth % K;
            if (axis === 0) {
                if (point.lon < node.point.lon) {
                    if (node.left == null) {
                        node.left = newNode;
                        newNode.parent = node;
                        return;
                    }
                    node = node.left;
                }
                else {
                    if (node.right == null) {
                        node.right = newNode;
                        newNode.parent = node;
                        return;
                    }
                    node = node.right;
                }
            }
            else {
                if (point.lat < node.point.lat) {
                    if (node.left == null) {
                        node.left = newNode;
                        newNode.parent = node;
                        return;
                    }
                    node = node.left;
                }
                else {
                    if (node.right == null) {
                        node.right = newNode;
                        newNode.parent = node;
                        return;
                    }
                    node = node.right;
                }
            }
            depth++;
        }
    }
    contains(point) {
        const pointKey = this.getPointKey(point);
        return this.nodeMap.has(pointKey);
    }
    getDocIDsByCoordinates(point) {
        const pointKey = this.getPointKey(point);
        const node = this.nodeMap.get(pointKey);
        if (node) {
            return Array.from(node.docIDs);
        }
        return null;
    }
    removeDocByID(point, docID) {
        const pointKey = this.getPointKey(point);
        const node = this.nodeMap.get(pointKey);
        if (node) {
            node.docIDs.delete(docID);
            if (node.docIDs.size === 0) {
                this.nodeMap.delete(pointKey);
                this.deleteNode(node);
            }
        }
    }
    deleteNode(node) {
        const parent = node.parent;
        const child = node.left ? node.left : node.right;
        if (child) {
            child.parent = parent;
        }
        if (parent) {
            if (parent.left === node) {
                parent.left = child;
            }
            else if (parent.right === node) {
                parent.right = child;
            }
        }
        else {
            this.root = child;
            if (this.root) {
                this.root.parent = null;
            }
        }
    }
    searchByRadius(center, radius, inclusive = true, sort = 'asc', highPrecision = false) {
        const distanceFn = highPrecision ? bkd_BKDTree.vincentyDistance : bkd_BKDTree.haversineDistance;
        const stack = [{ node: this.root, depth: 0 }];
        const result = [];
        while (stack.length > 0) {
            const { node, depth } = stack.pop();
            if (node == null)
                continue;
            const dist = distanceFn(center, node.point);
            if (inclusive ? dist <= radius : dist > radius) {
                result.push({ point: node.point, docIDs: Array.from(node.docIDs) });
            }
            if (node.left != null) {
                stack.push({ node: node.left, depth: depth + 1 });
            }
            if (node.right != null) {
                stack.push({ node: node.right, depth: depth + 1 });
            }
        }
        if (sort) {
            result.sort((a, b) => {
                const distA = distanceFn(center, a.point);
                const distB = distanceFn(center, b.point);
                return sort.toLowerCase() === 'asc' ? distA - distB : distB - distA;
            });
        }
        return result;
    }
    searchByPolygon(polygon, inclusive = true, sort = null, highPrecision = false) {
        const stack = [{ node: this.root, depth: 0 }];
        const result = [];
        while (stack.length > 0) {
            const { node, depth } = stack.pop();
            if (node == null)
                continue;
            if (node.left != null) {
                stack.push({ node: node.left, depth: depth + 1 });
            }
            if (node.right != null) {
                stack.push({ node: node.right, depth: depth + 1 });
            }
            const isInsidePolygon = bkd_BKDTree.isPointInPolygon(polygon, node.point);
            if ((isInsidePolygon && inclusive) || (!isInsidePolygon && !inclusive)) {
                result.push({ point: node.point, docIDs: Array.from(node.docIDs) });
            }
        }
        const centroid = bkd_BKDTree.calculatePolygonCentroid(polygon);
        if (sort) {
            const distanceFn = highPrecision ? bkd_BKDTree.vincentyDistance : bkd_BKDTree.haversineDistance;
            result.sort((a, b) => {
                const distA = distanceFn(centroid, a.point);
                const distB = distanceFn(centroid, b.point);
                return sort.toLowerCase() === 'asc' ? distA - distB : distB - distA;
            });
        }
        return result;
    }
    toJSON() {
        return {
            root: this.root ? this.root.toJSON() : null
        };
    }
    static fromJSON(json) {
        const tree = new bkd_BKDTree();
        if (json.root) {
            tree.root = BKDNode.fromJSON(json.root);
            tree.buildNodeMap(tree.root);
        }
        return tree;
    }
    buildNodeMap(node) {
        if (node == null)
            return;
        const pointKey = this.getPointKey(node.point);
        this.nodeMap.set(pointKey, node);
        if (node.left) {
            this.buildNodeMap(node.left);
        }
        if (node.right) {
            this.buildNodeMap(node.right);
        }
    }
    static calculatePolygonCentroid(polygon) {
        let totalArea = 0;
        let centroidX = 0;
        let centroidY = 0;
        const polygonLength = polygon.length;
        for (let i = 0, j = polygonLength - 1; i < polygonLength; j = i++) {
            const xi = polygon[i].lon;
            const yi = polygon[i].lat;
            const xj = polygon[j].lon;
            const yj = polygon[j].lat;
            const areaSegment = xi * yj - xj * yi;
            totalArea += areaSegment;
            centroidX += (xi + xj) * areaSegment;
            centroidY += (yi + yj) * areaSegment;
        }
        totalArea /= 2;
        const centroidCoordinate = 6 * totalArea;
        centroidX /= centroidCoordinate;
        centroidY /= centroidCoordinate;
        return { lon: centroidX, lat: centroidY };
    }
    static isPointInPolygon(polygon, point) {
        let isInside = false;
        const x = point.lon;
        const y = point.lat;
        const polygonLength = polygon.length;
        for (let i = 0, j = polygonLength - 1; i < polygonLength; j = i++) {
            const xi = polygon[i].lon;
            const yi = polygon[i].lat;
            const xj = polygon[j].lon;
            const yj = polygon[j].lat;
            const intersect = yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;
            if (intersect)
                isInside = !isInside;
        }
        return isInside;
    }
    static haversineDistance(coord1, coord2) {
        const P = Math.PI / 180;
        const lat1 = coord1.lat * P;
        const lat2 = coord2.lat * P;
        const deltaLat = (coord2.lat - coord1.lat) * P;
        const deltaLon = (coord2.lon - coord1.lon) * P;
        const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
            Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return EARTH_RADIUS * c;
    }
    static vincentyDistance(coord1, coord2) {
        const a = 6378137;
        const f = 1 / 298.257223563;
        const b = (1 - f) * a;
        const P = Math.PI / 180;
        const lat1 = coord1.lat * P;
        const lat2 = coord2.lat * P;
        const deltaLon = (coord2.lon - coord1.lon) * P;
        const U1 = Math.atan((1 - f) * Math.tan(lat1));
        const U2 = Math.atan((1 - f) * Math.tan(lat2));
        const sinU1 = Math.sin(U1);
        const cosU1 = Math.cos(U1);
        const sinU2 = Math.sin(U2);
        const cosU2 = Math.cos(U2);
        let lambda = deltaLon;
        let prevLambda;
        let iterationLimit = 1000;
        let sinSigma;
        let cosSigma;
        let sigma;
        let sinAlpha;
        let cos2Alpha;
        let cos2SigmaM;
        do {
            const sinLambda = Math.sin(lambda);
            const cosLambda = Math.cos(lambda);
            sinSigma = Math.sqrt(cosU2 * sinLambda * (cosU2 * sinLambda) +
                (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));
            if (sinSigma === 0)
                return 0; // co-incident points
            cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
            sigma = Math.atan2(sinSigma, cosSigma);
            sinAlpha = (cosU1 * cosU2 * sinLambda) / sinSigma;
            cos2Alpha = 1 - sinAlpha * sinAlpha;
            cos2SigmaM = cosSigma - (2 * sinU1 * sinU2) / cos2Alpha;
            if (isNaN(cos2SigmaM))
                cos2SigmaM = 0;
            const C = (f / 16) * cos2Alpha * (4 + f * (4 - 3 * cos2Alpha));
            prevLambda = lambda;
            lambda =
                deltaLon +
                    (1 - C) *
                        f *
                        sinAlpha *
                        (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
        } while (Math.abs(lambda - prevLambda) > 1e-12 && --iterationLimit > 0);
        if (iterationLimit === 0) {
            return NaN;
        }
        const uSquared = (cos2Alpha * (a * a - b * b)) / (b * b);
        const A = 1 + (uSquared / 16384) * (4096 + uSquared * (-768 + uSquared * (320 - 175 * uSquared)));
        const B = (uSquared / 1024) * (256 + uSquared * (-128 + uSquared * (74 - 47 * uSquared)));
        const deltaSigma = B *
            sinSigma *
            (cos2SigmaM +
                (B / 4) *
                    (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) -
                        (B / 6) * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
        const s = b * A * (sigma - deltaSigma);
        return s;
    }
}
//# sourceMappingURL=bkd.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/trees/bool.js
class BoolNode {
    true;
    false;
    constructor() {
        this.true = new Set();
        this.false = new Set();
    }
    insert(value, bool) {
        if (bool) {
            this.true.add(value);
        }
        else {
            this.false.add(value);
        }
    }
    delete(value, bool) {
        if (bool) {
            this.true.delete(value);
        }
        else {
            this.false.delete(value);
        }
    }
    getSize() {
        return this.true.size + this.false.size;
    }
    toJSON() {
        return {
            true: Array.from(this.true),
            false: Array.from(this.false)
        };
    }
    static fromJSON(json) {
        const node = new BoolNode();
        node.true = new Set(json.true);
        node.false = new Set(json.false);
        return node;
    }
}
//# sourceMappingURL=bool.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/algorithms.js

function prioritizeTokenScores(arrays, boost, threshold = 0, keywordsCount) {
    if (boost === 0) {
        throw createError('INVALID_BOOST_VALUE');
    }
    const tokenScoresMap = new Map();
    const mapsLength = arrays.length;
    for (let i = 0; i < mapsLength; i++) {
        const arr = arrays[i];
        const entriesLength = arr.length;
        for (let j = 0; j < entriesLength; j++) {
            const [token, score] = arr[j];
            const boostScore = score * boost;
            const oldScore = tokenScoresMap.get(token)?.[0];
            if (oldScore !== undefined) {
                tokenScoresMap.set(token, [oldScore * 1.5 + boostScore, (tokenScoresMap?.get(token)?.[1] || 0) + 1]);
            }
            else {
                tokenScoresMap.set(token, [boostScore, 1]);
            }
        }
    }
    const tokenScores = [];
    for (const tokenScoreEntry of tokenScoresMap.entries()) {
        tokenScores.push([tokenScoreEntry[0], tokenScoreEntry[1][0]]);
    }
    const results = tokenScores.sort((a, b) => b[1] - a[1]);
    // If threshold is 1, it means we will return all the results with at least one search term,
    // prioritizing the ones that contains more search terms (fuzzy match)
    if (threshold === 1) {
        return results;
    }
    // For threshold = 0 when keywordsCount is 1 (single term search),
    // we return all matches since they automatically contain 100% of keywords
    if (threshold === 0 && keywordsCount === 1) {
        return results;
    }
    // Prepare keywords count tracking for threshold handling
    const allResults = results.length;
    const tokenScoreWithKeywordsCount = [];
    for (const tokenScoreEntry of tokenScoresMap.entries()) {
        tokenScoreWithKeywordsCount.push([tokenScoreEntry[0], tokenScoreEntry[1][0], tokenScoreEntry[1][1]]);
    }
    // Find the index of the last result with all keywords.
    // Order the documents by the number of keywords they contain, and then by the score.
    const keywordsPerToken = tokenScoreWithKeywordsCount.sort((a, b) => {
        // Compare by the third element, higher numbers first
        if (a[2] > b[2])
            return -1;
        if (a[2] < b[2])
            return 1;
        // If the third elements are equal, compare by the second element, higher numbers first
        if (a[1] > b[1])
            return -1;
        if (a[1] < b[1])
            return 1;
        // If both the second and third elements are equal, consider the elements equal
        return 0;
    });
    let lastTokenWithAllKeywords = undefined;
    for (let i = 0; i < allResults; i++) {
        if (keywordsPerToken[i][2] === keywordsCount) {
            lastTokenWithAllKeywords = i;
        }
        else {
            break;
        }
    }
    // If no results had all the keywords, either bail out earlier or normalize
    if (typeof lastTokenWithAllKeywords === 'undefined') {
        if (threshold === 0) {
            return [];
        }
        lastTokenWithAllKeywords = 0;
    }
    const keywordsPerTokenLength = keywordsPerToken.length;
    const resultsWithIdAndScore = new Array(keywordsPerTokenLength);
    for (let i = 0; i < keywordsPerTokenLength; i++) {
        resultsWithIdAndScore[i] = [keywordsPerToken[i][0], keywordsPerToken[i][1]];
    }
    // If threshold is 0, it means we will only return all the results that contains ALL the search terms (exact match)
    if (threshold === 0) {
        return resultsWithIdAndScore.slice(0, lastTokenWithAllKeywords + 1);
    }
    // If the threshold is between 0 and 1, we will return all the results that contains at least the threshold of search terms
    // For example, if threshold is 0.5, we will return all the results that contains at least 50% of the search terms
    // (fuzzy match with a minimum threshold)
    const thresholdLength = lastTokenWithAllKeywords + Math.ceil((threshold * 100 * (allResults - lastTokenWithAllKeywords)) / 100);
    return resultsWithIdAndScore.slice(0, Math.min(allResults, thresholdLength));
}
function BM25(tf, matchingCount, docsCount, fieldLength, averageFieldLength, { k, b, d }) {
    const idf = Math.log(1 + (docsCount - matchingCount + 0.5) / (matchingCount + 0.5));
    return (idf * (d + tf * (k + 1))) / (tf + k * (1 - b + (b * fieldLength) / averageFieldLength));
}
//# sourceMappingURL=algorithms.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/trees/vector.js
const vector_DEFAULT_SIMILARITY = 0.8;
class VectorIndex {
    size;
    vectors = new Map();
    constructor(size) {
        this.size = size;
    }
    add(internalDocumentId, value) {
        if (!(value instanceof Float32Array)) {
            value = new Float32Array(value);
        }
        const magnitude = getMagnitude(value, this.size);
        this.vectors.set(internalDocumentId, [magnitude, value]);
    }
    remove(internalDocumentId) {
        this.vectors.delete(internalDocumentId);
    }
    find(vector, similarity, whereFiltersIDs) {
        if (!(vector instanceof Float32Array)) {
            vector = new Float32Array(vector);
        }
        const results = findSimilarVectors(vector, whereFiltersIDs, this.vectors, this.size, similarity);
        return results;
    }
    toJSON() {
        const vectors = [];
        for (const [id, [magnitude, vector]] of this.vectors) {
            vectors.push([id, [magnitude, Array.from(vector)]]);
        }
        return {
            size: this.size,
            vectors,
        };
    }
    static fromJSON(json) {
        const raw = json;
        const index = new VectorIndex(raw.size);
        for (const [id, [magnitude, vector]] of raw.vectors) {
            index.vectors.set(id, [magnitude, new Float32Array(vector)]);
        }
        return index;
    }
}
function getMagnitude(vector, vectorLength) {
    let magnitude = 0;
    for (let i = 0; i < vectorLength; i++) {
        magnitude += vector[i] * vector[i];
    }
    return Math.sqrt(magnitude);
}
// @todo: Write plugins for Node and Browsers to use parallel computation for this function
function findSimilarVectors(targetVector, keys, vectors, length, threshold) {
    const targetMagnitude = getMagnitude(targetVector, length);
    const similarVectors = [];
    const base = keys ? keys : vectors.keys();
    for (const vectorId of base) {
        const entry = vectors.get(vectorId);
        if (!entry) {
            continue;
        }
        const magnitude = entry[0];
        const vector = entry[1];
        let dotProduct = 0;
        for (let i = 0; i < length; i++) {
            dotProduct += targetVector[i] * vector[i];
        }
        const similarity = dotProduct / (targetMagnitude * magnitude);
        if (similarity >= threshold) {
            similarVectors.push([vectorId, similarity]);
        }
    }
    return similarVectors;
}
//# sourceMappingURL=vector.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/index.js











function insertDocumentScoreParameters(index, prop, id, tokens, docsCount) {
    const internalId = internal_document_id_store_getInternalDocumentId(index.sharedInternalDocumentStore, id);
    index.avgFieldLength[prop] = ((index.avgFieldLength[prop] ?? 0) * (docsCount - 1) + tokens.length) / docsCount;
    index.fieldLengths[prop][internalId] = tokens.length;
    index.frequencies[prop][internalId] = {};
}
function insertTokenScoreParameters(index, prop, id, tokens, token) {
    let tokenFrequency = 0;
    for (const t of tokens) {
        if (t === token) {
            tokenFrequency++;
        }
    }
    const internalId = internal_document_id_store_getInternalDocumentId(index.sharedInternalDocumentStore, id);
    const tf = tokenFrequency / tokens.length;
    index.frequencies[prop][internalId][token] = tf;
    if (!(token in index.tokenOccurrences[prop])) {
        index.tokenOccurrences[prop][token] = 0;
    }
    // increase a token counter that may not yet exist
    index.tokenOccurrences[prop][token] = (index.tokenOccurrences[prop][token] ?? 0) + 1;
}
function removeDocumentScoreParameters(index, prop, id, docsCount) {
    const internalId = internal_document_id_store_getInternalDocumentId(index.sharedInternalDocumentStore, id);
    if (docsCount > 1) {
        index.avgFieldLength[prop] =
            (index.avgFieldLength[prop] * docsCount - index.fieldLengths[prop][internalId]) / (docsCount - 1);
    }
    else {
        index.avgFieldLength[prop] = undefined;
    }
    index.fieldLengths[prop][internalId] = undefined;
    index.frequencies[prop][internalId] = undefined;
}
function removeTokenScoreParameters(index, prop, token) {
    index.tokenOccurrences[prop][token]--;
}
function components_create(orama, sharedInternalDocumentStore, schema, index, prefix = '') {
    if (!index) {
        index = {
            sharedInternalDocumentStore,
            indexes: {},
            vectorIndexes: {},
            searchableProperties: [],
            searchablePropertiesWithTypes: {},
            frequencies: {},
            tokenOccurrences: {},
            avgFieldLength: {},
            fieldLengths: {}
        };
    }
    for (const [prop, type] of Object.entries(schema)) {
        const path = `${prefix}${prefix ? '.' : ''}${prop}`;
        if (typeof type === 'object' && !Array.isArray(type)) {
            // Nested
            components_create(orama, sharedInternalDocumentStore, type, index, path);
            continue;
        }
        if (isVectorType(type)) {
            index.searchableProperties.push(path);
            index.searchablePropertiesWithTypes[path] = type;
            index.vectorIndexes[path] = {
                type: 'Vector',
                node: new VectorIndex(getVectorSize(type)),
                isArray: false
            };
        }
        else {
            const isArray = /\[/.test(type);
            switch (type) {
                case 'boolean':
                case 'boolean[]':
                    index.indexes[path] = { type: 'Bool', node: new BoolNode(), isArray };
                    break;
                case 'number':
                case 'number[]':
                    index.indexes[path] = { type: 'AVL', node: new AVLTree(0, []), isArray };
                    break;
                case 'string':
                case 'string[]':
                    index.indexes[path] = { type: 'Radix', node: new RadixTree(), isArray };
                    index.avgFieldLength[path] = 0;
                    index.frequencies[path] = {};
                    index.tokenOccurrences[path] = {};
                    index.fieldLengths[path] = {};
                    break;
                case 'enum':
                case 'enum[]':
                    index.indexes[path] = { type: 'Flat', node: new FlatTree(), isArray };
                    break;
                case 'geopoint':
                    index.indexes[path] = { type: 'BKD', node: new bkd_BKDTree(), isArray };
                    break;
                default:
                    throw errors_createError('INVALID_SCHEMA_TYPE', Array.isArray(type) ? 'array' : type, path);
            }
            index.searchableProperties.push(path);
            index.searchablePropertiesWithTypes[path] = type;
        }
    }
    return index;
}
function insertScalarBuilder(implementation, index, prop, internalId, language, tokenizer, docsCount, options) {
    return (value) => {
        const { type, node } = index.indexes[prop];
        switch (type) {
            case 'Bool': {
                node[value ? 'true' : 'false'].add(internalId);
                break;
            }
            case 'AVL': {
                const avlRebalanceThreshold = options?.avlRebalanceThreshold ?? 1;
                node.insert(value, internalId, avlRebalanceThreshold);
                break;
            }
            case 'Radix': {
                const tokens = tokenizer.tokenize(value, language, prop, false);
                implementation.insertDocumentScoreParameters(index, prop, internalId, tokens, docsCount);
                for (const token of tokens) {
                    implementation.insertTokenScoreParameters(index, prop, internalId, tokens, token);
                    node.insert(token, internalId);
                }
                break;
            }
            case 'Flat': {
                node.insert(value, internalId);
                break;
            }
            case 'BKD': {
                node.insert(value, [internalId]);
                break;
            }
        }
    };
}
function components_insert(implementation, index, prop, id, internalId, value, schemaType, language, tokenizer, docsCount, options) {
    if (isVectorType(schemaType)) {
        return insertVector(index, prop, value, id, internalId);
    }
    const insertScalar = insertScalarBuilder(implementation, index, prop, internalId, language, tokenizer, docsCount, options);
    if (!isArrayType(schemaType)) {
        return insertScalar(value);
    }
    const elements = value;
    const elementsLength = elements.length;
    for (let i = 0; i < elementsLength; i++) {
        insertScalar(elements[i]);
    }
}
function insertVector(index, prop, value, id, internalDocumentId) {
    index.vectorIndexes[prop].node.add(internalDocumentId, value);
}
function removeScalar(implementation, index, prop, id, internalId, value, schemaType, language, tokenizer, docsCount) {
    if (isVectorType(schemaType)) {
        index.vectorIndexes[prop].node.remove(internalId);
        return true;
    }
    const { type, node } = index.indexes[prop];
    switch (type) {
        case 'AVL': {
            node.removeDocument(value, internalId);
            return true;
        }
        case 'Bool': {
            node[value ? 'true' : 'false'].delete(internalId);
            return true;
        }
        case 'Radix': {
            const tokens = tokenizer.tokenize(value, language, prop);
            implementation.removeDocumentScoreParameters(index, prop, id, docsCount);
            for (const token of tokens) {
                implementation.removeTokenScoreParameters(index, prop, token);
                node.removeDocumentByWord(token, internalId);
            }
            return true;
        }
        case 'Flat': {
            node.removeDocument(internalId, value);
            return true;
        }
        case 'BKD': {
            node.removeDocByID(value, internalId);
            return false;
        }
    }
}
function components_remove(implementation, index, prop, id, internalId, value, schemaType, language, tokenizer, docsCount) {
    if (!isArrayType(schemaType)) {
        return removeScalar(implementation, index, prop, id, internalId, value, schemaType, language, tokenizer, docsCount);
    }
    const innerSchemaType = getInnerType(schemaType);
    const elements = value;
    const elementsLength = elements.length;
    for (let i = 0; i < elementsLength; i++) {
        removeScalar(implementation, index, prop, id, internalId, elements[i], innerSchemaType, language, tokenizer, docsCount);
    }
    return true;
}
function calculateResultScores(index, prop, term, ids, docsCount, bm25Relevance, resultsMap, boostPerProperty, whereFiltersIDs, keywordMatchesMap) {
    const documentIDs = Array.from(ids);
    const avgFieldLength = index.avgFieldLength[prop];
    const fieldLengths = index.fieldLengths[prop];
    const oramaOccurrences = index.tokenOccurrences[prop];
    const oramaFrequencies = index.frequencies[prop];
    // oramaOccurrences[term] can be undefined, 0, string, or { [k: string]: number }
    const termOccurrences = typeof oramaOccurrences[term] === 'number' ? (oramaOccurrences[term] ?? 0) : 0;
    // Calculate TF-IDF value for each term, in each document, for each index.
    const documentIDsLength = documentIDs.length;
    for (let k = 0; k < documentIDsLength; k++) {
        const internalId = documentIDs[k];
        if (whereFiltersIDs && !whereFiltersIDs.has(internalId)) {
            continue;
        }
        // Track keyword matches per property
        if (!keywordMatchesMap.has(internalId)) {
            keywordMatchesMap.set(internalId, new Map());
        }
        const propertyMatches = keywordMatchesMap.get(internalId);
        propertyMatches.set(prop, (propertyMatches.get(prop) || 0) + 1);
        const tf = oramaFrequencies?.[internalId]?.[term] ?? 0;
        const bm25 = BM25(tf, termOccurrences, docsCount, fieldLengths[internalId], avgFieldLength, bm25Relevance);
        if (resultsMap.has(internalId)) {
            resultsMap.set(internalId, resultsMap.get(internalId) + bm25 * boostPerProperty);
        }
        else {
            resultsMap.set(internalId, bm25 * boostPerProperty);
        }
    }
}
function components_search(index, term, tokenizer, language, propertiesToSearch, exact, tolerance, boost, relevance, docsCount, whereFiltersIDs, threshold = 0) {
    const tokens = tokenizer.tokenize(term, language);
    const keywordsCount = tokens.length || 1;
    // Track keyword matches per document and property
    const keywordMatchesMap = new Map();
    // Track which tokens were found in the search
    const tokenFoundMap = new Map();
    const resultsMap = new Map();
    for (const prop of propertiesToSearch) {
        if (!(prop in index.indexes)) {
            continue;
        }
        const tree = index.indexes[prop];
        const { type } = tree;
        if (type !== 'Radix') {
            throw errors_createError('WRONG_SEARCH_PROPERTY_TYPE', prop);
        }
        const boostPerProperty = boost[prop] ?? 1;
        if (boostPerProperty <= 0) {
            throw errors_createError('INVALID_BOOST_VALUE', boostPerProperty);
        }
        // if the tokenizer returns an empty array, we returns all the documents
        if (tokens.length === 0 && !term) {
            tokens.push('');
        }
        // Process each token in the search term
        const tokenLength = tokens.length;
        for (let i = 0; i < tokenLength; i++) {
            const token = tokens[i];
            const searchResult = tree.node.find({ term: token, exact, tolerance });
            // See if this token was found (for threshold=0 filtering)
            const termsFound = Object.keys(searchResult);
            if (termsFound.length > 0) {
                tokenFoundMap.set(token, true);
            }
            // Process each matching term
            const termsFoundLength = termsFound.length;
            for (let j = 0; j < termsFoundLength; j++) {
                const word = termsFound[j];
                const ids = searchResult[word];
                calculateResultScores(index, prop, word, ids, docsCount, relevance, resultsMap, boostPerProperty, whereFiltersIDs, keywordMatchesMap);
            }
        }
    }
    // Convert to array and sort by score
    const results = Array.from(resultsMap.entries())
        .map(([id, score]) => [id, score])
        .sort((a, b) => b[1] - a[1]);
    if (results.length === 0) {
        return [];
    }
    // If threshold is 1, return all results
    if (threshold === 1) {
        return results;
    }
    // For threshold=0, check if all tokens were found
    if (threshold === 0) {
        // Quick return for single tokens - already validated
        if (keywordsCount === 1) {
            return results;
        }
        // For multiple tokens, verify that ALL tokens were found
        // If any token wasn't found, return an empty result
        for (const token of tokens) {
            if (!tokenFoundMap.get(token)) {
                return [];
            }
        }
        // Find documents that have all keywords in at least one property
        const fullMatches = results.filter(([id]) => {
            const propertyMatches = keywordMatchesMap.get(id);
            if (!propertyMatches)
                return false;
            // Check if any property has all keywords
            return Array.from(propertyMatches.values()).some((matches) => matches === keywordsCount);
        });
        return fullMatches;
    }
    // Find documents that have all keywords in at least one property
    const fullMatches = results.filter(([id]) => {
        const propertyMatches = keywordMatchesMap.get(id);
        if (!propertyMatches)
            return false;
        // Check if any property has all keywords
        return Array.from(propertyMatches.values()).some((matches) => matches === keywordsCount);
    });
    // If we have full matches and threshold < 1, return full matches plus a percentage of partial matches
    if (fullMatches.length > 0) {
        const remainingResults = results.filter(([id]) => !fullMatches.some(([fid]) => fid === id));
        const additionalResults = Math.ceil(remainingResults.length * threshold);
        return [...fullMatches, ...remainingResults.slice(0, additionalResults)];
    }
    // If no full matches, return all results
    return results;
}
function searchByWhereClause(index, tokenizer, filters, language) {
    // Handle logical operators
    if ('and' in filters && filters.and && Array.isArray(filters.and)) {
        const andFilters = filters.and;
        if (andFilters.length === 0) {
            return new Set();
        }
        const results = andFilters.map((filter) => searchByWhereClause(index, tokenizer, filter, language));
        return setIntersection(...results);
    }
    if ('or' in filters && filters.or && Array.isArray(filters.or)) {
        const orFilters = filters.or;
        if (orFilters.length === 0) {
            return new Set();
        }
        const results = orFilters.map((filter) => searchByWhereClause(index, tokenizer, filter, language));
        // Use reduce to union all sets
        return results.reduce((acc, set) => setUnion(acc, set), new Set());
    }
    if ('not' in filters && filters.not) {
        const notFilter = filters.not;
        // Get all document IDs from the internal document store
        const allDocs = new Set();
        // Get all document IDs from the internal document store
        const docsStore = index.sharedInternalDocumentStore;
        for (let i = 1; i <= docsStore.internalIdToId.length; i++) {
            allDocs.add(i);
        }
        const notResult = searchByWhereClause(index, tokenizer, notFilter, language);
        return setDifference(allDocs, notResult);
    }
    // Handle regular property filters (existing logic)
    const filterKeys = Object.keys(filters);
    const filtersMap = filterKeys.reduce((acc, key) => ({
        [key]: new Set(),
        ...acc
    }), {});
    for (const param of filterKeys) {
        const operation = filters[param];
        if (typeof index.indexes[param] === 'undefined') {
            throw errors_createError('UNKNOWN_FILTER_PROPERTY', param);
        }
        const { node, type, isArray } = index.indexes[param];
        if (type === 'Bool') {
            const idx = node;
            const filteredIDs = operation ? idx.true : idx.false;
            filtersMap[param] = setUnion(filtersMap[param], filteredIDs);
            continue;
        }
        if (type === 'BKD') {
            let reqOperation;
            if ('radius' in operation) {
                reqOperation = 'radius';
            }
            else if ('polygon' in operation) {
                reqOperation = 'polygon';
            }
            else {
                throw new Error(`Invalid operation ${operation}`);
            }
            if (reqOperation === 'radius') {
                const { value, coordinates, unit = 'm', inside = true, highPrecision = false } = operation[reqOperation];
                const distanceInMeters = utils_convertDistanceToMeters(value, unit);
                const ids = node.searchByRadius(coordinates, distanceInMeters, inside, undefined, highPrecision);
                filtersMap[param] = addGeoResult(filtersMap[param], ids);
            }
            else {
                const { coordinates, inside = true, highPrecision = false } = operation[reqOperation];
                const ids = node.searchByPolygon(coordinates, inside, undefined, highPrecision);
                filtersMap[param] = addGeoResult(filtersMap[param], ids);
            }
            continue;
        }
        if (type === 'Radix' && (typeof operation === 'string' || Array.isArray(operation))) {
            for (const raw of [operation].flat()) {
                const term = tokenizer.tokenize(raw, language, param);
                for (const t of term) {
                    const filteredIDsResults = node.find({ term: t, exact: true });
                    filtersMap[param] = addFindResult(filtersMap[param], filteredIDsResults);
                }
            }
            continue;
        }
        const operationKeys = Object.keys(operation);
        if (operationKeys.length > 1) {
            throw errors_createError('INVALID_FILTER_OPERATION', operationKeys.length);
        }
        if (type === 'Flat') {
            const results = new Set(isArray
                ? node.filterArr(operation)
                : node.filter(operation));
            filtersMap[param] = setUnion(filtersMap[param], results);
            continue;
        }
        if (type === 'AVL') {
            const operationOpt = operationKeys[0];
            const operationValue = operation[operationOpt];
            let filteredIDs;
            switch (operationOpt) {
                case 'gt': {
                    filteredIDs = node.greaterThan(operationValue, false);
                    break;
                }
                case 'gte': {
                    filteredIDs = node.greaterThan(operationValue, true);
                    break;
                }
                case 'lt': {
                    filteredIDs = node.lessThan(operationValue, false);
                    break;
                }
                case 'lte': {
                    filteredIDs = node.lessThan(operationValue, true);
                    break;
                }
                case 'eq': {
                    const ret = node.find(operationValue);
                    filteredIDs = ret ?? new Set();
                    break;
                }
                case 'between': {
                    const [min, max] = operationValue;
                    filteredIDs = node.rangeSearch(min, max);
                    break;
                }
                default:
                    throw errors_createError('INVALID_FILTER_OPERATION', operationOpt);
            }
            filtersMap[param] = setUnion(filtersMap[param], filteredIDs);
        }
    }
    // AND operation: calculate the intersection between all the IDs in filterMap
    return setIntersection(...Object.values(filtersMap));
}
function getSearchableProperties(index) {
    return index.searchableProperties;
}
function getSearchablePropertiesWithTypes(index) {
    return index.searchablePropertiesWithTypes;
}
function components_load(sharedInternalDocumentStore, raw) {
    const { indexes: rawIndexes, vectorIndexes: rawVectorIndexes, searchableProperties, searchablePropertiesWithTypes, frequencies, tokenOccurrences, avgFieldLength, fieldLengths } = raw;
    const indexes = {};
    const vectorIndexes = {};
    for (const prop of Object.keys(rawIndexes)) {
        const { node, type, isArray } = rawIndexes[prop];
        switch (type) {
            case 'Radix':
                indexes[prop] = {
                    type: 'Radix',
                    node: RadixTree.fromJSON(node),
                    isArray
                };
                break;
            case 'Flat':
                indexes[prop] = {
                    type: 'Flat',
                    node: FlatTree.fromJSON(node),
                    isArray
                };
                break;
            case 'AVL':
                indexes[prop] = {
                    type: 'AVL',
                    node: AVLTree.fromJSON(node),
                    isArray
                };
                break;
            case 'BKD':
                indexes[prop] = {
                    type: 'BKD',
                    node: bkd_BKDTree.fromJSON(node),
                    isArray
                };
                break;
            case 'Bool':
                indexes[prop] = {
                    type: 'Bool',
                    node: BoolNode.fromJSON(node),
                    isArray
                };
                break;
            default:
                indexes[prop] = rawIndexes[prop];
        }
    }
    for (const idx of Object.keys(rawVectorIndexes)) {
        vectorIndexes[idx] = {
            type: 'Vector',
            isArray: false,
            node: VectorIndex.fromJSON(rawVectorIndexes[idx])
        };
    }
    return {
        sharedInternalDocumentStore,
        indexes,
        vectorIndexes,
        searchableProperties,
        searchablePropertiesWithTypes,
        frequencies,
        tokenOccurrences,
        avgFieldLength,
        fieldLengths
    };
}
function components_save(index) {
    const { indexes, vectorIndexes, searchableProperties, searchablePropertiesWithTypes, frequencies, tokenOccurrences, avgFieldLength, fieldLengths } = index;
    const dumpVectorIndexes = {};
    for (const idx of Object.keys(vectorIndexes)) {
        dumpVectorIndexes[idx] = vectorIndexes[idx].node.toJSON();
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const savedIndexes = {};
    for (const name of Object.keys(indexes)) {
        const { type, node, isArray } = indexes[name];
        if (type === 'Flat' || type === 'Radix' || type === 'AVL' || type === 'BKD' || type === 'Bool') {
            savedIndexes[name] = {
                type,
                node: node.toJSON(),
                isArray
            };
        }
        else {
            savedIndexes[name] = indexes[name];
            savedIndexes[name].node = savedIndexes[name].node.toJSON();
        }
    }
    return {
        indexes: savedIndexes,
        vectorIndexes: dumpVectorIndexes,
        searchableProperties,
        searchablePropertiesWithTypes,
        frequencies,
        tokenOccurrences,
        avgFieldLength,
        fieldLengths
    };
}
function createIndex() {
    return {
        create: components_create,
        insert: components_insert,
        remove: components_remove,
        insertDocumentScoreParameters,
        insertTokenScoreParameters,
        removeDocumentScoreParameters,
        removeTokenScoreParameters,
        calculateResultScores,
        search: components_search,
        searchByWhereClause,
        getSearchableProperties,
        getSearchablePropertiesWithTypes,
        load: components_load,
        save: components_save
    };
}
function addGeoResult(set, ids) {
    if (!set) {
        set = new Set();
    }
    const idsLength = ids.length;
    for (let i = 0; i < idsLength; i++) {
        const entry = ids[i].docIDs;
        const idsLength = entry.length;
        for (let j = 0; j < idsLength; j++) {
            set.add(entry[j]);
        }
    }
    return set;
}
function createGeoTokenScores(ids, centerPoint, highPrecision = false) {
    const distanceFn = highPrecision ? BKDTree.vincentyDistance : BKDTree.haversineDistance;
    const results = [];
    // Calculate distances for all results to find the maximum
    const distances = [];
    for (const { point } of ids) {
        distances.push(distanceFn(centerPoint, point));
    }
    const maxDistance = Math.max(...distances);
    // Create results with inverse distance scores (higher score = closer)
    let index = 0;
    for (const { docIDs } of ids) {
        const distance = distances[index];
        // Use inverse score: closer points get higher scores
        // Add 1 to avoid division by zero for points at exact center
        const score = maxDistance - distance + 1;
        for (const docID of docIDs) {
            results.push([docID, score]);
        }
        index++;
    }
    // Sort by score (higher first - closer points)
    results.sort((a, b) => b[1] - a[1]);
    return results;
}
function isGeosearchOnlyQuery(filters, index) {
    const filterKeys = Object.keys(filters);
    if (filterKeys.length !== 1) {
        return { isGeoOnly: false };
    }
    const param = filterKeys[0];
    const operation = filters[param];
    if (typeof index.indexes[param] === 'undefined') {
        return { isGeoOnly: false };
    }
    const { type } = index.indexes[param];
    if (type === 'BKD' && operation && ('radius' in operation || 'polygon' in operation)) {
        return { isGeoOnly: true, geoProperty: param, geoOperation: operation };
    }
    return { isGeoOnly: false };
}
function components_searchByGeoWhereClause(index, filters) {
    const indexTyped = index;
    const geoInfo = isGeosearchOnlyQuery(filters, indexTyped);
    if (!geoInfo.isGeoOnly || !geoInfo.geoProperty || !geoInfo.geoOperation) {
        return null;
    }
    const { node } = indexTyped.indexes[geoInfo.geoProperty];
    const operation = geoInfo.geoOperation;
    // Cast node to BKDTree since we already verified it's type 'BKD'
    const bkdNode = node;
    let results;
    if ('radius' in operation) {
        const { value, coordinates, unit = 'm', inside = true, highPrecision = false } = operation.radius;
        const centerPoint = coordinates;
        const distanceInMeters = convertDistanceToMeters(value, unit);
        results = bkdNode.searchByRadius(centerPoint, distanceInMeters, inside, 'asc', highPrecision);
        return createGeoTokenScores(results, centerPoint, highPrecision);
    }
    else if ('polygon' in operation) {
        const { coordinates, inside = true, highPrecision = false } = operation.polygon;
        results = bkdNode.searchByPolygon(coordinates, inside, 'asc', highPrecision);
        const centroid = BKDTree.calculatePolygonCentroid(coordinates);
        return createGeoTokenScores(results, centroid, highPrecision);
    }
    return null;
}
function addFindResult(set, filteredIDsResults) {
    if (!set) {
        set = new Set();
    }
    const keys = Object.keys(filteredIDsResults);
    const keysLength = keys.length;
    for (let i = 0; i < keysLength; i++) {
        const ids = filteredIDsResults[keys[i]];
        const idsLength = ids.length;
        for (let j = 0; j < idsLength; j++) {
            set.add(ids[j]);
        }
    }
    return set;
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/sorter.js





function innerCreate(orama, sharedInternalDocumentStore, schema, sortableDeniedProperties, prefix) {
    const sorter = {
        language: orama.tokenizer.language,
        sharedInternalDocumentStore,
        enabled: true,
        isSorted: true,
        sortableProperties: [],
        sortablePropertiesWithTypes: {},
        sorts: {}
    };
    for (const [prop, type] of Object.entries(schema)) {
        const path = `${prefix}${prefix ? '.' : ''}${prop}`;
        if (sortableDeniedProperties.includes(path)) {
            continue;
        }
        if (typeof type === 'object' && !Array.isArray(type)) {
            // Nested
            const ret = innerCreate(orama, sharedInternalDocumentStore, type, sortableDeniedProperties, path);
            utils_safeArrayPush(sorter.sortableProperties, ret.sortableProperties);
            sorter.sorts = {
                ...sorter.sorts,
                ...ret.sorts
            };
            sorter.sortablePropertiesWithTypes = {
                ...sorter.sortablePropertiesWithTypes,
                ...ret.sortablePropertiesWithTypes
            };
            continue;
        }
        if (!isVectorType(type)) {
            switch (type) {
                case 'boolean':
                case 'number':
                case 'string':
                    sorter.sortableProperties.push(path);
                    sorter.sortablePropertiesWithTypes[path] = type;
                    sorter.sorts[path] = {
                        docs: new Map(),
                        orderedDocsToRemove: new Map(),
                        orderedDocs: [],
                        type: type
                    };
                    break;
                case 'geopoint':
                case 'enum':
                    // We don't allow to sort by enums or geopoints
                    continue;
                case 'enum[]':
                case 'boolean[]':
                case 'number[]':
                case 'string[]':
                    // We don't allow to sort by arrays
                    continue;
                default:
                    throw errors_createError('INVALID_SORT_SCHEMA_TYPE', Array.isArray(type) ? 'array' : type, path);
            }
        }
    }
    return sorter;
}
function sorter_create(orama, sharedInternalDocumentStore, schema, config) {
    const isSortEnabled = config?.enabled !== false;
    if (!isSortEnabled) {
        return {
            disabled: true
        };
    }
    return innerCreate(orama, sharedInternalDocumentStore, schema, (config || {}).unsortableProperties || [], '');
}
function sorter_insert(sorter, prop, id, value) {
    if (!sorter.enabled) {
        return;
    }
    sorter.isSorted = false;
    const internalId = internal_document_id_store_getInternalDocumentId(sorter.sharedInternalDocumentStore, id);
    const s = sorter.sorts[prop];
    // This happen during a document updating
    // Because we re-use the same internalId
    // We need to clean-up the data structure before re-inserting
    // to avoid duplicates in the orderedDocs array
    // See: https://github.com/oramasearch/orama/issues/629
    if (s.orderedDocsToRemove.has(internalId)) {
        ensureOrderedDocsAreDeletedByProperty(sorter, prop);
    }
    s.docs.set(internalId, s.orderedDocs.length);
    s.orderedDocs.push([internalId, value]);
}
function ensureIsSorted(sorter) {
    if (sorter.isSorted || !sorter.enabled) {
        return;
    }
    const properties = Object.keys(sorter.sorts);
    for (const prop of properties) {
        ensurePropertyIsSorted(sorter, prop);
    }
    sorter.isSorted = true;
}
function stringSort(language, value, d) {
    return value[1].localeCompare(d[1], getLocale(language));
}
function numberSort(value, d) {
    return value[1] - d[1];
}
function booleanSort(value, d) {
    return d[1] ? -1 : 1;
}
function ensurePropertyIsSorted(sorter, prop) {
    const s = sorter.sorts[prop];
    let predicate;
    switch (s.type) {
        case 'string':
            predicate = stringSort.bind(null, sorter.language);
            break;
        case 'number':
            predicate = numberSort.bind(null);
            break;
        case 'boolean':
            predicate = booleanSort.bind(null);
            break;
    }
    s.orderedDocs.sort(predicate);
    // Increment position for the greather documents
    const orderedDocsLength = s.orderedDocs.length;
    for (let i = 0; i < orderedDocsLength; i++) {
        const docId = s.orderedDocs[i][0];
        s.docs.set(docId, i);
    }
}
function ensureOrderedDocsAreDeleted(sorter) {
    const properties = Object.keys(sorter.sorts);
    for (const prop of properties) {
        ensureOrderedDocsAreDeletedByProperty(sorter, prop);
    }
}
function ensureOrderedDocsAreDeletedByProperty(sorter, prop) {
    const s = sorter.sorts[prop];
    if (!s.orderedDocsToRemove.size)
        return;
    s.orderedDocs = s.orderedDocs.filter((doc) => !s.orderedDocsToRemove.has(doc[0]));
    s.orderedDocsToRemove.clear();
}
function sorter_remove(sorter, prop, id) {
    if (!sorter.enabled) {
        return;
    }
    const s = sorter.sorts[prop];
    const internalId = internal_document_id_store_getInternalDocumentId(sorter.sharedInternalDocumentStore, id);
    const index = s.docs.get(internalId);
    if (!index)
        return;
    s.docs.delete(internalId);
    s.orderedDocsToRemove.set(internalId, true);
}
function sortBy(sorter, docIds, by) {
    if (!sorter.enabled) {
        throw errors_createError('SORT_DISABLED');
    }
    const property = by.property;
    const isDesc = by.order === 'DESC';
    const s = sorter.sorts[property];
    if (!s) {
        throw errors_createError('UNABLE_TO_SORT_ON_UNKNOWN_FIELD', property, sorter.sortableProperties.join(', '));
    }
    ensureOrderedDocsAreDeletedByProperty(sorter, property);
    ensureIsSorted(sorter);
    docIds.sort((a, b) => {
        // This sort algorithm works leveraging on
        // that s.docs is a map of docId -> position
        // If a document is not indexed, it will be not present in the map
        const indexOfA = s.docs.get(internal_document_id_store_getInternalDocumentId(sorter.sharedInternalDocumentStore, a[0]));
        const indexOfB = s.docs.get(internal_document_id_store_getInternalDocumentId(sorter.sharedInternalDocumentStore, b[0]));
        const isAIndexed = typeof indexOfA !== 'undefined';
        const isBIndexed = typeof indexOfB !== 'undefined';
        if (!isAIndexed && !isBIndexed) {
            return 0;
        }
        // unindexed documents are always at the end
        if (!isAIndexed) {
            return 1;
        }
        if (!isBIndexed) {
            return -1;
        }
        return isDesc ? indexOfB - indexOfA : indexOfA - indexOfB;
    });
    return docIds;
}
function getSortableProperties(sorter) {
    if (!sorter.enabled) {
        return [];
    }
    return sorter.sortableProperties;
}
function getSortablePropertiesWithTypes(sorter) {
    if (!sorter.enabled) {
        return {};
    }
    return sorter.sortablePropertiesWithTypes;
}
function sorter_load(sharedInternalDocumentStore, raw) {
    const rawDocument = raw;
    if (!rawDocument.enabled) {
        return {
            enabled: false
        };
    }
    const sorts = Object.keys(rawDocument.sorts).reduce((acc, prop) => {
        const { docs, orderedDocs, type } = rawDocument.sorts[prop];
        acc[prop] = {
            docs: new Map(Object.entries(docs).map(([k, v]) => [+k, v])),
            orderedDocsToRemove: new Map(),
            orderedDocs,
            type
        };
        return acc;
    }, {});
    return {
        sharedInternalDocumentStore,
        language: rawDocument.language,
        sortableProperties: rawDocument.sortableProperties,
        sortablePropertiesWithTypes: rawDocument.sortablePropertiesWithTypes,
        sorts,
        enabled: true,
        isSorted: rawDocument.isSorted
    };
}
function sorter_save(sorter) {
    if (!sorter.enabled) {
        return {
            enabled: false
        };
    }
    ensureOrderedDocsAreDeleted(sorter);
    ensureIsSorted(sorter);
    const sorts = Object.keys(sorter.sorts).reduce((acc, prop) => {
        const { docs, orderedDocs, type } = sorter.sorts[prop];
        acc[prop] = {
            docs: Object.fromEntries(docs.entries()),
            orderedDocs,
            type
        };
        return acc;
    }, {});
    return {
        language: sorter.language,
        sortableProperties: sorter.sortableProperties,
        sortablePropertiesWithTypes: sorter.sortablePropertiesWithTypes,
        sorts,
        enabled: sorter.enabled,
        isSorted: sorter.isSorted
    };
}
function createSorter() {
    return {
        create: sorter_create,
        insert: sorter_insert,
        remove: sorter_remove,
        save: sorter_save,
        load: sorter_load,
        sortBy,
        getSortableProperties,
        getSortablePropertiesWithTypes
    };
}
//# sourceMappingURL=sorter.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/tokenizer/diacritics.js
const DIACRITICS_CHARCODE_START = 192;
const DIACRITICS_CHARCODE_END = 383;
const CHARCODE_REPLACE_MAPPING = [
    65,
    65,
    65,
    65,
    65,
    65,
    65,
    67,
    69,
    69,
    69,
    69,
    73,
    73,
    73,
    73,
    69,
    78,
    79,
    79,
    79,
    79,
    79,
    null,
    79,
    85,
    85,
    85,
    85,
    89,
    80,
    115,
    97,
    97,
    97,
    97,
    97,
    97,
    97,
    99,
    101,
    101,
    101,
    101,
    105,
    105,
    105,
    105,
    101,
    110,
    111,
    111,
    111,
    111,
    111,
    null,
    111,
    117,
    117,
    117,
    117,
    121,
    112,
    121,
    65,
    97,
    65,
    97,
    65,
    97,
    67,
    99,
    67,
    99,
    67,
    99,
    67,
    99,
    68,
    100,
    68,
    100,
    69,
    101,
    69,
    101,
    69,
    101,
    69,
    101,
    69,
    101,
    71,
    103,
    71,
    103,
    71,
    103,
    71,
    103,
    72,
    104,
    72,
    104,
    73,
    105,
    73,
    105,
    73,
    105,
    73,
    105,
    73,
    105,
    73,
    105,
    74,
    106,
    75,
    107,
    107,
    76,
    108,
    76,
    108,
    76,
    108,
    76,
    108,
    76,
    108,
    78,
    110,
    78,
    110,
    78,
    110,
    110,
    78,
    110,
    79,
    111,
    79,
    111,
    79,
    111,
    79,
    111,
    82,
    114,
    82,
    114,
    82,
    114,
    83,
    115,
    83,
    115,
    83,
    115,
    83,
    115,
    84,
    116,
    84,
    116,
    84,
    116,
    85,
    117,
    85,
    117,
    85,
    117,
    85,
    117,
    85,
    117,
    85,
    117,
    87,
    119,
    89,
    121,
    89,
    90,
    122,
    90,
    122,
    90,
    122,
    115
];
function replaceChar(charCode) {
    if (charCode < DIACRITICS_CHARCODE_START || charCode > DIACRITICS_CHARCODE_END)
        return charCode;
    /* c8 ignore next  */
    return CHARCODE_REPLACE_MAPPING[charCode - DIACRITICS_CHARCODE_START] || charCode;
}
function replaceDiacritics(str) {
    const stringCharCode = [];
    for (let idx = 0; idx < str.length; idx++) {
        stringCharCode[idx] = replaceChar(str.charCodeAt(idx));
    }
    return String.fromCharCode(...stringCharCode);
}
//# sourceMappingURL=diacritics.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/tokenizer/english-stemmer.js
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck
const step2List = {
    ational: 'ate',
    tional: 'tion',
    enci: 'ence',
    anci: 'ance',
    izer: 'ize',
    bli: 'ble',
    alli: 'al',
    entli: 'ent',
    eli: 'e',
    ousli: 'ous',
    ization: 'ize',
    ation: 'ate',
    ator: 'ate',
    alism: 'al',
    iveness: 'ive',
    fulness: 'ful',
    ousness: 'ous',
    aliti: 'al',
    iviti: 'ive',
    biliti: 'ble',
    logi: 'log'
};
const step3List = {
    icate: 'ic',
    ative: '',
    alize: 'al',
    iciti: 'ic',
    ical: 'ic',
    ful: '',
    ness: ''
};
// Consonant
const english_stemmer_c = '[^aeiou]';
// Vowel
const english_stemmer_v = '[aeiouy]';
// Consonant sequence
const english_stemmer_C = english_stemmer_c + '[^aeiouy]*';
// Vowel sequence
const V = english_stemmer_v + '[aeiou]*';
// [C]VC... is m>0
const mgr0 = '^(' + english_stemmer_C + ')?' + V + english_stemmer_C;
// [C]VC[V] is m=1
const meq1 = '^(' + english_stemmer_C + ')?' + V + english_stemmer_C + '(' + V + ')?$';
// [C]VCVC... is m>1
const mgr1 = '^(' + english_stemmer_C + ')?' + V + english_stemmer_C + V + english_stemmer_C;
// vowel in stem
const s_v = '^(' + english_stemmer_C + ')?' + english_stemmer_v;
function english_stemmer_stemmer(w) {
    let stem;
    let suffix;
    let re;
    let re2;
    let re3;
    let re4;
    if (w.length < 3) {
        return w;
    }
    const firstch = w.substring(0, 1);
    if (firstch == 'y') {
        w = firstch.toUpperCase() + w.substring(1);
    }
    re = /^(.+?)(ss|i)es$/;
    re2 = /^(.+?)([^s])s$/;
    if (re.test(w)) {
        w = w.replace(re, '$1$2');
    }
    else if (re2.test(w)) {
        w = w.replace(re2, '$1$2');
    }
    re = /^(.+?)eed$/;
    re2 = /^(.+?)(ed|ing)$/;
    if (re.test(w)) {
        const fp = re.exec(w);
        re = new RegExp(mgr0);
        if (re.test(fp[1])) {
            re = /.$/;
            w = w.replace(re, '');
        }
    }
    else if (re2.test(w)) {
        const fp = re2.exec(w);
        stem = fp[1];
        re2 = new RegExp(s_v);
        if (re2.test(stem)) {
            w = stem;
            re2 = /(at|bl|iz)$/;
            re3 = new RegExp('([^aeiouylsz])\\1$');
            re4 = new RegExp('^' + english_stemmer_C + english_stemmer_v + '[^aeiouwxy]$');
            if (re2.test(w)) {
                w = w + 'e';
            }
            else if (re3.test(w)) {
                re = /.$/;
                w = w.replace(re, '');
            }
            else if (re4.test(w)) {
                w = w + 'e';
            }
        }
    }
    re = /^(.+?)y$/;
    if (re.test(w)) {
        const fp = re.exec(w);
        stem = fp?.[1];
        re = new RegExp(s_v);
        if (stem && re.test(stem)) {
            w = stem + 'i';
        }
    }
    re =
        /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;
    if (re.test(w)) {
        const fp = re.exec(w);
        stem = fp?.[1];
        suffix = fp?.[2];
        re = new RegExp(mgr0);
        if (stem && re.test(stem)) {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            w = stem + step2List[suffix];
        }
    }
    re = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;
    if (re.test(w)) {
        const fp = re.exec(w);
        stem = fp?.[1];
        suffix = fp?.[2];
        re = new RegExp(mgr0);
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        if (stem && re.test(stem)) {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            w = stem + step3List[suffix];
        }
    }
    re = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;
    re2 = /^(.+?)(s|t)(ion)$/;
    if (re.test(w)) {
        const fp = re.exec(w);
        stem = fp?.[1];
        re = new RegExp(mgr1);
        if (stem && re.test(stem)) {
            w = stem;
        }
    }
    else if (re2.test(w)) {
        const fp = re2.exec(w);
        stem = fp?.[1] ?? '' + fp?.[2] ?? '';
        re2 = new RegExp(mgr1);
        if (re2.test(stem)) {
            w = stem;
        }
    }
    re = /^(.+?)e$/;
    if (re.test(w)) {
        const fp = re.exec(w);
        stem = fp?.[1];
        re = new RegExp(mgr1);
        re2 = new RegExp(meq1);
        re3 = new RegExp('^' + english_stemmer_C + english_stemmer_v + '[^aeiouwxy]$');
        if (stem && (re.test(stem) || (re2.test(stem) && !re3.test(stem)))) {
            w = stem;
        }
    }
    re = /ll$/;
    re2 = new RegExp(mgr1);
    if (re.test(w) && re2.test(w)) {
        re = /.$/;
        w = w.replace(re, '');
    }
    if (firstch == 'y') {
        w = firstch.toLowerCase() + w.substring(1);
    }
    return w;
}
//# sourceMappingURL=english-stemmer.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/tokenizer/index.js




function tokenizer_normalizeToken(prop, token, withCache = true) {
    const key = `${this.language}:${prop}:${token}`;
    if (withCache && this.normalizationCache.has(key)) {
        return this.normalizationCache.get(key);
    }
    // Remove stopwords if enabled
    if (this.stopWords?.includes(token)) {
        if (withCache) {
            this.normalizationCache.set(key, '');
        }
        return '';
    }
    // Apply stemming if enabled
    if (this.stemmer && !this.stemmerSkipProperties.has(prop)) {
        token = this.stemmer(token);
    }
    token = replaceDiacritics(token);
    if (withCache) {
        this.normalizationCache.set(key, token);
    }
    return token;
}
/* c8 ignore next 10 */
function trim(text) {
    while (text[text.length - 1] === '') {
        text.pop();
    }
    while (text[0] === '') {
        text.shift();
    }
    return text;
}
function tokenize(input, language, prop, withCache = true) {
    if (language && language !== this.language) {
        throw errors_createError('LANGUAGE_NOT_SUPPORTED', language);
    }
    /* c8 ignore next 3 */
    if (typeof input !== 'string') {
        return [input];
    }
    const normalizeToken = this.normalizeToken.bind(this, prop ?? '');
    let tokens;
    if (prop && this.tokenizeSkipProperties.has(prop)) {
        tokens = [normalizeToken(input, withCache)];
    }
    else {
        const splitRule = SPLITTERS[this.language];
        tokens = input
            .toLowerCase()
            .split(splitRule)
            .map(t => normalizeToken(t, withCache))
            .filter(Boolean);
    }
    const trimTokens = trim(tokens);
    if (!this.allowDuplicates) {
        return Array.from(new Set(trimTokens));
    }
    return trimTokens;
}
function createTokenizer(config = {}) {
    if (!config.language) {
        config.language = 'english';
    }
    else if (!SUPPORTED_LANGUAGES.includes(config.language)) {
        throw errors_createError('LANGUAGE_NOT_SUPPORTED', config.language);
    }
    // Handle stemming - It is disabled by default
    let stemmer;
    if (config.stemming || (config.stemmer && !('stemming' in config))) {
        if (config.stemmer) {
            if (typeof config.stemmer !== 'function') {
                throw errors_createError('INVALID_STEMMER_FUNCTION_TYPE');
            }
            stemmer = config.stemmer;
        }
        else {
            if (config.language === 'english') {
                stemmer = english_stemmer_stemmer;
            }
            else {
                throw errors_createError('MISSING_STEMMER', config.language);
            }
        }
    }
    // Handle stopwords
    let stopWords;
    if (config.stopWords !== false) {
        stopWords = [];
        if (Array.isArray(config.stopWords)) {
            stopWords = config.stopWords;
        }
        else if (typeof config.stopWords === 'function') {
            stopWords = config.stopWords(stopWords);
        }
        else if (config.stopWords) {
            throw errors_createError('CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY');
        }
        // Make sure stopWords is just an array of strings
        if (!Array.isArray(stopWords)) {
            throw errors_createError('CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY');
        }
        for (const s of stopWords) {
            if (typeof s !== 'string') {
                throw errors_createError('CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY');
            }
        }
    }
    // Create the tokenizer
    const tokenizer = {
        tokenize,
        language: config.language,
        stemmer,
        stemmerSkipProperties: new Set(config.stemmerSkipProperties ? [config.stemmerSkipProperties].flat() : []),
        tokenizeSkipProperties: new Set(config.tokenizeSkipProperties ? [config.tokenizeSkipProperties].flat() : []),
        stopWords,
        allowDuplicates: Boolean(config.allowDuplicates),
        normalizeToken: tokenizer_normalizeToken,
        normalizationCache: new Map()
    };
    tokenizer.tokenize = tokenize.bind(tokenizer);
    tokenizer.normalizeToken = tokenizer_normalizeToken;
    return tokenizer;
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/pinning.js
function pinning_create(sharedInternalDocumentStore) {
    return {
        sharedInternalDocumentStore,
        rules: new Map()
    };
}
function addRule(store, rule) {
    if (store.rules.has(rule.id)) {
        throw new Error(`PINNING_RULE_ALREADY_EXISTS: A pinning rule with id "${rule.id}" already exists. Use updateRule to modify it.`);
    }
    store.rules.set(rule.id, rule);
}
function updateRule(store, rule) {
    if (!store.rules.has(rule.id)) {
        throw new Error(`PINNING_RULE_NOT_FOUND: Cannot update pinning rule with id "${rule.id}" because it does not exist. Use addRule to create it.`);
    }
    store.rules.set(rule.id, rule);
}
function removeRule(store, ruleId) {
    return store.rules.delete(ruleId);
}
function getRule(store, ruleId) {
    return store.rules.get(ruleId);
}
function getAllRules(store) {
    return Array.from(store.rules.values());
}
function matchesCondition(term, condition) {
    const normalizedTerm = term.toLowerCase().trim();
    const normalizedPattern = condition.pattern.toLowerCase().trim();
    switch (condition.anchoring) {
        case 'is':
            return normalizedTerm === normalizedPattern;
        case 'starts_with':
            return normalizedTerm.startsWith(normalizedPattern);
        case 'contains':
            return normalizedTerm.includes(normalizedPattern);
        default:
            return false;
    }
}
function matchesRule(term, rule) {
    if (!term) {
        return false;
    }
    // All conditions must match (AND logic)
    return rule.conditions.every((condition) => matchesCondition(term, condition));
}
function getMatchingRules(store, term) {
    if (!term) {
        return [];
    }
    const matchingRules = [];
    for (const rule of store.rules.values()) {
        if (matchesRule(term, rule)) {
            matchingRules.push(rule);
        }
    }
    return matchingRules;
}
function pinning_load(sharedInternalDocumentStore, raw) {
    const rawStore = raw;
    return {
        sharedInternalDocumentStore,
        rules: new Map(rawStore?.rules ?? [])
    };
}
function pinning_save(store) {
    return {
        rules: Array.from(store.rules.entries())
    };
}
function createPinning() {
    return {
        create: pinning_create,
        addRule,
        updateRule,
        removeRule,
        getRule,
        getAllRules,
        getMatchingRules,
        load: pinning_load,
        save: pinning_save
    };
}
//# sourceMappingURL=pinning.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/methods/create.js











function validateComponents(components) {
    const defaultComponents = {
        formatElapsedTime: defaults_formatElapsedTime,
        getDocumentIndexId: defaults_getDocumentIndexId,
        getDocumentProperties: utils_getDocumentProperties,
        validateSchema: defaults_validateSchema
    };
    for (const rawKey of FUNCTION_COMPONENTS) {
        const key = rawKey;
        if (components[key]) {
            if (typeof components[key] !== 'function') {
                throw errors_createError('COMPONENT_MUST_BE_FUNCTION', key);
            }
        }
        else {
            components[key] = defaultComponents[key];
        }
    }
    for (const rawKey of Object.keys(components)) {
        if (!OBJECT_COMPONENTS.includes(rawKey) && !FUNCTION_COMPONENTS.includes(rawKey)) {
            throw errors_createError('UNSUPPORTED_COMPONENT', rawKey);
        }
    }
}
function create_create({ schema, sort, language, components, id, plugins }) {
    if (!components) {
        components = {};
    }
    for (const plugin of plugins ?? []) {
        if (!('getComponents' in plugin)) {
            continue;
        }
        if (typeof plugin.getComponents !== 'function') {
            continue;
        }
        const pluginComponents = plugin.getComponents(schema);
        const keys = Object.keys(pluginComponents);
        for (const key of keys) {
            if (components[key]) {
                throw errors_createError('PLUGIN_COMPONENT_CONFLICT', key, plugin.name);
            }
        }
        components = {
            ...components,
            ...pluginComponents
        };
    }
    if (!id) {
        id = uniqueId();
    }
    let tokenizer = components.tokenizer;
    let index = components.index;
    let documentsStore = components.documentsStore;
    let sorter = components.sorter;
    let pinning = components.pinning;
    if (!tokenizer) {
        // Use the default tokenizer
        tokenizer = createTokenizer({ language: language ?? 'english' });
    }
    else if (!tokenizer.tokenize) {
        // If there is no tokenizer function, we assume this is a TokenizerConfig
        tokenizer = createTokenizer(tokenizer);
    }
    else {
        const customTokenizer = tokenizer;
        tokenizer = customTokenizer;
    }
    if (components.tokenizer && language) {
        // Accept language only if a tokenizer is not provided
        throw errors_createError('NO_LANGUAGE_WITH_CUSTOM_TOKENIZER');
    }
    const internalDocumentStore = createInternalDocumentIDStore();
    index ||= createIndex();
    sorter ||= createSorter();
    documentsStore ||= createDocumentsStore();
    pinning ||= createPinning();
    // Validate all other components
    validateComponents(components);
    // Assign only recognized components and hooks
    const { getDocumentProperties, getDocumentIndexId, validateSchema, formatElapsedTime } = components;
    const orama = {
        data: {},
        caches: {},
        schema,
        tokenizer,
        index,
        sorter,
        documentsStore,
        pinning,
        internalDocumentIDStore: internalDocumentStore,
        getDocumentProperties,
        getDocumentIndexId,
        validateSchema,
        beforeInsert: [],
        afterInsert: [],
        beforeRemove: [],
        afterRemove: [],
        beforeUpdate: [],
        afterUpdate: [],
        beforeUpsert: [],
        afterUpsert: [],
        beforeSearch: [],
        afterSearch: [],
        beforeInsertMultiple: [],
        afterInsertMultiple: [],
        beforeRemoveMultiple: [],
        afterRemoveMultiple: [],
        beforeUpdateMultiple: [],
        afterUpdateMultiple: [],
        beforeUpsertMultiple: [],
        afterUpsertMultiple: [],
        afterCreate: [],
        formatElapsedTime,
        id,
        plugins,
        version: getVersion()
    };
    orama.data = {
        index: orama.index.create(orama, internalDocumentStore, schema),
        docs: orama.documentsStore.create(orama, internalDocumentStore),
        sorting: orama.sorter.create(orama, internalDocumentStore, schema, sort),
        pinning: orama.pinning.create(internalDocumentStore)
    };
    for (const hook of AVAILABLE_PLUGIN_HOOKS) {
        orama[hook] = (orama[hook] ?? []).concat(getAllPluginsByHook(orama, hook));
    }
    const afterCreate = orama['afterCreate'];
    if (afterCreate) {
        runAfterCreate(afterCreate, orama);
    }
    return orama;
}
function getVersion() {
    return '{{VERSION}}';
}
//# sourceMappingURL=create.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components.js






//# sourceMappingURL=components.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/methods/insert.js





function insert_insert(orama, doc, language, skipHooks, options) {
    const errorProperty = orama.validateSchema(doc, orama.schema);
    if (errorProperty) {
        throw errors_createError('SCHEMA_VALIDATION_FAILURE', errorProperty);
    }
    const asyncNeeded = utils_isAsyncFunction(orama.beforeInsert) ||
        utils_isAsyncFunction(orama.afterInsert) ||
        utils_isAsyncFunction(orama.index.beforeInsert) ||
        utils_isAsyncFunction(orama.index.insert) ||
        utils_isAsyncFunction(orama.index.afterInsert);
    if (asyncNeeded) {
        return innerInsertAsync(orama, doc, language, skipHooks, options);
    }
    return innerInsertSync(orama, doc, language, skipHooks, options);
}
const ENUM_TYPE = new Set(['enum', 'enum[]']);
const STRING_NUMBER_TYPE = new Set(['string', 'number']);
async function innerInsertAsync(orama, doc, language, skipHooks, options) {
    const { index, docs } = orama.data;
    const id = orama.getDocumentIndexId(doc);
    if (typeof id !== 'string') {
        throw errors_createError('DOCUMENT_ID_MUST_BE_STRING', typeof id);
    }
    const internalId = internal_document_id_store_getInternalDocumentId(orama.internalDocumentIDStore, id);
    if (!skipHooks) {
        await hooks_runSingleHook(orama.beforeInsert, orama, id, doc);
    }
    if (!orama.documentsStore.store(docs, id, internalId, doc)) {
        throw errors_createError('DOCUMENT_ALREADY_EXISTS', id);
    }
    const docsCount = orama.documentsStore.count(docs);
    const indexableProperties = orama.index.getSearchableProperties(index);
    const indexablePropertiesWithTypes = orama.index.getSearchablePropertiesWithTypes(index);
    const indexableValues = orama.getDocumentProperties(doc, indexableProperties);
    for (const [key, value] of Object.entries(indexableValues)) {
        if (typeof value === 'undefined')
            continue;
        const actualType = typeof value;
        const expectedType = indexablePropertiesWithTypes[key];
        validateDocumentProperty(actualType, expectedType, key, value);
    }
    await indexAndSortDocument(orama, id, indexableProperties, indexableValues, docsCount, language, doc, options);
    if (!skipHooks) {
        await hooks_runSingleHook(orama.afterInsert, orama, id, doc);
    }
    return id;
}
function innerInsertSync(orama, doc, language, skipHooks, options) {
    const { index, docs } = orama.data;
    const id = orama.getDocumentIndexId(doc);
    if (typeof id !== 'string') {
        throw errors_createError('DOCUMENT_ID_MUST_BE_STRING', typeof id);
    }
    const internalId = internal_document_id_store_getInternalDocumentId(orama.internalDocumentIDStore, id);
    if (!skipHooks) {
        hooks_runSingleHook(orama.beforeInsert, orama, id, doc);
    }
    if (!orama.documentsStore.store(docs, id, internalId, doc)) {
        throw errors_createError('DOCUMENT_ALREADY_EXISTS', id);
    }
    const docsCount = orama.documentsStore.count(docs);
    const indexableProperties = orama.index.getSearchableProperties(index);
    const indexablePropertiesWithTypes = orama.index.getSearchablePropertiesWithTypes(index);
    const indexableValues = orama.getDocumentProperties(doc, indexableProperties);
    for (const [key, value] of Object.entries(indexableValues)) {
        if (typeof value === 'undefined')
            continue;
        const actualType = typeof value;
        const expectedType = indexablePropertiesWithTypes[key];
        validateDocumentProperty(actualType, expectedType, key, value);
    }
    indexAndSortDocumentSync(orama, id, indexableProperties, indexableValues, docsCount, language, doc, options);
    if (!skipHooks) {
        hooks_runSingleHook(orama.afterInsert, orama, id, doc);
    }
    return id;
}
function validateDocumentProperty(actualType, expectedType, key, value) {
    if (isGeoPointType(expectedType) &&
        typeof value === 'object' &&
        typeof value.lon === 'number' &&
        typeof value.lat === 'number') {
        return;
    }
    if (isVectorType(expectedType) && Array.isArray(value))
        return;
    if (isArrayType(expectedType) && Array.isArray(value))
        return;
    if (ENUM_TYPE.has(expectedType) && STRING_NUMBER_TYPE.has(actualType))
        return;
    if (actualType !== expectedType) {
        throw errors_createError('INVALID_DOCUMENT_PROPERTY', key, expectedType, actualType);
    }
}
async function indexAndSortDocument(orama, id, indexableProperties, indexableValues, docsCount, language, doc, options) {
    for (const prop of indexableProperties) {
        const value = indexableValues[prop];
        if (typeof value === 'undefined')
            continue;
        const expectedType = orama.index.getSearchablePropertiesWithTypes(orama.data.index)[prop];
        await orama.index.beforeInsert?.(orama.data.index, prop, id, value, expectedType, language, orama.tokenizer, docsCount);
        const internalId = orama.internalDocumentIDStore.idToInternalId.get(id);
        await orama.index.insert(orama.index, orama.data.index, prop, id, internalId, value, expectedType, language, orama.tokenizer, docsCount, options);
        await orama.index.afterInsert?.(orama.data.index, prop, id, value, expectedType, language, orama.tokenizer, docsCount);
    }
    const sortableProperties = orama.sorter.getSortableProperties(orama.data.sorting);
    const sortableValues = orama.getDocumentProperties(doc, sortableProperties);
    for (const prop of sortableProperties) {
        const value = sortableValues[prop];
        if (typeof value === 'undefined')
            continue;
        const expectedType = orama.sorter.getSortablePropertiesWithTypes(orama.data.sorting)[prop];
        orama.sorter.insert(orama.data.sorting, prop, id, value, expectedType, language);
    }
}
function indexAndSortDocumentSync(orama, id, indexableProperties, indexableValues, docsCount, language, doc, options) {
    for (const prop of indexableProperties) {
        const value = indexableValues[prop];
        if (typeof value === 'undefined')
            continue;
        const expectedType = orama.index.getSearchablePropertiesWithTypes(orama.data.index)[prop];
        const internalDocumentId = internal_document_id_store_getInternalDocumentId(orama.internalDocumentIDStore, id);
        orama.index.beforeInsert?.(orama.data.index, prop, id, value, expectedType, language, orama.tokenizer, docsCount);
        orama.index.insert(orama.index, orama.data.index, prop, id, internalDocumentId, value, expectedType, language, orama.tokenizer, docsCount, options);
        orama.index.afterInsert?.(orama.data.index, prop, id, value, expectedType, language, orama.tokenizer, docsCount);
    }
    const sortableProperties = orama.sorter.getSortableProperties(orama.data.sorting);
    const sortableValues = orama.getDocumentProperties(doc, sortableProperties);
    for (const prop of sortableProperties) {
        const value = sortableValues[prop];
        if (typeof value === 'undefined')
            continue;
        const expectedType = orama.sorter.getSortablePropertiesWithTypes(orama.data.sorting)[prop];
        orama.sorter.insert(orama.data.sorting, prop, id, value, expectedType, language);
    }
}
function insertMultiple(orama, docs, batchSize, language, skipHooks, timeout) {
    const asyncNeeded = utils_isAsyncFunction(orama.afterInsertMultiple) ||
        utils_isAsyncFunction(orama.beforeInsertMultiple) ||
        utils_isAsyncFunction(orama.index.beforeInsert) ||
        utils_isAsyncFunction(orama.index.insert) ||
        utils_isAsyncFunction(orama.index.afterInsert);
    if (asyncNeeded) {
        return innerInsertMultipleAsync(orama, docs, batchSize, language, skipHooks, timeout);
    }
    return innerInsertMultipleSync(orama, docs, batchSize, language, skipHooks, timeout);
}
async function innerInsertMultipleAsync(orama, docs, batchSize = 1000, language, skipHooks, timeout = 0) {
    const ids = [];
    const processNextBatch = async (startIndex) => {
        const endIndex = Math.min(startIndex + batchSize, docs.length);
        const batch = docs.slice(startIndex, endIndex);
        for (const doc of batch) {
            const options = { avlRebalanceThreshold: batch.length };
            const id = await insert_insert(orama, doc, language, skipHooks, options);
            ids.push(id);
        }
        return endIndex;
    };
    const processAllBatches = async () => {
        let currentIndex = 0;
        while (currentIndex < docs.length) {
            const startTime = Date.now();
            currentIndex = await processNextBatch(currentIndex);
            if (timeout > 0) {
                const elapsedTime = Date.now() - startTime;
                const waitTime = timeout - elapsedTime;
                if (waitTime > 0) {
                    sleep(waitTime);
                }
            }
        }
    };
    await processAllBatches();
    if (!skipHooks) {
        await hooks_runMultipleHook(orama.afterInsertMultiple, orama, docs);
    }
    return ids;
}
function innerInsertMultipleSync(orama, docs, batchSize = 1000, language, skipHooks, timeout = 0) {
    const ids = [];
    let i = 0;
    function processNextBatch() {
        const batch = docs.slice(i * batchSize, (i + 1) * batchSize);
        if (batch.length === 0)
            return false;
        for (const doc of batch) {
            const options = { avlRebalanceThreshold: batch.length };
            const id = insert_insert(orama, doc, language, skipHooks, options);
            ids.push(id);
        }
        i++;
        return true;
    }
    function processAllBatches() {
        const startTime = Date.now();
        // eslint-disable-next-line no-constant-condition
        while (true) {
            const hasMoreBatches = processNextBatch();
            if (!hasMoreBatches)
                break;
            if (timeout > 0) {
                const elapsedTime = Date.now() - startTime;
                if (elapsedTime >= timeout) {
                    const remainingTime = timeout - (elapsedTime % timeout);
                    if (remainingTime > 0) {
                        sleep(remainingTime);
                    }
                }
            }
        }
    }
    processAllBatches();
    if (!skipHooks) {
        hooks_runMultipleHook(orama.afterInsertMultiple, orama, docs);
    }
    return ids;
}
function insert_innerInsertMultiple(orama, docs, batchSize, language, skipHooks, timeout) {
    const asyncNeeded = isAsyncFunction(orama.beforeInsert) ||
        isAsyncFunction(orama.afterInsert) ||
        isAsyncFunction(orama.index.beforeInsert) ||
        isAsyncFunction(orama.index.insert) ||
        isAsyncFunction(orama.index.afterInsert);
    if (asyncNeeded) {
        return innerInsertMultipleAsync(orama, docs, batchSize, language, skipHooks, timeout);
    }
    return innerInsertMultipleSync(orama, docs, batchSize, language, skipHooks, timeout);
}
//# sourceMappingURL=insert.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/methods/remove.js



function remove_remove(orama, id, language, skipHooks) {
    const asyncNeeded = isAsyncFunction(orama.index.beforeRemove) ||
        isAsyncFunction(orama.index.remove) ||
        isAsyncFunction(orama.index.afterRemove);
    if (asyncNeeded) {
        return removeAsync(orama, id, language, skipHooks);
    }
    return removeSync(orama, id, language, skipHooks);
}
async function removeAsync(orama, id, language, skipHooks) {
    let result = true;
    const { index, docs } = orama.data;
    const doc = orama.documentsStore.get(docs, id);
    if (!doc) {
        return false;
    }
    const internalId = getInternalDocumentId(orama.internalDocumentIDStore, id);
    const docId = getDocumentIdFromInternalId(orama.internalDocumentIDStore, internalId);
    const docsCount = orama.documentsStore.count(docs);
    if (!skipHooks) {
        await runSingleHook(orama.beforeRemove, orama, docId);
    }
    const indexableProperties = orama.index.getSearchableProperties(index);
    const indexablePropertiesWithTypes = orama.index.getSearchablePropertiesWithTypes(index);
    const values = orama.getDocumentProperties(doc, indexableProperties);
    for (const prop of indexableProperties) {
        const value = values[prop];
        if (typeof value === 'undefined') {
            continue;
        }
        const schemaType = indexablePropertiesWithTypes[prop];
        await orama.index.beforeRemove?.(orama.data.index, prop, docId, value, schemaType, language, orama.tokenizer, docsCount);
        if (!(await orama.index.remove(orama.index, orama.data.index, prop, id, internalId, value, schemaType, language, orama.tokenizer, docsCount))) {
            result = false;
        }
        await orama.index.afterRemove?.(orama.data.index, prop, docId, value, schemaType, language, orama.tokenizer, docsCount);
    }
    const sortableProperties = await orama.sorter.getSortableProperties(orama.data.sorting);
    const sortableValues = await orama.getDocumentProperties(doc, sortableProperties);
    for (const prop of sortableProperties) {
        if (typeof sortableValues[prop] === 'undefined') {
            continue;
        }
        orama.sorter.remove(orama.data.sorting, prop, id);
    }
    if (!skipHooks) {
        await runSingleHook(orama.afterRemove, orama, docId);
    }
    orama.documentsStore.remove(orama.data.docs, id, internalId);
    return result;
}
function removeSync(orama, id, language, skipHooks) {
    let result = true;
    const { index, docs } = orama.data;
    const doc = orama.documentsStore.get(docs, id);
    if (!doc) {
        return false;
    }
    const internalId = getInternalDocumentId(orama.internalDocumentIDStore, id);
    const docId = getDocumentIdFromInternalId(orama.internalDocumentIDStore, internalId);
    const docsCount = orama.documentsStore.count(docs);
    if (!skipHooks) {
        runSingleHook(orama.beforeRemove, orama, docId);
    }
    const indexableProperties = orama.index.getSearchableProperties(index);
    const indexablePropertiesWithTypes = orama.index.getSearchablePropertiesWithTypes(index);
    const values = orama.getDocumentProperties(doc, indexableProperties);
    for (const prop of indexableProperties) {
        const value = values[prop];
        if (typeof value === 'undefined') {
            continue;
        }
        const schemaType = indexablePropertiesWithTypes[prop];
        orama.index.beforeRemove?.(orama.data.index, prop, docId, value, schemaType, language, orama.tokenizer, docsCount);
        if (!orama.index.remove(orama.index, orama.data.index, prop, id, internalId, value, schemaType, language, orama.tokenizer, docsCount)) {
            result = false;
        }
        orama.index.afterRemove?.(orama.data.index, prop, docId, value, schemaType, language, orama.tokenizer, docsCount);
    }
    const sortableProperties = orama.sorter.getSortableProperties(orama.data.sorting);
    const sortableValues = orama.getDocumentProperties(doc, sortableProperties);
    for (const prop of sortableProperties) {
        if (typeof sortableValues[prop] === 'undefined') {
            continue;
        }
        orama.sorter.remove(orama.data.sorting, prop, id);
    }
    if (!skipHooks) {
        runSingleHook(orama.afterRemove, orama, docId);
    }
    orama.documentsStore.remove(orama.data.docs, id, internalId);
    return result;
}
function remove_removeMultiple(orama, ids, batchSize, language, skipHooks) {
    const asyncNeeded = isAsyncFunction(orama.index.beforeRemove) ||
        isAsyncFunction(orama.index.remove) ||
        isAsyncFunction(orama.index.afterRemove) ||
        isAsyncFunction(orama.beforeRemoveMultiple) ||
        isAsyncFunction(orama.afterRemoveMultiple);
    if (asyncNeeded) {
        return removeMultipleAsync(orama, ids, batchSize, language, skipHooks);
    }
    return removeMultipleSync(orama, ids, batchSize, language, skipHooks);
}
async function removeMultipleAsync(orama, ids, batchSize, language, skipHooks) {
    let result = 0;
    if (!batchSize) {
        batchSize = 1000;
    }
    const docIdsForHooks = skipHooks
        ? []
        : ids.map((id) => getDocumentIdFromInternalId(orama.internalDocumentIDStore, getInternalDocumentId(orama.internalDocumentIDStore, id)));
    if (!skipHooks) {
        await runMultipleHook(orama.beforeRemoveMultiple, orama, docIdsForHooks);
    }
    await new Promise((resolve, reject) => {
        let i = 0;
        async function _removeMultiple() {
            const batch = ids.slice(i * batchSize, ++i * batchSize);
            if (!batch.length) {
                return resolve();
            }
            for (const doc of batch) {
                try {
                    if (await remove_remove(orama, doc, language, skipHooks)) {
                        result++;
                    }
                }
                catch (err) {
                    reject(err);
                }
            }
            setTimeout(_removeMultiple, 0);
        }
        setTimeout(_removeMultiple, 0);
    });
    if (!skipHooks) {
        await runMultipleHook(orama.afterRemoveMultiple, orama, docIdsForHooks);
    }
    return result;
}
function removeMultipleSync(orama, ids, batchSize, language, skipHooks) {
    let result = 0;
    if (!batchSize) {
        batchSize = 1000;
    }
    const docIdsForHooks = skipHooks
        ? []
        : ids.map((id) => getDocumentIdFromInternalId(orama.internalDocumentIDStore, getInternalDocumentId(orama.internalDocumentIDStore, id)));
    if (!skipHooks) {
        runMultipleHook(orama.beforeRemoveMultiple, orama, docIdsForHooks);
    }
    let i = 0;
    function _removeMultipleSync() {
        const batch = ids.slice(i * batchSize, ++i * batchSize);
        if (!batch.length)
            return;
        for (const doc of batch) {
            if (remove_remove(orama, doc, language, skipHooks)) {
                result++;
            }
        }
        setTimeout(_removeMultipleSync, 0);
    }
    _removeMultipleSync();
    if (!skipHooks) {
        runMultipleHook(orama.afterRemoveMultiple, orama, docIdsForHooks);
    }
    return result;
}
//# sourceMappingURL=remove.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/facets.js


function sortAsc(a, b) {
    return a[1] - b[1];
}
function sortDesc(a, b) {
    return b[1] - a[1];
}
function sortingPredicateBuilder(order = 'desc') {
    return order.toLowerCase() === 'asc' ? sortAsc : sortDesc;
}
function facets_getFacets(orama, results, facetsConfig) {
    const facets = {};
    const allIDs = results.map(([id]) => id);
    const allDocs = orama.documentsStore.getMultiple(orama.data.docs, allIDs);
    const facetKeys = Object.keys(facetsConfig);
    const properties = orama.index.getSearchablePropertiesWithTypes(orama.data.index);
    for (const facet of facetKeys) {
        let values;
        // Hack to guarantee the same order of ranges as specified by the user
        // TODO: Revisit this once components land
        if (properties[facet] === 'number') {
            const { ranges } = facetsConfig[facet];
            const rangesLength = ranges.length;
            const tmp = Array.from({ length: rangesLength });
            for (let i = 0; i < rangesLength; i++) {
                const range = ranges[i];
                tmp[i] = [`${range.from}-${range.to}`, 0];
            }
            values = Object.fromEntries(tmp);
        }
        facets[facet] = {
            count: 0,
            values: values ?? {}
        };
    }
    const allDocsLength = allDocs.length;
    for (let i = 0; i < allDocsLength; i++) {
        const doc = allDocs[i];
        for (const facet of facetKeys) {
            const facetValue = facet.includes('.') ? getNested(doc, facet) : doc[facet];
            const propertyType = properties[facet];
            const facetValues = facets[facet].values;
            switch (propertyType) {
                case 'number': {
                    const ranges = facetsConfig[facet].ranges;
                    calculateNumberFacetBuilder(ranges, facetValues)(facetValue);
                    break;
                }
                case 'number[]': {
                    const alreadyInsertedValues = new Set();
                    const ranges = facetsConfig[facet].ranges;
                    const calculateNumberFacet = calculateNumberFacetBuilder(ranges, facetValues, alreadyInsertedValues);
                    for (const v of facetValue) {
                        calculateNumberFacet(v);
                    }
                    break;
                }
                case 'boolean':
                case 'enum':
                case 'string': {
                    calculateBooleanStringOrEnumFacetBuilder(facetValues, propertyType)(facetValue);
                    break;
                }
                case 'boolean[]':
                case 'enum[]':
                case 'string[]': {
                    const alreadyInsertedValues = new Set();
                    const innerType = propertyType === 'boolean[]' ? 'boolean' : 'string';
                    const calculateBooleanStringOrEnumFacet = calculateBooleanStringOrEnumFacetBuilder(facetValues, innerType, alreadyInsertedValues);
                    for (const v of facetValue) {
                        calculateBooleanStringOrEnumFacet(v);
                    }
                    break;
                }
                default:
                    throw createError('FACET_NOT_SUPPORTED', propertyType);
            }
        }
    }
    // TODO: We are looping again with the same previous keys, should we creat a single loop instead?
    for (const facet of facetKeys) {
        const currentFacet = facets[facet];
        // Count the number of values for each facet
        currentFacet.count = Object.keys(currentFacet.values).length;
        // Sort only string-based facets
        if (properties[facet] === 'string') {
            const stringFacetDefinition = facetsConfig[facet];
            const sortingPredicate = sortingPredicateBuilder(stringFacetDefinition.sort);
            currentFacet.values = Object.fromEntries(Object.entries(currentFacet.values)
                .sort(sortingPredicate)
                .slice(stringFacetDefinition.offset ?? 0, stringFacetDefinition.limit ?? 10));
        }
    }
    return facets;
}
function calculateNumberFacetBuilder(ranges, values, alreadyInsertedValues) {
    return (facetValue) => {
        for (const range of ranges) {
            const value = `${range.from}-${range.to}`;
            if (alreadyInsertedValues?.has(value)) {
                continue;
            }
            if (facetValue >= range.from && facetValue <= range.to) {
                if (values[value] === undefined) {
                    values[value] = 1;
                }
                else {
                    values[value]++;
                    alreadyInsertedValues?.add(value);
                }
            }
        }
    };
}
function calculateBooleanStringOrEnumFacetBuilder(values, propertyType, alreadyInsertedValues) {
    const defaultValue = propertyType === 'boolean' ? 'false' : '';
    return (facetValue) => {
        // String or boolean based facets
        const value = facetValue?.toString() ?? defaultValue;
        if (alreadyInsertedValues?.has(value)) {
            return;
        }
        values[value] = (values[value] ?? 0) + 1;
        alreadyInsertedValues?.add(value);
    };
}
//# sourceMappingURL=facets.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/groups.js



const DEFAULT_REDUCE = (/* unused pure expression or super */ null && ({
    reducer: (_, acc, res, index) => {
        acc[index] = res;
        return acc;
    },
    getInitialValue: (length) => Array.from({ length })
}));
const ALLOWED_TYPES = (/* unused pure expression or super */ null && (['string', 'number', 'boolean']));
function groups_getGroups(orama, results, groupBy) {
    const properties = groupBy.properties;
    const propertiesLength = properties.length;
    const schemaProperties = orama.index.getSearchablePropertiesWithTypes(orama.data.index);
    for (let i = 0; i < propertiesLength; i++) {
        const property = properties[i];
        if (typeof schemaProperties[property] === 'undefined') {
            throw createError('UNKNOWN_GROUP_BY_PROPERTY', property);
        }
        if (!ALLOWED_TYPES.includes(schemaProperties[property])) {
            throw createError('INVALID_GROUP_BY_PROPERTY', property, ALLOWED_TYPES.join(', '), schemaProperties[property]);
        }
    }
    const allIDs = results.map(([id]) => getDocumentIdFromInternalId(orama.internalDocumentIDStore, id));
    // allDocs is already sorted by the sortBy algorithm
    // We leverage on that to limit the number of documents returned
    const allDocs = orama.documentsStore.getMultiple(orama.data.docs, allIDs);
    const allDocsLength = allDocs.length;
    const returnedCount = groupBy.maxResult || Number.MAX_SAFE_INTEGER;
    const listOfValues = [];
    // We want to understand which documents have which values
    // and group them by the property and values
    const g = {};
    for (let i = 0; i < propertiesLength; i++) {
        const groupByKey = properties[i];
        const group = {
            property: groupByKey,
            perValue: {}
        };
        const values = new Set();
        for (let j = 0; j < allDocsLength; j++) {
            const doc = allDocs[j];
            const value = getNested(doc, groupByKey);
            // we don't want to consider undefined values
            if (typeof value === 'undefined') {
                continue;
            }
            const keyValue = typeof value !== 'boolean' ? value : '' + value;
            const perValue = group.perValue[keyValue] ?? {
                indexes: [],
                count: 0
            };
            if (perValue.count >= returnedCount) {
                // We stop early because for this value we react the limit
                continue;
            }
            // We use the index to keep track of the original order
            perValue.indexes.push(j);
            perValue.count++;
            group.perValue[keyValue] = perValue;
            values.add(value);
        }
        listOfValues.push(Array.from(values));
        g[groupByKey] = group;
    }
    const combinations = calculateCombination(listOfValues);
    const combinationsLength = combinations.length;
    const groups = [];
    for (let i = 0; i < combinationsLength; i++) {
        const combination = combinations[i];
        const combinationLength = combination.length;
        const group = {
            values: [],
            indexes: []
        };
        const indexes = [];
        for (let j = 0; j < combinationLength; j++) {
            const value = combination[j];
            const property = properties[j];
            indexes.push(g[property].perValue[(typeof value !== 'boolean' ? value : '' + value)].indexes);
            group.values.push(value);
        }
        // We leverage on the index to sort the results by the original order
        group.indexes = intersect(indexes).sort((a, b) => a - b);
        // don't generate empty groups
        if (group.indexes.length === 0) {
            continue;
        }
        groups.push(group);
    }
    const groupsLength = groups.length;
    const res = Array.from({ length: groupsLength });
    for (let i = 0; i < groupsLength; i++) {
        const group = groups[i];
        const reduce = (groupBy.reduce || DEFAULT_REDUCE);
        const docs = group.indexes.map((index) => {
            return {
                id: allIDs[index],
                score: results[index][1],
                document: allDocs[index]
            };
        });
        const func = reduce.reducer.bind(null, group.values);
        const initialValue = reduce.getInitialValue(group.indexes.length);
        const aggregationValue = docs.reduce(func, initialValue);
        res[i] = {
            values: group.values,
            result: aggregationValue
        };
    }
    return res;
}
function calculateCombination(arrs, index = 0) {
    if (index + 1 === arrs.length)
        return arrs[index].map((item) => [item]);
    const head = arrs[index];
    const c = calculateCombination(arrs, index + 1);
    const combinations = [];
    for (const value of head) {
        for (const combination of c) {
            const result = [value];
            safeArrayPush(result, combination);
            combinations.push(result);
        }
    }
    return combinations;
}
//# sourceMappingURL=groups.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/methods/search-fulltext.js










function search_fulltext_innerFullTextSearch(orama, params, language) {
    const { term, properties } = params;
    const index = orama.data.index;
    // Get searchable string properties
    let propertiesToSearch = orama.caches['propertiesToSearch'];
    if (!propertiesToSearch) {
        const propertiesToSearchWithTypes = orama.index.getSearchablePropertiesWithTypes(index);
        propertiesToSearch = orama.index.getSearchableProperties(index);
        propertiesToSearch = propertiesToSearch.filter((prop) => propertiesToSearchWithTypes[prop].startsWith('string'));
        orama.caches['propertiesToSearch'] = propertiesToSearch;
    }
    if (properties && properties !== '*') {
        for (const prop of properties) {
            if (!propertiesToSearch.includes(prop)) {
                throw createError('UNKNOWN_INDEX', prop, propertiesToSearch.join(', '));
            }
        }
        propertiesToSearch = propertiesToSearch.filter((prop) => properties.includes(prop));
    }
    // If filters are enabled, we need to get the IDs of the documents that match the filters.
    const hasFilters = Object.keys(params.where ?? {}).length > 0;
    let whereFiltersIDs;
    if (hasFilters) {
        whereFiltersIDs = orama.index.searchByWhereClause(index, orama.tokenizer, params.where, language);
    }
    let uniqueDocsIDs;
    // We need to perform the search if:
    // - we have a search term
    // - or we have properties to search
    //   in this case, we need to return all the documents that contains at least one of the given properties
    const threshold = params.threshold !== undefined && params.threshold !== null ? params.threshold : 1;
    if (term || properties) {
        const docsCount = count(orama);
        uniqueDocsIDs = orama.index.search(index, term || '', orama.tokenizer, language, propertiesToSearch, params.exact || false, params.tolerance || 0, params.boost || {}, applyDefault(params.relevance), docsCount, whereFiltersIDs, threshold);
        // When exact is true and we have a term, filter results to only include documents
        // where the original text contains the exact search term (case-sensitive).
        // This is a highly requested feature and although Orama is not case-sensitive by design,
        // this is a reasonable compromise.
        if (params.exact && term) {
            const searchTerms = term.trim().split(/\s+/);
            uniqueDocsIDs = uniqueDocsIDs.filter(([docId]) => {
                const doc = orama.documentsStore.get(orama.data.docs, docId);
                if (!doc)
                    return false;
                // Check if any of the specified properties contain the exact search term
                for (const prop of propertiesToSearch) {
                    const propValue = getPropValue(doc, prop);
                    if (typeof propValue === 'string') {
                        // Check if all search terms appear as complete words in the property value
                        const hasAllTerms = searchTerms.every((searchTerm) => {
                            // Create a regex that matches the term as a complete word (case-sensitive)
                            const regex = new RegExp(`\\b${escapeRegex(searchTerm)}\\b`);
                            return regex.test(propValue);
                        });
                        if (hasAllTerms) {
                            return true;
                        }
                    }
                }
                return false;
            });
        }
    }
    else {
        // Check if this is a geosearch-only query first
        if (hasFilters) {
            const geoResults = searchByGeoWhereClause(index, params.where);
            if (geoResults) {
                // This is a geosearch-only query with distance scoring
                uniqueDocsIDs = geoResults;
            }
            else {
                // Regular filter query without search term
                const docIds = whereFiltersIDs ? Array.from(whereFiltersIDs) : [];
                uniqueDocsIDs = docIds.map((k) => [+k, 0]);
            }
        }
        else {
            // No search term and no filters - return all documents
            const docIds = Object.keys(orama.documentsStore.getAll(orama.data.docs));
            uniqueDocsIDs = docIds.map((k) => [+k, 0]);
        }
    }
    return uniqueDocsIDs;
}
// Helper function to escape regex special characters
function escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
// Helper function to get nested property value
function getPropValue(obj, path) {
    const keys = path.split('.');
    let value = obj;
    for (const key of keys) {
        if (value && typeof value === 'object' && key in value) {
            value = value[key];
        }
        else {
            return undefined;
        }
    }
    return value;
}
function search_fulltext_fullTextSearch(orama, params, language) {
    const timeStart = getNanosecondsTime();
    function performSearchLogic() {
        const vectorProperties = Object.keys(orama.data.index.vectorIndexes);
        const shouldCalculateFacets = params.facets && Object.keys(params.facets).length > 0;
        const { limit = 10, offset = 0, distinctOn, includeVectors = false } = params;
        const isPreflight = params.preflight === true;
        let uniqueDocsArray = search_fulltext_innerFullTextSearch(orama, params, language);
        if (params.sortBy) {
            if (typeof params.sortBy === 'function') {
                const ids = uniqueDocsArray.map(([id]) => id);
                const docs = orama.documentsStore.getMultiple(orama.data.docs, ids);
                const docsWithIdAndScore = docs.map((d, i) => [
                    uniqueDocsArray[i][0],
                    uniqueDocsArray[i][1],
                    d
                ]);
                docsWithIdAndScore.sort(params.sortBy);
                uniqueDocsArray = docsWithIdAndScore.map(([id, score]) => [id, score]);
            }
            else {
                uniqueDocsArray = orama.sorter
                    .sortBy(orama.data.sorting, uniqueDocsArray, params.sortBy)
                    .map(([id, score]) => [getInternalDocumentId(orama.internalDocumentIDStore, id), score]);
            }
        }
        else {
            uniqueDocsArray = uniqueDocsArray.sort(sortTokenScorePredicate);
        }
        // Apply pinning rules after sorting but before pagination
        uniqueDocsArray = applyPinningRules(orama, orama.data.pinning, uniqueDocsArray, params.term);
        let results;
        if (!isPreflight) {
            results = distinctOn
                ? fetchDocumentsWithDistinct(orama, uniqueDocsArray, offset, limit, distinctOn)
                : fetchDocuments(orama, uniqueDocsArray, offset, limit);
        }
        const searchResult = {
            elapsed: {
                formatted: '',
                raw: 0
            },
            hits: [],
            count: uniqueDocsArray.length
        };
        if (typeof results !== 'undefined') {
            searchResult.hits = results.filter(Boolean);
            if (!includeVectors) {
                removeVectorsFromHits(searchResult, vectorProperties);
            }
        }
        if (shouldCalculateFacets) {
            const facets = getFacets(orama, uniqueDocsArray, params.facets);
            searchResult.facets = facets;
        }
        if (params.groupBy) {
            searchResult.groups = getGroups(orama, uniqueDocsArray, params.groupBy);
        }
        searchResult.elapsed = orama.formatElapsedTime(getNanosecondsTime() - timeStart);
        return searchResult;
    }
    async function executeSearchAsync() {
        if (orama.beforeSearch) {
            await runBeforeSearch(orama.beforeSearch, orama, params, language);
        }
        const searchResult = performSearchLogic();
        if (orama.afterSearch) {
            await runAfterSearch(orama.afterSearch, orama, params, language, searchResult);
        }
        return searchResult;
    }
    const asyncNeeded = orama.beforeSearch?.length || orama.afterSearch?.length;
    if (asyncNeeded) {
        return executeSearchAsync();
    }
    return performSearchLogic();
}
const defaultBM25Params = (/* unused pure expression or super */ null && ({
    k: 1.2,
    b: 0.75,
    d: 0.5
}));
function applyDefault(bm25Relevance) {
    const r = bm25Relevance ?? {};
    r.k = r.k ?? defaultBM25Params.k;
    r.b = r.b ?? defaultBM25Params.b;
    r.d = r.d ?? defaultBM25Params.d;
    return r;
}
//# sourceMappingURL=search-fulltext.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/methods/search-vector.js








function search_vector_innerVectorSearch(orama, params, language) {
    const vector = params.vector;
    if (vector && (!('value' in vector) || !('property' in vector))) {
        throw createError('INVALID_VECTOR_INPUT', Object.keys(vector).join(', '));
    }
    const vectorIndex = orama.data.index.vectorIndexes[vector.property];
    if (!vectorIndex) {
        throw createError('UNKNOWN_VECTOR_PROPERTY', vector.property);
    }
    const vectorSize = vectorIndex.node.size;
    if (vector?.value.length !== vectorSize) {
        if (vector?.property === undefined || vector?.value.length === undefined) {
            throw createError('INVALID_INPUT_VECTOR', 'undefined', vectorSize, 'undefined');
        }
        throw createError('INVALID_INPUT_VECTOR', vector.property, vectorSize, vector.value.length);
    }
    const index = orama.data.index;
    let whereFiltersIDs;
    const hasFilters = Object.keys(params.where ?? {}).length > 0;
    if (hasFilters) {
        whereFiltersIDs = orama.index.searchByWhereClause(index, orama.tokenizer, params.where, language);
    }
    return vectorIndex.node.find(vector.value, params.similarity ?? DEFAULT_SIMILARITY, whereFiltersIDs);
}
function search_vector_searchVector(orama, params, language = 'english') {
    const timeStart = getNanosecondsTime();
    function performSearchLogic() {
        let results = search_vector_innerVectorSearch(orama, params, language)
            .sort(sortTokenScorePredicate);
        // Apply pinning rules after sorting but before pagination
        results = applyPinningRules(orama, orama.data.pinning, results, undefined);
        let facetsResults = [];
        const shouldCalculateFacets = params.facets && Object.keys(params.facets).length > 0;
        if (shouldCalculateFacets) {
            const facets = getFacets(orama, results, params.facets);
            facetsResults = facets;
        }
        const vectorProperty = params.vector.property;
        const includeVectors = params.includeVectors ?? false;
        const limit = params.limit ?? 10;
        const offset = params.offset ?? 0;
        const docs = Array.from({ length: limit });
        for (let i = 0; i < limit; i++) {
            const result = results[i + offset];
            if (!result) {
                break;
            }
            const doc = orama.data.docs.docs[result[0]];
            if (doc) {
                if (!includeVectors) {
                    doc[vectorProperty] = null;
                }
                const newDoc = {
                    id: getDocumentIdFromInternalId(orama.internalDocumentIDStore, result[0]),
                    score: result[1],
                    document: doc
                };
                docs[i] = newDoc;
            }
        }
        let groups = [];
        if (params.groupBy) {
            groups = getGroups(orama, results, params.groupBy);
        }
        const timeEnd = getNanosecondsTime();
        const elapsedTime = timeEnd - timeStart;
        return {
            count: results.length,
            hits: docs.filter(Boolean),
            elapsed: {
                raw: Number(elapsedTime),
                formatted: formatNanoseconds(elapsedTime)
            },
            ...(facetsResults ? { facets: facetsResults } : {}),
            ...(groups ? { groups } : {})
        };
    }
    async function executeSearchAsync() {
        if (orama.beforeSearch) {
            await runBeforeSearch(orama.beforeSearch, orama, params, language);
        }
        const results = performSearchLogic();
        if (orama.afterSearch) {
            await runAfterSearch(orama.afterSearch, orama, params, language, results);
        }
        return results;
    }
    const asyncNeeded = orama.beforeSearch?.length || orama.afterSearch?.length;
    if (asyncNeeded) {
        return executeSearchAsync();
    }
    // Sync path
    return performSearchLogic();
}
//# sourceMappingURL=search-vector.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/methods/search-hybrid.js








function innerHybridSearch(orama, params, language) {
    const fullTextIDs = minMaxScoreNormalization(innerFullTextSearch(orama, params, language));
    const vectorIDs = innerVectorSearch(orama, params, language);
    const hybridWeights = params.hybridWeights;
    return mergeAndRankResults(fullTextIDs, vectorIDs, params.term ?? '', hybridWeights);
}
function search_hybrid_hybridSearch(orama, params, language) {
    const timeStart = getNanosecondsTime();
    function performSearchLogic() {
        let uniqueTokenScores = innerHybridSearch(orama, params, language);
        // Apply pinning rules after merging results but before pagination
        uniqueTokenScores = applyPinningRules(orama, orama.data.pinning, uniqueTokenScores, params.term);
        let facetsResults;
        const shouldCalculateFacets = params.facets && Object.keys(params.facets).length > 0;
        if (shouldCalculateFacets) {
            facetsResults = getFacets(orama, uniqueTokenScores, params.facets);
        }
        let groups;
        if (params.groupBy) {
            groups = getGroups(orama, uniqueTokenScores, params.groupBy);
        }
        const offset = params.offset ?? 0;
        const limit = params.limit ?? 10;
        const results = fetchDocuments(orama, uniqueTokenScores, offset, limit).filter(Boolean);
        const timeEnd = getNanosecondsTime();
        const returningResults = {
            count: uniqueTokenScores.length,
            elapsed: {
                raw: Number(timeEnd - timeStart),
                formatted: formatNanoseconds(timeEnd - timeStart)
            },
            hits: results,
            ...(facetsResults ? { facets: facetsResults } : {}),
            ...(groups ? { groups } : {})
        };
        const includeVectors = params.includeVectors ?? false;
        if (!includeVectors) {
            const vectorProperties = Object.keys(orama.data.index.vectorIndexes);
            removeVectorsFromHits(returningResults, vectorProperties);
        }
        return returningResults;
    }
    async function executeSearchAsync() {
        if (orama.beforeSearch) {
            await runBeforeSearch(orama.beforeSearch, orama, params, language);
        }
        const results = performSearchLogic();
        if (orama.afterSearch) {
            await runAfterSearch(orama.afterSearch, orama, params, language, results);
        }
        return results;
    }
    const asyncNeeded = orama.beforeSearch?.length || orama.afterSearch?.length;
    if (asyncNeeded) {
        return executeSearchAsync();
    }
    return performSearchLogic();
}
function extractScore(token) {
    return token[1];
}
function minMaxScoreNormalization(results) {
    // In this case I disabled the `prefer-spread` rule because spread seems to be slower
    // eslint-disable-next-line prefer-spread
    const maxScore = Math.max.apply(Math, results.map(extractScore));
    return results.map(([id, score]) => [id, score / maxScore]);
}
function normalizeScore(score, maxScore) {
    return score / maxScore;
}
function hybridScoreBuilder(textWeight, vectorWeight) {
    return (textScore, vectorScore) => textScore * textWeight + vectorScore * vectorWeight;
}
function mergeAndRankResults(textResults, vectorResults, query, hybridWeights) {
    // eslint-disable-next-line prefer-spread
    const maxTextScore = Math.max.apply(Math, textResults.map(extractScore));
    // eslint-disable-next-line prefer-spread
    const maxVectorScore = Math.max.apply(Math, vectorResults.map(extractScore));
    const hasHybridWeights = hybridWeights && hybridWeights.text && hybridWeights.vector;
    const { text: textWeight, vector: vectorWeight } = hasHybridWeights ? hybridWeights : getQueryWeights(query);
    const mergedResults = new Map();
    const textResultsLength = textResults.length;
    const hybridScore = hybridScoreBuilder(textWeight, vectorWeight);
    for (let i = 0; i < textResultsLength; i++) {
        const [id, score] = textResults[i];
        const normalizedScore = normalizeScore(score, maxTextScore);
        const hybridScoreValue = hybridScore(normalizedScore, 0);
        mergedResults.set(id, hybridScoreValue);
    }
    const vectorResultsLength = vectorResults.length;
    for (let i = 0; i < vectorResultsLength; i++) {
        const [resultId, score] = vectorResults[i];
        const normalizedScore = normalizeScore(score, maxVectorScore);
        const existingRes = mergedResults.get(resultId) ?? 0;
        mergedResults.set(resultId, existingRes + hybridScore(0, normalizedScore));
    }
    return [...mergedResults].sort((a, b) => b[1] - a[1]);
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function getQueryWeights(query) {
    // In the next versions of Orama, we will ship a plugin containing a ML model to adjust the weights
    // based on whether the query is keyword-focused, conceptual, etc.
    // For now, we just return a fixed value.
    return {
        text: 0.5,
        vector: 0.5
    };
}
//# sourceMappingURL=search-hybrid.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/methods/search.js







function search_search(orama, params, language) {
    const mode = params.mode ?? MODE_FULLTEXT_SEARCH;
    if (mode === MODE_FULLTEXT_SEARCH) {
        return fullTextSearch(orama, params, language);
    }
    if (mode === MODE_VECTOR_SEARCH) {
        return searchVector(orama, params);
    }
    if (mode === MODE_HYBRID_SEARCH) {
        return hybridSearch(orama, params);
    }
    throw createError('INVALID_SEARCH_MODE', mode);
}
function search_fetchDocumentsWithDistinct(orama, uniqueDocsArray, offset, limit, distinctOn) {
    const docs = orama.data.docs;
    // Keep track which values we already seen
    const values = new Map();
    // We cannot know how many results we will have in the end,
    // so we need cannot pre-allocate the array.
    const results = [];
    const resultIDs = new Set();
    const uniqueDocsArrayLength = uniqueDocsArray.length;
    let count = 0;
    for (let i = 0; i < uniqueDocsArrayLength; i++) {
        const idAndScore = uniqueDocsArray[i];
        // If there are no more results, just break the loop
        if (typeof idAndScore === 'undefined') {
            continue;
        }
        const [id, score] = idAndScore;
        if (resultIDs.has(id)) {
            continue;
        }
        const doc = orama.documentsStore.get(docs, id);
        const value = getNested(doc, distinctOn);
        if (typeof value === 'undefined' || values.has(value)) {
            continue;
        }
        values.set(value, true);
        count++;
        // We shouldn't consider the document if it's not in the offset range
        if (count <= offset) {
            continue;
        }
        results.push({ id: getDocumentIdFromInternalId(orama.internalDocumentIDStore, id), score, document: doc });
        resultIDs.add(id);
        // reached the limit, break the loop
        if (count >= offset + limit) {
            break;
        }
    }
    return results;
}
function search_fetchDocuments(orama, uniqueDocsArray, offset, limit) {
    const docs = orama.data.docs;
    const results = Array.from({
        length: limit
    });
    const resultIDs = new Set();
    // We already have the list of ALL the document IDs containing the search terms.
    // We loop over them starting from a positional value "offset" and ending at "offset + limit"
    // to provide pagination capabilities to the search.
    for (let i = offset; i < limit + offset; i++) {
        const idAndScore = uniqueDocsArray[i];
        // If there are no more results, just break the loop
        if (typeof idAndScore === 'undefined') {
            break;
        }
        const [id, score] = idAndScore;
        if (!resultIDs.has(id)) {
            // We retrieve the full document only AFTER making sure that we really want it.
            // We never retrieve the full document preventively.
            const fullDoc = orama.documentsStore.get(docs, id);
            results[i] = { id: getDocumentIdFromInternalId(orama.internalDocumentIDStore, id), score, document: fullDoc };
            resultIDs.add(id);
        }
    }
    return results;
}
//# sourceMappingURL=search.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/methods/serialization.js
function serialization_load(orama, raw) {
    orama.internalDocumentIDStore.load(orama, raw.internalDocumentIDStore);
    orama.data.index = orama.index.load(orama.internalDocumentIDStore, raw.index);
    orama.data.docs = orama.documentsStore.load(orama.internalDocumentIDStore, raw.docs);
    orama.data.sorting = orama.sorter.load(orama.internalDocumentIDStore, raw.sorting);
    orama.data.pinning = orama.pinning.load(orama.internalDocumentIDStore, raw.pinning);
    orama.tokenizer.language = raw.language;
}
function serialization_save(orama) {
    return {
        internalDocumentIDStore: orama.internalDocumentIDStore.save(orama.internalDocumentIDStore),
        index: orama.index.save(orama.data.index),
        docs: orama.documentsStore.save(orama.data.docs),
        sorting: orama.sorter.save(orama.data.sorting),
        pinning: orama.pinning.save(orama.data.pinning),
        language: orama.tokenizer.language
    };
}
//# sourceMappingURL=serialization.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/methods/update.js





function update_update(orama, id, doc, language, skipHooks) {
    const asyncNeeded = isAsyncFunction(orama.afterInsert) ||
        isAsyncFunction(orama.beforeInsert) ||
        isAsyncFunction(orama.afterRemove) ||
        isAsyncFunction(orama.beforeRemove) ||
        isAsyncFunction(orama.beforeUpdate) ||
        isAsyncFunction(orama.afterUpdate);
    if (asyncNeeded) {
        return updateAsync(orama, id, doc, language, skipHooks);
    }
    return updateSync(orama, id, doc, language, skipHooks);
}
async function updateAsync(orama, id, doc, language, skipHooks) {
    if (!skipHooks && orama.beforeUpdate) {
        await runSingleHook(orama.beforeUpdate, orama, id);
    }
    await remove(orama, id, language, skipHooks);
    const newId = await insert(orama, doc, language, skipHooks);
    if (!skipHooks && orama.afterUpdate) {
        await runSingleHook(orama.afterUpdate, orama, newId);
    }
    return newId;
}
function updateSync(orama, id, doc, language, skipHooks) {
    if (!skipHooks && orama.beforeUpdate) {
        runSingleHook(orama.beforeUpdate, orama, id);
    }
    remove(orama, id, language, skipHooks);
    const newId = insert(orama, doc, language, skipHooks);
    if (!skipHooks && orama.afterUpdate) {
        runSingleHook(orama.afterUpdate, orama, newId);
    }
    return newId;
}
function update_updateMultiple(orama, ids, docs, batchSize, language, skipHooks) {
    const asyncNeeded = isAsyncFunction(orama.afterInsert) ||
        isAsyncFunction(orama.beforeInsert) ||
        isAsyncFunction(orama.afterRemove) ||
        isAsyncFunction(orama.beforeRemove) ||
        isAsyncFunction(orama.beforeUpdate) ||
        isAsyncFunction(orama.afterUpdate) ||
        isAsyncFunction(orama.beforeUpdateMultiple) ||
        isAsyncFunction(orama.afterUpdateMultiple) ||
        isAsyncFunction(orama.beforeRemoveMultiple) ||
        isAsyncFunction(orama.afterRemoveMultiple) ||
        isAsyncFunction(orama.beforeInsertMultiple) ||
        isAsyncFunction(orama.afterInsertMultiple);
    if (asyncNeeded) {
        return updateMultipleAsync(orama, ids, docs, batchSize, language, skipHooks);
    }
    return updateMultipleSync(orama, ids, docs, batchSize, language, skipHooks);
}
async function updateMultipleAsync(orama, ids, docs, batchSize, language, skipHooks) {
    if (!skipHooks) {
        await runMultipleHook(orama.beforeUpdateMultiple, orama, ids);
    }
    const docsLength = docs.length;
    for (let i = 0; i < docsLength; i++) {
        const errorProperty = orama.validateSchema(docs[i], orama.schema);
        if (errorProperty) {
            throw createError('SCHEMA_VALIDATION_FAILURE', errorProperty);
        }
    }
    await removeMultiple(orama, ids, batchSize, language, skipHooks);
    const newIds = await innerInsertMultiple(orama, docs, batchSize, language, skipHooks);
    if (!skipHooks) {
        await runMultipleHook(orama.afterUpdateMultiple, orama, newIds);
    }
    return newIds;
}
function updateMultipleSync(orama, ids, docs, batchSize, language, skipHooks) {
    if (!skipHooks) {
        runMultipleHook(orama.beforeUpdateMultiple, orama, ids);
    }
    const docsLength = docs.length;
    for (let i = 0; i < docsLength; i++) {
        const errorProperty = orama.validateSchema(docs[i], orama.schema);
        if (errorProperty) {
            throw createError('SCHEMA_VALIDATION_FAILURE', errorProperty);
        }
    }
    removeMultiple(orama, ids, batchSize, language, skipHooks);
    const newIds = innerInsertMultiple(orama, docs, batchSize, language, skipHooks);
    if (!skipHooks) {
        runMultipleHook(orama.afterUpdateMultiple, orama, newIds);
    }
    return newIds;
}
//# sourceMappingURL=update.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/methods/upsert.js





function upsert(orama, doc, language, skipHooks, options) {
    const asyncNeeded = isAsyncFunction(orama.afterInsert) ||
        isAsyncFunction(orama.beforeInsert) ||
        isAsyncFunction(orama.afterRemove) ||
        isAsyncFunction(orama.beforeRemove) ||
        isAsyncFunction(orama.beforeUpdate) ||
        isAsyncFunction(orama.afterUpdate) ||
        isAsyncFunction(orama.beforeUpsert) ||
        isAsyncFunction(orama.afterUpsert) ||
        isAsyncFunction(orama.index.beforeInsert) ||
        isAsyncFunction(orama.index.insert) ||
        isAsyncFunction(orama.index.afterInsert);
    if (asyncNeeded) {
        return upsertAsync(orama, doc, language, skipHooks, options);
    }
    return upsertSync(orama, doc, language, skipHooks, options);
}
async function upsertAsync(orama, doc, language, skipHooks, options) {
    const id = orama.getDocumentIndexId(doc);
    if (typeof id !== 'string') {
        throw createError('DOCUMENT_ID_MUST_BE_STRING', typeof id);
    }
    if (!skipHooks && orama.beforeUpsert) {
        await runSingleHook(orama.beforeUpsert, orama, id, doc);
    }
    // Check if document exists
    const existingDoc = orama.documentsStore.get(orama.data.docs, id);
    let resultId;
    if (existingDoc) {
        // Document exists, update it
        resultId = await update(orama, id, doc, language, skipHooks);
    }
    else {
        // Document doesn't exist, insert it
        resultId = await insert(orama, doc, language, skipHooks, options);
    }
    if (!skipHooks && orama.afterUpsert) {
        await runSingleHook(orama.afterUpsert, orama, resultId, doc);
    }
    return resultId;
}
function upsertSync(orama, doc, language, skipHooks, options) {
    const id = orama.getDocumentIndexId(doc);
    if (typeof id !== 'string') {
        throw createError('DOCUMENT_ID_MUST_BE_STRING', typeof id);
    }
    if (!skipHooks && orama.beforeUpsert) {
        runSingleHook(orama.beforeUpsert, orama, id, doc);
    }
    // Check if document exists
    const existingDoc = orama.documentsStore.get(orama.data.docs, id);
    let resultId;
    if (existingDoc) {
        // Document exists, update it
        resultId = update(orama, id, doc, language, skipHooks);
    }
    else {
        // Document doesn't exist, insert it
        resultId = insert(orama, doc, language, skipHooks, options);
    }
    if (!skipHooks && orama.afterUpsert) {
        runSingleHook(orama.afterUpsert, orama, resultId, doc);
    }
    return resultId;
}
function upsertMultiple(orama, docs, batchSize, language, skipHooks) {
    const asyncNeeded = isAsyncFunction(orama.afterInsert) ||
        isAsyncFunction(orama.beforeInsert) ||
        isAsyncFunction(orama.afterRemove) ||
        isAsyncFunction(orama.beforeRemove) ||
        isAsyncFunction(orama.beforeUpdate) ||
        isAsyncFunction(orama.afterUpdate) ||
        isAsyncFunction(orama.beforeUpsert) ||
        isAsyncFunction(orama.afterUpsert) ||
        isAsyncFunction(orama.beforeUpsertMultiple) ||
        isAsyncFunction(orama.afterUpsertMultiple) ||
        isAsyncFunction(orama.beforeInsertMultiple) ||
        isAsyncFunction(orama.afterInsertMultiple) ||
        isAsyncFunction(orama.beforeUpdateMultiple) ||
        isAsyncFunction(orama.afterUpdateMultiple) ||
        isAsyncFunction(orama.beforeRemoveMultiple) ||
        isAsyncFunction(orama.afterRemoveMultiple) ||
        isAsyncFunction(orama.index.beforeInsert) ||
        isAsyncFunction(orama.index.insert) ||
        isAsyncFunction(orama.index.afterInsert);
    if (asyncNeeded) {
        return upsertMultipleAsync(orama, docs, batchSize, language, skipHooks);
    }
    return upsertMultipleSync(orama, docs, batchSize, language, skipHooks);
}
async function upsertMultipleAsync(orama, docs, batchSize, language, skipHooks) {
    if (!skipHooks && orama.beforeUpsertMultiple) {
        await runMultipleHook(orama.beforeUpsertMultiple, orama, docs);
    }
    // Validate all documents first
    const docsLength = docs.length;
    for (let i = 0; i < docsLength; i++) {
        const errorProperty = orama.validateSchema(docs[i], orama.schema);
        if (errorProperty) {
            throw createError('SCHEMA_VALIDATION_FAILURE', errorProperty);
        }
    }
    // Separate documents into insert and update arrays
    const docsToInsert = [];
    const docsToUpdate = [];
    const idsToUpdate = [];
    for (const doc of docs) {
        const id = orama.getDocumentIndexId(doc);
        if (typeof id !== 'string') {
            throw createError('DOCUMENT_ID_MUST_BE_STRING', typeof id);
        }
        const existingDoc = orama.documentsStore.get(orama.data.docs, id);
        if (existingDoc) {
            docsToUpdate.push(doc);
            idsToUpdate.push(id);
        }
        else {
            docsToInsert.push(doc);
        }
    }
    // Perform bulk operations
    const results = [];
    if (docsToUpdate.length > 0) {
        const updateResults = await updateMultiple(orama, idsToUpdate, docsToUpdate, batchSize, language, skipHooks);
        results.push(...updateResults);
    }
    if (docsToInsert.length > 0) {
        const insertResults = await innerInsertMultiple(orama, docsToInsert, batchSize, language, skipHooks);
        results.push(...insertResults);
    }
    if (!skipHooks && orama.afterUpsertMultiple) {
        await runMultipleHook(orama.afterUpsertMultiple, orama, results);
    }
    return results;
}
function upsertMultipleSync(orama, docs, batchSize, language, skipHooks) {
    if (!skipHooks && orama.beforeUpsertMultiple) {
        runMultipleHook(orama.beforeUpsertMultiple, orama, docs);
    }
    // Validate all documents first
    const docsLength = docs.length;
    for (let i = 0; i < docsLength; i++) {
        const errorProperty = orama.validateSchema(docs[i], orama.schema);
        if (errorProperty) {
            throw createError('SCHEMA_VALIDATION_FAILURE', errorProperty);
        }
    }
    // Separate documents into insert and update arrays
    const docsToInsert = [];
    const docsToUpdate = [];
    const idsToUpdate = [];
    for (const doc of docs) {
        const id = orama.getDocumentIndexId(doc);
        if (typeof id !== 'string') {
            throw createError('DOCUMENT_ID_MUST_BE_STRING', typeof id);
        }
        const existingDoc = orama.documentsStore.get(orama.data.docs, id);
        if (existingDoc) {
            docsToUpdate.push(doc);
            idsToUpdate.push(id);
        }
        else {
            docsToInsert.push(doc);
        }
    }
    // Perform bulk operations
    const results = [];
    if (docsToUpdate.length > 0) {
        const updateResults = updateMultiple(orama, idsToUpdate, docsToUpdate, batchSize, language, skipHooks);
        results.push(...updateResults);
    }
    if (docsToInsert.length > 0) {
        const insertResults = innerInsertMultiple(orama, docsToInsert, batchSize, language, skipHooks);
        results.push(...insertResults);
    }
    if (!skipHooks && orama.afterUpsertMultiple) {
        runMultipleHook(orama.afterUpsertMultiple, orama, results);
    }
    return results;
}
//# sourceMappingURL=upsert.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/methods/answer-session.js


const ORAMA_SECURE_PROXY_PLUGIN_NAME = 'orama-secure-proxy';
class AnswerSession {
    db;
    proxy = null;
    config;
    abortController = null;
    lastInteractionParams = null;
    chatModel = null;
    conversationID;
    messages = [];
    events;
    initPromise;
    state = [];
    constructor(db, config) {
        this.db = db;
        this.config = config;
        this.init();
        this.messages = config.initialMessages || [];
        this.events = config.events || {};
        this.conversationID = config.conversationID || this.generateRandomID();
    }
    async ask(query) {
        await this.initPromise;
        let output = '';
        for await (const msg of await this.askStream(query)) {
            output += msg;
        }
        return output;
    }
    async askStream(query) {
        await this.initPromise;
        return this.fetchAnswer(query);
    }
    abortAnswer() {
        this.abortController?.abort();
        this.state[this.state.length - 1].aborted = true;
        this.triggerStateChange();
    }
    getMessages() {
        return this.messages;
    }
    clearSession() {
        this.messages = [];
        this.state = [];
    }
    regenerateLast({ stream = true }) {
        if (this.state.length === 0 || this.messages.length === 0) {
            throw new Error('No messages to regenerate');
        }
        const isLastMessageAssistant = this.messages.at(-1)?.role === 'assistant';
        if (!isLastMessageAssistant) {
            throw createError('ANSWER_SESSION_LAST_MESSAGE_IS_NOT_ASSISTANT');
        }
        this.messages.pop();
        this.state.pop();
        if (stream) {
            return this.askStream(this.lastInteractionParams);
        }
        return this.ask(this.lastInteractionParams);
    }
    async *fetchAnswer(params) {
        if (!this.chatModel) {
            throw createError('PLUGIN_SECURE_PROXY_MISSING_CHAT_MODEL');
        }
        this.abortController = new AbortController();
        this.lastInteractionParams = params;
        const interactionId = this.generateRandomID();
        this.messages.push({ role: 'user', content: params.term ?? '' });
        this.state.push({
            interactionId,
            aborted: false,
            loading: true,
            query: params.term ?? '',
            response: '',
            sources: null,
            translatedQuery: null,
            error: false,
            errorMessage: null
        });
        const stateIdx = this.state.length - 1;
        this.addEmptyAssistantMessage();
        this.triggerStateChange();
        try {
            const sources = await search(this.db, params);
            this.state[stateIdx].sources = sources;
            this.triggerStateChange();
            for await (const msg of this.proxy.chatStream({ model: this.chatModel, messages: this.messages })) {
                yield msg;
                this.state[stateIdx].response += msg;
                this.messages.findLast((msg) => msg.role === 'assistant').content += msg;
                this.triggerStateChange();
            }
        }
        catch (err) {
            if (err.name === 'AbortError') {
                this.state[stateIdx].aborted = true;
            }
            else {
                this.state[stateIdx].error = true;
                this.state[stateIdx].errorMessage = err.toString();
            }
            this.triggerStateChange();
        }
        this.state[stateIdx].loading = false;
        this.triggerStateChange();
        return this.state[stateIdx].response;
    }
    generateRandomID(length = 24) {
        return Array.from({ length }, () => Math.floor(Math.random() * 36).toString(36)).join('');
    }
    triggerStateChange() {
        if (this.events.onStateChange) {
            this.events.onStateChange(this.state);
        }
    }
    async init() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        async function getPlugin() {
            return await self.db.plugins.find((plugin) => plugin.name === ORAMA_SECURE_PROXY_PLUGIN_NAME);
        }
        const plugin = await getPlugin();
        if (!plugin) {
            throw createError('PLUGIN_SECURE_PROXY_NOT_FOUND');
        }
        const pluginExtras = plugin.extra;
        this.proxy = pluginExtras.proxy;
        if (this.config.systemPrompt) {
            this.messages.push({ role: 'system', content: this.config.systemPrompt });
        }
        if (pluginExtras?.pluginParams?.chat?.model) {
            this.chatModel = pluginExtras.pluginParams.chat.model;
        }
        else {
            throw createError('PLUGIN_SECURE_PROXY_MISSING_CHAT_MODEL');
        }
    }
    addEmptyAssistantMessage() {
        this.messages.push({ role: 'assistant', content: '' });
    }
}
//# sourceMappingURL=answer-session.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/types.js

const kInsertions = Symbol('orama.insertions');
const kRemovals = Symbol('orama.removals');
//# sourceMappingURL=types.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/internals.js



//# sourceMappingURL=internals.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/index.js














//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/plugin-analytics/dist/index.js
function dist_l(t,e){if(typeof navigator<"u"&&typeof navigator.sendBeacon=="function"){navigator.sendBeacon(t,e);return}fetch(t,{method:"POST",body:e,headers:{"Content-Type":"application/json"}}).catch(n=>{console.error(n)})}var dist_d="https://telemetry.orama.run/oss_collect",u="-",dist_f="-",dist_p="oss-fe";var dist_r=class t{data;config;constructor(e){this.data=[],this.config=e}static create(e){let n=new t(e);return n.start(),n}add(e){this.data.push({rawSearchString:e.rawSearchString,query:e.query,resultsCount:e.resultsCount,roundTripTime:e.roundTripTime,searchedAt:e.searchedAt,results:e.results,referer:typeof location<"u"?location.toString():void 0}),this.data.length>=this.config.flushSize&&this.flush()}flush(){if(this.data.length===0)return;let e=this.data;this.data=[];let n={source:dist_p,deploymentID:this.config.deploymentId,index:this.config.indexId,oramaId:this.config.oramaId,oramaVersion:this.config.oramaVersion,userAgent:typeof navigator<"u"?navigator.userAgent:void 0,events:e};dist_l(this.config.endpoint+`?api-key=${this.config.apiKey}`,JSON.stringify(n))}start(){let e=setInterval(this.flush.bind(this),this.config.flushInterval);e.unref!=null&&e.unref()}};var dist_h="plugin-analytics";function O(t){if(t.enabled===!1)return{name:dist_h};if(!t.apiKey)throw new Error("Missing apiKey for plugin-analytics");if(!t.indexId)throw new Error("Missing indexId for plugin-analytics");let e=t.flushInterval||5e3,n=t.flushSize||25,g=t.endpoint||dist_d,A=t.deploymentId||u,a;return{name:dist_h,afterSearch:(o,s,T,i)=>{a?.add({query:s,resultsCount:i.count,roundTripTime:Math.round(i.elapsed.raw/1e6),searchedAt:new Date,cached:!1,rawSearchString:s.term,results:i.hits?.map(c=>({id:c.id,score:c.score}))})},afterCreate:o=>{a=dist_r.create({endpoint:g,indexId:t.indexId,deploymentId:A,oramaId:o.id,oramaVersion:o.version||dist_f,apiKey:t.apiKey,flushSize:n,flushInterval:e})}}}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/oramacore-events-parser/esm/main.js
const STATES_STEPS = (/* unused pure expression or super */ null && ([
    // Main answer flow states
    'initializing',
    'handle_gpu_overload',
    'get_llm_config',
    'determine_query_strategy',
    'simple_rag', // When simple RAG is selected
    'advanced_autoquery', // When advanced autoquery is selected
    'handle_system_prompt',
    'optimize_query',
    'execute_search',
    'execute_before_answer_hook',
    'generate_answer',
    'generate_related_queries',
    'completed',
    'error',
    // Advanced autoquery states (forwarded with prefix)
    'advanced_autoquery_initializing',
    'advanced_autoquery_analyzing_input',
    'advanced_autoquery_query_optimized',
    'advanced_autoquery_select_properties',
    'advanced_autoquery_properties_selected',
    'advanced_autoquery_combine_queries',
    'advanced_autoquery_queries_combined',
    'advanced_autoquery_generate_tracked_queries',
    'advanced_autoquery_tracked_queries_generated',
    'advanced_autoquery_execute_before_retrieval_hook',
    'advanced_autoquery_hooks_executed',
    'advanced_autoquery_execute_searches',
    'advanced_autoquery_search_results',
    'advanced_autoquery_completed',
]));
const PROGRESS_STEPS = (/* unused pure expression or super */ null && ([
    // Main answer flow progress steps (enum variant names)
    'Initialize',
    'HandleGPUOverload',
    'GetLLMConfig',
    'DetermineQueryStrategy',
    'HandleSystemPrompt',
    'OptimizeQuery',
    'ExecuteSearch',
    'ExecuteBeforeAnswerHook',
    'GenerateAnswer',
    'GenerateRelatedQueries',
    'Completed',
    'Error',
    // Advanced autoquery progress steps
    'AnalyzeInput',
    'QueryOptimized',
    'SelectProperties',
    'PropertiesSelected',
    'CombineQueriesAndProperties',
    'QueriesCombined',
    'GenerateTrackedQueries',
    'TrackedQueriesGenerated',
    'ExecuteBeforeRetrievalHook',
    'HooksExecuted',
    'ExecuteSearches',
    'SearchResults',
]));
class EventsStreamTransformer extends TransformStream {
    constructor() {
        const decoder = new TextDecoder('utf-8', { ignoreBOM: false });
        let buffer = '';
        super({
            start() {
                buffer = '';
            },
            transform(chunk, controller) {
                const chunkText = decoder.decode(chunk);
                buffer += chunkText;
                // Split on double newlines (end of SSE event)
                let eventEnd = buffer.indexOf('\n\n');
                while (eventEnd === -1 && buffer.indexOf('\r\n\r\n') !== -1) {
                    eventEnd = buffer.indexOf('\r\n\r\n');
                }
                while (eventEnd !== -1) {
                    // Support both \n\n and \r\n\r\n as event delimiters
                    let delimiterLength = 2;
                    if (buffer.slice(eventEnd, eventEnd + 4) === '\r\n\r\n') {
                        delimiterLength = 4;
                    }
                    const eventBlock = buffer.slice(0, eventEnd);
                    buffer = buffer.slice(eventEnd + delimiterLength);
                    // Find the data line(s)
                    const dataLines = eventBlock
                        .split(/\r?\n/)
                        .filter((line) => line.startsWith('data:'));
                    for (const dataLine of dataLines) {
                        const jsonStr = dataLine.replace(/^data:\s*/, '');
                        try {
                            // Handle string events like "acknowledged"
                            if (jsonStr.startsWith('"') && jsonStr.endsWith('"')) {
                                const stringEvent = JSON.parse(jsonStr);
                                controller.enqueue({ type: stringEvent });
                                continue;
                            }
                            let parsed = JSON.parse(jsonStr);
                            // Handle new nested structure
                            if (typeof parsed === 'object' &&
                                parsed !== null &&
                                !('type' in parsed)) {
                                // Convert nested format like {"state_changed": {...}} to {type: "state_changed", ...}
                                const keys = Object.keys(parsed);
                                if (keys.length === 1) {
                                    const [eventType] = keys;
                                    const eventData = parsed[eventType];
                                    if (typeof eventData === 'object' && eventData !== null) {
                                        parsed = { type: eventType, ...eventData };
                                    }
                                    else {
                                        parsed = { type: eventType, data: eventData };
                                    }
                                }
                            }
                            controller.enqueue(parsed);
                        }
                        catch (e) {
                            controller.enqueue({
                                type: 'error',
                                error: 'Invalid JSON in SSE data',
                                state: 'parse_error',
                            });
                        }
                    }
                    // Find the next event
                    eventEnd = buffer.indexOf('\n\n');
                    if (eventEnd === -1 && buffer.indexOf('\r\n\r\n') !== -1) {
                        eventEnd = buffer.indexOf('\r\n\r\n');
                    }
                }
            },
        });
    }
}
class OramaEventEmitter {
    constructor() {
        Object.defineProperty(this, "handlers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "endHandlers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "done", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "resolveDone", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => { }
        });
        this.done = new Promise((resolve) => {
            this.resolveDone = resolve;
        });
    }
    on(event, handler) {
        if (!this.handlers[event]) {
            this.handlers[event] = [];
        }
        this.handlers[event].push(handler);
        return this;
    }
    onStateChange(handler) {
        return this.on('state_changed', handler);
    }
    onProgress(handler) {
        return this.on('progress', handler);
    }
    onEnd(handler) {
        this.endHandlers.push(handler);
        return this;
    }
    emit(event) {
        const hs = this.handlers[event.type];
        if (hs) {
            for (const h of hs)
                h(event);
        }
        // Check for completion - updated for new event format
        const shouldEnd = 
        // Success completion
        (event.type === 'state_changed' &&
            'state' in event &&
            (event.state === 'completed' ||
                event.state === 'advanced_autoquery_completed')) ||
            // Terminal errors only
            (event.type === 'error' &&
                'is_terminal' in event &&
                event.is_terminal === true);
        if (shouldEnd) {
            this._triggerEnd();
        }
    }
    _triggerEnd() {
        for (const handler of this.endHandlers) {
            handler();
        }
    }
    _markDone() {
        this.resolveDone();
    }
}
function isAnswerEvent(event) {
    // First check for Answer-specific event types
    if (event.type === 'acknowledged' ||
        event.type === 'selected_llm' ||
        event.type === 'optimizing_query' ||
        event.type === 'answer_token' ||
        event.type === 'related_queries' ||
        event.type === 'result_action') {
        return true;
    }
    // For overlapping types, include all since AnswerEvent is a superset
    // The distinction is made at the parser level, not the type guard level
    if (event.type === 'state_changed' ||
        event.type === 'error' ||
        event.type === 'progress' ||
        event.type === 'search_results') {
        return true;
    }
    return false;
}
function isAdvancedAutoqueryEvent(event) {
    // Advanced autoquery events can have any state - the prefix logic only applies
    // when they're forwarded through the answer stream
    return (event.type === 'state_changed' ||
        event.type === 'error' ||
        event.type === 'progress' ||
        event.type === 'search_results');
}
function parseAnswerStream(stream) {
    const emitter = new OramaEventEmitter();
    const transformer = new EventsStreamTransformer();
    (async () => {
        const reader = stream.pipeThrough(transformer).getReader();
        while (true) {
            const { value, done } = await reader.read();
            if (done)
                break;
            if (isAnswerEvent(value))
                emitter.emit(value);
        }
        // Give a small delay to ensure all events are emitted
        await new Promise((resolve) => setTimeout(resolve, 0));
        emitter._markDone();
    })();
    return emitter;
}
function parseNLPQueryStream(stream) {
    const emitter = new OramaEventEmitter();
    const transformer = new EventsStreamTransformer();
    (async () => {
        const reader = stream.pipeThrough(transformer).getReader();
        while (true) {
            const { value, done } = await reader.read();
            if (done)
                break;
            if (isAdvancedAutoqueryEvent(value))
                emitter.emit(value);
        }
        // Give a small delay to ensure all events are emitted
        await new Promise((resolve) => setTimeout(resolve, 0));
        emitter._markDone();
    })();
    return emitter;
}
function isAnswerFlowState(state) {
    return !state.startsWith('advanced_autoquery_');
}
function isAdvancedAutoqueryState(state) {
    return state.startsWith('advanced_autoquery_');
}

// EXTERNAL MODULE: ./node_modules/@orama/cuid2/index.js
var cuid2 = __webpack_require__(96389);
;// CONCATENATED MODULE: ./node_modules/@orama/core/esm/_dnt.shims.js
const dntGlobals = {};
const dntGlobalThis = createMergeProxy(globalThis, dntGlobals);
function createMergeProxy(baseObj, extObj) {
    return new Proxy(baseObj, {
        get(_target, prop, _receiver) {
            if (prop in extObj) {
                return extObj[prop];
            }
            else {
                return baseObj[prop];
            }
        },
        set(_target, prop, value) {
            if (prop in extObj) {
                delete extObj[prop];
            }
            baseObj[prop] = value;
            return true;
        },
        deleteProperty(_target, prop) {
            let success = false;
            if (prop in extObj) {
                delete extObj[prop];
                success = true;
            }
            if (prop in baseObj) {
                delete baseObj[prop];
                success = true;
            }
            return success;
        },
        ownKeys(_target) {
            const baseKeys = Reflect.ownKeys(baseObj);
            const extKeys = Reflect.ownKeys(extObj);
            const extKeysSet = new Set(extKeys);
            return [...baseKeys.filter((k) => !extKeysSet.has(k)), ...extKeys];
        },
        defineProperty(_target, prop, desc) {
            if (prop in extObj) {
                delete extObj[prop];
            }
            Reflect.defineProperty(baseObj, prop, desc);
            return true;
        },
        getOwnPropertyDescriptor(_target, prop) {
            if (prop in extObj) {
                return Reflect.getOwnPropertyDescriptor(extObj, prop);
            }
            else {
                return Reflect.getOwnPropertyDescriptor(baseObj, prop);
            }
        },
        has(_target, prop) {
            return prop in extObj || prop in baseObj;
        },
    });
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/Options.js
const ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
const jsonDescription = (jsonSchema, def) => {
    if (def.description) {
        try {
            return {
                ...jsonSchema,
                ...JSON.parse(def.description),
            };
        }
        catch { }
    }
    return jsonSchema;
};
const defaultOptions = {
    name: undefined,
    $refStrategy: "root",
    basePath: ["#"],
    effectStrategy: "input",
    pipeStrategy: "all",
    dateStrategy: "format:date-time",
    mapStrategy: "entries",
    removeAdditionalStrategy: "passthrough",
    allowedAdditionalProperties: true,
    rejectedAdditionalProperties: false,
    definitionPath: "definitions",
    target: "jsonSchema7",
    strictUnions: false,
    definitions: {},
    errorMessages: false,
    markdownDescription: false,
    patternStrategy: "escape",
    applyRegexFlags: false,
    emailStrategy: "format:email",
    base64Strategy: "contentEncoding:base64",
    nameStrategy: "ref",
};
const getDefaultOptions = (options) => (typeof options === "string"
    ? {
        ...defaultOptions,
        name: options,
    }
    : {
        ...defaultOptions,
        ...options,
    });

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/Refs.js

const getRefs = (options) => {
    const _options = getDefaultOptions(options);
    const currentPath = _options.name !== undefined
        ? [..._options.basePath, _options.definitionPath, _options.name]
        : _options.basePath;
    return {
        ..._options,
        currentPath: currentPath,
        propertyPath: undefined,
        seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [
            def._def,
            {
                def: def._def,
                path: [..._options.basePath, _options.definitionPath, name],
                // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
                jsonSchema: undefined,
            },
        ])),
    };
};

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod/lib/index.mjs
var lib_util;
(function (util) {
    util.assertEqual = (val) => val;
    function assertIs(_arg) { }
    util.assertIs = assertIs;
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
            obj[item] = item;
        }
        return obj;
    };
    util.getValidEnumValues = (obj) => {
        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
            filtered[k] = obj[k];
        }
        return util.objectValues(filtered);
    };
    util.objectValues = (obj) => {
        return util.objectKeys(obj).map(function (e) {
            return obj[e];
        });
    };
    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban
        : (object) => {
            const keys = [];
            for (const key in object) {
                if (Object.prototype.hasOwnProperty.call(object, key)) {
                    keys.push(key);
                }
            }
            return keys;
        };
    util.find = (arr, checker) => {
        for (const item of arr) {
            if (checker(item))
                return item;
        }
        return undefined;
    };
    util.isInteger = typeof Number.isInteger === "function"
        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
        : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
        return array
            .map((val) => (typeof val === "string" ? `'${val}'` : val))
            .join(separator);
    }
    util.joinValues = joinValues;
    util.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
            return value.toString();
        }
        return value;
    };
})(lib_util || (lib_util = {}));
var lib_objectUtil;
(function (objectUtil) {
    objectUtil.mergeShapes = (first, second) => {
        return {
            ...first,
            ...second, // second overwrites first
        };
    };
})(lib_objectUtil || (lib_objectUtil = {}));
const ZodParsedType = lib_util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
]);
const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
        case "undefined":
            return ZodParsedType.undefined;
        case "string":
            return ZodParsedType.string;
        case "number":
            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
            return ZodParsedType.boolean;
        case "function":
            return ZodParsedType.function;
        case "bigint":
            return ZodParsedType.bigint;
        case "symbol":
            return ZodParsedType.symbol;
        case "object":
            if (Array.isArray(data)) {
                return ZodParsedType.array;
            }
            if (data === null) {
                return ZodParsedType.null;
            }
            if (data.then &&
                typeof data.then === "function" &&
                data.catch &&
                typeof data.catch === "function") {
                return ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
                return ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
                return ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
                return ZodParsedType.date;
            }
            return ZodParsedType.object;
        default:
            return ZodParsedType.unknown;
    }
};

const ZodIssueCode = lib_util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
]);
const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
    get errors() {
        return this.issues;
    }
    constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            // eslint-disable-next-line ban/ban
            Object.setPrototypeOf(this, actualProto);
        }
        else {
            this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
    }
    format(_mapper) {
        const mapper = _mapper ||
            function (issue) {
                return issue.message;
            };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
            for (const issue of error.issues) {
                if (issue.code === "invalid_union") {
                    issue.unionErrors.map(processError);
                }
                else if (issue.code === "invalid_return_type") {
                    processError(issue.returnTypeError);
                }
                else if (issue.code === "invalid_arguments") {
                    processError(issue.argumentsError);
                }
                else if (issue.path.length === 0) {
                    fieldErrors._errors.push(mapper(issue));
                }
                else {
                    let curr = fieldErrors;
                    let i = 0;
                    while (i < issue.path.length) {
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) {
                            curr[el] = curr[el] || { _errors: [] };
                            // if (typeof el === "string") {
                            //   curr[el] = curr[el] || { _errors: [] };
                            // } else if (typeof el === "number") {
                            //   const errorArray: any = [];
                            //   errorArray._errors = [];
                            //   curr[el] = curr[el] || errorArray;
                            // }
                        }
                        else {
                            curr[el] = curr[el] || { _errors: [] };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    static assert(value) {
        if (!(value instanceof ZodError)) {
            throw new Error(`Not a ZodError: ${value}`);
        }
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, lib_util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
            if (sub.path.length > 0) {
                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                fieldErrors[sub.path[0]].push(mapper(sub));
            }
            else {
                formErrors.push(mapper(sub));
            }
        }
        return { formErrors, fieldErrors };
    }
    get formErrors() {
        return this.flatten();
    }
}
ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
};

const lib_errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
        case ZodIssueCode.invalid_type:
            if (issue.received === ZodParsedType.undefined) {
                message = "Required";
            }
            else {
                message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
        case ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, lib_util.jsonStringifyReplacer)}`;
            break;
        case ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${lib_util.joinValues(issue.keys, ", ")}`;
            break;
        case ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${lib_util.joinValues(issue.options)}`;
            break;
        case ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${lib_util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
        case ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
        case ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
                if ("includes" in issue.validation) {
                    message = `Invalid input: must include "${issue.validation.includes}"`;
                    if (typeof issue.validation.position === "number") {
                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                    }
                }
                else if ("startsWith" in issue.validation) {
                    message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                }
                else if ("endsWith" in issue.validation) {
                    message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                }
                else {
                    lib_util.assertNever(issue.validation);
                }
            }
            else if (issue.validation !== "regex") {
                message = `Invalid ${issue.validation}`;
            }
            else {
                message = "Invalid";
            }
            break;
        case ZodIssueCode.too_small:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${issue.minimum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${new Date(Number(issue.minimum))}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.too_big:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint")
                message = `BigInt must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `smaller than or equal to`
                        : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.custom:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        case ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
        default:
            message = _ctx.defaultError;
            lib_util.assertNever(issue);
    }
    return { message };
};

let overrideErrorMap = lib_errorMap;
function setErrorMap(map) {
    overrideErrorMap = map;
}
function getErrorMap() {
    return overrideErrorMap;
}

const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...(issueData.path || [])];
    const fullIssue = {
        ...issueData,
        path: fullPath,
    };
    if (issueData.message !== undefined) {
        return {
            ...issueData,
            path: fullPath,
            message: issueData.message,
        };
    }
    let errorMessage = "";
    const maps = errorMaps
        .filter((m) => !!m)
        .slice()
        .reverse();
    for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
        ...issueData,
        path: fullPath,
        message: errorMessage,
    };
};
const EMPTY_PATH = (/* unused pure expression or super */ null && ([]));
function addIssueToContext(ctx, issueData) {
    const overrideMap = getErrorMap();
    const issue = makeIssue({
        issueData: issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
            ctx.common.contextualErrorMap, // contextual error map is first priority
            ctx.schemaErrorMap, // then schema-bound map if available
            overrideMap, // then global override map
            overrideMap === lib_errorMap ? undefined : lib_errorMap, // then global default map
        ].filter((x) => !!x),
    });
    ctx.common.issues.push(issue);
}
class ParseStatus {
    constructor() {
        this.value = "valid";
    }
    dirty() {
        if (this.value === "valid")
            this.value = "dirty";
    }
    abort() {
        if (this.value !== "aborted")
            this.value = "aborted";
    }
    static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
            if (s.status === "aborted")
                return INVALID;
            if (s.status === "dirty")
                status.dirty();
            arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
                key,
                value,
            });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
                return INVALID;
            if (value.status === "aborted")
                return INVALID;
            if (key.status === "dirty")
                status.dirty();
            if (value.status === "dirty")
                status.dirty();
            if (key.value !== "__proto__" &&
                (typeof value.value !== "undefined" || pair.alwaysSet)) {
                finalObject[key.value] = value.value;
            }
        }
        return { status: status.value, value: finalObject };
    }
}
const INVALID = Object.freeze({
    status: "aborted",
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var lib_errorUtil;
(function (errorUtil) {
    errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(lib_errorUtil || (lib_errorUtil = {}));

var _ZodEnum_cache, _ZodNativeEnum_cache;
class ParseInputLazyPath {
    constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
    }
    get path() {
        if (!this._cachedPath.length) {
            if (this._key instanceof Array) {
                this._cachedPath.push(...this._path, ...this._key);
            }
            else {
                this._cachedPath.push(...this._path, this._key);
            }
        }
        return this._cachedPath;
    }
}
const handleResult = (ctx, result) => {
    if (isValid(result)) {
        return { success: true, data: result.value };
    }
    else {
        if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
        }
        return {
            success: false,
            get error() {
                if (this._error)
                    return this._error;
                const error = new ZodError(ctx.common.issues);
                this._error = error;
                return this._error;
            },
        };
    }
};
function processCreateParams(params) {
    if (!params)
        return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap)
        return { errorMap: errorMap, description };
    const customMap = (iss, ctx) => {
        var _a, _b;
        const { message } = params;
        if (iss.code === "invalid_enum_value") {
            return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
        }
        if (typeof ctx.data === "undefined") {
            return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
        }
        if (iss.code !== "invalid_type")
            return { message: ctx.defaultError };
        return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
    };
    return { errorMap: customMap, description };
}
class ZodType {
    get description() {
        return this._def.description;
    }
    _getType(input) {
        return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
        return (ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent,
        });
    }
    _processInputParams(input) {
        return {
            status: new ParseStatus(),
            ctx: {
                common: input.parent.common,
                data: input.data,
                parsedType: getParsedType(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent,
            },
        };
    }
    _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
            throw new Error("Synchronous parse encountered promise.");
        }
        return result;
    }
    _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
    }
    parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    safeParse(data, params) {
        var _a;
        const ctx = {
            common: {
                issues: [],
                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
    }
    "~validate"(data) {
        var _a, _b;
        const ctx = {
            common: {
                issues: [],
                async: !!this["~standard"].async,
            },
            path: [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        if (!this["~standard"].async) {
            try {
                const result = this._parseSync({ data, path: [], parent: ctx });
                return isValid(result)
                    ? {
                        value: result.value,
                    }
                    : {
                        issues: ctx.common.issues,
                    };
            }
            catch (err) {
                if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
                    this["~standard"].async = true;
                }
                ctx.common = {
                    issues: [],
                    async: true,
                };
            }
        }
        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result)
            ? {
                value: result.value,
            }
            : {
                issues: ctx.common.issues,
            });
    }
    async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    async safeParseAsync(data, params) {
        const ctx = {
            common: {
                issues: [],
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
                async: true,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult)
            ? maybeAsyncResult
            : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
    }
    refine(check, message) {
        const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
                return { message };
            }
            else if (typeof message === "function") {
                return message(val);
            }
            else {
                return message;
            }
        };
        return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () => ctx.addIssue({
                code: ZodIssueCode.custom,
                ...getIssueProperties(val),
            });
            if (typeof Promise !== "undefined" && result instanceof Promise) {
                return result.then((data) => {
                    if (!data) {
                        setError();
                        return false;
                    }
                    else {
                        return true;
                    }
                });
            }
            if (!result) {
                setError();
                return false;
            }
            else {
                return true;
            }
        });
    }
    refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
            if (!check(val)) {
                ctx.addIssue(typeof refinementData === "function"
                    ? refinementData(val, ctx)
                    : refinementData);
                return false;
            }
            else {
                return true;
            }
        });
    }
    _refinement(refinement) {
        return new ZodEffects({
            schema: this,
            typeName: lib_ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "refinement", refinement },
        });
    }
    superRefine(refinement) {
        return this._refinement(refinement);
    }
    constructor(def) {
        /** Alias of safeParseAsync */
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
            version: 1,
            vendor: "zod",
            validate: (data) => this["~validate"](data),
        };
    }
    optional() {
        return ZodOptional.create(this, this._def);
    }
    nullable() {
        return ZodNullable.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return ZodArray.create(this);
    }
    promise() {
        return ZodPromise.create(this, this._def);
    }
    or(option) {
        return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
        return new ZodEffects({
            ...processCreateParams(this._def),
            schema: this,
            typeName: lib_ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "transform", transform },
        });
    }
    default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
            ...processCreateParams(this._def),
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: lib_ZodFirstPartyTypeKind.ZodDefault,
        });
    }
    brand() {
        return new ZodBranded({
            typeName: lib_ZodFirstPartyTypeKind.ZodBranded,
            type: this,
            ...processCreateParams(this._def),
        });
    }
    catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
            ...processCreateParams(this._def),
            innerType: this,
            catchValue: catchValueFunc,
            typeName: lib_ZodFirstPartyTypeKind.ZodCatch,
        });
    }
    describe(description) {
        const This = this.constructor;
        return new This({
            ...this._def,
            description,
        });
    }
    pipe(target) {
        return ZodPipeline.create(this, target);
    }
    readonly() {
        return ZodReadonly.create(this);
    }
    isOptional() {
        return this.safeParse(undefined).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
// const uuidRegex =
//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
// from https://stackoverflow.com/a/46181/1550155
// old version: too slow, didn't support unicode
// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
//old email regex
// const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
// eslint-disable-next-line
// const emailRegex =
//   /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
// const emailRegex =
//   /^[a-zA-Z0-9\.\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
// const emailRegex =
//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
// const emailRegex =
//   /^[a-z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9\-]+)*$/i;
// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
// faster, simpler, safer
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
// const ipv6Regex =
// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
// https://base64.guru/standards/base64url
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
// simple
// const dateRegexSource = `\\d{4}-\\d{2}-\\d{2}`;
// no leap year validation
// const dateRegexSource = `\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\d|2\\d))`;
// with leap year validation
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
    // let regex = `\\d{2}:\\d{2}:\\d{2}`;
    let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
    if (args.precision) {
        regex = `${regex}\\.\\d{${args.precision}}`;
    }
    else if (args.precision == null) {
        regex = `${regex}(\\.\\d+)?`;
    }
    return regex;
}
function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
}
// Adapted from https://stackoverflow.com/a/3143231
function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
        opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
        return true;
    }
    return false;
}
function isValidJWT(jwt, alg) {
    if (!jwtRegex.test(jwt))
        return false;
    try {
        const [header] = jwt.split(".");
        // Convert base64url to base64
        const base64 = header
            .replace(/-/g, "+")
            .replace(/_/g, "/")
            .padEnd(header.length + ((4 - (header.length % 4)) % 4), "=");
        const decoded = JSON.parse(atob(base64));
        if (typeof decoded !== "object" || decoded === null)
            return false;
        if (!decoded.typ || !decoded.alg)
            return false;
        if (alg && decoded.alg !== alg)
            return false;
        return true;
    }
    catch (_a) {
        return false;
    }
}
function isValidCidr(ip, version) {
    if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
        return true;
    }
    return false;
}
class ZodString extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.string,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "length") {
                const tooBig = input.data.length > check.value;
                const tooSmall = input.data.length < check.value;
                if (tooBig || tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    if (tooBig) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    else if (tooSmall) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    status.dirty();
                }
            }
            else if (check.kind === "email") {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "email",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "emoji") {
                if (!emojiRegex) {
                    emojiRegex = new RegExp(_emojiRegex, "u");
                }
                if (!emojiRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "emoji",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "uuid") {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "uuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "nanoid") {
                if (!nanoidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "nanoid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid") {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid2") {
                if (!cuid2Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid2",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ulid") {
                if (!ulidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ulid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "url") {
                try {
                    new URL(input.data);
                }
                catch (_a) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "regex") {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "regex",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "trim") {
                input.data = input.data.trim();
            }
            else if (check.kind === "includes") {
                if (!input.data.includes(check.value, check.position)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { includes: check.value, position: check.position },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "toLowerCase") {
                input.data = input.data.toLowerCase();
            }
            else if (check.kind === "toUpperCase") {
                input.data = input.data.toUpperCase();
            }
            else if (check.kind === "startsWith") {
                if (!input.data.startsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { startsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "endsWith") {
                if (!input.data.endsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { endsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "datetime") {
                const regex = datetimeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "datetime",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "date") {
                const regex = dateRegex;
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "date",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "time") {
                const regex = timeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "time",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "duration") {
                if (!durationRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "duration",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ip") {
                if (!isValidIP(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ip",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "jwt") {
                if (!isValidJWT(input.data, check.alg)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "jwt",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cidr") {
                if (!isValidCidr(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cidr",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "base64") {
                if (!base64Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "base64",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "base64url") {
                if (!base64urlRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "base64url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                lib_util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
            validation,
            code: ZodIssueCode.invalid_string,
            ...lib_errorUtil.errToObj(message),
        });
    }
    _addCheck(check) {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    email(message) {
        return this._addCheck({ kind: "email", ...lib_errorUtil.errToObj(message) });
    }
    url(message) {
        return this._addCheck({ kind: "url", ...lib_errorUtil.errToObj(message) });
    }
    emoji(message) {
        return this._addCheck({ kind: "emoji", ...lib_errorUtil.errToObj(message) });
    }
    uuid(message) {
        return this._addCheck({ kind: "uuid", ...lib_errorUtil.errToObj(message) });
    }
    nanoid(message) {
        return this._addCheck({ kind: "nanoid", ...lib_errorUtil.errToObj(message) });
    }
    cuid(message) {
        return this._addCheck({ kind: "cuid", ...lib_errorUtil.errToObj(message) });
    }
    cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...lib_errorUtil.errToObj(message) });
    }
    ulid(message) {
        return this._addCheck({ kind: "ulid", ...lib_errorUtil.errToObj(message) });
    }
    base64(message) {
        return this._addCheck({ kind: "base64", ...lib_errorUtil.errToObj(message) });
    }
    base64url(message) {
        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
        return this._addCheck({
            kind: "base64url",
            ...lib_errorUtil.errToObj(message),
        });
    }
    jwt(options) {
        return this._addCheck({ kind: "jwt", ...lib_errorUtil.errToObj(options) });
    }
    ip(options) {
        return this._addCheck({ kind: "ip", ...lib_errorUtil.errToObj(options) });
    }
    cidr(options) {
        return this._addCheck({ kind: "cidr", ...lib_errorUtil.errToObj(options) });
    }
    datetime(options) {
        var _a, _b;
        if (typeof options === "string") {
            return this._addCheck({
                kind: "datetime",
                precision: null,
                offset: false,
                local: false,
                message: options,
            });
        }
        return this._addCheck({
            kind: "datetime",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
            local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
            ...lib_errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    date(message) {
        return this._addCheck({ kind: "date", message });
    }
    time(options) {
        if (typeof options === "string") {
            return this._addCheck({
                kind: "time",
                precision: null,
                message: options,
            });
        }
        return this._addCheck({
            kind: "time",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            ...lib_errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    duration(message) {
        return this._addCheck({ kind: "duration", ...lib_errorUtil.errToObj(message) });
    }
    regex(regex, message) {
        return this._addCheck({
            kind: "regex",
            regex: regex,
            ...lib_errorUtil.errToObj(message),
        });
    }
    includes(value, options) {
        return this._addCheck({
            kind: "includes",
            value: value,
            position: options === null || options === void 0 ? void 0 : options.position,
            ...lib_errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    startsWith(value, message) {
        return this._addCheck({
            kind: "startsWith",
            value: value,
            ...lib_errorUtil.errToObj(message),
        });
    }
    endsWith(value, message) {
        return this._addCheck({
            kind: "endsWith",
            value: value,
            ...lib_errorUtil.errToObj(message),
        });
    }
    min(minLength, message) {
        return this._addCheck({
            kind: "min",
            value: minLength,
            ...lib_errorUtil.errToObj(message),
        });
    }
    max(maxLength, message) {
        return this._addCheck({
            kind: "max",
            value: maxLength,
            ...lib_errorUtil.errToObj(message),
        });
    }
    length(len, message) {
        return this._addCheck({
            kind: "length",
            value: len,
            ...lib_errorUtil.errToObj(message),
        });
    }
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(message) {
        return this.min(1, lib_errorUtil.errToObj(message));
    }
    trim() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "trim" }],
        });
    }
    toLowerCase() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toLowerCase" }],
        });
    }
    toUpperCase() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toUpperCase" }],
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
        return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
        return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
ZodString.create = (params) => {
    var _a;
    return new ZodString({
        checks: [],
        typeName: lib_ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params),
    });
};
// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return (valInt % stepInt) / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.number,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "int") {
                if (!lib_util.isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (floatSafeRemainder(input.data, check.value) !== 0) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "finite") {
                if (!Number.isFinite(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_finite,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                lib_util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, lib_errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, lib_errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, lib_errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, lib_errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: lib_errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodNumber({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    int(message) {
        return this._addCheck({
            kind: "int",
            message: lib_errorUtil.toString(message),
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: lib_errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: lib_errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: lib_errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: lib_errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value: value,
            message: lib_errorUtil.toString(message),
        });
    }
    finite(message) {
        return this._addCheck({
            kind: "finite",
            message: lib_errorUtil.toString(message),
        });
    }
    safe(message) {
        return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: lib_errorUtil.toString(message),
        })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: lib_errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
    get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" ||
            (ch.kind === "multipleOf" && lib_util.isInteger(ch.value)));
    }
    get isFinite() {
        let max = null, min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "finite" ||
                ch.kind === "int" ||
                ch.kind === "multipleOf") {
                return true;
            }
            else if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
            else if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return Number.isFinite(min) && Number.isFinite(max);
    }
}
ZodNumber.create = (params) => {
    return new ZodNumber({
        checks: [],
        typeName: lib_ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params),
    });
};
class ZodBigInt extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
    }
    _parse(input) {
        if (this._def.coerce) {
            try {
                input.data = BigInt(input.data);
            }
            catch (_a) {
                return this._getInvalidInput(input);
            }
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
            return this._getInvalidInput(input);
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        type: "bigint",
                        minimum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        type: "bigint",
                        maximum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (input.data % check.value !== BigInt(0)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                lib_util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.bigint,
            received: ctx.parsedType,
        });
        return INVALID;
    }
    gte(value, message) {
        return this.setLimit("min", value, true, lib_errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, lib_errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, lib_errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, lib_errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: lib_errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodBigInt({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: lib_errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: lib_errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: lib_errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: lib_errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value,
            message: lib_errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
ZodBigInt.create = (params) => {
    var _a;
    return new ZodBigInt({
        checks: [],
        typeName: lib_ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params),
    });
};
class ZodBoolean extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.boolean,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodBoolean.create = (params) => {
    return new ZodBoolean({
        typeName: lib_ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params),
    });
};
class ZodDate extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.date,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (isNaN(input.data.getTime())) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_date,
            });
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.getTime() < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        minimum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.getTime() > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        maximum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else {
                lib_util.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: new Date(input.data.getTime()),
        };
    }
    _addCheck(check) {
        return new ZodDate({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    min(minDate, message) {
        return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: lib_errorUtil.toString(message),
        });
    }
    max(maxDate, message) {
        return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: lib_errorUtil.toString(message),
        });
    }
    get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min != null ? new Date(min) : null;
    }
    get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max != null ? new Date(max) : null;
    }
}
ZodDate.create = (params) => {
    return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: lib_ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params),
    });
};
class ZodSymbol extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.symbol,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodSymbol.create = (params) => {
    return new ZodSymbol({
        typeName: lib_ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params),
    });
};
class ZodUndefined extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.undefined,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodUndefined.create = (params) => {
    return new ZodUndefined({
        typeName: lib_ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params),
    });
};
class ZodNull extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.null,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodNull.create = (params) => {
    return new ZodNull({
        typeName: lib_ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params),
    });
};
class ZodAny extends ZodType {
    constructor() {
        super(...arguments);
        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
        this._any = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodAny.create = (params) => {
    return new ZodAny({
        typeName: lib_ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params),
    });
};
class ZodUnknown extends ZodType {
    constructor() {
        super(...arguments);
        // required
        this._unknown = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodUnknown.create = (params) => {
    return new ZodUnknown({
        typeName: lib_ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params),
    });
};
class ZodNever extends ZodType {
    _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.never,
            received: ctx.parsedType,
        });
        return INVALID;
    }
}
ZodNever.create = (params) => {
    return new ZodNever({
        typeName: lib_ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params),
    });
};
class ZodVoid extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.void,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodVoid.create = (params) => {
    return new ZodVoid({
        typeName: lib_ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params),
    });
};
class ZodArray extends ZodType {
    _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (def.exactLength !== null) {
            const tooBig = ctx.data.length > def.exactLength.value;
            const tooSmall = ctx.data.length < def.exactLength.value;
            if (tooBig || tooSmall) {
                addIssueToContext(ctx, {
                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                    minimum: (tooSmall ? def.exactLength.value : undefined),
                    maximum: (tooBig ? def.exactLength.value : undefined),
                    type: "array",
                    inclusive: true,
                    exact: true,
                    message: def.exactLength.message,
                });
                status.dirty();
            }
        }
        if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.minLength.message,
                });
                status.dirty();
            }
        }
        if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.maxLength.message,
                });
                status.dirty();
            }
        }
        if (ctx.common.async) {
            return Promise.all([...ctx.data].map((item, i) => {
                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result) => {
                return ParseStatus.mergeArray(status, result);
            });
        }
        const result = [...ctx.data].map((item, i) => {
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
    }
    get element() {
        return this._def.type;
    }
    min(minLength, message) {
        return new ZodArray({
            ...this._def,
            minLength: { value: minLength, message: lib_errorUtil.toString(message) },
        });
    }
    max(maxLength, message) {
        return new ZodArray({
            ...this._def,
            maxLength: { value: maxLength, message: lib_errorUtil.toString(message) },
        });
    }
    length(len, message) {
        return new ZodArray({
            ...this._def,
            exactLength: { value: len, message: lib_errorUtil.toString(message) },
        });
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodArray.create = (schema, params) => {
    return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: lib_ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params),
    });
};
function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
        const newShape = {};
        for (const key in schema.shape) {
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
            ...schema._def,
            shape: () => newShape,
        });
    }
    else if (schema instanceof ZodArray) {
        return new ZodArray({
            ...schema._def,
            type: deepPartialify(schema.element),
        });
    }
    else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    }
    else {
        return schema;
    }
}
class ZodObject extends ZodType {
    constructor() {
        super(...arguments);
        this._cached = null;
        /**
         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
         * If you want to pass through unknown properties, use `.passthrough()` instead.
         */
        this.nonstrict = this.passthrough;
        // extend<
        //   Augmentation extends ZodRawShape,
        //   NewOutput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
        //       ? Augmentation[k]["_output"]
        //       : k extends keyof Output
        //       ? Output[k]
        //       : never;
        //   }>,
        //   NewInput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
        //       ? Augmentation[k]["_input"]
        //       : k extends keyof Input
        //       ? Input[k]
        //       : never;
        //   }>
        // >(
        //   augmentation: Augmentation
        // ): ZodObject<
        //   extendShape<T, Augmentation>,
        //   UnknownKeys,
        //   Catchall,
        //   NewOutput,
        //   NewInput
        // > {
        //   return new ZodObject({
        //     ...this._def,
        //     shape: () => ({
        //       ...this._def.shape(),
        //       ...augmentation,
        //     }),
        //   }) as any;
        // }
        /**
         * @deprecated Use `.extend` instead
         *  */
        this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const shape = this._def.shape();
        const keys = lib_util.objectKeys(shape);
        return (this._cached = { shape, keys });
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever &&
            this._def.unknownKeys === "strip")) {
            for (const key in ctx.data) {
                if (!shapeKeys.includes(key)) {
                    extraKeys.push(key);
                }
            }
        }
        const pairs = [];
        for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
                key: { status: "valid", value: key },
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
                for (const key of extraKeys) {
                    pairs.push({
                        key: { status: "valid", value: key },
                        value: { status: "valid", value: ctx.data[key] },
                    });
                }
            }
            else if (unknownKeys === "strict") {
                if (extraKeys.length > 0) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.unrecognized_keys,
                        keys: extraKeys,
                    });
                    status.dirty();
                }
            }
            else if (unknownKeys === "strip") ;
            else {
                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
        }
        else {
            // run catchall validation
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
                const value = ctx.data[key];
                pairs.push({
                    key: { status: "valid", value: key },
                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
                    ),
                    alwaysSet: key in ctx.data,
                });
            }
        }
        if (ctx.common.async) {
            return Promise.resolve()
                .then(async () => {
                const syncPairs = [];
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    syncPairs.push({
                        key,
                        value,
                        alwaysSet: pair.alwaysSet,
                    });
                }
                return syncPairs;
            })
                .then((syncPairs) => {
                return ParseStatus.mergeObjectSync(status, syncPairs);
            });
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get shape() {
        return this._def.shape();
    }
    strict(message) {
        lib_errorUtil.errToObj;
        return new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...(message !== undefined
                ? {
                    errorMap: (issue, ctx) => {
                        var _a, _b, _c, _d;
                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
                        if (issue.code === "unrecognized_keys")
                            return {
                                message: (_d = lib_errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,
                            };
                        return {
                            message: defaultError,
                        };
                    },
                }
                : {}),
        });
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip",
        });
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough",
        });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
        return new ZodObject({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...augmentation,
            }),
        });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
        const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => ({
                ...this._def.shape(),
                ...merging._def.shape(),
            }),
            typeName: lib_ZodFirstPartyTypeKind.ZodObject,
        });
        return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
        return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
        return new ZodObject({
            ...this._def,
            catchall: index,
        });
    }
    pick(mask) {
        const shape = {};
        lib_util.objectKeys(mask).forEach((key) => {
            if (mask[key] && this.shape[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    omit(mask) {
        const shape = {};
        lib_util.objectKeys(this.shape).forEach((key) => {
            if (!mask[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    /**
     * @deprecated
     */
    deepPartial() {
        return deepPartialify(this);
    }
    partial(mask) {
        const newShape = {};
        lib_util.objectKeys(this.shape).forEach((key) => {
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) {
                newShape[key] = fieldSchema;
            }
            else {
                newShape[key] = fieldSchema.optional();
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    required(mask) {
        const newShape = {};
        lib_util.objectKeys(this.shape).forEach((key) => {
            if (mask && !mask[key]) {
                newShape[key] = this.shape[key];
            }
            else {
                const fieldSchema = this.shape[key];
                let newField = fieldSchema;
                while (newField instanceof ZodOptional) {
                    newField = newField._def.innerType;
                }
                newShape[key] = newField;
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    keyof() {
        return createZodEnum(lib_util.objectKeys(this.shape));
    }
}
ZodObject.create = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: lib_ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: lib_ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: lib_ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
class ZodUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
            // return first issue-free validation if it exists
            for (const result of results) {
                if (result.result.status === "valid") {
                    return result.result;
                }
            }
            for (const result of results) {
                if (result.result.status === "dirty") {
                    // add issues from dirty option
                    ctx.common.issues.push(...result.ctx.common.issues);
                    return result.result;
                }
            }
            // return invalid
            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return Promise.all(options.map(async (option) => {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                return {
                    result: await option._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx,
                    }),
                    ctx: childCtx,
                };
            })).then(handleResults);
        }
        else {
            let dirty = undefined;
            const issues = [];
            for (const option of options) {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                const result = option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx,
                });
                if (result.status === "valid") {
                    return result;
                }
                else if (result.status === "dirty" && !dirty) {
                    dirty = { result, ctx: childCtx };
                }
                if (childCtx.common.issues.length) {
                    issues.push(childCtx.common.issues);
                }
            }
            if (dirty) {
                ctx.common.issues.push(...dirty.ctx.common.issues);
                return dirty.result;
            }
            const unionErrors = issues.map((issues) => new ZodError(issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
    }
    get options() {
        return this._def.options;
    }
}
ZodUnion.create = (types, params) => {
    return new ZodUnion({
        options: types,
        typeName: lib_ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params),
    });
};
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
//////////                                 //////////
//////////      ZodDiscriminatedUnion      //////////
//////////                                 //////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
    }
    else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
    }
    else if (type instanceof ZodLiteral) {
        return [type.value];
    }
    else if (type instanceof ZodEnum) {
        return type.options;
    }
    else if (type instanceof ZodNativeEnum) {
        // eslint-disable-next-line ban/ban
        return lib_util.objectValues(type.enum);
    }
    else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
    }
    else if (type instanceof ZodUndefined) {
        return [undefined];
    }
    else if (type instanceof ZodNull) {
        return [null];
    }
    else if (type instanceof ZodOptional) {
        return [undefined, ...getDiscriminator(type.unwrap())];
    }
    else if (type instanceof ZodNullable) {
        return [null, ...getDiscriminator(type.unwrap())];
    }
    else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
    }
    else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
    }
    else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
    }
    else {
        return [];
    }
};
class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [discriminator],
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
        else {
            return option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
        // Get all the valid discriminator values
        const optionsMap = new Map();
        // try {
        for (const type of options) {
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues.length) {
                throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            }
            for (const value of discriminatorValues) {
                if (optionsMap.has(value)) {
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                }
                optionsMap.set(value, type);
            }
        }
        return new ZodDiscriminatedUnion({
            typeName: lib_ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap,
            ...processCreateParams(params),
        });
    }
}
function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
        return { valid: true, data: a };
    }
    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
        const bKeys = lib_util.objectKeys(b);
        const sharedKeys = lib_util
            .objectKeys(a)
            .filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
    }
    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
        if (a.length !== b.length) {
            return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
    }
    else if (aType === ZodParsedType.date &&
        bType === ZodParsedType.date &&
        +a === +b) {
        return { valid: true, data: a };
    }
    else {
        return { valid: false };
    }
}
class ZodIntersection extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
            if (isAborted(parsedLeft) || isAborted(parsedRight)) {
                return INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_intersection_types,
                });
                return INVALID;
            }
            if (isDirty(parsedLeft) || isDirty(parsedRight)) {
                status.dirty();
            }
            return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
            return Promise.all([
                this._def.left._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
                this._def.right._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
            ]).then(([left, right]) => handleParsed(left, right));
        }
        else {
            return handleParsed(this._def.left._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }), this._def.right._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }));
        }
    }
}
ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
        left: left,
        right: right,
        typeName: lib_ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params),
    });
};
class ZodTuple extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            status.dirty();
        }
        const items = [...ctx.data]
            .map((item, itemIndex) => {
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema)
                return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        })
            .filter((x) => !!x); // filter nulls
        if (ctx.common.async) {
            return Promise.all(items).then((results) => {
                return ParseStatus.mergeArray(status, results);
            });
        }
        else {
            return ParseStatus.mergeArray(status, items);
        }
    }
    get items() {
        return this._def.items;
    }
    rest(rest) {
        return new ZodTuple({
            ...this._def,
            rest,
        });
    }
}
ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
        items: schemas,
        typeName: lib_ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params),
    });
};
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
            pairs.push({
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (ctx.common.async) {
            return ParseStatus.mergeObjectAsync(status, pairs);
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get element() {
        return this._def.valueType;
    }
    static create(first, second, third) {
        if (second instanceof ZodType) {
            return new ZodRecord({
                keyType: first,
                valueType: second,
                typeName: lib_ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams(third),
            });
        }
        return new ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: lib_ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(second),
        });
    }
}
class ZodMap extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.map,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
            };
        });
        if (ctx.common.async) {
            const finalMap = new Map();
            return Promise.resolve().then(async () => {
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    if (key.status === "aborted" || value.status === "aborted") {
                        return INVALID;
                    }
                    if (key.status === "dirty" || value.status === "dirty") {
                        status.dirty();
                    }
                    finalMap.set(key.value, value.value);
                }
                return { status: status.value, value: finalMap };
            });
        }
        else {
            const finalMap = new Map();
            for (const pair of pairs) {
                const key = pair.key;
                const value = pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                    return INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                    status.dirty();
                }
                finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
        }
    }
}
ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
        valueType,
        keyType,
        typeName: lib_ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params),
    });
};
class ZodSet extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.set,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.minSize.message,
                });
                status.dirty();
            }
        }
        if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.maxSize.message,
                });
                status.dirty();
            }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements) {
            const parsedSet = new Set();
            for (const element of elements) {
                if (element.status === "aborted")
                    return INVALID;
                if (element.status === "dirty")
                    status.dirty();
                parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
            return Promise.all(elements).then((elements) => finalizeSet(elements));
        }
        else {
            return finalizeSet(elements);
        }
    }
    min(minSize, message) {
        return new ZodSet({
            ...this._def,
            minSize: { value: minSize, message: lib_errorUtil.toString(message) },
        });
    }
    max(maxSize, message) {
        return new ZodSet({
            ...this._def,
            maxSize: { value: maxSize, message: lib_errorUtil.toString(message) },
        });
    }
    size(size, message) {
        return this.min(size, message).max(size, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodSet.create = (valueType, params) => {
    return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: lib_ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params),
    });
};
class ZodFunction extends ZodType {
    constructor() {
        super(...arguments);
        this.validate = this.implement;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.function,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        function makeArgsIssue(args, error) {
            return makeIssue({
                data: args,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    getErrorMap(),
                    lib_errorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_arguments,
                    argumentsError: error,
                },
            });
        }
        function makeReturnsIssue(returns, error) {
            return makeIssue({
                data: returns,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    getErrorMap(),
                    lib_errorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_return_type,
                    returnTypeError: error,
                },
            });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return OK(async function (...args) {
                const error = new ZodError([]);
                const parsedArgs = await me._def.args
                    .parseAsync(args, params)
                    .catch((e) => {
                    error.addIssue(makeArgsIssue(args, e));
                    throw error;
                });
                const result = await Reflect.apply(fn, this, parsedArgs);
                const parsedReturns = await me._def.returns._def.type
                    .parseAsync(result, params)
                    .catch((e) => {
                    error.addIssue(makeReturnsIssue(result, e));
                    throw error;
                });
                return parsedReturns;
            });
        }
        else {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return OK(function (...args) {
                const parsedArgs = me._def.args.safeParse(args, params);
                if (!parsedArgs.success) {
                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
                }
                const result = Reflect.apply(fn, this, parsedArgs.data);
                const parsedReturns = me._def.returns.safeParse(result, params);
                if (!parsedReturns.success) {
                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
                }
                return parsedReturns.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...items) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create()),
        });
    }
    returns(returnType) {
        return new ZodFunction({
            ...this._def,
            returns: returnType,
        });
    }
    implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    static create(args, returns, params) {
        return new ZodFunction({
            args: (args
                ? args
                : ZodTuple.create([]).rest(ZodUnknown.create())),
            returns: returns || ZodUnknown.create(),
            typeName: lib_ZodFirstPartyTypeKind.ZodFunction,
            ...processCreateParams(params),
        });
    }
}
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter();
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
}
ZodLazy.create = (getter, params) => {
    return new ZodLazy({
        getter: getter,
        typeName: lib_ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params),
    });
};
class ZodLiteral extends ZodType {
    _parse(input) {
        if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_literal,
                expected: this._def.value,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
    get value() {
        return this._def.value;
    }
}
ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
        value: value,
        typeName: lib_ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params),
    });
};
function createZodEnum(values, params) {
    return new ZodEnum({
        values,
        typeName: lib_ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params),
    });
}
class ZodEnum extends ZodType {
    constructor() {
        super(...arguments);
        _ZodEnum_cache.set(this, void 0);
    }
    _parse(input) {
        if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                expected: lib_util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
            __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    extract(values, newDef = this._def) {
        return ZodEnum.create(values, {
            ...this._def,
            ...newDef,
        });
    }
    exclude(values, newDef = this._def) {
        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
            ...this._def,
            ...newDef,
        });
    }
}
_ZodEnum_cache = new WeakMap();
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    constructor() {
        super(...arguments);
        _ZodNativeEnum_cache.set(this, void 0);
    }
    _parse(input) {
        const nativeEnumValues = lib_util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string &&
            ctx.parsedType !== ZodParsedType.number) {
            const expectedValues = lib_util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                expected: lib_util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
            __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(lib_util.getValidEnumValues(this._def.values)), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
            const expectedValues = lib_util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get enum() {
        return this._def.values;
    }
}
_ZodNativeEnum_cache = new WeakMap();
ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
        values: values,
        typeName: lib_ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params),
    });
};
class ZodPromise extends ZodType {
    unwrap() {
        return this._def.type;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise &&
            ctx.common.async === false) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.promise,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise
            ? ctx.data
            : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
                path: ctx.path,
                errorMap: ctx.common.contextualErrorMap,
            });
        }));
    }
}
ZodPromise.create = (schema, params) => {
    return new ZodPromise({
        type: schema,
        typeName: lib_ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params),
    });
};
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === lib_ZodFirstPartyTypeKind.ZodEffects
            ? this._def.schema.sourceType()
            : this._def.schema;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
            addIssue: (arg) => {
                addIssueToContext(ctx, arg);
                if (arg.fatal) {
                    status.abort();
                }
                else {
                    status.dirty();
                }
            },
            get path() {
                return ctx.path;
            },
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data, checkCtx);
            if (ctx.common.async) {
                return Promise.resolve(processed).then(async (processed) => {
                    if (status.value === "aborted")
                        return INVALID;
                    const result = await this._def.schema._parseAsync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx,
                    });
                    if (result.status === "aborted")
                        return INVALID;
                    if (result.status === "dirty")
                        return DIRTY(result.value);
                    if (status.value === "dirty")
                        return DIRTY(result.value);
                    return result;
                });
            }
            else {
                if (status.value === "aborted")
                    return INVALID;
                const result = this._def.schema._parseSync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx,
                });
                if (result.status === "aborted")
                    return INVALID;
                if (result.status === "dirty")
                    return DIRTY(result.value);
                if (status.value === "dirty")
                    return DIRTY(result.value);
                return result;
            }
        }
        if (effect.type === "refinement") {
            const executeRefinement = (acc) => {
                const result = effect.refinement(acc, checkCtx);
                if (ctx.common.async) {
                    return Promise.resolve(result);
                }
                if (result instanceof Promise) {
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                }
                return acc;
            };
            if (ctx.common.async === false) {
                const inner = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inner.status === "aborted")
                    return INVALID;
                if (inner.status === "dirty")
                    status.dirty();
                // return value is ignored
                executeRefinement(inner.value);
                return { status: status.value, value: inner.value };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((inner) => {
                    if (inner.status === "aborted")
                        return INVALID;
                    if (inner.status === "dirty")
                        status.dirty();
                    return executeRefinement(inner.value).then(() => {
                        return { status: status.value, value: inner.value };
                    });
                });
            }
        }
        if (effect.type === "transform") {
            if (ctx.common.async === false) {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (!isValid(base))
                    return base;
                const result = effect.transform(base.value, checkCtx);
                if (result instanceof Promise) {
                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                }
                return { status: status.value, value: result };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((base) => {
                    if (!isValid(base))
                        return base;
                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
                });
            }
        }
        lib_util.assertNever(effect);
    }
}
ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
        schema,
        typeName: lib_ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params),
    });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: lib_ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params),
    });
};
class ZodOptional extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
            return OK(undefined);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodOptional.create = (type, params) => {
    return new ZodOptional({
        innerType: type,
        typeName: lib_ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params),
    });
};
class ZodNullable extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
            return OK(null);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodNullable.create = (type, params) => {
    return new ZodNullable({
        innerType: type,
        typeName: lib_ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params),
    });
};
class ZodDefault extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
            data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
ZodDefault.create = (type, params) => {
    return new ZodDefault({
        innerType: type,
        typeName: lib_ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function"
            ? params.default
            : () => params.default,
        ...processCreateParams(params),
    });
};
class ZodCatch extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        // newCtx is used to not collect issues from inner types in ctx
        const newCtx = {
            ...ctx,
            common: {
                ...ctx.common,
                issues: [],
            },
        };
        const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: {
                ...newCtx,
            },
        });
        if (isAsync(result)) {
            return result.then((result) => {
                return {
                    status: "valid",
                    value: result.status === "valid"
                        ? result.value
                        : this._def.catchValue({
                            get error() {
                                return new ZodError(newCtx.common.issues);
                            },
                            input: newCtx.data,
                        }),
                };
            });
        }
        else {
            return {
                status: "valid",
                value: result.status === "valid"
                    ? result.value
                    : this._def.catchValue({
                        get error() {
                            return new ZodError(newCtx.common.issues);
                        },
                        input: newCtx.data,
                    }),
            };
        }
    }
    removeCatch() {
        return this._def.innerType;
    }
}
ZodCatch.create = (type, params) => {
    return new ZodCatch({
        innerType: type,
        typeName: lib_ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params),
    });
};
class ZodNaN extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.nan,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
}
ZodNaN.create = (params) => {
    return new ZodNaN({
        typeName: lib_ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params),
    });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    unwrap() {
        return this._def.type;
    }
}
class ZodPipeline extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
            const handleAsync = async () => {
                const inResult = await this._def.in._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inResult.status === "aborted")
                    return INVALID;
                if (inResult.status === "dirty") {
                    status.dirty();
                    return DIRTY(inResult.value);
                }
                else {
                    return this._def.out._parseAsync({
                        data: inResult.value,
                        path: ctx.path,
                        parent: ctx,
                    });
                }
            };
            return handleAsync();
        }
        else {
            const inResult = this._def.in._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
            if (inResult.status === "aborted")
                return INVALID;
            if (inResult.status === "dirty") {
                status.dirty();
                return {
                    status: "dirty",
                    value: inResult.value,
                };
            }
            else {
                return this._def.out._parseSync({
                    data: inResult.value,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
    }
    static create(a, b) {
        return new ZodPipeline({
            in: a,
            out: b,
            typeName: lib_ZodFirstPartyTypeKind.ZodPipeline,
        });
    }
}
class ZodReadonly extends ZodType {
    _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = (data) => {
            if (isValid(data)) {
                data.value = Object.freeze(data.value);
            }
            return data;
        };
        return isAsync(result)
            ? result.then((data) => freeze(data))
            : freeze(result);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
        innerType: type,
        typeName: lib_ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params),
    });
};
////////////////////////////////////////
////////////////////////////////////////
//////////                    //////////
//////////      z.custom      //////////
//////////                    //////////
////////////////////////////////////////
////////////////////////////////////////
function cleanParams(params, data) {
    const p = typeof params === "function"
        ? params(data)
        : typeof params === "string"
            ? { message: params }
            : params;
    const p2 = typeof p === "string" ? { message: p } : p;
    return p2;
}
function custom(check, _params = {}, 
/**
 * @deprecated
 *
 * Pass `fatal` into the params object instead:
 *
 * ```ts
 * z.string().custom((val) => val.length > 5, { fatal: false })
 * ```
 *
 */
fatal) {
    if (check)
        return ZodAny.create().superRefine((data, ctx) => {
            var _a, _b;
            const r = check(data);
            if (r instanceof Promise) {
                return r.then((r) => {
                    var _a, _b;
                    if (!r) {
                        const params = cleanParams(_params, data);
                        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
                        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
                    }
                });
            }
            if (!r) {
                const params = cleanParams(_params, data);
                const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
                ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
            }
            return;
        });
    return ZodAny.create();
}
const late = {
    object: ZodObject.lazycreate,
};
var lib_ZodFirstPartyTypeKind;
(function (ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
})(lib_ZodFirstPartyTypeKind || (lib_ZodFirstPartyTypeKind = {}));
const instanceOfType = (
// const instanceOfType = <T extends new (...args: any[]) => any>(
cls, params = {
    message: `Input not instance of ${cls.name}`,
}) => custom((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = (/* unused pure expression or super */ null && ({
    string: ((arg) => ZodString.create({ ...arg, coerce: true })),
    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
    boolean: ((arg) => ZodBoolean.create({
        ...arg,
        coerce: true,
    })),
    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),
}));
const NEVER = (/* unused pure expression or super */ null && (INVALID));

var z = /*#__PURE__*/(/* unused pure expression or super */ null && (Object.freeze({
    __proto__: null,
    defaultErrorMap: lib_errorMap,
    setErrorMap: setErrorMap,
    getErrorMap: getErrorMap,
    makeIssue: makeIssue,
    EMPTY_PATH: EMPTY_PATH,
    addIssueToContext: addIssueToContext,
    ParseStatus: ParseStatus,
    INVALID: INVALID,
    DIRTY: DIRTY,
    OK: OK,
    isAborted: isAborted,
    isDirty: isDirty,
    isValid: isValid,
    isAsync: isAsync,
    get util () { return lib_util; },
    get objectUtil () { return lib_objectUtil; },
    ZodParsedType: ZodParsedType,
    getParsedType: getParsedType,
    ZodType: ZodType,
    datetimeRegex: datetimeRegex,
    ZodString: ZodString,
    ZodNumber: ZodNumber,
    ZodBigInt: ZodBigInt,
    ZodBoolean: ZodBoolean,
    ZodDate: ZodDate,
    ZodSymbol: ZodSymbol,
    ZodUndefined: ZodUndefined,
    ZodNull: ZodNull,
    ZodAny: ZodAny,
    ZodUnknown: ZodUnknown,
    ZodNever: ZodNever,
    ZodVoid: ZodVoid,
    ZodArray: ZodArray,
    ZodObject: ZodObject,
    ZodUnion: ZodUnion,
    ZodDiscriminatedUnion: ZodDiscriminatedUnion,
    ZodIntersection: ZodIntersection,
    ZodTuple: ZodTuple,
    ZodRecord: ZodRecord,
    ZodMap: ZodMap,
    ZodSet: ZodSet,
    ZodFunction: ZodFunction,
    ZodLazy: ZodLazy,
    ZodLiteral: ZodLiteral,
    ZodEnum: ZodEnum,
    ZodNativeEnum: ZodNativeEnum,
    ZodPromise: ZodPromise,
    ZodEffects: ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional: ZodOptional,
    ZodNullable: ZodNullable,
    ZodDefault: ZodDefault,
    ZodCatch: ZodCatch,
    ZodNaN: ZodNaN,
    BRAND: BRAND,
    ZodBranded: ZodBranded,
    ZodPipeline: ZodPipeline,
    ZodReadonly: ZodReadonly,
    custom: custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late: late,
    get ZodFirstPartyTypeKind () { return lib_ZodFirstPartyTypeKind; },
    coerce: coerce,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    'enum': enumType,
    'function': functionType,
    'instanceof': instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    'null': nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean: oboolean,
    onumber: onumber,
    optional: optionalType,
    ostring: ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    'undefined': undefinedType,
    union: unionType,
    unknown: unknownType,
    'void': voidType,
    NEVER: NEVER,
    ZodIssueCode: ZodIssueCode,
    quotelessJson: quotelessJson,
    ZodError: ZodError
})));



;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/any.js
function parseAnyDef() {
    return {};
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/errorMessages.js
function addErrorMessage(res, key, errorMessage, refs) {
    if (!refs?.errorMessages)
        return;
    if (errorMessage) {
        res.errorMessage = {
            ...res.errorMessage,
            [key]: errorMessage,
        };
    }
}
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
    res[key] = value;
    addErrorMessage(res, key, errorMessage, refs);
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/array.js



function parseArrayDef(def, refs) {
    const res = {
        type: "array",
    };
    if (def.type?._def &&
        def.type?._def?.typeName !== lib_ZodFirstPartyTypeKind.ZodAny) {
        res.items = parseDef(def.type._def, {
            ...refs,
            currentPath: [...refs.currentPath, "items"],
        });
    }
    if (def.minLength) {
        setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
    }
    if (def.maxLength) {
        setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
    }
    if (def.exactLength) {
        setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
        setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
    }
    return res;
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js

function parseBigintDef(def, refs) {
    const res = {
        type: "integer",
        format: "int64",
    };
    if (!def.checks)
        return res;
    for (const check of def.checks) {
        switch (check.kind) {
            case "min":
                if (refs.target === "jsonSchema7") {
                    if (check.inclusive) {
                        setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
                    }
                    else {
                        setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
                    }
                }
                else {
                    if (!check.inclusive) {
                        res.exclusiveMinimum = true;
                    }
                    setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
                }
                break;
            case "max":
                if (refs.target === "jsonSchema7") {
                    if (check.inclusive) {
                        setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
                    }
                    else {
                        setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
                    }
                }
                else {
                    if (!check.inclusive) {
                        res.exclusiveMaximum = true;
                    }
                    setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
                }
                break;
            case "multipleOf":
                setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
                break;
        }
    }
    return res;
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js
function parseBooleanDef() {
    return {
        type: "boolean",
    };
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/branded.js

function parseBrandedDef(_def, refs) {
    return parseDef(_def.type._def, refs);
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/catch.js

const parseCatchDef = (def, refs) => {
    return parseDef(def.innerType._def, refs);
};

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/date.js

function parseDateDef(def, refs, overrideDateStrategy) {
    const strategy = overrideDateStrategy ?? refs.dateStrategy;
    if (Array.isArray(strategy)) {
        return {
            anyOf: strategy.map((item, i) => parseDateDef(def, refs, item)),
        };
    }
    switch (strategy) {
        case "string":
        case "format:date-time":
            return {
                type: "string",
                format: "date-time",
            };
        case "format:date":
            return {
                type: "string",
                format: "date",
            };
        case "integer":
            return integerDateParser(def, refs);
    }
}
const integerDateParser = (def, refs) => {
    const res = {
        type: "integer",
        format: "unix-time",
    };
    if (refs.target === "openApi3") {
        return res;
    }
    for (const check of def.checks) {
        switch (check.kind) {
            case "min":
                setResponseValueAndErrors(res, "minimum", check.value, // This is in milliseconds
                check.message, refs);
                break;
            case "max":
                setResponseValueAndErrors(res, "maximum", check.value, // This is in milliseconds
                check.message, refs);
                break;
        }
    }
    return res;
};

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/default.js

function parseDefaultDef(_def, refs) {
    return {
        ...parseDef(_def.innerType._def, refs),
        default: _def.defaultValue(),
    };
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/effects.js

function parseEffectsDef(_def, refs) {
    return refs.effectStrategy === "input"
        ? parseDef(_def.schema._def, refs)
        : {};
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/enum.js
function parseEnumDef(def) {
    return {
        type: "string",
        enum: Array.from(def.values),
    };
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js

const isJsonSchema7AllOfType = (type) => {
    if ("type" in type && type.type === "string")
        return false;
    return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
    const allOf = [
        parseDef(def.left._def, {
            ...refs,
            currentPath: [...refs.currentPath, "allOf", "0"],
        }),
        parseDef(def.right._def, {
            ...refs,
            currentPath: [...refs.currentPath, "allOf", "1"],
        }),
    ].filter((x) => !!x);
    let unevaluatedProperties = refs.target === "jsonSchema2019-09"
        ? { unevaluatedProperties: false }
        : undefined;
    const mergedAllOf = [];
    // If either of the schemas is an allOf, merge them into a single allOf
    allOf.forEach((schema) => {
        if (isJsonSchema7AllOfType(schema)) {
            mergedAllOf.push(...schema.allOf);
            if (schema.unevaluatedProperties === undefined) {
                // If one of the schemas has no unevaluatedProperties set,
                // the merged schema should also have no unevaluatedProperties set
                unevaluatedProperties = undefined;
            }
        }
        else {
            let nestedSchema = schema;
            if ("additionalProperties" in schema &&
                schema.additionalProperties === false) {
                const { additionalProperties, ...rest } = schema;
                nestedSchema = rest;
            }
            else {
                // As soon as one of the schemas has additionalProperties set not to false, we allow unevaluatedProperties
                unevaluatedProperties = undefined;
            }
            mergedAllOf.push(nestedSchema);
        }
    });
    return mergedAllOf.length
        ? {
            allOf: mergedAllOf,
            ...unevaluatedProperties,
        }
        : undefined;
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/literal.js
function parseLiteralDef(def, refs) {
    const parsedType = typeof def.value;
    if (parsedType !== "bigint" &&
        parsedType !== "number" &&
        parsedType !== "boolean" &&
        parsedType !== "string") {
        return {
            type: Array.isArray(def.value) ? "array" : "object",
        };
    }
    if (refs.target === "openApi3") {
        return {
            type: parsedType === "bigint" ? "integer" : parsedType,
            enum: [def.value],
        };
    }
    return {
        type: parsedType === "bigint" ? "integer" : parsedType,
        const: def.value,
    };
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/string.js

let string_emojiRegex = undefined;
/**
 * Generated from the regular expressions found here as of 2024-05-22:
 * https://github.com/colinhacks/zod/blob/master/src/types.ts.
 *
 * Expressions with /i flag have been changed accordingly.
 */
const zodPatterns = {
    /**
     * `c` was changed to `[cC]` to replicate /i flag
     */
    cuid: /^[cC][^\s-]{8,}$/,
    cuid2: /^[0-9a-z]+$/,
    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
    /**
     * `a-z` was added to replicate /i flag
     */
    email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
    /**
     * Constructed a valid Unicode RegExp
     *
     * Lazily instantiate since this type of regex isn't supported
     * in all envs (e.g. React Native).
     *
     * See:
     * https://github.com/colinhacks/zod/issues/2433
     * Fix in Zod:
     * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
     */
    emoji: () => {
        if (string_emojiRegex === undefined) {
            string_emojiRegex = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
        }
        return string_emojiRegex;
    },
    /**
     * Unused
     */
    uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
    /**
     * Unused
     */
    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
    /**
     * Unused
     */
    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
    nanoid: /^[a-zA-Z0-9_-]{21}$/,
    jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
};
function parseStringDef(def, refs) {
    const res = {
        type: "string",
    };
    if (def.checks) {
        for (const check of def.checks) {
            switch (check.kind) {
                case "min":
                    setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number"
                        ? Math.max(res.minLength, check.value)
                        : check.value, check.message, refs);
                    break;
                case "max":
                    setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number"
                        ? Math.min(res.maxLength, check.value)
                        : check.value, check.message, refs);
                    break;
                case "email":
                    switch (refs.emailStrategy) {
                        case "format:email":
                            addFormat(res, "email", check.message, refs);
                            break;
                        case "format:idn-email":
                            addFormat(res, "idn-email", check.message, refs);
                            break;
                        case "pattern:zod":
                            addPattern(res, zodPatterns.email, check.message, refs);
                            break;
                    }
                    break;
                case "url":
                    addFormat(res, "uri", check.message, refs);
                    break;
                case "uuid":
                    addFormat(res, "uuid", check.message, refs);
                    break;
                case "regex":
                    addPattern(res, check.regex, check.message, refs);
                    break;
                case "cuid":
                    addPattern(res, zodPatterns.cuid, check.message, refs);
                    break;
                case "cuid2":
                    addPattern(res, zodPatterns.cuid2, check.message, refs);
                    break;
                case "startsWith":
                    addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);
                    break;
                case "endsWith":
                    addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);
                    break;
                case "datetime":
                    addFormat(res, "date-time", check.message, refs);
                    break;
                case "date":
                    addFormat(res, "date", check.message, refs);
                    break;
                case "time":
                    addFormat(res, "time", check.message, refs);
                    break;
                case "duration":
                    addFormat(res, "duration", check.message, refs);
                    break;
                case "length":
                    setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number"
                        ? Math.max(res.minLength, check.value)
                        : check.value, check.message, refs);
                    setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number"
                        ? Math.min(res.maxLength, check.value)
                        : check.value, check.message, refs);
                    break;
                case "includes": {
                    addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);
                    break;
                }
                case "ip": {
                    if (check.version !== "v6") {
                        addFormat(res, "ipv4", check.message, refs);
                    }
                    if (check.version !== "v4") {
                        addFormat(res, "ipv6", check.message, refs);
                    }
                    break;
                }
                case "base64url":
                    addPattern(res, zodPatterns.base64url, check.message, refs);
                    break;
                case "jwt":
                    addPattern(res, zodPatterns.jwt, check.message, refs);
                    break;
                case "cidr": {
                    if (check.version !== "v6") {
                        addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
                    }
                    if (check.version !== "v4") {
                        addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
                    }
                    break;
                }
                case "emoji":
                    addPattern(res, zodPatterns.emoji(), check.message, refs);
                    break;
                case "ulid": {
                    addPattern(res, zodPatterns.ulid, check.message, refs);
                    break;
                }
                case "base64": {
                    switch (refs.base64Strategy) {
                        case "format:binary": {
                            addFormat(res, "binary", check.message, refs);
                            break;
                        }
                        case "contentEncoding:base64": {
                            setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
                            break;
                        }
                        case "pattern:zod": {
                            addPattern(res, zodPatterns.base64, check.message, refs);
                            break;
                        }
                    }
                    break;
                }
                case "nanoid": {
                    addPattern(res, zodPatterns.nanoid, check.message, refs);
                }
                case "toLowerCase":
                case "toUpperCase":
                case "trim":
                    break;
                default:
                    /* c8 ignore next */
                    ((_) => { })(check);
            }
        }
    }
    return res;
}
function escapeLiteralCheckValue(literal, refs) {
    return refs.patternStrategy === "escape"
        ? escapeNonAlphaNumeric(literal)
        : literal;
}
const ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric(source) {
    let result = "";
    for (let i = 0; i < source.length; i++) {
        if (!ALPHA_NUMERIC.has(source[i])) {
            result += "\\";
        }
        result += source[i];
    }
    return result;
}
// Adds a "format" keyword to the schema. If a format exists, both formats will be joined in an allOf-node, along with subsequent ones.
function addFormat(schema, value, message, refs) {
    if (schema.format || schema.anyOf?.some((x) => x.format)) {
        if (!schema.anyOf) {
            schema.anyOf = [];
        }
        if (schema.format) {
            schema.anyOf.push({
                format: schema.format,
                ...(schema.errorMessage &&
                    refs.errorMessages && {
                    errorMessage: { format: schema.errorMessage.format },
                }),
            });
            delete schema.format;
            if (schema.errorMessage) {
                delete schema.errorMessage.format;
                if (Object.keys(schema.errorMessage).length === 0) {
                    delete schema.errorMessage;
                }
            }
        }
        schema.anyOf.push({
            format: value,
            ...(message &&
                refs.errorMessages && { errorMessage: { format: message } }),
        });
    }
    else {
        setResponseValueAndErrors(schema, "format", value, message, refs);
    }
}
// Adds a "pattern" keyword to the schema. If a pattern exists, both patterns will be joined in an allOf-node, along with subsequent ones.
function addPattern(schema, regex, message, refs) {
    if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {
        if (!schema.allOf) {
            schema.allOf = [];
        }
        if (schema.pattern) {
            schema.allOf.push({
                pattern: schema.pattern,
                ...(schema.errorMessage &&
                    refs.errorMessages && {
                    errorMessage: { pattern: schema.errorMessage.pattern },
                }),
            });
            delete schema.pattern;
            if (schema.errorMessage) {
                delete schema.errorMessage.pattern;
                if (Object.keys(schema.errorMessage).length === 0) {
                    delete schema.errorMessage;
                }
            }
        }
        schema.allOf.push({
            pattern: stringifyRegExpWithFlags(regex, refs),
            ...(message &&
                refs.errorMessages && { errorMessage: { pattern: message } }),
        });
    }
    else {
        setResponseValueAndErrors(schema, "pattern", stringifyRegExpWithFlags(regex, refs), message, refs);
    }
}
// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true
function stringifyRegExpWithFlags(regex, refs) {
    if (!refs.applyRegexFlags || !regex.flags) {
        return regex.source;
    }
    // Currently handled flags
    const flags = {
        i: regex.flags.includes("i"),
        m: regex.flags.includes("m"),
        s: regex.flags.includes("s"), // `.` matches newlines
    };
    // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!
    const source = flags.i ? regex.source.toLowerCase() : regex.source;
    let pattern = "";
    let isEscaped = false;
    let inCharGroup = false;
    let inCharRange = false;
    for (let i = 0; i < source.length; i++) {
        if (isEscaped) {
            pattern += source[i];
            isEscaped = false;
            continue;
        }
        if (flags.i) {
            if (inCharGroup) {
                if (source[i].match(/[a-z]/)) {
                    if (inCharRange) {
                        pattern += source[i];
                        pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
                        inCharRange = false;
                    }
                    else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/)) {
                        pattern += source[i];
                        inCharRange = true;
                    }
                    else {
                        pattern += `${source[i]}${source[i].toUpperCase()}`;
                    }
                    continue;
                }
            }
            else if (source[i].match(/[a-z]/)) {
                pattern += `[${source[i]}${source[i].toUpperCase()}]`;
                continue;
            }
        }
        if (flags.m) {
            if (source[i] === "^") {
                pattern += `(^|(?<=[\r\n]))`;
                continue;
            }
            else if (source[i] === "$") {
                pattern += `($|(?=[\r\n]))`;
                continue;
            }
        }
        if (flags.s && source[i] === ".") {
            pattern += inCharGroup ? `${source[i]}\r\n` : `[${source[i]}\r\n]`;
            continue;
        }
        pattern += source[i];
        if (source[i] === "\\") {
            isEscaped = true;
        }
        else if (inCharGroup && source[i] === "]") {
            inCharGroup = false;
        }
        else if (!inCharGroup && source[i] === "[") {
            inCharGroup = true;
        }
    }
    try {
        new RegExp(pattern);
    }
    catch {
        console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
        return regex.source;
    }
    return pattern;
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/record.js




function parseRecordDef(def, refs) {
    if (refs.target === "openAi") {
        console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
    }
    if (refs.target === "openApi3" &&
        def.keyType?._def.typeName === lib_ZodFirstPartyTypeKind.ZodEnum) {
        return {
            type: "object",
            required: def.keyType._def.values,
            properties: def.keyType._def.values.reduce((acc, key) => ({
                ...acc,
                [key]: parseDef(def.valueType._def, {
                    ...refs,
                    currentPath: [...refs.currentPath, "properties", key],
                }) ?? {},
            }), {}),
            additionalProperties: refs.rejectedAdditionalProperties,
        };
    }
    const schema = {
        type: "object",
        additionalProperties: parseDef(def.valueType._def, {
            ...refs,
            currentPath: [...refs.currentPath, "additionalProperties"],
        }) ?? refs.allowedAdditionalProperties,
    };
    if (refs.target === "openApi3") {
        return schema;
    }
    if (def.keyType?._def.typeName === lib_ZodFirstPartyTypeKind.ZodString &&
        def.keyType._def.checks?.length) {
        const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
        return {
            ...schema,
            propertyNames: keyType,
        };
    }
    else if (def.keyType?._def.typeName === lib_ZodFirstPartyTypeKind.ZodEnum) {
        return {
            ...schema,
            propertyNames: {
                enum: def.keyType._def.values,
            },
        };
    }
    else if (def.keyType?._def.typeName === lib_ZodFirstPartyTypeKind.ZodBranded &&
        def.keyType._def.type._def.typeName === lib_ZodFirstPartyTypeKind.ZodString &&
        def.keyType._def.type._def.checks?.length) {
        const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
        return {
            ...schema,
            propertyNames: keyType,
        };
    }
    return schema;
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/map.js


function parseMapDef(def, refs) {
    if (refs.mapStrategy === "record") {
        return parseRecordDef(def, refs);
    }
    const keys = parseDef(def.keyType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", "items", "0"],
    }) || {};
    const values = parseDef(def.valueType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", "items", "1"],
    }) || {};
    return {
        type: "array",
        maxItems: 125,
        items: {
            type: "array",
            items: [keys, values],
            minItems: 2,
            maxItems: 2,
        },
    };
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js
function parseNativeEnumDef(def) {
    const object = def.values;
    const actualKeys = Object.keys(def.values).filter((key) => {
        return typeof object[object[key]] !== "number";
    });
    const actualValues = actualKeys.map((key) => object[key]);
    const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
    return {
        type: parsedTypes.length === 1
            ? parsedTypes[0] === "string"
                ? "string"
                : "number"
            : ["string", "number"],
        enum: actualValues,
    };
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/never.js
function parseNeverDef() {
    return {
        not: {},
    };
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/null.js
function parseNullDef(refs) {
    return refs.target === "openApi3"
        ? {
            enum: ["null"],
            nullable: true,
        }
        : {
            type: "null",
        };
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/union.js

const primitiveMappings = {
    ZodString: "string",
    ZodNumber: "number",
    ZodBigInt: "integer",
    ZodBoolean: "boolean",
    ZodNull: "null",
};
function parseUnionDef(def, refs) {
    if (refs.target === "openApi3")
        return asAnyOf(def, refs);
    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
    // This blocks tries to look ahead a bit to produce nicer looking schemas with type array instead of anyOf.
    if (options.every((x) => x._def.typeName in primitiveMappings &&
        (!x._def.checks || !x._def.checks.length))) {
        // all types in union are primitive and lack checks, so might as well squash into {type: [...]}
        const types = options.reduce((types, x) => {
            const type = primitiveMappings[x._def.typeName]; //Can be safely casted due to row 43
            return type && !types.includes(type) ? [...types, type] : types;
        }, []);
        return {
            type: types.length > 1 ? types : types[0],
        };
    }
    else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
        // all options literals
        const types = options.reduce((acc, x) => {
            const type = typeof x._def.value;
            switch (type) {
                case "string":
                case "number":
                case "boolean":
                    return [...acc, type];
                case "bigint":
                    return [...acc, "integer"];
                case "object":
                    if (x._def.value === null)
                        return [...acc, "null"];
                case "symbol":
                case "undefined":
                case "function":
                default:
                    return acc;
            }
        }, []);
        if (types.length === options.length) {
            // all the literals are primitive, as far as null can be considered primitive
            const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
            return {
                type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
                enum: options.reduce((acc, x) => {
                    return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
                }, []),
            };
        }
    }
    else if (options.every((x) => x._def.typeName === "ZodEnum")) {
        return {
            type: "string",
            enum: options.reduce((acc, x) => [
                ...acc,
                ...x._def.values.filter((x) => !acc.includes(x)),
            ], []),
        };
    }
    return asAnyOf(def, refs);
}
const asAnyOf = (def, refs) => {
    const anyOf = (def.options instanceof Map
        ? Array.from(def.options.values())
        : def.options)
        .map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", `${i}`],
    }))
        .filter((x) => !!x &&
        (!refs.strictUnions ||
            (typeof x === "object" && Object.keys(x).length > 0)));
    return anyOf.length ? { anyOf } : undefined;
};

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js


function parseNullableDef(def, refs) {
    if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) &&
        (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
        if (refs.target === "openApi3") {
            return {
                type: primitiveMappings[def.innerType._def.typeName],
                nullable: true,
            };
        }
        return {
            type: [
                primitiveMappings[def.innerType._def.typeName],
                "null",
            ],
        };
    }
    if (refs.target === "openApi3") {
        const base = parseDef(def.innerType._def, {
            ...refs,
            currentPath: [...refs.currentPath],
        });
        if (base && "$ref" in base)
            return { allOf: [base], nullable: true };
        return base && { ...base, nullable: true };
    }
    const base = parseDef(def.innerType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", "0"],
    });
    return base && { anyOf: [base, { type: "null" }] };
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/number.js

function parseNumberDef(def, refs) {
    const res = {
        type: "number",
    };
    if (!def.checks)
        return res;
    for (const check of def.checks) {
        switch (check.kind) {
            case "int":
                res.type = "integer";
                addErrorMessage(res, "type", check.message, refs);
                break;
            case "min":
                if (refs.target === "jsonSchema7") {
                    if (check.inclusive) {
                        setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
                    }
                    else {
                        setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
                    }
                }
                else {
                    if (!check.inclusive) {
                        res.exclusiveMinimum = true;
                    }
                    setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
                }
                break;
            case "max":
                if (refs.target === "jsonSchema7") {
                    if (check.inclusive) {
                        setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
                    }
                    else {
                        setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
                    }
                }
                else {
                    if (!check.inclusive) {
                        res.exclusiveMaximum = true;
                    }
                    setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
                }
                break;
            case "multipleOf":
                setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
                break;
        }
    }
    return res;
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/object.js


function parseObjectDef(def, refs) {
    const forceOptionalIntoNullable = refs.target === "openAi";
    const result = {
        type: "object",
        properties: {},
    };
    const required = [];
    const shape = def.shape();
    for (const propName in shape) {
        let propDef = shape[propName];
        if (propDef === undefined || propDef._def === undefined) {
            continue;
        }
        let propOptional = safeIsOptional(propDef);
        if (propOptional && forceOptionalIntoNullable) {
            if (propDef instanceof ZodOptional) {
                propDef = propDef._def.innerType;
            }
            if (!propDef.isNullable()) {
                propDef = propDef.nullable();
            }
            propOptional = false;
        }
        const parsedDef = parseDef(propDef._def, {
            ...refs,
            currentPath: [...refs.currentPath, "properties", propName],
            propertyPath: [...refs.currentPath, "properties", propName],
        });
        if (parsedDef === undefined) {
            continue;
        }
        result.properties[propName] = parsedDef;
        if (!propOptional) {
            required.push(propName);
        }
    }
    if (required.length) {
        result.required = required;
    }
    const additionalProperties = decideAdditionalProperties(def, refs);
    if (additionalProperties !== undefined) {
        result.additionalProperties = additionalProperties;
    }
    return result;
}
function decideAdditionalProperties(def, refs) {
    if (def.catchall._def.typeName !== "ZodNever") {
        return parseDef(def.catchall._def, {
            ...refs,
            currentPath: [...refs.currentPath, "additionalProperties"],
        });
    }
    switch (def.unknownKeys) {
        case "passthrough":
            return refs.allowedAdditionalProperties;
        case "strict":
            return refs.rejectedAdditionalProperties;
        case "strip":
            return refs.removeAdditionalStrategy === "strict"
                ? refs.allowedAdditionalProperties
                : refs.rejectedAdditionalProperties;
    }
}
function safeIsOptional(schema) {
    try {
        return schema.isOptional();
    }
    catch {
        return true;
    }
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/optional.js

const parseOptionalDef = (def, refs) => {
    if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
        return parseDef(def.innerType._def, refs);
    }
    const innerSchema = parseDef(def.innerType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", "1"],
    });
    return innerSchema
        ? {
            anyOf: [
                {
                    not: {},
                },
                innerSchema,
            ],
        }
        : {};
};

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js

const parsePipelineDef = (def, refs) => {
    if (refs.pipeStrategy === "input") {
        return parseDef(def.in._def, refs);
    }
    else if (refs.pipeStrategy === "output") {
        return parseDef(def.out._def, refs);
    }
    const a = parseDef(def.in._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "0"],
    });
    const b = parseDef(def.out._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"],
    });
    return {
        allOf: [a, b].filter((x) => x !== undefined),
    };
};

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/promise.js

function parsePromiseDef(def, refs) {
    return parseDef(def.type._def, refs);
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/set.js


function parseSetDef(def, refs) {
    const items = parseDef(def.valueType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items"],
    });
    const schema = {
        type: "array",
        uniqueItems: true,
        items,
    };
    if (def.minSize) {
        setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
    }
    if (def.maxSize) {
        setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
    }
    return schema;
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js

function parseTupleDef(def, refs) {
    if (def.rest) {
        return {
            type: "array",
            minItems: def.items.length,
            items: def.items
                .map((x, i) => parseDef(x._def, {
                ...refs,
                currentPath: [...refs.currentPath, "items", `${i}`],
            }))
                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),
            additionalItems: parseDef(def.rest._def, {
                ...refs,
                currentPath: [...refs.currentPath, "additionalItems"],
            }),
        };
    }
    else {
        return {
            type: "array",
            minItems: def.items.length,
            maxItems: def.items.length,
            items: def.items
                .map((x, i) => parseDef(x._def, {
                ...refs,
                currentPath: [...refs.currentPath, "items", `${i}`],
            }))
                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),
        };
    }
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js
function parseUndefinedDef() {
    return {
        not: {},
    };
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js
function parseUnknownDef() {
    return {};
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js

const parseReadonlyDef = (def, refs) => {
    return parseDef(def.innerType._def, refs);
};

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/selectParser.js































const selectParser = (def, typeName, refs) => {
    switch (typeName) {
        case lib_ZodFirstPartyTypeKind.ZodString:
            return parseStringDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodNumber:
            return parseNumberDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodObject:
            return parseObjectDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodBigInt:
            return parseBigintDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodBoolean:
            return parseBooleanDef();
        case lib_ZodFirstPartyTypeKind.ZodDate:
            return parseDateDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodUndefined:
            return parseUndefinedDef();
        case lib_ZodFirstPartyTypeKind.ZodNull:
            return parseNullDef(refs);
        case lib_ZodFirstPartyTypeKind.ZodArray:
            return parseArrayDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodUnion:
        case lib_ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
            return parseUnionDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodIntersection:
            return parseIntersectionDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodTuple:
            return parseTupleDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodRecord:
            return parseRecordDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodLiteral:
            return parseLiteralDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodEnum:
            return parseEnumDef(def);
        case lib_ZodFirstPartyTypeKind.ZodNativeEnum:
            return parseNativeEnumDef(def);
        case lib_ZodFirstPartyTypeKind.ZodNullable:
            return parseNullableDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodOptional:
            return parseOptionalDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodMap:
            return parseMapDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodSet:
            return parseSetDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodLazy:
            return () => def.getter()._def;
        case lib_ZodFirstPartyTypeKind.ZodPromise:
            return parsePromiseDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodNaN:
        case lib_ZodFirstPartyTypeKind.ZodNever:
            return parseNeverDef();
        case lib_ZodFirstPartyTypeKind.ZodEffects:
            return parseEffectsDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodAny:
            return parseAnyDef();
        case lib_ZodFirstPartyTypeKind.ZodUnknown:
            return parseUnknownDef();
        case lib_ZodFirstPartyTypeKind.ZodDefault:
            return parseDefaultDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodBranded:
            return parseBrandedDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodReadonly:
            return parseReadonlyDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodCatch:
            return parseCatchDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodPipeline:
            return parsePipelineDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodFunction:
        case lib_ZodFirstPartyTypeKind.ZodVoid:
        case lib_ZodFirstPartyTypeKind.ZodSymbol:
            return undefined;
        default:
            /* c8 ignore next */
            return ((_) => undefined)(typeName);
    }
};

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parseDef.js


function parseDef(def, refs, forceResolution = false) {
    const seenItem = refs.seen.get(def);
    if (refs.override) {
        const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
        if (overrideResult !== ignoreOverride) {
            return overrideResult;
        }
    }
    if (seenItem && !forceResolution) {
        const seenSchema = get$ref(seenItem, refs);
        if (seenSchema !== undefined) {
            return seenSchema;
        }
    }
    const newItem = { def, path: refs.currentPath, jsonSchema: undefined };
    refs.seen.set(def, newItem);
    const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
    // If the return was a function, then the inner definition needs to be extracted before a call to parseDef (recursive)
    const jsonSchema = typeof jsonSchemaOrGetter === "function"
        ? parseDef(jsonSchemaOrGetter(), refs)
        : jsonSchemaOrGetter;
    if (jsonSchema) {
        addMeta(def, refs, jsonSchema);
    }
    if (refs.postProcess) {
        const postProcessResult = refs.postProcess(jsonSchema, def, refs);
        newItem.jsonSchema = jsonSchema;
        return postProcessResult;
    }
    newItem.jsonSchema = jsonSchema;
    return jsonSchema;
}
const get$ref = (item, refs) => {
    switch (refs.$refStrategy) {
        case "root":
            return { $ref: item.path.join("/") };
        case "relative":
            return { $ref: getRelativePath(refs.currentPath, item.path) };
        case "none":
        case "seen": {
            if (item.path.length < refs.currentPath.length &&
                item.path.every((value, index) => refs.currentPath[index] === value)) {
                console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
                return {};
            }
            return refs.$refStrategy === "seen" ? {} : undefined;
        }
    }
};
const getRelativePath = (pathA, pathB) => {
    let i = 0;
    for (; i < pathA.length && i < pathB.length; i++) {
        if (pathA[i] !== pathB[i])
            break;
    }
    return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};
const addMeta = (def, refs, jsonSchema) => {
    if (def.description) {
        jsonSchema.description = def.description;
        if (refs.markdownDescription) {
            jsonSchema.markdownDescription = def.description;
        }
    }
    return jsonSchema;
};

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js


const zodToJsonSchema_zodToJsonSchema = (schema, options) => {
    const refs = getRefs(options);
    const definitions = typeof options === "object" && options.definitions
        ? Object.entries(options.definitions).reduce((acc, [name, schema]) => ({
            ...acc,
            [name]: parseDef(schema._def, {
                ...refs,
                currentPath: [...refs.basePath, refs.definitionPath, name],
            }, true) ?? {},
        }), {})
        : undefined;
    const name = typeof options === "string"
        ? options
        : options?.nameStrategy === "title"
            ? undefined
            : options?.name;
    const main = parseDef(schema._def, name === undefined
        ? refs
        : {
            ...refs,
            currentPath: [...refs.basePath, refs.definitionPath, name],
        }, false) ?? {};
    const title = typeof options === "object" &&
        options.name !== undefined &&
        options.nameStrategy === "title"
        ? options.name
        : undefined;
    if (title !== undefined) {
        main.title = title;
    }
    const combined = name === undefined
        ? definitions
            ? {
                ...main,
                [refs.definitionPath]: definitions,
            }
            : main
        : {
            $ref: [
                ...(refs.$refStrategy === "relative" ? [] : refs.basePath),
                refs.definitionPath,
                name,
            ].join("/"),
            [refs.definitionPath]: {
                ...definitions,
                [name]: main,
            },
        };
    if (refs.target === "jsonSchema7") {
        combined.$schema = "http://json-schema.org/draft-07/schema#";
    }
    else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
        combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
    }
    if (refs.target === "openAi" &&
        ("anyOf" in combined ||
            "oneOf" in combined ||
            "allOf" in combined ||
            ("type" in combined && Array.isArray(combined.type)))) {
        console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
    }
    return combined;
};


;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/index.js






































/* export default */ const esm = ((/* unused pure expression or super */ null && (zodToJsonSchema)));

;// CONCATENATED MODULE: ./node_modules/@orama/core/esm/lib/utils.js


const LOCAL_STORAGE_USER_ID_KEY = '___orama_anonymous_user_id';
const LOCAL_STORAGE_SERVER_SIDE_SESSION_KEY = '___orama_server_side_session';
function utils_createRandomString(length) {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-$';
    let result = '';
    for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * characters.length));
    }
    return result;
}
function formatDuration(duration) {
    if (duration < 1000) {
        return `${duration}ms`;
    }
    else {
        const seconds = duration / 1000;
        if (Number.isInteger(seconds)) {
            return `${seconds}s`;
        }
        return `${seconds.toFixed(1)}s`;
    }
}
function sendBeacon(endpoint, body) {
    if (typeof navigator !== 'undefined') {
        if (typeof navigator.sendBeacon !== 'undefined') {
            navigator.sendBeacon(endpoint, body);
        }
        return;
    }
    fetch(endpoint, {
        method: 'POST',
        body,
        headers: {
            'Content-Type': 'application/json',
        },
    }).then(() => { }, (e) => console.log(e));
}
const hasLocalStorage = typeof localStorage !== 'undefined';
function throttle(func, limit) {
    let inThrottle;
    return function (...args) {
        if (!inThrottle) {
            // @ts-ignore - 'this' has implicitly any, yes
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => (inThrottle = false), limit);
        }
    };
}
function debounce(func, delay) {
    let debounceTimer;
    return function (...args) {
        clearTimeout(debounceTimer);
        // @ts-ignore - 'this' has implicitly any, yes
        debounceTimer = setTimeout(() => func.apply(this, args), delay);
    };
}
function isServerRuntime() {
    // Browser detection: if window or document exists, you're definitely in a browser
    if (typeof dntGlobalThis !== 'undefined' || typeof document !== 'undefined') {
        return false;
    }
    // Node.js
    // @ts-ignore - process is not defined
    if (typeof process !== 'undefined' && "24.10.0") {
        return true;
    }
    // Deno
    // @ts-ignore - Deno is not defined
    if (typeof Deno !== 'undefined' && typeof Deno.version !== 'undefined') {
        return true;
    }
    // Bun
    // @ts-ignore - Bun is not defined
    if (typeof Bun !== 'undefined' && typeof Bun.version !== 'undefined') {
        return true;
    }
    // Cloudflare Workers, Vercel Edge, and other serverless environments often run in a V8 isolate
    if (typeof dntGlobalThis !== 'undefined' &&
        typeof globalThis.Response === 'function' &&
        typeof globalThis.fetch === 'function' &&
        typeof globalThis.navigator === 'undefined' // real browser usually has navigator
    ) {
        return true;
    }
    // AWS Lambda or generic serverless
    // @ts-ignore - process is not defined
    if (typeof process !== 'undefined' && {}.AWS_LAMBDA_FUNCTION_NAME) {
        return true;
    }
    // Default to false if it looks like a browser
    return false;
}
function flattenZodSchema(schema) {
    const raw = zodToJsonSchema_zodToJsonSchema(schema, 'Tool');
    if (raw.$ref && raw.definitions) {
        const defName = raw.$ref.replace('#/definitions/', '');
        const flattened = raw.definitions[defName];
        if (!flattened) {
            throw new Error(`Could not resolve definition: ${defName}`);
        }
        return flattened;
    }
    return raw;
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/esm/constants.js
const constants_LOCAL_STORAGE_USER_ID_KEY = '___$orama_user_id$___';
const DEFAULT_SERVER_USER_ID = 'ssid';

;// CONCATENATED MODULE: ./node_modules/@orama/core/esm/lib/event-stream.js
class event_stream_EventsStreamTransformer extends TransformStream {
    constructor() {
        const decoder = new TextDecoder('utf-8', { ignoreBOM: false });
        let buffer;
        let currentEvent;
        super({
            start() {
                buffer = '';
                currentEvent = { data: '' };
            },
            transform(chunk, controller) {
                const chunkText = decoder.decode(chunk);
                buffer += chunkText;
                let lineEnd;
                while ((lineEnd = /\r\n|\n|\r/.exec(buffer)) !== null) {
                    const line = buffer.substring(0, lineEnd.index);
                    buffer = buffer.substring(lineEnd.index + lineEnd[0].length);
                    if (line.length === 0) {
                        controller.enqueue(currentEvent);
                        currentEvent = { data: '' };
                    }
                    else if (!line.startsWith(':')) {
                        const firstColonMatch = /:/.exec(line);
                        if (!firstColonMatch) {
                            // @ts-expect-error - Temporary fix
                            currentEvent[line] = '';
                            continue;
                        }
                        const key = line.substring(0, firstColonMatch.index);
                        const value = line.substring(firstColonMatch.index + 1);
                        // @ts-expect-error - Temporary fix
                        currentEvent[key] = value?.replace(/^\u0020/, '');
                    }
                }
            },
        });
    }
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/esm/common.js

class common_Auth {
    constructor(config) {
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.config = config;
    }
    async getRef(target, init) {
        let bearer;
        let baseURL;
        switch (this.config.type) {
            case 'apiKey': {
                bearer = this.config.apiKey;
                if (target == 'writer' && !this.config.writerURL) {
                    throw new Error('Cannot perform a request to a writer without the writerURL. Use `cluster.writerURL` to configure it');
                }
                if (target == 'reader' && !this.config.readerURL) {
                    throw new Error('Cannot perform a request to a writer without the writerURL. Use `cluster.readerURL` to configure it');
                }
                baseURL = target == 'writer' ? this.config.writerURL : this.config.readerURL;
                break;
            }
            case 'jwt': {
                const ret = await getJwtToken(this.config.authJwtURL, this.config.collectionID, this.config.privateApiKey, 'write', init);
                // NB: This allow us to support at *client side* a way invocation to reader with private api key!!
                if (target == 'reader') {
                    baseURL = this.config.readerURL ?? ret.readerURL;
                    bearer = ret.readerApiKey;
                }
                else {
                    bearer = ret.jwt;
                    baseURL = this.config.writerURL ?? ret.writerURL;
                }
                break;
            }
        }
        return {
            bearer,
            baseURL,
        };
    }
}
class common_Client {
    constructor(config) {
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.config = config;
    }
    async request(req) {
        const response = await this.getResponse(req);
        if (!response.ok) {
            let text;
            try {
                text = await response.text();
            }
            catch (e) {
                text = `Unable to got response body ${e}`;
            }
            throw new Error(`Request to "${req.path}?${new URLSearchParams(req.params ?? {}).toString()}" failed with status ${response.status}: ${text}`);
        }
        return response.json();
    }
    async requestStream(req) {
        const response = await this.getResponse(req);
        if (response.body === null) {
            throw new Error(`Response body is null for "${req.path}"`);
        }
        return response.body?.pipeThrough(new event_stream_EventsStreamTransformer());
    }
    async eventSource(req) {
        if (req.apiKeyPosition !== 'query-params') {
            throw new Error(`EventSource only supports apiKeyPosition as 'query-params', but got ${req.apiKeyPosition}`);
        }
        if (req.method !== 'GET') {
            throw new Error(`EventSource only supports GET requests, but got ${req.method}`);
        }
        const { baseURL, bearer, } = await this.config.auth.getRef(req.target, req.init);
        const remoteURL = new URL(req.path, baseURL);
        req.params = req.params ?? {};
        req.params['api-key'] = bearer;
        if (req.params) {
            remoteURL.search = new URLSearchParams(req.params).toString();
        }
        return new EventSource(remoteURL);
    }
    async getResponse({ method, path, body, params, apiKeyPosition, init, target, }) {
        const { baseURL, bearer, } = await this.config.auth.getRef(target, init);
        const remoteURL = new URL(path, baseURL);
        const headers = new Headers();
        headers.append('Content-Type', 'application/json');
        if (apiKeyPosition === 'header') {
            headers.append('Authorization', `Bearer ${bearer}`);
        }
        if (apiKeyPosition === 'query-params') {
            params = params ?? {};
            params['api-key'] = bearer;
        }
        const requestObject = {
            method: method,
            headers,
            ...init,
        };
        if (body && (method === 'POST' || method === 'PUT')) {
            requestObject.body = JSON.stringify(body);
        }
        if (params) {
            remoteURL.search = new URLSearchParams(params).toString();
        }
        const response = await fetch(remoteURL, requestObject);
        if (response.status === 401) {
            throw new Error(`Unauthorized: are you using the correct Api Key?`);
        }
        if (response.status === 400) {
            const errorText = await response.text();
            throw new Error(`Bad Request: ${errorText} (path: ${remoteURL.toString()})`);
        }
        return response;
    }
}
async function getJwtToken(authJwtUrl, collectionId, privateApiKey, scope, init) {
    const payload = {
        collectionId,
        privateApiKey,
        scope,
    };
    const request = await fetch(authJwtUrl, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
        ...init,
    });
    if (!request.ok) {
        throw new Error(`JWT request to ${request.url} failed with status ${request.status}: ${await request.text()}`);
    }
    return request.json();
}
function safeJSONParse(data, silent = true) {
    try {
        return JSON.parse(data);
    }
    catch (error) {
        if (!silent) {
            console.warn('Recovered from failed JSON parsing with error:', error);
        }
        return data;
    }
}
const TRAINING_SETS = (/* unused pure expression or super */ null && (['query_optimizer', 'query_planner', 'query_filtering']));

;// CONCATENATED MODULE: ./node_modules/@orama/core/esm/stream-manager.js






class OramaCoreStream {
    constructor(config) {
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "oramaInterface", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "abortController", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "LLMConfig", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sessionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastInteractionParams", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "messages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "state", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        this.collectionID = config.collectionID;
        this.oramaInterface = config.common;
        this.LLMConfig = config.LLMConfig;
        this.messages = config.initialMessages || [];
        this.events = config.events;
        this.sessionID = config.sessionID || (0,cuid2.createId)();
    }
    async answer(data, init) {
        const stream = this.answerStream(data, init);
        let result = '';
        for await (const chunk of stream) {
            result = chunk;
        }
        return result;
    }
    async *answerStream(data, init) {
        this.lastInteractionParams = { ...data };
        data = this._enrichConfig(data);
        this.abortController = new AbortController();
        // Connect the abort signal to the request
        const requestInit = init ?? {};
        requestInit.signal = this.abortController.signal;
        this.messages.push({ role: 'user', content: data.query });
        this.messages.push({ role: 'assistant', content: '' });
        const interactionID = data.interactionID || (0,cuid2.createId)();
        this.state.push({
            id: interactionID,
            query: data.query,
            optimizedQuery: null,
            response: '',
            sources: null,
            loading: true,
            error: false,
            aborted: false,
            errorMessage: null,
            related: data.related?.enabled ? '' : null,
            currentStep: 'starting',
            currentStepVerbose: null,
            selectedLLM: null,
            advancedAutoquery: null,
        });
        this._pushState();
        const currentStateIndex = this.state.length - 1;
        const currentMessageIndex = this.messages.length - 1;
        try {
            const body = {
                interaction_id: interactionID,
                query: data.query,
                visitor_id: data.visitorID,
                conversation_id: data.sessionID,
                messages: this.messages.slice(0, -1), // Send conversation history excluding the empty assistant message
                llm_config: null,
                related: data.related,
                min_similarity: data.min_similarity,
                max_documents: data.max_documents,
                ragat_notation: data.ragat_notation,
            };
            if (this.LLMConfig) {
                body.llm_config = this.LLMConfig;
            }
            const reqStream = await this.oramaInterface.getResponse({
                method: 'POST',
                path: `/v1/collections/${this.collectionID}/generate/answer`,
                body,
                init: requestInit,
                apiKeyPosition: 'query-params',
                target: 'reader',
            });
            if (!reqStream.body) {
                throw new Error('No response body');
            }
            const emitter = parseAnswerStream(reqStream.body);
            let finished = false;
            let lastYielded = '';
            emitter.on('answer_token', (event) => {
                this.state[currentStateIndex].response += event.token;
                this.messages[currentMessageIndex].content = this.state[currentStateIndex].response;
                this._pushState();
            });
            emitter.on('selected_llm', (event) => {
                this.state[currentStateIndex].selectedLLM = {
                    provider: event.provider,
                    model: event.model,
                };
                this._pushState();
            });
            emitter.on('optimizing_query', (event) => {
                this.state[currentStateIndex].optimizedQuery = safeJSONParse(event.optimized_query);
                this._pushState();
            });
            emitter.on('search_results', (event) => {
                this.state[currentStateIndex].sources = event.results;
                this._pushState();
            });
            emitter.on('related_queries', (event) => {
                this.state[currentStateIndex].related = event.queries;
                this._pushState();
            });
            emitter.onStateChange((event) => {
                this.state[currentStateIndex].currentStep = event.state;
                this._pushState();
            });
            emitter.on('state_changed', (event) => {
                this.events?.onIncomingEvent?.(event);
                const eventData = event.data;
                // Handle advanced autoquery state updates
                if (event.state === 'advanced_autoquery_query_optimized' && eventData?.optimized_queries) {
                    if (!this.state[currentStateIndex].advancedAutoquery) {
                        this.state[currentStateIndex].advancedAutoquery = {};
                    }
                    this.state[currentStateIndex].advancedAutoquery.optimizedQueries = eventData.optimized_queries;
                    const verboseMessage = this.state[currentStateIndex].advancedAutoquery.optimizedQueries?.join('\nAlso, ');
                    const deduped = dedupe(verboseMessage);
                    if (deduped) {
                        this.state[currentStateIndex].currentStepVerbose = verboseMessage;
                        this._pushState();
                    }
                }
                if (event.state === 'advanced_autoquery_properties_selected' && eventData?.selected_properties) {
                    if (!this.state[currentStateIndex].advancedAutoquery) {
                        this.state[currentStateIndex].advancedAutoquery = {};
                    }
                    this.state[currentStateIndex].advancedAutoquery.selectedProperties = eventData.selected_properties;
                    const filters = this.state[currentStateIndex].advancedAutoquery.selectedProperties?.map(Object.values).flat()
                        .map((x) => x.selected_properties).flat().map((x) => `${x.property}`).join(', ');
                    const verboseMessage = `Filtering by ${filters}`;
                    const deduped = dedupe(verboseMessage);
                    if (deduped) {
                        this.state[currentStateIndex].currentStepVerbose = verboseMessage;
                        this._pushState();
                    }
                }
                if (event.state === 'advanced_autoquery_combine_queries' && eventData?.queries_and_properties) {
                    if (!this.state[currentStateIndex].advancedAutoquery) {
                        this.state[currentStateIndex].advancedAutoquery = {};
                    }
                    this.state[currentStateIndex].advancedAutoquery.queriesAndProperties = eventData.queries_and_properties;
                    this._pushState();
                }
                if (event.state === 'advanced_autoquery_tracked_queries_generated' && eventData?.tracked_queries) {
                    if (!this.state[currentStateIndex].advancedAutoquery) {
                        this.state[currentStateIndex].advancedAutoquery = {};
                    }
                    this.state[currentStateIndex].advancedAutoquery.trackedQueries = eventData.tracked_queries;
                    this._pushState();
                }
                if (event.state === 'advanced_autoquery_search_results' && eventData?.search_results) {
                    if (!this.state[currentStateIndex].advancedAutoquery) {
                        this.state[currentStateIndex].advancedAutoquery = {};
                    }
                    this.state[currentStateIndex].advancedAutoquery.searchResults = eventData.search_results;
                    const resultsCount = eventData.search_results.reduce((acc, curr) => acc + curr.results[0].count, 0);
                    const resultText = eventData.search_results.map((x) => JSON.parse(x.generated_query).term).join(', ');
                    const verboseMessage = `Found ${resultsCount} result${resultsCount === 1 ? '' : 's'} for "${resultText}"`;
                    const deduped = dedupe(verboseMessage);
                    if (deduped) {
                        this.state[currentStateIndex].currentStepVerbose = verboseMessage;
                        this._pushState();
                    }
                }
                if (event.state === 'advanced_autoquery_completed' && eventData?.results) {
                    if (!this.state[currentStateIndex].advancedAutoquery) {
                        this.state[currentStateIndex].advancedAutoquery = {};
                    }
                    this.state[currentStateIndex].advancedAutoquery.results = eventData.results;
                    this.state[currentStateIndex].currentStepVerbose = null;
                    this._pushState();
                }
                if (event.state === 'completed') {
                    finished = true;
                    this.state[currentStateIndex].loading = false;
                    this._pushState();
                }
                if (this.events?.onEnd) {
                    this.events.onEnd(this.state);
                }
            });
            while (!finished) {
                const response = this.state[currentStateIndex].response;
                if (response !== lastYielded) {
                    lastYielded = response;
                    yield response;
                }
                else if (!finished) {
                    await new Promise((resolve) => setTimeout(resolve, 0));
                }
            }
        }
        catch (error) {
            // Handle AbortError gracefully
            if (error instanceof Error && error.name === 'AbortError') {
                // Stream was aborted - this is expected behavior, don't throw
                this.state[currentStateIndex].loading = false;
                this.state[currentStateIndex].aborted = true;
                this._pushState();
                return; // Exit the generator gracefully
            }
            // Handle other errors
            this.state[currentStateIndex].loading = false;
            this.state[currentStateIndex].error = true;
            this.state[currentStateIndex].errorMessage = error instanceof Error ? error.message : 'Unknown error';
            this._pushState();
            throw error; // Re-throw non-abort errors
        }
    }
    regenerateLast({ stream = true } = {}, init) {
        if (this.state.length === 0 || this.messages.length === 0) {
            throw new Error('No messages to regenerate');
        }
        const isLastMessageAssistant = this.messages.at(-1)?.role === 'assistant';
        if (!isLastMessageAssistant) {
            throw new Error('Last message is not an assistant message');
        }
        // Remove the last assistant message and state
        this.messages.pop();
        this.state.pop();
        if (!this.lastInteractionParams) {
            throw new Error('No last interaction parameters available');
        }
        if (stream) {
            return this.answerStream(this.lastInteractionParams, init);
        }
        return this.answer(this.lastInteractionParams, init);
    }
    abort() {
        if (!this.abortController) {
            throw new Error('AbortController is not available.');
        }
        if (this.state.length === 0) {
            throw new Error('There is no active request to abort.');
        }
        this.abortController.abort();
        this.abortController = undefined;
        const lastState = this.state[this.state.length - 1];
        lastState.aborted = true;
        lastState.loading = false;
        this._pushState();
    }
    clearSession() {
        this.messages = [];
        this.state = [];
        this._pushState();
    }
    _pushState() {
        this.events?.onStateChange?.(this.state);
    }
    _enrichConfig(config) {
        if (!config.visitorID) {
            config.visitorID = getUserID();
        }
        if (!config.interactionID) {
            config.interactionID = (0,cuid2.createId)();
        }
        if (!config.sessionID) {
            config.sessionID = this.sessionID;
        }
        return config;
    }
}
function getUserID() {
    if (isServerRuntime()) {
        return DEFAULT_SERVER_USER_ID;
    }
    if (hasLocalStorage) {
        const id = localStorage.getItem(constants_LOCAL_STORAGE_USER_ID_KEY);
        if (id) {
            return id;
        }
    }
    return (0,cuid2.createId)();
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/esm/manager.js


class OramaCoreManager {
    constructor(config) {
        Object.defineProperty(this, "collection", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        const client = new Client({
            auth: new Auth({
                type: 'apiKey',
                apiKey: config.masterAPIKey,
                writerURL: config.url,
                readerURL: undefined,
            }),
        });
        this.collection = new CollectionNamespace(client);
    }
}
class CollectionNamespace {
    constructor(client) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
    }
    async create(config, init) {
        const body = {
            id: config.id,
            description: config.description,
            write_api_key: config.writeAPIKey ?? createRandomString(32),
            read_api_key: config.readAPIKey ?? createRandomString(32),
        };
        if (config.embeddingsModel) {
            body.embeddings_model = config.embeddingsModel;
        }
        await this.client.request({
            path: '/v1/collections/create',
            body,
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
        return {
            id: body.id,
            description: body.description,
            writeAPIKey: body.write_api_key,
            readonlyAPIKey: body.read_api_key,
        };
    }
    list(init) {
        return this.client.request({
            path: '/v1/collections',
            method: 'GET',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    get(collectionID, init) {
        return this.client.request({
            path: `/v1/collections/${collectionID}`,
            method: 'GET',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    delete(collectionID, init) {
        return this.client.request({
            path: `/v1/collections/delete`,
            method: 'POST',
            body: {
                collection_id_to_delete: collectionID,
            },
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/esm/send-beacon.js
function send_beacon_sendBeacon(endpoint, body) {
    if (typeof navigator !== 'undefined') {
        if (typeof navigator.sendBeacon !== 'undefined') {
            navigator.sendBeacon(endpoint, body);
        }
        return;
    }
    fetch(endpoint, {
        method: 'POST',
        body,
        headers: {
            'Content-Type': 'application/json',
        },
    }).then(() => { }, (e) => console.log(e));
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/esm/profile.js



class Profile {
    constructor({ endpoint, apiKey }) {
        Object.defineProperty(this, "endpoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "apiKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "userId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "identity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "userAlias", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (!endpoint || !apiKey) {
            throw new Error('Endpoint and API Key are required to create a Profile');
        }
        if (typeof endpoint !== 'string' || typeof apiKey !== 'string') {
            throw new Error('Endpoint and API Key must be strings');
        }
        if (typeof localStorage !== 'undefined') {
            // Browser side
            const userId = localStorage.getItem(constants_LOCAL_STORAGE_USER_ID_KEY);
            if (userId) {
                this.userId = userId;
            }
            else {
                this.userId = (0,cuid2.createId)();
                localStorage.setItem(constants_LOCAL_STORAGE_USER_ID_KEY, this.userId);
            }
        }
        else {
            // Server side
            this.userId = (0,cuid2.createId)();
        }
        this.endpoint = endpoint;
        this.apiKey = apiKey;
    }
    setParams(params) {
        const { protocol, host } = new URL(params.identifyUrl);
        const telemetryDomain = `${protocol}//${host}/identify`;
        this.params = {
            identifyUrl: telemetryDomain,
            index: params.index,
        };
    }
    getIdentity() {
        return this.identity;
    }
    getUserId() {
        return this.userId;
    }
    getAlias() {
        return this.userAlias;
    }
    async sendProfileData(data) {
        if (!this.params) {
            throw new Error('Orama Profile is not initialized');
        }
        const body = JSON.stringify({
            ...data,
            visitorId: this.getUserId(),
            index: this.params.index,
        });
        await send_beacon_sendBeacon(`${this.params?.identifyUrl}?api-key=${this.apiKey}`, body);
    }
    async identify(identity) {
        if (typeof identity !== 'string') {
            throw new Error('Identity must be a string');
        }
        await this.sendProfileData({
            entity: 'identity',
            id: identity,
        });
        this.identity = identity;
    }
    async alias(alias) {
        if (typeof alias !== 'string') {
            throw new Error('Identity must be a string');
        }
        await this.sendProfileData({
            entity: 'alias',
            id: alias,
        });
        this.userAlias = alias;
    }
    reset() {
        this.userId = (0,cuid2.createId)();
        this.identity = undefined;
        this.userAlias = undefined;
    }
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/esm/collection.js







const DEFAULT_READER_URL = 'https://collections.orama.com';
const DEAFULT_JWT_URL = 'https://app.orama.com/api/user/jwt';
class collection_CollectionManager {
    constructor(config) {
        // private url: string
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "apiKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // private writeAPIKey?: string
        // private readAPIKey?: string
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "profile", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "ai", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collections", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "hooks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "logs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "systemPrompts", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tools", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "identity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "trainingSets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "mcp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        let auth;
        if (config.apiKey.startsWith('p_')) {
            // OramaCore Cloud Private Api Key (JWT flow)
            auth = new common_Auth({
                type: 'jwt',
                authJwtURL: config.authJwtURL ?? DEAFULT_JWT_URL,
                collectionID: config.collectionID,
                privateApiKey: config.apiKey,
                readerURL: config.cluster?.readURL ?? DEFAULT_READER_URL,
                writerURL: config.cluster?.writerURL,
            });
        }
        else {
            auth = new common_Auth({
                type: 'apiKey',
                readerURL: config.cluster?.readURL ?? DEFAULT_READER_URL,
                writerURL: config.cluster?.writerURL,
                apiKey: config.apiKey,
            });
            this.profile = new Profile({
                endpoint: config.cluster?.readURL ?? DEFAULT_READER_URL,
                apiKey: config.apiKey,
            });
        }
        const commonConfig = {
            auth,
        };
        this.collectionID = config.collectionID;
        this.client = new common_Client(commonConfig);
        this.apiKey = config.apiKey;
        // Initialize namespaces
        this.ai = new AINamespace(this.client, this.collectionID, this.profile);
        this.collections = new CollectionsNamespace(this.client, this.collectionID);
        this.index = new IndexNamespace(this.client, this.collectionID);
        this.hooks = new HooksNamespace(this.client, this.collectionID);
        this.logs = new LogsNamespace(this.client, this.collectionID);
        this.systemPrompts = new SystemPromptsNamespace(this.client, this.collectionID);
        this.tools = new ToolsNamespace(this.client, this.collectionID);
        this.identity = new IdentityNamespace(this.profile);
        this.trainingSets = new TrainingSetsNamespace(this.client, this.collectionID);
        this.mcp = new MCPNamespace(this.client, this.collectionID);
    }
    async search(query, init) {
        const start = Date.now();
        const { datasourceIDs, indexes, ...restQuery } = query;
        const result = await this.client.request({
            path: `/v1/collections/${this.collectionID}/search`,
            body: {
                userID: this.profile?.getUserId() || undefined,
                ...restQuery, // restQuery can override `userID`
                indexes: datasourceIDs || indexes,
            },
            method: 'POST',
            params: undefined,
            init,
            apiKeyPosition: 'query-params',
            target: 'reader',
        });
        const elapsed = Date.now() - start;
        return {
            ...result,
            elapsed: {
                raw: elapsed,
                formatted: formatDuration(elapsed),
            },
        };
    }
}
class AINamespace {
    constructor(client, collectionID, profile) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "profile", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.collectionID = collectionID;
        this.profile = profile;
    }
    async NLPSearch(params, init) {
        const body = {
            llm_config: params.LLMConfig ? { ...params.LLMConfig } : undefined,
            userID: this.profile?.getUserId() || undefined,
            messages: [
                {
                    role: 'user',
                    content: params.query,
                },
            ],
        };
        const response = await this.client.getResponse({
            method: 'POST',
            path: `/v1/collections/${this.collectionID}/generate/nlp_query`,
            body: body,
            init,
            apiKeyPosition: 'query-params',
            target: 'reader',
        });
        if (!response.body) {
            throw new Error('No response body');
        }
        const emitter = parseNLPQueryStream(response.body);
        let finished = false;
        let results = [];
        emitter.on('search_results', (event) => {
            results = event.results;
            finished = true;
        });
        emitter.on('error', (e) => {
            if (e.is_terminal) {
                finished = true;
            }
            throw new Error(e.error);
        });
        while (!finished) {
            await new Promise((resolve) => setTimeout(resolve, 10));
        }
        return results;
    }
    async *NLPSearchStream(params, init) {
        const body = {
            llm_config: params.LLMConfig ? { ...params.LLMConfig } : undefined,
            userID: this.profile?.getUserId() || undefined,
            messages: [
                {
                    role: 'user',
                    content: params.query,
                },
            ],
        };
        const response = await this.client.getResponse({
            method: 'POST',
            path: `/v1/collections/${this.collectionID}/generate/nlp_query`,
            body: body,
            init,
            apiKeyPosition: 'query-params',
            target: 'reader',
        });
        if (!response.body) {
            throw new Error('No response body');
        }
        let finished = false;
        let currentResult = null;
        const emitter = parseNLPQueryStream(response.body);
        emitter.on('error', (e) => {
            if (e.is_terminal) {
                finished = true;
            }
            throw new Error(e.error);
        });
        emitter.on('state_changed', (event) => {
            currentResult = {
                status: event.state,
                data: (event.data || []),
            };
        });
        emitter.on('search_results', (event) => {
            currentResult = {
                status: 'SEARCH_RESULTS',
                data: event.results,
            };
            finished = true;
        });
        // Yield results until we get search results
        while (!finished) {
            if (currentResult !== null) {
                const deduped = dedupe(currentResult.status);
                if (deduped) {
                    yield currentResult;
                }
            }
            // Small delay to prevent busy waiting
            await new Promise((resolve) => setTimeout(resolve, 10));
        }
        // Yield the final search results
        if (currentResult !== null) {
            const deduped = dedupe(currentResult.status);
            if (deduped) {
                yield currentResult;
            }
        }
    }
    createAISession(config) {
        return new OramaCoreStream({
            collectionID: this.collectionID,
            common: this.client,
            ...config,
        });
    }
}
class CollectionsNamespace {
    constructor(client, collectionID) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.collectionID = collectionID;
    }
    getStats(collectionID, init) {
        return this.client.request({
            path: `/v1/collections/${collectionID}/stats`,
            method: 'GET',
            init,
            apiKeyPosition: 'query-params',
            target: 'reader',
        });
    }
    getAllDocs(id, init) {
        return this.client.request({
            path: `/v1/collections/list`,
            method: 'POST',
            body: { id },
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
}
class IndexNamespace {
    constructor(client, collectionID) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.collectionID = collectionID;
    }
    async create(config, init) {
        const body = {
            id: config.id,
            embedding: config.embeddings,
        };
        if (config?.typeStrategy?.enum) {
            const enumStrategy = config.typeStrategy.enum;
            if (enumStrategy === 'explicit') {
                body.type_strategy = {
                    enum_strategy: 'Explicit',
                };
            }
            else {
                const match = enumStrategy.match(/^string\((\d+)\)$/);
                if (match) {
                    const length = parseInt(match[1], 10);
                    body.type_strategy = {
                        enum_strategy: {
                            StringLength: length,
                        },
                    };
                }
                else {
                    throw new Error('Invalid enum strategy format. Use "explicit" or "string(N)" where N is a number.');
                }
            }
        }
        await this.client.request({
            path: `/v1/collections/${this.collectionID}/indexes/create`,
            body,
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    async delete(indexID, init) {
        await this.client.request({
            path: `/v1/collections/${this.collectionID}/indexes/delete`,
            body: { index_id_to_delete: indexID },
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    set(id) {
        return new Index(this.client, this.collectionID, id);
    }
}
class HooksNamespace {
    constructor(client, collectionID) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.collectionID = collectionID;
    }
    async insert(config, init) {
        const body = {
            name: config.name,
            code: config.code,
        };
        await this.client.request({
            path: `/v1/collections/${this.collectionID}/hooks/set`,
            body,
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
        return {
            hookID: body.name,
            code: body.code,
        };
    }
    async list(init) {
        const res = await this.client.request({
            path: `/v1/collections/${this.collectionID}/hooks/list`,
            method: 'GET',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
        return res.hooks || {};
    }
    async delete(hook, init) {
        const body = {
            name_to_delete: hook,
        };
        await this.client.request({
            path: `/v1/collections/${this.collectionID}/hooks/delete`,
            body,
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
}
class PinningRulesNamespace {
    constructor(client, collectionID, indexID) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "indexID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.collectionID = collectionID;
        this.indexID = indexID;
    }
    insert(rule) {
        if (!rule.id) {
            rule.id = utils_createRandomString(32);
        }
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/indexes/${this.indexID}/pin_rules/insert`,
            body: rule,
            method: 'POST',
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    update(rule) {
        if (!rule.id) {
            rule.id = utils_createRandomString(32);
        }
        return this.insert(rule);
    }
    async list() {
        const results = await this.client.request({
            path: `/v1/collections/${this.collectionID}/indexes/${this.indexID}/pin_rules/list`,
            method: 'GET',
            apiKeyPosition: 'header',
            target: 'writer',
        });
        return results.data;
    }
    listIDs() {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/indexes/${this.indexID}/pin_rules/ids`,
            method: 'GET',
            apiKeyPosition: 'query-params',
            target: 'reader',
        });
    }
    delete(id) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/indexes/${this.indexID}/pin_rules/delete`,
            method: 'POST',
            body: {
                pin_rule_id_to_delete: id,
            },
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
}
class LogsNamespace {
    constructor(client, collectionID) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.collectionID = collectionID;
    }
    stream(init) {
        return this.client.eventSource({
            path: `/v1/collections/${this.collectionID}/logs`,
            method: 'GET',
            init,
            apiKeyPosition: 'query-params',
            target: 'reader',
        });
    }
}
class SystemPromptsNamespace {
    constructor(client, collectionID) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.collectionID = collectionID;
    }
    insert(systemPrompt, init) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/system_prompts/insert`,
            body: systemPrompt,
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    get(id, init) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/system_prompts/get`,
            params: { system_prompt_id: id },
            method: 'GET',
            init,
            apiKeyPosition: 'query-params',
            target: 'reader',
        });
    }
    getAll(init) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/system_prompts/all`,
            method: 'GET',
            init,
            apiKeyPosition: 'query-params',
            target: 'reader',
        });
    }
    delete(id, init) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/system_prompts/delete`,
            body: { id },
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    update(systemPrompt, init) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/system_prompts/update`,
            body: systemPrompt,
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    validate(systemPrompt, init) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/system_prompts/validate`,
            body: systemPrompt,
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
}
class ToolsNamespace {
    constructor(client, collectionID) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.collectionID = collectionID;
    }
    insert(tool, init) {
        let parameters;
        switch (true) {
            case typeof tool.parameters === 'string': {
                parameters = tool.parameters;
                break;
            }
            case tool.parameters instanceof ZodType: {
                const flattenedSchema = flattenZodSchema(tool.parameters);
                parameters = JSON.stringify(flattenedSchema);
                break;
            }
            case typeof tool.parameters === 'object': {
                parameters = JSON.stringify(tool.parameters);
                break;
            }
            default:
                throw new Error('Invalid parameters type. Must be string, object or ZodType');
        }
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/tools/insert`,
            body: {
                ...tool,
                parameters,
            },
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    get(id, init) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/tools/get`,
            params: { tool_id: id },
            method: 'GET',
            init,
            apiKeyPosition: 'query-params',
            target: 'reader',
        });
    }
    getAll(init) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/tools/all`,
            method: 'GET',
            init,
            apiKeyPosition: 'query-params',
            target: 'reader',
        });
    }
    delete(id, init) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/tools/delete`,
            body: { id },
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    update(tool, init) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/tools/update`,
            body: tool,
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    async execute(tools, init) {
        const response = await this.client.request({
            path: `/v1/collections/${this.collectionID}/tools/run`,
            body: tools,
            method: 'POST',
            init,
            apiKeyPosition: 'query-params',
            target: 'reader',
        });
        if (response.results) {
            return {
                results: response.results.map((result) => {
                    if ('functionResult' in result) {
                        return {
                            functionResult: {
                                tool_id: result.functionResult.tool_id,
                                result: JSON.parse(result.functionResult.result),
                            },
                        };
                    }
                    if ('functionParameters' in result) {
                        return {
                            functionParameters: {
                                tool_id: result.functionParameters.tool_id,
                                result: JSON.parse(result.functionParameters.result),
                            },
                        };
                    }
                    return result;
                }),
            };
        }
        return {
            results: null,
        };
    }
}
class IdentityNamespace {
    constructor(profile) {
        Object.defineProperty(this, "profile", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.profile = profile;
    }
    get() {
        if (!this.profile) {
            throw new Error('Profile is not defined');
        }
        return this.profile.getIdentity();
    }
    getUserId() {
        if (!this.profile) {
            throw new Error('Profile is not defined');
        }
        return this.profile.getUserId();
    }
    getAlias() {
        if (!this.profile) {
            throw new Error('Profile is not defined');
        }
        return this.profile.getAlias();
    }
    async identify(identity) {
        if (!this.profile) {
            throw new Error('Profile is not defined');
        }
        await this.profile.identify(identity);
    }
    async alias(alias) {
        if (!this.profile) {
            throw new Error('Profile is not defined');
        }
        await this.profile.alias(alias);
    }
    reset() {
        if (!this.profile) {
            throw new Error('Profile is not defined');
        }
        this.profile.reset();
    }
}
class TrainingSetsNamespace {
    constructor(client, collectionID) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.collectionID = collectionID;
    }
    async get(trainingSetId, init) {
        const response = await this.client.request({
            path: `/v1/collections/${this.collectionID}/training_sets/${trainingSetId}/get`,
            method: 'GET',
            init,
            apiKeyPosition: 'query-params',
            target: 'reader',
        });
        const trainingSets = response.training_sets && JSON.parse(response.training_sets);
        return { training_sets: trainingSets };
    }
    generate(trainingSetId, LLMConfig, init) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/training_sets/${trainingSetId}/generate`,
            method: 'POST',
            body: {
                llm_config: LLMConfig ? { ...LLMConfig } : undefined,
            },
            init,
            apiKeyPosition: 'query-params',
            target: 'reader',
        });
    }
    insert(trainingSetId, trainingSet, init) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/training_sets/${trainingSetId}/insert`,
            method: 'POST',
            body: {
                training_set: trainingSet,
            },
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    delete(trainingSetId, init) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/training_sets/${trainingSetId}/delete`,
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
}
class Index {
    constructor(oramaInterface, collectionID, indexID) {
        Object.defineProperty(this, "indexID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "oramaInterface", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "transaction", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "pinningRules", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.indexID = indexID;
        this.collectionID = collectionID;
        this.oramaInterface = oramaInterface;
        this.transaction = new Transaction(oramaInterface, collectionID, indexID);
        this.pinningRules = new PinningRulesNamespace(oramaInterface, collectionID, indexID);
    }
    async reindex(init) {
        await this.oramaInterface.request({
            path: `/v1/collections/${this.collectionID}/indexes/${this.indexID}/reindex`,
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    async insertDocuments(documents, init) {
        await this.oramaInterface.request({
            path: `/v1/collections/${this.collectionID}/indexes/${this.indexID}/insert`,
            body: Array.isArray(documents) ? documents : [documents],
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    async deleteDocuments(documentIDs, init) {
        await this.oramaInterface.request({
            path: `/v1/collections/${this.collectionID}/indexes/${this.indexID}/delete`,
            body: Array.isArray(documentIDs) ? documentIDs : [documentIDs],
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    async upsertDocuments(documents, init) {
        await this.oramaInterface.request({
            path: `/v1/collections/${this.collectionID}/indexes/${this.indexID}/documents/upsert`,
            body: {
                strategy: "merge",
                documents: documents
            },
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
}
class Transaction {
    constructor(oramaInterface, collectionID, indexID, tempIndexID = utils_createRandomString(16)) {
        Object.defineProperty(this, "indexID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tempIndexID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "oramaInterface", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.oramaInterface = oramaInterface;
        this.collectionID = collectionID;
        this.indexID = indexID;
        this.tempIndexID = tempIndexID;
    }
    open(init) {
        return this.oramaInterface.request({
            path: `/v1/collections/${this.collectionID}/indexes/${this.indexID}/create-temporary-index`,
            method: 'POST',
            body: {
                id: this.tempIndexID,
            },
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    insertDocuments(documents, init) {
        return this.oramaInterface.request({
            path: `/v1/collections/${this.collectionID}/indexes/${this.tempIndexID}/insert`,
            body: Array.isArray(documents) ? documents : [documents],
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    commit(init) {
        return this.oramaInterface.request({
            path: `/v1/collections/${this.collectionID}/replace-index`,
            method: 'POST',
            body: {
                target_index_id: this.indexID,
                temp_index_id: this.tempIndexID,
            },
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    rollback(init) {
        return this.oramaInterface.request({
            path: `/v1/collections/${this.collectionID}/indexes/${this.tempIndexID}/delete`,
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
}
class MCPNamespace {
    constructor(client, collectionID) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.collectionID = collectionID;
    }
    updateDescription(newDescription, init) {
        return this.client.request({
            method: 'PUT',
            target: 'writer',
            apiKeyPosition: 'header',
            init,
            path: `/v1/collections/${this.collectionID}/mcp/update`,
            body: {
                mcp_description: newDescription,
            },
        });
    }
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/esm/cloud.js

class OramaCloud {
    constructor(config) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // Expose all namespaces from CollectionManager
        Object.defineProperty(this, "identity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "ai", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collections", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "hooks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "logs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "systemPrompts", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tools", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = new CollectionManager({
            ...config,
            collectionID: config.projectId,
        });
        // Delegate to CollectionManager namespaces
        this.identity = this.client.identity;
        this.ai = this.client.ai;
        this.collections = this.client.collections;
        this.index = this.client.index;
        this.hooks = this.client.hooks;
        this.logs = this.client.logs;
        this.systemPrompts = this.client.systemPrompts;
        this.tools = this.client.tools;
    }
    search(params) {
        const { datasources, ...rest } = params;
        return this.client.search({ ...rest, indexes: datasources });
    }
    dataSource(id) {
        const index = this.client.index.set(id);
        return new DataSourceNamespace(index);
    }
}
class DataSourceNamespace {
    constructor(index) {
        Object.defineProperty(this, "index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.index = index;
    }
    reindex() {
        return this.index.reindex();
    }
    insertDocuments(documents) {
        return this.index.insertDocuments(documents);
    }
    deleteDocuments(documentIDs) {
        return this.index.deleteDocuments(documentIDs);
    }
    upsertDocuments(documents) {
        return this.index.upsertDocuments(documents);
    }
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/esm/index.js







const dedupe = (() => {
    const seenMessages = new Set();
    return function (message) {
        if (!message)
            return '';
        if (seenMessages.has(message)) {
            return '';
        }
        seenMessages.add(message);
        return message;
    };
})();

;// CONCATENATED MODULE: ./node_modules/@orama/plugin-docusaurus-v3/dist/constants.js
const DOCS_PRESET_SCHEMA = {
    title: 'string',
    content: 'string',
    path: 'string',
    section: 'string',
    category: 'enum',
    version: 'enum'
};

;// CONCATENATED MODULE: ./node_modules/@orama/plugin-docusaurus-v3/dist/utils.js


const restFetcher = async (url, options)=>{
    const response = await fetch(url, options);
    if (response.status === 0) {
        throw new Error(`Request failed (network error): ${await response.text()}`);
    } else if (response.status >= 400) {
        const error = new Error(`Request failed (HTTP error ${response.status})}`);
        error.response = response;
        throw error;
    }
    return await response.json();
};
async function loggedOperation(preMessage, fn, postMessage) {
    if (preMessage != null) {
        console.debug(preMessage);
    }
    try {
        const response = await fn();
        if (postMessage != null) {
            console.debug(postMessage);
        }
        return response;
    } catch (error) {
        throw new Error(`Error: ${error.message}`);
    }
}
async function fetchEndpointConfig(baseUrl, APIKey, indexId) {
    const result = await loggedOperation('Orama: Fetch index endpoint config', async ()=>await restFetcher(`${baseUrl}/indexes/get-index?id=${indexId}`, {
            headers: {
                Authorization: `Bearer ${APIKey}`
            }
        }), 'Orama: Fetch index endpoint config (success)');
    return {
        endpoint: result === null || result === void 0 ? void 0 : result.api_endpoint,
        api_key: result === null || result === void 0 ? void 0 : result.api_key,
        collection_id: ''
    };
}
async function createOramaInstance(oramaDocs) {
    console.debug('Orama: Creating instance.');
    const db = create_create({
        schema: {
            ...DOCS_PRESET_SCHEMA,
            version: 'enum'
        }
    });
    await insertMultiple(db, oramaDocs);
    console.debug('Orama: Instance created.');
    return db;
}

;// CONCATENATED MODULE: ./node_modules/@orama/plugin-docusaurus-v3/dist/theme/SearchBar/useOrama.js










function getOramaPlugins(plugins) {
    const pluginsArray = [];
    if (plugins === null || plugins === void 0 ? void 0 : plugins.analytics) {
        pluginsArray.push(O({
            apiKey: plugins.analytics.apiKey,
            indexId: plugins.analytics.indexId,
            enabled: plugins.analytics.enabled
        }));
    }
    return pluginsArray;
}
async function getOramaLocalData(indexGzipURL, plugins) {
    try {
        const searchResponse = await fetch(indexGzipURL);
        if (!searchResponse.ok) {
            const errorText = await searchResponse.text();
            throw new Error(`HTTP error ${searchResponse.status}: ${errorText}`);
        }
        const buffer = await searchResponse.arrayBuffer();
        const deflatedString = ungzip_1(buffer, {
            to: 'string'
        });
        const parsedData = JSON.parse(deflatedString);
        const db = create_create({
            schema: {
                ...DOCS_PRESET_SCHEMA,
                version: 'enum'
            },
            plugins: getOramaPlugins(plugins)
        });
        serialization_load(db, parsedData);
        return db;
    } catch (error) {
        console.error('Error loading search index:', error);
        throw error;
    }
}
function isCloudData(data) {
    return data.oramaMode === 'cloud';
}
function useOrama() {
    const [searchBoxConfig, setSearchBoxConfig] = (0,react.useState)({
        basic: {},
        custom: {}
    });
    const oramaData = (0,useGlobalData/* .usePluginData */.P_)('@orama/plugin-docusaurus-v3');
    const indexGzipURL = (0,useBaseUrl/* ["default"] */.Ay)('orama-search-index-current.json.gz');
    const isBrowser = (0,useIsBrowser/* ["default"] */.A)();
    (0,react.useEffect)(()=>{
        async function loadOrama() {
            var _a;
            let oramaInstance;
            let searchBoxBasicConfig = {};
            if (isCloudData(oramaData)) {
                const collectionId = oramaData.indexConfig.collection_id;
                const apiKey = oramaData.indexConfig.api_key;
                let collectionManager;
                if (collectionId) {
                    // Note: collectionId is ONLY available in OramaCore
                    collectionManager = new collection_CollectionManager({
                        collectionID: collectionId,
                        apiKey
                    });
                }
                searchBoxBasicConfig = {
                    index: {
                        endpoint: oramaData.indexConfig.endpoint,
                        api_key: oramaData.indexConfig.api_key
                    },
                    collectionManager: collectionManager
                };
            } else if (oramaData.oramaDocs) {
                oramaInstance = await createOramaInstance(oramaData.oramaDocs);
                searchBoxBasicConfig = {
                    clientInstance: oramaInstance
                };
            } else {
                oramaInstance = await getOramaLocalData(indexGzipURL, oramaData.plugins);
                searchBoxBasicConfig = {
                    clientInstance: oramaInstance
                };
            }
            setSearchBoxConfig({
                basic: {
                    ...searchBoxBasicConfig,
                    facetProperty: 'category',
                    disableChat: !isCloudData(oramaData)
                },
                custom: (_a = oramaData.searchbox) !== null && _a !== void 0 ? _a : {}
            });
        }
        if (!isBrowser) {
            return;
        }
        loadOrama().catch((error)=>{
            console.error('Cannot load search index.', error);
        });
    }, [
        isBrowser
    ]);
    return {
        searchBoxConfig,
        searchBtnConfig: oramaData.searchButton
    };
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

// TODO Docusaurus v4: remove these workarounds as a breaking change
//  and remove docs plugin peerDeps in theme-common/package.json
//  This is public API surface that we need to keep for v3
//  See https://github.com/facebook/docusaurus/pull/10316
function useCurrentSidebarCategory(...args) {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    return (__webpack_require__(88209)/* .useCurrentSidebarCategory */.$S)(...args);
}
function filterDocCardListItems(...args) {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    return (__webpack_require__(88209)/* .filterDocCardListItems */.d1)(...args);
}
function useDocsPreferredVersion(...args) {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    return (__webpack_require__(88209)/* .useDocsPreferredVersion */.g1)(...args);
}
function useContextualSearchFilters() {
    const { i18n } = useDocusaurusContext();
    const docsTags = // eslint-disable-next-line @typescript-eslint/no-var-requires, react-compiler/react-compiler
    (__webpack_require__(88209)/* .useDocsContextualSearchTags */.vF)();
    const tags = [
        DEFAULT_SEARCH_TAG,
        ...docsTags
    ];
    return {
        locale: i18n.currentLocale,
        tags
    };
}
/*
 * APIs to document
 */ 











/*
 * APIs kept undocumented, on purpose
 * Note: we still guarantee retro-compatibility on those
 */ 










 //# sourceMappingURL=index.js.map

;// CONCATENATED MODULE: ./node_modules/@orama/plugin-docusaurus-v3/dist/theme/SearchBar/utils.js


function getColorMode() {
    if (typeof document === 'undefined') {
        return 'light';
    }
    const html = document.querySelector("html");
    return html === null || html === void 0 ? void 0 : html.dataset.theme;
}
function getPreferredVersion(index) {
    var _a;
    const activePlugin = (0,lib_client/* .useActivePlugin */.vT)();
    try {
        const { preferredVersion } = useDocsPreferredVersion((_a = activePlugin === null || activePlugin === void 0 ? void 0 : activePlugin.pluginId) !== null && _a !== void 0 ? _a : "default");
        if (!preferredVersion) {
            throw new reactUtils/* .ReactContextError */.dV("Not using versioned docs");
        }
        return preferredVersion.name;
    } catch (e) {
        if (index) {
            if (e instanceof reactUtils/* .ReactContextError */.dV) {
                return "current";
            } else {
                throw e;
            }
        }
        return null;
    }
}

;// CONCATENATED MODULE: ./node_modules/@orama/plugin-docusaurus-v3/dist/theme/SearchBar/index.js







const OramaSearchButton = /*#__PURE__*/ (0,react.lazy)(()=>__webpack_require__.e(/* import() */ "1359").then(__webpack_require__.bind(__webpack_require__, 19042)).then((module)=>({
            default: module.OramaSearchButton
        })));
const OramaSearchBox = /*#__PURE__*/ (0,react.lazy)(()=>__webpack_require__.e(/* import() */ "1359").then(__webpack_require__.bind(__webpack_require__, 19042)).then((module)=>({
            default: module.OramaSearchBox
        })));
// Add `where` when collectionManager is provided
// Handles different query APIs
function formatSearchParams(versionName, collectionManager) {
    if (collectionManager) {
        return {
            version: versionName
        };
    }
    return {
        version: {
            eq: versionName
        }
    };
}
function OramaSearchNoDocs() {
    var _a;
    const colorMode = getColorMode();
    const { searchBoxConfig, searchBtnConfig = {
        text: 'Search'
    } } = useOrama();
    const collectionManager = (_a = searchBoxConfig.basic) === null || _a === void 0 ? void 0 : _a.collectionManager;
    return /*#__PURE__*/ react.createElement(react.Fragment, null, /*#__PURE__*/ react.createElement(OramaSearchButton, {
        colorScheme: colorMode,
        className: "DocSearch-Button",
        ...searchBtnConfig
    }, searchBtnConfig === null || searchBtnConfig === void 0 ? void 0 : searchBtnConfig.text), /*#__PURE__*/ react.createElement(OramaSearchBox, {
        ...collectionManager ? {} : searchBoxConfig.basic,
        ...searchBoxConfig.custom,
        oramaCoreClientInstance: collectionManager,
        colorScheme: colorMode,
        searchParams: {
            where: formatSearchParams('current', collectionManager)
        }
    }));
}
function OramaSearchWithDocs({ pluginId }) {
    var _a;
    const colorMode = getColorMode();
    const { searchBoxConfig, searchBtnConfig } = useOrama();
    const collectionManager = (_a = searchBoxConfig.basic) === null || _a === void 0 ? void 0 : _a.collectionManager;
    const versions = (0,lib_client/* .useVersions */.jh)(pluginId);
    const activeVersion = (0,lib_client/* .useActiveVersion */.ir)(pluginId);
    const preferredVersion = getPreferredVersion(searchBoxConfig.basic.clientInstance);
    const currentVersion = activeVersion || preferredVersion || versions[0];
    const searchParams = {
        ...currentVersion && {
            ...formatSearchParams(currentVersion, collectionManager)
        }
    };
    return /*#__PURE__*/ react.createElement(react.Fragment, null, /*#__PURE__*/ react.createElement(OramaSearchButton, {
        colorScheme: colorMode,
        className: "DocSearch-Button",
        ...searchBtnConfig
    }, (searchBtnConfig === null || searchBtnConfig === void 0 ? void 0 : searchBtnConfig.text) || 'Search'), /*#__PURE__*/ react.createElement(OramaSearchBox, {
        ...collectionManager ? {} : searchBoxConfig.basic,
        ...searchBoxConfig.custom,
        oramaCoreClientInstance: collectionManager,
        colorScheme: colorMode,
        searchParams: {
            where: searchParams
        }
    }));
}
function OramaSearchWrapper() {
    const { pathname } = (0,react_router/* .useLocation */.zy)();
    const { docsInstances } = (0,useGlobalData/* .usePluginData */.P_)('@orama/plugin-docusaurus-v3');
    let pluginId = undefined;
    if (docsInstances) {
        pluginId = docsInstances.find((id)=>pathname.includes(id)) || (docsInstances === null || docsInstances === void 0 ? void 0 : docsInstances[0]);
    }
    return /*#__PURE__*/ react.createElement(BrowserOnly/* ["default"] */.A, {
        fallback: /*#__PURE__*/ react.createElement("div", null, "Loading Search...")
    }, ()=>{
        if (pluginId) {
            return /*#__PURE__*/ react.createElement(OramaSearchWithDocs, {
                pluginId: pluginId
            });
        } else {
            return /*#__PURE__*/ react.createElement(OramaSearchNoDocs, null);
        }
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/Search/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const Search_styles_module = ({"navbarSearchContainer":"navbarSearchContainer_Bca1"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/Search/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



function NavbarSearch({ children, className }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
        className: (0,clsx/* ["default"] */.A)(className, Search_styles_module.navbarSearchContainer),
        children: children
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/SearchNavbarItem.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



function SearchNavbarItem({ mobile, className }) {
    if (mobile) {
        return null;
    }
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarSearch, {
        className: className,
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(OramaSearchWrapper, {})
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/HtmlNavbarItem.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


function HtmlNavbarItem({ value, className, mobile = false, isDropdownItem = false }) {
    const Comp = isDropdownItem ? 'li' : 'div';
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(Comp, {
        className: (0,clsx/* ["default"] */.A)({
            navbar__item: !mobile && !isDropdownItem,
            'menu__list-item': mobile
        }, className),
        dangerouslySetInnerHTML: {
            __html: value
        }
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/plugin-content-docs/lib/client/docsUtils.js
var docsUtils = __webpack_require__(88260);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/DocNavbarItem.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



function DocNavbarItem({ docId, label: staticLabel, docsPluginId, ...props }) {
    const { activeDoc } = (0,lib_client/* .useActiveDocContext */.zK)(docsPluginId);
    const doc = (0,docsUtils/* .useLayoutDoc */.QB)(docId, docsPluginId);
    const pageActive = activeDoc?.path === doc?.path;
    // Draft and unlisted items are not displayed in the navbar.
    if (doc === null || doc.unlisted && !pageActive) {
        return null;
    }
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(DefaultNavbarItem, {
        exact: true,
        ...props,
        isActive: ()=>pageActive || !!activeDoc?.sidebar && activeDoc.sidebar === doc.sidebar,
        label: staticLabel ?? doc.id,
        to: doc.path
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/DocSidebarNavbarItem.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



function DocSidebarNavbarItem({ sidebarId, label, docsPluginId, ...props }) {
    const { activeDoc } = (0,lib_client/* .useActiveDocContext */.zK)(docsPluginId);
    const sidebarLink = (0,docsUtils/* .useLayoutDocsSidebar */.fW)(sidebarId, docsPluginId).link;
    if (!sidebarLink) {
        throw new Error(`DocSidebarNavbarItem: Sidebar with ID "${sidebarId}" doesn't have anything to be linked to.`);
    }
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(DefaultNavbarItem, {
        exact: true,
        ...props,
        isActive: ()=>activeDoc?.sidebar === sidebarId,
        label: label ?? sidebarLink.label,
        to: sidebarLink.path
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/DocsVersionNavbarItem.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



const getVersionMainDoc = (version)=>version.docs.find((doc)=>doc.id === version.mainDocId);
function DocsVersionNavbarItem({ label: staticLabel, to: staticTo, docsPluginId, ...props }) {
    const version = (0,docsUtils/* .useDocsVersionCandidates */.Vd)(docsPluginId)[0];
    const label = staticLabel ?? version.label;
    const path = staticTo ?? getVersionMainDoc(version).path;
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(DefaultNavbarItem, {
        ...props,
        label: label,
        to: path
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/plugin-content-docs/lib/client/docsPreferredVersion.js
var docsPreferredVersion = __webpack_require__(42086);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/DocsVersionDropdownNavbarItem.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 






function getVersionItems(versions, configs) {
    if (configs) {
        // Collect all the versions we have
        const versionMap = new Map(versions.map((version)=>[
                version.name,
                version
            ]));
        const toVersionItem = (name, config)=>{
            const version = versionMap.get(name);
            if (!version) {
                throw new Error(`No docs version exist for name '${name}', please verify your 'docsVersionDropdown' navbar item versions config.
Available version names:\n- ${versions.map((v)=>`${v.name}`).join('\n- ')}`);
            }
            return {
                version,
                label: config?.label ?? version.label
            };
        };
        if (Array.isArray(configs)) {
            return configs.map((name)=>toVersionItem(name, undefined));
        } else {
            return Object.entries(configs).map(([name, config])=>toVersionItem(name, config));
        }
    } else {
        return versions.map((version)=>({
                version,
                label: version.label
            }));
    }
}
function useVersionItems({ docsPluginId, configs }) {
    const versions = (0,lib_client/* .useVersions */.jh)(docsPluginId);
    return getVersionItems(versions, configs);
}
function DocsVersionDropdownNavbarItem_getVersionMainDoc(version) {
    return version.docs.find((doc)=>doc.id === version.mainDocId);
}
function getVersionTargetDoc(version, activeDocContext) {
    // We try to link to the same doc, in another version
    // When not possible, fallback to the "main doc" of the version
    return activeDocContext.alternateDocVersions[version.name] ?? DocsVersionDropdownNavbarItem_getVersionMainDoc(version);
}
// The version item to use for the "dropdown button"
function useDisplayedVersionItem({ docsPluginId, versionItems }) {
    // The order of the candidates matters!
    const candidates = (0,docsUtils/* .useDocsVersionCandidates */.Vd)(docsPluginId);
    const candidateItems = candidates.map((candidate)=>versionItems.find((vi)=>vi.version === candidate)).filter((vi)=>vi !== undefined);
    return candidateItems[0] ?? versionItems[0];
}
function DocsVersionDropdownNavbarItem({ mobile, docsPluginId, dropdownActiveClassDisabled, dropdownItemsBefore, dropdownItemsAfter, versions: configs, ...props }) {
    const search = (0,historyUtils/* .useHistorySelector */.Hl)((history)=>history.location.search);
    const hash = (0,historyUtils/* .useHistorySelector */.Hl)((history)=>history.location.hash);
    const activeDocContext = (0,lib_client/* .useActiveDocContext */.zK)(docsPluginId);
    const { savePreferredVersionName } = (0,docsPreferredVersion/* .useDocsPreferredVersion */.g1)(docsPluginId);
    const versionItems = useVersionItems({
        docsPluginId,
        configs
    });
    const displayedVersionItem = useDisplayedVersionItem({
        docsPluginId,
        versionItems
    });
    function versionItemToLink({ version, label }) {
        const targetDoc = getVersionTargetDoc(version, activeDocContext);
        return {
            label,
            // preserve ?search#hash suffix on version switches
            to: `${targetDoc.path}${search}${hash}`,
            isActive: ()=>version === activeDocContext.activeVersion,
            onClick: ()=>savePreferredVersionName(version.name)
        };
    }
    const items = [
        ...dropdownItemsBefore,
        ...versionItems.map(versionItemToLink),
        ...dropdownItemsAfter
    ];
    // Mobile dropdown is handled a bit differently
    const dropdownLabel = mobile && items.length > 1 ? (0,Translate/* .translate */.T)({
        id: 'theme.navbar.mobileVersionsDropdown.label',
        message: 'Versions',
        description: 'The label for the navbar versions dropdown on mobile view'
    }) : displayedVersionItem.label;
    const dropdownTo = mobile && items.length > 1 ? undefined : getVersionTargetDoc(displayedVersionItem.version, activeDocContext).path;
    // We don't want to render a version dropdown with 0 or 1 item. If we build
    // the site with a single docs version (onlyIncludeVersions: ['1.0.0']),
    // We'd rather render a button instead of a dropdown
    if (items.length <= 1) {
        return /*#__PURE__*/ (0,jsx_runtime.jsx)(DefaultNavbarItem, {
            ...props,
            mobile: mobile,
            label: dropdownLabel,
            to: dropdownTo,
            isActive: dropdownActiveClassDisabled ? ()=>false : undefined
        });
    }
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(DropdownNavbarItem, {
        ...props,
        mobile: mobile,
        label: dropdownLabel,
        to: dropdownTo,
        items: items,
        isActive: dropdownActiveClassDisabled ? ()=>false : undefined
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/ComponentTypes.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 








const ComponentTypes = {
    default: DefaultNavbarItem,
    localeDropdown: LocaleDropdownNavbarItem,
    search: SearchNavbarItem,
    dropdown: DropdownNavbarItem,
    html: HtmlNavbarItem,
    doc: DocNavbarItem,
    docSidebar: DocSidebarNavbarItem,
    docsVersion: DocsVersionNavbarItem,
    docsVersionDropdown: DocsVersionDropdownNavbarItem
};
/* export default */ const NavbarItem_ComponentTypes = (ComponentTypes);

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


function normalizeComponentType(type, props) {
    // Backward compatibility: navbar item with no type set
    // but containing dropdown items should use the type "dropdown"
    if (!type || type === 'default') {
        return 'items' in props ? 'dropdown' : 'default';
    }
    return type;
}
function NavbarItem({ type, ...props }) {
    const componentType = normalizeComponentType(type, props);
    const NavbarItemComponent = NavbarItem_ComponentTypes[componentType];
    if (!NavbarItemComponent) {
        throw new Error(`No NavbarItem component found for type "${type}".`);
    }
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarItemComponent, {
        ...props
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/MobileSidebar/PrimaryMenu/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 





function useNavbarItems() {
    // TODO temporary casting until ThemeConfig type is improved
    return (0,useThemeConfig/* .useThemeConfig */.p)().navbar.items;
}
// The primary menu displays the navbar items
function NavbarMobilePrimaryMenu() {
    const mobileSidebar = (0,navbarMobileSidebar/* .useNavbarMobileSidebar */.M)();
    // TODO how can the order be defined for mobile?
    // Should we allow providing a different list of items?
    const items = useNavbarItems();
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("ul", {
        className: "menu__list",
        children: items.map((item, i)=>/*#__PURE__*/ (0,react.createElement)(NavbarItem, {
                mobile: true,
                ...item,
                onClick: ()=>mobileSidebar.toggle(),
                key: i
            }))
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/MobileSidebar/SecondaryMenu/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




function SecondaryMenuBackButton(props) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("button", {
        ...props,
        type: "button",
        className: "clean-btn navbar-sidebar__back",
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(Translate/* ["default"] */.A, {
            id: "theme.navbar.mobileSidebarSecondaryMenu.backButtonLabel",
            description: "The label of the back button to return to main menu, inside the mobile navbar sidebar secondary menu (notably used to display the docs sidebar)",
            children: "← Back to main menu"
        })
    });
}
// The secondary menu slides from the right and shows contextual information
// such as the docs sidebar
function NavbarMobileSidebarSecondaryMenu() {
    const isPrimaryMenuEmpty = (0,useThemeConfig/* .useThemeConfig */.p)().navbar.items.length === 0;
    const secondaryMenu = useNavbarSecondaryMenu();
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
        children: [
            !isPrimaryMenuEmpty && /*#__PURE__*/ (0,jsx_runtime.jsx)(SecondaryMenuBackButton, {
                onClick: ()=>secondaryMenu.hide()
            }),
            secondaryMenu.content
        ]
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/MobileSidebar/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 






function NavbarMobileSidebar() {
    const mobileSidebar = (0,navbarMobileSidebar/* .useNavbarMobileSidebar */.M)();
    useLockBodyScroll(mobileSidebar.shown);
    if (!mobileSidebar.shouldRender) {
        return null;
    }
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarMobileSidebarLayout, {
        header: /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarMobileSidebarHeader, {}),
        primaryMenu: /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarMobilePrimaryMenu, {}),
        secondaryMenu: /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarMobileSidebarSecondaryMenu, {})
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/Layout/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const Layout_styles_module = ({"navbarHideable":"navbarHideable_m1mJ","navbarHidden":"navbarHidden_jGov"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/Layout/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 







function NavbarBackdrop(props) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
        role: "presentation",
        ...props,
        className: (0,clsx/* ["default"] */.A)('navbar-sidebar__backdrop', props.className)
    });
}
function NavbarLayout({ children }) {
    const { navbar: { hideOnScroll, style } } = (0,useThemeConfig/* .useThemeConfig */.p)();
    const mobileSidebar = (0,navbarMobileSidebar/* .useNavbarMobileSidebar */.M)();
    const { navbarRef, isNavbarVisible } = useHideableNavbar(hideOnScroll);
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)("nav", {
        ref: navbarRef,
        "aria-label": (0,Translate/* .translate */.T)({
            id: 'theme.NavBar.navAriaLabel',
            message: 'Main',
            description: 'The ARIA label for the main navigation'
        }),
        className: (0,clsx/* ["default"] */.A)(ThemeClassNames/* .ThemeClassNames.layout.navbar.container */.G.layout.navbar.container, 'navbar', 'navbar--fixed-top', hideOnScroll && [
            Layout_styles_module.navbarHideable,
            !isNavbarVisible && Layout_styles_module.navbarHidden
        ], {
            'navbar--dark': style === 'dark',
            'navbar--primary': style === 'primary',
            'navbar-sidebar--show': mobileSidebar.shown
        }),
        children: [
            children,
            /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarBackdrop, {
                onClick: mobileSidebar.toggle
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarMobileSidebar, {})
        ]
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/utils-common/lib/index.js
var lib = __webpack_require__(5248);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/errorBoundaryUtils.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const errorBoundaryUtils_module = ({"errorBoundaryError":"errorBoundaryError_a6uf","errorBoundaryFallback":"errorBoundaryFallback_VBag"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/errorBoundaryUtils.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




function ErrorBoundaryTryAgainButton(props) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("button", {
        type: "button",
        ...props,
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(Translate/* ["default"] */.A, {
            id: "theme.ErrorPageContent.tryAgain",
            description: "The label of the button to try again rendering when the React error boundary captures an error",
            children: "Try again"
        })
    });
}
// A very simple reusable ErrorBoundary fallback component
function ErrorBoundaryErrorMessageFallback({ error, tryAgain }) {
    return /*#__PURE__*/ _jsxs("div", {
        className: styles.errorBoundaryFallback,
        children: [
            /*#__PURE__*/ _jsx("p", {
                children: error.message
            }),
            /*#__PURE__*/ _jsx(ErrorBoundaryTryAgainButton, {
                onClick: tryAgain
            })
        ]
    });
}
function ErrorBoundaryError({ error }) {
    const causalChain = (0,lib.getErrorCausalChain)(error);
    const fullMessage = causalChain.map((e)=>e.message).join('\n\nCause:\n');
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("p", {
        className: errorBoundaryUtils_module.errorBoundaryError,
        children: fullMessage
    });
}
/**
 * This component is useful to wrap a low-level error into a more meaningful
 * error with extra context, using the ES error-cause feature.
 *
 * <ErrorCauseBoundary
 *   onError={(error) => new Error("extra context message",{cause: error})}
 * >
 *   <RiskyComponent>
 * </ErrorCauseBoundary>
 */ class ErrorCauseBoundary extends react.Component {
    componentDidCatch(error, errorInfo) {
        throw this.props.onError(error, errorInfo);
    }
    render() {
        return this.props.children;
    }
} //# sourceMappingURL=errorBoundaryUtils.js.map

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/navbarUtils.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




const DefaultNavItemPosition = 'right';
/**
 * Split links by left/right. If position is unspecified, fallback to right.
 */ function splitNavbarItems(items) {
    function isLeft(item) {
        return (item.position ?? DefaultNavItemPosition) === 'left';
    }
    const leftItems = items.filter(isLeft);
    const rightItems = items.filter((item)=>!isLeft(item));
    return [
        leftItems,
        rightItems
    ];
}
/**
 * Composes multiple navbar state providers that are mutually dependent and
 * hence can't be re-ordered.
 */ function NavbarProvider({ children }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(navbarSecondaryMenu_content/* .NavbarSecondaryMenuContentProvider */.y_, {
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(navbarMobileSidebar/* .NavbarMobileSidebarProvider */.e, {
            children: /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarSecondaryMenuDisplayProvider, {
                children: children
            })
        })
    });
} //# sourceMappingURL=navbarUtils.js.map

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Icon/Menu/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

function IconMenu({ width = 30, height = 30, className, ...restProps }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("svg", {
        className: className,
        width: width,
        height: height,
        viewBox: "0 0 30 30",
        "aria-hidden": "true",
        ...restProps,
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)("path", {
            stroke: "currentColor",
            strokeLinecap: "round",
            strokeMiterlimit: "10",
            strokeWidth: "2",
            d: "M4 7h22M4 15h22M4 23h22"
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/MobileSidebar/Toggle/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




function MobileSidebarToggle() {
    const { toggle, shown } = (0,navbarMobileSidebar/* .useNavbarMobileSidebar */.M)();
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("button", {
        onClick: toggle,
        "aria-label": (0,Translate/* .translate */.T)({
            id: 'theme.docs.sidebar.toggleSidebarButtonAriaLabel',
            message: 'Toggle navigation bar',
            description: 'The ARIA label for hamburger menu button of mobile navigation'
        }),
        "aria-expanded": shown,
        className: "navbar__toggle clean-btn",
        type: "button",
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(IconMenu, {})
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/Content/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const Navbar_Content_styles_module = ({"colorModeToggle":"colorModeToggle_DEke"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/Content/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 











function Content_useNavbarItems() {
    // TODO temporary casting until ThemeConfig type is improved
    return (0,useThemeConfig/* .useThemeConfig */.p)().navbar.items;
}
function NavbarItems({ items }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
        children: items.map((item, i)=>/*#__PURE__*/ (0,jsx_runtime.jsx)(ErrorCauseBoundary, {
                onError: (error)=>new Error(`A theme navbar item failed to render.
Please double-check the following navbar item (themeConfig.navbar.items) of your Docusaurus config:
${JSON.stringify(item, null, 2)}`, {
                        cause: error
                    }),
                children: /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarItem, {
                    ...item
                })
            }, i))
    });
}
function NavbarContentLayout({ left, right }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
        className: "navbar__inner",
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
                className: (0,clsx/* ["default"] */.A)(ThemeClassNames/* .ThemeClassNames.layout.navbar.containerLeft */.G.layout.navbar.containerLeft, 'navbar__items'),
                children: left
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
                className: (0,clsx/* ["default"] */.A)(ThemeClassNames/* .ThemeClassNames.layout.navbar.containerRight */.G.layout.navbar.containerRight, 'navbar__items navbar__items--right'),
                children: right
            })
        ]
    });
}
function NavbarContent() {
    const mobileSidebar = (0,navbarMobileSidebar/* .useNavbarMobileSidebar */.M)();
    const items = Content_useNavbarItems();
    const [leftItems, rightItems] = splitNavbarItems(items);
    const searchBarItem = items.find((item)=>item.type === 'search');
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarContentLayout, {
        left: // TODO stop hardcoding items?
        /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
            children: [
                !mobileSidebar.disabled && /*#__PURE__*/ (0,jsx_runtime.jsx)(MobileSidebarToggle, {}),
                /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarLogo, {}),
                /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarItems, {
                    items: leftItems
                })
            ]
        }),
        right: // TODO stop hardcoding items?
        // Ask the user to add the respective navbar items => more flexible
        /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
            children: [
                /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarItems, {
                    items: rightItems
                }),
                /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarColorModeToggle, {
                    className: Navbar_Content_styles_module.colorModeToggle
                }),
                !searchBarItem && /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarSearch, {
                    children: /*#__PURE__*/ (0,jsx_runtime.jsx)(OramaSearchWrapper, {})
                })
            ]
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



function Navbar() {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarLayout, {
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarContent, {})
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/footerUtils.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ /**
 * A rough duck-typing about whether the `footer.links` is intended to be multi-
 * column.
 */ function isMultiColumnFooterLinks(links) {
    return 'title' in links[0];
} //# sourceMappingURL=footerUtils.js.map

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Footer/LinkItem/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 






function FooterLinkItem({ item }) {
    const { to, href, label, prependBaseUrlToHref, className, ...props } = item;
    const toUrl = (0,useBaseUrl/* ["default"] */.Ay)(to);
    const normalizedHref = (0,useBaseUrl/* ["default"] */.Ay)(href, {
        forcePrependBaseUrl: true
    });
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)(Link/* ["default"] */.A, {
        className: (0,clsx/* ["default"] */.A)('footer__link-item', className),
        ...href ? {
            href: prependBaseUrlToHref ? normalizedHref : href
        } : {
            to: toUrl
        },
        ...props,
        children: [
            label,
            href && !(0,isInternalUrl/* ["default"] */.A)(href) && /*#__PURE__*/ (0,jsx_runtime.jsx)(ExternalLink/* ["default"] */.A, {})
        ]
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Footer/Links/MultiColumn/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




function ColumnLinkItem({ item }) {
    return item.html ? /*#__PURE__*/ (0,jsx_runtime.jsx)("li", {
        className: (0,clsx/* ["default"] */.A)('footer__item', item.className),
        // Developer provided the HTML, so assume it's safe.
        // eslint-disable-next-line react/no-danger
        dangerouslySetInnerHTML: {
            __html: item.html
        }
    }) : /*#__PURE__*/ (0,jsx_runtime.jsx)("li", {
        className: "footer__item",
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(FooterLinkItem, {
            item: item
        })
    }, item.href ?? item.to);
}
function Column({ column }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
        className: (0,clsx/* ["default"] */.A)(ThemeClassNames/* .ThemeClassNames.layout.footer.column */.G.layout.footer.column, 'col footer__col', column.className),
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
                className: "footer__title",
                children: column.title
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)("ul", {
                className: "footer__items clean-list",
                children: column.items.map((item, i)=>/*#__PURE__*/ (0,jsx_runtime.jsx)(ColumnLinkItem, {
                        item: item
                    }, i))
            })
        ]
    });
}
function FooterLinksMultiColumn({ columns }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
        className: "row footer__links",
        children: columns.map((column, i)=>/*#__PURE__*/ (0,jsx_runtime.jsx)(Column, {
                column: column
            }, i))
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Footer/Links/Simple/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



function Separator() {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("span", {
        className: "footer__link-separator",
        children: "\xb7"
    });
}
function SimpleLinkItem({ item }) {
    return item.html ? /*#__PURE__*/ (0,jsx_runtime.jsx)("span", {
        className: (0,clsx/* ["default"] */.A)('footer__link-item', item.className),
        // Developer provided the HTML, so assume it's safe.
        // eslint-disable-next-line react/no-danger
        dangerouslySetInnerHTML: {
            __html: item.html
        }
    }) : /*#__PURE__*/ (0,jsx_runtime.jsx)(FooterLinkItem, {
        item: item
    });
}
function FooterLinksSimple({ links }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
        className: "footer__links text--center",
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
            className: "footer__links",
            children: links.map((item, i)=>/*#__PURE__*/ (0,jsx_runtime.jsxs)(react.Fragment, {
                    children: [
                        /*#__PURE__*/ (0,jsx_runtime.jsx)(SimpleLinkItem, {
                            item: item
                        }),
                        links.length !== i + 1 && /*#__PURE__*/ (0,jsx_runtime.jsx)(Separator, {})
                    ]
                }, i))
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Footer/Links/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




function FooterLinks({ links }) {
    return isMultiColumnFooterLinks(links) ? /*#__PURE__*/ (0,jsx_runtime.jsx)(FooterLinksMultiColumn, {
        columns: links
    }) : /*#__PURE__*/ (0,jsx_runtime.jsx)(FooterLinksSimple, {
        links: links
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/ThemedImage/index.js + 2 modules
var ThemedImage = __webpack_require__(38586);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Footer/Logo/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const Logo_styles_module = ({"footerLogoLink":"footerLogoLink_BH7S"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Footer/Logo/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 






function LogoImage({ logo }) {
    const { withBaseUrl } = (0,useBaseUrl/* .useBaseUrlUtils */.hH)();
    const sources = {
        light: withBaseUrl(logo.src),
        dark: withBaseUrl(logo.srcDark ?? logo.src)
    };
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(ThemedImage/* ["default"] */.A, {
        className: (0,clsx/* ["default"] */.A)('footer__logo', logo.className),
        alt: logo.alt,
        sources: sources,
        width: logo.width,
        height: logo.height,
        style: logo.style
    });
}
function FooterLogo({ logo }) {
    return logo.href ? /*#__PURE__*/ (0,jsx_runtime.jsx)(Link/* ["default"] */.A, {
        href: logo.href,
        className: Logo_styles_module.footerLogoLink,
        target: logo.target,
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(LogoImage, {
            logo: logo
        })
    }) : /*#__PURE__*/ (0,jsx_runtime.jsx)(LogoImage, {
        logo: logo
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Footer/Copyright/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

function FooterCopyright({ copyright }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
        className: "footer__copyright",
        // Developer provided the HTML, so assume it's safe.
        // eslint-disable-next-line react/no-danger
        dangerouslySetInnerHTML: {
            __html: copyright
        }
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Footer/Layout/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



function FooterLayout({ style, links, logo, copyright }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("footer", {
        className: (0,clsx/* ["default"] */.A)(ThemeClassNames/* .ThemeClassNames.layout.footer.container */.G.layout.footer.container, 'footer', {
            'footer--dark': style === 'dark'
        }),
        children: /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
            className: "container container-fluid",
            children: [
                links,
                (logo || copyright) && /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
                    className: "footer__bottom text--center",
                    children: [
                        logo && /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
                            className: "margin-bottom--sm",
                            children: logo
                        }),
                        copyright
                    ]
                })
            ]
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Footer/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 






function Footer() {
    const { footer } = (0,useThemeConfig/* .useThemeConfig */.p)();
    if (!footer) {
        return null;
    }
    const { copyright, links, logo, style } = footer;
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(FooterLayout, {
        style: style,
        links: links && links.length > 0 && /*#__PURE__*/ (0,jsx_runtime.jsx)(FooterLinks, {
            links: links
        }),
        logo: logo && /*#__PURE__*/ (0,jsx_runtime.jsx)(FooterLogo, {
            logo: logo
        }),
        copyright: copyright && /*#__PURE__*/ (0,jsx_runtime.jsx)(FooterCopyright, {
            copyright: copyright
        })
    });
}
/* export default */ const theme_Footer = (/*#__PURE__*/react.memo(Footer));

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Layout/Provider/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




const Provider = (0,reactUtils/* .composeProviders */.fM)([
    contexts_colorMode/* .ColorModeProvider */.a,
    contexts_announcementBar/* .AnnouncementBarProvider */.o,
    scrollUtils/* .ScrollControllerProvider */.Tv,
    docsPreferredVersion/* .DocsPreferredVersionContextProvider */.VQ,
    metadataUtils/* .PluginHtmlClassNameProvider */.Jx,
    NavbarProvider
]);
function LayoutProvider({ children }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(Provider, {
        children: children
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Heading/index.js
var Heading = __webpack_require__(72072);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/ErrorPageContent.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




function ErrorPageContent({ error, tryAgain }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("main", {
        className: "container margin-vert--xl",
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
            className: "row",
            children: /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
                className: "col col--6 col--offset-3",
                children: [
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(Heading/* ["default"] */.A, {
                        as: "h1",
                        className: "hero__title",
                        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(Translate/* ["default"] */.A, {
                            id: "theme.ErrorPageContent.title",
                            description: "The title of the fallback page when the page crashed",
                            children: "This page crashed."
                        })
                    }),
                    /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
                        className: "margin-vert--lg",
                        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(ErrorBoundaryTryAgainButton, {
                            onClick: tryAgain,
                            className: "button button--primary shadow--lw"
                        })
                    }),
                    /*#__PURE__*/ (0,jsx_runtime.jsx)("hr", {}),
                    /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
                        className: "margin-vert--md",
                        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(ErrorBoundaryError, {
                            error: error
                        })
                    })
                ]
            })
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Layout/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const theme_Layout_styles_module = ({"mainWrapper":"mainWrapper_z2l0"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Layout/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 












function Layout(props) {
    const { children, noFooter, wrapperClassName, // Not really layout-related, but kept for convenience/retro-compatibility
    title, description } = props;
    (0,useKeyboardNavigation/* .useKeyboardNavigation */.J)();
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)(LayoutProvider, {
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsx)(metadataUtils/* .PageMetadata */.be, {
                title: title,
                description: description
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(SkipToContent, {}),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(AnnouncementBar, {}),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(Navbar, {}),
            /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
                id: SkipToContentFallbackId,
                className: (0,clsx/* ["default"] */.A)(ThemeClassNames/* .ThemeClassNames.layout.main.container */.G.layout.main.container, ThemeClassNames/* .ThemeClassNames.wrapper.main */.G.wrapper.main, theme_Layout_styles_module.mainWrapper, wrapperClassName),
                children: /*#__PURE__*/ (0,jsx_runtime.jsx)(ErrorBoundary/* ["default"] */.A, {
                    fallback: (params)=>/*#__PURE__*/ (0,jsx_runtime.jsx)(ErrorPageContent, {
                            ...params
                        }),
                    children: children
                })
            }),
            !noFooter && /*#__PURE__*/ (0,jsx_runtime.jsx)(theme_Footer, {})
        ]
    });
}


}),
85153: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (Logo)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _docusaurus_Link__rspack_import_2 = __webpack_require__(95310);
/* import */ var _docusaurus_useBaseUrl__rspack_import_3 = __webpack_require__(66497);
/* import */ var _docusaurus_useDocusaurusContext__rspack_import_4 = __webpack_require__(10898);
/* import */ var _docusaurus_theme_common__rspack_import_6 = __webpack_require__(61022);
/* import */ var _theme_ThemedImage__rspack_import_5 = __webpack_require__(38586);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 






function LogoThemedImage({ logo, alt, imageClassName }) {
    const sources = {
        light: (0,_docusaurus_useBaseUrl__rspack_import_3/* ["default"] */.Ay)(logo.src),
        dark: (0,_docusaurus_useBaseUrl__rspack_import_3/* ["default"] */.Ay)(logo.srcDark || logo.src)
    };
    const themedImage = /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(_theme_ThemedImage__rspack_import_5/* ["default"] */.A, {
        className: logo.className,
        sources: sources,
        height: logo.height,
        width: logo.width,
        alt: alt,
        style: logo.style
    });
    // Is this extra div really necessary?
    // introduced in https://github.com/facebook/docusaurus/pull/5666
    return imageClassName ? /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("div", {
        className: imageClassName,
        children: themedImage
    }) : themedImage;
}
function Logo(props) {
    const { siteConfig: { title } } = (0,_docusaurus_useDocusaurusContext__rspack_import_4/* ["default"] */.A)();
    const { navbar: { title: navbarTitle, logo } } = (0,_docusaurus_theme_common__rspack_import_6/* .useThemeConfig */.p)();
    const { imageClassName, titleClassName, ...propsRest } = props;
    const logoLink = (0,_docusaurus_useBaseUrl__rspack_import_3/* ["default"] */.Ay)(logo?.href || '/');
    // If visible title is shown, fallback alt text should be
    // an empty string to mark the logo as decorative.
    const fallbackAlt = navbarTitle ? '' : title;
    // Use logo alt text if provided (including empty string),
    // and provide a sensible fallback otherwise.
    const alt = logo?.alt ?? fallbackAlt;
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsxs)(_docusaurus_Link__rspack_import_2/* ["default"] */.A, {
        to: logoLink,
        ...propsRest,
        ...logo?.target && {
            target: logo.target
        },
        children: [
            logo && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(LogoThemedImage, {
                logo: logo,
                alt: alt,
                imageClassName: imageClassName
            }),
            navbarTitle != null && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("b", {
                className: titleClassName,
                children: navbarTitle
            })
        ]
    });
}


}),
54175: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (SearchMetadata)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _docusaurus_Head__rspack_import_2 = __webpack_require__(53572);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


// Note: we bias toward using Algolia metadata on purpose
// Not doing so leads to confusion in the community,
// as it requires to first crawl the site with the Algolia plugin enabled first
// - https://github.com/facebook/docusaurus/issues/6693
// - https://github.com/facebook/docusaurus/issues/4555
function SearchMetadata({ locale, version, tag }) {
    // Seems safe to consider here the locale is the language, as the existing
    // docsearch:language filter is afaik a regular string-based filter
    const language = locale;
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsxs)(_docusaurus_Head__rspack_import_2/* ["default"] */.A, {
        children: [
            locale && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("meta", {
                name: "docusaurus_locale",
                content: locale
            }),
            version && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("meta", {
                name: "docusaurus_version",
                content: version
            }),
            tag && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("meta", {
                name: "docusaurus_tag",
                content: tag
            }),
            language && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("meta", {
                name: "docsearch:language",
                content: language
            }),
            version && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("meta", {
                name: "docsearch:version",
                content: version
            }),
            tag && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("meta", {
                name: "docsearch:docusaurus_tag",
                content: tag
            })
        ]
    });
}


}),
38586: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ ThemedImage)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(74848);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/clsx/dist/clsx.mjs
var clsx = __webpack_require__(34164);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/useIsBrowser.js
var useIsBrowser = __webpack_require__(19863);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/contexts/colorMode.js
var contexts_colorMode = __webpack_require__(83941);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/components/ThemedComponent/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const styles_module = ({"themedComponent":"themedComponent_mlkZ","themedComponent--light":"themedComponent--light_NVdE","themedComponent--dark":"themedComponent--dark_xIcU"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/components/ThemedComponent/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 





const AllThemes = (/* unused pure expression or super */ null && ([
    'light',
    'dark'
]));
/**
 * Generic component to render anything themed in light/dark
 * Note: it's preferable to use CSS for theming because this component
 * will need to render all the variants during SSR to avoid a theme flash.
 *
 * Use this only when CSS customizations are not convenient or impossible.
 * For example, rendering themed images or SVGs...
 *
 * @param className applied to all the variants
 * @param children function to render a theme variant
 * @constructor
 */ function ThemedComponent({ className, children }) {
    const isBrowser = (0,useIsBrowser/* ["default"] */.A)();
    const { colorMode } = (0,contexts_colorMode/* .useColorMode */.G)();
    function getThemesToRender() {
        if (isBrowser) {
            return colorMode === 'dark' ? [
                'dark'
            ] : [
                'light'
            ];
        }
        // We need to render both components on the server / hydration to avoid:
        // - a flash of wrong theme before hydration
        // - React hydration mismatches
        // See https://github.com/facebook/docusaurus/pull/3730
        return [
            'light',
            'dark'
        ];
    }
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
        children: getThemesToRender().map((theme)=>{
            const themedElement = children({
                theme,
                className: (0,clsx/* ["default"] */.A)(className, styles_module.themedComponent, styles_module[`themedComponent--${theme}`])
            });
            return /*#__PURE__*/ (0,jsx_runtime.jsx)(react.Fragment, {
                children: themedElement
            }, theme);
        })
    });
} //# sourceMappingURL=index.js.map

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/ThemedImage/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


function ThemedImage(props) {
    const { sources, className: parentClassName, alt, ...propsRest } = props;
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(ThemedComponent, {
        className: parentClassName,
        children: ({ theme, className })=>/*#__PURE__*/ (0,jsx_runtime.jsx)("img", {
                src: sources[theme],
                alt: alt,
                className: className,
                ...propsRest
            })
    });
}


}),
39510: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  N: () => (Collapsible),
  u: () => (useCollapsible)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _docusaurus_useIsomorphicLayoutEffect__rspack_import_2 = __webpack_require__(99989);
/* import */ var _utils_accessibilityUtils__rspack_import_3 = __webpack_require__(269);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



const DefaultAnimationEasing = 'ease-in-out';
/**
 * This hook is a very thin wrapper around a `useState`.
 */ function useCollapsible({ initialState }) {
    const [collapsed, setCollapsed] = (0,react__rspack_import_1.useState)(initialState ?? false);
    const toggleCollapsed = (0,react__rspack_import_1.useCallback)(()=>{
        setCollapsed((expanded)=>!expanded);
    }, []);
    return {
        collapsed,
        setCollapsed,
        toggleCollapsed
    };
}
const CollapsedStyles = {
    display: 'none',
    overflow: 'hidden',
    height: '0px'
};
const ExpandedStyles = {
    display: 'block',
    overflow: 'visible',
    height: 'auto'
};
function applyCollapsedStyle(el, collapsed) {
    const collapsedStyles = collapsed ? CollapsedStyles : ExpandedStyles;
    el.style.display = collapsedStyles.display;
    el.style.overflow = collapsedStyles.overflow;
    el.style.height = collapsedStyles.height;
}
/*
Lex111: Dynamic transition duration is used in Material design, this technique
is good for a large number of items.
https://material.io/archive/guidelines/motion/duration-easing.html#duration-easing-dynamic-durations
https://github.com/mui-org/material-ui/blob/e724d98eba018e55e1a684236a2037e24bcf050c/packages/material-ui/src/styles/createTransitions.js#L40-L43
 */ function getAutoHeightDuration(height) {
    if ((0,_utils_accessibilityUtils__rspack_import_3/* .prefersReducedMotion */.O)()) {
        // Not using 0 because it prevents onTransitionEnd to fire and bubble up :/
        // See https://github.com/facebook/docusaurus/pull/8906
        return 1;
    }
    const constant = height / 36;
    return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
}
function useCollapseAnimation({ collapsibleRef, collapsed, animation }) {
    const mounted = (0,react__rspack_import_1.useRef)(false);
    (0,react__rspack_import_1.useEffect)(()=>{
        const el = collapsibleRef.current;
        function getTransitionStyles() {
            const height = el.scrollHeight;
            const duration = animation?.duration ?? getAutoHeightDuration(height);
            const easing = animation?.easing ?? DefaultAnimationEasing;
            return {
                transition: `height ${duration}ms ${easing}`,
                height: `${height}px`
            };
        }
        function applyTransitionStyles() {
            const transitionStyles = getTransitionStyles();
            el.style.transition = transitionStyles.transition;
            el.style.height = transitionStyles.height;
        }
        // On mount, we just apply styles, no animated transition
        if (!mounted.current) {
            applyCollapsedStyle(el, collapsed);
            mounted.current = true;
            return undefined;
        }
        // eslint-disable-next-line react-compiler/react-compiler
        el.style.willChange = 'height';
        function startAnimation() {
            const animationFrame = requestAnimationFrame(()=>{
                // When collapsing
                if (collapsed) {
                    applyTransitionStyles();
                    requestAnimationFrame(()=>{
                        el.style.height = CollapsedStyles.height;
                        el.style.overflow = CollapsedStyles.overflow;
                    });
                } else {
                    el.style.display = 'block';
                    requestAnimationFrame(()=>{
                        applyTransitionStyles();
                    });
                }
            });
            return ()=>cancelAnimationFrame(animationFrame);
        }
        return startAnimation();
    }, [
        collapsibleRef,
        collapsed,
        animation
    ]);
}
function CollapsibleBase({ as: As = 'div', collapsed, children, animation, onCollapseTransitionEnd, className }) {
    const collapsibleRef = (0,react__rspack_import_1.useRef)(null);
    useCollapseAnimation({
        collapsibleRef,
        collapsed,
        animation
    });
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(As, {
        // @ts-expect-error: the "too complicated type" is produced from
        // "CollapsibleElementType" being a huge union
        ref: collapsibleRef,
        onTransitionEnd: (e)=>{
            if (e.propertyName !== 'height') {
                return;
            }
            applyCollapsedStyle(collapsibleRef.current, collapsed);
            onCollapseTransitionEnd?.(collapsed);
        },
        className: className,
        children: children
    });
}
function CollapsibleLazy({ collapsed, ...props }) {
    const [mounted, setMounted] = (0,react__rspack_import_1.useState)(!collapsed);
    // Updated in effect so that first expansion transition can work
    const [lazyCollapsed, setLazyCollapsed] = (0,react__rspack_import_1.useState)(collapsed);
    (0,_docusaurus_useIsomorphicLayoutEffect__rspack_import_2/* ["default"] */.A)(()=>{
        if (!collapsed) {
            setMounted(true);
        }
    }, [
        collapsed
    ]);
    (0,_docusaurus_useIsomorphicLayoutEffect__rspack_import_2/* ["default"] */.A)(()=>{
        if (mounted) {
            setLazyCollapsed(collapsed);
        }
    }, [
        mounted,
        collapsed
    ]);
    return mounted ? /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(CollapsibleBase, {
        ...props,
        collapsed: lazyCollapsed
    }) : null;
}
/**
 * A headless component providing smooth and uniform collapsing behavior. The
 * component will be invisible (zero height) when collapsed. Doesn't provide
 * interactivity by itself: collapse state is toggled through props.
 */ function Collapsible({ lazy, ...props }) {
    const Comp = lazy ? CollapsibleLazy : CollapsibleBase;
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(Comp, {
        ...props
    });
} //# sourceMappingURL=index.js.map


}),
63337: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  M: () => (useAnnouncementBar),
  o: () => (AnnouncementBarProvider)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _docusaurus_useIsBrowser__rspack_import_2 = __webpack_require__(19863);
/* import */ var _utils_storageUtils__rspack_import_3 = __webpack_require__(41367);
/* import */ var _utils_reactUtils__rspack_import_5 = __webpack_require__(52260);
/* import */ var _utils_useThemeConfig__rspack_import_4 = __webpack_require__(61022);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 





// Keep these keys in sync with the inlined script
// See packages/docusaurus-theme-classic/src/inlineScripts.ts
const AnnouncementBarDismissStorage = (0,_utils_storageUtils__rspack_import_3/* .createStorageSlot */.Wf)('docusaurus.announcement.dismiss');
const IdStorage = (0,_utils_storageUtils__rspack_import_3/* .createStorageSlot */.Wf)('docusaurus.announcement.id');
const isDismissedInStorage = ()=>AnnouncementBarDismissStorage.get() === 'true';
const setDismissedInStorage = (bool)=>AnnouncementBarDismissStorage.set(String(bool));
const Context = /*#__PURE__*/ react__rspack_import_1.createContext(null);
function useContextValue() {
    const { announcementBar } = (0,_utils_useThemeConfig__rspack_import_4/* .useThemeConfig */.p)();
    const isBrowser = (0,_docusaurus_useIsBrowser__rspack_import_2/* ["default"] */.A)();
    const [isClosed, setClosed] = (0,react__rspack_import_1.useState)(()=>isBrowser ? isDismissedInStorage() : false);
    // Update state after hydration
    (0,react__rspack_import_1.useEffect)(()=>{
        setClosed(isDismissedInStorage());
    }, []);
    const handleClose = (0,react__rspack_import_1.useCallback)(()=>{
        setDismissedInStorage(true);
        setClosed(true);
    }, []);
    (0,react__rspack_import_1.useEffect)(()=>{
        if (!announcementBar) {
            return;
        }
        const { id } = announcementBar;
        let viewedId = IdStorage.get();
        // Retrocompatibility due to spelling mistake of default id
        // see https://github.com/facebook/docusaurus/issues/3338
        // cSpell:ignore annoucement
        if (viewedId === 'annoucement-bar') {
            viewedId = 'announcement-bar';
        }
        const isNewAnnouncement = id !== viewedId;
        IdStorage.set(id);
        if (isNewAnnouncement) {
            setDismissedInStorage(false);
        }
        if (isNewAnnouncement || !isDismissedInStorage()) {
            setClosed(false);
        }
    }, [
        announcementBar
    ]);
    return (0,react__rspack_import_1.useMemo)(()=>({
            isActive: !!announcementBar && !isClosed,
            close: handleClose
        }), [
        announcementBar,
        isClosed,
        handleClose
    ]);
}
function AnnouncementBarProvider({ children }) {
    const value = useContextValue();
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(Context.Provider, {
        value: value,
        children: children
    });
}
function useAnnouncementBar() {
    const api = (0,react__rspack_import_1.useContext)(Context);
    if (!api) {
        throw new _utils_reactUtils__rspack_import_5/* .ReactContextError */.dV('AnnouncementBarProvider');
    }
    return api;
} //# sourceMappingURL=announcementBar.js.map


}),
83941: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  G: () => (useColorMode),
  a: () => (ColorModeProvider)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _docusaurus_useIsBrowser__rspack_import_2 = __webpack_require__(19863);
/* import */ var _utils_reactUtils__rspack_import_5 = __webpack_require__(52260);
/* import */ var _utils_storageUtils__rspack_import_3 = __webpack_require__(41367);
/* import */ var _utils_useThemeConfig__rspack_import_4 = __webpack_require__(61022);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 





function getSystemColorMode() {
    return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
}
function subscribeToMedia(query, listener) {
    const mql = window.matchMedia(query);
    mql.addEventListener('change', listener);
    return ()=>mql.removeEventListener('change', listener);
}
function subscribeToSystemColorModeChange(onChange) {
    return subscribeToMedia('(prefers-color-scheme: dark)', ()=>onChange(getSystemColorMode()));
}
const Context = /*#__PURE__*/ react__rspack_import_1.createContext(undefined);
const ColorModeStorageKey = 'theme';
const ColorModeStorage = (0,_utils_storageUtils__rspack_import_3/* .createStorageSlot */.Wf)(ColorModeStorageKey);
// We use data-theme-choice="system", not an absent attribute
// This is easier to handle for users with CSS
const SystemAttribute = 'system';
// Ensure to always return a valid colorMode even if input is invalid
const coerceToColorMode = (colorMode)=>colorMode === 'dark' ? 'dark' : 'light';
const coerceToColorModeChoice = (colorMode)=>colorMode === null || colorMode === SystemAttribute ? null : coerceToColorMode(colorMode);
const ColorModeAttribute = {
    get: ()=>{
        return coerceToColorMode(document.documentElement.getAttribute('data-theme'));
    },
    set: (colorMode)=>{
        document.documentElement.setAttribute('data-theme', coerceToColorMode(colorMode));
    }
};
const ColorModeChoiceAttribute = {
    get: ()=>{
        return coerceToColorModeChoice(document.documentElement.getAttribute('data-theme-choice'));
    },
    set: (colorMode)=>{
        document.documentElement.setAttribute('data-theme-choice', coerceToColorModeChoice(colorMode) ?? SystemAttribute);
    }
};
const persistColorModeChoice = (newColorMode)=>{
    if (newColorMode === null) {
        ColorModeStorage.del();
    } else {
        ColorModeStorage.set(coerceToColorMode(newColorMode));
    }
};
// The color mode state is initialized in useEffect on purpose
// to avoid a React hydration mismatch errors
// The useColorMode() hook value lags behind on purpose
// This helps users avoid hydration mismatch errors in their code
// See also https://github.com/facebook/docusaurus/issues/7986
function useColorModeState() {
    const { colorMode: { defaultMode } } = (0,_utils_useThemeConfig__rspack_import_4/* .useThemeConfig */.p)();
    const isBrowser = (0,_docusaurus_useIsBrowser__rspack_import_2/* ["default"] */.A)();
    // Since the provider may unmount/remount on client navigation, we need to
    // reinitialize the state with the correct values to avoid visual glitches.
    // See also https://github.com/facebook/docusaurus/issues/11399#issuecomment-3279181314
    const [colorMode, setColorModeState] = (0,react__rspack_import_1.useState)(isBrowser ? ColorModeAttribute.get() : defaultMode);
    const [colorModeChoice, setColorModeChoiceState] = (0,react__rspack_import_1.useState)(isBrowser ? ColorModeChoiceAttribute.get() : null);
    (0,react__rspack_import_1.useEffect)(()=>{
        setColorModeState(ColorModeAttribute.get());
        setColorModeChoiceState(ColorModeChoiceAttribute.get());
    }, []);
    return {
        colorMode,
        setColorModeState,
        colorModeChoice,
        setColorModeChoiceState
    };
}
function useContextValue() {
    const { colorMode: { defaultMode, disableSwitch, respectPrefersColorScheme } } = (0,_utils_useThemeConfig__rspack_import_4/* .useThemeConfig */.p)();
    const { colorMode, setColorModeState, colorModeChoice, setColorModeChoiceState } = useColorModeState();
    (0,react__rspack_import_1.useEffect)(()=>{
        // A site is deployed without disableSwitch
        // => User visits the site and has a persisted value
        // => Site later enabled disableSwitch
        // => Clear the previously stored value to apply the site's setting
        if (disableSwitch) {
            ColorModeStorage.del();
        }
    }, [
        disableSwitch
    ]);
    const setColorMode = (0,react__rspack_import_1.useCallback)((newColorModeChoice, options = {})=>{
        const { persist = true } = options;
        // Reset to system/default color mode
        if (newColorModeChoice === null) {
            // Set the effective color
            const newColorMode = respectPrefersColorScheme ? getSystemColorMode() : defaultMode;
            ColorModeAttribute.set(newColorMode);
            setColorModeState(newColorMode);
            // Set the chosen color
            ColorModeChoiceAttribute.set(null);
            setColorModeChoiceState(null);
        } else {
            ColorModeAttribute.set(newColorModeChoice);
            ColorModeChoiceAttribute.set(newColorModeChoice);
            setColorModeState(newColorModeChoice);
            setColorModeChoiceState(newColorModeChoice);
        }
        if (persist) {
            persistColorModeChoice(newColorModeChoice);
        }
    }, [
        setColorModeState,
        setColorModeChoiceState,
        respectPrefersColorScheme,
        defaultMode
    ]);
    // Synchronize theme color/choice mode with browser storage
    (0,react__rspack_import_1.useEffect)(()=>{
        return ColorModeStorage.listen((e)=>{
            setColorMode(coerceToColorModeChoice(e.newValue));
        });
    }, [
        setColorMode
    ]);
    // Synchronize theme color with system color
    (0,react__rspack_import_1.useEffect)(()=>{
        if (colorModeChoice !== null || !respectPrefersColorScheme) {
            return undefined;
        }
        return subscribeToSystemColorModeChange((newSystemColorMode)=>{
            // Note: we don't use "setColorMode" on purpose
            // The system changes should never be considered an explicit theme choice
            // They only affect the "effective" color, and should never be persisted
            // Note: this listener also fire when printing, see https://github.com/facebook/docusaurus/pull/6490
            setColorModeState(newSystemColorMode);
            ColorModeAttribute.set(newSystemColorMode);
        });
    }, [
        respectPrefersColorScheme,
        colorModeChoice,
        setColorModeState
    ]);
    return (0,react__rspack_import_1.useMemo)(()=>({
            colorMode,
            colorModeChoice,
            setColorMode,
            get isDarkTheme () {
                if (false) {}
                return colorMode === 'dark';
            },
            setLightTheme () {
                if (false) {}
                setColorMode('light');
            },
            setDarkTheme () {
                if (false) {}
                setColorMode('dark');
            }
        }), [
        colorMode,
        colorModeChoice,
        setColorMode
    ]);
}
function ColorModeProvider({ children }) {
    const value = useContextValue();
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(Context.Provider, {
        value: value,
        children: children
    });
}
function useColorMode() {
    const context = (0,react__rspack_import_1.useContext)(Context);
    if (context == null) {
        throw new _utils_reactUtils__rspack_import_5/* .ReactContextError */.dV('ColorModeProvider', 'Please see https://docusaurus.io/docs/api/themes/configuration#use-color-mode.');
    }
    return context;
} //# sourceMappingURL=colorMode.js.map


}),
29965: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  M: () => (useNavbarMobileSidebar),
  e: () => (NavbarMobileSidebarProvider)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _navbarSecondaryMenu_content__rspack_import_2 = __webpack_require__(17000);
/* import */ var _hooks_useWindowSize__rspack_import_4 = __webpack_require__(53741);
/* import */ var _utils_historyUtils__rspack_import_5 = __webpack_require__(96629);
/* import */ var _utils_useThemeConfig__rspack_import_3 = __webpack_require__(61022);
/* import */ var _utils_reactUtils__rspack_import_6 = __webpack_require__(52260);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 






const Context = /*#__PURE__*/ react__rspack_import_1.createContext(undefined);
function useIsNavbarMobileSidebarDisabled() {
    const secondaryMenuContent = (0,_navbarSecondaryMenu_content__rspack_import_2/* .useNavbarSecondaryMenuContent */.YL)();
    const { items } = (0,_utils_useThemeConfig__rspack_import_3/* .useThemeConfig */.p)().navbar;
    return items.length === 0 && !secondaryMenuContent.component;
}
function useContextValue() {
    const disabled = useIsNavbarMobileSidebarDisabled();
    const windowSize = (0,_hooks_useWindowSize__rspack_import_4/* .useWindowSize */.l)();
    const shouldRender = !disabled && windowSize === 'mobile';
    const [shown, setShown] = (0,react__rspack_import_1.useState)(false);
    const toggle = (0,react__rspack_import_1.useCallback)(()=>{
        setShown((s)=>!s);
    }, []);
    (0,react__rspack_import_1.useEffect)(()=>{
        if (windowSize === 'desktop') {
            setShown(false);
        }
    }, [
        windowSize
    ]);
    return (0,react__rspack_import_1.useMemo)(()=>({
            disabled,
            shouldRender,
            toggle,
            shown
        }), [
        disabled,
        shouldRender,
        toggle,
        shown
    ]);
}
// A component hook wrapper enables conditional rendering
// See reason here: https://github.com/facebook/docusaurus/issues/10988
function OnHistoryPop({ handler }) {
    (0,_utils_historyUtils__rspack_import_5/* .useHistoryPopHandler */.$Z)(handler);
    return null;
}
function NavbarMobileSidebarProvider({ children }) {
    const value = useContextValue();
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsxs)(react_jsx_runtime__rspack_import_0.Fragment, {
        children: [
            // Close mobile sidebar on navigation pop
            // Most likely firing when using the Android back button (but not only)
            // Important: we can only have a single history blocker at a time
            // That's why this needs to be rendered conditionally
            // See bug report https://github.com/facebook/docusaurus/issues/10988
            value.shown && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(OnHistoryPop, {
                handler: ()=>{
                    value.toggle();
                    // Prevent pop navigation; seems desirable enough
                    // See https://github.com/facebook/docusaurus/pull/5462#issuecomment-911699846
                    return false;
                }
            }),
            /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(Context.Provider, {
                value: value,
                children: children
            })
        ]
    });
}
function useNavbarMobileSidebar() {
    const context = react__rspack_import_1.useContext(Context);
    if (context === undefined) {
        throw new _utils_reactUtils__rspack_import_6/* .ReactContextError */.dV('NavbarMobileSidebarProvider');
    }
    return context;
} //# sourceMappingURL=navbarMobileSidebar.js.map


}),
17000: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  GX: () => (NavbarSecondaryMenuFiller),
  YL: () => (useNavbarSecondaryMenuContent),
  y_: () => (NavbarSecondaryMenuContentProvider)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _utils_reactUtils__rspack_import_2 = __webpack_require__(52260);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


const Context = /*#__PURE__*/ react__rspack_import_1.createContext(null);
/** @internal */ function NavbarSecondaryMenuContentProvider({ children }) {
    const value = (0,react__rspack_import_1.useState)({
        component: null,
        props: null
    });
    return(// @ts-expect-error: this context is hard to type
    /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(Context.Provider, {
        value: value,
        children: children
    }));
}
/** @internal */ function useNavbarSecondaryMenuContent() {
    const value = (0,react__rspack_import_1.useContext)(Context);
    if (!value) {
        throw new _utils_reactUtils__rspack_import_2/* .ReactContextError */.dV('NavbarSecondaryMenuContentProvider');
    }
    return value[0];
}
/**
 * This component renders nothing by itself, but it fills the placeholder in the
 * generic secondary menu layout. This reduces coupling between the main layout
 * and the specific page.
 *
 * This kind of feature is often called portal/teleport/gateway/outlet...
 * Various unmaintained React libs exist. Most up-to-date one:
 * https://github.com/gregberge/react-teleporter
 * Not sure any of those is safe regarding concurrent mode.
 */ function NavbarSecondaryMenuFiller({ component, props }) {
    const context = (0,react__rspack_import_1.useContext)(Context);
    if (!context) {
        throw new _utils_reactUtils__rspack_import_2/* .ReactContextError */.dV('NavbarSecondaryMenuContentProvider');
    }
    const [, setContent] = context;
    // To avoid useless context re-renders, props are memoized shallowly
    const memoizedProps = (0,_utils_reactUtils__rspack_import_2/* .useShallowMemoObject */.Be)(props);
    (0,react__rspack_import_1.useEffect)(()=>{
        // @ts-expect-error: this context is hard to type
        setContent({
            component,
            props: memoizedProps
        });
    }, [
        setContent,
        component,
        memoizedProps
    ]);
    (0,react__rspack_import_1.useEffect)(()=>()=>setContent({
                component: null,
                props: null
            }), [
        setContent
    ]);
    return null;
} //# sourceMappingURL=content.js.map


}),
23433: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  w: () => (/* binding */ keyboardFocusedClassName),
  J: () => (/* binding */ useKeyboardNavigation)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/hooks/styles.css
// extracted by css-extract-rspack-plugin

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/hooks/useKeyboardNavigation.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

const keyboardFocusedClassName = 'navigation-with-keyboard';
/**
 * Side-effect that adds the `keyboardFocusedClassName` to the body element when
 * the keyboard has been pressed, or removes it when the mouse is clicked.
 *
 * The presence of this class name signals that the user may be using keyboard
 * for navigation, and the theme **must** add focus outline when this class name
 * is present. (And optionally not if it's absent, for design purposes)
 *
 * Inspired by https://hackernoon.com/removing-that-ugly-focus-ring-and-keeping-it-too-6c8727fefcd2
 */ function useKeyboardNavigation() {
    (0,react.useEffect)(()=>{
        function handleOutlineStyles(e) {
            if (e.type === 'keydown' && e.key === 'Tab') {
                document.body.classList.add(keyboardFocusedClassName);
            }
            if (e.type === 'mousedown') {
                document.body.classList.remove(keyboardFocusedClassName);
            }
        }
        document.addEventListener('keydown', handleOutlineStyles);
        document.addEventListener('mousedown', handleOutlineStyles);
        return ()=>{
            document.body.classList.remove(keyboardFocusedClassName);
            document.removeEventListener('keydown', handleOutlineStyles);
            document.removeEventListener('mousedown', handleOutlineStyles);
        };
    }, []);
} //# sourceMappingURL=useKeyboardNavigation.js.map


}),
53741: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  l: () => (useWindowSize)
});
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var _docusaurus_ExecutionEnvironment__rspack_import_1 = __webpack_require__(91289);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

const windowSizes = {
    desktop: 'desktop',
    mobile: 'mobile',
    ssr: 'ssr'
};
// Note: this value is also hardcoded in Infima
// Both JS and CSS must have the same value
// Updating this JS value alone is not enough
// See https://github.com/facebook/docusaurus/issues/9603
const DesktopBreakpoint = 996;
function getWindowSize(desktopBreakpoint) {
    if (!_docusaurus_ExecutionEnvironment__rspack_import_1["default"].canUseDOM) {
        throw new Error('getWindowSize() should only be called after React hydration');
    }
    return window.innerWidth > desktopBreakpoint ? windowSizes.desktop : windowSizes.mobile;
}
/**
 * Gets the current window size as an enum value. We don't want it to return the
 * actual width value, so that it only re-renders once a breakpoint is crossed.
 *
 * It may return `"ssr"`, which is very important to handle hydration FOUC or
 * layout shifts. You have to handle it explicitly upfront. On the server, you
 * may need to render BOTH the mobile/desktop elements (and hide one of them
 * with mediaquery). We don't return `undefined` on purpose, to make it more
 * explicit.
 */ function useWindowSize({ desktopBreakpoint = DesktopBreakpoint } = {}) {
    const [windowSize, setWindowSize] = (0,react__rspack_import_0.useState)(()=>// super important to return a constant value to avoid hydration mismatch
        // see https://github.com/facebook/docusaurus/issues/9379
        'ssr');
    (0,react__rspack_import_0.useEffect)(()=>{
        function updateWindowSize() {
            setWindowSize(getWindowSize(desktopBreakpoint));
        }
        updateWindowSize();
        window.addEventListener('resize', updateWindowSize);
        return ()=>{
            window.removeEventListener('resize', updateWindowSize);
        };
    }, [
        desktopBreakpoint
    ]);
    return windowSize;
} //# sourceMappingURL=useWindowSize.js.map


}),
88287: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  G: () => (ThemeClassNames)
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ // Please do not modify the classnames! This is a breaking change, and annoying
// for users!
/**
 * These class names are used to style page layouts in Docusaurus, meant to be
 * targeted by user-provided custom CSS selectors.
 */ const ThemeClassNames = {
    page: {
        blogListPage: 'blog-list-page',
        blogPostPage: 'blog-post-page',
        blogTagsListPage: 'blog-tags-list-page',
        blogTagPostListPage: 'blog-tags-post-list-page',
        blogAuthorsListPage: 'blog-authors-list-page',
        blogAuthorsPostsPage: 'blog-authors-posts-page',
        docsDocPage: 'docs-doc-page',
        docsTagsListPage: 'docs-tags-list-page',
        docsTagDocListPage: 'docs-tags-doc-list-page',
        mdxPage: 'mdx-page'
    },
    // TODO Docusaurus v4: remove old classes?
    wrapper: {
        main: 'main-wrapper',
        // TODO these wrapper class names are now quite useless
        // TODO do breaking change later in 3.0
        // we already add plugin name/id class on <html>: that's enough
        blogPages: 'blog-wrapper',
        docsPages: 'docs-wrapper',
        mdxPages: 'mdx-wrapper'
    },
    common: {
        editThisPage: 'theme-edit-this-page',
        lastUpdated: 'theme-last-updated',
        backToTopButton: 'theme-back-to-top-button',
        codeBlock: 'theme-code-block',
        admonition: 'theme-admonition',
        unlistedBanner: 'theme-unlisted-banner',
        draftBanner: 'theme-draft-banner',
        admonitionType: (type)=>`theme-admonition-${type}`
    },
    announcementBar: {
        container: 'theme-announcement-bar'
    },
    tabs: {
        container: 'theme-tabs-container'
    },
    layout: {
        navbar: {
            container: 'theme-layout-navbar',
            containerLeft: 'theme-layout-navbar-left',
            containerRight: 'theme-layout-navbar-right',
            mobileSidebar: {
                container: 'theme-layout-navbar-sidebar',
                panel: 'theme-layout-navbar-sidebar-panel'
            }
        },
        main: {
            container: 'theme-layout-main'
        },
        footer: {
            container: 'theme-layout-footer',
            column: 'theme-layout-footer-column'
        }
    },
    /**
     * Follows the naming convention "theme-{blog,doc,version,page}?-<suffix>"
     */ docs: {
        docVersionBanner: 'theme-doc-version-banner',
        docVersionBadge: 'theme-doc-version-badge',
        docBreadcrumbs: 'theme-doc-breadcrumbs',
        docMarkdown: 'theme-doc-markdown',
        docTocMobile: 'theme-doc-toc-mobile',
        docTocDesktop: 'theme-doc-toc-desktop',
        docFooter: 'theme-doc-footer',
        docFooterTagsRow: 'theme-doc-footer-tags-row',
        docFooterEditMetaRow: 'theme-doc-footer-edit-meta-row',
        docSidebarContainer: 'theme-doc-sidebar-container',
        docSidebarMenu: 'theme-doc-sidebar-menu',
        docSidebarItemCategory: 'theme-doc-sidebar-item-category',
        docSidebarItemLink: 'theme-doc-sidebar-item-link',
        docSidebarItemCategoryLevel: (level)=>`theme-doc-sidebar-item-category-level-${level}`,
        docSidebarItemLinkLevel: (level)=>`theme-doc-sidebar-item-link-level-${level}`
    },
    blog: {
        // TODO add other stable classNames here
        blogFooterTagsRow: 'theme-blog-footer-tags-row',
        blogFooterEditMetaRow: 'theme-blog-footer-edit-meta-row'
    },
    pages: {
        pageFooterEditMetaRow: 'theme-pages-footer-edit-meta-row'
    }
}; //# sourceMappingURL=ThemeClassNames.js.map


}),
269: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  O: () => (prefersReducedMotion)
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ function prefersReducedMotion() {
    return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
} //# sourceMappingURL=accessibilityUtils.js.map


}),
34727: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  v: () => (/* binding */ useAnchorTargetClassName)
});

// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/useThemeConfig.js
var useThemeConfig = __webpack_require__(61022);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/anchorUtils.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const anchorUtils_module = ({"anchorTargetStickyNavbar":"anchorTargetStickyNavbar_Vzrq","anchorTargetHideOnScrollNavbar":"anchorTargetHideOnScrollNavbar_vjPI"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/anchorUtils.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

/**
 * When the navbar is sticky, this ensures that when clicking a hash link,
 * we do not navigate to an anchor that will appear below the navbar.
 * This happens in particular for MDX headings and footnotes.
 *
 * See https://github.com/facebook/docusaurus/issues/11232
 * See also headings case https://x.com/JoshWComeau/status/1332015868725891076
 */ function useAnchorTargetClassName(id) {
    const { navbar: { hideOnScroll } } = (0,useThemeConfig/* .useThemeConfig */.p)();
    if (typeof id === 'undefined') {
        return undefined;
    }
    return hideOnScroll ? anchorUtils_module.anchorTargetHideOnScrollNavbar : anchorUtils_module.anchorTargetStickyNavbar;
} //# sourceMappingURL=anchorUtils.js.map


}),
96629: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  $Z: () => (useHistoryPopHandler),
  Hl: () => (useHistorySelector),
  jy: () => (mergeSearchStrings)
});
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var _docusaurus_router__rspack_import_1 = __webpack_require__(56347);
/* import */ var _reactUtils__rspack_import_2 = __webpack_require__(52260);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


/**
 * Permits to register a handler that will be called on history actions (pop,
 * push, replace). If the handler returns `false`, the navigation transition
 * will be blocked/cancelled.
 */ function useHistoryActionHandler(handler) {
    const history = (0,_docusaurus_router__rspack_import_1/* .useHistory */.W6)();
    const stableHandler = (0,_reactUtils__rspack_import_2/* .useEvent */._q)(handler);
    (0,react__rspack_import_0.useEffect)(// See https://github.com/remix-run/history/blob/main/docs/blocking-transitions.md
    ()=>history.block((location, action)=>stableHandler(location, action)), [
        history,
        stableHandler
    ]);
}
/**
 * Permits to register a handler that will be called on history pop navigation
 * (backward/forward). If the handler returns `false`, the backward/forward
 * transition will be blocked. Unfortunately there's no good way to detect the
 * "direction" (backward/forward) of the POP event.
 */ function useHistoryPopHandler(handler) {
    useHistoryActionHandler((location, action)=>{
        if (action === 'POP') {
            // Maybe block navigation if handler returns false
            return handler(location, action);
        }
        // Don't block other navigation actions
        return undefined;
    });
}
/**
 * Permits to efficiently subscribe to a slice of the history
 * See https://thisweekinreact.com/articles/useSyncExternalStore-the-underrated-react-api
 * @param selector
 */ function useHistorySelector(selector) {
    const history = (0,_docusaurus_router__rspack_import_1/* .useHistory */.W6)();
    return (0,react__rspack_import_0.useSyncExternalStore)(history.listen, ()=>selector(history), ()=>selector({
            ...history,
            location: {
                ...history.location,
                // On the server/hydration, these attributes should always be empty
                // Forcing empty state makes this hook safe from hydration errors
                search: '',
                hash: '',
                state: undefined
            }
        }));
}
/**
 * Permits to efficiently subscribe to a specific querystring value
 * @param key
 */ function useQueryStringValue(key) {
    return useHistorySelector((history)=>{
        if (key === null) {
            return null;
        }
        return new URLSearchParams(history.location.search).get(key);
    });
}
function useQueryStringUpdater(key) {
    const history = useHistory();
    return useCallback((newValue, options)=>{
        const searchParams = new URLSearchParams(history.location.search);
        if (newValue) {
            searchParams.set(key, newValue);
        } else {
            searchParams.delete(key);
        }
        const updateHistory = options?.push ? history.push : history.replace;
        updateHistory({
            search: searchParams.toString()
        });
    }, [
        key,
        history
    ]);
}
function useQueryString(key) {
    const value = useQueryStringValue(key) ?? '';
    const update = useQueryStringUpdater(key);
    return [
        value,
        update
    ];
}
function useQueryStringListValues(key) {
    // Unfortunately we can't just use searchParams.getAll(key) in the selector
    // It would create a new array every time and lead to an infinite loop...
    // The selector has to return a primitive/string value to avoid that...
    const arrayJsonString = useHistorySelector((history)=>{
        const values = new URLSearchParams(history.location.search).getAll(key);
        return JSON.stringify(values);
    });
    return useMemo(()=>JSON.parse(arrayJsonString), [
        arrayJsonString
    ]);
}
function useQueryStringListUpdater(key) {
    const history = useHistory();
    const setValues = useCallback((update, options)=>{
        const searchParams = new URLSearchParams(history.location.search);
        const newValues = Array.isArray(update) ? update : update(searchParams.getAll(key));
        searchParams.delete(key);
        newValues.forEach((v)=>searchParams.append(key, v));
        const updateHistory = options?.push ? history.push : history.replace;
        updateHistory({
            search: searchParams.toString()
        });
    }, [
        history,
        key
    ]);
    return setValues;
}
function useQueryStringList(key) {
    const values = useQueryStringListValues(key);
    const setValues = useQueryStringListUpdater(key);
    return [
        values,
        setValues
    ];
}
function useClearQueryString() {
    const history = useHistory();
    return useCallback(()=>{
        history.replace({
            search: undefined
        });
    }, [
        history
    ]);
}
function mergeSearchParams(params, strategy) {
    const result = new URLSearchParams();
    for (const item of params){
        for (const [key, value] of item.entries()){
            if (strategy === 'append') {
                result.append(key, value);
            } else {
                result.set(key, value);
            }
        }
    }
    return result;
}
function mergeSearchStrings(searchStrings, strategy) {
    const params = mergeSearchParams(searchStrings.map((s)=>new URLSearchParams(s ?? '')), strategy);
    const str = params.toString();
    return str ? `?${str}` : str;
} //# sourceMappingURL=historyUtils.js.map


}),
80618: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  $z: () => (groupBy),
  sb: () => (uniq)
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ // A replacement of lodash in client code
/**
 * Gets the duplicate values in an array.
 * @param arr The array.
 * @param comparator Compares two values and returns `true` if they are equal
 * (duplicated).
 * @returns Value of the elements `v` that have a preceding element `u` where
 * `comparator(u, v) === true`. Values within the returned array are not
 * guaranteed to be unique.
 */ function duplicates(arr, comparator = (a, b)=>a === b) {
    return arr.filter((v, vIndex)=>arr.findIndex((u)=>comparator(u, v)) !== vIndex);
}
/**
 * Remove duplicate array items (similar to `_.uniq`)
 * @param arr The array.
 * @returns An array with duplicate elements removed by reference comparison.
 */ function uniq(arr) {
    // Note: had problems with [...new Set()]: https://github.com/facebook/docusaurus/issues/4972#issuecomment-863895061
    return Array.from(new Set(arr));
}
// TODO 2025: replace by std Object.groupBy ?
// This is a local polyfill with exact same TS signature
// see https://github.com/microsoft/TypeScript/blob/main/src/lib/esnext.object.d.ts
function groupBy(items, keySelector) {
    const result = {};
    let index = 0;
    for (const item of items){
        const key = keySelector(item, index);
        result[key] ??= [];
        result[key].push(item);
        index += 1;
    }
    return result;
} //# sourceMappingURL=jsUtils.js.map


}),
34308: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  Jx: () => (PluginHtmlClassNameProvider),
  be: () => (PageMetadata),
  e3: () => (HtmlClassNameProvider)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var clsx__rspack_import_6 = __webpack_require__(34164);
/* import */ var _docusaurus_Head__rspack_import_2 = __webpack_require__(53572);
/* import */ var _docusaurus_useRouteContext__rspack_import_3 = __webpack_require__(78491);
/* import */ var _docusaurus_useBaseUrl__rspack_import_4 = __webpack_require__(66497);
/* import */ var _titleFormatterUtils__rspack_import_5 = __webpack_require__(3899);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 






function TitleMetadata({ title }) {
    const titleFormatter = (0,_titleFormatterUtils__rspack_import_5/* .useTitleFormatter */.s$)();
    const formattedTitle = titleFormatter.format(title);
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsxs)(_docusaurus_Head__rspack_import_2/* ["default"] */.A, {
        children: [
            /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("title", {
                children: formattedTitle
            }),
            /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("meta", {
                property: "og:title",
                content: formattedTitle
            })
        ]
    });
}
function DescriptionMetadata({ description }) {
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsxs)(_docusaurus_Head__rspack_import_2/* ["default"] */.A, {
        children: [
            /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("meta", {
                name: "description",
                content: description
            }),
            /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("meta", {
                property: "og:description",
                content: description
            })
        ]
    });
}
function ImageMetadata({ image }) {
    const { withBaseUrl } = (0,_docusaurus_useBaseUrl__rspack_import_4/* .useBaseUrlUtils */.hH)();
    const pageImage = withBaseUrl(image, {
        absolute: true
    });
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsxs)(_docusaurus_Head__rspack_import_2/* ["default"] */.A, {
        children: [
            /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("meta", {
                property: "og:image",
                content: pageImage
            }),
            /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("meta", {
                name: "twitter:image",
                content: pageImage
            })
        ]
    });
}
function KeywordsMetadata({ keywords }) {
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(_docusaurus_Head__rspack_import_2/* ["default"] */.A, {
        children: /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("meta", {
            name: "keywords",
            content: // https://github.com/microsoft/TypeScript/issues/17002
            Array.isArray(keywords) ? keywords.join(',') : keywords
        })
    });
}
/**
 * Helper component to manipulate page metadata and override site defaults.
 * Works in the same way as Helmet.
 */ function PageMetadata({ title, description, keywords, image, children }) {
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsxs)(react_jsx_runtime__rspack_import_0.Fragment, {
        children: [
            title && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(TitleMetadata, {
                title: title
            }),
            description && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(DescriptionMetadata, {
                description: description
            }),
            keywords && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(KeywordsMetadata, {
                keywords: keywords
            }),
            image && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(ImageMetadata, {
                image: image
            }),
            children && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(_docusaurus_Head__rspack_import_2/* ["default"] */.A, {
                children: children
            })
        ]
    });
}
const HtmlClassNameContext = /*#__PURE__*/ react__rspack_import_1.createContext(undefined);
/**
 * Every layer of this provider will append a class name to the HTML element.
 * There's no consumer for this hook: it's side-effect-only. This wrapper is
 * necessary because Helmet does not "merge" classes.
 * @see https://github.com/staylor/react-helmet-async/issues/161
 */ function HtmlClassNameProvider({ className: classNameProp, children }) {
    const classNameContext = react__rspack_import_1.useContext(HtmlClassNameContext);
    const className = (0,clsx__rspack_import_6/* ["default"] */.A)(classNameContext, classNameProp);
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsxs)(HtmlClassNameContext.Provider, {
        value: className,
        children: [
            /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(_docusaurus_Head__rspack_import_2/* ["default"] */.A, {
                children: /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("html", {
                    className: className
                })
            }),
            children
        ]
    });
}
function pluginNameToClassName(pluginName) {
    return `plugin-${pluginName.replace(/docusaurus-(?:plugin|theme)-(?:content-)?/gi, '')}`;
}
/**
 * A very thin wrapper around `HtmlClassNameProvider` that adds the plugin ID +
 * name to the HTML class name.
 */ function PluginHtmlClassNameProvider({ children }) {
    const routeContext = (0,_docusaurus_useRouteContext__rspack_import_3/* ["default"] */.A)();
    const nameClass = pluginNameToClassName(routeContext.plugin.name);
    const idClass = `plugin-id-${routeContext.plugin.id}`;
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(HtmlClassNameProvider, {
        className: (0,clsx__rspack_import_6/* ["default"] */.A)(nameClass, idClass),
        children: children
    });
} //# sourceMappingURL=metadataUtils.js.map


}),
52260: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  Be: () => (useShallowMemoObject),
  ZC: () => (usePrevious),
  _q: () => (useEvent),
  dV: () => (ReactContextError),
  fM: () => (composeProviders)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _docusaurus_useIsomorphicLayoutEffect__rspack_import_2 = __webpack_require__(99989);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


/**
 * Temporary userland implementation until an official hook is implemented
 * See RFC: https://github.com/reactjs/rfcs/pull/220
 *
 * Permits to transform an unstable callback (like an arrow function provided as
 * props) to a "stable" callback that is safe to use in a `useEffect` dependency
 * array. Useful to avoid React stale closure problems + avoid useless effect
 * re-executions.
 *
 * This generally works but has some potential drawbacks, such as
 * https://github.com/facebook/react/issues/16956#issuecomment-536636418
 */ function useEvent(callback) {
    const ref = (0,react__rspack_import_1.useRef)(callback);
    (0,_docusaurus_useIsomorphicLayoutEffect__rspack_import_2/* ["default"] */.A)(()=>{
        ref.current = callback;
    }, [
        callback
    ]);
    // @ts-expect-error: TS is right that this callback may be a supertype of T,
    // but good enough for our use
    return (0,react__rspack_import_1.useCallback)((...args)=>ref.current(...args), []);
}
/**
 * Gets `value` from the last render.
 */ function usePrevious(value) {
    const ref = (0,react__rspack_import_1.useRef)();
    (0,_docusaurus_useIsomorphicLayoutEffect__rspack_import_2/* ["default"] */.A)(()=>{
        ref.current = value;
    });
    // TODO need to fix this React Compiler lint error
    //  probably requires changing the API though
    // eslint-disable-next-line react-compiler/react-compiler
    return ref.current;
}
/**
 * This error is thrown when a context is consumed outside its provider. Allows
 * reusing a generic error message format and reduces bundle size. The hook's
 * name will be extracted from its stack, so only the provider's name is needed.
 */ class ReactContextError extends Error {
    constructor(providerName, additionalInfo){
        super();
        this.name = 'ReactContextError';
        this.message = `Hook ${this.stack?.split('\n')[1]?.match(/at (?:\w+\.)?(?<name>\w+)/)?.groups.name ?? ''} is called outside the <${providerName}>. ${additionalInfo ?? ''}`;
    }
}
/**
 * Shallow-memoize an object. This means the returned object will be the same as
 * the previous render if the property keys and values did not change. This
 * works for simple cases: when property values are primitives or stable
 * objects.
 *
 * @param obj
 */ function useShallowMemoObject(obj) {
    const deps = Object.entries(obj);
    // Sort by keys to make it order-insensitive
    deps.sort((a, b)=>a[0].localeCompare(b[0]));
    // eslint-disable-next-line react-compiler/react-compiler,react-hooks/exhaustive-deps
    return (0,react__rspack_import_1.useMemo)(()=>obj, deps.flat());
}
/**
 * Creates a single React provider from an array of existing providers
 * assuming providers only take "children" as props.
 *
 * Prevents the annoying React element nesting
 * Example here: https://getfrontend.tips/compose-multiple-react-providers/
 *
 * The order matters:
 * - The first provider is at the top of the tree.
 * - The last provider is the most nested one
 *
 * @param providers array of providers to compose
 */ function composeProviders(providers) {
    // Creates a single React component: it's cheaper to compose JSX elements
    return ({ children })=>/*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(react_jsx_runtime__rspack_import_0.Fragment, {
            children: providers.reduceRight((element, CurrentProvider)=>/*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(CurrentProvider, {
                    children: element
                }), children)
        });
} //# sourceMappingURL=reactUtils.js.map


}),
19209: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  Dt: () => (useHomePageRoute),
  ys: () => (isSamePath)
});
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var _generated_routes__rspack_import_1 = __webpack_require__(58460);
/* import */ var _docusaurus_useDocusaurusContext__rspack_import_2 = __webpack_require__(10898);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


/**
 * Compare the 2 paths, case insensitive and ignoring trailing slash
 */ function isSamePath(path1, path2) {
    const normalize = (pathname)=>(!pathname || pathname.endsWith('/') ? pathname : `${pathname}/`)?.toLowerCase();
    return normalize(path1) === normalize(path2);
}
/**
 * Note that sites don't always have a homepage in practice, so we can't assume
 * that linking to '/' is always safe.
 * @see https://github.com/facebook/docusaurus/pull/6517#issuecomment-1048709116
 */ function findHomePageRoute({ baseUrl, routes: initialRoutes }) {
    function isHomePageRoute(route) {
        return route.path === baseUrl && route.exact === true;
    }
    function isHomeParentRoute(route) {
        return route.path === baseUrl && !route.exact;
    }
    function doFindHomePageRoute(routes) {
        if (routes.length === 0) {
            return undefined;
        }
        const homePage = routes.find(isHomePageRoute);
        if (homePage) {
            return homePage;
        }
        const indexSubRoutes = routes.filter(isHomeParentRoute).flatMap((route)=>route.routes ?? []);
        return doFindHomePageRoute(indexSubRoutes);
    }
    return doFindHomePageRoute(initialRoutes);
}
/**
 * Fetches the route that points to "/". Use this instead of the naive "/",
 * because the homepage may not exist.
 */ function useHomePageRoute() {
    const { baseUrl } = (0,_docusaurus_useDocusaurusContext__rspack_import_2/* ["default"] */.A)().siteConfig;
    return (0,react__rspack_import_0.useMemo)(()=>findHomePageRoute({
            routes: _generated_routes__rspack_import_1/* ["default"] */.A,
            baseUrl
        }), [
        baseUrl
    ]);
} //# sourceMappingURL=routesUtils.js.map


}),
28584: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  Mq: () => (useScrollPosition),
  Tv: () => (ScrollControllerProvider),
  gk: () => (useSmoothScrollTo)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _docusaurus_ExecutionEnvironment__rspack_import_2 = __webpack_require__(91289);
/* import */ var _docusaurus_useIsBrowser__rspack_import_3 = __webpack_require__(19863);
/* import */ var _docusaurus_useIsomorphicLayoutEffect__rspack_import_4 = __webpack_require__(99989);
/* import */ var _reactUtils__rspack_import_5 = __webpack_require__(52260);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 





function useScrollControllerContextValue() {
    const scrollEventsEnabledRef = (0,react__rspack_import_1.useRef)(true);
    return (0,react__rspack_import_1.useMemo)(()=>({
            scrollEventsEnabledRef,
            enableScrollEvents: ()=>{
                scrollEventsEnabledRef.current = true;
            },
            disableScrollEvents: ()=>{
                scrollEventsEnabledRef.current = false;
            }
        }), []);
}
const ScrollMonitorContext = /*#__PURE__*/ react__rspack_import_1.createContext(undefined);
function ScrollControllerProvider({ children }) {
    const value = useScrollControllerContextValue();
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(ScrollMonitorContext.Provider, {
        value: value,
        children: children
    });
}
/**
 * We need a way to update the scroll position while ignoring scroll events
 * so as not to toggle Navbar/BackToTop visibility.
 *
 * This API permits to temporarily disable/ignore scroll events. Motivated by
 * https://github.com/facebook/docusaurus/pull/5618
 */ function useScrollController() {
    const context = (0,react__rspack_import_1.useContext)(ScrollMonitorContext);
    if (context == null) {
        throw new _reactUtils__rspack_import_5/* .ReactContextError */.dV('ScrollControllerProvider');
    }
    return context;
}
const getScrollPosition = ()=>_docusaurus_ExecutionEnvironment__rspack_import_2["default"].canUseDOM ? {
        scrollX: window.pageXOffset,
        scrollY: window.pageYOffset
    } : null;
/**
 * This hook fires an effect when the scroll position changes. The effect will
 * be provided with the before/after scroll positions. Note that the effect may
 * not be always run: if scrolling is disabled through `useScrollController`, it
 * will be a no-op.
 *
 * @see {@link useScrollController}
 */ function useScrollPosition(effect, deps = []) {
    const { scrollEventsEnabledRef } = useScrollController();
    const lastPositionRef = (0,react__rspack_import_1.useRef)(getScrollPosition());
    const dynamicEffect = (0,_reactUtils__rspack_import_5/* .useEvent */._q)(effect);
    (0,react__rspack_import_1.useEffect)(()=>{
        const handleScroll = ()=>{
            if (!scrollEventsEnabledRef.current) {
                return;
            }
            const currentPosition = getScrollPosition();
            dynamicEffect(currentPosition, lastPositionRef.current);
            lastPositionRef.current = currentPosition;
        };
        const opts = {
            passive: true
        };
        handleScroll();
        window.addEventListener('scroll', handleScroll, opts);
        return ()=>window.removeEventListener('scroll', handleScroll, opts);
    // eslint-disable-next-line react-compiler/react-compiler
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        dynamicEffect,
        scrollEventsEnabledRef,
        ...deps
    ]);
}
function useScrollPositionSaver() {
    const lastElementRef = useRef({
        elem: null,
        top: 0
    });
    const save = useCallback((elem)=>{
        lastElementRef.current = {
            elem,
            top: elem.getBoundingClientRect().top
        };
    }, []);
    const restore = useCallback(()=>{
        const { current: { elem, top } } = lastElementRef;
        if (!elem) {
            return {
                restored: false
            };
        }
        const newTop = elem.getBoundingClientRect().top;
        const heightDiff = newTop - top;
        if (heightDiff) {
            window.scrollBy({
                left: 0,
                top: heightDiff
            });
        }
        lastElementRef.current = {
            elem: null,
            top: 0
        };
        return {
            restored: heightDiff !== 0
        };
    }, []);
    return useMemo(()=>({
            save,
            restore
        }), [
        restore,
        save
    ]);
}
/**
 * This hook permits to "block" the scroll position of a DOM element.
 * The idea is that we should be able to update DOM content above this element
 * but the screen position of this element should not change.
 *
 * Feature motivated by the Tabs groups: clicking on a tab may affect tabs of
 * the same group upper in the tree, yet to avoid a bad UX, the clicked tab must
 * remain under the user mouse.
 *
 * @see https://github.com/facebook/docusaurus/pull/5618
 */ function useScrollPositionBlocker() {
    const scrollController = useScrollController();
    const scrollPositionSaver = useScrollPositionSaver();
    const nextLayoutEffectCallbackRef = useRef(undefined);
    const blockElementScrollPositionUntilNextRender = useCallback((el)=>{
        scrollPositionSaver.save(el);
        scrollController.disableScrollEvents();
        nextLayoutEffectCallbackRef.current = ()=>{
            const { restored } = scrollPositionSaver.restore();
            nextLayoutEffectCallbackRef.current = undefined;
            // Restoring the former scroll position will trigger a scroll event. We
            // need to wait for next scroll event to happen before enabling the
            // scrollController events again.
            if (restored) {
                const handleScrollRestoreEvent = ()=>{
                    scrollController.enableScrollEvents();
                    window.removeEventListener('scroll', handleScrollRestoreEvent);
                };
                window.addEventListener('scroll', handleScrollRestoreEvent);
            } else {
                scrollController.enableScrollEvents();
            }
        };
    }, [
        scrollController,
        scrollPositionSaver
    ]);
    useIsomorphicLayoutEffect(()=>{
        // Queuing permits to restore scroll position after all useLayoutEffect
        // have run, and yet preserve the sync nature of the scroll restoration
        // See https://github.com/facebook/docusaurus/issues/8625
        queueMicrotask(()=>nextLayoutEffectCallbackRef.current?.());
    });
    return {
        blockElementScrollPositionUntilNextRender
    };
}
function smoothScrollNative(top) {
    window.scrollTo({
        top,
        behavior: 'smooth'
    });
    return ()=>{
    // Nothing to cancel, it's natively cancelled if user tries to scroll down
    };
}
function smoothScrollPolyfill(top) {
    let raf = null;
    const isUpScroll = document.documentElement.scrollTop > top;
    function rafRecursion() {
        const currentScroll = document.documentElement.scrollTop;
        if (isUpScroll && currentScroll > top || !isUpScroll && currentScroll < top) {
            raf = requestAnimationFrame(rafRecursion);
            window.scrollTo(0, Math.floor((currentScroll - top) * 0.85) + top);
        }
    }
    rafRecursion();
    // Break the recursion. Prevents the user from "fighting" against that
    // recursion producing a weird UX
    return ()=>raf && cancelAnimationFrame(raf);
}
/**
 * A "smart polyfill" of `window.scrollTo({ top, behavior: "smooth" })`.
 * This currently always uses a polyfilled implementation unless
 * `scroll-behavior: smooth` has been set in CSS, because native support
 * detection for scroll behavior seems unreliable.
 *
 * This hook does not do anything by itself: it returns a start and a stop
 * handle. You can execute either handle at any time.
 */ function useSmoothScrollTo() {
    const cancelRef = (0,react__rspack_import_1.useRef)(null);
    const isBrowser = (0,_docusaurus_useIsBrowser__rspack_import_3/* ["default"] */.A)();
    // Not all have support for smooth scrolling (particularly Safari mobile iOS)
    // TODO proper detection is currently unreliable!
    // see https://github.com/wessberg/scroll-behavior-polyfill/issues/16
    // For now, we only use native scroll behavior if smooth is already set,
    // because otherwise the polyfill produces a weird UX when both CSS and JS try
    // to scroll a page, and they cancel each other.
    const supportsNativeSmoothScrolling = isBrowser && getComputedStyle(document.documentElement).scrollBehavior === 'smooth';
    return {
        startScroll: (top)=>{
            cancelRef.current = supportsNativeSmoothScrolling ? smoothScrollNative(top) : smoothScrollPolyfill(top);
        },
        cancelScroll: ()=>cancelRef.current?.()
    };
} //# sourceMappingURL=scrollUtils.js.map


}),
41367: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Wf: () => (/* binding */ createStorageSlot)
});

// UNUSED EXPORTS: listStorageKeys, useStorageSlot

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
;// CONCATENATED MODULE: ./.docusaurus/site-storage.json
var site_storage_namespaceObject = JSON.parse('{"N":"localStorage","M":""}')
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/storageUtils.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

const DefaultStorageType = site_storage_namespaceObject.N;
function applyNamespace(storageKey) {
    return `${storageKey}${site_storage_namespaceObject.M}`;
}
// window.addEventListener('storage') only works for different windows...
// so for current window we have to dispatch the event manually
// Now we can listen for both cross-window / current-window storage changes!
// see https://stackoverflow.com/a/71177640/82609
// see https://stackoverflow.com/questions/26974084/listen-for-changes-with-localstorage-on-the-same-window
function dispatchChangeEvent({ key, oldValue, newValue, storage }) {
    // If we set multiple times the same storage value, events should not be fired
    // The native events behave this way, so our manual event dispatch should
    // rather behave exactly the same. Not doing so might create infinite loops.
    // See https://github.com/facebook/docusaurus/issues/8594
    if (oldValue === newValue) {
        return;
    }
    const event = document.createEvent('StorageEvent');
    event.initStorageEvent('storage', false, false, key, oldValue, newValue, window.location.href, storage);
    window.dispatchEvent(event);
}
/**
 * Will return `null` if browser storage is unavailable (like running Docusaurus
 * in an iframe). This should NOT be called in SSR.
 *
 * @see https://github.com/facebook/docusaurus/pull/4501
 */ function getBrowserStorage(storageType = DefaultStorageType) {
    if (typeof window === 'undefined') {
        throw new Error('Browser storage is not available on Node.js/Docusaurus SSR process.');
    }
    if (storageType === 'none') {
        return null;
    }
    try {
        return window[storageType];
    } catch (err) {
        logOnceBrowserStorageNotAvailableWarning(err);
        return null;
    }
}
let hasLoggedBrowserStorageNotAvailableWarning = false;
/**
 * Poor man's memoization to avoid logging multiple times the same warning.
 * Sometimes, `localStorage`/`sessionStorage` is unavailable due to browser
 * policies.
 */ function logOnceBrowserStorageNotAvailableWarning(error) {
    if (!hasLoggedBrowserStorageNotAvailableWarning) {
        console.warn(`Docusaurus browser storage is not available.
Possible reasons: running Docusaurus in an iframe, in an incognito browser session, or using too strict browser privacy settings.`, error);
        hasLoggedBrowserStorageNotAvailableWarning = true;
    }
}
const NoopStorageSlot = {
    get: ()=>null,
    set: ()=>{},
    del: ()=>{},
    listen: ()=>()=>{}
};
// Fail-fast, as storage APIs should not be used during the SSR process
function createServerStorageSlot(key) {
    function throwError() {
        throw new Error(`Illegal storage API usage for storage key "${key}".
Docusaurus storage APIs are not supposed to be called on the server-rendering process.
Please only call storage APIs in effects and event handlers.`);
    }
    return {
        get: throwError,
        set: throwError,
        del: throwError,
        listen: throwError
    };
}
/**
 * Creates an interface to work on a particular key in the storage model.
 * Note that this function only initializes the interface, but doesn't allocate
 * anything by itself (i.e. no side-effects).
 *
 * The API is fail-safe, since usage of browser storage should be considered
 * unreliable. Local storage might simply be unavailable (iframe + browser
 * security) or operations might fail individually. Please assume that using
 * this API can be a no-op. See also https://github.com/facebook/docusaurus/issues/6036
 */ function createStorageSlot(keyInput, options) {
    const key = applyNamespace(keyInput);
    if (typeof window === 'undefined') {
        return createServerStorageSlot(key);
    }
    const storage = getBrowserStorage(options?.persistence);
    if (storage === null) {
        return NoopStorageSlot;
    }
    return {
        get: ()=>{
            try {
                return storage.getItem(key);
            } catch (err) {
                console.error(`Docusaurus storage error, can't get key=${key}`, err);
                return null;
            }
        },
        set: (newValue)=>{
            try {
                const oldValue = storage.getItem(key);
                storage.setItem(key, newValue);
                dispatchChangeEvent({
                    key,
                    oldValue,
                    newValue,
                    storage
                });
            } catch (err) {
                console.error(`Docusaurus storage error, can't set ${key}=${newValue}`, err);
            }
        },
        del: ()=>{
            try {
                const oldValue = storage.getItem(key);
                storage.removeItem(key);
                dispatchChangeEvent({
                    key,
                    oldValue,
                    newValue: null,
                    storage
                });
            } catch (err) {
                console.error(`Docusaurus storage error, can't delete key=${key}`, err);
            }
        },
        listen: (onChange)=>{
            try {
                const listener = (event)=>{
                    if (event.storageArea === storage && event.key === key) {
                        onChange(event);
                    }
                };
                window.addEventListener('storage', listener);
                return ()=>window.removeEventListener('storage', listener);
            } catch (err) {
                console.error(`Docusaurus storage error, can't listen for changes of key=${key}`, err);
                return ()=>{};
            }
        }
    };
}
function useStorageSlot(key, options) {
    // Not ideal but good enough: assumes storage slot config is constant
    const [storageSlot] = useState(()=>{
        if (key === null) {
            return NoopStorageSlot;
        }
        return createStorageSlot(key, options);
    });
    const listen = useCallback((onChange)=>{
        // Do not try to add a listener during SSR
        if (typeof window === 'undefined') {
            return ()=>{};
        }
        return storageSlot.listen(onChange);
    }, [
        storageSlot
    ]);
    const currentValue = useSyncExternalStore(listen, ()=>{
        // react-test-renderer (deprecated) never call getServerSnapshot() :/
        if (false) {}
        return storageSlot.get();
    }, ()=>null);
    return [
        currentValue,
        storageSlot
    ];
}
/**
 * Returns a list of all the keys currently stored in browser storage,
 * or an empty list if browser storage can't be accessed.
 */ function listStorageKeys(storageType = DefaultStorageType) {
    const browserStorage = getBrowserStorage(storageType);
    if (!browserStorage) {
        return [];
    }
    const keys = [];
    for(let i = 0; i < browserStorage.length; i += 1){
        const key = browserStorage.key(i);
        if (key !== null) {
            keys.push(key);
        }
    }
    return keys;
} //# sourceMappingURL=storageUtils.js.map


}),
3899: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  AL: () => (TitleFormatterProvider),
  s$: () => (useTitleFormatter)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _docusaurus_useDocusaurusContext__rspack_import_2 = __webpack_require__(10898);
/* import */ var _docusaurus_useRouteContext__rspack_import_3 = __webpack_require__(78491);
/* import */ var _reactUtils__rspack_import_4 = __webpack_require__(52260);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




const TitleFormatterFnDefault = ({ title, siteTitle, titleDelimiter })=>{
    const trimmedTitle = title?.trim();
    if (!trimmedTitle || trimmedTitle === siteTitle) {
        return siteTitle;
    }
    return `${trimmedTitle} ${titleDelimiter} ${siteTitle}`;
};
const TitleFormatterContext = /*#__PURE__*/ (0,react__rspack_import_1.createContext)(null);
function TitleFormatterProvider({ formatter, children }) {
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(TitleFormatterContext.Provider, {
        value: formatter,
        children: children
    });
}
function useTitleFormatterContext() {
    const value = (0,react__rspack_import_1.useContext)(TitleFormatterContext);
    if (value === null) {
        throw new _reactUtils__rspack_import_4/* .ReactContextError */.dV('TitleFormatterProvider');
    }
    return value;
}
/**
 * Returns a function to format the page title
 */ function useTitleFormatter() {
    const formatter = useTitleFormatterContext();
    const { siteConfig } = (0,_docusaurus_useDocusaurusContext__rspack_import_2/* ["default"] */.A)();
    const { title: siteTitle, titleDelimiter } = siteConfig;
    // Unfortunately we can only call this hook here, not in the provider
    // Route context can't be accessed in any provider applied above the router
    const { plugin } = (0,_docusaurus_useRouteContext__rspack_import_3/* ["default"] */.A)();
    return {
        format: (title)=>formatter({
                title,
                siteTitle,
                titleDelimiter,
                plugin,
                defaultFormatter: TitleFormatterFnDefault
            })
    };
} //# sourceMappingURL=titleFormatterUtils.js.map


}),
5243: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  o: () => (useAlternatePageUtils)
});
/* import */ var _docusaurus_useDocusaurusContext__rspack_import_0 = __webpack_require__(10898);
/* import */ var _docusaurus_router__rspack_import_1 = __webpack_require__(56347);
/* import */ var _docusaurus_utils_common__rspack_import_2 = __webpack_require__(5248);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


/**
 * Permits to obtain the url of the current page in another locale, useful to
 * generate hreflang meta headers etc...
 *
 * @see https://developers.google.com/search/docs/advanced/crawling/localized-versions
 */ function useAlternatePageUtils() {
    const { siteConfig: { baseUrl, trailingSlash }, i18n: { localeConfigs } } = (0,_docusaurus_useDocusaurusContext__rspack_import_0/* ["default"] */.A)();
    // TODO using useLocation().pathname is not a super idea
    // See https://github.com/facebook/docusaurus/issues/9170
    const { pathname } = (0,_docusaurus_router__rspack_import_1/* .useLocation */.zy)();
    const canonicalPathname = (0,_docusaurus_utils_common__rspack_import_2.applyTrailingSlash)(pathname, {
        trailingSlash,
        baseUrl
    });
    // Canonical pathname, without the baseUrl of the current locale
    const pathnameSuffix = canonicalPathname.replace(baseUrl, '');
    function getLocaleConfig(locale) {
        const localeConfig = localeConfigs[locale];
        if (!localeConfig) {
            throw new Error(`Unexpected Docusaurus bug, no locale config found for locale=${locale}`);
        }
        return localeConfig;
    }
    function createUrl({ locale, fullyQualified }) {
        const localeConfig = getLocaleConfig(locale);
        const newUrl = `${fullyQualified ? localeConfig.url : ''}`;
        const newBaseUrl = localeConfig.baseUrl;
        return `${newUrl}${newBaseUrl}${pathnameSuffix}`;
    }
    return {
        createUrl
    };
} //# sourceMappingURL=useAlternatePageUtils.js.map


}),
98398: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  $: () => (useLocationChange)
});
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var _docusaurus_router__rspack_import_1 = __webpack_require__(56347);
/* import */ var _reactUtils__rspack_import_2 = __webpack_require__(52260);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


/**
 * Fires an effect when the location changes (which includes hash, query, etc.).
 * Importantly, doesn't fire when there's no previous location: see
 * https://github.com/facebook/docusaurus/pull/6696
 */ function useLocationChange(onLocationChange) {
    const location = (0,_docusaurus_router__rspack_import_1/* .useLocation */.zy)();
    const previousLocation = (0,_reactUtils__rspack_import_2/* .usePrevious */.ZC)(location);
    const onLocationChangeDynamic = (0,_reactUtils__rspack_import_2/* .useEvent */._q)(onLocationChange);
    (0,react__rspack_import_0.useEffect)(()=>{
        if (!previousLocation) {
            return;
        }
        if (location !== previousLocation) {
            onLocationChangeDynamic({
                location,
                previousLocation
            });
        }
    }, [
        onLocationChangeDynamic,
        location,
        previousLocation
    ]);
} //# sourceMappingURL=useLocationChange.js.map


}),
61022: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  p: () => (useThemeConfig)
});
/* import */ var _docusaurus_useDocusaurusContext__rspack_import_0 = __webpack_require__(10898);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 
/**
 * A convenient/more semantic way to get theme config from context.
 */ function useThemeConfig() {
    return (0,_docusaurus_useDocusaurusContext__rspack_import_0/* ["default"] */.A)().siteConfig.themeConfig;
} //# sourceMappingURL=useThemeConfig.js.map


}),
84207: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.addTrailingSlash = addTrailingSlash;
exports["default"] = applyTrailingSlash;
exports.addLeadingSlash = addLeadingSlash;
exports.removeTrailingSlash = removeTrailingSlash;
const stringUtils_1 = __webpack_require__(89262);
function addTrailingSlash(str) {
    return str.endsWith('/') ? str : `${str}/`;
}
// Trailing slash handling depends in some site configuration options
function applyTrailingSlash(path, options) {
    const { trailingSlash, baseUrl } = options;
    if (path.startsWith('#')) {
        // Never apply trailing slash to an anchor link
        return path;
    }
    function handleTrailingSlash(str, trailing) {
        return trailing ? addTrailingSlash(str) : removeTrailingSlash(str);
    }
    // undefined = legacy retrocompatible behavior
    if (typeof trailingSlash === 'undefined') {
        return path;
    }
    // The trailing slash should be handled before the ?search#hash !
    const [pathname] = path.split(/[#?]/);
    // Never transform '/' to ''
    // Never remove the baseUrl trailing slash!
    // If baseUrl = /myBase/, we want to emit /myBase/index.html and not
    // /myBase.html! See https://github.com/facebook/docusaurus/issues/5077
    const shouldNotApply = pathname === '/' || pathname === baseUrl;
    const newPathname = shouldNotApply ? pathname : handleTrailingSlash(pathname, trailingSlash);
    return path.replace(pathname, newPathname);
}
/** Appends a leading slash to `str`, if one doesn't exist. */ function addLeadingSlash(str) {
    return (0, stringUtils_1.addPrefix)(str, '/');
}
/** Removes the trailing slash from `str`. */ function removeTrailingSlash(str) {
    return (0, stringUtils_1.removeSuffix)(str, '/');
} //# sourceMappingURL=applyTrailingSlash.js.map


}),
17541: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getErrorCausalChain = getErrorCausalChain;
function getErrorCausalChain(error) {
    if (error.cause) {
        return [
            error,
            ...getErrorCausalChain(error.cause)
        ];
    }
    return [
        error
    ];
} //# sourceMappingURL=errorUtils.js.map


}),
5248: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";
var __webpack_unused_export__;

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ __webpack_unused_export__ = ({
    value: true
});
exports.getErrorCausalChain = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = exports.applyTrailingSlash = exports.blogPostContainerID = void 0;
const tslib_1 = __webpack_require__(31635);
// __ prefix allows search crawlers (Algolia/DocSearch) to ignore anchors
// https://github.com/facebook/docusaurus/issues/8883#issuecomment-1516328368
exports.blogPostContainerID = '__blog-post-container';
var applyTrailingSlash_1 = __webpack_require__(84207);
Object.defineProperty(exports, "applyTrailingSlash", ({
    enumerable: true,
    get: function() {
        return tslib_1.__importDefault(applyTrailingSlash_1).default;
    }
}));
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return applyTrailingSlash_1.addTrailingSlash;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return applyTrailingSlash_1.addLeadingSlash;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return applyTrailingSlash_1.removeTrailingSlash;
    }
});
var stringUtils_1 = __webpack_require__(89262);
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return stringUtils_1.addPrefix;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return stringUtils_1.removeSuffix;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return stringUtils_1.addSuffix;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return stringUtils_1.removePrefix;
    }
});
var errorUtils_1 = __webpack_require__(17541);
Object.defineProperty(exports, "getErrorCausalChain", ({
    enumerable: true,
    get: function() {
        return errorUtils_1.getErrorCausalChain;
    }
})); //# sourceMappingURL=index.js.map


}),
89262: (function (__unused_webpack_module, exports) {
"use strict";

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.addPrefix = addPrefix;
exports.removeSuffix = removeSuffix;
exports.addSuffix = addSuffix;
exports.removePrefix = removePrefix;
/** Adds a given string prefix to `str`. */ function addPrefix(str, prefix) {
    return str.startsWith(prefix) ? str : `${prefix}${str}`;
}
/** Removes a given string suffix from `str`. */ function removeSuffix(str, suffix) {
    if (suffix === '') {
        // str.slice(0, 0) is ""
        return str;
    }
    return str.endsWith(suffix) ? str.slice(0, -suffix.length) : str;
}
/** Adds a given string suffix to `str`. */ function addSuffix(str, suffix) {
    return str.endsWith(suffix) ? str : `${str}${suffix}`;
}
/** Removes a given string prefix from `str`. */ function removePrefix(str, prefix) {
    return str.startsWith(prefix) ? str.slice(prefix.length) : str;
} //# sourceMappingURL=stringUtils.js.map


}),
70630: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const ExecutionEnvironment_1 = __importDefault(__webpack_require__(91289));
if (ExecutionEnvironment_1.default.canUseDOM) {
    window.Prism = window.Prism || {};
    window.Prism.manual = true;
} //# sourceMappingURL=global.js.map


}),
4784: (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (__rspack_default_export)
});
/*
 * AUTOGENERATED - DON'T EDIT
 * Your edits in this file will be overwritten in the next build!
 * Modify the docusaurus.config.js file at your site's root instead.
 */
/* export default */ const __rspack_default_export = ({
  "title": "Fintesk - documentación para usuarios",
  "tagline": "Obtén todos los consejos y tips que necesitas para customizar nuestra aplicación con estos tutoriales",
  "favicon": "img/fintesk.ico",
  "url": "https://docs.fintesk.com",
  "baseUrl": "/",
  "projectName": "fabouru1985.github.io",
  "organizationName": "fabouru1985",
  "deploymentBranch": "main",
  "onBrokenLinks": "warn",
  "trailingSlash": false,
  "i18n": {
    "defaultLocale": "en",
    "locales": [
      "en",
      "es"
    ],
    "path": "i18n",
    "localeConfigs": {}
  },
  "presets": [
    [
      "classic",
      {
        "docs": {
          "sidebarPath": "./sidebars.js",
          "routeBasePath": "/",
          "exclude": [
            "**_api/**"
          ],
          "showLastUpdateAuthor": true,
          "showLastUpdateTime": true
        },
        "blog": {
          "showReadingTime": true,
          "blogSidebarTitle": "All posts",
          "blogSidebarCount": "ALL",
          "feedOptions": {
            "type": null
          }
        },
        "theme": {
          "customCss": "./src/css/custom.css"
        }
      }
    ],
    [
      "redocusaurus",
      {
        "specs": [
          {
            "id": "fintesk-v1",
            "spec": "docs/_api/fintesk/fintesk_api.yaml",
            "route": "docs/fintesk-v1/"
          }
        ],
        "theme": {
          "primaryColor": "#1890ff"
        }
      }
    ]
  ],
  "plugins": [
    [
      "@docusaurus/plugin-google-tag-manager",
      {
        "containerId": "GTM-MFMP7WDH"
      }
    ],
    [
      "@orama/plugin-docusaurus-v3",
      {
        "plugins": {
          "analytics": {
            "enabled": true
          }
        }
      }
    ]
  ],
  "themeConfig": {
    "navbar": {
      "title": "Fintesk Docs",
      "logo": {
        "alt": "Fintesk Logo",
        "src": "img/Fintesk-V2023-06-09.svg"
      },
      "items": [
        {
          "type": "docSidebar",
          "sidebarId": "tutorialSidebar",
          "position": "left",
          "label": "Tutorial"
        },
        {
          "to": "/blog",
          "label": "Blog",
          "position": "left"
        },
        {
          "type": "localeDropdown",
          "position": "right",
          "dropdownItemsBefore": [],
          "dropdownItemsAfter": []
        }
      ],
      "hideOnScroll": false
    },
    "footer": {
      "style": "dark",
      "links": [],
      "copyright": "<div>Copyright © 2020 - 2025 <a href=\"https://fintesk.com?utm_source=fintesk-docs\">www.fintesk.com<a><div>"
    },
    "prism": {
      "theme": {
        "plain": {
          "color": "#393A34",
          "backgroundColor": "#f6f8fa"
        },
        "styles": [
          {
            "types": [
              "comment",
              "prolog",
              "doctype",
              "cdata"
            ],
            "style": {
              "color": "#999988",
              "fontStyle": "italic"
            }
          },
          {
            "types": [
              "namespace"
            ],
            "style": {
              "opacity": 0.7
            }
          },
          {
            "types": [
              "string",
              "attr-value"
            ],
            "style": {
              "color": "#e3116c"
            }
          },
          {
            "types": [
              "punctuation",
              "operator"
            ],
            "style": {
              "color": "#393A34"
            }
          },
          {
            "types": [
              "entity",
              "url",
              "symbol",
              "number",
              "boolean",
              "variable",
              "constant",
              "property",
              "regex",
              "inserted"
            ],
            "style": {
              "color": "#36acaa"
            }
          },
          {
            "types": [
              "atrule",
              "keyword",
              "attr-name",
              "selector"
            ],
            "style": {
              "color": "#00a4db"
            }
          },
          {
            "types": [
              "function",
              "deleted",
              "tag"
            ],
            "style": {
              "color": "#d73a49"
            }
          },
          {
            "types": [
              "function-variable"
            ],
            "style": {
              "color": "#6f42c1"
            }
          },
          {
            "types": [
              "tag",
              "selector",
              "keyword"
            ],
            "style": {
              "color": "#00009f"
            }
          }
        ]
      },
      "darkTheme": {
        "plain": {
          "color": "#F8F8F2",
          "backgroundColor": "#282A36"
        },
        "styles": [
          {
            "types": [
              "prolog",
              "constant",
              "builtin"
            ],
            "style": {
              "color": "rgb(189, 147, 249)"
            }
          },
          {
            "types": [
              "inserted",
              "function"
            ],
            "style": {
              "color": "rgb(80, 250, 123)"
            }
          },
          {
            "types": [
              "deleted"
            ],
            "style": {
              "color": "rgb(255, 85, 85)"
            }
          },
          {
            "types": [
              "changed"
            ],
            "style": {
              "color": "rgb(255, 184, 108)"
            }
          },
          {
            "types": [
              "punctuation",
              "symbol"
            ],
            "style": {
              "color": "rgb(248, 248, 242)"
            }
          },
          {
            "types": [
              "string",
              "char",
              "tag",
              "selector"
            ],
            "style": {
              "color": "rgb(255, 121, 198)"
            }
          },
          {
            "types": [
              "keyword",
              "variable"
            ],
            "style": {
              "color": "rgb(189, 147, 249)",
              "fontStyle": "italic"
            }
          },
          {
            "types": [
              "comment"
            ],
            "style": {
              "color": "rgb(98, 114, 164)"
            }
          },
          {
            "types": [
              "attr-name"
            ],
            "style": {
              "color": "rgb(241, 250, 140)"
            }
          }
        ]
      },
      "additionalLanguages": [
        "powershell",
        "php",
        "python"
      ],
      "magicComments": [
        {
          "className": "theme-code-block-highlighted-line",
          "line": "highlight-next-line",
          "block": {
            "start": "highlight-start",
            "end": "highlight-end"
          }
        }
      ]
    },
    "tableOfContents": {
      "minHeadingLevel": 2,
      "maxHeadingLevel": 3
    },
    "colorMode": {
      "defaultMode": "light",
      "disableSwitch": false,
      "respectPrefersColorScheme": false
    },
    "docs": {
      "versionPersistence": "localStorage",
      "sidebar": {
        "hideable": false,
        "autoCollapseCategories": false
      }
    },
    "blog": {
      "sidebar": {
        "groupByYear": true
      }
    },
    "metadata": []
  },
  "future": {
    "v4": {
      "removeLegacyPostBuildHeadAttribute": true,
      "useCssCascadeLayers": true
    },
    "experimental_faster": {
      "swcJsLoader": true,
      "swcJsMinimizer": true,
      "swcHtmlMinimizer": true,
      "lightningCssMinimizer": true,
      "rspackBundler": true,
      "rspackPersistentCache": true,
      "ssgWorkerThreads": true,
      "mdxCrossCompilerCache": true
    },
    "experimental_storage": {
      "type": "localStorage",
      "namespace": false
    },
    "experimental_router": "browser"
  },
  "markdown": {
    "hooks": {
      "onBrokenMarkdownImages": "warn",
      "onBrokenMarkdownLinks": "warn"
    },
    "format": "mdx",
    "mermaid": false,
    "emoji": true,
    "mdx1Compat": {
      "comments": true,
      "admonitions": true,
      "headingIds": true
    },
    "anchors": {
      "maintainCase": false
    }
  },
  "baseUrlIssueBanner": true,
  "onBrokenAnchors": "warn",
  "onDuplicateRoutes": "warn",
  "staticDirectories": [
    "static"
  ],
  "customFields": {},
  "themes": [],
  "scripts": [],
  "headTags": [],
  "stylesheets": [],
  "clientModules": [],
  "titleDelimiter": "|",
  "noIndex": false
});


}),
58168: (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (_extends)
});
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}


}),
77387: (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (_inheritsLoose)
});
/* import */ var _setPrototypeOf_js__rspack_import_0 = __webpack_require__(63662);

function _inheritsLoose(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, (0,_setPrototypeOf_js__rspack_import_0/* ["default"] */.A)(t, o);
}


}),
98587: (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (_objectWithoutPropertiesLoose)
});
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}


}),
63662: (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (_setPrototypeOf)
});
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}


}),
34164: (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (__rspack_default_export)
});
function r(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=" "),n+=f)}else for(f in e)e[f]&&(n&&(n+=" "),n+=f);return n}function clsx(){for(var e,t,f=0,n="",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=" "),n+=t);return n}/* export default */ const __rspack_default_export = (clsx);

}),
71765: (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  My: () => (Prism),
  f4: () => (Highlight2)
});
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var clsx__rspack_import_1 = __webpack_require__(34164);
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/.pnpm/prismjs@1.29.0_patch_hash=vrxx3pzkik6jpmgpayxfjunetu/node_modules/prismjs/prism.js
var require_prism = __commonJS({
  "../../node_modules/.pnpm/prismjs@1.29.0_patch_hash=vrxx3pzkik6jpmgpayxfjunetu/node_modules/prismjs/prism.js"(exports, module) {
    var Prism2 = function() {
      var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
      var uniqueId = 0;
      var plainTextGrammar = {};
      var _ = {
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function encode(tokens) {
            if (tokens instanceof Token) {
              return new Token(tokens.type, encode(tokens.content), tokens.alias);
            } else if (Array.isArray(tokens)) {
              return tokens.map(encode);
            } else {
              return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            }
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(o) {
            return Object.prototype.toString.call(o).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(obj) {
            if (!obj["__id"]) {
              Object.defineProperty(obj, "__id", { value: ++uniqueId });
            }
            return obj["__id"];
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function deepClone(o, visited) {
            visited = visited || {};
            var clone;
            var id;
            switch (_.util.type(o)) {
              case "Object":
                id = _.util.objId(o);
                if (visited[id]) {
                  return visited[id];
                }
                clone = /** @type {Record<string, any>} */
                {};
                visited[id] = clone;
                for (var key in o) {
                  if (o.hasOwnProperty(key)) {
                    clone[key] = deepClone(o[key], visited);
                  }
                }
                return (
                  /** @type {any} */
                  clone
                );
              case "Array":
                id = _.util.objId(o);
                if (visited[id]) {
                  return visited[id];
                }
                clone = [];
                visited[id] = clone;
                /** @type {Array} */
                /** @type {any} */
                o.forEach(function(v, i) {
                  clone[i] = deepClone(v, visited);
                });
                return (
                  /** @type {any} */
                  clone
                );
              default:
                return o;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(element) {
            while (element) {
              var m = lang.exec(element.className);
              if (m) {
                return m[1].toLowerCase();
              }
              element = element.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(element, language) {
            element.className = element.className.replace(RegExp(lang, "gi"), "");
            element.classList.add("language-" + language);
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(element, className, defaultActivation) {
            var no = "no-" + className;
            while (element) {
              var classList = element.classList;
              if (classList.contains(className)) {
                return true;
              }
              if (classList.contains(no)) {
                return false;
              }
              element = element.parentElement;
            }
            return !!defaultActivation;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: plainTextGrammar,
          plaintext: plainTextGrammar,
          text: plainTextGrammar,
          txt: plainTextGrammar,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(id, redef) {
            var lang2 = _.util.clone(_.languages[id]);
            for (var key in redef) {
              lang2[key] = redef[key];
            }
            return lang2;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(inside, before, insert, root) {
            root = root || /** @type {any} */
            _.languages;
            var grammar = root[inside];
            var ret = {};
            for (var token in grammar) {
              if (grammar.hasOwnProperty(token)) {
                if (token == before) {
                  for (var newToken in insert) {
                    if (insert.hasOwnProperty(newToken)) {
                      ret[newToken] = insert[newToken];
                    }
                  }
                }
                if (!insert.hasOwnProperty(token)) {
                  ret[token] = grammar[token];
                }
              }
            }
            var old = root[inside];
            root[inside] = ret;
            _.languages.DFS(_.languages, function(key, value) {
              if (value === old && key != inside) {
                this[key] = ret;
              }
            });
            return ret;
          },
          // Traverse a language definition with Depth First Search
          DFS: function DFS(o, callback, type, visited) {
            visited = visited || {};
            var objId = _.util.objId;
            for (var i in o) {
              if (o.hasOwnProperty(i)) {
                callback.call(o, i, o[i], type || i);
                var property = o[i];
                var propertyType = _.util.type(property);
                if (propertyType === "Object" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, null, visited);
                } else if (propertyType === "Array" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, i, visited);
                }
              }
            }
          }
        },
        plugins: {},
        /**
         * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(text, grammar, language) {
          var env = {
            code: text,
            grammar,
            language
          };
          _.hooks.run("before-tokenize", env);
          if (!env.grammar) {
            throw new Error('The language "' + env.language + '" has no grammar.');
          }
          env.tokens = _.tokenize(env.code, env.grammar);
          _.hooks.run("after-tokenize", env);
          return Token.stringify(_.util.encode(env.tokens), env.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(text, grammar) {
          var rest = grammar.rest;
          if (rest) {
            for (var token in rest) {
              grammar[token] = rest[token];
            }
            delete grammar.rest;
          }
          var tokenList = new LinkedList();
          addAfter(tokenList, tokenList.head, text);
          matchGrammar(text, tokenList, grammar, tokenList.head, 0);
          return toArray(tokenList);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(name, callback) {
            var hooks2 = _.hooks.all;
            hooks2[name] = hooks2[name] || [];
            hooks2[name].push(callback);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(name, env) {
            var callbacks = _.hooks.all[name];
            if (!callbacks || !callbacks.length) {
              return;
            }
            for (var i = 0, callback; callback = callbacks[i++]; ) {
              callback(env);
            }
          }
        },
        Token
      };
      function Token(type, content, alias, matchedStr) {
        this.type = type;
        this.content = content;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
      }
      Token.stringify = function stringify(o, language) {
        if (typeof o == "string") {
          return o;
        }
        if (Array.isArray(o)) {
          var s = "";
          o.forEach(function(e) {
            s += stringify(e, language);
          });
          return s;
        }
        var env = {
          type: o.type,
          content: stringify(o.content, language),
          tag: "span",
          classes: ["token", o.type],
          attributes: {},
          language
        };
        var aliases = o.alias;
        if (aliases) {
          if (Array.isArray(aliases)) {
            Array.prototype.push.apply(env.classes, aliases);
          } else {
            env.classes.push(aliases);
          }
        }
        _.hooks.run("wrap", env);
        var attributes = "";
        for (var name in env.attributes) {
          attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
      };
      function matchPattern(pattern, pos, text, lookbehind) {
        pattern.lastIndex = pos;
        var match = pattern.exec(text);
        if (match && lookbehind && match[1]) {
          var lookbehindLength = match[1].length;
          match.index += lookbehindLength;
          match[0] = match[0].slice(lookbehindLength);
        }
        return match;
      }
      function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
        for (var token in grammar) {
          if (!grammar.hasOwnProperty(token) || !grammar[token]) {
            continue;
          }
          var patterns = grammar[token];
          patterns = Array.isArray(patterns) ? patterns : [patterns];
          for (var j = 0; j < patterns.length; ++j) {
            if (rematch && rematch.cause == token + "," + j) {
              return;
            }
            var patternObj = patterns[j];
            var inside = patternObj.inside;
            var lookbehind = !!patternObj.lookbehind;
            var greedy = !!patternObj.greedy;
            var alias = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            var pattern = patternObj.pattern || patternObj;
            for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
              if (rematch && pos >= rematch.reach) {
                break;
              }
              var str = currentNode.value;
              if (tokenList.length > text.length) {
                return;
              }
              if (str instanceof Token) {
                continue;
              }
              var removeCount = 1;
              var match;
              if (greedy) {
                match = matchPattern(pattern, pos, text, lookbehind);
                if (!match || match.index >= text.length) {
                  break;
                }
                var from = match.index;
                var to = match.index + match[0].length;
                var p = pos;
                p += currentNode.value.length;
                while (from >= p) {
                  currentNode = currentNode.next;
                  p += currentNode.value.length;
                }
                p -= currentNode.value.length;
                pos = p;
                if (currentNode.value instanceof Token) {
                  continue;
                }
                for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === "string"); k = k.next) {
                  removeCount++;
                  p += k.value.length;
                }
                removeCount--;
                str = text.slice(pos, p);
                match.index -= pos;
              } else {
                match = matchPattern(pattern, 0, str, lookbehind);
                if (!match) {
                  continue;
                }
              }
              var from = match.index;
              var matchStr = match[0];
              var before = str.slice(0, from);
              var after = str.slice(from + matchStr.length);
              var reach = pos + str.length;
              if (rematch && reach > rematch.reach) {
                rematch.reach = reach;
              }
              var removeFrom = currentNode.prev;
              if (before) {
                removeFrom = addAfter(tokenList, removeFrom, before);
                pos += before.length;
              }
              removeRange(tokenList, removeFrom, removeCount);
              var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
              currentNode = addAfter(tokenList, removeFrom, wrapped);
              if (after) {
                addAfter(tokenList, currentNode, after);
              }
              if (removeCount > 1) {
                var nestedRematch = {
                  cause: token + "," + j,
                  reach
                };
                matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                if (rematch && nestedRematch.reach > rematch.reach) {
                  rematch.reach = nestedRematch.reach;
                }
              }
            }
          }
        }
      }
      function LinkedList() {
        var head = { value: null, prev: null, next: null };
        var tail = { value: null, prev: head, next: null };
        head.next = tail;
        this.head = head;
        this.tail = tail;
        this.length = 0;
      }
      function addAfter(list, node, value) {
        var next = node.next;
        var newNode = { value, prev: node, next };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
      }
      function removeRange(list, node, count) {
        var next = node.next;
        for (var i = 0; i < count && next !== list.tail; i++) {
          next = next.next;
        }
        node.next = next;
        next.prev = node;
        list.length -= i;
      }
      function toArray(list) {
        var array = [];
        var node = list.head.next;
        while (node !== list.tail) {
          array.push(node.value);
          node = node.next;
        }
        return array;
      }
      return _;
    }();
    module.exports = Prism2;
    Prism2.default = Prism2;
  }
});

// src/prism-langs.ts
var Prism = __toESM(require_prism());
Prism.languages.markup = { comment: { pattern: /<!--(?:(?!<!--)[\s\S])*?-->/, greedy: true }, prolog: { pattern: /<\?[\s\S]+?\?>/, greedy: true }, doctype: { pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i, greedy: true, inside: { "internal-subset": { pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/, lookbehind: true, greedy: true, inside: null }, string: { pattern: /"[^"]*"|'[^']*'/, greedy: true }, punctuation: /^<!|>$|[[\]]/, "doctype-tag": /^DOCTYPE/i, name: /[^\s<>'"]+/ } }, cdata: { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, greedy: true }, tag: { pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/, greedy: true, inside: { tag: { pattern: /^<\/?[^\s>\/]+/, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } }, "special-attr": [], "attr-value": { pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/, inside: { punctuation: [{ pattern: /^=/, alias: "attr-equals" }, { pattern: /^(\s*)["']|["']$/, lookbehind: true }] } }, punctuation: /\/?>/, "attr-name": { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } } } }, entity: [{ pattern: /&[\da-z]{1,8};/i, alias: "named-entity" }, /&#x?[\da-f]{1,8};/i] }, Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity, Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup, Prism.hooks.add("wrap", function(e) {
  "entity" === e.type && (e.attributes.title = e.content.replace(/&amp;/, "&"));
}), Object.defineProperty(Prism.languages.markup.tag, "addInlined", { value: function(e, n) {
  var t = {}, t = (t["language-" + n] = { pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i, lookbehind: true, inside: Prism.languages[n] }, t.cdata = /^<!\[CDATA\[|\]\]>$/i, { "included-cdata": { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, inside: t } }), n = (t["language-" + n] = { pattern: /[\s\S]+/, inside: Prism.languages[n] }, {});
  n[e] = { pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
    return e;
  }), "i"), lookbehind: true, greedy: true, inside: t }, Prism.languages.insertBefore("markup", "cdata", n);
} }), Object.defineProperty(Prism.languages.markup.tag, "addAttribute", { value: function(e, n) {
  Prism.languages.markup.tag.inside["special-attr"].push({ pattern: RegExp(/(^|["'\s])/.source + "(?:" + e + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"), lookbehind: true, inside: { "attr-name": /^[^\s=]+/, "attr-value": { pattern: /=[\s\S]+/, inside: { value: { pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/, lookbehind: true, alias: [n, "language-" + n], inside: Prism.languages[n] }, punctuation: [{ pattern: /^=/, alias: "attr-equals" }, /"|'/] } } } });
} }), Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.xml = Prism.languages.extend("markup", {}), Prism.languages.ssml = Prism.languages.xml, Prism.languages.atom = Prism.languages.xml, Prism.languages.rss = Prism.languages.xml, function(e) {
  var n = { pattern: /\\[\\(){}[\]^$+*?|.]/, alias: "escape" }, t = /\\(?:x[\da-fA-F]{2}|u[\da-fA-F]{4}|u\{[\da-fA-F]+\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/, a = "(?:[^\\\\-]|" + t.source + ")", a = RegExp(a + "-" + a), r = { pattern: /(<|')[^<>']+(?=[>']$)/, lookbehind: true, alias: "variable" };
  e.languages.regex = { "char-class": { pattern: /((?:^|[^\\])(?:\\\\)*)\[(?:[^\\\]]|\\[\s\S])*\]/, lookbehind: true, inside: { "char-class-negation": { pattern: /(^\[)\^/, lookbehind: true, alias: "operator" }, "char-class-punctuation": { pattern: /^\[|\]$/, alias: "punctuation" }, range: { pattern: a, inside: { escape: t, "range-punctuation": { pattern: /-/, alias: "operator" } } }, "special-escape": n, "char-set": { pattern: /\\[wsd]|\\p\{[^{}]+\}/i, alias: "class-name" }, escape: t } }, "special-escape": n, "char-set": { pattern: /\.|\\[wsd]|\\p\{[^{}]+\}/i, alias: "class-name" }, backreference: [{ pattern: /\\(?![123][0-7]{2})[1-9]/, alias: "keyword" }, { pattern: /\\k<[^<>']+>/, alias: "keyword", inside: { "group-name": r } }], anchor: { pattern: /[$^]|\\[ABbGZz]/, alias: "function" }, escape: t, group: [{ pattern: /\((?:\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/, alias: "punctuation", inside: { "group-name": r } }, { pattern: /\)/, alias: "punctuation" }], quantifier: { pattern: /(?:[+*?]|\{\d+(?:,\d*)?\})[?+]?/, alias: "number" }, alternation: { pattern: /\|/, alias: "keyword" } };
}(Prism), Prism.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true, greedy: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/, boolean: /\b(?:false|true)\b/, function: /\b\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/, punctuation: /[{}[\];(),.:]/ }, Prism.languages.javascript = Prism.languages.extend("clike", { "class-name": [Prism.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/, lookbehind: true }], keyword: [{ pattern: /((?:^|\})\s*)catch\b/, lookbehind: true }, { pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, number: { pattern: RegExp(/(^|[^\w$])/.source + "(?:" + /NaN|Infinity/.source + "|" + /0[bB][01]+(?:_[01]+)*n?/.source + "|" + /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + /\d+(?:_\d+)*n/.source + "|" + /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source + ")" + /(?![\w$])/.source), lookbehind: true }, operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/ }), Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, Prism.languages.insertBefore("javascript", "keyword", { regex: { pattern: RegExp(/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source), lookbehind: true, greedy: true, inside: { "regex-source": { pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/, lookbehind: true, alias: "language-regex", inside: Prism.languages.regex }, "regex-delimiter": /^\/|\/$/, "regex-flags": /^[a-z]+$/ } }, "function-variable": { pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/, lookbehind: true, inside: Prism.languages.javascript }, { pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i, lookbehind: true, inside: Prism.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/, lookbehind: true, inside: Prism.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/, lookbehind: true, inside: Prism.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ }), Prism.languages.insertBefore("javascript", "string", { hashbang: { pattern: /^#!.*/, greedy: true, alias: "comment" }, "template-string": { pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/, greedy: true, inside: { "template-punctuation": { pattern: /^`|`$/, alias: "string" }, interpolation: { pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/, lookbehind: true, inside: { "interpolation-punctuation": { pattern: /^\$\{|\}$/, alias: "punctuation" }, rest: Prism.languages.javascript } }, string: /[\s\S]+/ } }, "string-property": { pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m, lookbehind: true, greedy: true, alias: "property" } }), Prism.languages.insertBefore("javascript", "operator", { "literal-property": { pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m, lookbehind: true, alias: "property" } }), Prism.languages.markup && (Prism.languages.markup.tag.addInlined("script", "javascript"), Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript")), Prism.languages.js = Prism.languages.javascript, Prism.languages.actionscript = Prism.languages.extend("javascript", { keyword: /\b(?:as|break|case|catch|class|const|default|delete|do|dynamic|each|else|extends|final|finally|for|function|get|if|implements|import|in|include|instanceof|interface|internal|is|namespace|native|new|null|override|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|use|var|void|while|with)\b/, operator: /\+\+|--|(?:[+\-*\/%^]|&&?|\|\|?|<<?|>>?>?|[!=]=?)=?|[~?@]/ }), Prism.languages.actionscript["class-name"].alias = "function", delete Prism.languages.actionscript.parameter, delete Prism.languages.actionscript["literal-property"], Prism.languages.markup && Prism.languages.insertBefore("actionscript", "string", { xml: { pattern: /(^|[^.])<\/?\w+(?:\s+[^\s>\/=]+=("|')(?:\\[\s\S]|(?!\2)[^\\])*\2)*\s*\/?>/, lookbehind: true, inside: Prism.languages.markup } }), function(e) {
  var n = /#(?!\{).+/, t = { pattern: /#\{[^}]+\}/, alias: "variable" };
  e.languages.coffeescript = e.languages.extend("javascript", { comment: n, string: [{ pattern: /'(?:\\[\s\S]|[^\\'])*'/, greedy: true }, { pattern: /"(?:\\[\s\S]|[^\\"])*"/, greedy: true, inside: { interpolation: t } }], keyword: /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/, "class-member": { pattern: /@(?!\d)\w+/, alias: "variable" } }), e.languages.insertBefore("coffeescript", "comment", { "multiline-comment": { pattern: /###[\s\S]+?###/, alias: "comment" }, "block-regex": { pattern: /\/{3}[\s\S]*?\/{3}/, alias: "regex", inside: { comment: n, interpolation: t } } }), e.languages.insertBefore("coffeescript", "string", { "inline-javascript": { pattern: /`(?:\\[\s\S]|[^\\`])*`/, inside: { delimiter: { pattern: /^`|`$/, alias: "punctuation" }, script: { pattern: /[\s\S]+/, alias: "language-javascript", inside: e.languages.javascript } } }, "multiline-string": [{ pattern: /'''[\s\S]*?'''/, greedy: true, alias: "string" }, { pattern: /"""[\s\S]*?"""/, greedy: true, alias: "string", inside: { interpolation: t } }] }), e.languages.insertBefore("coffeescript", "keyword", { property: /(?!\d)\w+(?=\s*:(?!:))/ }), delete e.languages.coffeescript["template-string"], e.languages.coffee = e.languages.coffeescript;
}(Prism), function(l) {
  var e = l.languages.javadoclike = { parameter: { pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*@(?:arg|arguments|param)\s+)\w+/m, lookbehind: true }, keyword: { pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*|\{)@[a-z][a-zA-Z-]+\b/m, lookbehind: true }, punctuation: /[{}]/ };
  Object.defineProperty(e, "addSupport", { value: function(e2, o) {
    (e2 = "string" == typeof e2 ? [e2] : e2).forEach(function(e3) {
      var n = function(e4) {
        e4.inside || (e4.inside = {}), e4.inside.rest = o;
      }, t = "doc-comment";
      if (a = l.languages[e3]) {
        var a, r = a[t];
        if ((r = r ? r : (a = l.languages.insertBefore(e3, "comment", { "doc-comment": { pattern: /(^|[^\\])\/\*\*[^/][\s\S]*?(?:\*\/|$)/, lookbehind: true, alias: "comment" } }))[t]) instanceof RegExp && (r = a[t] = { pattern: r }), Array.isArray(r))
          for (var s = 0, i = r.length; s < i; s++)
            r[s] instanceof RegExp && (r[s] = { pattern: r[s] }), n(r[s]);
        else
          n(r);
      }
    });
  } }), e.addSupport(["java", "javascript", "php"], e);
}(Prism), function(e) {
  var n = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/, n = (e.languages.css = { comment: /\/\*[\s\S]*?\*\//, atrule: { pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + n.source + ")*?" + /(?:;|(?=\s*\{))/.source), inside: { rule: /^@[\w-]+/, "selector-function-argument": { pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/, lookbehind: true, alias: "selector" }, keyword: { pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/, lookbehind: true } } }, url: { pattern: RegExp("\\burl\\((?:" + n.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"), greedy: true, inside: { function: /^url/i, punctuation: /^\(|\)$/, string: { pattern: RegExp("^" + n.source + "$"), alias: "url" } } }, selector: { pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + n.source + ")*(?=\\s*\\{)"), lookbehind: true }, string: { pattern: n, greedy: true }, property: { pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i, lookbehind: true }, important: /!important\b/i, function: { pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i, lookbehind: true }, punctuation: /[(){};:,]/ }, e.languages.css.atrule.inside.rest = e.languages.css, e.languages.markup);
  n && (n.tag.addInlined("style", "css"), n.tag.addAttribute("style", "css"));
}(Prism), function(e) {
  var n = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, n = (e.languages.css.selector = { pattern: e.languages.css.selector.pattern, lookbehind: true, inside: n = { "pseudo-element": /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/, "pseudo-class": /:[-\w]+/, class: /\.[-\w]+/, id: /#[-\w]+/, attribute: { pattern: RegExp(`\\[(?:[^[\\]"']|` + n.source + ")*\\]"), greedy: true, inside: { punctuation: /^\[|\]$/, "case-sensitivity": { pattern: /(\s)[si]$/i, lookbehind: true, alias: "keyword" }, namespace: { pattern: /^(\s*)(?:(?!\s)[-*\w\xA0-\uFFFF])*\|(?!=)/, lookbehind: true, inside: { punctuation: /\|$/ } }, "attr-name": { pattern: /^(\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+/, lookbehind: true }, "attr-value": [n, { pattern: /(=\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+(?=\s*$)/, lookbehind: true }], operator: /[|~*^$]?=/ } }, "n-th": [{ pattern: /(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/, lookbehind: true, inside: { number: /[\dn]+/, operator: /[+-]/ } }, { pattern: /(\(\s*)(?:even|odd)(?=\s*\))/i, lookbehind: true }], combinator: />|\+|~|\|\|/, punctuation: /[(),]/ } }, e.languages.css.atrule.inside["selector-function-argument"].inside = n, e.languages.insertBefore("css", "property", { variable: { pattern: /(^|[^-\w\xA0-\uFFFF])--(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*/i, lookbehind: true } }), { pattern: /(\b\d+)(?:%|[a-z]+(?![\w-]))/, lookbehind: true }), t = { pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/, lookbehind: true };
  e.languages.insertBefore("css", "function", { operator: { pattern: /(\s)[+\-*\/](?=\s)/, lookbehind: true }, hexcode: { pattern: /\B#[\da-f]{3,8}\b/i, alias: "color" }, color: [{ pattern: /(^|[^\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|RebeccaPurple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\w-])/i, lookbehind: true }, { pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i, inside: { unit: n, number: t, function: /[\w-]+(?=\()/, punctuation: /[(),]/ } }], entity: /\\[\da-f]{1,8}/i, unit: n, number: t });
}(Prism), function(e) {
  var n = /[*&][^\s[\]{},]+/, t = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/, a = "(?:" + t.source + "(?:[ 	]+" + n.source + ")?|" + n.source + "(?:[ 	]+" + t.source + ")?)", r = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
    return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
  }), s = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
  function i(e2, n2) {
    n2 = (n2 || "").replace(/m/g, "") + "m";
    var t2 = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
      return a;
    }).replace(/<<value>>/g, function() {
      return e2;
    });
    return RegExp(t2, n2);
  }
  e.languages.yaml = { scalar: { pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
    return a;
  })), lookbehind: true, alias: "string" }, comment: /#.*/, key: { pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
    return a;
  }).replace(/<<key>>/g, function() {
    return "(?:" + r + "|" + s + ")";
  })), lookbehind: true, greedy: true, alias: "atrule" }, directive: { pattern: /(^[ \t]*)%.+/m, lookbehind: true, alias: "important" }, datetime: { pattern: i(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source), lookbehind: true, alias: "number" }, boolean: { pattern: i(/false|true/.source, "i"), lookbehind: true, alias: "important" }, null: { pattern: i(/null|~/.source, "i"), lookbehind: true, alias: "important" }, string: { pattern: i(s), lookbehind: true, greedy: true }, number: { pattern: i(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"), lookbehind: true }, tag: t, important: n, punctuation: /---|[:[\]{}\-,|>?]|\.\.\./ }, e.languages.yml = e.languages.yaml;
}(Prism), function(o) {
  var n = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
  function e(e2) {
    return e2 = e2.replace(/<inner>/g, function() {
      return n;
    }), RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + e2 + ")");
  }
  var t = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source, a = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
    return t;
  }), r = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source, l = (o.languages.markdown = o.languages.extend("markup", {}), o.languages.insertBefore("markdown", "prolog", { "front-matter-block": { pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/, lookbehind: true, greedy: true, inside: { punctuation: /^---|---$/, "front-matter": { pattern: /\S+(?:\s+\S+)*/, alias: ["yaml", "language-yaml"], inside: o.languages.yaml } } }, blockquote: { pattern: /^>(?:[\t ]*>)*/m, alias: "punctuation" }, table: { pattern: RegExp("^" + a + r + "(?:" + a + ")*", "m"), inside: { "table-data-rows": { pattern: RegExp("^(" + a + r + ")(?:" + a + ")*$"), lookbehind: true, inside: { "table-data": { pattern: RegExp(t), inside: o.languages.markdown }, punctuation: /\|/ } }, "table-line": { pattern: RegExp("^(" + a + ")" + r + "$"), lookbehind: true, inside: { punctuation: /\||:?-{3,}:?/ } }, "table-header-row": { pattern: RegExp("^" + a + "$"), inside: { "table-header": { pattern: RegExp(t), alias: "important", inside: o.languages.markdown }, punctuation: /\|/ } } } }, code: [{ pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/, lookbehind: true, alias: "keyword" }, { pattern: /^```[\s\S]*?^```$/m, greedy: true, inside: { "code-block": { pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m, lookbehind: true }, "code-language": { pattern: /^(```).+/, lookbehind: true }, punctuation: /```/ } }], title: [{ pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m, alias: "important", inside: { punctuation: /==+$|--+$/ } }, { pattern: /(^\s*)#.+/m, lookbehind: true, alias: "important", inside: { punctuation: /^#+|#+$/ } }], hr: { pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m, lookbehind: true, alias: "punctuation" }, list: { pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m, lookbehind: true, alias: "punctuation" }, "url-reference": { pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/, inside: { variable: { pattern: /^(!?\[)[^\]]+/, lookbehind: true }, string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/, punctuation: /^[\[\]!:]|[<>]/ }, alias: "url" }, bold: { pattern: e(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source), lookbehind: true, greedy: true, inside: { content: { pattern: /(^..)[\s\S]+(?=..$)/, lookbehind: true, inside: {} }, punctuation: /\*\*|__/ } }, italic: { pattern: e(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source), lookbehind: true, greedy: true, inside: { content: { pattern: /(^.)[\s\S]+(?=.$)/, lookbehind: true, inside: {} }, punctuation: /[*_]/ } }, strike: { pattern: e(/(~~?)(?:(?!~)<inner>)+\2/.source), lookbehind: true, greedy: true, inside: { content: { pattern: /(^~~?)[\s\S]+(?=\1$)/, lookbehind: true, inside: {} }, punctuation: /~~?/ } }, "code-snippet": { pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/, lookbehind: true, greedy: true, alias: ["code", "keyword"] }, url: { pattern: e(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source), lookbehind: true, greedy: true, inside: { operator: /^!/, content: { pattern: /(^\[)[^\]]+(?=\])/, lookbehind: true, inside: {} }, variable: { pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/, lookbehind: true }, url: { pattern: /(^\]\()[^\s)]+/, lookbehind: true }, string: { pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/, lookbehind: true } } } }), ["url", "bold", "italic", "strike"].forEach(function(n2) {
    ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(e2) {
      n2 !== e2 && (o.languages.markdown[n2].inside.content.inside[e2] = o.languages.markdown[e2]);
    });
  }), o.hooks.add("after-tokenize", function(e2) {
    "markdown" !== e2.language && "md" !== e2.language || !function e3(n2) {
      if (n2 && "string" != typeof n2)
        for (var t2 = 0, a2 = n2.length; t2 < a2; t2++) {
          var r2, s = n2[t2];
          "code" !== s.type ? e3(s.content) : (r2 = s.content[1], s = s.content[3], r2 && s && "code-language" === r2.type && "code-block" === s.type && "string" == typeof r2.content && (r2 = r2.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp"), r2 = "language-" + (r2 = (/[a-z][\w-]*/i.exec(r2) || [""])[0].toLowerCase()), s.alias ? "string" == typeof s.alias ? s.alias = [s.alias, r2] : s.alias.push(r2) : s.alias = [r2]));
        }
    }(e2.tokens);
  }), o.hooks.add("wrap", function(e2) {
    if ("code-block" === e2.type) {
      for (var n2 = "", t2 = 0, a2 = e2.classes.length; t2 < a2; t2++) {
        var r2 = e2.classes[t2], r2 = /language-(.+)/.exec(r2);
        if (r2) {
          n2 = r2[1];
          break;
        }
      }
      var s, i = o.languages[n2];
      i ? e2.content = o.highlight(function(e3) {
        e3 = e3.replace(l, "");
        return e3 = e3.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(e4, n3) {
          var t3;
          return "#" === (n3 = n3.toLowerCase())[0] ? (t3 = "x" === n3[1] ? parseInt(n3.slice(2), 16) : Number(n3.slice(1)), c(t3)) : u[n3] || e4;
        });
      }(e2.content), i, n2) : n2 && "none" !== n2 && o.plugins.autoloader && (s = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(1e16 * Math.random()), e2.attributes.id = s, o.plugins.autoloader.loadLanguages(n2, function() {
        var e3 = document.getElementById(s);
        e3 && (e3.innerHTML = o.highlight(e3.textContent, o.languages[n2], n2));
      }));
    }
  }), RegExp(o.languages.markup.tag.pattern.source, "gi")), u = { amp: "&", lt: "<", gt: ">", quot: '"' }, c = String.fromCodePoint || String.fromCharCode;
  o.languages.md = o.languages.markdown;
}(Prism), Prism.languages.graphql = { comment: /#.*/, description: { pattern: /(?:"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*")(?=\s*[a-z_])/i, greedy: true, alias: "string", inside: { "language-markdown": { pattern: /(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/, lookbehind: true, inside: Prism.languages.markdown } } }, string: { pattern: /"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*"/, greedy: true }, number: /(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i, boolean: /\b(?:false|true)\b/, variable: /\$[a-z_]\w*/i, directive: { pattern: /@[a-z_]\w*/i, alias: "function" }, "attr-name": { pattern: /\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\"\r\n])*")*\))?:)/i, greedy: true }, "atom-input": { pattern: /\b[A-Z]\w*Input\b/, alias: "class-name" }, scalar: /\b(?:Boolean|Float|ID|Int|String)\b/, constant: /\b[A-Z][A-Z_\d]*\b/, "class-name": { pattern: /(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/, lookbehind: true }, fragment: { pattern: /(\bfragment\s+|\.{3}\s*(?!on\b))[a-zA-Z_]\w*/, lookbehind: true, alias: "function" }, "definition-mutation": { pattern: /(\bmutation\s+)[a-zA-Z_]\w*/, lookbehind: true, alias: "function" }, "definition-query": { pattern: /(\bquery\s+)[a-zA-Z_]\w*/, lookbehind: true, alias: "function" }, keyword: /\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/, operator: /[!=|&]|\.{3}/, "property-query": /\w+(?=\s*\()/, object: /\w+(?=\s*\{)/, punctuation: /[!(){}\[\]:=,]/, property: /\w+/ }, Prism.hooks.add("after-tokenize", function(e) {
  if ("graphql" === e.language)
    for (var i = e.tokens.filter(function(e2) {
      return "string" != typeof e2 && "comment" !== e2.type && "scalar" !== e2.type;
    }), o = 0; o < i.length; ) {
      var n = i[o++];
      if ("keyword" === n.type && "mutation" === n.content) {
        var t = [];
        if (p(["definition-mutation", "punctuation"]) && "(" === c(1).content) {
          o += 2;
          var a = d(/^\($/, /^\)$/);
          if (-1 === a)
            continue;
          for (; o < a; o++) {
            var r = c(0);
            "variable" === r.type && (g(r, "variable-input"), t.push(r.content));
          }
          o = a + 1;
        }
        if (p(["punctuation", "property-query"]) && "{" === c(0).content && (o++, g(c(0), "property-mutation"), 0 < t.length)) {
          var s = d(/^\{$/, /^\}$/);
          if (-1 !== s)
            for (var l = o; l < s; l++) {
              var u = i[l];
              "variable" === u.type && 0 <= t.indexOf(u.content) && g(u, "variable-input");
            }
        }
      }
    }
  function c(e2) {
    return i[o + e2];
  }
  function p(e2, n2) {
    n2 = n2 || 0;
    for (var t2 = 0; t2 < e2.length; t2++) {
      var a2 = c(t2 + n2);
      if (!a2 || a2.type !== e2[t2])
        return;
    }
    return 1;
  }
  function d(e2, n2) {
    for (var t2 = 1, a2 = o; a2 < i.length; a2++) {
      var r2 = i[a2], s2 = r2.content;
      if ("punctuation" === r2.type && "string" == typeof s2) {
        if (e2.test(s2))
          t2++;
        else if (n2.test(s2) && 0 === --t2)
          return a2;
      }
    }
    return -1;
  }
  function g(e2, n2) {
    var t2 = e2.alias;
    t2 ? Array.isArray(t2) || (e2.alias = t2 = [t2]) : e2.alias = t2 = [], t2.push(n2);
  }
}), Prism.languages.sql = { comment: { pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/, lookbehind: true }, variable: [{ pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/, greedy: true }, /@[\w.$]+/], string: { pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/, greedy: true, lookbehind: true }, identifier: { pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/, greedy: true, lookbehind: true, inside: { punctuation: /^`|`$/ } }, function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i, keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i, boolean: /\b(?:FALSE|NULL|TRUE)\b/i, number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i, operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i, punctuation: /[;[\]()`,.]/ }, function(b) {
  var e = b.languages.javascript["template-string"], t = e.pattern.source, m = e.inside.interpolation, f = m.inside["interpolation-punctuation"], s = m.pattern.source;
  function n(e2, n2) {
    if (b.languages[e2])
      return { pattern: RegExp("((?:" + n2 + ")\\s*)" + t), lookbehind: true, greedy: true, inside: { "template-punctuation": { pattern: /^`|`$/, alias: "string" }, "embedded-code": { pattern: /[\s\S]+/, alias: e2 } } };
  }
  function h(e2, n2, t2) {
    e2 = { code: e2, grammar: n2, language: t2 };
    return b.hooks.run("before-tokenize", e2), e2.tokens = b.tokenize(e2.code, e2.grammar), b.hooks.run("after-tokenize", e2), e2.tokens;
  }
  function l(a2, e2, r) {
    var n2 = b.tokenize(a2, { interpolation: { pattern: RegExp(s), lookbehind: true } }), p = 0, d = {}, n2 = h(n2.map(function(e3) {
      if ("string" == typeof e3)
        return e3;
      for (var n3, t2, e3 = e3.content; -1 !== a2.indexOf((t2 = p++, n3 = "___" + r.toUpperCase() + "_" + t2 + "___")); )
        ;
      return d[n3] = e3, n3;
    }).join(""), e2, r), g = Object.keys(d);
    return p = 0, function e3(n3) {
      for (var t2 = 0; t2 < n3.length; t2++) {
        if (p >= g.length)
          return;
        var a3, r2, s2, i, o, l2, u2, c = n3[t2];
        "string" == typeof c || "string" == typeof c.content ? (a3 = g[p], -1 !== (u2 = (l2 = "string" == typeof c ? c : c.content).indexOf(a3)) && (++p, r2 = l2.substring(0, u2), o = d[a3], s2 = void 0, (i = {})["interpolation-punctuation"] = f, 3 === (i = b.tokenize(o, i)).length && ((s2 = [1, 1]).push.apply(s2, h(i[1], b.languages.javascript, "javascript")), i.splice.apply(i, s2)), s2 = new b.Token("interpolation", i, m.alias, o), i = l2.substring(u2 + a3.length), o = [], r2 && o.push(r2), o.push(s2), i && (e3(l2 = [i]), o.push.apply(o, l2)), "string" == typeof c ? (n3.splice.apply(n3, [t2, 1].concat(o)), t2 += o.length - 1) : c.content = o)) : (u2 = c.content, Array.isArray(u2) ? e3(u2) : e3([u2]));
      }
    }(n2), new b.Token(r, n2, "language-" + r, a2);
  }
  b.languages.javascript["template-string"] = [n("css", /\b(?:styled(?:\([^)]*\))?(?:\s*\.\s*\w+(?:\([^)]*\))*)*|css(?:\s*\.\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source), n("html", /\bhtml|\.\s*(?:inner|outer)HTML\s*\+?=/.source), n("svg", /\bsvg/.source), n("markdown", /\b(?:markdown|md)/.source), n("graphql", /\b(?:gql|graphql(?:\s*\.\s*experimental)?)/.source), n("sql", /\bsql/.source), e].filter(Boolean);
  var a = { javascript: true, js: true, typescript: true, ts: true, jsx: true, tsx: true };
  function u(e2) {
    return "string" == typeof e2 ? e2 : Array.isArray(e2) ? e2.map(u).join("") : u(e2.content);
  }
  b.hooks.add("after-tokenize", function(e2) {
    e2.language in a && !function e3(n2) {
      for (var t2 = 0, a2 = n2.length; t2 < a2; t2++) {
        var r, s2, i, o = n2[t2];
        "string" != typeof o && (r = o.content, Array.isArray(r) ? "template-string" === o.type ? (o = r[1], 3 === r.length && "string" != typeof o && "embedded-code" === o.type && (s2 = u(o), o = o.alias, o = Array.isArray(o) ? o[0] : o, i = b.languages[o]) && (r[1] = l(s2, i, o))) : e3(r) : "string" != typeof r && e3([r]));
      }
    }(e2.tokens);
  });
}(Prism), function(e) {
  e.languages.typescript = e.languages.extend("javascript", { "class-name": { pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/, lookbehind: true, greedy: true, inside: null }, builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/ }), e.languages.typescript.keyword.push(/\b(?:abstract|declare|is|keyof|readonly|require)\b/, /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/, /\btype\b(?=\s*(?:[\{*]|$))/), delete e.languages.typescript.parameter, delete e.languages.typescript["literal-property"];
  var n = e.languages.extend("typescript", {});
  delete n["class-name"], e.languages.typescript["class-name"].inside = n, e.languages.insertBefore("typescript", "function", { decorator: { pattern: /@[$\w\xA0-\uFFFF]+/, inside: { at: { pattern: /^@/, alias: "operator" }, function: /^[\s\S]+/ } }, "generic-function": { pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/, greedy: true, inside: { function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/, generic: { pattern: /<[\s\S]+/, alias: "class-name", inside: n } } } }), e.languages.ts = e.languages.typescript;
}(Prism), function(e) {
  var n = e.languages.javascript, t = /\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})+\}/.source, a = "(@(?:arg|argument|param|property)\\s+(?:" + t + "\\s+)?)";
  e.languages.jsdoc = e.languages.extend("javadoclike", { parameter: { pattern: RegExp(a + /(?:(?!\s)[$\w\xA0-\uFFFF.])+(?=\s|$)/.source), lookbehind: true, inside: { punctuation: /\./ } } }), e.languages.insertBefore("jsdoc", "keyword", { "optional-parameter": { pattern: RegExp(a + /\[(?:(?!\s)[$\w\xA0-\uFFFF.])+(?:=[^[\]]+)?\](?=\s|$)/.source), lookbehind: true, inside: { parameter: { pattern: /(^\[)[$\w\xA0-\uFFFF\.]+/, lookbehind: true, inside: { punctuation: /\./ } }, code: { pattern: /(=)[\s\S]*(?=\]$)/, lookbehind: true, inside: n, alias: "language-javascript" }, punctuation: /[=[\]]/ } }, "class-name": [{ pattern: RegExp(/(@(?:augments|class|extends|interface|memberof!?|template|this|typedef)\s+(?:<TYPE>\s+)?)[A-Z]\w*(?:\.[A-Z]\w*)*/.source.replace(/<TYPE>/g, function() {
    return t;
  })), lookbehind: true, inside: { punctuation: /\./ } }, { pattern: RegExp("(@[a-z]+\\s+)" + t), lookbehind: true, inside: { string: n.string, number: n.number, boolean: n.boolean, keyword: e.languages.typescript.keyword, operator: /=>|\.\.\.|[&|?:*]/, punctuation: /[.,;=<>{}()[\]]/ } }], example: { pattern: /(@example\s+(?!\s))(?:[^@\s]|\s+(?!\s))+?(?=\s*(?:\*\s*)?(?:@\w|\*\/))/, lookbehind: true, inside: { code: { pattern: /^([\t ]*(?:\*\s*)?)\S.*$/m, lookbehind: true, inside: n, alias: "language-javascript" } } } }), e.languages.javadoclike.addSupport("javascript", e.languages.jsdoc);
}(Prism), function(e) {
  e.languages.flow = e.languages.extend("javascript", {}), e.languages.insertBefore("flow", "keyword", { type: [{ pattern: /\b(?:[Bb]oolean|Function|[Nn]umber|[Ss]tring|[Ss]ymbol|any|mixed|null|void)\b/, alias: "class-name" }] }), e.languages.flow["function-variable"].pattern = /(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=\s*(?:function\b|(?:\([^()]*\)(?:\s*:\s*\w+)?|(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/i, delete e.languages.flow.parameter, e.languages.insertBefore("flow", "operator", { "flow-punctuation": { pattern: /\{\||\|\}/, alias: "punctuation" } }), Array.isArray(e.languages.flow.keyword) || (e.languages.flow.keyword = [e.languages.flow.keyword]), e.languages.flow.keyword.unshift({ pattern: /(^|[^$]\b)(?:Class|declare|opaque|type)\b(?!\$)/, lookbehind: true }, { pattern: /(^|[^$]\B)\$(?:Diff|Enum|Exact|Keys|ObjMap|PropertyType|Record|Shape|Subtype|Supertype|await)\b(?!\$)/, lookbehind: true });
}(Prism), Prism.languages.n4js = Prism.languages.extend("javascript", { keyword: /\b(?:Array|any|boolean|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|module|new|null|number|package|private|protected|public|return|set|static|string|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/ }), Prism.languages.insertBefore("n4js", "constant", { annotation: { pattern: /@+\w+/, alias: "operator" } }), Prism.languages.n4jsd = Prism.languages.n4js, function(e) {
  function n(e2, n2) {
    return RegExp(e2.replace(/<ID>/g, function() {
      return /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/.source;
    }), n2);
  }
  e.languages.insertBefore("javascript", "function-variable", { "method-variable": { pattern: RegExp("(\\.\\s*)" + e.languages.javascript["function-variable"].pattern.source), lookbehind: true, alias: ["function-variable", "method", "function", "property-access"] } }), e.languages.insertBefore("javascript", "function", { method: { pattern: RegExp("(\\.\\s*)" + e.languages.javascript.function.source), lookbehind: true, alias: ["function", "property-access"] } }), e.languages.insertBefore("javascript", "constant", { "known-class-name": [{ pattern: /\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\b/, alias: "class-name" }, { pattern: /\b(?:[A-Z]\w*)Error\b/, alias: "class-name" }] }), e.languages.insertBefore("javascript", "keyword", { imports: { pattern: n(/(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/.source), lookbehind: true, inside: e.languages.javascript }, exports: { pattern: n(/(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/.source), lookbehind: true, inside: e.languages.javascript } }), e.languages.javascript.keyword.unshift({ pattern: /\b(?:as|default|export|from|import)\b/, alias: "module" }, { pattern: /\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/, alias: "control-flow" }, { pattern: /\bnull\b/, alias: ["null", "nil"] }, { pattern: /\bundefined\b/, alias: "nil" }), e.languages.insertBefore("javascript", "operator", { spread: { pattern: /\.{3}/, alias: "operator" }, arrow: { pattern: /=>/, alias: "operator" } }), e.languages.insertBefore("javascript", "punctuation", { "property-access": { pattern: n(/(\.\s*)#?<ID>/.source), lookbehind: true }, "maybe-class-name": { pattern: /(^|[^$\w\xA0-\uFFFF])[A-Z][$\w\xA0-\uFFFF]+/, lookbehind: true }, dom: { pattern: /\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\b/, alias: "variable" }, console: { pattern: /\bconsole(?=\s*\.)/, alias: "class-name" } });
  for (var t = ["function", "function-variable", "method", "method-variable", "property-access"], a = 0; a < t.length; a++) {
    var r = t[a], s = e.languages.javascript[r], r = (s = "RegExp" === e.util.type(s) ? e.languages.javascript[r] = { pattern: s } : s).inside || {};
    (s.inside = r)["maybe-class-name"] = /^[A-Z][\s\S]*/;
  }
}(Prism), function(s) {
  var e = s.util.clone(s.languages.javascript), t = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source, a = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source, r = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
  function n(e2, n2) {
    return e2 = e2.replace(/<S>/g, function() {
      return t;
    }).replace(/<BRACES>/g, function() {
      return a;
    }).replace(/<SPREAD>/g, function() {
      return r;
    }), RegExp(e2, n2);
  }
  r = n(r).source, s.languages.jsx = s.languages.extend("markup", e), s.languages.jsx.tag.pattern = n(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source), s.languages.jsx.tag.inside.tag.pattern = /^<\/?[^\s>\/]*/, s.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/, s.languages.jsx.tag.inside.tag.inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/, s.languages.jsx.tag.inside.comment = e.comment, s.languages.insertBefore("inside", "attr-name", { spread: { pattern: n(/<SPREAD>/.source), inside: s.languages.jsx } }, s.languages.jsx.tag), s.languages.insertBefore("inside", "special-attr", { script: { pattern: n(/=<BRACES>/.source), alias: "language-javascript", inside: { "script-punctuation": { pattern: /^=(?=\{)/, alias: "punctuation" }, rest: s.languages.jsx } } }, s.languages.jsx.tag);
  function i(e2) {
    for (var n2 = [], t2 = 0; t2 < e2.length; t2++) {
      var a2 = e2[t2], r2 = false;
      "string" != typeof a2 && ("tag" === a2.type && a2.content[0] && "tag" === a2.content[0].type ? "</" === a2.content[0].content[0].content ? 0 < n2.length && n2[n2.length - 1].tagName === o(a2.content[0].content[1]) && n2.pop() : "/>" !== a2.content[a2.content.length - 1].content && n2.push({ tagName: o(a2.content[0].content[1]), openedBraces: 0 }) : 0 < n2.length && "punctuation" === a2.type && "{" === a2.content ? n2[n2.length - 1].openedBraces++ : 0 < n2.length && 0 < n2[n2.length - 1].openedBraces && "punctuation" === a2.type && "}" === a2.content ? n2[n2.length - 1].openedBraces-- : r2 = true), (r2 || "string" == typeof a2) && 0 < n2.length && 0 === n2[n2.length - 1].openedBraces && (r2 = o(a2), t2 < e2.length - 1 && ("string" == typeof e2[t2 + 1] || "plain-text" === e2[t2 + 1].type) && (r2 += o(e2[t2 + 1]), e2.splice(t2 + 1, 1)), 0 < t2 && ("string" == typeof e2[t2 - 1] || "plain-text" === e2[t2 - 1].type) && (r2 = o(e2[t2 - 1]) + r2, e2.splice(t2 - 1, 1), t2--), e2[t2] = new s.Token("plain-text", r2, null, r2)), a2.content && "string" != typeof a2.content && i(a2.content);
    }
  }
  var o = function(e2) {
    return e2 ? "string" == typeof e2 ? e2 : "string" == typeof e2.content ? e2.content : e2.content.map(o).join("") : "";
  };
  s.hooks.add("after-tokenize", function(e2) {
    "jsx" !== e2.language && "tsx" !== e2.language || i(e2.tokens);
  });
}(Prism), function(e) {
  var n = e.util.clone(e.languages.typescript), n = (e.languages.tsx = e.languages.extend("jsx", n), delete e.languages.tsx.parameter, delete e.languages.tsx["literal-property"], e.languages.tsx.tag);
  n.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + "(?:" + n.pattern.source + ")", n.pattern.flags), n.lookbehind = true;
}(Prism), Prism.languages.swift = { comment: { pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/, lookbehind: true, greedy: true }, "string-literal": [{ pattern: RegExp(/(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source), lookbehind: true, greedy: true, inside: { interpolation: { pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/, lookbehind: true, inside: null }, "interpolation-punctuation": { pattern: /^\)|\\\($/, alias: "punctuation" }, punctuation: /\\(?=[\r\n])/, string: /[\s\S]+/ } }, { pattern: RegExp(/(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"), lookbehind: true, greedy: true, inside: { interpolation: { pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/, lookbehind: true, inside: null }, "interpolation-punctuation": { pattern: /^\)|\\#+\($/, alias: "punctuation" }, string: /[\s\S]+/ } }], directive: { pattern: RegExp(/#/.source + "(?:" + /(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+|" + /(?:else|endif)\b/.source + ")"), alias: "property", inside: { "directive-name": /^#\w+/, boolean: /\b(?:false|true)\b/, number: /\b\d+(?:\.\d+)*\b/, operator: /!|&&|\|\||[<>]=?/, punctuation: /[(),]/ } }, literal: { pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/, alias: "constant" }, "other-directive": { pattern: /#\w+\b/, alias: "property" }, attribute: { pattern: /@\w+/, alias: "atrule" }, "function-definition": { pattern: /(\bfunc\s+)\w+/, lookbehind: true, alias: "function" }, label: { pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/, lookbehind: true, alias: "important" }, keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/, boolean: /\b(?:false|true)\b/, nil: { pattern: /\bnil\b/, alias: "constant" }, "short-argument": /\$\d+\b/, omit: { pattern: /\b_\b/, alias: "keyword" }, number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i, "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/, function: /\b[a-z_]\w*(?=\s*\()/i, constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/, operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/, punctuation: /[{}[\]();,.:\\]/ }, Prism.languages.swift["string-literal"].forEach(function(e) {
  e.inside.interpolation.inside = Prism.languages.swift;
}), function(e) {
  e.languages.kotlin = e.languages.extend("clike", { keyword: { pattern: /(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/, lookbehind: true }, function: [{ pattern: /(?:`[^\r\n`]+`|\b\w+)(?=\s*\()/, greedy: true }, { pattern: /(\.)(?:`[^\r\n`]+`|\w+)(?=\s*\{)/, lookbehind: true, greedy: true }], number: /\b(?:0[xX][\da-fA-F]+(?:_[\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/, operator: /\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/ }), delete e.languages.kotlin["class-name"];
  var n = { "interpolation-punctuation": { pattern: /^\$\{?|\}$/, alias: "punctuation" }, expression: { pattern: /[\s\S]+/, inside: e.languages.kotlin } };
  e.languages.insertBefore("kotlin", "string", { "string-literal": [{ pattern: /"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/, alias: "multiline", inside: { interpolation: { pattern: /\$(?:[a-z_]\w*|\{[^{}]*\})/i, inside: n }, string: /[\s\S]+/ } }, { pattern: /"(?:[^"\\\r\n$]|\\.|\$(?:(?!\{)|\{[^{}]*\}))*"/, alias: "singleline", inside: { interpolation: { pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:[a-z_]\w*|\{[^{}]*\})/i, lookbehind: true, inside: n }, string: /[\s\S]+/ } }], char: { pattern: /'(?:[^'\\\r\n]|\\(?:.|u[a-fA-F0-9]{0,4}))'/, greedy: true } }), delete e.languages.kotlin.string, e.languages.insertBefore("kotlin", "keyword", { annotation: { pattern: /\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/, alias: "builtin" } }), e.languages.insertBefore("kotlin", "function", { label: { pattern: /\b\w+@|@\w+\b/, alias: "symbol" } }), e.languages.kt = e.languages.kotlin, e.languages.kts = e.languages.kotlin;
}(Prism), Prism.languages.c = Prism.languages.extend("clike", { comment: { pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/, greedy: true }, string: { pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/, greedy: true }, "class-name": { pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/, lookbehind: true }, keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/, function: /\b[a-z_]\w*(?=\s*\()/i, number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i, operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/ }), Prism.languages.insertBefore("c", "string", { char: { pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/, greedy: true } }), Prism.languages.insertBefore("c", "string", { macro: { pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im, lookbehind: true, greedy: true, alias: "property", inside: { string: [{ pattern: /^(#\s*include\s*)<[^>]+>/, lookbehind: true }, Prism.languages.c.string], char: Prism.languages.c.char, comment: Prism.languages.c.comment, "macro-name": [{ pattern: /(^#\s*define\s+)\w+\b(?!\()/i, lookbehind: true }, { pattern: /(^#\s*define\s+)\w+\b(?=\()/i, lookbehind: true, alias: "function" }], directive: { pattern: /^(#\s*)[a-z]+/, lookbehind: true, alias: "keyword" }, "directive-hash": /^#/, punctuation: /##|\\(?=[\r\n])/, expression: { pattern: /\S[\s\S]*/, inside: Prism.languages.c } } } }), Prism.languages.insertBefore("c", "function", { constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/ }), delete Prism.languages.c.boolean, Prism.languages.objectivec = Prism.languages.extend("c", { string: { pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/, greedy: true }, keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/, operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/ }), delete Prism.languages.objectivec["class-name"], Prism.languages.objc = Prism.languages.objectivec, Prism.languages.reason = Prism.languages.extend("clike", { string: { pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/, greedy: true }, "class-name": /\b[A-Z]\w*/, keyword: /\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\b/, operator: /\.{3}|:[:=]|\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\-*\/]\.?|\b(?:asr|land|lor|lsl|lsr|lxor|mod)\b/ }), Prism.languages.insertBefore("reason", "class-name", { char: { pattern: /'(?:\\x[\da-f]{2}|\\o[0-3][0-7][0-7]|\\\d{3}|\\.|[^'\\\r\n])'/, greedy: true }, constructor: /\b[A-Z]\w*\b(?!\s*\.)/, label: { pattern: /\b[a-z]\w*(?=::)/, alias: "symbol" } }), delete Prism.languages.reason.function, function(e) {
  for (var n = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source, t = 0; t < 2; t++)
    n = n.replace(/<self>/g, function() {
      return n;
    });
  n = n.replace(/<self>/g, function() {
    return /[^\s\S]/.source;
  }), e.languages.rust = { comment: [{ pattern: RegExp(/(^|[^\\])/.source + n), lookbehind: true, greedy: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/, greedy: true }, char: { pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/, greedy: true }, attribute: { pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/, greedy: true, alias: "attr-name", inside: { string: null } }, "closure-params": { pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/, lookbehind: true, greedy: true, inside: { "closure-punctuation": { pattern: /^\||\|$/, alias: "punctuation" }, rest: null } }, "lifetime-annotation": { pattern: /'\w+/, alias: "symbol" }, "fragment-specifier": { pattern: /(\$\w+:)[a-z]+/, lookbehind: true, alias: "punctuation" }, variable: /\$\w+/, "function-definition": { pattern: /(\bfn\s+)\w+/, lookbehind: true, alias: "function" }, "type-definition": { pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/, lookbehind: true, alias: "class-name" }, "module-declaration": [{ pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/, lookbehind: true, alias: "namespace" }, { pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/, lookbehind: true, alias: "namespace", inside: { punctuation: /::/ } }], keyword: [/\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/, /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/], function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/, macro: { pattern: /\b\w+!/, alias: "property" }, constant: /\b[A-Z_][A-Z_\d]+\b/, "class-name": /\b[A-Z]\w*\b/, namespace: { pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/, inside: { punctuation: /::/ } }, number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/, boolean: /\b(?:false|true)\b/, punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/, operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/ }, e.languages.rust["closure-params"].inside.rest = e.languages.rust, e.languages.rust.attribute.inside.string = e.languages.rust.string;
}(Prism), Prism.languages.go = Prism.languages.extend("clike", { string: { pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/, lookbehind: true, greedy: true }, keyword: /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/, boolean: /\b(?:_|false|iota|nil|true)\b/, number: [/\b0(?:b[01_]+|o[0-7_]+)i?\b/i, /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i, /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i], operator: /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./, builtin: /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/ }), Prism.languages.insertBefore("go", "string", { char: { pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/, greedy: true } }), delete Prism.languages.go["class-name"], function(e) {
  var n = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, t = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
    return n.source;
  });
  e.languages.cpp = e.languages.extend("c", { "class-name": [{ pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
    return n.source;
  })), lookbehind: true }, /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/, /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i, /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/], keyword: n, number: { pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i, greedy: true }, operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/, boolean: /\b(?:false|true)\b/ }), e.languages.insertBefore("cpp", "string", { module: { pattern: RegExp(/(\b(?:import|module)\s+)/.source + "(?:" + /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
    return t;
  }) + ")"), lookbehind: true, greedy: true, inside: { string: /^[<"][\s\S]+/, operator: /:/, punctuation: /\./ } }, "raw-string": { pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/, alias: "string", greedy: true } }), e.languages.insertBefore("cpp", "keyword", { "generic-function": { pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i, inside: { function: /^\w+/, generic: { pattern: /<[\s\S]+/, alias: "class-name", inside: e.languages.cpp } } } }), e.languages.insertBefore("cpp", "operator", { "double-colon": { pattern: /::/, alias: "punctuation" } }), e.languages.insertBefore("cpp", "class-name", { "base-clause": { pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/, lookbehind: true, greedy: true, inside: e.languages.extend("cpp", {}) } }), e.languages.insertBefore("inside", "double-colon", { "class-name": /\b[a-z_]\w*\b(?!\s*::)/i }, e.languages.cpp["base-clause"]);
}(Prism), Prism.languages.python = { comment: { pattern: /(^|[^\\])#.*/, lookbehind: true, greedy: true }, "string-interpolation": { pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i, greedy: true, inside: { interpolation: { pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/, lookbehind: true, inside: { "format-spec": { pattern: /(:)[^:(){}]+(?=\}$)/, lookbehind: true }, "conversion-option": { pattern: /![sra](?=[:}]$)/, alias: "punctuation" }, rest: null } }, string: /[\s\S]+/ } }, "triple-quoted-string": { pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i, greedy: true, alias: "string" }, string: { pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i, greedy: true }, function: { pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g, lookbehind: true }, "class-name": { pattern: /(\bclass\s+)\w+/i, lookbehind: true }, decorator: { pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m, lookbehind: true, alias: ["annotation", "punctuation"], inside: { punctuation: /\./ } }, keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/, builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/, boolean: /\b(?:False|None|True)\b/, number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i, operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/, punctuation: /[{}[\];(),.:]/ }, Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest = Prism.languages.python, Prism.languages.py = Prism.languages.python, Prism.languages.json = { property: { pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/, lookbehind: true, greedy: true }, string: { pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/, lookbehind: true, greedy: true }, comment: { pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/, greedy: true }, number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i, punctuation: /[{}[\],]/, operator: /:/, boolean: /\b(?:false|true)\b/, null: { pattern: /\bnull\b/, alias: "keyword" } }, Prism.languages.webmanifest = Prism.languages.json;

// src/themes/index.ts
var themes_exports = {};
__export(themes_exports, {
  dracula: () => dracula_default,
  duotoneDark: () => duotoneDark_default,
  duotoneLight: () => duotoneLight_default,
  github: () => github_default,
  gruvboxMaterialDark: () => gruvboxMaterialDark_default,
  gruvboxMaterialLight: () => gruvboxMaterialLight_default,
  jettwaveDark: () => jettwaveDark_default,
  jettwaveLight: () => jettwaveLight_default,
  nightOwl: () => nightOwl_default,
  nightOwlLight: () => nightOwlLight_default,
  oceanicNext: () => oceanicNext_default,
  okaidia: () => okaidia_default,
  oneDark: () => oneDark_default,
  oneLight: () => oneLight_default,
  palenight: () => palenight_default,
  shadesOfPurple: () => shadesOfPurple_default,
  synthwave84: () => synthwave84_default,
  ultramin: () => ultramin_default,
  vsDark: () => vsDark_default,
  vsLight: () => vsLight_default
});

// src/themes/dracula.ts
var theme = {
  plain: {
    color: "#F8F8F2",
    backgroundColor: "#282A36"
  },
  styles: [
    {
      types: ["prolog", "constant", "builtin"],
      style: {
        color: "rgb(189, 147, 249)"
      }
    },
    {
      types: ["inserted", "function"],
      style: {
        color: "rgb(80, 250, 123)"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "rgb(255, 85, 85)"
      }
    },
    {
      types: ["changed"],
      style: {
        color: "rgb(255, 184, 108)"
      }
    },
    {
      types: ["punctuation", "symbol"],
      style: {
        color: "rgb(248, 248, 242)"
      }
    },
    {
      types: ["string", "char", "tag", "selector"],
      style: {
        color: "rgb(255, 121, 198)"
      }
    },
    {
      types: ["keyword", "variable"],
      style: {
        color: "rgb(189, 147, 249)",
        fontStyle: "italic"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(98, 114, 164)"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "rgb(241, 250, 140)"
      }
    }
  ]
};
var dracula_default = theme;

// src/themes/duotoneDark.ts
var theme2 = {
  plain: {
    backgroundColor: "#2a2734",
    color: "#9a86fd"
  },
  styles: [
    {
      types: ["comment", "prolog", "doctype", "cdata", "punctuation"],
      style: {
        color: "#6c6783"
      }
    },
    {
      types: ["namespace"],
      style: {
        opacity: 0.7
      }
    },
    {
      types: ["tag", "operator", "number"],
      style: {
        color: "#e09142"
      }
    },
    {
      types: ["property", "function"],
      style: {
        color: "#9a86fd"
      }
    },
    {
      types: ["tag-id", "selector", "atrule-id"],
      style: {
        color: "#eeebff"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "#c4b9fe"
      }
    },
    {
      types: [
        "boolean",
        "string",
        "entity",
        "url",
        "attr-value",
        "keyword",
        "control",
        "directive",
        "unit",
        "statement",
        "regex",
        "atrule",
        "placeholder",
        "variable"
      ],
      style: {
        color: "#ffcc99"
      }
    },
    {
      types: ["deleted"],
      style: {
        textDecorationLine: "line-through"
      }
    },
    {
      types: ["inserted"],
      style: {
        textDecorationLine: "underline"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["important"],
      style: {
        color: "#c4b9fe"
      }
    }
  ]
};
var duotoneDark_default = theme2;

// src/themes/duotoneLight.ts
var theme3 = {
  plain: {
    backgroundColor: "#faf8f5",
    color: "#728fcb"
  },
  styles: [
    {
      types: ["comment", "prolog", "doctype", "cdata", "punctuation"],
      style: {
        color: "#b6ad9a"
      }
    },
    {
      types: ["namespace"],
      style: {
        opacity: 0.7
      }
    },
    {
      types: ["tag", "operator", "number"],
      style: {
        color: "#063289"
      }
    },
    {
      types: ["property", "function"],
      style: {
        color: "#b29762"
      }
    },
    {
      types: ["tag-id", "selector", "atrule-id"],
      style: {
        color: "#2d2006"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "#896724"
      }
    },
    {
      types: [
        "boolean",
        "string",
        "entity",
        "url",
        "attr-value",
        "keyword",
        "control",
        "directive",
        "unit",
        "statement",
        "regex",
        "atrule"
      ],
      style: {
        color: "#728fcb"
      }
    },
    {
      types: ["placeholder", "variable"],
      style: {
        color: "#93abdc"
      }
    },
    {
      types: ["deleted"],
      style: {
        textDecorationLine: "line-through"
      }
    },
    {
      types: ["inserted"],
      style: {
        textDecorationLine: "underline"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["important"],
      style: {
        color: "#896724"
      }
    }
  ]
};
var duotoneLight_default = theme3;

// src/themes/github.ts
var theme4 = {
  plain: {
    color: "#393A34",
    backgroundColor: "#f6f8fa"
  },
  styles: [
    {
      types: ["comment", "prolog", "doctype", "cdata"],
      style: {
        color: "#999988",
        fontStyle: "italic"
      }
    },
    {
      types: ["namespace"],
      style: {
        opacity: 0.7
      }
    },
    {
      types: ["string", "attr-value"],
      style: {
        color: "#e3116c"
      }
    },
    {
      types: ["punctuation", "operator"],
      style: {
        color: "#393A34"
      }
    },
    {
      types: [
        "entity",
        "url",
        "symbol",
        "number",
        "boolean",
        "variable",
        "constant",
        "property",
        "regex",
        "inserted"
      ],
      style: {
        color: "#36acaa"
      }
    },
    {
      types: ["atrule", "keyword", "attr-name", "selector"],
      style: {
        color: "#00a4db"
      }
    },
    {
      types: ["function", "deleted", "tag"],
      style: {
        color: "#d73a49"
      }
    },
    {
      types: ["function-variable"],
      style: {
        color: "#6f42c1"
      }
    },
    {
      types: ["tag", "selector", "keyword"],
      style: {
        color: "#00009f"
      }
    }
  ]
};
var github_default = theme4;

// src/themes/nightOwl.ts
var theme5 = {
  plain: {
    color: "#d6deeb",
    backgroundColor: "#011627"
  },
  styles: [
    {
      types: ["changed"],
      style: {
        color: "rgb(162, 191, 252)",
        fontStyle: "italic"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "rgba(239, 83, 80, 0.56)",
        fontStyle: "italic"
      }
    },
    {
      types: ["inserted", "attr-name"],
      style: {
        color: "rgb(173, 219, 103)",
        fontStyle: "italic"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(99, 119, 119)",
        fontStyle: "italic"
      }
    },
    {
      types: ["string", "url"],
      style: {
        color: "rgb(173, 219, 103)"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "rgb(214, 222, 235)"
      }
    },
    {
      types: ["number"],
      style: {
        color: "rgb(247, 140, 108)"
      }
    },
    {
      types: ["builtin", "char", "constant", "function"],
      style: {
        color: "rgb(130, 170, 255)"
      }
    },
    {
      // This was manually added after the auto-generation
      // so that punctuations are not italicised
      types: ["punctuation"],
      style: {
        color: "rgb(199, 146, 234)"
      }
    },
    {
      types: ["selector", "doctype"],
      style: {
        color: "rgb(199, 146, 234)",
        fontStyle: "italic"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "rgb(255, 203, 139)"
      }
    },
    {
      types: ["tag", "operator", "keyword"],
      style: {
        color: "rgb(127, 219, 202)"
      }
    },
    {
      types: ["boolean"],
      style: {
        color: "rgb(255, 88, 116)"
      }
    },
    {
      types: ["property"],
      style: {
        color: "rgb(128, 203, 196)"
      }
    },
    {
      types: ["namespace"],
      style: {
        color: "rgb(178, 204, 214)"
      }
    }
  ]
};
var nightOwl_default = theme5;

// src/themes/nightOwlLight.ts
var theme6 = {
  plain: {
    color: "#403f53",
    backgroundColor: "#FBFBFB"
  },
  styles: [
    {
      types: ["changed"],
      style: {
        color: "rgb(162, 191, 252)",
        fontStyle: "italic"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "rgba(239, 83, 80, 0.56)",
        fontStyle: "italic"
      }
    },
    {
      types: ["inserted", "attr-name"],
      style: {
        color: "rgb(72, 118, 214)",
        fontStyle: "italic"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(152, 159, 177)",
        fontStyle: "italic"
      }
    },
    {
      types: ["string", "builtin", "char", "constant", "url"],
      style: {
        color: "rgb(72, 118, 214)"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "rgb(201, 103, 101)"
      }
    },
    {
      types: ["number"],
      style: {
        color: "rgb(170, 9, 130)"
      }
    },
    {
      // This was manually added after the auto-generation
      // so that punctuations are not italicised
      types: ["punctuation"],
      style: {
        color: "rgb(153, 76, 195)"
      }
    },
    {
      types: ["function", "selector", "doctype"],
      style: {
        color: "rgb(153, 76, 195)",
        fontStyle: "italic"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "rgb(17, 17, 17)"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "rgb(153, 76, 195)"
      }
    },
    {
      types: ["operator", "property", "keyword", "namespace"],
      style: {
        color: "rgb(12, 150, 155)"
      }
    },
    {
      types: ["boolean"],
      style: {
        color: "rgb(188, 84, 84)"
      }
    }
  ]
};
var nightOwlLight_default = theme6;

// src/themes/oceanicNext.ts
var colors = {
  char: "#D8DEE9",
  comment: "#999999",
  keyword: "#c5a5c5",
  primitive: "#5a9bcf",
  string: "#8dc891",
  variable: "#d7deea",
  boolean: "#ff8b50",
  punctuation: "#5FB3B3",
  tag: "#fc929e",
  function: "#79b6f2",
  className: "#FAC863",
  method: "#6699CC",
  operator: "#fc929e"
};
var theme7 = {
  plain: {
    backgroundColor: "#282c34",
    color: "#ffffff"
  },
  styles: [
    {
      types: ["attr-name"],
      style: {
        color: colors.keyword
      }
    },
    {
      types: ["attr-value"],
      style: {
        color: colors.string
      }
    },
    {
      types: [
        "comment",
        "block-comment",
        "prolog",
        "doctype",
        "cdata",
        "shebang"
      ],
      style: {
        color: colors.comment
      }
    },
    {
      types: [
        "property",
        "number",
        "function-name",
        "constant",
        "symbol",
        "deleted"
      ],
      style: {
        color: colors.primitive
      }
    },
    {
      types: ["boolean"],
      style: {
        color: colors.boolean
      }
    },
    {
      types: ["tag"],
      style: {
        color: colors.tag
      }
    },
    {
      types: ["string"],
      style: {
        color: colors.string
      }
    },
    {
      types: ["punctuation"],
      style: {
        color: colors.string
      }
    },
    {
      types: ["selector", "char", "builtin", "inserted"],
      style: {
        color: colors.char
      }
    },
    {
      types: ["function"],
      style: {
        color: colors.function
      }
    },
    {
      types: ["operator", "entity", "url", "variable"],
      style: {
        color: colors.variable
      }
    },
    {
      types: ["keyword"],
      style: {
        color: colors.keyword
      }
    },
    {
      types: ["atrule", "class-name"],
      style: {
        color: colors.className
      }
    },
    {
      types: ["important"],
      style: {
        fontWeight: "400"
      }
    },
    {
      types: ["bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["namespace"],
      style: {
        opacity: 0.7
      }
    }
  ]
};
var oceanicNext_default = theme7;

// src/themes/okaidia.ts
var theme8 = {
  plain: {
    color: "#f8f8f2",
    backgroundColor: "#272822"
  },
  styles: [
    {
      types: ["changed"],
      style: {
        color: "rgb(162, 191, 252)",
        fontStyle: "italic"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "#f92672",
        fontStyle: "italic"
      }
    },
    {
      types: ["inserted"],
      style: {
        color: "rgb(173, 219, 103)",
        fontStyle: "italic"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "#8292a2",
        fontStyle: "italic"
      }
    },
    {
      types: ["string", "url"],
      style: {
        color: "#a6e22e"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "#f8f8f2"
      }
    },
    {
      types: ["number"],
      style: {
        color: "#ae81ff"
      }
    },
    {
      types: ["builtin", "char", "constant", "function", "class-name"],
      style: {
        color: "#e6db74"
      }
    },
    {
      types: ["punctuation"],
      style: {
        color: "#f8f8f2"
      }
    },
    {
      types: ["selector", "doctype"],
      style: {
        color: "#a6e22e",
        fontStyle: "italic"
      }
    },
    {
      types: ["tag", "operator", "keyword"],
      style: {
        color: "#66d9ef"
      }
    },
    {
      types: ["boolean"],
      style: {
        color: "#ae81ff"
      }
    },
    {
      types: ["namespace"],
      style: {
        color: "rgb(178, 204, 214)",
        opacity: 0.7
      }
    },
    {
      types: ["tag", "property"],
      style: {
        color: "#f92672"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "#a6e22e !important"
      }
    },
    {
      types: ["doctype"],
      style: {
        color: "#8292a2"
      }
    },
    {
      types: ["rule"],
      style: {
        color: "#e6db74"
      }
    }
  ]
};
var okaidia_default = theme8;

// src/themes/palenight.ts
var theme9 = {
  plain: {
    color: "#bfc7d5",
    backgroundColor: "#292d3e"
  },
  styles: [
    {
      types: ["comment"],
      style: {
        color: "rgb(105, 112, 152)",
        fontStyle: "italic"
      }
    },
    {
      types: ["string", "inserted"],
      style: {
        color: "rgb(195, 232, 141)"
      }
    },
    {
      types: ["number"],
      style: {
        color: "rgb(247, 140, 108)"
      }
    },
    {
      types: ["builtin", "char", "constant", "function"],
      style: {
        color: "rgb(130, 170, 255)"
      }
    },
    {
      types: ["punctuation", "selector"],
      style: {
        color: "rgb(199, 146, 234)"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "rgb(191, 199, 213)"
      }
    },
    {
      types: ["class-name", "attr-name"],
      style: {
        color: "rgb(255, 203, 107)"
      }
    },
    {
      types: ["tag", "deleted"],
      style: {
        color: "rgb(255, 85, 114)"
      }
    },
    {
      types: ["operator"],
      style: {
        color: "rgb(137, 221, 255)"
      }
    },
    {
      types: ["boolean"],
      style: {
        color: "rgb(255, 88, 116)"
      }
    },
    {
      types: ["keyword"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["doctype"],
      style: {
        color: "rgb(199, 146, 234)",
        fontStyle: "italic"
      }
    },
    {
      types: ["namespace"],
      style: {
        color: "rgb(178, 204, 214)"
      }
    },
    {
      types: ["url"],
      style: {
        color: "rgb(221, 221, 221)"
      }
    }
  ]
};
var palenight_default = theme9;

// src/themes/shadesOfPurple.ts
var theme10 = {
  plain: {
    color: "#9EFEFF",
    backgroundColor: "#2D2A55"
  },
  styles: [
    {
      types: ["changed"],
      style: {
        color: "rgb(255, 238, 128)"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "rgba(239, 83, 80, 0.56)"
      }
    },
    {
      types: ["inserted"],
      style: {
        color: "rgb(173, 219, 103)"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(179, 98, 255)",
        fontStyle: "italic"
      }
    },
    {
      types: ["punctuation"],
      style: {
        color: "rgb(255, 255, 255)"
      }
    },
    {
      types: ["constant"],
      style: {
        color: "rgb(255, 98, 140)"
      }
    },
    {
      types: ["string", "url"],
      style: {
        color: "rgb(165, 255, 144)"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "rgb(255, 238, 128)"
      }
    },
    {
      types: ["number", "boolean"],
      style: {
        color: "rgb(255, 98, 140)"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "rgb(255, 180, 84)"
      }
    },
    {
      types: [
        "keyword",
        "operator",
        "property",
        "namespace",
        "tag",
        "selector",
        "doctype"
      ],
      style: {
        color: "rgb(255, 157, 0)"
      }
    },
    {
      types: ["builtin", "char", "constant", "function", "class-name"],
      style: {
        color: "rgb(250, 208, 0)"
      }
    }
  ]
};
var shadesOfPurple_default = theme10;

// src/themes/synthwave84.ts
var theme11 = {
  plain: {
    backgroundColor: "linear-gradient(to bottom, #2a2139 75%, #34294f)",
    backgroundImage: "#34294f",
    color: "#f92aad",
    textShadow: "0 0 2px #100c0f, 0 0 5px #dc078e33, 0 0 10px #fff3"
  },
  styles: [
    {
      types: ["comment", "block-comment", "prolog", "doctype", "cdata"],
      style: {
        color: "#495495",
        fontStyle: "italic"
      }
    },
    {
      types: ["punctuation"],
      style: {
        color: "#ccc"
      }
    },
    {
      types: [
        "tag",
        "attr-name",
        "namespace",
        "number",
        "unit",
        "hexcode",
        "deleted"
      ],
      style: {
        color: "#e2777a"
      }
    },
    {
      types: ["property", "selector"],
      style: {
        color: "#72f1b8",
        textShadow: "0 0 2px #100c0f, 0 0 10px #257c5575, 0 0 35px #21272475"
      }
    },
    {
      types: ["function-name"],
      style: {
        color: "#6196cc"
      }
    },
    {
      types: ["boolean", "selector-id", "function"],
      style: {
        color: "#fdfdfd",
        textShadow: "0 0 2px #001716, 0 0 3px #03edf975, 0 0 5px #03edf975, 0 0 8px #03edf975"
      }
    },
    {
      types: ["class-name", "maybe-class-name", "builtin"],
      style: {
        color: "#fff5f6",
        textShadow: "0 0 2px #000, 0 0 10px #fc1f2c75, 0 0 5px #fc1f2c75, 0 0 25px #fc1f2c75"
      }
    },
    {
      types: ["constant", "symbol"],
      style: {
        color: "#f92aad",
        textShadow: "0 0 2px #100c0f, 0 0 5px #dc078e33, 0 0 10px #fff3"
      }
    },
    {
      types: ["important", "atrule", "keyword", "selector-class"],
      style: {
        color: "#f4eee4",
        textShadow: "0 0 2px #393a33, 0 0 8px #f39f0575, 0 0 2px #f39f0575"
      }
    },
    {
      types: ["string", "char", "attr-value", "regex", "variable"],
      style: {
        color: "#f87c32"
      }
    },
    {
      types: ["parameter"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["entity", "url"],
      style: {
        color: "#67cdcc"
      }
    },
    {
      types: ["operator"],
      style: {
        color: "ffffffee"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["entity"],
      style: {
        cursor: "help"
      }
    },
    {
      types: ["inserted"],
      style: {
        color: "green"
      }
    }
  ]
};
var synthwave84_default = theme11;

// src/themes/ultramin.ts
var theme12 = {
  plain: {
    color: "#282a2e",
    backgroundColor: "#ffffff"
  },
  styles: [
    {
      types: ["comment"],
      style: {
        color: "rgb(197, 200, 198)"
      }
    },
    {
      types: ["string", "number", "builtin", "variable"],
      style: {
        color: "rgb(150, 152, 150)"
      }
    },
    {
      types: ["class-name", "function", "tag", "attr-name"],
      style: {
        color: "rgb(40, 42, 46)"
      }
    }
  ]
};
var ultramin_default = theme12;

// src/themes/vsDark.ts
var theme13 = {
  plain: {
    color: "#9CDCFE",
    backgroundColor: "#1E1E1E"
  },
  styles: [
    {
      types: ["prolog"],
      style: {
        color: "rgb(0, 0, 128)"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(106, 153, 85)"
      }
    },
    {
      types: ["builtin", "changed", "keyword", "interpolation-punctuation"],
      style: {
        color: "rgb(86, 156, 214)"
      }
    },
    {
      types: ["number", "inserted"],
      style: {
        color: "rgb(181, 206, 168)"
      }
    },
    {
      types: ["constant"],
      style: {
        color: "rgb(100, 102, 149)"
      }
    },
    {
      types: ["attr-name", "variable"],
      style: {
        color: "rgb(156, 220, 254)"
      }
    },
    {
      types: ["deleted", "string", "attr-value", "template-punctuation"],
      style: {
        color: "rgb(206, 145, 120)"
      }
    },
    {
      types: ["selector"],
      style: {
        color: "rgb(215, 186, 125)"
      }
    },
    {
      // Fix tag color
      types: ["tag"],
      style: {
        color: "rgb(78, 201, 176)"
      }
    },
    {
      // Fix tag color for HTML
      types: ["tag"],
      languages: ["markup"],
      style: {
        color: "rgb(86, 156, 214)"
      }
    },
    {
      types: ["punctuation", "operator"],
      style: {
        color: "rgb(212, 212, 212)"
      }
    },
    {
      // Fix punctuation color for HTML
      types: ["punctuation"],
      languages: ["markup"],
      style: {
        color: "#808080"
      }
    },
    {
      types: ["function"],
      style: {
        color: "rgb(220, 220, 170)"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "rgb(78, 201, 176)"
      }
    },
    {
      types: ["char"],
      style: {
        color: "rgb(209, 105, 105)"
      }
    }
  ]
};
var vsDark_default = theme13;

// src/themes/vsLight.ts
var theme14 = {
  plain: {
    color: "#000000",
    backgroundColor: "#ffffff"
  },
  styles: [
    {
      types: ["comment"],
      style: {
        color: "rgb(0, 128, 0)"
      }
    },
    {
      types: ["builtin"],
      style: {
        color: "rgb(0, 112, 193)"
      }
    },
    {
      types: ["number", "variable", "inserted"],
      style: {
        color: "rgb(9, 134, 88)"
      }
    },
    {
      types: ["operator"],
      style: {
        color: "rgb(0, 0, 0)"
      }
    },
    {
      types: ["constant", "char"],
      style: {
        color: "rgb(129, 31, 63)"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "rgb(128, 0, 0)"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "rgb(255, 0, 0)"
      }
    },
    {
      types: ["deleted", "string"],
      style: {
        color: "rgb(163, 21, 21)"
      }
    },
    {
      types: ["changed", "punctuation"],
      style: {
        color: "rgb(4, 81, 165)"
      }
    },
    {
      types: ["function", "keyword"],
      style: {
        color: "rgb(0, 0, 255)"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "rgb(38, 127, 153)"
      }
    }
  ]
};
var vsLight_default = theme14;

// src/themes/jettwaveDark.ts
var theme15 = {
  plain: {
    color: "#f8fafc",
    backgroundColor: "#011627"
  },
  styles: [
    {
      types: ["prolog"],
      style: {
        color: "#000080"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "#6A9955"
      }
    },
    {
      types: ["builtin", "changed", "keyword", "interpolation-punctuation"],
      style: {
        color: "#569CD6"
      }
    },
    {
      types: ["number", "inserted"],
      style: {
        color: "#B5CEA8"
      }
    },
    {
      types: ["constant"],
      style: {
        color: "#f8fafc"
      }
    },
    {
      types: ["attr-name", "variable"],
      style: {
        color: "#9CDCFE"
      }
    },
    {
      types: ["deleted", "string", "attr-value", "template-punctuation"],
      style: {
        color: "#cbd5e1"
      }
    },
    {
      types: ["selector"],
      style: {
        color: "#D7BA7D"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["tag"],
      languages: ["markup"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["punctuation", "operator"],
      style: {
        color: "#D4D4D4"
      }
    },
    {
      types: ["punctuation"],
      languages: ["markup"],
      style: {
        color: "#808080"
      }
    },
    {
      types: ["function"],
      style: {
        color: "#7dd3fc"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["char"],
      style: {
        color: "#D16969"
      }
    }
  ]
};
var jettwaveDark_default = theme15;

// src/themes/jettwaveLight.ts
var theme16 = {
  plain: {
    color: "#0f172a",
    backgroundColor: "#f1f5f9"
  },
  styles: [
    {
      types: ["prolog"],
      style: {
        color: "#000080"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "#6A9955"
      }
    },
    {
      types: ["builtin", "changed", "keyword", "interpolation-punctuation"],
      style: {
        color: "#0c4a6e"
      }
    },
    {
      types: ["number", "inserted"],
      style: {
        color: "#B5CEA8"
      }
    },
    {
      types: ["constant"],
      style: {
        color: "#0f172a"
      }
    },
    {
      types: ["attr-name", "variable"],
      style: {
        color: "#0c4a6e"
      }
    },
    {
      types: ["deleted", "string", "attr-value", "template-punctuation"],
      style: {
        color: "#64748b"
      }
    },
    {
      types: ["selector"],
      style: {
        color: "#D7BA7D"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["tag"],
      languages: ["markup"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["punctuation", "operator"],
      style: {
        color: "#475569"
      }
    },
    {
      types: ["punctuation"],
      languages: ["markup"],
      style: {
        color: "#808080"
      }
    },
    {
      types: ["function"],
      style: {
        color: "#0e7490"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["char"],
      style: {
        color: "#D16969"
      }
    }
  ]
};
var jettwaveLight_default = theme16;

// src/themes/oneDark.ts
var theme17 = {
  plain: {
    backgroundColor: "hsl(220, 13%, 18%)",
    color: "hsl(220, 14%, 71%)",
    textShadow: "0 1px rgba(0, 0, 0, 0.3)"
  },
  styles: [
    {
      types: ["comment", "prolog", "cdata"],
      style: {
        color: "hsl(220, 10%, 40%)"
      }
    },
    {
      types: ["doctype", "punctuation", "entity"],
      style: {
        color: "hsl(220, 14%, 71%)"
      }
    },
    {
      types: [
        "attr-name",
        "class-name",
        "maybe-class-name",
        "boolean",
        "constant",
        "number",
        "atrule"
      ],
      style: { color: "hsl(29, 54%, 61%)" }
    },
    {
      types: ["keyword"],
      style: { color: "hsl(286, 60%, 67%)" }
    },
    {
      types: ["property", "tag", "symbol", "deleted", "important"],
      style: {
        color: "hsl(355, 65%, 65%)"
      }
    },
    {
      types: [
        "selector",
        "string",
        "char",
        "builtin",
        "inserted",
        "regex",
        "attr-value"
      ],
      style: {
        color: "hsl(95, 38%, 62%)"
      }
    },
    {
      types: ["variable", "operator", "function"],
      style: {
        color: "hsl(207, 82%, 66%)"
      }
    },
    {
      types: ["url"],
      style: {
        color: "hsl(187, 47%, 55%)"
      }
    },
    {
      types: ["deleted"],
      style: {
        textDecorationLine: "line-through"
      }
    },
    {
      types: ["inserted"],
      style: {
        textDecorationLine: "underline"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["important"],
      style: {
        color: "hsl(220, 14%, 71%)"
      }
    }
  ]
};
var oneDark_default = theme17;

// src/themes/oneLight.ts
var theme18 = {
  plain: {
    backgroundColor: "hsl(230, 1%, 98%)",
    color: "hsl(230, 8%, 24%)"
  },
  styles: [
    {
      types: ["comment", "prolog", "cdata"],
      style: {
        color: "hsl(230, 4%, 64%)"
      }
    },
    {
      types: ["doctype", "punctuation", "entity"],
      style: {
        color: "hsl(230, 8%, 24%)"
      }
    },
    {
      types: [
        "attr-name",
        "class-name",
        "boolean",
        "constant",
        "number",
        "atrule"
      ],
      style: {
        color: "hsl(35, 99%, 36%)"
      }
    },
    {
      types: ["keyword"],
      style: {
        color: "hsl(301, 63%, 40%)"
      }
    },
    {
      types: ["property", "tag", "symbol", "deleted", "important"],
      style: {
        color: "hsl(5, 74%, 59%)"
      }
    },
    {
      types: [
        "selector",
        "string",
        "char",
        "builtin",
        "inserted",
        "regex",
        "attr-value",
        "punctuation"
      ],
      style: {
        color: "hsl(119, 34%, 47%)"
      }
    },
    {
      types: ["variable", "operator", "function"],
      style: {
        color: "hsl(221, 87%, 60%)"
      }
    },
    {
      types: ["url"],
      style: {
        color: "hsl(198, 99%, 37%)"
      }
    },
    {
      types: ["deleted"],
      style: {
        textDecorationLine: "line-through"
      }
    },
    {
      types: ["inserted"],
      style: {
        textDecorationLine: "underline"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["important"],
      style: {
        color: "hsl(230, 8%, 24%)"
      }
    }
  ]
};
var oneLight_default = theme18;

// src/themes/gruvboxMaterialDark.ts
var theme19 = {
  plain: {
    color: "#ebdbb2",
    backgroundColor: "#292828"
  },
  styles: [
    {
      types: [
        "imports",
        "class-name",
        "maybe-class-name",
        "constant",
        "doctype",
        "builtin",
        "function"
      ],
      style: {
        color: "#d8a657"
      }
    },
    {
      types: ["property-access"],
      style: {
        color: "#7daea3"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "#e78a4e"
      }
    },
    {
      types: ["attr-name", "char", "url", "regex"],
      style: {
        color: "#a9b665"
      }
    },
    {
      types: ["attr-value", "string"],
      style: {
        color: "#89b482"
      }
    },
    {
      types: ["comment", "prolog", "cdata", "operator", "inserted"],
      style: {
        color: "#a89984"
      }
    },
    {
      types: [
        "delimiter",
        "boolean",
        "keyword",
        "selector",
        "important",
        "atrule",
        "property",
        "variable",
        "deleted"
      ],
      style: {
        color: "#ea6962"
      }
    },
    {
      types: ["entity", "number", "symbol"],
      style: {
        color: "#d3869b"
      }
    }
  ]
};
var gruvboxMaterialDark_default = theme19;

// src/themes/gruvboxMaterialLight.ts
var theme20 = {
  plain: {
    color: "#654735",
    backgroundColor: "#f9f5d7"
  },
  styles: [
    {
      types: [
        "delimiter",
        "boolean",
        "keyword",
        "selector",
        "important",
        "atrule",
        "property",
        "variable",
        "deleted"
      ],
      style: {
        color: "#af2528"
      }
    },
    {
      types: [
        "imports",
        "class-name",
        "maybe-class-name",
        "constant",
        "doctype",
        "builtin"
      ],
      style: {
        color: "#b4730e"
      }
    },
    {
      types: ["string", "attr-value"],
      style: {
        color: "#477a5b"
      }
    },
    {
      types: ["property-access"],
      style: {
        color: "#266b79"
      }
    },
    {
      types: ["function", "attr-name", "char", "url"],
      style: {
        color: "#72761e"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "#b94c07"
      }
    },
    {
      types: ["comment", "prolog", "cdata", "operator", "inserted"],
      style: {
        color: "#a89984"
      }
    },
    {
      types: ["entity", "number", "symbol"],
      style: {
        color: "#924f79"
      }
    }
  ]
};
var gruvboxMaterialLight_default = theme20;

// src/index.ts


// src/components/useGetLineProps.ts


var useGetLineProps = (themeDictionary) => (0,react__rspack_import_0.useCallback)(
  (_a) => {
    var _b = _a, { className, style, line } = _b, rest = __objRest(_b, ["className", "style", "line"]);
    const output = __spreadProps(__spreadValues({}, rest), {
      className: (0,clsx__rspack_import_1/* ["default"] */.A)("token-line", className)
    });
    if (typeof themeDictionary === "object" && "plain" in themeDictionary)
      output.style = themeDictionary.plain;
    if (typeof style === "object")
      output.style = __spreadValues(__spreadValues({}, output.style || {}), style);
    return output;
  },
  [themeDictionary]
);

// src/components/useGetTokenProps.ts


var useGetTokenProps = (themeDictionary) => {
  const styleForToken = (0,react__rspack_import_0.useCallback)(
    ({ types, empty }) => {
      if (themeDictionary == null)
        return void 0;
      else if (types.length === 1 && types[0] === "plain") {
        return empty != null ? { display: "inline-block" } : void 0;
      } else if (types.length === 1 && empty != null) {
        return themeDictionary[types[0]];
      }
      return Object.assign(
        empty != null ? { display: "inline-block" } : {},
        ...types.map((type) => themeDictionary[type])
      );
    },
    [themeDictionary]
  );
  return (0,react__rspack_import_0.useCallback)(
    (_a) => {
      var _b = _a, { token, className, style } = _b, rest = __objRest(_b, ["token", "className", "style"]);
      const output = __spreadProps(__spreadValues({}, rest), {
        className: (0,clsx__rspack_import_1/* ["default"] */.A)("token", ...token.types, className),
        children: token.content,
        style: styleForToken(token)
      });
      if (style != null) {
        output.style = __spreadValues(__spreadValues({}, output.style || {}), style);
      }
      return output;
    },
    [styleForToken]
  );
};

// src/utils/normalizeTokens.ts
var newlineRe = /\r\n|\r|\n/;
var normalizeEmptyLines = (line) => {
  if (line.length === 0) {
    line.push({
      types: ["plain"],
      content: "\n",
      empty: true
    });
  } else if (line.length === 1 && line[0].content === "") {
    line[0].content = "\n";
    line[0].empty = true;
  }
};
var appendTypes = (types, add) => {
  const typesSize = types.length;
  if (typesSize > 0 && types[typesSize - 1] === add) {
    return types;
  }
  return types.concat(add);
};
var normalizeTokens = (tokens) => {
  const typeArrStack = [[]];
  const tokenArrStack = [tokens];
  const tokenArrIndexStack = [0];
  const tokenArrSizeStack = [tokens.length];
  let i = 0;
  let stackIndex = 0;
  let currentLine = [];
  const acc = [currentLine];
  while (stackIndex > -1) {
    while ((i = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]) {
      let content;
      let types = typeArrStack[stackIndex];
      const tokenArr = tokenArrStack[stackIndex];
      const token = tokenArr[i];
      if (typeof token === "string") {
        types = stackIndex > 0 ? types : ["plain"];
        content = token;
      } else {
        types = appendTypes(types, token.type);
        if (token.alias) {
          types = appendTypes(types, token.alias);
        }
        content = token.content;
      }
      if (typeof content !== "string") {
        stackIndex++;
        typeArrStack.push(types);
        tokenArrStack.push(content);
        tokenArrIndexStack.push(0);
        tokenArrSizeStack.push(content.length);
        continue;
      }
      const splitByNewlines = content.split(newlineRe);
      const newlineCount = splitByNewlines.length;
      currentLine.push({
        types,
        content: splitByNewlines[0]
      });
      for (let i2 = 1; i2 < newlineCount; i2++) {
        normalizeEmptyLines(currentLine);
        acc.push(currentLine = []);
        currentLine.push({
          types,
          content: splitByNewlines[i2]
        });
      }
    }
    stackIndex--;
    typeArrStack.pop();
    tokenArrStack.pop();
    tokenArrIndexStack.pop();
    tokenArrSizeStack.pop();
  }
  normalizeEmptyLines(currentLine);
  return acc;
};
var normalizeTokens_default = normalizeTokens;

// src/components/useTokenize.ts

var useTokenize = ({ prism, code, grammar, language }) => {
  return (0,react__rspack_import_0.useMemo)(() => {
    if (grammar == null)
      return normalizeTokens_default([code]);
    const prismConfig = {
      code,
      grammar,
      language,
      tokens: []
    };
    prism.hooks.run("before-tokenize", prismConfig);
    prismConfig.tokens = prism.tokenize(code, grammar);
    prism.hooks.run("after-tokenize", prismConfig);
    return normalizeTokens_default(prismConfig.tokens);
  }, [
    code,
    grammar,
    language,
    // prism is a stable import
    prism
  ]);
};

// src/utils/themeToDict.ts
var themeToDict = (theme21, language) => {
  const { plain } = theme21;
  const themeDict = theme21.styles.reduce((acc, themeEntry) => {
    const { languages: languages2, style } = themeEntry;
    if (languages2 && !languages2.includes(language)) {
      return acc;
    }
    themeEntry.types.forEach((type) => {
      const accStyle = __spreadValues(__spreadValues({}, acc[type]), style);
      acc[type] = accStyle;
    });
    return acc;
  }, {});
  themeDict.root = plain;
  themeDict.plain = __spreadProps(__spreadValues({}, plain), { backgroundColor: void 0 });
  return themeDict;
};
var themeToDict_default = themeToDict;

// src/components/highlight.ts
var Highlight = ({
  children,
  language: _language,
  code,
  theme: theme21,
  prism
}) => {
  const language = _language.toLowerCase();
  const themeDictionary = themeToDict_default(theme21, language);
  const getLineProps = useGetLineProps(themeDictionary);
  const getTokenProps = useGetTokenProps(themeDictionary);
  const grammar = prism.languages[language];
  const tokens = useTokenize({ prism, language, code, grammar });
  return children({
    tokens,
    className: `prism-code language-${language}`,
    style: themeDictionary != null ? themeDictionary.root : {},
    getLineProps,
    getTokenProps
  });
};

// src/index.ts
var Highlight2 = (props) => (0,react__rspack_import_0.createElement)(Highlight, __spreadProps(__spreadValues({}, props), {
  prism: props.prism || Prism,
  theme: props.theme || vsDark_default,
  code: props.code,
  language: props.language
}));

/*! Bundled license information:

prismjs/prism.js:
  (**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   *)
*/
//# sourceMappingURL=index.mjs.map

}),
11561: (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (invariant)
});
var isProduction = "production" === 'production';
var prefix = 'Invariant failed';
function invariant(condition, message) {
    if (condition) {
        return;
    }
    if (isProduction) {
        throw new Error(prefix);
    }
    var provided = typeof message === 'function' ? message() : message;
    var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
    throw new Error(value);
}




}),
31635: (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  __addDisposableResource: () => (__addDisposableResource),
  __assign: () => (__assign),
  __asyncDelegator: () => (__asyncDelegator),
  __asyncGenerator: () => (__asyncGenerator),
  __asyncValues: () => (__asyncValues),
  __await: () => (__await),
  __awaiter: () => (__awaiter),
  __classPrivateFieldGet: () => (__classPrivateFieldGet),
  __classPrivateFieldIn: () => (__classPrivateFieldIn),
  __classPrivateFieldSet: () => (__classPrivateFieldSet),
  __createBinding: () => (__createBinding),
  __decorate: () => (__decorate),
  __disposeResources: () => (__disposeResources),
  __esDecorate: () => (__esDecorate),
  __exportStar: () => (__exportStar),
  __extends: () => (__extends),
  __generator: () => (__generator),
  __importDefault: () => (__importDefault),
  __importStar: () => (__importStar),
  __makeTemplateObject: () => (__makeTemplateObject),
  __metadata: () => (__metadata),
  __param: () => (__param),
  __propKey: () => (__propKey),
  __read: () => (__read),
  __rest: () => (__rest),
  __rewriteRelativeImportExtension: () => (__rewriteRelativeImportExtension),
  __runInitializers: () => (__runInitializers),
  __setFunctionName: () => (__setFunctionName),
  __spread: () => (__spread),
  __spreadArray: () => (__spreadArray),
  __spreadArrays: () => (__spreadArrays),
  __values: () => (__values),
  "default": () => (__rspack_default_export)
});
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  }
  return __assign.apply(this, arguments);
}

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};

function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};

function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};

var ownKeys = function(o) {
  ownKeys = Object.getOwnPropertyNames || function (o) {
    var ar = [];
    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
    return ar;
  };
  return ownKeys(o);
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  __setModuleDefault(result, mod);
  return result;
}

function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
    env.stack.push({ value: value, dispose: dispose, async: async });
  }
  else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
        }
        else s |= 1;
      }
      catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}

function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
      return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : (d + ext + "." + cm.toLowerCase() + "js");
      });
  }
  return path;
}

/* export default */ const __rspack_default_export = ({
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension,
});


}),
22654: (function (module) {
"use strict";
module.exports = JSON.parse('{"theme.ErrorPageContent.title":"This page crashed.","theme.BackToTopButton.buttonAriaLabel":"Scroll back to top","theme.blog.archive.title":"Archive","theme.blog.archive.description":"Archive","theme.blog.paginator.navAriaLabel":"Blog list page navigation","theme.blog.paginator.newerEntries":"Newer entries","theme.blog.paginator.olderEntries":"Older entries","theme.blog.post.paginator.navAriaLabel":"Blog post page navigation","theme.blog.post.paginator.newerPost":"Newer post","theme.blog.post.paginator.olderPost":"Older post","theme.tags.tagsPageLink":"View all tags","theme.colorToggle.ariaLabel":"Switch between dark and light mode (currently {mode})","theme.colorToggle.ariaLabel.mode.dark":"dark mode","theme.colorToggle.ariaLabel.mode.light":"light mode","theme.docs.breadcrumbs.navAriaLabel":"Breadcrumbs","theme.docs.DocCard.categoryDescription.plurals":"1 item|{count} items","theme.docs.paginator.navAriaLabel":"Docs pages","theme.docs.paginator.previous":"Previous","theme.docs.paginator.next":"Next","theme.docs.tagDocListPageTitle.nDocsTagged":"One doc tagged|{count} docs tagged","theme.docs.tagDocListPageTitle":"{nDocsTagged} with \\"{tagName}\\"","theme.docs.versionBadge.label":"Version: {versionLabel}","theme.docs.versions.unreleasedVersionLabel":"This is unreleased documentation for {siteTitle} {versionLabel} version.","theme.docs.versions.unmaintainedVersionLabel":"This is documentation for {siteTitle} {versionLabel}, which is no longer actively maintained.","theme.docs.versions.latestVersionSuggestionLabel":"For up-to-date documentation, see the {latestVersionLink} ({versionLabel}).","theme.docs.versions.latestVersionLinkLabel":"latest version","theme.common.editThisPage":"Edit this page","theme.common.headingLinkTitle":"Direct link to {heading}","theme.lastUpdated.atDate":" on {date}","theme.lastUpdated.byUser":" by {user}","theme.lastUpdated.lastUpdatedAtBy":"Last updated{atDate}{byUser}","theme.navbar.mobileVersionsDropdown.label":"Versions","theme.NotFound.title":"Page Not Found","theme.tags.tagsListLabel":"Tags:","theme.admonition.caution":"caution","theme.admonition.danger":"danger","theme.admonition.info":"info","theme.admonition.note":"note","theme.admonition.tip":"tip","theme.admonition.warning":"warning","theme.AnnouncementBar.closeButtonAriaLabel":"Close","theme.blog.sidebar.navAriaLabel":"Blog recent posts navigation","theme.CodeBlock.copied":"Copied","theme.CodeBlock.copyButtonAriaLabel":"Copy code to clipboard","theme.CodeBlock.copy":"Copy","theme.CodeBlock.wordWrapToggle":"Toggle word wrap","theme.DocSidebarItem.expandCategoryAriaLabel":"Expand sidebar category \'{label}\'","theme.DocSidebarItem.collapseCategoryAriaLabel":"Collapse sidebar category \'{label}\'","theme.NavBar.navAriaLabel":"Main","theme.NotFound.p1":"We could not find what you were looking for.","theme.NotFound.p2":"Please contact the owner of the site that linked you to the original URL and let them know their link is broken.","theme.navbar.mobileLanguageDropdown.label":"Languages","theme.TOCCollapsible.toggleButtonLabel":"On this page","theme.blog.post.readingTime.plurals":"One min read|{readingTime} min read","theme.blog.post.readMore":"Read more","theme.blog.post.readMoreLabel":"Read more about {title}","theme.docs.breadcrumbs.home":"Home page","theme.docs.sidebar.navAriaLabel":"Docs sidebar","theme.docs.sidebar.collapseButtonTitle":"Collapse sidebar","theme.docs.sidebar.collapseButtonAriaLabel":"Collapse sidebar","theme.docs.sidebar.closeSidebarButtonAriaLabel":"Close navigation bar","theme.navbar.mobileSidebarSecondaryMenu.backButtonLabel":"← Back to main menu","theme.docs.sidebar.toggleSidebarButtonAriaLabel":"Toggle navigation bar","theme.docs.sidebar.expandButtonTitle":"Expand sidebar","theme.docs.sidebar.expandButtonAriaLabel":"Expand sidebar","theme.blog.post.plurals":"One post|{count} posts","theme.blog.tagTitle":"{nPosts} tagged with \\"{tagName}\\"","theme.blog.author.pageTitle":"{authorName} - {nPosts}","theme.blog.authorsList.pageTitle":"Authors","theme.blog.authorsList.viewAll":"View all authors","theme.blog.author.noPosts":"This author has not written any posts yet.","theme.contentVisibility.unlistedBanner.title":"Unlisted page","theme.contentVisibility.unlistedBanner.message":"This page is unlisted. Search engines will not index it, and only users having a direct link can access it.","theme.contentVisibility.draftBanner.title":"Draft page","theme.contentVisibility.draftBanner.message":"This page is a draft. It will only be visible in dev and be excluded from the production build.","theme.ErrorPageContent.tryAgain":"Try again","theme.common.skipToMainContent":"Skip to main content","theme.tags.tagsPageTitle":"Tags"}')

}),
84054: (function (module) {
"use strict";
module.exports = JSON.parse('{"/blog-895":{"__comp":"a6aa9e1f","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"3e0612ca"},{"content":"71b694a8"},{"content":"908f8316"},{"content":"6114d855"},{"content":"9373caed"},{"content":"01fb8007"},{"content":"59423c55"},{"content":"d8a6de9e"},{"content":"0cab6d25"},{"content":"6de61594"}],"__props":"c15d9823"},"/blog/alineando-marketing-y-ventas-para-una-conversion-optima-5fc":{"__comp":"ccc49370","__context":{"data":{"blogMetadata":"acecf23e"},"plugin":"36994c47"},"sidebar":"814f3328","content":"42702193"},"/blog/archive-182":{"__comp":"9e4087bc","__context":{"plugin":"36994c47"},"__props":"f81c1134"},"/blog/authors-0b7":{"__comp":"621db11d","__context":{"data":{"blogMetadata":"acecf23e"},"plugin":"36994c47"},"sidebar":"814f3328","__props":"ef8b811a"},"/blog/como-elegir-el-crm-o-software-de-gestion-de-ventas-adecuado-para-su-empresa-027":{"__comp":"ccc49370","__context":{"data":{"blogMetadata":"acecf23e"},"plugin":"36994c47"},"sidebar":"814f3328","content":"d4adaca3"},"/blog/comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel-b2c":{"__comp":"ccc49370","__context":{"data":{"blogMetadata":"acecf23e"},"plugin":"36994c47"},"sidebar":"814f3328","content":"cf1e8ef5"},"/blog/crm-vs-excel-un-analisis-comparativo-927":{"__comp":"ccc49370","__context":{"data":{"blogMetadata":"acecf23e"},"plugin":"36994c47"},"sidebar":"814f3328","content":"20e4b877"},"/blog/estrategias-para-atraer-leads-de-alta-calidad-af7":{"__comp":"ccc49370","__context":{"data":{"blogMetadata":"acecf23e"},"plugin":"36994c47"},"sidebar":"814f3328","content":"42dbfab1"},"/blog/estrategias-para-mejorar-las-tasas-de-conversion-en-cada-etapa-del-embudo-c14":{"__comp":"ccc49370","__context":{"data":{"blogMetadata":"acecf23e"},"plugin":"36994c47"},"sidebar":"814f3328","content":"68d382cf"},"/blog/indicadores-clave-de-rendimiento-kpi-para-medir-el-exito-8db":{"__comp":"ccc49370","__context":{"data":{"blogMetadata":"acecf23e"},"plugin":"36994c47"},"sidebar":"814f3328","content":"b3361e2b"},"/blog/las-desventajas-de-usar-excel-para-la-nutricion-y-el-seguimiento-de-leads-345":{"__comp":"ccc49370","__context":{"data":{"blogMetadata":"acecf23e"},"plugin":"36994c47"},"sidebar":"814f3328","content":"e0fede9b"},"/blog/las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads-646":{"__comp":"ccc49370","__context":{"data":{"blogMetadata":"acecf23e"},"plugin":"36994c47"},"sidebar":"814f3328","content":"b2d6b5e2"},"/blog/mejora-de-las-tasas-de-conversion-a-traves-del-embudo-de-marketing-y-ventas-42b":{"__comp":"ccc49370","__context":{"data":{"blogMetadata":"acecf23e"},"plugin":"36994c47"},"sidebar":"814f3328","content":"57886a6f"},"/blog/page/2-698":{"__comp":"a6aa9e1f","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"6a26327e"}],"__props":"8ea09047"},"/blog/software-crm-popular-en-el-mercado-estadounidense-198":{"__comp":"ccc49370","__context":{"data":{"blogMetadata":"acecf23e"},"plugin":"36994c47"},"sidebar":"814f3328","content":"e4ebf854"},"/blog/tags-287":{"__comp":"01a85c17","__context":{"plugin":"36994c47"},"sidebar":"814f3328","__props":"3a2db09e"},"/blog/tags/como-elegir-crm-be1":{"__comp":"6875c492","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"71b694a8"},{"content":"908f8316"}],"__props":"f2c1b3ae"},"/blog/tags/crm-6a1":{"__comp":"6875c492","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"3e0612ca"},{"content":"71b694a8"},{"content":"908f8316"},{"content":"6114d855"},{"content":"9373caed"},{"content":"01fb8007"},{"content":"59423c55"},{"content":"d8a6de9e"},{"content":"0cab6d25"},{"content":"6de61594"}],"__props":"c57612b1"},"/blog/tags/crm/page/2-a2a":{"__comp":"6875c492","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"6a26327e"}],"__props":"23f37113"},"/blog/tags/embudo-marketing-2cf":{"__comp":"6875c492","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"0cab6d25"},{"content":"6de61594"},{"content":"6a26327e"}],"__props":"8133f5e8"},"/blog/tags/embudo-ventas-188":{"__comp":"6875c492","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"0cab6d25"},{"content":"6de61594"},{"content":"6a26327e"}],"__props":"00e732e1"},"/blog/tags/excel-c87":{"__comp":"6875c492","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"6114d855"},{"content":"9373caed"},{"content":"01fb8007"},{"content":"59423c55"},{"content":"d8a6de9e"}],"__props":"c3f8fc91"},"/blog/tags/excel-vs-crm-e20":{"__comp":"6875c492","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"6114d855"},{"content":"9373caed"},{"content":"01fb8007"},{"content":"59423c55"},{"content":"d8a6de9e"}],"__props":"1d8fdc93"},"/blog/tags/leads-730":{"__comp":"6875c492","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"3e0612ca"}],"__props":"0641b426"},"/blog/tags/leads-alta-calidad-3b7":{"__comp":"6875c492","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"3e0612ca"}],"__props":"aaa9ddfb"},"/blog/tags/tasa-de-conversion-c09":{"__comp":"6875c492","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"0cab6d25"},{"content":"6de61594"},{"content":"6a26327e"}],"__props":"f0f9da59"},"/blog/tags/ventas-155":{"__comp":"6875c492","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"3e0612ca"},{"content":"71b694a8"},{"content":"908f8316"},{"content":"6114d855"},{"content":"9373caed"},{"content":"01fb8007"},{"content":"59423c55"},{"content":"d8a6de9e"},{"content":"0cab6d25"},{"content":"6de61594"}],"__props":"65f62bf7"},"/blog/tags/ventas/page/2-492":{"__comp":"6875c492","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"6a26327e"}],"__props":"8457b37d"},"/docs/fintesk-v1-e50":{"__comp":"f0ad3fbb","__context":{"plugin":"b8387ec1"},"specProps":"348d668f","layoutProps":"7711c30d"},"/markdown-page-3d7":{"__comp":"1f391b9e","__context":{"plugin":"a7456010"},"content":"393be207"},"/-452":{"__comp":"5e95c892","__context":{"plugin":"aba21aa0"}},"/-d2b":{"__comp":"a7bd4aaa","__props":"22dd74f7"},"/tags-ce1":{"__comp":"3720c009","__props":"59af61a6"},"/tags/account-settings-da9":{"__comp":"df203c0f","__props":"86c6c05b"},"/tags/activities-676":{"__comp":"df203c0f","__props":"347da0e9"},"/tags/basic-concepts-ffb":{"__comp":"df203c0f","__props":"0a9aba24"},"/tags/billing-aa4":{"__comp":"df203c0f","__props":"0420c4c4"},"/tags/billing-information-c18":{"__comp":"df203c0f","__props":"5ad9b99e"},"/tags/browser-a2b":{"__comp":"df203c0f","__props":"73975f86"},"/tags/changelog-bc9":{"__comp":"df203c0f","__props":"26cb95a8"},"/tags/company-settings-468":{"__comp":"df203c0f","__props":"40a066f6"},"/tags/contact-support-140":{"__comp":"df203c0f","__props":"a2a5017d"},"/tags/contacts-84d":{"__comp":"df203c0f","__props":"fad1eddb"},"/tags/core-api-concepts-02d":{"__comp":"df203c0f","__props":"35f50680"},"/tags/data-fields-2f0":{"__comp":"df203c0f","__props":"6ee5b1e1"},"/tags/deals-f34":{"__comp":"df203c0f","__props":"54136c51"},"/tags/detail-view-cde":{"__comp":"df203c0f","__props":"b11c7337"},"/tags/developers-015":{"__comp":"df203c0f","__props":"2500cc84"},"/tags/features-372":{"__comp":"df203c0f","__props":"f5d0524d"},"/tags/filtering-2f8":{"__comp":"df203c0f","__props":"1a1bfc42"},"/tags/fintesk-api-194":{"__comp":"df203c0f","__props":"b1371af7"},"/tags/getting-started-4b7":{"__comp":"df203c0f","__props":"e5f74b05"},"/tags/importing-data-8b5":{"__comp":"df203c0f","__props":"8cd1d658"},"/tags/list-view-6e1":{"__comp":"df203c0f","__props":"d1afd025"},"/tags/list-view-reporting-dc4":{"__comp":"df203c0f","__props":"bf0b52ac"},"/tags/manage-users-13d":{"__comp":"df203c0f","__props":"be6789a8"},"/tags/organizing-your-data-a55":{"__comp":"df203c0f","__props":"552c5e87"},"/tags/personal-settings-336":{"__comp":"df203c0f","__props":"5d7e0aec"},"/tags/pipeline-view-f24":{"__comp":"df203c0f","__props":"a55d7aae"},"/tags/pipelines-d57":{"__comp":"df203c0f","__props":"5b13c556"},"/tags/privacy-856":{"__comp":"df203c0f","__props":"77181fba"},"/tags/products-de5":{"__comp":"df203c0f","__props":"3ec0aa47"},"/tags/progress-15d":{"__comp":"df203c0f","__props":"8405ba0f"},"/tags/tos-af1":{"__comp":"df203c0f","__props":"0f049439"},"/tags/troubleshooting-220":{"__comp":"df203c0f","__props":"04aa852f"},"/tags/troubleshooting-the-web-app-1fa":{"__comp":"df203c0f","__props":"339d9f16"},"/tags/users-and-permissions-f54":{"__comp":"df203c0f","__props":"e502ecb5"},"/tags/your-fintesk-subscription-plan-107":{"__comp":"df203c0f","__props":"9e2e739c"},"/-961":{"__comp":"a94703ab"},"/billing/billing-information/what-happens-to-my-billing-when-i-add-a-user-in-fintesk-9b3":{"__comp":"17896441","content":"5bc11281"},"/billing/billing-information/what-happens-to-my-billing-when-i-change-my-billing-frequency-6bf":{"__comp":"17896441","content":"feb46e2b"},"/billing/billing-information/what-happens-to-my-billing-when-i-change-my-fintesk-subscription-plan-cd7":{"__comp":"17896441","content":"9c239c1c"},"/billing/billing-information/what-happens-to-my-billing-when-i-deactivate-a-user-in-fintesk-d15":{"__comp":"17896441","content":"dd8eb1f7"},"/billing/your-fintesk-subscription-plan/how-can-i-switch-to-a-different-fintesk-plan-or-change-my-billing-frequency-048":{"__comp":"17896441","content":"d0f09388"},"/billing/your-fintesk-subscription-plan/what-features-do-the-fintesk-plans-have-91a":{"__comp":"17896441","content":"740980d9"},"/category/activities-43d":{"__comp":"14eb3368","__props":"55b8e973"},"/category/billing-825":{"__comp":"14eb3368","__props":"5a7b92dd"},"/category/billing-information-0b8":{"__comp":"14eb3368","__props":"3a790c7e"},"/category/company-settings-f20":{"__comp":"14eb3368","__props":"36947cfd"},"/category/contacts-c70":{"__comp":"14eb3368","__props":"b4465dc8"},"/category/core-api-concepts-98e":{"__comp":"14eb3368","__props":"4efe2e96"},"/category/data-fields-ba7":{"__comp":"14eb3368","__props":"0a7e2833"},"/category/deals-b06":{"__comp":"14eb3368","__props":"58c2ff45"},"/category/detail-view-c86":{"__comp":"14eb3368","__props":"3344a506"},"/category/developers-620":{"__comp":"14eb3368","__props":"deef8cf1"},"/category/exporting-data-08c":{"__comp":"14eb3368","__props":"7a29ade3"},"/category/filtering-81c":{"__comp":"14eb3368","__props":"16b8a101"},"/category/fintesk-api-ad6":{"__comp":"14eb3368","__props":"fe54bfe0"},"/category/getting-started-685":{"__comp":"14eb3368","__props":"02387f82"},"/category/importing-data-5d9":{"__comp":"14eb3368","__props":"8493f915"},"/category/knowledge-base-3a1":{"__comp":"14eb3368","__props":"14426f04"},"/category/list-view-7e9":{"__comp":"14eb3368","__props":"1a6e6df9"},"/category/overview-178":{"__comp":"14eb3368","__props":"aad23ca5"},"/category/personal-settings-eca":{"__comp":"14eb3368","__props":"3964d4cf"},"/category/pipeline-view-9c9":{"__comp":"14eb3368","__props":"4355a079"},"/category/pipelines-4f5":{"__comp":"14eb3368","__props":"217e589f"},"/category/privacy-91c":{"__comp":"14eb3368","__props":"288fdf9d"},"/category/products-f9b":{"__comp":"14eb3368","__props":"dc1d0bdb"},"/category/terms-of-service-7fd":{"__comp":"14eb3368","__props":"79c74b4f"},"/category/troubleshooting-366":{"__comp":"14eb3368","__props":"3aa59ccb"},"/category/users-and-permissions-b08":{"__comp":"14eb3368","__props":"c610caec"},"/category/your-fintesk-subscription-plan-f39":{"__comp":"14eb3368","__props":"f26f0e2c"},"/developers/core-api-concepts/changes-to-the-api-2ac":{"__comp":"17896441","content":"57536add"},"/developers/core-api-concepts/core-api-concepts-about-fintesk-api-995":{"__comp":"17896441","content":"497e7b2b"},"/developers/core-api-concepts/core-api-concepts-custom-fields-1ec":{"__comp":"17896441","content":"7e188a67"},"/developers/core-api-concepts/core-api-concepts-date-format-2d6":{"__comp":"17896441","content":"ec4249a1"},"/developers/core-api-concepts/core-api-concepts-http-status-codes-1f1":{"__comp":"17896441","content":"4f5dbec8"},"/developers/core-api-concepts/core-api-concepts-pagination-656":{"__comp":"17896441","content":"8bea8cac"},"/developers/core-api-concepts/core-api-concepts-requests-cfe":{"__comp":"17896441","content":"9f82584d"},"/developers/overview/getting-started-15e":{"__comp":"17896441","content":"eda2513a"},"/fintesk/api-v1-61c":{"__comp":"17896441","content":"0ddb9610"},"/fintesk/changelog-a18":{"__comp":"17896441","content":"8b8ca0e3"},"/kb/activities-de6":{"__comp":"17896441","content":"dadb3d7b"},"/kb/activities/activity-marked-as-done-logic-ab2":{"__comp":"17896441","content":"7ff52d0a"},"/kb/activities/creating-custom-activity-types-333":{"__comp":"17896441","content":"c5c6524c"},"/kb/activities/how-can-i-create-activities-in-bulk-a0c":{"__comp":"17896441","content":"703821d4"},"/kb/activities/how-can-i-filter-my-activities-in-the-list-view-2e1":{"__comp":"17896441","content":"d5f456ae"},"/kb/activities/how-can-i-link-my-activities-with-multiple-contact-persons-05a":{"__comp":"17896441","content":"b83a625c"},"/kb/activities/how-can-i-see-done-activities-efd":{"__comp":"17896441","content":"7665015b"},"/kb/company-settings/how-can-i-create-a-custom-currency-a90":{"__comp":"17896441","content":"ff67488a"},"/kb/company-settings/how-can-i-enable-predefined-lost-reasons-142":{"__comp":"17896441","content":"ebf7d2d7"},"/kb/company-settings/lost-reasons-9d2":{"__comp":"17896441","content":"faa1f05b"},"/kb/contacts/contact-detail-view-d37":{"__comp":"17896441","content":"c3467b10"},"/kb/contacts/contacts-persons-and-organizations-fa1":{"__comp":"17896441","content":"8ba53785"},"/kb/contacts/how-can-i-add-related-persons-or-organizations-to-a-deal-bf7":{"__comp":"17896441","content":"a1391e31"},"/kb/contacts/linking-persons-and-organizations-fe4":{"__comp":"17896441","content":"9ed7a22e"},"/kb/data-fields/custom-fields-8f0":{"__comp":"17896441","content":"460bd348"},"/kb/data-fields/data-fields-in-fintesk-fc7":{"__comp":"17896441","content":"5f97402f"},"/kb/data-fields/how-can-i-add-data-fields-to-an-add-deal-contact-or-product-modal-ce8":{"__comp":"17896441","content":"f3b52007"},"/kb/data-fields/what-types-of-custom-fields-are-there-118":{"__comp":"17896441","content":"934382b2"},"/kb/deals/adding-deals-in-bulk-4b4":{"__comp":"17896441","content":"557b7ec6"},"/kb/deals/deals-what-they-are-and-how-to-add-them-0a6":{"__comp":"17896441","content":"350e7c1c"},"/kb/deals/editing-the-contact-linked-to-a-deal-136":{"__comp":"17896441","content":"c665a9b3"},"/kb/deals/filtering-for-my-won-lost-or-deleted-deals-451":{"__comp":"17896441","content":"ef5e0799"},"/kb/deals/how-can-i-move-a-deal-to-another-pipeline-12a":{"__comp":"17896441","content":"7658d294"},"/kb/deals/how-can-i-restore-deleted-deals-5da":{"__comp":"17896441","content":"9ddd768b"},"/kb/detail-view-98e":{"__comp":"17896441","content":"d557e752"},"/kb/detail-view/deal-detail-view-ae0":{"__comp":"17896441","content":"64b4bdc3"},"/kb/detail-view/how-can-i-add-notes-to-a-deal-or-contact-5c4":{"__comp":"17896441","content":"15bc0e42"},"/kb/detail-view/updating-items-in-the-detail-view-aa5":{"__comp":"17896441","content":"17e0ce07"},"/kb/exporting-data/exporting-data-from-fintesk-977":{"__comp":"17896441","content":"68a6222d"},"/kb/filtering-b55":{"__comp":"17896441","content":"22ed1d20"},"/kb/filtering/filters-common-uses-a73":{"__comp":"17896441","content":"0b32ee9d"},"/kb/getting-started/fintesk-glossary-c98":{"__comp":"17896441","content":"e518d369"},"/kb/getting-started/fintesk-user-vs-company-account-07c":{"__comp":"17896441","content":"41e76799"},"/kb/getting-started/how-can-i-delete-items-in-fintesk-090":{"__comp":"17896441","content":"11db73b9"},"/kb/getting-started/interface-in-fintesk-2d6":{"__comp":"17896441","content":"aa775e8c"},"/kb/getting-started/organization-vs-company-account-560":{"__comp":"17896441","content":"5f673c16"},"/kb/getting-started/search-finding-what-you-need-a62":{"__comp":"17896441","content":"ae26eec0"},"/kb/getting-started/what-is-the-difference-between-a-user-and-a-seat-e02":{"__comp":"17896441","content":"eb185d82"},"/kb/importing-data/changing-the-field-type-of-a-custom-field-f77":{"__comp":"17896441","content":"1561ae7f"},"/kb/importing-data/how-can-i-format-dates-to-import-into-fintesk-7fa":{"__comp":"17896441","content":"92fdd400"},"/kb/importing-data/import-fields-a8f":{"__comp":"17896441","content":"b13ea042"},"/kb/importing-data/importing-advanced-mapping-e34":{"__comp":"17896441","content":"321734ec"},"/kb/importing-data/importing-data-into-fintesk-with-spreadsheets-9da":{"__comp":"17896441","content":"d5eb89e4"},"/kb/importing-data/importing-mandatory-fields-251":{"__comp":"17896441","content":"ce193921"},"/kb/importing-data/importing-mapping-your-fields-fdf":{"__comp":"17896441","content":"076880ce"},"/kb/importing-data/importing-sample-import-spreadsheets-889":{"__comp":"17896441","content":"360fe992"},"/kb/importing-data/transferring-data-to-a-different-fintesk-company-account-42c":{"__comp":"17896441","content":"4266b0db"},"/kb/importing-data/updating-fintesk-data-with-a-spreadsheet-c8f":{"__comp":"17896441","content":"98258112"},"/kb/importing-data/why-do-my-imported-currency-values-appear-as-0-560":{"__comp":"17896441","content":"28b9f67b"},"/kb/list-view-55a":{"__comp":"17896441","content":"98c47b7a"},"/kb/list-view/customizing-the-columns-in-the-list-view-3bc":{"__comp":"17896441","content":"9685dfba"},"/kb/list-view/fintesk-system-ids-ce6":{"__comp":"17896441","content":"a4bb4cf1"},"/kb/list-view/how-can-i-add-or-remove-columns-in-the-list-view-a2f":{"__comp":"17896441","content":"66b10d08"},"/kb/list-view/how-can-i-edit-a-field-in-the-list-view-976":{"__comp":"17896441","content":"ed379444"},"/kb/list-view/how-can-i-set-default-columns-for-all-my-users-in-the-list-view-595":{"__comp":"17896441","content":"5032f16e"},"/kb/personal-settings/fintesk-settings-73d":{"__comp":"17896441","content":"79b26084"},"/kb/personal-settings/how-can-i-change-or-reset-my-password-8c8":{"__comp":"17896441","content":"105c8d66"},"/kb/personal-settings/how-can-i-free-up-space-16f":{"__comp":"17896441","content":"76e8ffac"},"/kb/personal-settings/usage-limits-in-fintesk-20f":{"__comp":"17896441","content":"4fad16d7"},"/kb/pipeline-view-2b5":{"__comp":"17896441","content":"39a1d5e5"},"/kb/pipeline-view/how-can-i-delete-a-deal-in-the-pipeline-view-1dc":{"__comp":"17896441","content":"891c2643"},"/kb/pipeline-view/how-can-i-see-deals-in-a-different-pipeline-363":{"__comp":"17896441","content":"ebe4800a"},"/kb/pipeline-view/the-rotting-feature-a1a":{"__comp":"17896441","content":"583624b8"},"/kb/pipelines/how-can-i-add-a-stage-to-my-pipeline-31f":{"__comp":"17896441","content":"6c8a611e"},"/kb/pipelines/how-can-i-customize-my-pipeline-stages-33f":{"__comp":"17896441","content":"f985740b"},"/kb/pipelines/how-can-i-have-multiple-pipelines-9e7":{"__comp":"17896441","content":"2e6f48d8"},"/kb/products-879":{"__comp":"17896441","content":"93a29f76"},"/kb/products/can-i-add-extra-fields-to-the-add-new-product-modal-6f3":{"__comp":"17896441","content":"bb18f21e"},"/kb/products/can-i-have-one-product-in-different-price-variations-afd":{"__comp":"17896441","content":"9a23c939"},"/kb/products/can-i-import-products-and-automatically-link-them-to-deals-fc0":{"__comp":"17896441","content":"15152d82"},"/kb/products/how-can-i-link-products-to-a-deal-94d":{"__comp":"17896441","content":"46212578"},"/kb/products/where-do-i-activate-or-deactivate-individual-products-c3c":{"__comp":"17896441","content":"b17dd5db"},"/kb/troubleshooting/can-fintesk-be-used-offline-b3f":{"__comp":"17896441","content":"414cb524"},"/kb/troubleshooting/how-can-i-take-a-screenshot-293":{"__comp":"17896441","content":"08d3a22b"},"/kb/troubleshooting/how-do-i-clear-my-browser-s-cache-and-cookies-5ea":{"__comp":"17896441","content":"72450ad2"},"/kb/troubleshooting/how-do-i-open-my-browser-console-373":{"__comp":"17896441","content":"9997302d"},"/kb/troubleshooting/troubleshooting-fintesk-web-app-7b0":{"__comp":"17896441","content":"159ada6c"},"/kb/troubleshooting/which-browser-is-best-for-fintesk-c11":{"__comp":"17896441","content":"4f35b503"},"/kb/users-and-permissions/global-user-management-f4e":{"__comp":"17896441","content":"78f609cd"},"/kb/users-and-permissions/how-can-i-add-a-user-094":{"__comp":"17896441","content":"06e61810"},"/kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user-799":{"__comp":"17896441","content":"2387fda4"},"/kb/users-and-permissions/how-can-i-replace-users-in-my-fintesk-company-account-a93":{"__comp":"17896441","content":"9c343362"},"/kb/users-and-permissions/updating-user-information-98d":{"__comp":"17896441","content":"e426a42f"},"/kb/users-and-permissions/users-de0":{"__comp":"17896441","content":"c57f6fe4"},"/kb/users-and-permissions/what-is-a-regular-user-2b9":{"__comp":"17896441","content":"278a4813"},"/kb/users-and-permissions/who-is-the-admin-user-of-my-account-e9f":{"__comp":"17896441","content":"f36639c8"},"/privacy-c0d":{"__comp":"17896441","content":"7918b82f"},"/privacy/dpa-02b":{"__comp":"17896441","content":"68f438f9"},"/privacy/fintesk-data-sub-processors-78a":{"__comp":"17896441","content":"24bd74fc"},"/tos/terms-of-service-421":{"__comp":"17896441","content":"47a1e68f"},"/-f06":{"__comp":"17896441","content":"ca74cf47"}}')

}),

},function(__webpack_require__) {
var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId) }
__webpack_require__.O(0, ["4014",], function() {
        return __webpack_exec__(10354);
      });
var __webpack_exports__ = __webpack_require__.O();

}
]);