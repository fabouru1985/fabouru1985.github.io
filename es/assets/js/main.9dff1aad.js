(self["webpackChunkdocs_fintesk_com"] = self["webpackChunkdocs_fintesk_com"] || []).push([["1889"], {
22318: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;
exports.add = add;
exports.fromBig = fromBig;
exports.split = split;
/**
 * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.
 * @todo re-check https://issues.chromium.org/issues/42212588
 * @module
 */
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for (let i = 0; i < len; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, _l, s) => h >>> s;
exports.shrSH = shrSH;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
exports.rotrSH = rotrSH;
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
exports.rotrBH = rotrBH;
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
exports.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l) => l;
exports.rotr32H = rotr32H;
const rotr32L = (h, _l) => h;
exports.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
exports.rotlSH = rotlSH;
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
exports.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
exports.rotlBH = rotlBH;
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
exports.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
exports.add3L = add3L;
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
exports.add3H = add3H;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
exports.add4L = add4L;
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
exports.add4H = add4H;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
exports.add5L = add5L;
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
exports.add5H = add5H;
// prettier-ignore
const u64 = {
    fromBig, split, toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
exports["default"] = u64;
//# sourceMappingURL=_u64.js.map

}),
25145: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.crypto = void 0;
exports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;
//# sourceMappingURL=crypto.js.map

}),
32955: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = void 0;
exports.keccakP = keccakP;
/**
 * SHA3 (keccak) hash function, based on a new "Sponge function" design.
 * Different from older hashes, the internal state is bigger than output size.
 *
 * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),
 * [Website](https://keccak.team/keccak.html),
 * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).
 *
 * Check out `sha3-addons` module for cSHAKE, k12, and others.
 * @module
 */
const _u64_ts_1 = __webpack_require__(22318);
// prettier-ignore
const utils_ts_1 = __webpack_require__(99175);
// No __PURE__ annotations in sha3 header:
// EVERYTHING is in fact used on every export.
// Various per round constants calculations
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(0x71);
const SHA3_PI = [];
const SHA3_ROTL = [];
const _SHA3_IOTA = [];
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const IOTAS = (0, _u64_ts_1.split)(_SHA3_IOTA, true);
const SHA3_IOTA_H = IOTAS[0];
const SHA3_IOTA_L = IOTAS[1];
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => (s > 32 ? (0, _u64_ts_1.rotlBH)(h, l, s) : (0, _u64_ts_1.rotlSH)(h, l, s));
const rotlL = (h, l, s) => (s > 32 ? (0, _u64_ts_1.rotlBL)(h, l, s) : (0, _u64_ts_1.rotlSL)(h, l, s));
/** `keccakf1600` internal function, additionally allows to adjust round count. */
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta θ
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho (ρ) and Pi (π)
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi (χ)
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota (ι)
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    (0, utils_ts_1.clean)(B);
}
/** Keccak sponge function. */
class Keccak extends utils_ts_1.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        this.enableXOF = false;
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        // Can be passed from user as dkLen
        (0, utils_ts_1.anumber)(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        // 0 < blockLen < 200
        if (!(0 < blockLen && blockLen < 200))
            throw new Error('only keccak-f1600 function is supported');
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_ts_1.u32)(this.state);
    }
    clone() {
        return this._cloneInto();
    }
    keccak() {
        (0, utils_ts_1.swap32IfBE)(this.state32);
        keccakP(this.state32, this.rounds);
        (0, utils_ts_1.swap32IfBE)(this.state32);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { blockLen, state } = this;
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        (0, utils_ts_1.aexists)(this, false);
        (0, utils_ts_1.abytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        (0, utils_ts_1.anumber)(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        (0, utils_ts_1.aoutput)(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.state);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
exports.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen) => (0, utils_ts_1.createHasher)(() => new Keccak(blockLen, suffix, outputLen));
/** SHA3-224 hash function. */
exports.sha3_224 = (() => gen(0x06, 144, 224 / 8))();
/** SHA3-256 hash function. Different from keccak-256. */
exports.sha3_256 = (() => gen(0x06, 136, 256 / 8))();
/** SHA3-384 hash function. */
exports.sha3_384 = (() => gen(0x06, 104, 384 / 8))();
/** SHA3-512 hash function. */
exports.sha3_512 = (() => gen(0x06, 72, 512 / 8))();
/** keccak-224 hash function. */
exports.keccak_224 = (() => gen(0x01, 144, 224 / 8))();
/** keccak-256 hash function. Different from SHA3-256. */
exports.keccak_256 = (() => gen(0x01, 136, 256 / 8))();
/** keccak-384 hash function. */
exports.keccak_384 = (() => gen(0x01, 104, 384 / 8))();
/** keccak-512 hash function. */
exports.keccak_512 = (() => gen(0x01, 72, 512 / 8))();
const genShake = (suffix, blockLen, outputLen) => (0, utils_ts_1.createXOFer)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
/** SHAKE128 XOF with 128-bit security. */
exports.shake128 = (() => genShake(0x1f, 168, 128 / 8))();
/** SHAKE256 XOF with 256-bit security. */
exports.shake256 = (() => genShake(0x1f, 136, 256 / 8))();
//# sourceMappingURL=sha3.js.map

}),
99175: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

/**
 * Utilities for hex, bytes, CSPRNG.
 * @module
 */
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
exports.isBytes = isBytes;
exports.anumber = anumber;
exports.abytes = abytes;
exports.ahash = ahash;
exports.aexists = aexists;
exports.aoutput = aoutput;
exports.u8 = u8;
exports.u32 = u32;
exports.clean = clean;
exports.createView = createView;
exports.rotr = rotr;
exports.rotl = rotl;
exports.byteSwap = byteSwap;
exports.byteSwap32 = byteSwap32;
exports.bytesToHex = bytesToHex;
exports.hexToBytes = hexToBytes;
exports.asyncLoop = asyncLoop;
exports.utf8ToBytes = utf8ToBytes;
exports.bytesToUtf8 = bytesToUtf8;
exports.toBytes = toBytes;
exports.kdfInputToBytes = kdfInputToBytes;
exports.concatBytes = concatBytes;
exports.checkOpts = checkOpts;
exports.createHasher = createHasher;
exports.createOptHasher = createOptHasher;
exports.createXOFer = createXOFer;
exports.randomBytes = randomBytes;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
const crypto_1 = __webpack_require__(25145);
/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */
function isBytes(a) {
    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
}
/** Asserts something is positive integer. */
function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error('positive integer expected, got ' + n);
}
/** Asserts something is Uint8Array. */
function abytes(b, ...lengths) {
    if (!isBytes(b))
        throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
/** Asserts something is hash */
function ahash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function')
        throw new Error('Hash should be wrapped by utils.createHasher');
    anumber(h.outputLen);
    anumber(h.blockLen);
}
/** Asserts a hash instance has not been destroyed / finished */
function aexists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
/** Asserts output is properly-sized byte array */
function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error('digestInto() expects output buffer of length at least ' + min);
    }
}
/** Cast u8 / u16 / u32 to u8. */
function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** Cast u8 / u16 / u32 to u32. */
function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
/** Zeroize a byte array. Warning: JS provides no guarantees. */
function clean(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
    }
}
/** Create DataView of an array for easy byte-level manipulation. */
function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** The rotate right (circular right shift) operation for uint32 */
function rotr(word, shift) {
    return (word << (32 - shift)) | (word >>> shift);
}
/** The rotate left (circular left shift) operation for uint32 */
function rotl(word, shift) {
    return (word << shift) | ((word >>> (32 - shift)) >>> 0);
}
/** Is current platform little-endian? Most are. Big-Endian platform: IBM */
exports.isLE = (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();
/** The byte swap operation for uint32 */
function byteSwap(word) {
    return (((word << 24) & 0xff000000) |
        ((word << 8) & 0xff0000) |
        ((word >>> 8) & 0xff00) |
        ((word >>> 24) & 0xff));
}
/** Conditionally byte swap if on a big-endian platform */
exports.swap8IfBE = exports.isLE
    ? (n) => n
    : (n) => byteSwap(n);
/** @deprecated */
exports.byteSwapIfBE = exports.swap8IfBE;
/** In place byte swap for Uint32Array */
function byteSwap32(arr) {
    for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
    }
    return arr;
}
exports.swap32IfBE = exports.isLE
    ? (u) => u
    : byteSwap32;
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
const hasHexBuiltin = /* @__PURE__ */ (() => 
// @ts-ignore
typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * Convert byte array to hex string. Uses built-in function, when available.
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    abytes(bytes);
    // @ts-ignore
    if (hasHexBuiltin)
        return bytes.toHex();
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0; // '2' => 50-48
    if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10); // 'B' => 66-(65-10)
    if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10); // 'b' => 98-(97-10)
    return;
}
/**
 * Convert hex string to byte array. Uses built-in function, when available.
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    // @ts-ignore
    if (hasHexBuiltin)
        return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
        throw new Error('hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
    }
    return array;
}
/**
 * There is no setImmediate in browser and setTimeout is slow.
 * Call of async fn will return Promise, which will be fullfiled only on
 * next scheduler queue processing step and this is exactly what we need.
 */
const nextTick = async () => { };
exports.nextTick = nextTick;
/** Returns control to thread each 'tick' ms to avoid blocking. */
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
/**
 * Converts string to bytes using UTF8 encoding.
 * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error('string expected');
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Converts bytes to string using UTF8 encoding.
 * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'
 */
function bytesToUtf8(bytes) {
    return new TextDecoder().decode(bytes);
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/**
 * Helper for KDFs: consumes uint8array or string.
 * When string is passed, does utf8 decoding, using TextDecoder.
 */
function kdfInputToBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/** Copies several Uint8Arrays into one. */
function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
function checkOpts(defaults, opts) {
    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')
        throw new Error('options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
/** For runtime check if class implements interface */
class Hash {
}
exports.Hash = Hash;
/** Wraps hash function, creating an interface on top of it */
function createHasher(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}
function createOptHasher(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
function createXOFer(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapConstructor = createHasher;
exports.wrapConstructorWithOpts = createOptHasher;
exports.wrapXOFConstructorWithOpts = createXOFer;
/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */
function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    // Legacy Node.js compatibility
    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
}
//# sourceMappingURL=utils.js.map

}),
96389: (function (module, __unused_webpack_exports, __webpack_require__) {
var __webpack_unused_export__;
const { createId, init, getConstants, isCuid } = __webpack_require__(25228);

module.exports.createId = createId;
__webpack_unused_export__ = init;
__webpack_unused_export__ = getConstants;
__webpack_unused_export__ = isCuid;


}),
25228: (function (module, __unused_webpack_exports, __webpack_require__) {
/* global global, window, module */
const { sha3_512: sha3 } = __webpack_require__(32955);

const defaultLength = 24;
const bigLength = 32;

const createEntropy = (length = 4, random = Math.random) => {
  let entropy = "";

  while (entropy.length < length) {
    entropy = entropy + Math.floor(random() * 36).toString(36);
  }
  return entropy;
};

/*
 * Adapted from https://github.com/juanelas/bigint-conversion
 * MIT License Copyright (c) 2018 Juan Hernández Serrano
 */
function bufToBigInt(buf) {
  let bits = BigInt(8);

  let value = BigInt(0);
  for (const i of buf.values()) {
    const bi = BigInt(i);
    value = (value << bits) + bi;
  }
  return value;
}

const hash = (input = "") => {
  // Drop the first character because it will bias the histogram
  // to the left.
  return bufToBigInt(sha3(input)).toString(36).slice(1);
};

const alphabet = Array.from({ length: 26 }, (x, i) =>
  String.fromCharCode(i + 97)
);

const randomLetter = (random) =>
  alphabet[Math.floor(random() * alphabet.length)];

/*
This is a fingerprint of the host environment. It is used to help
prevent collisions when generating ids in a distributed system.
If no global object is available, you can pass in your own, or fall back
on a random string.
*/
const createFingerprint = ({
  globalObj = typeof __webpack_require__.g !== "undefined"
    ? __webpack_require__.g
    : typeof window !== "undefined"
    ? window
    : {},
  random = Math.random,
} = {}) => {
  const globals = Object.keys(globalObj).toString();
  const sourceString = globals.length
    ? globals + createEntropy(bigLength, random)
    : createEntropy(bigLength, random);

  return hash(sourceString).substring(0, bigLength);
};

const createCounter = (count) => () => {
  return count++;
};

// ~22k hosts before 50% chance of initial counter collision
// with a remaining counter range of 9.0e+15 in JavaScript.
const initialCountMax = 476782367;

const init = ({
  // Fallback if the user does not pass in a CSPRNG. This should be OK
  // because we don't rely solely on the random number generator for entropy.
  // We also use the host fingerprint, current time, and a session counter.
  random = Math.random,
  counter = createCounter(Math.floor(random() * initialCountMax)),
  length = defaultLength,
  fingerprint = createFingerprint({ random }),
} = {}) => {
  return function cuid2() {
    const firstLetter = randomLetter(random);

    // If we're lucky, the `.toString(36)` calls may reduce hashing rounds
    // by shortening the input to the hash function a little.
    const time = Date.now().toString(36);
    const count = counter().toString(36);

    // The salt should be long enough to be globally unique across the full
    // length of the hash. For simplicity, we use the same length as the
    // intended id output.
    const salt = createEntropy(length, random);
    const hashInput = `${time + salt + count + fingerprint}`;

    return `${firstLetter + hash(hashInput).substring(1, length)}`;
  };
};

const createId = init();

const isCuid = (id, { minLength = 2, maxLength = bigLength } = {}) => {
  const length = id.length;
  const regex = /^[a-z][0-9a-z]+$/;

  try {
    if (
      typeof id === "string" &&
      length >= minLength &&
      length <= maxLength &&
      regex.test(id)
    )
      return true;
  } finally {
  }

  return false;
};

module.exports.getConstants = () => ({ defaultLength, bigLength });
module.exports.init = init;
module.exports.createId = createId;
module.exports.bufToBigInt = bufToBigInt;
module.exports.createCounter = createCounter;
module.exports.createFingerprint = createFingerprint;
module.exports.isCuid = isCuid;


}),
77612: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by css-extract-rspack-plugin


}),
56814: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by css-extract-rspack-plugin


}),
87570: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by css-extract-rspack-plugin


}),
56464: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by css-extract-rspack-plugin


}),
16448: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by css-extract-rspack-plugin


}),
33328: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  AO: () => (/* binding */ createPath),
  yJ: () => (/* binding */ createLocation),
  sC: () => (/* binding */ createMemoryHistory),
  TM: () => (/* binding */ createHashHistory),
  zR: () => (/* binding */ createBrowserHistory)
});

// UNUSED EXPORTS: parsePath, locationsAreEqual

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
var esm_extends = __webpack_require__(58168);
;// CONCATENATED MODULE: ./node_modules/resolve-pathname/esm/resolve-pathname.js
function isAbsolute(pathname) {
  return pathname.charAt(0) === '/';
}

// About 1.5x faster than the two-arg version of Array#splice()
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
    list[i] = list[k];
  }

  list.pop();
}

// This implementation is based heavily on node's url.parse
function resolvePathname(to, from) {
  if (from === undefined) from = '';

  var toParts = (to && to.split('/')) || [];
  var fromParts = (from && from.split('/')) || [];

  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;

  if (to && isAbsolute(to)) {
    // to is absolute
    fromParts = toParts;
  } else if (toParts.length) {
    // to is relative, drop the filename
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }

  if (!fromParts.length) return '/';

  var hasTrailingSlash;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === '.' || last === '..' || last === '';
  } else {
    hasTrailingSlash = false;
  }

  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];

    if (part === '.') {
      spliceOne(fromParts, i);
    } else if (part === '..') {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }

  if (!mustEndAbs) for (; up--; up) fromParts.unshift('..');

  if (
    mustEndAbs &&
    fromParts[0] !== '' &&
    (!fromParts[0] || !isAbsolute(fromParts[0]))
  )
    fromParts.unshift('');

  var result = fromParts.join('/');

  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';

  return result;
}

/* export default */ const resolve_pathname = (resolvePathname);

// EXTERNAL MODULE: ./node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var tiny_invariant = __webpack_require__(11561);
;// CONCATENATED MODULE: ./node_modules/history/esm/history.js






function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
}
function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
}
function hasBasename(path, prefix) {
  return path.toLowerCase().indexOf(prefix.toLowerCase()) === 0 && '/?#'.indexOf(path.charAt(prefix.length)) !== -1;
}
function stripBasename(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
}
function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
}
function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';
  var hashIndex = pathname.indexOf('#');

  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');

  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
}
function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;
  var path = pathname || '/';
  if (search && search !== '?') path += search.charAt(0) === '?' ? search : "?" + search;
  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : "#" + hash;
  return path;
}

function createLocation(path, state, key, currentLocation) {
  var location;

  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = parsePath(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = (0,esm_extends/* ["default"] */.A)({}, path);
    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = resolve_pathname(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
}
function locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && valueEqual(a.state, b.state);
}

function createTransitionManager() {
  var prompt = null;

  function setPrompt(nextPrompt) {
     false ? 0 : void 0;
    prompt = nextPrompt;
    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  }

  function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
           false ? 0 : void 0;
          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  }

  var listeners = [];

  function appendListener(fn) {
    var isActive = true;

    function listener() {
      if (isActive) fn.apply(void 0, arguments);
    }

    listeners.push(listener);
    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  }

  function notifyListeners() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(void 0, args);
    });
  }

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
}

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
function getConfirmation(message, callback) {
  callback(window.confirm(message)); // eslint-disable-line no-alert
}
/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */

function supportsHistory() {
  var ua = window.navigator.userAgent;
  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;
  return window.history && 'pushState' in window.history;
}
/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */

function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
}
/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */

function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
}
/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */

function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
}

var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
}
/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */


function createBrowserHistory(props) {
  if (props === void 0) {
    props = {};
  }

  !canUseDOM ?  false ? 0 : (0,tiny_invariant/* ["default"] */.A)(false) : void 0;
  var globalHistory = window.history;
  var canUseHistory = supportsHistory();
  var needsHashChangeListener = !supportsPopStateOnHashChange();
  var _props = props,
      _props$forceRefresh = _props.forceRefresh,
      forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh,
      _props$getUserConfirm = _props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,
      _props$keyLength = _props.keyLength,
      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';

  function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;
    var path = pathname + search + hash;
     false ? 0 : void 0;
    if (basename) path = stripBasename(path, basename);
    return createLocation(path, state, key);
  }

  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }

  var transitionManager = createTransitionManager();

  function setState(nextState) {
    (0,esm_extends/* ["default"] */.A)(history, nextState);

    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }

  function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if (isExtraneousPopstateEvent(event)) return;
    handlePop(getDOMLocation(event.state));
  }

  function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  }

  var forceNextPop = false;

  function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({
            action: action,
            location: location
          });
        } else {
          revertPop(location);
        }
      });
    }
  }

  function revertPop(fromLocation) {
    var toLocation = history.location; // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);
    if (toIndex === -1) toIndex = 0;
    var fromIndex = allKeys.indexOf(fromLocation.key);
    if (fromIndex === -1) fromIndex = 0;
    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  }

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key]; // Public interface

  function createHref(location) {
    return basename + createPath(location);
  }

  function push(path, state) {
     false ? 0 : void 0;
    var action = 'PUSH';
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var href = createHref(location);
      var key = location.key,
          state = location.state;

      if (canUseHistory) {
        globalHistory.pushState({
          key: key,
          state: state
        }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex + 1);
          nextKeys.push(location.key);
          allKeys = nextKeys;
          setState({
            action: action,
            location: location
          });
        }
      } else {
         false ? 0 : void 0;
        window.location.href = href;
      }
    });
  }

  function replace(path, state) {
     false ? 0 : void 0;
    var action = 'REPLACE';
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var href = createHref(location);
      var key = location.key,
          state = location.state;

      if (canUseHistory) {
        globalHistory.replaceState({
          key: key,
          state: state
        }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          if (prevIndex !== -1) allKeys[prevIndex] = location.key;
          setState({
            action: action,
            location: location
          });
        }
      } else {
         false ? 0 : void 0;
        window.location.replace(href);
      }
    });
  }

  function go(n) {
    globalHistory.go(n);
  }

  function goBack() {
    go(-1);
  }

  function goForward() {
    go(1);
  }

  var listenerCount = 0;

  function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener) window.addEventListener(HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener) window.removeEventListener(HashChangeEvent, handleHashChange);
    }
  }

  var isBlocked = false;

  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  }

  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  }

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };
  return history;
}

var HashChangeEvent$1 = 'hashchange';
var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: stripLeadingSlash,
    decodePath: addLeadingSlash
  },
  slash: {
    encodePath: addLeadingSlash,
    decodePath: addLeadingSlash
  }
};

function stripHash(url) {
  var hashIndex = url.indexOf('#');
  return hashIndex === -1 ? url : url.slice(0, hashIndex);
}

function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
}

function pushHashPath(path) {
  window.location.hash = path;
}

function replaceHashPath(path) {
  window.location.replace(stripHash(window.location.href) + '#' + path);
}

function createHashHistory(props) {
  if (props === void 0) {
    props = {};
  }

  !canUseDOM ?  false ? 0 : (0,tiny_invariant/* ["default"] */.A)(false) : void 0;
  var globalHistory = window.history;
  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();
  var _props = props,
      _props$getUserConfirm = _props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,
      _props$hashType = _props.hashType,
      hashType = _props$hashType === void 0 ? 'slash' : _props$hashType;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';
  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;

  function getDOMLocation() {
    var path = decodePath(getHashPath());
     false ? 0 : void 0;
    if (basename) path = stripBasename(path, basename);
    return createLocation(path);
  }

  var transitionManager = createTransitionManager();

  function setState(nextState) {
    (0,esm_extends/* ["default"] */.A)(history, nextState);

    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }

  var forceNextPop = false;
  var ignorePath = null;

  function locationsAreEqual$$1(a, b) {
    return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;
  }

  function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;
      if (!forceNextPop && locationsAreEqual$$1(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;
      handlePop(location);
    }
  }

  function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({
            action: action,
            location: location
          });
        } else {
          revertPop(location);
        }
      });
    }
  }

  function revertPop(fromLocation) {
    var toLocation = history.location; // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf(createPath(toLocation));
    if (toIndex === -1) toIndex = 0;
    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
    if (fromIndex === -1) fromIndex = 0;
    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  } // Ensure the hash is encoded properly before doing anything else.


  var path = getHashPath();
  var encodedPath = encodePath(path);
  if (path !== encodedPath) replaceHashPath(encodedPath);
  var initialLocation = getDOMLocation();
  var allPaths = [createPath(initialLocation)]; // Public interface

  function createHref(location) {
    var baseTag = document.querySelector('base');
    var href = '';

    if (baseTag && baseTag.getAttribute('href')) {
      href = stripHash(window.location.href);
    }

    return href + '#' + encodePath(basename + createPath(location));
  }

  function push(path, state) {
     false ? 0 : void 0;
    var action = 'PUSH';
    var location = createLocation(path, undefined, undefined, history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var path = createPath(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a PUSH, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        pushHashPath(encodedPath);
        var prevIndex = allPaths.lastIndexOf(createPath(history.location));
        var nextPaths = allPaths.slice(0, prevIndex + 1);
        nextPaths.push(path);
        allPaths = nextPaths;
        setState({
          action: action,
          location: location
        });
      } else {
         false ? 0 : void 0;
        setState();
      }
    });
  }

  function replace(path, state) {
     false ? 0 : void 0;
    var action = 'REPLACE';
    var location = createLocation(path, undefined, undefined, history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var path = createPath(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        replaceHashPath(encodedPath);
      }

      var prevIndex = allPaths.indexOf(createPath(history.location));
      if (prevIndex !== -1) allPaths[prevIndex] = path;
      setState({
        action: action,
        location: location
      });
    });
  }

  function go(n) {
     false ? 0 : void 0;
    globalHistory.go(n);
  }

  function goBack() {
    go(-1);
  }

  function goForward() {
    go(1);
  }

  var listenerCount = 0;

  function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(HashChangeEvent$1, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(HashChangeEvent$1, handleHashChange);
    }
  }

  var isBlocked = false;

  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  }

  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  }

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };
  return history;
}

function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
}
/**
 * Creates a history object that stores locations in memory.
 */


function createMemoryHistory(props) {
  if (props === void 0) {
    props = {};
  }

  var _props = props,
      getUserConfirmation = _props.getUserConfirmation,
      _props$initialEntries = _props.initialEntries,
      initialEntries = _props$initialEntries === void 0 ? ['/'] : _props$initialEntries,
      _props$initialIndex = _props.initialIndex,
      initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex,
      _props$keyLength = _props.keyLength,
      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var transitionManager = createTransitionManager();

  function setState(nextState) {
    (0,esm_extends/* ["default"] */.A)(history, nextState);

    history.length = history.entries.length;
    transitionManager.notifyListeners(history.location, history.action);
  }

  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? createLocation(entry, undefined, createKey()) : createLocation(entry, undefined, entry.key || createKey());
  }); // Public interface

  var createHref = createPath;

  function push(path, state) {
     false ? 0 : void 0;
    var action = 'PUSH';
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;
      var nextEntries = history.entries.slice(0);

      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  }

  function replace(path, state) {
     false ? 0 : void 0;
    var action = 'REPLACE';
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      history.entries[history.index] = location;
      setState({
        action: action,
        location: location
      });
    });
  }

  function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);
    var action = 'POP';
    var location = history.entries[nextIndex];
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  }

  function goBack() {
    go(-1);
  }

  function goForward() {
    go(1);
  }

  function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  }

  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }

    return transitionManager.setPrompt(prompt);
  }

  function listen(listener) {
    return transitionManager.appendListener(listener);
  }

  var history = {
    length: entries.length,
    action: 'POP',
    location: entries[index],
    index: index,
    entries: entries,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };
  return history;
}




}),
4146: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


var reactIs = __webpack_require__(44363);

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

module.exports = hoistNonReactStatics;


}),
20311: (function (module) {
"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (false) {}

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;


}),
64634: (function (module) {
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};


}),
5947: (function (module) {
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */

;(function(root, factory) {

  if (typeof define === 'function' && define.amd) {
    define(factory);
  } else if (true) {
    module.exports = factory();
  } else {}

})(this, function() {
  var NProgress = {};

  NProgress.version = '0.2.0';

  var Settings = NProgress.settings = {
    minimum: 0.08,
    easing: 'ease',
    positionUsing: '',
    speed: 200,
    trickle: true,
    trickleRate: 0.02,
    trickleSpeed: 800,
    showSpinner: true,
    barSelector: '[role="bar"]',
    spinnerSelector: '[role="spinner"]',
    parent: 'body',
    template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
  };

  /**
   * Updates configuration.
   *
   *     NProgress.configure({
   *       minimum: 0.1
   *     });
   */
  NProgress.configure = function(options) {
    var key, value;
    for (key in options) {
      value = options[key];
      if (value !== undefined && options.hasOwnProperty(key)) Settings[key] = value;
    }

    return this;
  };

  /**
   * Last number.
   */

  NProgress.status = null;

  /**
   * Sets the progress bar status, where `n` is a number from `0.0` to `1.0`.
   *
   *     NProgress.set(0.4);
   *     NProgress.set(1.0);
   */

  NProgress.set = function(n) {
    var started = NProgress.isStarted();

    n = clamp(n, Settings.minimum, 1);
    NProgress.status = (n === 1 ? null : n);

    var progress = NProgress.render(!started),
        bar      = progress.querySelector(Settings.barSelector),
        speed    = Settings.speed,
        ease     = Settings.easing;

    progress.offsetWidth; /* Repaint */

    queue(function(next) {
      // Set positionUsing if it hasn't already been set
      if (Settings.positionUsing === '') Settings.positionUsing = NProgress.getPositioningCSS();

      // Add transition
      css(bar, barPositionCSS(n, speed, ease));

      if (n === 1) {
        // Fade out
        css(progress, { 
          transition: 'none', 
          opacity: 1 
        });
        progress.offsetWidth; /* Repaint */

        setTimeout(function() {
          css(progress, { 
            transition: 'all ' + speed + 'ms linear', 
            opacity: 0 
          });
          setTimeout(function() {
            NProgress.remove();
            next();
          }, speed);
        }, speed);
      } else {
        setTimeout(next, speed);
      }
    });

    return this;
  };

  NProgress.isStarted = function() {
    return typeof NProgress.status === 'number';
  };

  /**
   * Shows the progress bar.
   * This is the same as setting the status to 0%, except that it doesn't go backwards.
   *
   *     NProgress.start();
   *
   */
  NProgress.start = function() {
    if (!NProgress.status) NProgress.set(0);

    var work = function() {
      setTimeout(function() {
        if (!NProgress.status) return;
        NProgress.trickle();
        work();
      }, Settings.trickleSpeed);
    };

    if (Settings.trickle) work();

    return this;
  };

  /**
   * Hides the progress bar.
   * This is the *sort of* the same as setting the status to 100%, with the
   * difference being `done()` makes some placebo effect of some realistic motion.
   *
   *     NProgress.done();
   *
   * If `true` is passed, it will show the progress bar even if its hidden.
   *
   *     NProgress.done(true);
   */

  NProgress.done = function(force) {
    if (!force && !NProgress.status) return this;

    return NProgress.inc(0.3 + 0.5 * Math.random()).set(1);
  };

  /**
   * Increments by a random amount.
   */

  NProgress.inc = function(amount) {
    var n = NProgress.status;

    if (!n) {
      return NProgress.start();
    } else {
      if (typeof amount !== 'number') {
        amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95);
      }

      n = clamp(n + amount, 0, 0.994);
      return NProgress.set(n);
    }
  };

  NProgress.trickle = function() {
    return NProgress.inc(Math.random() * Settings.trickleRate);
  };

  /**
   * Waits for all supplied jQuery promises and
   * increases the progress as the promises resolve.
   *
   * @param $promise jQUery Promise
   */
  (function() {
    var initial = 0, current = 0;

    NProgress.promise = function($promise) {
      if (!$promise || $promise.state() === "resolved") {
        return this;
      }

      if (current === 0) {
        NProgress.start();
      }

      initial++;
      current++;

      $promise.always(function() {
        current--;
        if (current === 0) {
            initial = 0;
            NProgress.done();
        } else {
            NProgress.set((initial - current) / initial);
        }
      });

      return this;
    };

  })();

  /**
   * (Internal) renders the progress bar markup based on the `template`
   * setting.
   */

  NProgress.render = function(fromStart) {
    if (NProgress.isRendered()) return document.getElementById('nprogress');

    addClass(document.documentElement, 'nprogress-busy');
    
    var progress = document.createElement('div');
    progress.id = 'nprogress';
    progress.innerHTML = Settings.template;

    var bar      = progress.querySelector(Settings.barSelector),
        perc     = fromStart ? '-100' : toBarPerc(NProgress.status || 0),
        parent   = document.querySelector(Settings.parent),
        spinner;
    
    css(bar, {
      transition: 'all 0 linear',
      transform: 'translate3d(' + perc + '%,0,0)'
    });

    if (!Settings.showSpinner) {
      spinner = progress.querySelector(Settings.spinnerSelector);
      spinner && removeElement(spinner);
    }

    if (parent != document.body) {
      addClass(parent, 'nprogress-custom-parent');
    }

    parent.appendChild(progress);
    return progress;
  };

  /**
   * Removes the element. Opposite of render().
   */

  NProgress.remove = function() {
    removeClass(document.documentElement, 'nprogress-busy');
    removeClass(document.querySelector(Settings.parent), 'nprogress-custom-parent');
    var progress = document.getElementById('nprogress');
    progress && removeElement(progress);
  };

  /**
   * Checks if the progress bar is rendered.
   */

  NProgress.isRendered = function() {
    return !!document.getElementById('nprogress');
  };

  /**
   * Determine which positioning CSS rule to use.
   */

  NProgress.getPositioningCSS = function() {
    // Sniff on document.body.style
    var bodyStyle = document.body.style;

    // Sniff prefixes
    var vendorPrefix = ('WebkitTransform' in bodyStyle) ? 'Webkit' :
                       ('MozTransform' in bodyStyle) ? 'Moz' :
                       ('msTransform' in bodyStyle) ? 'ms' :
                       ('OTransform' in bodyStyle) ? 'O' : '';

    if (vendorPrefix + 'Perspective' in bodyStyle) {
      // Modern browsers with 3D support, e.g. Webkit, IE10
      return 'translate3d';
    } else if (vendorPrefix + 'Transform' in bodyStyle) {
      // Browsers without 3D support, e.g. IE9
      return 'translate';
    } else {
      // Browsers without translate() support, e.g. IE7-8
      return 'margin';
    }
  };

  /**
   * Helpers
   */

  function clamp(n, min, max) {
    if (n < min) return min;
    if (n > max) return max;
    return n;
  }

  /**
   * (Internal) converts a percentage (`0..1`) to a bar translateX
   * percentage (`-100%..0%`).
   */

  function toBarPerc(n) {
    return (-1 + n) * 100;
  }


  /**
   * (Internal) returns the correct CSS for changing the bar's
   * position given an n percentage, and speed and ease from Settings
   */

  function barPositionCSS(n, speed, ease) {
    var barCSS;

    if (Settings.positionUsing === 'translate3d') {
      barCSS = { transform: 'translate3d('+toBarPerc(n)+'%,0,0)' };
    } else if (Settings.positionUsing === 'translate') {
      barCSS = { transform: 'translate('+toBarPerc(n)+'%,0)' };
    } else {
      barCSS = { 'margin-left': toBarPerc(n)+'%' };
    }

    barCSS.transition = 'all '+speed+'ms '+ease;

    return barCSS;
  }

  /**
   * (Internal) Queues a function to be executed.
   */

  var queue = (function() {
    var pending = [];
    
    function next() {
      var fn = pending.shift();
      if (fn) {
        fn(next);
      }
    }

    return function(fn) {
      pending.push(fn);
      if (pending.length == 1) next();
    };
  })();

  /**
   * (Internal) Applies css properties to an element, similar to the jQuery 
   * css method.
   *
   * While this helper does assist with vendor prefixed property names, it 
   * does not perform any manipulation of values prior to setting styles.
   */

  var css = (function() {
    var cssPrefixes = [ 'Webkit', 'O', 'Moz', 'ms' ],
        cssProps    = {};

    function camelCase(string) {
      return string.replace(/^-ms-/, 'ms-').replace(/-([\da-z])/gi, function(match, letter) {
        return letter.toUpperCase();
      });
    }

    function getVendorProp(name) {
      var style = document.body.style;
      if (name in style) return name;

      var i = cssPrefixes.length,
          capName = name.charAt(0).toUpperCase() + name.slice(1),
          vendorName;
      while (i--) {
        vendorName = cssPrefixes[i] + capName;
        if (vendorName in style) return vendorName;
      }

      return name;
    }

    function getStyleProp(name) {
      name = camelCase(name);
      return cssProps[name] || (cssProps[name] = getVendorProp(name));
    }

    function applyCss(element, prop, value) {
      prop = getStyleProp(prop);
      element.style[prop] = value;
    }

    return function(element, properties) {
      var args = arguments,
          prop, 
          value;

      if (args.length == 2) {
        for (prop in properties) {
          value = properties[prop];
          if (value !== undefined && properties.hasOwnProperty(prop)) applyCss(element, prop, value);
        }
      } else {
        applyCss(element, args[1], args[2]);
      }
    }
  })();

  /**
   * (Internal) Determines if an element or space separated list of class names contains a class name.
   */

  function hasClass(element, name) {
    var list = typeof element == 'string' ? element : classList(element);
    return list.indexOf(' ' + name + ' ') >= 0;
  }

  /**
   * (Internal) Adds a class to an element.
   */

  function addClass(element, name) {
    var oldList = classList(element),
        newList = oldList + name;

    if (hasClass(oldList, name)) return; 

    // Trim the opening space.
    element.className = newList.substring(1);
  }

  /**
   * (Internal) Removes a class from an element.
   */

  function removeClass(element, name) {
    var oldList = classList(element),
        newList;

    if (!hasClass(element, name)) return;

    // Replace the class name.
    newList = oldList.replace(' ' + name + ' ', ' ');

    // Trim the opening and closing spaces.
    element.className = newList.substring(1, newList.length - 1);
  }

  /**
   * (Internal) Gets a space separated list of the class names on the element. 
   * The list is wrapped with a single space on each end to facilitate finding 
   * matches within the list.
   */

  function classList(element) {
    return (' ' + (element.className || '') + ' ').replace(/\s+/gi, ' ');
  }

  /**
   * (Internal) Removes an element from the DOM.
   */

  function removeElement(element) {
    element && element.parentNode && element.parentNode.removeChild(element);
  }

  return NProgress;
});



}),
19700: (function () {
(function (Prism) {

	/**
	 * Returns the placeholder for the given language id and index.
	 *
	 * @param {string} language
	 * @param {string|number} index
	 * @returns {string}
	 */
	function getPlaceholder(language, index) {
		return '___' + language.toUpperCase() + index + '___';
	}

	Object.defineProperties(Prism.languages['markup-templating'] = {}, {
		buildPlaceholders: {
			/**
			 * Tokenize all inline templating expressions matching `placeholderPattern`.
			 *
			 * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns
			 * `true` will be replaced.
			 *
			 * @param {object} env The environment of the `before-tokenize` hook.
			 * @param {string} language The language id.
			 * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.
			 * @param {(match: string) => boolean} [replaceFilter]
			 */
			value: function (env, language, placeholderPattern, replaceFilter) {
				if (env.language !== language) {
					return;
				}

				var tokenStack = env.tokenStack = [];

				env.code = env.code.replace(placeholderPattern, function (match) {
					if (typeof replaceFilter === 'function' && !replaceFilter(match)) {
						return match;
					}
					var i = tokenStack.length;
					var placeholder;

					// Check for existing strings
					while (env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1) {
						++i;
					}

					// Create a sparse array
					tokenStack[i] = match;

					return placeholder;
				});

				// Switch the grammar to markup
				env.grammar = Prism.languages.markup;
			}
		},
		tokenizePlaceholders: {
			/**
			 * Replace placeholders with proper tokens after tokenizing.
			 *
			 * @param {object} env The environment of the `after-tokenize` hook.
			 * @param {string} language The language id.
			 */
			value: function (env, language) {
				if (env.language !== language || !env.tokenStack) {
					return;
				}

				// Switch the grammar back
				env.grammar = Prism.languages[language];

				var j = 0;
				var keys = Object.keys(env.tokenStack);

				function walkTokens(tokens) {
					for (var i = 0; i < tokens.length; i++) {
						// all placeholders are replaced already
						if (j >= keys.length) {
							break;
						}

						var token = tokens[i];
						if (typeof token === 'string' || (token.content && typeof token.content === 'string')) {
							var k = keys[j];
							var t = env.tokenStack[k];
							var s = typeof token === 'string' ? token : token.content;
							var placeholder = getPlaceholder(language, k);

							var index = s.indexOf(placeholder);
							if (index > -1) {
								++j;

								var before = s.substring(0, index);
								var middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), 'language-' + language, t);
								var after = s.substring(index + placeholder.length);

								var replacement = [];
								if (before) {
									replacement.push.apply(replacement, walkTokens([before]));
								}
								replacement.push(middle);
								if (after) {
									replacement.push.apply(replacement, walkTokens([after]));
								}

								if (typeof token === 'string') {
									tokens.splice.apply(tokens, [i, 1].concat(replacement));
								} else {
									token.content = replacement;
								}
							}
						} else if (token.content /* && typeof token.content !== 'string' */) {
							walkTokens(token.content);
						}
					}

					return tokens;
				}

				walkTokens(env.tokens);
			}
		}
	});

}(Prism));


}),
43554: (function () {
/**
 * Original by Aaron Harun: http://aahacreative.com/2012/07/31/php-syntax-highlighting-prism/
 * Modified by Miles Johnson: http://milesj.me
 * Rewritten by Tom Pavelec
 *
 * Supports PHP 5.3 - 8.0
 */
(function (Prism) {
	var comment = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/;
	var constant = [
		{
			pattern: /\b(?:false|true)\b/i,
			alias: 'boolean'
		},
		{
			pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
			greedy: true,
			lookbehind: true,
		},
		{
			pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
			greedy: true,
			lookbehind: true,
		},
		/\b(?:null)\b/i,
		/\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/,
	];
	var number = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i;
	var operator = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/;
	var punctuation = /[{}\[\](),:;]/;

	Prism.languages.php = {
		'delimiter': {
			pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
			alias: 'important'
		},
		'comment': comment,
		'variable': /\$+(?:\w+\b|(?=\{))/,
		'package': {
			pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
			lookbehind: true,
			inside: {
				'punctuation': /\\/
			}
		},
		'class-name-definition': {
			pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
			lookbehind: true,
			alias: 'class-name'
		},
		'function-definition': {
			pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
			lookbehind: true,
			alias: 'function'
		},
		'keyword': [
			{
				pattern: /(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i,
				alias: 'type-casting',
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i,
				alias: 'type-hint',
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|never|object|self|static|string|void)\b/i,
				alias: 'return-type',
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i,
				alias: 'type-declaration',
				greedy: true
			},
			{
				pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i,
				alias: 'type-declaration',
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /\b(?:parent|self|static)(?=\s*::)/i,
				alias: 'static-context',
				greedy: true
			},
			{
				// yield from
				pattern: /(\byield\s+)from\b/i,
				lookbehind: true
			},
			// `class` is always a keyword unlike other keywords
			/\bclass\b/i,
			{
				// https://www.php.net/manual/en/reserved.keywords.php
				//
				// keywords cannot be preceded by "->"
				// the complex lookbehind means `(?<!(?:->|::)\s*)`
				pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|never|new|or|parent|print|private|protected|public|readonly|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i,
				lookbehind: true
			}
		],
		'argument-name': {
			pattern: /([(,]\s*)\b[a-z_]\w*(?=\s*:(?!:))/i,
			lookbehind: true
		},
		'class-name': [
			{
				pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,
				greedy: true
			},
			{
				pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
				alias: 'class-name-fully-qualified',
				greedy: true,
				lookbehind: true,
				inside: {
					'punctuation': /\\/
				}
			},
			{
				pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
				alias: 'class-name-fully-qualified',
				greedy: true,
				inside: {
					'punctuation': /\\/
				}
			},
			{
				pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
				alias: 'class-name-fully-qualified',
				greedy: true,
				lookbehind: true,
				inside: {
					'punctuation': /\\/
				}
			},
			{
				pattern: /\b[a-z_]\w*(?=\s*\$)/i,
				alias: 'type-declaration',
				greedy: true
			},
			{
				pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
				alias: ['class-name-fully-qualified', 'type-declaration'],
				greedy: true,
				inside: {
					'punctuation': /\\/
				}
			},
			{
				pattern: /\b[a-z_]\w*(?=\s*::)/i,
				alias: 'static-context',
				greedy: true
			},
			{
				pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
				alias: ['class-name-fully-qualified', 'static-context'],
				greedy: true,
				inside: {
					'punctuation': /\\/
				}
			},
			{
				pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
				alias: 'type-hint',
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
				alias: ['class-name-fully-qualified', 'type-hint'],
				greedy: true,
				lookbehind: true,
				inside: {
					'punctuation': /\\/
				}
			},
			{
				pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
				alias: 'return-type',
				greedy: true,
				lookbehind: true
			},
			{
				pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
				alias: ['class-name-fully-qualified', 'return-type'],
				greedy: true,
				lookbehind: true,
				inside: {
					'punctuation': /\\/
				}
			}
		],
		'constant': constant,
		'function': {
			pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
			lookbehind: true,
			inside: {
				'punctuation': /\\/
			}
		},
		'property': {
			pattern: /(->\s*)\w+/,
			lookbehind: true
		},
		'number': number,
		'operator': operator,
		'punctuation': punctuation
	};

	var string_interpolation = {
		pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
		lookbehind: true,
		inside: Prism.languages.php
	};

	var string = [
		{
			pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
			alias: 'nowdoc-string',
			greedy: true,
			inside: {
				'delimiter': {
					pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
					alias: 'symbol',
					inside: {
						'punctuation': /^<<<'?|[';]$/
					}
				}
			}
		},
		{
			pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
			alias: 'heredoc-string',
			greedy: true,
			inside: {
				'delimiter': {
					pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
					alias: 'symbol',
					inside: {
						'punctuation': /^<<<"?|[";]$/
					}
				},
				'interpolation': string_interpolation
			}
		},
		{
			pattern: /`(?:\\[\s\S]|[^\\`])*`/,
			alias: 'backtick-quoted-string',
			greedy: true
		},
		{
			pattern: /'(?:\\[\s\S]|[^\\'])*'/,
			alias: 'single-quoted-string',
			greedy: true
		},
		{
			pattern: /"(?:\\[\s\S]|[^\\"])*"/,
			alias: 'double-quoted-string',
			greedy: true,
			inside: {
				'interpolation': string_interpolation
			}
		}
	];

	Prism.languages.insertBefore('php', 'variable', {
		'string': string,
		'attribute': {
			pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
			greedy: true,
			inside: {
				'attribute-content': {
					pattern: /^(#\[)[\s\S]+(?=\]$)/,
					lookbehind: true,
					// inside can appear subset of php
					inside: {
						'comment': comment,
						'string': string,
						'attribute-class-name': [
							{
								pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
								alias: 'class-name',
								greedy: true,
								lookbehind: true
							},
							{
								pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
								alias: [
									'class-name',
									'class-name-fully-qualified'
								],
								greedy: true,
								lookbehind: true,
								inside: {
									'punctuation': /\\/
								}
							}
						],
						'constant': constant,
						'number': number,
						'operator': operator,
						'punctuation': punctuation
					}
				},
				'delimiter': {
					pattern: /^#\[|\]$/,
					alias: 'punctuation'
				}
			}
		},
	});

	Prism.hooks.add('before-tokenize', function (env) {
		if (!/<\?/.test(env.code)) {
			return;
		}

		var phpPattern = /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
		Prism.languages['markup-templating'].buildPlaceholders(env, 'php', phpPattern);
	});

	Prism.hooks.add('after-tokenize', function (env) {
		Prism.languages['markup-templating'].tokenizePlaceholders(env, 'php');
	});

}(Prism));


}),
30905: (function () {
(function (Prism) {

	var powershell = Prism.languages.powershell = {
		'comment': [
			{
				pattern: /(^|[^`])<#[\s\S]*?#>/,
				lookbehind: true
			},
			{
				pattern: /(^|[^`])#.*/,
				lookbehind: true
			}
		],
		'string': [
			{
				pattern: /"(?:`[\s\S]|[^`"])*"/,
				greedy: true,
				inside: null // see below
			},
			{
				pattern: /'(?:[^']|'')*'/,
				greedy: true
			}
		],
		// Matches name spaces as well as casts, attribute decorators. Force starting with letter to avoid matching array indices
		// Supports two levels of nested brackets (e.g. `[OutputType([System.Collections.Generic.List[int]])]`)
		'namespace': /\[[a-z](?:\[(?:\[[^\]]*\]|[^\[\]])*\]|[^\[\]])*\]/i,
		'boolean': /\$(?:false|true)\b/i,
		'variable': /\$\w+\b/,
		// Cmdlets and aliases. Aliases should come last, otherwise "write" gets preferred over "write-host" for example
		// Get-Command | ?{ $_.ModuleName -match "Microsoft.PowerShell.(Util|Core|Management)" }
		// Get-Alias | ?{ $_.ReferencedCommand.Module.Name -match "Microsoft.PowerShell.(Util|Core|Management)" }
		'function': [
			/\b(?:Add|Approve|Assert|Backup|Block|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|ForEach|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Sort|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Tee|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Where|Write)-[a-z]+\b/i,
			/\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i
		],
		// per http://technet.microsoft.com/en-us/library/hh847744.aspx
		'keyword': /\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,
		'operator': {
			pattern: /(^|\W)(?:!|-(?:b?(?:and|x?or)|as|(?:Not)?(?:Contains|In|Like|Match)|eq|ge|gt|is(?:Not)?|Join|le|lt|ne|not|Replace|sh[lr])\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,
			lookbehind: true
		},
		'punctuation': /[|{}[\];(),.]/
	};

	// Variable interpolation inside strings, and nested expressions
	powershell.string[0].inside = {
		'function': {
			// Allow for one level of nesting
			pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/,
			lookbehind: true,
			inside: powershell
		},
		'boolean': powershell.boolean,
		'variable': powershell.variable,
	};

}(Prism));


}),
52342: (function () {
Prism.languages.python = {
	'comment': {
		pattern: /(^|[^\\])#.*/,
		lookbehind: true,
		greedy: true
	},
	'string-interpolation': {
		pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
		greedy: true,
		inside: {
			'interpolation': {
				// "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
				pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
				lookbehind: true,
				inside: {
					'format-spec': {
						pattern: /(:)[^:(){}]+(?=\}$)/,
						lookbehind: true
					},
					'conversion-option': {
						pattern: /![sra](?=[:}]$)/,
						alias: 'punctuation'
					},
					rest: null
				}
			},
			'string': /[\s\S]+/
		}
	},
	'triple-quoted-string': {
		pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
		greedy: true,
		alias: 'string'
	},
	'string': {
		pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
		greedy: true
	},
	'function': {
		pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
		lookbehind: true
	},
	'class-name': {
		pattern: /(\bclass\s+)\w+/i,
		lookbehind: true
	},
	'decorator': {
		pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
		lookbehind: true,
		alias: ['annotation', 'punctuation'],
		inside: {
			'punctuation': /\./
		}
	},
	'keyword': /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
	'builtin': /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
	'boolean': /\b(?:False|None|True)\b/,
	'number': /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
	'operator': /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
	'punctuation': /[{}[\];(),.:]/
};

Prism.languages.python['string-interpolation'].inside['interpolation'].inside.rest = Prism.languages.python;

Prism.languages.py = Prism.languages.python;


}),
75166: (function (module, __unused_webpack_exports, __webpack_require__) {
var map = {
  "./prism-php": "43554",
  "./prism-powershell": "30905",
  "./prism-python": "52342"
};


function webpackContext(req) {
  var id = webpackContextResolve(req);
  return __webpack_require__(id);
}
function webpackContextResolve(req) {
  if(!__webpack_require__.o(map, req)) {
    var e = new Error("Cannot find module '" + req + "'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
  }
  return map[req];
}
webpackContext.keys = function webpackContextKeys() {
  return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 75166;


}),
2694: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = __webpack_require__(6925);

function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,

    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };

  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


}),
5556: (function (module, __unused_webpack_exports, __webpack_require__) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (false) { var throwOnDirectAccess, ReactIs } else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(2694)();
}


}),
6925: (function (module) {
"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


}),
31247: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/

var Scheduler = __webpack_require__(69982),
  React = __webpack_require__(96540),
  ReactDOM = __webpack_require__(40961);
function formatProdErrorMessage(code) {
  var url = "https://react.dev/errors/" + code;
  if (1 < arguments.length) {
    url += "?args[]=" + encodeURIComponent(arguments[1]);
    for (var i = 2; i < arguments.length; i++)
      url += "&args[]=" + encodeURIComponent(arguments[i]);
  }
  return (
    "Minified React error #" +
    code +
    "; visit " +
    url +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
function isValidContainer(node) {
  return !(
    !node ||
    (1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType)
  );
}
function getNearestMountedFiber(fiber) {
  var node = fiber,
    nearestMounted = fiber;
  if (fiber.alternate) for (; node.return; ) node = node.return;
  else {
    fiber = node;
    do
      (node = fiber),
        0 !== (node.flags & 4098) && (nearestMounted = node.return),
        (fiber = node.return);
    while (fiber);
  }
  return 3 === node.tag ? nearestMounted : null;
}
function getSuspenseInstanceFromFiber(fiber) {
  if (13 === fiber.tag) {
    var suspenseState = fiber.memoizedState;
    null === suspenseState &&
      ((fiber = fiber.alternate),
      null !== fiber && (suspenseState = fiber.memoizedState));
    if (null !== suspenseState) return suspenseState.dehydrated;
  }
  return null;
}
function getActivityInstanceFromFiber(fiber) {
  if (31 === fiber.tag) {
    var activityState = fiber.memoizedState;
    null === activityState &&
      ((fiber = fiber.alternate),
      null !== fiber && (activityState = fiber.memoizedState));
    if (null !== activityState) return activityState.dehydrated;
  }
  return null;
}
function assertIsMounted(fiber) {
  if (getNearestMountedFiber(fiber) !== fiber)
    throw Error(formatProdErrorMessage(188));
}
function findCurrentFiberUsingSlowPath(fiber) {
  var alternate = fiber.alternate;
  if (!alternate) {
    alternate = getNearestMountedFiber(fiber);
    if (null === alternate) throw Error(formatProdErrorMessage(188));
    return alternate !== fiber ? null : fiber;
  }
  for (var a = fiber, b = alternate; ; ) {
    var parentA = a.return;
    if (null === parentA) break;
    var parentB = parentA.alternate;
    if (null === parentB) {
      b = parentA.return;
      if (null !== b) {
        a = b;
        continue;
      }
      break;
    }
    if (parentA.child === parentB.child) {
      for (parentB = parentA.child; parentB; ) {
        if (parentB === a) return assertIsMounted(parentA), fiber;
        if (parentB === b) return assertIsMounted(parentA), alternate;
        parentB = parentB.sibling;
      }
      throw Error(formatProdErrorMessage(188));
    }
    if (a.return !== b.return) (a = parentA), (b = parentB);
    else {
      for (var didFindChild = !1, child$0 = parentA.child; child$0; ) {
        if (child$0 === a) {
          didFindChild = !0;
          a = parentA;
          b = parentB;
          break;
        }
        if (child$0 === b) {
          didFindChild = !0;
          b = parentA;
          a = parentB;
          break;
        }
        child$0 = child$0.sibling;
      }
      if (!didFindChild) {
        for (child$0 = parentB.child; child$0; ) {
          if (child$0 === a) {
            didFindChild = !0;
            a = parentB;
            b = parentA;
            break;
          }
          if (child$0 === b) {
            didFindChild = !0;
            b = parentB;
            a = parentA;
            break;
          }
          child$0 = child$0.sibling;
        }
        if (!didFindChild) throw Error(formatProdErrorMessage(189));
      }
    }
    if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
  }
  if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
  return a.stateNode.current === a ? fiber : alternate;
}
function findCurrentHostFiberImpl(node) {
  var tag = node.tag;
  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
  for (node = node.child; null !== node; ) {
    tag = findCurrentHostFiberImpl(node);
    if (null !== tag) return tag;
    node = node.sibling;
  }
  return null;
}
var assign = Object.assign,
  REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
  REACT_PORTAL_TYPE = Symbol.for("react.portal"),
  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
  REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
  REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
  REACT_MEMO_TYPE = Symbol.for("react.memo"),
  REACT_LAZY_TYPE = Symbol.for("react.lazy");
Symbol.for("react.scope");
var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
Symbol.for("react.legacy_hidden");
Symbol.for("react.tracing_marker");
var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
Symbol.for("react.view_transition");
var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
function getIteratorFn(maybeIterable) {
  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
  maybeIterable =
    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
    maybeIterable["@@iterator"];
  return "function" === typeof maybeIterable ? maybeIterable : null;
}
var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
function getComponentNameFromType(type) {
  if (null == type) return null;
  if ("function" === typeof type)
    return type.$$typeof === REACT_CLIENT_REFERENCE
      ? null
      : type.displayName || type.name || null;
  if ("string" === typeof type) return type;
  switch (type) {
    case REACT_FRAGMENT_TYPE:
      return "Fragment";
    case REACT_PROFILER_TYPE:
      return "Profiler";
    case REACT_STRICT_MODE_TYPE:
      return "StrictMode";
    case REACT_SUSPENSE_TYPE:
      return "Suspense";
    case REACT_SUSPENSE_LIST_TYPE:
      return "SuspenseList";
    case REACT_ACTIVITY_TYPE:
      return "Activity";
  }
  if ("object" === typeof type)
    switch (type.$$typeof) {
      case REACT_PORTAL_TYPE:
        return "Portal";
      case REACT_CONTEXT_TYPE:
        return type.displayName || "Context";
      case REACT_CONSUMER_TYPE:
        return (type._context.displayName || "Context") + ".Consumer";
      case REACT_FORWARD_REF_TYPE:
        var innerType = type.render;
        type = type.displayName;
        type ||
          ((type = innerType.displayName || innerType.name || ""),
          (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
        return type;
      case REACT_MEMO_TYPE:
        return (
          (innerType = type.displayName || null),
          null !== innerType
            ? innerType
            : getComponentNameFromType(type.type) || "Memo"
        );
      case REACT_LAZY_TYPE:
        innerType = type._payload;
        type = type._init;
        try {
          return getComponentNameFromType(type(innerType));
        } catch (x) {}
    }
  return null;
}
var isArrayImpl = Array.isArray,
  ReactSharedInternals =
    React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
  ReactDOMSharedInternals =
    ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
  sharedNotPendingObject = {
    pending: !1,
    data: null,
    method: null,
    action: null
  },
  valueStack = [],
  index = -1;
function createCursor(defaultValue) {
  return { current: defaultValue };
}
function pop(cursor) {
  0 > index ||
    ((cursor.current = valueStack[index]), (valueStack[index] = null), index--);
}
function push(cursor, value) {
  index++;
  valueStack[index] = cursor.current;
  cursor.current = value;
}
var contextStackCursor = createCursor(null),
  contextFiberStackCursor = createCursor(null),
  rootInstanceStackCursor = createCursor(null),
  hostTransitionProviderCursor = createCursor(null);
function pushHostContainer(fiber, nextRootInstance) {
  push(rootInstanceStackCursor, nextRootInstance);
  push(contextFiberStackCursor, fiber);
  push(contextStackCursor, null);
  switch (nextRootInstance.nodeType) {
    case 9:
    case 11:
      fiber = (fiber = nextRootInstance.documentElement)
        ? (fiber = fiber.namespaceURI)
          ? getOwnHostContext(fiber)
          : 0
        : 0;
      break;
    default:
      if (
        ((fiber = nextRootInstance.tagName),
        (nextRootInstance = nextRootInstance.namespaceURI))
      )
        (nextRootInstance = getOwnHostContext(nextRootInstance)),
          (fiber = getChildHostContextProd(nextRootInstance, fiber));
      else
        switch (fiber) {
          case "svg":
            fiber = 1;
            break;
          case "math":
            fiber = 2;
            break;
          default:
            fiber = 0;
        }
  }
  pop(contextStackCursor);
  push(contextStackCursor, fiber);
}
function popHostContainer() {
  pop(contextStackCursor);
  pop(contextFiberStackCursor);
  pop(rootInstanceStackCursor);
}
function pushHostContext(fiber) {
  null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
  var context = contextStackCursor.current;
  var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
  context !== JSCompiler_inline_result &&
    (push(contextFiberStackCursor, fiber),
    push(contextStackCursor, JSCompiler_inline_result));
}
function popHostContext(fiber) {
  contextFiberStackCursor.current === fiber &&
    (pop(contextStackCursor), pop(contextFiberStackCursor));
  hostTransitionProviderCursor.current === fiber &&
    (pop(hostTransitionProviderCursor),
    (HostTransitionContext._currentValue = sharedNotPendingObject));
}
var prefix, suffix;
function describeBuiltInComponentFrame(name) {
  if (void 0 === prefix)
    try {
      throw Error();
    } catch (x) {
      var match = x.stack.trim().match(/\n( *(at )?)/);
      prefix = (match && match[1]) || "";
      suffix =
        -1 < x.stack.indexOf("\n    at")
          ? " (<anonymous>)"
          : -1 < x.stack.indexOf("@")
            ? "@unknown:0:0"
            : "";
    }
  return "\n" + prefix + name + suffix;
}
var reentry = !1;
function describeNativeComponentFrame(fn, construct) {
  if (!fn || reentry) return "";
  reentry = !0;
  var previousPrepareStackTrace = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    var RunInRootFrame = {
      DetermineComponentFrameRoot: function () {
        try {
          if (construct) {
            var Fake = function () {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function () {
                throw Error();
              }
            });
            if ("object" === typeof Reflect && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                var control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x$1) {
                control = x$1;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x$2) {
              control = x$2;
            }
            (Fake = fn()) &&
              "function" === typeof Fake.catch &&
              Fake.catch(function () {});
          }
        } catch (sample) {
          if (sample && control && "string" === typeof sample.stack)
            return [sample.stack, control.stack];
        }
        return [null, null];
      }
    };
    RunInRootFrame.DetermineComponentFrameRoot.displayName =
      "DetermineComponentFrameRoot";
    var namePropDescriptor = Object.getOwnPropertyDescriptor(
      RunInRootFrame.DetermineComponentFrameRoot,
      "name"
    );
    namePropDescriptor &&
      namePropDescriptor.configurable &&
      Object.defineProperty(
        RunInRootFrame.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),
      sampleStack = _RunInRootFrame$Deter[0],
      controlStack = _RunInRootFrame$Deter[1];
    if (sampleStack && controlStack) {
      var sampleLines = sampleStack.split("\n"),
        controlLines = controlStack.split("\n");
      for (
        namePropDescriptor = RunInRootFrame = 0;
        RunInRootFrame < sampleLines.length &&
        !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot");

      )
        RunInRootFrame++;
      for (
        ;
        namePropDescriptor < controlLines.length &&
        !controlLines[namePropDescriptor].includes(
          "DetermineComponentFrameRoot"
        );

      )
        namePropDescriptor++;
      if (
        RunInRootFrame === sampleLines.length ||
        namePropDescriptor === controlLines.length
      )
        for (
          RunInRootFrame = sampleLines.length - 1,
            namePropDescriptor = controlLines.length - 1;
          1 <= RunInRootFrame &&
          0 <= namePropDescriptor &&
          sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];

        )
          namePropDescriptor--;
      for (
        ;
        1 <= RunInRootFrame && 0 <= namePropDescriptor;
        RunInRootFrame--, namePropDescriptor--
      )
        if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
          if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
            do
              if (
                (RunInRootFrame--,
                namePropDescriptor--,
                0 > namePropDescriptor ||
                  sampleLines[RunInRootFrame] !==
                    controlLines[namePropDescriptor])
              ) {
                var frame =
                  "\n" +
                  sampleLines[RunInRootFrame].replace(" at new ", " at ");
                fn.displayName &&
                  frame.includes("<anonymous>") &&
                  (frame = frame.replace("<anonymous>", fn.displayName));
                return frame;
              }
            while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
          }
          break;
        }
    }
  } finally {
    (reentry = !1), (Error.prepareStackTrace = previousPrepareStackTrace);
  }
  return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "")
    ? describeBuiltInComponentFrame(previousPrepareStackTrace)
    : "";
}
function describeFiber(fiber, childFiber) {
  switch (fiber.tag) {
    case 26:
    case 27:
    case 5:
      return describeBuiltInComponentFrame(fiber.type);
    case 16:
      return describeBuiltInComponentFrame("Lazy");
    case 13:
      return fiber.child !== childFiber && null !== childFiber
        ? describeBuiltInComponentFrame("Suspense Fallback")
        : describeBuiltInComponentFrame("Suspense");
    case 19:
      return describeBuiltInComponentFrame("SuspenseList");
    case 0:
    case 15:
      return describeNativeComponentFrame(fiber.type, !1);
    case 11:
      return describeNativeComponentFrame(fiber.type.render, !1);
    case 1:
      return describeNativeComponentFrame(fiber.type, !0);
    case 31:
      return describeBuiltInComponentFrame("Activity");
    default:
      return "";
  }
}
function getStackByFiberInDevAndProd(workInProgress) {
  try {
    var info = "",
      previous = null;
    do
      (info += describeFiber(workInProgress, previous)),
        (previous = workInProgress),
        (workInProgress = workInProgress.return);
    while (workInProgress);
    return info;
  } catch (x) {
    return "\nError generating stack: " + x.message + "\n" + x.stack;
  }
}
var hasOwnProperty = Object.prototype.hasOwnProperty,
  scheduleCallback$3 = Scheduler.unstable_scheduleCallback,
  cancelCallback$1 = Scheduler.unstable_cancelCallback,
  shouldYield = Scheduler.unstable_shouldYield,
  requestPaint = Scheduler.unstable_requestPaint,
  now = Scheduler.unstable_now,
  getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
  ImmediatePriority = Scheduler.unstable_ImmediatePriority,
  UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
  NormalPriority$1 = Scheduler.unstable_NormalPriority,
  LowPriority = Scheduler.unstable_LowPriority,
  IdlePriority = Scheduler.unstable_IdlePriority,
  log$1 = Scheduler.log,
  unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,
  rendererID = null,
  injectedHook = null;
function setIsStrictModeForDevtools(newIsStrictMode) {
  "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
  if (injectedHook && "function" === typeof injectedHook.setStrictMode)
    try {
      injectedHook.setStrictMode(rendererID, newIsStrictMode);
    } catch (err) {}
}
var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
  log = Math.log,
  LN2 = Math.LN2;
function clz32Fallback(x) {
  x >>>= 0;
  return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;
}
var nextTransitionUpdateLane = 256,
  nextTransitionDeferredLane = 262144,
  nextRetryLane = 4194304;
function getHighestPriorityLanes(lanes) {
  var pendingSyncLanes = lanes & 42;
  if (0 !== pendingSyncLanes) return pendingSyncLanes;
  switch (lanes & -lanes) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
      return 64;
    case 128:
      return 128;
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
      return lanes & 261888;
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return lanes & 3932160;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
      return lanes & 62914560;
    case 67108864:
      return 67108864;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 0;
    default:
      return lanes;
  }
}
function getNextLanes(root, wipLanes, rootHasPendingCommit) {
  var pendingLanes = root.pendingLanes;
  if (0 === pendingLanes) return 0;
  var nextLanes = 0,
    suspendedLanes = root.suspendedLanes,
    pingedLanes = root.pingedLanes;
  root = root.warmLanes;
  var nonIdlePendingLanes = pendingLanes & 134217727;
  0 !== nonIdlePendingLanes
    ? ((pendingLanes = nonIdlePendingLanes & ~suspendedLanes),
      0 !== pendingLanes
        ? (nextLanes = getHighestPriorityLanes(pendingLanes))
        : ((pingedLanes &= nonIdlePendingLanes),
          0 !== pingedLanes
            ? (nextLanes = getHighestPriorityLanes(pingedLanes))
            : rootHasPendingCommit ||
              ((rootHasPendingCommit = nonIdlePendingLanes & ~root),
              0 !== rootHasPendingCommit &&
                (nextLanes = getHighestPriorityLanes(rootHasPendingCommit)))))
    : ((nonIdlePendingLanes = pendingLanes & ~suspendedLanes),
      0 !== nonIdlePendingLanes
        ? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))
        : 0 !== pingedLanes
          ? (nextLanes = getHighestPriorityLanes(pingedLanes))
          : rootHasPendingCommit ||
            ((rootHasPendingCommit = pendingLanes & ~root),
            0 !== rootHasPendingCommit &&
              (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
  return 0 === nextLanes
    ? 0
    : 0 !== wipLanes &&
        wipLanes !== nextLanes &&
        0 === (wipLanes & suspendedLanes) &&
        ((suspendedLanes = nextLanes & -nextLanes),
        (rootHasPendingCommit = wipLanes & -wipLanes),
        suspendedLanes >= rootHasPendingCommit ||
          (32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)))
      ? wipLanes
      : nextLanes;
}
function checkIfRootIsPrerendering(root, renderLanes) {
  return (
    0 ===
    (root.pendingLanes &
      ~(root.suspendedLanes & ~root.pingedLanes) &
      renderLanes)
  );
}
function computeExpirationTime(lane, currentTime) {
  switch (lane) {
    case 1:
    case 2:
    case 4:
    case 8:
    case 64:
      return currentTime + 250;
    case 16:
    case 32:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return currentTime + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
      return -1;
    case 67108864:
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function claimNextRetryLane() {
  var lane = nextRetryLane;
  nextRetryLane <<= 1;
  0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
  return lane;
}
function createLaneMap(initial) {
  for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
  return laneMap;
}
function markRootUpdated$1(root, updateLane) {
  root.pendingLanes |= updateLane;
  268435456 !== updateLane &&
    ((root.suspendedLanes = 0), (root.pingedLanes = 0), (root.warmLanes = 0));
}
function markRootFinished(
  root,
  finishedLanes,
  remainingLanes,
  spawnedLane,
  updatedLanes,
  suspendedRetryLanes
) {
  var previouslyPendingLanes = root.pendingLanes;
  root.pendingLanes = remainingLanes;
  root.suspendedLanes = 0;
  root.pingedLanes = 0;
  root.warmLanes = 0;
  root.expiredLanes &= remainingLanes;
  root.entangledLanes &= remainingLanes;
  root.errorRecoveryDisabledLanes &= remainingLanes;
  root.shellSuspendCounter = 0;
  var entanglements = root.entanglements,
    expirationTimes = root.expirationTimes,
    hiddenUpdates = root.hiddenUpdates;
  for (
    remainingLanes = previouslyPendingLanes & ~remainingLanes;
    0 < remainingLanes;

  ) {
    var index$7 = 31 - clz32(remainingLanes),
      lane = 1 << index$7;
    entanglements[index$7] = 0;
    expirationTimes[index$7] = -1;
    var hiddenUpdatesForLane = hiddenUpdates[index$7];
    if (null !== hiddenUpdatesForLane)
      for (
        hiddenUpdates[index$7] = null, index$7 = 0;
        index$7 < hiddenUpdatesForLane.length;
        index$7++
      ) {
        var update = hiddenUpdatesForLane[index$7];
        null !== update && (update.lane &= -536870913);
      }
    remainingLanes &= ~lane;
  }
  0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
  0 !== suspendedRetryLanes &&
    0 === updatedLanes &&
    0 !== root.tag &&
    (root.suspendedLanes |=
      suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
}
function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
  root.pendingLanes |= spawnedLane;
  root.suspendedLanes &= ~spawnedLane;
  var spawnedLaneIndex = 31 - clz32(spawnedLane);
  root.entangledLanes |= spawnedLane;
  root.entanglements[spawnedLaneIndex] =
    root.entanglements[spawnedLaneIndex] |
    1073741824 |
    (entangledLanes & 261930);
}
function markRootEntangled(root, entangledLanes) {
  var rootEntangledLanes = (root.entangledLanes |= entangledLanes);
  for (root = root.entanglements; rootEntangledLanes; ) {
    var index$8 = 31 - clz32(rootEntangledLanes),
      lane = 1 << index$8;
    (lane & entangledLanes) | (root[index$8] & entangledLanes) &&
      (root[index$8] |= entangledLanes);
    rootEntangledLanes &= ~lane;
  }
}
function getBumpedLaneForHydration(root, renderLanes) {
  var renderLane = renderLanes & -renderLanes;
  renderLane =
    0 !== (renderLane & 42) ? 1 : getBumpedLaneForHydrationByLane(renderLane);
  return 0 !== (renderLane & (root.suspendedLanes | renderLanes))
    ? 0
    : renderLane;
}
function getBumpedLaneForHydrationByLane(lane) {
  switch (lane) {
    case 2:
      lane = 1;
      break;
    case 8:
      lane = 4;
      break;
    case 32:
      lane = 16;
      break;
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
      lane = 128;
      break;
    case 268435456:
      lane = 134217728;
      break;
    default:
      lane = 0;
  }
  return lane;
}
function lanesToEventPriority(lanes) {
  lanes &= -lanes;
  return 2 < lanes
    ? 8 < lanes
      ? 0 !== (lanes & 134217727)
        ? 32
        : 268435456
      : 8
    : 2;
}
function resolveUpdatePriority() {
  var updatePriority = ReactDOMSharedInternals.p;
  if (0 !== updatePriority) return updatePriority;
  updatePriority = window.event;
  return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
}
function runWithPriority(priority, fn) {
  var previousPriority = ReactDOMSharedInternals.p;
  try {
    return (ReactDOMSharedInternals.p = priority), fn();
  } finally {
    ReactDOMSharedInternals.p = previousPriority;
  }
}
var randomKey = Math.random().toString(36).slice(2),
  internalInstanceKey = "__reactFiber$" + randomKey,
  internalPropsKey = "__reactProps$" + randomKey,
  internalContainerInstanceKey = "__reactContainer$" + randomKey,
  internalEventHandlersKey = "__reactEvents$" + randomKey,
  internalEventHandlerListenersKey = "__reactListeners$" + randomKey,
  internalEventHandlesSetKey = "__reactHandles$" + randomKey,
  internalRootNodeResourcesKey = "__reactResources$" + randomKey,
  internalHoistableMarker = "__reactMarker$" + randomKey;
function detachDeletedInstance(node) {
  delete node[internalInstanceKey];
  delete node[internalPropsKey];
  delete node[internalEventHandlersKey];
  delete node[internalEventHandlerListenersKey];
  delete node[internalEventHandlesSetKey];
}
function getClosestInstanceFromNode(targetNode) {
  var targetInst = targetNode[internalInstanceKey];
  if (targetInst) return targetInst;
  for (var parentNode = targetNode.parentNode; parentNode; ) {
    if (
      (targetInst =
        parentNode[internalContainerInstanceKey] ||
        parentNode[internalInstanceKey])
    ) {
      parentNode = targetInst.alternate;
      if (
        null !== targetInst.child ||
        (null !== parentNode && null !== parentNode.child)
      )
        for (
          targetNode = getParentHydrationBoundary(targetNode);
          null !== targetNode;

        ) {
          if ((parentNode = targetNode[internalInstanceKey])) return parentNode;
          targetNode = getParentHydrationBoundary(targetNode);
        }
      return targetInst;
    }
    targetNode = parentNode;
    parentNode = targetNode.parentNode;
  }
  return null;
}
function getInstanceFromNode(node) {
  if (
    (node = node[internalInstanceKey] || node[internalContainerInstanceKey])
  ) {
    var tag = node.tag;
    if (
      5 === tag ||
      6 === tag ||
      13 === tag ||
      31 === tag ||
      26 === tag ||
      27 === tag ||
      3 === tag
    )
      return node;
  }
  return null;
}
function getNodeFromInstance(inst) {
  var tag = inst.tag;
  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
  throw Error(formatProdErrorMessage(33));
}
function getResourcesFromRoot(root) {
  var resources = root[internalRootNodeResourcesKey];
  resources ||
    (resources = root[internalRootNodeResourcesKey] =
      { hoistableStyles: new Map(), hoistableScripts: new Map() });
  return resources;
}
function markNodeAsHoistable(node) {
  node[internalHoistableMarker] = !0;
}
var allNativeEvents = new Set(),
  registrationNameDependencies = {};
function registerTwoPhaseEvent(registrationName, dependencies) {
  registerDirectEvent(registrationName, dependencies);
  registerDirectEvent(registrationName + "Capture", dependencies);
}
function registerDirectEvent(registrationName, dependencies) {
  registrationNameDependencies[registrationName] = dependencies;
  for (
    registrationName = 0;
    registrationName < dependencies.length;
    registrationName++
  )
    allNativeEvents.add(dependencies[registrationName]);
}
var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ),
  illegalAttributeNameCache = {},
  validatedAttributeNameCache = {};
function isAttributeNameSafe(attributeName) {
  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
    return !0;
  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return !1;
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
    return (validatedAttributeNameCache[attributeName] = !0);
  illegalAttributeNameCache[attributeName] = !0;
  return !1;
}
function setValueForAttribute(node, name, value) {
  if (isAttributeNameSafe(name))
    if (null === value) node.removeAttribute(name);
    else {
      switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
          node.removeAttribute(name);
          return;
        case "boolean":
          var prefix$10 = name.toLowerCase().slice(0, 5);
          if ("data-" !== prefix$10 && "aria-" !== prefix$10) {
            node.removeAttribute(name);
            return;
          }
      }
      node.setAttribute(name, "" + value);
    }
}
function setValueForKnownAttribute(node, name, value) {
  if (null === value) node.removeAttribute(name);
  else {
    switch (typeof value) {
      case "undefined":
      case "function":
      case "symbol":
      case "boolean":
        node.removeAttribute(name);
        return;
    }
    node.setAttribute(name, "" + value);
  }
}
function setValueForNamespacedAttribute(node, namespace, name, value) {
  if (null === value) node.removeAttribute(name);
  else {
    switch (typeof value) {
      case "undefined":
      case "function":
      case "symbol":
      case "boolean":
        node.removeAttribute(name);
        return;
    }
    node.setAttributeNS(namespace, name, "" + value);
  }
}
function getToStringValue(value) {
  switch (typeof value) {
    case "bigint":
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return value;
    case "object":
      return value;
    default:
      return "";
  }
}
function isCheckable(elem) {
  var type = elem.type;
  return (
    (elem = elem.nodeName) &&
    "input" === elem.toLowerCase() &&
    ("checkbox" === type || "radio" === type)
  );
}
function trackValueOnNode(node, valueField, currentValue) {
  var descriptor = Object.getOwnPropertyDescriptor(
    node.constructor.prototype,
    valueField
  );
  if (
    !node.hasOwnProperty(valueField) &&
    "undefined" !== typeof descriptor &&
    "function" === typeof descriptor.get &&
    "function" === typeof descriptor.set
  ) {
    var get = descriptor.get,
      set = descriptor.set;
    Object.defineProperty(node, valueField, {
      configurable: !0,
      get: function () {
        return get.call(this);
      },
      set: function (value) {
        currentValue = "" + value;
        set.call(this, value);
      }
    });
    Object.defineProperty(node, valueField, {
      enumerable: descriptor.enumerable
    });
    return {
      getValue: function () {
        return currentValue;
      },
      setValue: function (value) {
        currentValue = "" + value;
      },
      stopTracking: function () {
        node._valueTracker = null;
        delete node[valueField];
      }
    };
  }
}
function track(node) {
  if (!node._valueTracker) {
    var valueField = isCheckable(node) ? "checked" : "value";
    node._valueTracker = trackValueOnNode(
      node,
      valueField,
      "" + node[valueField]
    );
  }
}
function updateValueIfChanged(node) {
  if (!node) return !1;
  var tracker = node._valueTracker;
  if (!tracker) return !0;
  var lastValue = tracker.getValue();
  var value = "";
  node &&
    (value = isCheckable(node)
      ? node.checked
        ? "true"
        : "false"
      : node.value);
  node = value;
  return node !== lastValue ? (tracker.setValue(node), !0) : !1;
}
function getActiveElement(doc) {
  doc = doc || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof doc) return null;
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}
var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
  return value.replace(
    escapeSelectorAttributeValueInsideDoubleQuotesRegex,
    function (ch) {
      return "\\" + ch.charCodeAt(0).toString(16) + " ";
    }
  );
}
function updateInput(
  element,
  value,
  defaultValue,
  lastDefaultValue,
  checked,
  defaultChecked,
  type,
  name
) {
  element.name = "";
  null != type &&
  "function" !== typeof type &&
  "symbol" !== typeof type &&
  "boolean" !== typeof type
    ? (element.type = type)
    : element.removeAttribute("type");
  if (null != value)
    if ("number" === type) {
      if ((0 === value && "" === element.value) || element.value != value)
        element.value = "" + getToStringValue(value);
    } else
      element.value !== "" + getToStringValue(value) &&
        (element.value = "" + getToStringValue(value));
  else
    ("submit" !== type && "reset" !== type) || element.removeAttribute("value");
  null != value
    ? setDefaultValue(element, type, getToStringValue(value))
    : null != defaultValue
      ? setDefaultValue(element, type, getToStringValue(defaultValue))
      : null != lastDefaultValue && element.removeAttribute("value");
  null == checked &&
    null != defaultChecked &&
    (element.defaultChecked = !!defaultChecked);
  null != checked &&
    (element.checked =
      checked && "function" !== typeof checked && "symbol" !== typeof checked);
  null != name &&
  "function" !== typeof name &&
  "symbol" !== typeof name &&
  "boolean" !== typeof name
    ? (element.name = "" + getToStringValue(name))
    : element.removeAttribute("name");
}
function initInput(
  element,
  value,
  defaultValue,
  checked,
  defaultChecked,
  type,
  name,
  isHydrating
) {
  null != type &&
    "function" !== typeof type &&
    "symbol" !== typeof type &&
    "boolean" !== typeof type &&
    (element.type = type);
  if (null != value || null != defaultValue) {
    if (
      !(
        ("submit" !== type && "reset" !== type) ||
        (void 0 !== value && null !== value)
      )
    ) {
      track(element);
      return;
    }
    defaultValue =
      null != defaultValue ? "" + getToStringValue(defaultValue) : "";
    value = null != value ? "" + getToStringValue(value) : defaultValue;
    isHydrating || value === element.value || (element.value = value);
    element.defaultValue = value;
  }
  checked = null != checked ? checked : defaultChecked;
  checked =
    "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
  element.checked = isHydrating ? element.checked : !!checked;
  element.defaultChecked = !!checked;
  null != name &&
    "function" !== typeof name &&
    "symbol" !== typeof name &&
    "boolean" !== typeof name &&
    (element.name = name);
  track(element);
}
function setDefaultValue(node, type, value) {
  ("number" === type && getActiveElement(node.ownerDocument) === node) ||
    node.defaultValue === "" + value ||
    (node.defaultValue = "" + value);
}
function updateOptions(node, multiple, propValue, setDefaultSelected) {
  node = node.options;
  if (multiple) {
    multiple = {};
    for (var i = 0; i < propValue.length; i++)
      multiple["$" + propValue[i]] = !0;
    for (propValue = 0; propValue < node.length; propValue++)
      (i = multiple.hasOwnProperty("$" + node[propValue].value)),
        node[propValue].selected !== i && (node[propValue].selected = i),
        i && setDefaultSelected && (node[propValue].defaultSelected = !0);
  } else {
    propValue = "" + getToStringValue(propValue);
    multiple = null;
    for (i = 0; i < node.length; i++) {
      if (node[i].value === propValue) {
        node[i].selected = !0;
        setDefaultSelected && (node[i].defaultSelected = !0);
        return;
      }
      null !== multiple || node[i].disabled || (multiple = node[i]);
    }
    null !== multiple && (multiple.selected = !0);
  }
}
function updateTextarea(element, value, defaultValue) {
  if (
    null != value &&
    ((value = "" + getToStringValue(value)),
    value !== element.value && (element.value = value),
    null == defaultValue)
  ) {
    element.defaultValue !== value && (element.defaultValue = value);
    return;
  }
  element.defaultValue =
    null != defaultValue ? "" + getToStringValue(defaultValue) : "";
}
function initTextarea(element, value, defaultValue, children) {
  if (null == value) {
    if (null != children) {
      if (null != defaultValue) throw Error(formatProdErrorMessage(92));
      if (isArrayImpl(children)) {
        if (1 < children.length) throw Error(formatProdErrorMessage(93));
        children = children[0];
      }
      defaultValue = children;
    }
    null == defaultValue && (defaultValue = "");
    value = defaultValue;
  }
  defaultValue = getToStringValue(value);
  element.defaultValue = defaultValue;
  children = element.textContent;
  children === defaultValue &&
    "" !== children &&
    null !== children &&
    (element.value = children);
  track(element);
}
function setTextContent(node, text) {
  if (text) {
    var firstChild = node.firstChild;
    if (
      firstChild &&
      firstChild === node.lastChild &&
      3 === firstChild.nodeType
    ) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
}
var unitlessNumbers = new Set(
  "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
    " "
  )
);
function setValueForStyle(style, styleName, value) {
  var isCustomProperty = 0 === styleName.indexOf("--");
  null == value || "boolean" === typeof value || "" === value
    ? isCustomProperty
      ? style.setProperty(styleName, "")
      : "float" === styleName
        ? (style.cssFloat = "")
        : (style[styleName] = "")
    : isCustomProperty
      ? style.setProperty(styleName, value)
      : "number" !== typeof value ||
          0 === value ||
          unitlessNumbers.has(styleName)
        ? "float" === styleName
          ? (style.cssFloat = value)
          : (style[styleName] = ("" + value).trim())
        : (style[styleName] = value + "px");
}
function setValueForStyles(node, styles, prevStyles) {
  if (null != styles && "object" !== typeof styles)
    throw Error(formatProdErrorMessage(62));
  node = node.style;
  if (null != prevStyles) {
    for (var styleName in prevStyles)
      !prevStyles.hasOwnProperty(styleName) ||
        (null != styles && styles.hasOwnProperty(styleName)) ||
        (0 === styleName.indexOf("--")
          ? node.setProperty(styleName, "")
          : "float" === styleName
            ? (node.cssFloat = "")
            : (node[styleName] = ""));
    for (var styleName$16 in styles)
      (styleName = styles[styleName$16]),
        styles.hasOwnProperty(styleName$16) &&
          prevStyles[styleName$16] !== styleName &&
          setValueForStyle(node, styleName$16, styleName);
  } else
    for (var styleName$17 in styles)
      styles.hasOwnProperty(styleName$17) &&
        setValueForStyle(node, styleName$17, styles[styleName$17]);
}
function isCustomElement(tagName) {
  if (-1 === tagName.indexOf("-")) return !1;
  switch (tagName) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var aliases = new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]),
  isJavaScriptProtocol =
    /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
function sanitizeURL(url) {
  return isJavaScriptProtocol.test("" + url)
    ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')"
    : url;
}
function noop$1() {}
var currentReplayingEvent = null;
function getEventTarget(nativeEvent) {
  nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
  nativeEvent.correspondingUseElement &&
    (nativeEvent = nativeEvent.correspondingUseElement);
  return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
}
var restoreTarget = null,
  restoreQueue = null;
function restoreStateOfTarget(target) {
  var internalInstance = getInstanceFromNode(target);
  if (internalInstance && (target = internalInstance.stateNode)) {
    var props = target[internalPropsKey] || null;
    a: switch (((target = internalInstance.stateNode), internalInstance.type)) {
      case "input":
        updateInput(
          target,
          props.value,
          props.defaultValue,
          props.defaultValue,
          props.checked,
          props.defaultChecked,
          props.type,
          props.name
        );
        internalInstance = props.name;
        if ("radio" === props.type && null != internalInstance) {
          for (props = target; props.parentNode; ) props = props.parentNode;
          props = props.querySelectorAll(
            'input[name="' +
              escapeSelectorAttributeValueInsideDoubleQuotes(
                "" + internalInstance
              ) +
              '"][type="radio"]'
          );
          for (
            internalInstance = 0;
            internalInstance < props.length;
            internalInstance++
          ) {
            var otherNode = props[internalInstance];
            if (otherNode !== target && otherNode.form === target.form) {
              var otherProps = otherNode[internalPropsKey] || null;
              if (!otherProps) throw Error(formatProdErrorMessage(90));
              updateInput(
                otherNode,
                otherProps.value,
                otherProps.defaultValue,
                otherProps.defaultValue,
                otherProps.checked,
                otherProps.defaultChecked,
                otherProps.type,
                otherProps.name
              );
            }
          }
          for (
            internalInstance = 0;
            internalInstance < props.length;
            internalInstance++
          )
            (otherNode = props[internalInstance]),
              otherNode.form === target.form && updateValueIfChanged(otherNode);
        }
        break a;
      case "textarea":
        updateTextarea(target, props.value, props.defaultValue);
        break a;
      case "select":
        (internalInstance = props.value),
          null != internalInstance &&
            updateOptions(target, !!props.multiple, internalInstance, !1);
    }
  }
}
var isInsideEventHandler = !1;
function batchedUpdates$1(fn, a, b) {
  if (isInsideEventHandler) return fn(a, b);
  isInsideEventHandler = !0;
  try {
    var JSCompiler_inline_result = fn(a);
    return JSCompiler_inline_result;
  } finally {
    if (
      ((isInsideEventHandler = !1),
      null !== restoreTarget || null !== restoreQueue)
    )
      if (
        (flushSyncWork$1(),
        restoreTarget &&
          ((a = restoreTarget),
          (fn = restoreQueue),
          (restoreQueue = restoreTarget = null),
          restoreStateOfTarget(a),
          fn))
      )
        for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
  }
}
function getListener(inst, registrationName) {
  var stateNode = inst.stateNode;
  if (null === stateNode) return null;
  var props = stateNode[internalPropsKey] || null;
  if (null === props) return null;
  stateNode = props[registrationName];
  a: switch (registrationName) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (props = !props.disabled) ||
        ((inst = inst.type),
        (props = !(
          "button" === inst ||
          "input" === inst ||
          "select" === inst ||
          "textarea" === inst
        )));
      inst = !props;
      break a;
    default:
      inst = !1;
  }
  if (inst) return null;
  if (stateNode && "function" !== typeof stateNode)
    throw Error(
      formatProdErrorMessage(231, registrationName, typeof stateNode)
    );
  return stateNode;
}
var canUseDOM = !(
    "undefined" === typeof window ||
    "undefined" === typeof window.document ||
    "undefined" === typeof window.document.createElement
  ),
  passiveBrowserEventsSupported = !1;
if (canUseDOM)
  try {
    var options = {};
    Object.defineProperty(options, "passive", {
      get: function () {
        passiveBrowserEventsSupported = !0;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (e) {
    passiveBrowserEventsSupported = !1;
  }
var root = null,
  startText = null,
  fallbackText = null;
function getData() {
  if (fallbackText) return fallbackText;
  var start,
    startValue = startText,
    startLength = startValue.length,
    end,
    endValue = "value" in root ? root.value : root.textContent,
    endLength = endValue.length;
  for (
    start = 0;
    start < startLength && startValue[start] === endValue[start];
    start++
  );
  var minEnd = startLength - start;
  for (
    end = 1;
    end <= minEnd &&
    startValue[startLength - end] === endValue[endLength - end];
    end++
  );
  return (fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0));
}
function getEventCharCode(nativeEvent) {
  var keyCode = nativeEvent.keyCode;
  "charCode" in nativeEvent
    ? ((nativeEvent = nativeEvent.charCode),
      0 === nativeEvent && 13 === keyCode && (nativeEvent = 13))
    : (nativeEvent = keyCode);
  10 === nativeEvent && (nativeEvent = 13);
  return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
}
function functionThatReturnsTrue() {
  return !0;
}
function functionThatReturnsFalse() {
  return !1;
}
function createSyntheticEvent(Interface) {
  function SyntheticBaseEvent(
    reactName,
    reactEventType,
    targetInst,
    nativeEvent,
    nativeEventTarget
  ) {
    this._reactName = reactName;
    this._targetInst = targetInst;
    this.type = reactEventType;
    this.nativeEvent = nativeEvent;
    this.target = nativeEventTarget;
    this.currentTarget = null;
    for (var propName in Interface)
      Interface.hasOwnProperty(propName) &&
        ((reactName = Interface[propName]),
        (this[propName] = reactName
          ? reactName(nativeEvent)
          : nativeEvent[propName]));
    this.isDefaultPrevented = (
      null != nativeEvent.defaultPrevented
        ? nativeEvent.defaultPrevented
        : !1 === nativeEvent.returnValue
    )
      ? functionThatReturnsTrue
      : functionThatReturnsFalse;
    this.isPropagationStopped = functionThatReturnsFalse;
    return this;
  }
  assign(SyntheticBaseEvent.prototype, {
    preventDefault: function () {
      this.defaultPrevented = !0;
      var event = this.nativeEvent;
      event &&
        (event.preventDefault
          ? event.preventDefault()
          : "unknown" !== typeof event.returnValue && (event.returnValue = !1),
        (this.isDefaultPrevented = functionThatReturnsTrue));
    },
    stopPropagation: function () {
      var event = this.nativeEvent;
      event &&
        (event.stopPropagation
          ? event.stopPropagation()
          : "unknown" !== typeof event.cancelBubble &&
            (event.cancelBubble = !0),
        (this.isPropagationStopped = functionThatReturnsTrue));
    },
    persist: function () {},
    isPersistent: functionThatReturnsTrue
  });
  return SyntheticBaseEvent;
}
var EventInterface = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  },
  SyntheticEvent = createSyntheticEvent(EventInterface),
  UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }),
  SyntheticUIEvent = createSyntheticEvent(UIEventInterface),
  lastMovementX,
  lastMovementY,
  lastMouseEvent,
  MouseEventInterface = assign({}, UIEventInterface, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: getEventModifierState,
    button: 0,
    buttons: 0,
    relatedTarget: function (event) {
      return void 0 === event.relatedTarget
        ? event.fromElement === event.srcElement
          ? event.toElement
          : event.fromElement
        : event.relatedTarget;
    },
    movementX: function (event) {
      if ("movementX" in event) return event.movementX;
      event !== lastMouseEvent &&
        (lastMouseEvent && "mousemove" === event.type
          ? ((lastMovementX = event.screenX - lastMouseEvent.screenX),
            (lastMovementY = event.screenY - lastMouseEvent.screenY))
          : (lastMovementY = lastMovementX = 0),
        (lastMouseEvent = event));
      return lastMovementX;
    },
    movementY: function (event) {
      return "movementY" in event ? event.movementY : lastMovementY;
    }
  }),
  SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),
  DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }),
  SyntheticDragEvent = createSyntheticEvent(DragEventInterface),
  FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }),
  SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),
  AnimationEventInterface = assign({}, EventInterface, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }),
  SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),
  ClipboardEventInterface = assign({}, EventInterface, {
    clipboardData: function (event) {
      return "clipboardData" in event
        ? event.clipboardData
        : window.clipboardData;
    }
  }),
  SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),
  CompositionEventInterface = assign({}, EventInterface, { data: 0 }),
  SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface),
  normalizeKey = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  },
  translateToKey = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  },
  modifierKeyToProp = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
function modifierStateGetter(keyArg) {
  var nativeEvent = this.nativeEvent;
  return nativeEvent.getModifierState
    ? nativeEvent.getModifierState(keyArg)
    : (keyArg = modifierKeyToProp[keyArg])
      ? !!nativeEvent[keyArg]
      : !1;
}
function getEventModifierState() {
  return modifierStateGetter;
}
var KeyboardEventInterface = assign({}, UIEventInterface, {
    key: function (nativeEvent) {
      if (nativeEvent.key) {
        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
        if ("Unidentified" !== key) return key;
      }
      return "keypress" === nativeEvent.type
        ? ((nativeEvent = getEventCharCode(nativeEvent)),
          13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent))
        : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type
          ? translateToKey[nativeEvent.keyCode] || "Unidentified"
          : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: getEventModifierState,
    charCode: function (event) {
      return "keypress" === event.type ? getEventCharCode(event) : 0;
    },
    keyCode: function (event) {
      return "keydown" === event.type || "keyup" === event.type
        ? event.keyCode
        : 0;
    },
    which: function (event) {
      return "keypress" === event.type
        ? getEventCharCode(event)
        : "keydown" === event.type || "keyup" === event.type
          ? event.keyCode
          : 0;
    }
  }),
  SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),
  PointerEventInterface = assign({}, MouseEventInterface, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }),
  SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),
  TouchEventInterface = assign({}, UIEventInterface, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: getEventModifierState
  }),
  SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),
  TransitionEventInterface = assign({}, EventInterface, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }),
  SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),
  WheelEventInterface = assign({}, MouseEventInterface, {
    deltaX: function (event) {
      return "deltaX" in event
        ? event.deltaX
        : "wheelDeltaX" in event
          ? -event.wheelDeltaX
          : 0;
    },
    deltaY: function (event) {
      return "deltaY" in event
        ? event.deltaY
        : "wheelDeltaY" in event
          ? -event.wheelDeltaY
          : "wheelDelta" in event
            ? -event.wheelDelta
            : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }),
  SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),
  ToggleEventInterface = assign({}, EventInterface, {
    newState: 0,
    oldState: 0
  }),
  SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),
  END_KEYCODES = [9, 13, 27, 32],
  canUseCompositionEvent = canUseDOM && "CompositionEvent" in window,
  documentMode = null;
canUseDOM &&
  "documentMode" in document &&
  (documentMode = document.documentMode);
var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode,
  useFallbackCompositionData =
    canUseDOM &&
    (!canUseCompositionEvent ||
      (documentMode && 8 < documentMode && 11 >= documentMode)),
  SPACEBAR_CHAR = String.fromCharCode(32),
  hasSpaceKeypress = !1;
function isFallbackCompositionEnd(domEventName, nativeEvent) {
  switch (domEventName) {
    case "keyup":
      return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
    case "keydown":
      return 229 !== nativeEvent.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function getDataFromCustomEvent(nativeEvent) {
  nativeEvent = nativeEvent.detail;
  return "object" === typeof nativeEvent && "data" in nativeEvent
    ? nativeEvent.data
    : null;
}
var isComposing = !1;
function getNativeBeforeInputChars(domEventName, nativeEvent) {
  switch (domEventName) {
    case "compositionend":
      return getDataFromCustomEvent(nativeEvent);
    case "keypress":
      if (32 !== nativeEvent.which) return null;
      hasSpaceKeypress = !0;
      return SPACEBAR_CHAR;
    case "textInput":
      return (
        (domEventName = nativeEvent.data),
        domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName
      );
    default:
      return null;
  }
}
function getFallbackBeforeInputChars(domEventName, nativeEvent) {
  if (isComposing)
    return "compositionend" === domEventName ||
      (!canUseCompositionEvent &&
        isFallbackCompositionEnd(domEventName, nativeEvent))
      ? ((domEventName = getData()),
        (fallbackText = startText = root = null),
        (isComposing = !1),
        domEventName)
      : null;
  switch (domEventName) {
    case "paste":
      return null;
    case "keypress":
      if (
        !(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) ||
        (nativeEvent.ctrlKey && nativeEvent.altKey)
      ) {
        if (nativeEvent.char && 1 < nativeEvent.char.length)
          return nativeEvent.char;
        if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
      }
      return null;
    case "compositionend":
      return useFallbackCompositionData && "ko" !== nativeEvent.locale
        ? null
        : nativeEvent.data;
    default:
      return null;
  }
}
var supportedInputTypes = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0
};
function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return "input" === nodeName
    ? !!supportedInputTypes[elem.type]
    : "textarea" === nodeName
      ? !0
      : !1;
}
function createAndAccumulateChangeEvent(
  dispatchQueue,
  inst,
  nativeEvent,
  target
) {
  restoreTarget
    ? restoreQueue
      ? restoreQueue.push(target)
      : (restoreQueue = [target])
    : (restoreTarget = target);
  inst = accumulateTwoPhaseListeners(inst, "onChange");
  0 < inst.length &&
    ((nativeEvent = new SyntheticEvent(
      "onChange",
      "change",
      null,
      nativeEvent,
      target
    )),
    dispatchQueue.push({ event: nativeEvent, listeners: inst }));
}
var activeElement$1 = null,
  activeElementInst$1 = null;
function runEventInBatch(dispatchQueue) {
  processDispatchQueue(dispatchQueue, 0);
}
function getInstIfValueChanged(targetInst) {
  var targetNode = getNodeFromInstance(targetInst);
  if (updateValueIfChanged(targetNode)) return targetInst;
}
function getTargetInstForChangeEvent(domEventName, targetInst) {
  if ("change" === domEventName) return targetInst;
}
var isInputEventSupported = !1;
if (canUseDOM) {
  var JSCompiler_inline_result$jscomp$286;
  if (canUseDOM) {
    var isSupported$jscomp$inline_427 = "oninput" in document;
    if (!isSupported$jscomp$inline_427) {
      var element$jscomp$inline_428 = document.createElement("div");
      element$jscomp$inline_428.setAttribute("oninput", "return;");
      isSupported$jscomp$inline_427 =
        "function" === typeof element$jscomp$inline_428.oninput;
    }
    JSCompiler_inline_result$jscomp$286 = isSupported$jscomp$inline_427;
  } else JSCompiler_inline_result$jscomp$286 = !1;
  isInputEventSupported =
    JSCompiler_inline_result$jscomp$286 &&
    (!document.documentMode || 9 < document.documentMode);
}
function stopWatchingForValueChange() {
  activeElement$1 &&
    (activeElement$1.detachEvent("onpropertychange", handlePropertyChange),
    (activeElementInst$1 = activeElement$1 = null));
}
function handlePropertyChange(nativeEvent) {
  if (
    "value" === nativeEvent.propertyName &&
    getInstIfValueChanged(activeElementInst$1)
  ) {
    var dispatchQueue = [];
    createAndAccumulateChangeEvent(
      dispatchQueue,
      activeElementInst$1,
      nativeEvent,
      getEventTarget(nativeEvent)
    );
    batchedUpdates$1(runEventInBatch, dispatchQueue);
  }
}
function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
  "focusin" === domEventName
    ? (stopWatchingForValueChange(),
      (activeElement$1 = target),
      (activeElementInst$1 = targetInst),
      activeElement$1.attachEvent("onpropertychange", handlePropertyChange))
    : "focusout" === domEventName && stopWatchingForValueChange();
}
function getTargetInstForInputEventPolyfill(domEventName) {
  if (
    "selectionchange" === domEventName ||
    "keyup" === domEventName ||
    "keydown" === domEventName
  )
    return getInstIfValueChanged(activeElementInst$1);
}
function getTargetInstForClickEvent(domEventName, targetInst) {
  if ("click" === domEventName) return getInstIfValueChanged(targetInst);
}
function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
  if ("input" === domEventName || "change" === domEventName)
    return getInstIfValueChanged(targetInst);
}
function is(x, y) {
  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
}
var objectIs = "function" === typeof Object.is ? Object.is : is;
function shallowEqual(objA, objB) {
  if (objectIs(objA, objB)) return !0;
  if (
    "object" !== typeof objA ||
    null === objA ||
    "object" !== typeof objB ||
    null === objB
  )
    return !1;
  var keysA = Object.keys(objA),
    keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) return !1;
  for (keysB = 0; keysB < keysA.length; keysB++) {
    var currentKey = keysA[keysB];
    if (
      !hasOwnProperty.call(objB, currentKey) ||
      !objectIs(objA[currentKey], objB[currentKey])
    )
      return !1;
  }
  return !0;
}
function getLeafNode(node) {
  for (; node && node.firstChild; ) node = node.firstChild;
  return node;
}
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  root = 0;
  for (var nodeEnd; node; ) {
    if (3 === node.nodeType) {
      nodeEnd = root + node.textContent.length;
      if (root <= offset && nodeEnd >= offset)
        return { node: node, offset: offset - root };
      root = nodeEnd;
    }
    a: {
      for (; node; ) {
        if (node.nextSibling) {
          node = node.nextSibling;
          break a;
        }
        node = node.parentNode;
      }
      node = void 0;
    }
    node = getLeafNode(node);
  }
}
function containsNode(outerNode, innerNode) {
  return outerNode && innerNode
    ? outerNode === innerNode
      ? !0
      : outerNode && 3 === outerNode.nodeType
        ? !1
        : innerNode && 3 === innerNode.nodeType
          ? containsNode(outerNode, innerNode.parentNode)
          : "contains" in outerNode
            ? outerNode.contains(innerNode)
            : outerNode.compareDocumentPosition
              ? !!(outerNode.compareDocumentPosition(innerNode) & 16)
              : !1
    : !1;
}
function getActiveElementDeep(containerInfo) {
  containerInfo =
    null != containerInfo &&
    null != containerInfo.ownerDocument &&
    null != containerInfo.ownerDocument.defaultView
      ? containerInfo.ownerDocument.defaultView
      : window;
  for (
    var element = getActiveElement(containerInfo.document);
    element instanceof containerInfo.HTMLIFrameElement;

  ) {
    try {
      var JSCompiler_inline_result =
        "string" === typeof element.contentWindow.location.href;
    } catch (err) {
      JSCompiler_inline_result = !1;
    }
    if (JSCompiler_inline_result) containerInfo = element.contentWindow;
    else break;
    element = getActiveElement(containerInfo.document);
  }
  return element;
}
function hasSelectionCapabilities(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return (
    nodeName &&
    (("input" === nodeName &&
      ("text" === elem.type ||
        "search" === elem.type ||
        "tel" === elem.type ||
        "url" === elem.type ||
        "password" === elem.type)) ||
      "textarea" === nodeName ||
      "true" === elem.contentEditable)
  );
}
var skipSelectionChangeEvent =
    canUseDOM && "documentMode" in document && 11 >= document.documentMode,
  activeElement = null,
  activeElementInst = null,
  lastSelection = null,
  mouseDown = !1;
function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
  var doc =
    nativeEventTarget.window === nativeEventTarget
      ? nativeEventTarget.document
      : 9 === nativeEventTarget.nodeType
        ? nativeEventTarget
        : nativeEventTarget.ownerDocument;
  mouseDown ||
    null == activeElement ||
    activeElement !== getActiveElement(doc) ||
    ((doc = activeElement),
    "selectionStart" in doc && hasSelectionCapabilities(doc)
      ? (doc = { start: doc.selectionStart, end: doc.selectionEnd })
      : ((doc = (
          (doc.ownerDocument && doc.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (doc = {
          anchorNode: doc.anchorNode,
          anchorOffset: doc.anchorOffset,
          focusNode: doc.focusNode,
          focusOffset: doc.focusOffset
        })),
    (lastSelection && shallowEqual(lastSelection, doc)) ||
      ((lastSelection = doc),
      (doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect")),
      0 < doc.length &&
        ((nativeEvent = new SyntheticEvent(
          "onSelect",
          "select",
          null,
          nativeEvent,
          nativeEventTarget
        )),
        dispatchQueue.push({ event: nativeEvent, listeners: doc }),
        (nativeEvent.target = activeElement))));
}
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};
  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes["Webkit" + styleProp] = "webkit" + eventName;
  prefixes["Moz" + styleProp] = "moz" + eventName;
  return prefixes;
}
var vendorPrefixes = {
    animationend: makePrefixMap("Animation", "AnimationEnd"),
    animationiteration: makePrefixMap("Animation", "AnimationIteration"),
    animationstart: makePrefixMap("Animation", "AnimationStart"),
    transitionrun: makePrefixMap("Transition", "TransitionRun"),
    transitionstart: makePrefixMap("Transition", "TransitionStart"),
    transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
    transitionend: makePrefixMap("Transition", "TransitionEnd")
  },
  prefixedEventNames = {},
  style = {};
canUseDOM &&
  ((style = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete vendorPrefixes.animationend.animation,
    delete vendorPrefixes.animationiteration.animation,
    delete vendorPrefixes.animationstart.animation),
  "TransitionEvent" in window ||
    delete vendorPrefixes.transitionend.transition);
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
  if (!vendorPrefixes[eventName]) return eventName;
  var prefixMap = vendorPrefixes[eventName],
    styleProp;
  for (styleProp in prefixMap)
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
      return (prefixedEventNames[eventName] = prefixMap[styleProp]);
  return eventName;
}
var ANIMATION_END = getVendorPrefixedEventName("animationend"),
  ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"),
  ANIMATION_START = getVendorPrefixedEventName("animationstart"),
  TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"),
  TRANSITION_START = getVendorPrefixedEventName("transitionstart"),
  TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"),
  TRANSITION_END = getVendorPrefixedEventName("transitionend"),
  topLevelEventsToReactNames = new Map(),
  simpleEventPluginEvents =
    "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
simpleEventPluginEvents.push("scrollEnd");
function registerSimpleEvent(domEventName, reactName) {
  topLevelEventsToReactNames.set(domEventName, reactName);
  registerTwoPhaseEvent(reactName, [domEventName]);
}
var reportGlobalError =
    "function" === typeof reportError
      ? reportError
      : function (error) {
          if (
            "object" === typeof window &&
            "function" === typeof window.ErrorEvent
          ) {
            var event = new window.ErrorEvent("error", {
              bubbles: !0,
              cancelable: !0,
              message:
                "object" === typeof error &&
                null !== error &&
                "string" === typeof error.message
                  ? String(error.message)
                  : String(error),
              error: error
            });
            if (!window.dispatchEvent(event)) return;
          } else if (
            "object" === typeof process &&
            "function" === typeof process.emit
          ) {
            process.emit("uncaughtException", error);
            return;
          }
          console.error(error);
        },
  concurrentQueues = [],
  concurrentQueuesIndex = 0,
  concurrentlyUpdatedLanes = 0;
function finishQueueingConcurrentUpdates() {
  for (
    var endIndex = concurrentQueuesIndex,
      i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = 0);
    i < endIndex;

  ) {
    var fiber = concurrentQueues[i];
    concurrentQueues[i++] = null;
    var queue = concurrentQueues[i];
    concurrentQueues[i++] = null;
    var update = concurrentQueues[i];
    concurrentQueues[i++] = null;
    var lane = concurrentQueues[i];
    concurrentQueues[i++] = null;
    if (null !== queue && null !== update) {
      var pending = queue.pending;
      null === pending
        ? (update.next = update)
        : ((update.next = pending.next), (pending.next = update));
      queue.pending = update;
    }
    0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
  }
}
function enqueueUpdate$1(fiber, queue, update, lane) {
  concurrentQueues[concurrentQueuesIndex++] = fiber;
  concurrentQueues[concurrentQueuesIndex++] = queue;
  concurrentQueues[concurrentQueuesIndex++] = update;
  concurrentQueues[concurrentQueuesIndex++] = lane;
  concurrentlyUpdatedLanes |= lane;
  fiber.lanes |= lane;
  fiber = fiber.alternate;
  null !== fiber && (fiber.lanes |= lane);
}
function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
  enqueueUpdate$1(fiber, queue, update, lane);
  return getRootForUpdatedFiber(fiber);
}
function enqueueConcurrentRenderForLane(fiber, lane) {
  enqueueUpdate$1(fiber, null, null, lane);
  return getRootForUpdatedFiber(fiber);
}
function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
  sourceFiber.lanes |= lane;
  var alternate = sourceFiber.alternate;
  null !== alternate && (alternate.lanes |= lane);
  for (var isHidden = !1, parent = sourceFiber.return; null !== parent; )
    (parent.childLanes |= lane),
      (alternate = parent.alternate),
      null !== alternate && (alternate.childLanes |= lane),
      22 === parent.tag &&
        ((sourceFiber = parent.stateNode),
        null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = !0)),
      (sourceFiber = parent),
      (parent = parent.return);
  return 3 === sourceFiber.tag
    ? ((parent = sourceFiber.stateNode),
      isHidden &&
        null !== update &&
        ((isHidden = 31 - clz32(lane)),
        (sourceFiber = parent.hiddenUpdates),
        (alternate = sourceFiber[isHidden]),
        null === alternate
          ? (sourceFiber[isHidden] = [update])
          : alternate.push(update),
        (update.lane = lane | 536870912)),
      parent)
    : null;
}
function getRootForUpdatedFiber(sourceFiber) {
  if (50 < nestedUpdateCount)
    throw (
      ((nestedUpdateCount = 0),
      (rootWithNestedUpdates = null),
      Error(formatProdErrorMessage(185)))
    );
  for (var parent = sourceFiber.return; null !== parent; )
    (sourceFiber = parent), (parent = sourceFiber.return);
  return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
}
var emptyContextObject = {};
function FiberNode(tag, pendingProps, key, mode) {
  this.tag = tag;
  this.key = key;
  this.sibling =
    this.child =
    this.return =
    this.stateNode =
    this.type =
    this.elementType =
      null;
  this.index = 0;
  this.refCleanup = this.ref = null;
  this.pendingProps = pendingProps;
  this.dependencies =
    this.memoizedState =
    this.updateQueue =
    this.memoizedProps =
      null;
  this.mode = mode;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function createFiberImplClass(tag, pendingProps, key, mode) {
  return new FiberNode(tag, pendingProps, key, mode);
}
function shouldConstruct(Component) {
  Component = Component.prototype;
  return !(!Component || !Component.isReactComponent);
}
function createWorkInProgress(current, pendingProps) {
  var workInProgress = current.alternate;
  null === workInProgress
    ? ((workInProgress = createFiberImplClass(
        current.tag,
        pendingProps,
        current.key,
        current.mode
      )),
      (workInProgress.elementType = current.elementType),
      (workInProgress.type = current.type),
      (workInProgress.stateNode = current.stateNode),
      (workInProgress.alternate = current),
      (current.alternate = workInProgress))
    : ((workInProgress.pendingProps = pendingProps),
      (workInProgress.type = current.type),
      (workInProgress.flags = 0),
      (workInProgress.subtreeFlags = 0),
      (workInProgress.deletions = null));
  workInProgress.flags = current.flags & 65011712;
  workInProgress.childLanes = current.childLanes;
  workInProgress.lanes = current.lanes;
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;
  pendingProps = current.dependencies;
  workInProgress.dependencies =
    null === pendingProps
      ? null
      : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;
  workInProgress.refCleanup = current.refCleanup;
  return workInProgress;
}
function resetWorkInProgress(workInProgress, renderLanes) {
  workInProgress.flags &= 65011714;
  var current = workInProgress.alternate;
  null === current
    ? ((workInProgress.childLanes = 0),
      (workInProgress.lanes = renderLanes),
      (workInProgress.child = null),
      (workInProgress.subtreeFlags = 0),
      (workInProgress.memoizedProps = null),
      (workInProgress.memoizedState = null),
      (workInProgress.updateQueue = null),
      (workInProgress.dependencies = null),
      (workInProgress.stateNode = null))
    : ((workInProgress.childLanes = current.childLanes),
      (workInProgress.lanes = current.lanes),
      (workInProgress.child = current.child),
      (workInProgress.subtreeFlags = 0),
      (workInProgress.deletions = null),
      (workInProgress.memoizedProps = current.memoizedProps),
      (workInProgress.memoizedState = current.memoizedState),
      (workInProgress.updateQueue = current.updateQueue),
      (workInProgress.type = current.type),
      (renderLanes = current.dependencies),
      (workInProgress.dependencies =
        null === renderLanes
          ? null
          : {
              lanes: renderLanes.lanes,
              firstContext: renderLanes.firstContext
            }));
  return workInProgress;
}
function createFiberFromTypeAndProps(
  type,
  key,
  pendingProps,
  owner,
  mode,
  lanes
) {
  var fiberTag = 0;
  owner = type;
  if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
  else if ("string" === typeof type)
    fiberTag = isHostHoistableType(
      type,
      pendingProps,
      contextStackCursor.current
    )
      ? 26
      : "html" === type || "head" === type || "body" === type
        ? 27
        : 5;
  else
    a: switch (type) {
      case REACT_ACTIVITY_TYPE:
        return (
          (type = createFiberImplClass(31, pendingProps, key, mode)),
          (type.elementType = REACT_ACTIVITY_TYPE),
          (type.lanes = lanes),
          type
        );
      case REACT_FRAGMENT_TYPE:
        return createFiberFromFragment(pendingProps.children, mode, lanes, key);
      case REACT_STRICT_MODE_TYPE:
        fiberTag = 8;
        mode |= 24;
        break;
      case REACT_PROFILER_TYPE:
        return (
          (type = createFiberImplClass(12, pendingProps, key, mode | 2)),
          (type.elementType = REACT_PROFILER_TYPE),
          (type.lanes = lanes),
          type
        );
      case REACT_SUSPENSE_TYPE:
        return (
          (type = createFiberImplClass(13, pendingProps, key, mode)),
          (type.elementType = REACT_SUSPENSE_TYPE),
          (type.lanes = lanes),
          type
        );
      case REACT_SUSPENSE_LIST_TYPE:
        return (
          (type = createFiberImplClass(19, pendingProps, key, mode)),
          (type.elementType = REACT_SUSPENSE_LIST_TYPE),
          (type.lanes = lanes),
          type
        );
      default:
        if ("object" === typeof type && null !== type)
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              fiberTag = 10;
              break a;
            case REACT_CONSUMER_TYPE:
              fiberTag = 9;
              break a;
            case REACT_FORWARD_REF_TYPE:
              fiberTag = 11;
              break a;
            case REACT_MEMO_TYPE:
              fiberTag = 14;
              break a;
            case REACT_LAZY_TYPE:
              fiberTag = 16;
              owner = null;
              break a;
          }
        fiberTag = 29;
        pendingProps = Error(
          formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
        );
        owner = null;
    }
  key = createFiberImplClass(fiberTag, pendingProps, key, mode);
  key.elementType = type;
  key.type = owner;
  key.lanes = lanes;
  return key;
}
function createFiberFromFragment(elements, mode, lanes, key) {
  elements = createFiberImplClass(7, elements, key, mode);
  elements.lanes = lanes;
  return elements;
}
function createFiberFromText(content, mode, lanes) {
  content = createFiberImplClass(6, content, null, mode);
  content.lanes = lanes;
  return content;
}
function createFiberFromDehydratedFragment(dehydratedNode) {
  var fiber = createFiberImplClass(18, null, null, 0);
  fiber.stateNode = dehydratedNode;
  return fiber;
}
function createFiberFromPortal(portal, mode, lanes) {
  mode = createFiberImplClass(
    4,
    null !== portal.children ? portal.children : [],
    portal.key,
    mode
  );
  mode.lanes = lanes;
  mode.stateNode = {
    containerInfo: portal.containerInfo,
    pendingChildren: null,
    implementation: portal.implementation
  };
  return mode;
}
var CapturedStacks = new WeakMap();
function createCapturedValueAtFiber(value, source) {
  if ("object" === typeof value && null !== value) {
    var existing = CapturedStacks.get(value);
    if (void 0 !== existing) return existing;
    source = {
      value: value,
      source: source,
      stack: getStackByFiberInDevAndProd(source)
    };
    CapturedStacks.set(value, source);
    return source;
  }
  return {
    value: value,
    source: source,
    stack: getStackByFiberInDevAndProd(source)
  };
}
var forkStack = [],
  forkStackIndex = 0,
  treeForkProvider = null,
  treeForkCount = 0,
  idStack = [],
  idStackIndex = 0,
  treeContextProvider = null,
  treeContextId = 1,
  treeContextOverflow = "";
function pushTreeFork(workInProgress, totalChildren) {
  forkStack[forkStackIndex++] = treeForkCount;
  forkStack[forkStackIndex++] = treeForkProvider;
  treeForkProvider = workInProgress;
  treeForkCount = totalChildren;
}
function pushTreeId(workInProgress, totalChildren, index) {
  idStack[idStackIndex++] = treeContextId;
  idStack[idStackIndex++] = treeContextOverflow;
  idStack[idStackIndex++] = treeContextProvider;
  treeContextProvider = workInProgress;
  var baseIdWithLeadingBit = treeContextId;
  workInProgress = treeContextOverflow;
  var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
  baseIdWithLeadingBit &= ~(1 << baseLength);
  index += 1;
  var length = 32 - clz32(totalChildren) + baseLength;
  if (30 < length) {
    var numberOfOverflowBits = baseLength - (baseLength % 5);
    length = (
      baseIdWithLeadingBit &
      ((1 << numberOfOverflowBits) - 1)
    ).toString(32);
    baseIdWithLeadingBit >>= numberOfOverflowBits;
    baseLength -= numberOfOverflowBits;
    treeContextId =
      (1 << (32 - clz32(totalChildren) + baseLength)) |
      (index << baseLength) |
      baseIdWithLeadingBit;
    treeContextOverflow = length + workInProgress;
  } else
    (treeContextId =
      (1 << length) | (index << baseLength) | baseIdWithLeadingBit),
      (treeContextOverflow = workInProgress);
}
function pushMaterializedTreeId(workInProgress) {
  null !== workInProgress.return &&
    (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
}
function popTreeContext(workInProgress) {
  for (; workInProgress === treeForkProvider; )
    (treeForkProvider = forkStack[--forkStackIndex]),
      (forkStack[forkStackIndex] = null),
      (treeForkCount = forkStack[--forkStackIndex]),
      (forkStack[forkStackIndex] = null);
  for (; workInProgress === treeContextProvider; )
    (treeContextProvider = idStack[--idStackIndex]),
      (idStack[idStackIndex] = null),
      (treeContextOverflow = idStack[--idStackIndex]),
      (idStack[idStackIndex] = null),
      (treeContextId = idStack[--idStackIndex]),
      (idStack[idStackIndex] = null);
}
function restoreSuspendedTreeContext(workInProgress, suspendedContext) {
  idStack[idStackIndex++] = treeContextId;
  idStack[idStackIndex++] = treeContextOverflow;
  idStack[idStackIndex++] = treeContextProvider;
  treeContextId = suspendedContext.id;
  treeContextOverflow = suspendedContext.overflow;
  treeContextProvider = workInProgress;
}
var hydrationParentFiber = null,
  nextHydratableInstance = null,
  isHydrating = !1,
  hydrationErrors = null,
  rootOrSingletonContext = !1,
  HydrationMismatchException = Error(formatProdErrorMessage(519));
function throwOnHydrationMismatch(fiber) {
  var error = Error(
    formatProdErrorMessage(
      418,
      1 < arguments.length && void 0 !== arguments[1] && arguments[1]
        ? "text"
        : "HTML",
      ""
    )
  );
  queueHydrationError(createCapturedValueAtFiber(error, fiber));
  throw HydrationMismatchException;
}
function prepareToHydrateHostInstance(fiber) {
  var instance = fiber.stateNode,
    type = fiber.type,
    props = fiber.memoizedProps;
  instance[internalInstanceKey] = fiber;
  instance[internalPropsKey] = props;
  switch (type) {
    case "dialog":
      listenToNonDelegatedEvent("cancel", instance);
      listenToNonDelegatedEvent("close", instance);
      break;
    case "iframe":
    case "object":
    case "embed":
      listenToNonDelegatedEvent("load", instance);
      break;
    case "video":
    case "audio":
      for (type = 0; type < mediaEventTypes.length; type++)
        listenToNonDelegatedEvent(mediaEventTypes[type], instance);
      break;
    case "source":
      listenToNonDelegatedEvent("error", instance);
      break;
    case "img":
    case "image":
    case "link":
      listenToNonDelegatedEvent("error", instance);
      listenToNonDelegatedEvent("load", instance);
      break;
    case "details":
      listenToNonDelegatedEvent("toggle", instance);
      break;
    case "input":
      listenToNonDelegatedEvent("invalid", instance);
      initInput(
        instance,
        props.value,
        props.defaultValue,
        props.checked,
        props.defaultChecked,
        props.type,
        props.name,
        !0
      );
      break;
    case "select":
      listenToNonDelegatedEvent("invalid", instance);
      break;
    case "textarea":
      listenToNonDelegatedEvent("invalid", instance),
        initTextarea(instance, props.value, props.defaultValue, props.children);
  }
  type = props.children;
  ("string" !== typeof type &&
    "number" !== typeof type &&
    "bigint" !== typeof type) ||
  instance.textContent === "" + type ||
  !0 === props.suppressHydrationWarning ||
  checkForUnmatchedText(instance.textContent, type)
    ? (null != props.popover &&
        (listenToNonDelegatedEvent("beforetoggle", instance),
        listenToNonDelegatedEvent("toggle", instance)),
      null != props.onScroll && listenToNonDelegatedEvent("scroll", instance),
      null != props.onScrollEnd &&
        listenToNonDelegatedEvent("scrollend", instance),
      null != props.onClick && (instance.onclick = noop$1),
      (instance = !0))
    : (instance = !1);
  instance || throwOnHydrationMismatch(fiber, !0);
}
function popToNextHostParent(fiber) {
  for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
    switch (hydrationParentFiber.tag) {
      case 5:
      case 31:
      case 13:
        rootOrSingletonContext = !1;
        return;
      case 27:
      case 3:
        rootOrSingletonContext = !0;
        return;
      default:
        hydrationParentFiber = hydrationParentFiber.return;
    }
}
function popHydrationState(fiber) {
  if (fiber !== hydrationParentFiber) return !1;
  if (!isHydrating) return popToNextHostParent(fiber), (isHydrating = !0), !1;
  var tag = fiber.tag,
    JSCompiler_temp;
  if ((JSCompiler_temp = 3 !== tag && 27 !== tag)) {
    if ((JSCompiler_temp = 5 === tag))
      (JSCompiler_temp = fiber.type),
        (JSCompiler_temp =
          !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) ||
          shouldSetTextContent(fiber.type, fiber.memoizedProps));
    JSCompiler_temp = !JSCompiler_temp;
  }
  JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
  popToNextHostParent(fiber);
  if (13 === tag) {
    fiber = fiber.memoizedState;
    fiber = null !== fiber ? fiber.dehydrated : null;
    if (!fiber) throw Error(formatProdErrorMessage(317));
    nextHydratableInstance =
      getNextHydratableInstanceAfterHydrationBoundary(fiber);
  } else if (31 === tag) {
    fiber = fiber.memoizedState;
    fiber = null !== fiber ? fiber.dehydrated : null;
    if (!fiber) throw Error(formatProdErrorMessage(317));
    nextHydratableInstance =
      getNextHydratableInstanceAfterHydrationBoundary(fiber);
  } else
    27 === tag
      ? ((tag = nextHydratableInstance),
        isSingletonScope(fiber.type)
          ? ((fiber = previousHydratableOnEnteringScopedSingleton),
            (previousHydratableOnEnteringScopedSingleton = null),
            (nextHydratableInstance = fiber))
          : (nextHydratableInstance = tag))
      : (nextHydratableInstance = hydrationParentFiber
          ? getNextHydratable(fiber.stateNode.nextSibling)
          : null);
  return !0;
}
function resetHydrationState() {
  nextHydratableInstance = hydrationParentFiber = null;
  isHydrating = !1;
}
function upgradeHydrationErrorsToRecoverable() {
  var queuedErrors = hydrationErrors;
  null !== queuedErrors &&
    (null === workInProgressRootRecoverableErrors
      ? (workInProgressRootRecoverableErrors = queuedErrors)
      : workInProgressRootRecoverableErrors.push.apply(
          workInProgressRootRecoverableErrors,
          queuedErrors
        ),
    (hydrationErrors = null));
  return queuedErrors;
}
function queueHydrationError(error) {
  null === hydrationErrors
    ? (hydrationErrors = [error])
    : hydrationErrors.push(error);
}
var valueCursor = createCursor(null),
  currentlyRenderingFiber$1 = null,
  lastContextDependency = null;
function pushProvider(providerFiber, context, nextValue) {
  push(valueCursor, context._currentValue);
  context._currentValue = nextValue;
}
function popProvider(context) {
  context._currentValue = valueCursor.current;
  pop(valueCursor);
}
function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
  for (; null !== parent; ) {
    var alternate = parent.alternate;
    (parent.childLanes & renderLanes) !== renderLanes
      ? ((parent.childLanes |= renderLanes),
        null !== alternate && (alternate.childLanes |= renderLanes))
      : null !== alternate &&
        (alternate.childLanes & renderLanes) !== renderLanes &&
        (alternate.childLanes |= renderLanes);
    if (parent === propagationRoot) break;
    parent = parent.return;
  }
}
function propagateContextChanges(
  workInProgress,
  contexts,
  renderLanes,
  forcePropagateEntireTree
) {
  var fiber = workInProgress.child;
  null !== fiber && (fiber.return = workInProgress);
  for (; null !== fiber; ) {
    var list = fiber.dependencies;
    if (null !== list) {
      var nextFiber = fiber.child;
      list = list.firstContext;
      a: for (; null !== list; ) {
        var dependency = list;
        list = fiber;
        for (var i = 0; i < contexts.length; i++)
          if (dependency.context === contexts[i]) {
            list.lanes |= renderLanes;
            dependency = list.alternate;
            null !== dependency && (dependency.lanes |= renderLanes);
            scheduleContextWorkOnParentPath(
              list.return,
              renderLanes,
              workInProgress
            );
            forcePropagateEntireTree || (nextFiber = null);
            break a;
          }
        list = dependency.next;
      }
    } else if (18 === fiber.tag) {
      nextFiber = fiber.return;
      if (null === nextFiber) throw Error(formatProdErrorMessage(341));
      nextFiber.lanes |= renderLanes;
      list = nextFiber.alternate;
      null !== list && (list.lanes |= renderLanes);
      scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);
      nextFiber = null;
    } else nextFiber = fiber.child;
    if (null !== nextFiber) nextFiber.return = fiber;
    else
      for (nextFiber = fiber; null !== nextFiber; ) {
        if (nextFiber === workInProgress) {
          nextFiber = null;
          break;
        }
        fiber = nextFiber.sibling;
        if (null !== fiber) {
          fiber.return = nextFiber.return;
          nextFiber = fiber;
          break;
        }
        nextFiber = nextFiber.return;
      }
    fiber = nextFiber;
  }
}
function propagateParentContextChanges(
  current,
  workInProgress,
  renderLanes,
  forcePropagateEntireTree
) {
  current = null;
  for (
    var parent = workInProgress, isInsidePropagationBailout = !1;
    null !== parent;

  ) {
    if (!isInsidePropagationBailout)
      if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;
      else if (0 !== (parent.flags & 262144)) break;
    if (10 === parent.tag) {
      var currentParent = parent.alternate;
      if (null === currentParent) throw Error(formatProdErrorMessage(387));
      currentParent = currentParent.memoizedProps;
      if (null !== currentParent) {
        var context = parent.type;
        objectIs(parent.pendingProps.value, currentParent.value) ||
          (null !== current ? current.push(context) : (current = [context]));
      }
    } else if (parent === hostTransitionProviderCursor.current) {
      currentParent = parent.alternate;
      if (null === currentParent) throw Error(formatProdErrorMessage(387));
      currentParent.memoizedState.memoizedState !==
        parent.memoizedState.memoizedState &&
        (null !== current
          ? current.push(HostTransitionContext)
          : (current = [HostTransitionContext]));
    }
    parent = parent.return;
  }
  null !== current &&
    propagateContextChanges(
      workInProgress,
      current,
      renderLanes,
      forcePropagateEntireTree
    );
  workInProgress.flags |= 262144;
}
function checkIfContextChanged(currentDependencies) {
  for (
    currentDependencies = currentDependencies.firstContext;
    null !== currentDependencies;

  ) {
    if (
      !objectIs(
        currentDependencies.context._currentValue,
        currentDependencies.memoizedValue
      )
    )
      return !0;
    currentDependencies = currentDependencies.next;
  }
  return !1;
}
function prepareToReadContext(workInProgress) {
  currentlyRenderingFiber$1 = workInProgress;
  lastContextDependency = null;
  workInProgress = workInProgress.dependencies;
  null !== workInProgress && (workInProgress.firstContext = null);
}
function readContext(context) {
  return readContextForConsumer(currentlyRenderingFiber$1, context);
}
function readContextDuringReconciliation(consumer, context) {
  null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
  return readContextForConsumer(consumer, context);
}
function readContextForConsumer(consumer, context) {
  var value = context._currentValue;
  context = { context: context, memoizedValue: value, next: null };
  if (null === lastContextDependency) {
    if (null === consumer) throw Error(formatProdErrorMessage(308));
    lastContextDependency = context;
    consumer.dependencies = { lanes: 0, firstContext: context };
    consumer.flags |= 524288;
  } else lastContextDependency = lastContextDependency.next = context;
  return value;
}
var AbortControllerLocal =
    "undefined" !== typeof AbortController
      ? AbortController
      : function () {
          var listeners = [],
            signal = (this.signal = {
              aborted: !1,
              addEventListener: function (type, listener) {
                listeners.push(listener);
              }
            });
          this.abort = function () {
            signal.aborted = !0;
            listeners.forEach(function (listener) {
              return listener();
            });
          };
        },
  scheduleCallback$2 = Scheduler.unstable_scheduleCallback,
  NormalPriority = Scheduler.unstable_NormalPriority,
  CacheContext = {
    $$typeof: REACT_CONTEXT_TYPE,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
function createCache() {
  return {
    controller: new AbortControllerLocal(),
    data: new Map(),
    refCount: 0
  };
}
function releaseCache(cache) {
  cache.refCount--;
  0 === cache.refCount &&
    scheduleCallback$2(NormalPriority, function () {
      cache.controller.abort();
    });
}
var currentEntangledListeners = null,
  currentEntangledPendingCount = 0,
  currentEntangledLane = 0,
  currentEntangledActionThenable = null;
function entangleAsyncAction(transition, thenable) {
  if (null === currentEntangledListeners) {
    var entangledListeners = (currentEntangledListeners = []);
    currentEntangledPendingCount = 0;
    currentEntangledLane = requestTransitionLane();
    currentEntangledActionThenable = {
      status: "pending",
      value: void 0,
      then: function (resolve) {
        entangledListeners.push(resolve);
      }
    };
  }
  currentEntangledPendingCount++;
  thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
  return thenable;
}
function pingEngtangledActionScope() {
  if (
    0 === --currentEntangledPendingCount &&
    null !== currentEntangledListeners
  ) {
    null !== currentEntangledActionThenable &&
      (currentEntangledActionThenable.status = "fulfilled");
    var listeners = currentEntangledListeners;
    currentEntangledListeners = null;
    currentEntangledLane = 0;
    currentEntangledActionThenable = null;
    for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
  }
}
function chainThenableValue(thenable, result) {
  var listeners = [],
    thenableWithOverride = {
      status: "pending",
      value: null,
      reason: null,
      then: function (resolve) {
        listeners.push(resolve);
      }
    };
  thenable.then(
    function () {
      thenableWithOverride.status = "fulfilled";
      thenableWithOverride.value = result;
      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
    },
    function (error) {
      thenableWithOverride.status = "rejected";
      thenableWithOverride.reason = error;
      for (error = 0; error < listeners.length; error++)
        (0, listeners[error])(void 0);
    }
  );
  return thenableWithOverride;
}
var prevOnStartTransitionFinish = ReactSharedInternals.S;
ReactSharedInternals.S = function (transition, returnValue) {
  globalMostRecentTransitionTime = now();
  "object" === typeof returnValue &&
    null !== returnValue &&
    "function" === typeof returnValue.then &&
    entangleAsyncAction(transition, returnValue);
  null !== prevOnStartTransitionFinish &&
    prevOnStartTransitionFinish(transition, returnValue);
};
var resumedCache = createCursor(null);
function peekCacheFromPool() {
  var cacheResumedFromPreviousRender = resumedCache.current;
  return null !== cacheResumedFromPreviousRender
    ? cacheResumedFromPreviousRender
    : workInProgressRoot.pooledCache;
}
function pushTransition(offscreenWorkInProgress, prevCachePool) {
  null === prevCachePool
    ? push(resumedCache, resumedCache.current)
    : push(resumedCache, prevCachePool.pool);
}
function getSuspendedCache() {
  var cacheFromPool = peekCacheFromPool();
  return null === cacheFromPool
    ? null
    : { parent: CacheContext._currentValue, pool: cacheFromPool };
}
var SuspenseException = Error(formatProdErrorMessage(460)),
  SuspenseyCommitException = Error(formatProdErrorMessage(474)),
  SuspenseActionException = Error(formatProdErrorMessage(542)),
  noopSuspenseyCommitThenable = { then: function () {} };
function isThenableResolved(thenable) {
  thenable = thenable.status;
  return "fulfilled" === thenable || "rejected" === thenable;
}
function trackUsedThenable(thenableState, thenable, index) {
  index = thenableState[index];
  void 0 === index
    ? thenableState.push(thenable)
    : index !== thenable && (thenable.then(noop$1, noop$1), (thenable = index));
  switch (thenable.status) {
    case "fulfilled":
      return thenable.value;
    case "rejected":
      throw (
        ((thenableState = thenable.reason),
        checkIfUseWrappedInAsyncCatch(thenableState),
        thenableState)
      );
    default:
      if ("string" === typeof thenable.status) thenable.then(noop$1, noop$1);
      else {
        thenableState = workInProgressRoot;
        if (null !== thenableState && 100 < thenableState.shellSuspendCounter)
          throw Error(formatProdErrorMessage(482));
        thenableState = thenable;
        thenableState.status = "pending";
        thenableState.then(
          function (fulfilledValue) {
            if ("pending" === thenable.status) {
              var fulfilledThenable = thenable;
              fulfilledThenable.status = "fulfilled";
              fulfilledThenable.value = fulfilledValue;
            }
          },
          function (error) {
            if ("pending" === thenable.status) {
              var rejectedThenable = thenable;
              rejectedThenable.status = "rejected";
              rejectedThenable.reason = error;
            }
          }
        );
      }
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw (
            ((thenableState = thenable.reason),
            checkIfUseWrappedInAsyncCatch(thenableState),
            thenableState)
          );
      }
      suspendedThenable = thenable;
      throw SuspenseException;
  }
}
function resolveLazy(lazyType) {
  try {
    var init = lazyType._init;
    return init(lazyType._payload);
  } catch (x) {
    if (null !== x && "object" === typeof x && "function" === typeof x.then)
      throw ((suspendedThenable = x), SuspenseException);
    throw x;
  }
}
var suspendedThenable = null;
function getSuspendedThenable() {
  if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
  var thenable = suspendedThenable;
  suspendedThenable = null;
  return thenable;
}
function checkIfUseWrappedInAsyncCatch(rejectedReason) {
  if (
    rejectedReason === SuspenseException ||
    rejectedReason === SuspenseActionException
  )
    throw Error(formatProdErrorMessage(483));
}
var thenableState$1 = null,
  thenableIndexCounter$1 = 0;
function unwrapThenable(thenable) {
  var index = thenableIndexCounter$1;
  thenableIndexCounter$1 += 1;
  null === thenableState$1 && (thenableState$1 = []);
  return trackUsedThenable(thenableState$1, thenable, index);
}
function coerceRef(workInProgress, element) {
  element = element.props.ref;
  workInProgress.ref = void 0 !== element ? element : null;
}
function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
  if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
    throw Error(formatProdErrorMessage(525));
  returnFiber = Object.prototype.toString.call(newChild);
  throw Error(
    formatProdErrorMessage(
      31,
      "[object Object]" === returnFiber
        ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
        : returnFiber
    )
  );
}
function createChildReconciler(shouldTrackSideEffects) {
  function deleteChild(returnFiber, childToDelete) {
    if (shouldTrackSideEffects) {
      var deletions = returnFiber.deletions;
      null === deletions
        ? ((returnFiber.deletions = [childToDelete]), (returnFiber.flags |= 16))
        : deletions.push(childToDelete);
    }
  }
  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) return null;
    for (; null !== currentFirstChild; )
      deleteChild(returnFiber, currentFirstChild),
        (currentFirstChild = currentFirstChild.sibling);
    return null;
  }
  function mapRemainingChildren(currentFirstChild) {
    for (var existingChildren = new Map(); null !== currentFirstChild; )
      null !== currentFirstChild.key
        ? existingChildren.set(currentFirstChild.key, currentFirstChild)
        : existingChildren.set(currentFirstChild.index, currentFirstChild),
        (currentFirstChild = currentFirstChild.sibling);
    return existingChildren;
  }
  function useFiber(fiber, pendingProps) {
    fiber = createWorkInProgress(fiber, pendingProps);
    fiber.index = 0;
    fiber.sibling = null;
    return fiber;
  }
  function placeChild(newFiber, lastPlacedIndex, newIndex) {
    newFiber.index = newIndex;
    if (!shouldTrackSideEffects)
      return (newFiber.flags |= 1048576), lastPlacedIndex;
    newIndex = newFiber.alternate;
    if (null !== newIndex)
      return (
        (newIndex = newIndex.index),
        newIndex < lastPlacedIndex
          ? ((newFiber.flags |= 67108866), lastPlacedIndex)
          : newIndex
      );
    newFiber.flags |= 67108866;
    return lastPlacedIndex;
  }
  function placeSingleChild(newFiber) {
    shouldTrackSideEffects &&
      null === newFiber.alternate &&
      (newFiber.flags |= 67108866);
    return newFiber;
  }
  function updateTextNode(returnFiber, current, textContent, lanes) {
    if (null === current || 6 !== current.tag)
      return (
        (current = createFiberFromText(textContent, returnFiber.mode, lanes)),
        (current.return = returnFiber),
        current
      );
    current = useFiber(current, textContent);
    current.return = returnFiber;
    return current;
  }
  function updateElement(returnFiber, current, element, lanes) {
    var elementType = element.type;
    if (elementType === REACT_FRAGMENT_TYPE)
      return updateFragment(
        returnFiber,
        current,
        element.props.children,
        lanes,
        element.key
      );
    if (
      null !== current &&
      (current.elementType === elementType ||
        ("object" === typeof elementType &&
          null !== elementType &&
          elementType.$$typeof === REACT_LAZY_TYPE &&
          resolveLazy(elementType) === current.type))
    )
      return (
        (current = useFiber(current, element.props)),
        coerceRef(current, element),
        (current.return = returnFiber),
        current
      );
    current = createFiberFromTypeAndProps(
      element.type,
      element.key,
      element.props,
      null,
      returnFiber.mode,
      lanes
    );
    coerceRef(current, element);
    current.return = returnFiber;
    return current;
  }
  function updatePortal(returnFiber, current, portal, lanes) {
    if (
      null === current ||
      4 !== current.tag ||
      current.stateNode.containerInfo !== portal.containerInfo ||
      current.stateNode.implementation !== portal.implementation
    )
      return (
        (current = createFiberFromPortal(portal, returnFiber.mode, lanes)),
        (current.return = returnFiber),
        current
      );
    current = useFiber(current, portal.children || []);
    current.return = returnFiber;
    return current;
  }
  function updateFragment(returnFiber, current, fragment, lanes, key) {
    if (null === current || 7 !== current.tag)
      return (
        (current = createFiberFromFragment(
          fragment,
          returnFiber.mode,
          lanes,
          key
        )),
        (current.return = returnFiber),
        current
      );
    current = useFiber(current, fragment);
    current.return = returnFiber;
    return current;
  }
  function createChild(returnFiber, newChild, lanes) {
    if (
      ("string" === typeof newChild && "" !== newChild) ||
      "number" === typeof newChild ||
      "bigint" === typeof newChild
    )
      return (
        (newChild = createFiberFromText(
          "" + newChild,
          returnFiber.mode,
          lanes
        )),
        (newChild.return = returnFiber),
        newChild
      );
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return (
            (lanes = createFiberFromTypeAndProps(
              newChild.type,
              newChild.key,
              newChild.props,
              null,
              returnFiber.mode,
              lanes
            )),
            coerceRef(lanes, newChild),
            (lanes.return = returnFiber),
            lanes
          );
        case REACT_PORTAL_TYPE:
          return (
            (newChild = createFiberFromPortal(
              newChild,
              returnFiber.mode,
              lanes
            )),
            (newChild.return = returnFiber),
            newChild
          );
        case REACT_LAZY_TYPE:
          return (
            (newChild = resolveLazy(newChild)),
            createChild(returnFiber, newChild, lanes)
          );
      }
      if (isArrayImpl(newChild) || getIteratorFn(newChild))
        return (
          (newChild = createFiberFromFragment(
            newChild,
            returnFiber.mode,
            lanes,
            null
          )),
          (newChild.return = returnFiber),
          newChild
        );
      if ("function" === typeof newChild.then)
        return createChild(returnFiber, unwrapThenable(newChild), lanes);
      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
        return createChild(
          returnFiber,
          readContextDuringReconciliation(returnFiber, newChild),
          lanes
        );
      throwOnInvalidObjectTypeImpl(returnFiber, newChild);
    }
    return null;
  }
  function updateSlot(returnFiber, oldFiber, newChild, lanes) {
    var key = null !== oldFiber ? oldFiber.key : null;
    if (
      ("string" === typeof newChild && "" !== newChild) ||
      "number" === typeof newChild ||
      "bigint" === typeof newChild
    )
      return null !== key
        ? null
        : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return newChild.key === key
            ? updateElement(returnFiber, oldFiber, newChild, lanes)
            : null;
        case REACT_PORTAL_TYPE:
          return newChild.key === key
            ? updatePortal(returnFiber, oldFiber, newChild, lanes)
            : null;
        case REACT_LAZY_TYPE:
          return (
            (newChild = resolveLazy(newChild)),
            updateSlot(returnFiber, oldFiber, newChild, lanes)
          );
      }
      if (isArrayImpl(newChild) || getIteratorFn(newChild))
        return null !== key
          ? null
          : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
      if ("function" === typeof newChild.then)
        return updateSlot(
          returnFiber,
          oldFiber,
          unwrapThenable(newChild),
          lanes
        );
      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
        return updateSlot(
          returnFiber,
          oldFiber,
          readContextDuringReconciliation(returnFiber, newChild),
          lanes
        );
      throwOnInvalidObjectTypeImpl(returnFiber, newChild);
    }
    return null;
  }
  function updateFromMap(
    existingChildren,
    returnFiber,
    newIdx,
    newChild,
    lanes
  ) {
    if (
      ("string" === typeof newChild && "" !== newChild) ||
      "number" === typeof newChild ||
      "bigint" === typeof newChild
    )
      return (
        (existingChildren = existingChildren.get(newIdx) || null),
        updateTextNode(returnFiber, existingChildren, "" + newChild, lanes)
      );
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return (
            (existingChildren =
              existingChildren.get(
                null === newChild.key ? newIdx : newChild.key
              ) || null),
            updateElement(returnFiber, existingChildren, newChild, lanes)
          );
        case REACT_PORTAL_TYPE:
          return (
            (existingChildren =
              existingChildren.get(
                null === newChild.key ? newIdx : newChild.key
              ) || null),
            updatePortal(returnFiber, existingChildren, newChild, lanes)
          );
        case REACT_LAZY_TYPE:
          return (
            (newChild = resolveLazy(newChild)),
            updateFromMap(
              existingChildren,
              returnFiber,
              newIdx,
              newChild,
              lanes
            )
          );
      }
      if (isArrayImpl(newChild) || getIteratorFn(newChild))
        return (
          (existingChildren = existingChildren.get(newIdx) || null),
          updateFragment(returnFiber, existingChildren, newChild, lanes, null)
        );
      if ("function" === typeof newChild.then)
        return updateFromMap(
          existingChildren,
          returnFiber,
          newIdx,
          unwrapThenable(newChild),
          lanes
        );
      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
        return updateFromMap(
          existingChildren,
          returnFiber,
          newIdx,
          readContextDuringReconciliation(returnFiber, newChild),
          lanes
        );
      throwOnInvalidObjectTypeImpl(returnFiber, newChild);
    }
    return null;
  }
  function reconcileChildrenArray(
    returnFiber,
    currentFirstChild,
    newChildren,
    lanes
  ) {
    for (
      var resultingFirstChild = null,
        previousNewFiber = null,
        oldFiber = currentFirstChild,
        newIdx = (currentFirstChild = 0),
        nextOldFiber = null;
      null !== oldFiber && newIdx < newChildren.length;
      newIdx++
    ) {
      oldFiber.index > newIdx
        ? ((nextOldFiber = oldFiber), (oldFiber = null))
        : (nextOldFiber = oldFiber.sibling);
      var newFiber = updateSlot(
        returnFiber,
        oldFiber,
        newChildren[newIdx],
        lanes
      );
      if (null === newFiber) {
        null === oldFiber && (oldFiber = nextOldFiber);
        break;
      }
      shouldTrackSideEffects &&
        oldFiber &&
        null === newFiber.alternate &&
        deleteChild(returnFiber, oldFiber);
      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
      null === previousNewFiber
        ? (resultingFirstChild = newFiber)
        : (previousNewFiber.sibling = newFiber);
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }
    if (newIdx === newChildren.length)
      return (
        deleteRemainingChildren(returnFiber, oldFiber),
        isHydrating && pushTreeFork(returnFiber, newIdx),
        resultingFirstChild
      );
    if (null === oldFiber) {
      for (; newIdx < newChildren.length; newIdx++)
        (oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),
          null !== oldFiber &&
            ((currentFirstChild = placeChild(
              oldFiber,
              currentFirstChild,
              newIdx
            )),
            null === previousNewFiber
              ? (resultingFirstChild = oldFiber)
              : (previousNewFiber.sibling = oldFiber),
            (previousNewFiber = oldFiber));
      isHydrating && pushTreeFork(returnFiber, newIdx);
      return resultingFirstChild;
    }
    for (
      oldFiber = mapRemainingChildren(oldFiber);
      newIdx < newChildren.length;
      newIdx++
    )
      (nextOldFiber = updateFromMap(
        oldFiber,
        returnFiber,
        newIdx,
        newChildren[newIdx],
        lanes
      )),
        null !== nextOldFiber &&
          (shouldTrackSideEffects &&
            null !== nextOldFiber.alternate &&
            oldFiber.delete(
              null === nextOldFiber.key ? newIdx : nextOldFiber.key
            ),
          (currentFirstChild = placeChild(
            nextOldFiber,
            currentFirstChild,
            newIdx
          )),
          null === previousNewFiber
            ? (resultingFirstChild = nextOldFiber)
            : (previousNewFiber.sibling = nextOldFiber),
          (previousNewFiber = nextOldFiber));
    shouldTrackSideEffects &&
      oldFiber.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    isHydrating && pushTreeFork(returnFiber, newIdx);
    return resultingFirstChild;
  }
  function reconcileChildrenIterator(
    returnFiber,
    currentFirstChild,
    newChildren,
    lanes
  ) {
    if (null == newChildren) throw Error(formatProdErrorMessage(151));
    for (
      var resultingFirstChild = null,
        previousNewFiber = null,
        oldFiber = currentFirstChild,
        newIdx = (currentFirstChild = 0),
        nextOldFiber = null,
        step = newChildren.next();
      null !== oldFiber && !step.done;
      newIdx++, step = newChildren.next()
    ) {
      oldFiber.index > newIdx
        ? ((nextOldFiber = oldFiber), (oldFiber = null))
        : (nextOldFiber = oldFiber.sibling);
      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
      if (null === newFiber) {
        null === oldFiber && (oldFiber = nextOldFiber);
        break;
      }
      shouldTrackSideEffects &&
        oldFiber &&
        null === newFiber.alternate &&
        deleteChild(returnFiber, oldFiber);
      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
      null === previousNewFiber
        ? (resultingFirstChild = newFiber)
        : (previousNewFiber.sibling = newFiber);
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }
    if (step.done)
      return (
        deleteRemainingChildren(returnFiber, oldFiber),
        isHydrating && pushTreeFork(returnFiber, newIdx),
        resultingFirstChild
      );
    if (null === oldFiber) {
      for (; !step.done; newIdx++, step = newChildren.next())
        (step = createChild(returnFiber, step.value, lanes)),
          null !== step &&
            ((currentFirstChild = placeChild(step, currentFirstChild, newIdx)),
            null === previousNewFiber
              ? (resultingFirstChild = step)
              : (previousNewFiber.sibling = step),
            (previousNewFiber = step));
      isHydrating && pushTreeFork(returnFiber, newIdx);
      return resultingFirstChild;
    }
    for (
      oldFiber = mapRemainingChildren(oldFiber);
      !step.done;
      newIdx++, step = newChildren.next()
    )
      (step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes)),
        null !== step &&
          (shouldTrackSideEffects &&
            null !== step.alternate &&
            oldFiber.delete(null === step.key ? newIdx : step.key),
          (currentFirstChild = placeChild(step, currentFirstChild, newIdx)),
          null === previousNewFiber
            ? (resultingFirstChild = step)
            : (previousNewFiber.sibling = step),
          (previousNewFiber = step));
    shouldTrackSideEffects &&
      oldFiber.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    isHydrating && pushTreeFork(returnFiber, newIdx);
    return resultingFirstChild;
  }
  function reconcileChildFibersImpl(
    returnFiber,
    currentFirstChild,
    newChild,
    lanes
  ) {
    "object" === typeof newChild &&
      null !== newChild &&
      newChild.type === REACT_FRAGMENT_TYPE &&
      null === newChild.key &&
      (newChild = newChild.props.children);
    if ("object" === typeof newChild && null !== newChild) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          a: {
            for (var key = newChild.key; null !== currentFirstChild; ) {
              if (currentFirstChild.key === key) {
                key = newChild.type;
                if (key === REACT_FRAGMENT_TYPE) {
                  if (7 === currentFirstChild.tag) {
                    deleteRemainingChildren(
                      returnFiber,
                      currentFirstChild.sibling
                    );
                    lanes = useFiber(
                      currentFirstChild,
                      newChild.props.children
                    );
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                    break a;
                  }
                } else if (
                  currentFirstChild.elementType === key ||
                  ("object" === typeof key &&
                    null !== key &&
                    key.$$typeof === REACT_LAZY_TYPE &&
                    resolveLazy(key) === currentFirstChild.type)
                ) {
                  deleteRemainingChildren(
                    returnFiber,
                    currentFirstChild.sibling
                  );
                  lanes = useFiber(currentFirstChild, newChild.props);
                  coerceRef(lanes, newChild);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                  break a;
                }
                deleteRemainingChildren(returnFiber, currentFirstChild);
                break;
              } else deleteChild(returnFiber, currentFirstChild);
              currentFirstChild = currentFirstChild.sibling;
            }
            newChild.type === REACT_FRAGMENT_TYPE
              ? ((lanes = createFiberFromFragment(
                  newChild.props.children,
                  returnFiber.mode,
                  lanes,
                  newChild.key
                )),
                (lanes.return = returnFiber),
                (returnFiber = lanes))
              : ((lanes = createFiberFromTypeAndProps(
                  newChild.type,
                  newChild.key,
                  newChild.props,
                  null,
                  returnFiber.mode,
                  lanes
                )),
                coerceRef(lanes, newChild),
                (lanes.return = returnFiber),
                (returnFiber = lanes));
          }
          return placeSingleChild(returnFiber);
        case REACT_PORTAL_TYPE:
          a: {
            for (key = newChild.key; null !== currentFirstChild; ) {
              if (currentFirstChild.key === key)
                if (
                  4 === currentFirstChild.tag &&
                  currentFirstChild.stateNode.containerInfo ===
                    newChild.containerInfo &&
                  currentFirstChild.stateNode.implementation ===
                    newChild.implementation
                ) {
                  deleteRemainingChildren(
                    returnFiber,
                    currentFirstChild.sibling
                  );
                  lanes = useFiber(currentFirstChild, newChild.children || []);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                  break a;
                } else {
                  deleteRemainingChildren(returnFiber, currentFirstChild);
                  break;
                }
              else deleteChild(returnFiber, currentFirstChild);
              currentFirstChild = currentFirstChild.sibling;
            }
            lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
            lanes.return = returnFiber;
            returnFiber = lanes;
          }
          return placeSingleChild(returnFiber);
        case REACT_LAZY_TYPE:
          return (
            (newChild = resolveLazy(newChild)),
            reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            )
          );
      }
      if (isArrayImpl(newChild))
        return reconcileChildrenArray(
          returnFiber,
          currentFirstChild,
          newChild,
          lanes
        );
      if (getIteratorFn(newChild)) {
        key = getIteratorFn(newChild);
        if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
        newChild = key.call(newChild);
        return reconcileChildrenIterator(
          returnFiber,
          currentFirstChild,
          newChild,
          lanes
        );
      }
      if ("function" === typeof newChild.then)
        return reconcileChildFibersImpl(
          returnFiber,
          currentFirstChild,
          unwrapThenable(newChild),
          lanes
        );
      if (newChild.$$typeof === REACT_CONTEXT_TYPE)
        return reconcileChildFibersImpl(
          returnFiber,
          currentFirstChild,
          readContextDuringReconciliation(returnFiber, newChild),
          lanes
        );
      throwOnInvalidObjectTypeImpl(returnFiber, newChild);
    }
    return ("string" === typeof newChild && "" !== newChild) ||
      "number" === typeof newChild ||
      "bigint" === typeof newChild
      ? ((newChild = "" + newChild),
        null !== currentFirstChild && 6 === currentFirstChild.tag
          ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling),
            (lanes = useFiber(currentFirstChild, newChild)),
            (lanes.return = returnFiber),
            (returnFiber = lanes))
          : (deleteRemainingChildren(returnFiber, currentFirstChild),
            (lanes = createFiberFromText(newChild, returnFiber.mode, lanes)),
            (lanes.return = returnFiber),
            (returnFiber = lanes)),
        placeSingleChild(returnFiber))
      : deleteRemainingChildren(returnFiber, currentFirstChild);
  }
  return function (returnFiber, currentFirstChild, newChild, lanes) {
    try {
      thenableIndexCounter$1 = 0;
      var firstChildFiber = reconcileChildFibersImpl(
        returnFiber,
        currentFirstChild,
        newChild,
        lanes
      );
      thenableState$1 = null;
      return firstChildFiber;
    } catch (x) {
      if (x === SuspenseException || x === SuspenseActionException) throw x;
      var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
      fiber.lanes = lanes;
      fiber.return = returnFiber;
      return fiber;
    } finally {
    }
  };
}
var reconcileChildFibers = createChildReconciler(!0),
  mountChildFibers = createChildReconciler(!1),
  hasForceUpdate = !1;
function initializeUpdateQueue(fiber) {
  fiber.updateQueue = {
    baseState: fiber.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, lanes: 0, hiddenCallbacks: null },
    callbacks: null
  };
}
function cloneUpdateQueue(current, workInProgress) {
  current = current.updateQueue;
  workInProgress.updateQueue === current &&
    (workInProgress.updateQueue = {
      baseState: current.baseState,
      firstBaseUpdate: current.firstBaseUpdate,
      lastBaseUpdate: current.lastBaseUpdate,
      shared: current.shared,
      callbacks: null
    });
}
function createUpdate(lane) {
  return { lane: lane, tag: 0, payload: null, callback: null, next: null };
}
function enqueueUpdate(fiber, update, lane) {
  var updateQueue = fiber.updateQueue;
  if (null === updateQueue) return null;
  updateQueue = updateQueue.shared;
  if (0 !== (executionContext & 2)) {
    var pending = updateQueue.pending;
    null === pending
      ? (update.next = update)
      : ((update.next = pending.next), (pending.next = update));
    updateQueue.pending = update;
    update = getRootForUpdatedFiber(fiber);
    markUpdateLaneFromFiberToRoot(fiber, null, lane);
    return update;
  }
  enqueueUpdate$1(fiber, updateQueue, update, lane);
  return getRootForUpdatedFiber(fiber);
}
function entangleTransitions(root, fiber, lane) {
  fiber = fiber.updateQueue;
  if (null !== fiber && ((fiber = fiber.shared), 0 !== (lane & 4194048))) {
    var queueLanes = fiber.lanes;
    queueLanes &= root.pendingLanes;
    lane |= queueLanes;
    fiber.lanes = lane;
    markRootEntangled(root, lane);
  }
}
function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
  var queue = workInProgress.updateQueue,
    current = workInProgress.alternate;
  if (
    null !== current &&
    ((current = current.updateQueue), queue === current)
  ) {
    var newFirst = null,
      newLast = null;
    queue = queue.firstBaseUpdate;
    if (null !== queue) {
      do {
        var clone = {
          lane: queue.lane,
          tag: queue.tag,
          payload: queue.payload,
          callback: null,
          next: null
        };
        null === newLast
          ? (newFirst = newLast = clone)
          : (newLast = newLast.next = clone);
        queue = queue.next;
      } while (null !== queue);
      null === newLast
        ? (newFirst = newLast = capturedUpdate)
        : (newLast = newLast.next = capturedUpdate);
    } else newFirst = newLast = capturedUpdate;
    queue = {
      baseState: current.baseState,
      firstBaseUpdate: newFirst,
      lastBaseUpdate: newLast,
      shared: current.shared,
      callbacks: current.callbacks
    };
    workInProgress.updateQueue = queue;
    return;
  }
  workInProgress = queue.lastBaseUpdate;
  null === workInProgress
    ? (queue.firstBaseUpdate = capturedUpdate)
    : (workInProgress.next = capturedUpdate);
  queue.lastBaseUpdate = capturedUpdate;
}
var didReadFromEntangledAsyncAction = !1;
function suspendIfUpdateReadFromEntangledAsyncAction() {
  if (didReadFromEntangledAsyncAction) {
    var entangledActionThenable = currentEntangledActionThenable;
    if (null !== entangledActionThenable) throw entangledActionThenable;
  }
}
function processUpdateQueue(
  workInProgress$jscomp$0,
  props,
  instance$jscomp$0,
  renderLanes
) {
  didReadFromEntangledAsyncAction = !1;
  var queue = workInProgress$jscomp$0.updateQueue;
  hasForceUpdate = !1;
  var firstBaseUpdate = queue.firstBaseUpdate,
    lastBaseUpdate = queue.lastBaseUpdate,
    pendingQueue = queue.shared.pending;
  if (null !== pendingQueue) {
    queue.shared.pending = null;
    var lastPendingUpdate = pendingQueue,
      firstPendingUpdate = lastPendingUpdate.next;
    lastPendingUpdate.next = null;
    null === lastBaseUpdate
      ? (firstBaseUpdate = firstPendingUpdate)
      : (lastBaseUpdate.next = firstPendingUpdate);
    lastBaseUpdate = lastPendingUpdate;
    var current = workInProgress$jscomp$0.alternate;
    null !== current &&
      ((current = current.updateQueue),
      (pendingQueue = current.lastBaseUpdate),
      pendingQueue !== lastBaseUpdate &&
        (null === pendingQueue
          ? (current.firstBaseUpdate = firstPendingUpdate)
          : (pendingQueue.next = firstPendingUpdate),
        (current.lastBaseUpdate = lastPendingUpdate)));
  }
  if (null !== firstBaseUpdate) {
    var newState = queue.baseState;
    lastBaseUpdate = 0;
    current = firstPendingUpdate = lastPendingUpdate = null;
    pendingQueue = firstBaseUpdate;
    do {
      var updateLane = pendingQueue.lane & -536870913,
        isHiddenUpdate = updateLane !== pendingQueue.lane;
      if (
        isHiddenUpdate
          ? (workInProgressRootRenderLanes & updateLane) === updateLane
          : (renderLanes & updateLane) === updateLane
      ) {
        0 !== updateLane &&
          updateLane === currentEntangledLane &&
          (didReadFromEntangledAsyncAction = !0);
        null !== current &&
          (current = current.next =
            {
              lane: 0,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: null,
              next: null
            });
        a: {
          var workInProgress = workInProgress$jscomp$0,
            update = pendingQueue;
          updateLane = props;
          var instance = instance$jscomp$0;
          switch (update.tag) {
            case 1:
              workInProgress = update.payload;
              if ("function" === typeof workInProgress) {
                newState = workInProgress.call(instance, newState, updateLane);
                break a;
              }
              newState = workInProgress;
              break a;
            case 3:
              workInProgress.flags = (workInProgress.flags & -65537) | 128;
            case 0:
              workInProgress = update.payload;
              updateLane =
                "function" === typeof workInProgress
                  ? workInProgress.call(instance, newState, updateLane)
                  : workInProgress;
              if (null === updateLane || void 0 === updateLane) break a;
              newState = assign({}, newState, updateLane);
              break a;
            case 2:
              hasForceUpdate = !0;
          }
        }
        updateLane = pendingQueue.callback;
        null !== updateLane &&
          ((workInProgress$jscomp$0.flags |= 64),
          isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192),
          (isHiddenUpdate = queue.callbacks),
          null === isHiddenUpdate
            ? (queue.callbacks = [updateLane])
            : isHiddenUpdate.push(updateLane));
      } else
        (isHiddenUpdate = {
          lane: updateLane,
          tag: pendingQueue.tag,
          payload: pendingQueue.payload,
          callback: pendingQueue.callback,
          next: null
        }),
          null === current
            ? ((firstPendingUpdate = current = isHiddenUpdate),
              (lastPendingUpdate = newState))
            : (current = current.next = isHiddenUpdate),
          (lastBaseUpdate |= updateLane);
      pendingQueue = pendingQueue.next;
      if (null === pendingQueue)
        if (((pendingQueue = queue.shared.pending), null === pendingQueue))
          break;
        else
          (isHiddenUpdate = pendingQueue),
            (pendingQueue = isHiddenUpdate.next),
            (isHiddenUpdate.next = null),
            (queue.lastBaseUpdate = isHiddenUpdate),
            (queue.shared.pending = null);
    } while (1);
    null === current && (lastPendingUpdate = newState);
    queue.baseState = lastPendingUpdate;
    queue.firstBaseUpdate = firstPendingUpdate;
    queue.lastBaseUpdate = current;
    null === firstBaseUpdate && (queue.shared.lanes = 0);
    workInProgressRootSkippedLanes |= lastBaseUpdate;
    workInProgress$jscomp$0.lanes = lastBaseUpdate;
    workInProgress$jscomp$0.memoizedState = newState;
  }
}
function callCallback(callback, context) {
  if ("function" !== typeof callback)
    throw Error(formatProdErrorMessage(191, callback));
  callback.call(context);
}
function commitCallbacks(updateQueue, context) {
  var callbacks = updateQueue.callbacks;
  if (null !== callbacks)
    for (
      updateQueue.callbacks = null, updateQueue = 0;
      updateQueue < callbacks.length;
      updateQueue++
    )
      callCallback(callbacks[updateQueue], context);
}
var currentTreeHiddenStackCursor = createCursor(null),
  prevEntangledRenderLanesCursor = createCursor(0);
function pushHiddenContext(fiber, context) {
  fiber = entangledRenderLanes;
  push(prevEntangledRenderLanesCursor, fiber);
  push(currentTreeHiddenStackCursor, context);
  entangledRenderLanes = fiber | context.baseLanes;
}
function reuseHiddenContextOnStack() {
  push(prevEntangledRenderLanesCursor, entangledRenderLanes);
  push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
}
function popHiddenContext() {
  entangledRenderLanes = prevEntangledRenderLanesCursor.current;
  pop(currentTreeHiddenStackCursor);
  pop(prevEntangledRenderLanesCursor);
}
var suspenseHandlerStackCursor = createCursor(null),
  shellBoundary = null;
function pushPrimaryTreeSuspenseHandler(handler) {
  var current = handler.alternate;
  push(suspenseStackCursor, suspenseStackCursor.current & 1);
  push(suspenseHandlerStackCursor, handler);
  null === shellBoundary &&
    (null === current || null !== currentTreeHiddenStackCursor.current
      ? (shellBoundary = handler)
      : null !== current.memoizedState && (shellBoundary = handler));
}
function pushDehydratedActivitySuspenseHandler(fiber) {
  push(suspenseStackCursor, suspenseStackCursor.current);
  push(suspenseHandlerStackCursor, fiber);
  null === shellBoundary && (shellBoundary = fiber);
}
function pushOffscreenSuspenseHandler(fiber) {
  22 === fiber.tag
    ? (push(suspenseStackCursor, suspenseStackCursor.current),
      push(suspenseHandlerStackCursor, fiber),
      null === shellBoundary && (shellBoundary = fiber))
    : reuseSuspenseHandlerOnStack(fiber);
}
function reuseSuspenseHandlerOnStack() {
  push(suspenseStackCursor, suspenseStackCursor.current);
  push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
}
function popSuspenseHandler(fiber) {
  pop(suspenseHandlerStackCursor);
  shellBoundary === fiber && (shellBoundary = null);
  pop(suspenseStackCursor);
}
var suspenseStackCursor = createCursor(0);
function findFirstSuspended(row) {
  for (var node = row; null !== node; ) {
    if (13 === node.tag) {
      var state = node.memoizedState;
      if (
        null !== state &&
        ((state = state.dehydrated),
        null === state ||
          isSuspenseInstancePending(state) ||
          isSuspenseInstanceFallback(state))
      )
        return node;
    } else if (
      19 === node.tag &&
      ("forwards" === node.memoizedProps.revealOrder ||
        "backwards" === node.memoizedProps.revealOrder ||
        "unstable_legacy-backwards" === node.memoizedProps.revealOrder ||
        "together" === node.memoizedProps.revealOrder)
    ) {
      if (0 !== (node.flags & 128)) return node;
    } else if (null !== node.child) {
      node.child.return = node;
      node = node.child;
      continue;
    }
    if (node === row) break;
    for (; null === node.sibling; ) {
      if (null === node.return || node.return === row) return null;
      node = node.return;
    }
    node.sibling.return = node.return;
    node = node.sibling;
  }
  return null;
}
var renderLanes = 0,
  currentlyRenderingFiber = null,
  currentHook = null,
  workInProgressHook = null,
  didScheduleRenderPhaseUpdate = !1,
  didScheduleRenderPhaseUpdateDuringThisPass = !1,
  shouldDoubleInvokeUserFnsInHooksDEV = !1,
  localIdCounter = 0,
  thenableIndexCounter = 0,
  thenableState = null,
  globalClientIdCounter = 0;
function throwInvalidHookError() {
  throw Error(formatProdErrorMessage(321));
}
function areHookInputsEqual(nextDeps, prevDeps) {
  if (null === prevDeps) return !1;
  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
    if (!objectIs(nextDeps[i], prevDeps[i])) return !1;
  return !0;
}
function renderWithHooks(
  current,
  workInProgress,
  Component,
  props,
  secondArg,
  nextRenderLanes
) {
  renderLanes = nextRenderLanes;
  currentlyRenderingFiber = workInProgress;
  workInProgress.memoizedState = null;
  workInProgress.updateQueue = null;
  workInProgress.lanes = 0;
  ReactSharedInternals.H =
    null === current || null === current.memoizedState
      ? HooksDispatcherOnMount
      : HooksDispatcherOnUpdate;
  shouldDoubleInvokeUserFnsInHooksDEV = !1;
  nextRenderLanes = Component(props, secondArg);
  shouldDoubleInvokeUserFnsInHooksDEV = !1;
  didScheduleRenderPhaseUpdateDuringThisPass &&
    (nextRenderLanes = renderWithHooksAgain(
      workInProgress,
      Component,
      props,
      secondArg
    ));
  finishRenderingHooks(current);
  return nextRenderLanes;
}
function finishRenderingHooks(current) {
  ReactSharedInternals.H = ContextOnlyDispatcher;
  var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
  renderLanes = 0;
  workInProgressHook = currentHook = currentlyRenderingFiber = null;
  didScheduleRenderPhaseUpdate = !1;
  thenableIndexCounter = 0;
  thenableState = null;
  if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
  null === current ||
    didReceiveUpdate ||
    ((current = current.dependencies),
    null !== current &&
      checkIfContextChanged(current) &&
      (didReceiveUpdate = !0));
}
function renderWithHooksAgain(workInProgress, Component, props, secondArg) {
  currentlyRenderingFiber = workInProgress;
  var numberOfReRenders = 0;
  do {
    didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
    thenableIndexCounter = 0;
    didScheduleRenderPhaseUpdateDuringThisPass = !1;
    if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
    numberOfReRenders += 1;
    workInProgressHook = currentHook = null;
    if (null != workInProgress.updateQueue) {
      var children = workInProgress.updateQueue;
      children.lastEffect = null;
      children.events = null;
      children.stores = null;
      null != children.memoCache && (children.memoCache.index = 0);
    }
    ReactSharedInternals.H = HooksDispatcherOnRerender;
    children = Component(props, secondArg);
  } while (didScheduleRenderPhaseUpdateDuringThisPass);
  return children;
}
function TransitionAwareHostComponent() {
  var dispatcher = ReactSharedInternals.H,
    maybeThenable = dispatcher.useState()[0];
  maybeThenable =
    "function" === typeof maybeThenable.then
      ? useThenable(maybeThenable)
      : maybeThenable;
  dispatcher = dispatcher.useState()[0];
  (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher &&
    (currentlyRenderingFiber.flags |= 1024);
  return maybeThenable;
}
function checkDidRenderIdHook() {
  var didRenderIdHook = 0 !== localIdCounter;
  localIdCounter = 0;
  return didRenderIdHook;
}
function bailoutHooks(current, workInProgress, lanes) {
  workInProgress.updateQueue = current.updateQueue;
  workInProgress.flags &= -2053;
  current.lanes &= ~lanes;
}
function resetHooksOnUnwind(workInProgress) {
  if (didScheduleRenderPhaseUpdate) {
    for (
      workInProgress = workInProgress.memoizedState;
      null !== workInProgress;

    ) {
      var queue = workInProgress.queue;
      null !== queue && (queue.pending = null);
      workInProgress = workInProgress.next;
    }
    didScheduleRenderPhaseUpdate = !1;
  }
  renderLanes = 0;
  workInProgressHook = currentHook = currentlyRenderingFiber = null;
  didScheduleRenderPhaseUpdateDuringThisPass = !1;
  thenableIndexCounter = localIdCounter = 0;
  thenableState = null;
}
function mountWorkInProgressHook() {
  var hook = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null
  };
  null === workInProgressHook
    ? (currentlyRenderingFiber.memoizedState = workInProgressHook = hook)
    : (workInProgressHook = workInProgressHook.next = hook);
  return workInProgressHook;
}
function updateWorkInProgressHook() {
  if (null === currentHook) {
    var nextCurrentHook = currentlyRenderingFiber.alternate;
    nextCurrentHook =
      null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
  } else nextCurrentHook = currentHook.next;
  var nextWorkInProgressHook =
    null === workInProgressHook
      ? currentlyRenderingFiber.memoizedState
      : workInProgressHook.next;
  if (null !== nextWorkInProgressHook)
    (workInProgressHook = nextWorkInProgressHook),
      (currentHook = nextCurrentHook);
  else {
    if (null === nextCurrentHook) {
      if (null === currentlyRenderingFiber.alternate)
        throw Error(formatProdErrorMessage(467));
      throw Error(formatProdErrorMessage(310));
    }
    currentHook = nextCurrentHook;
    nextCurrentHook = {
      memoizedState: currentHook.memoizedState,
      baseState: currentHook.baseState,
      baseQueue: currentHook.baseQueue,
      queue: currentHook.queue,
      next: null
    };
    null === workInProgressHook
      ? (currentlyRenderingFiber.memoizedState = workInProgressHook =
          nextCurrentHook)
      : (workInProgressHook = workInProgressHook.next = nextCurrentHook);
  }
  return workInProgressHook;
}
function createFunctionComponentUpdateQueue() {
  return { lastEffect: null, events: null, stores: null, memoCache: null };
}
function useThenable(thenable) {
  var index = thenableIndexCounter;
  thenableIndexCounter += 1;
  null === thenableState && (thenableState = []);
  thenable = trackUsedThenable(thenableState, thenable, index);
  index = currentlyRenderingFiber;
  null ===
    (null === workInProgressHook
      ? index.memoizedState
      : workInProgressHook.next) &&
    ((index = index.alternate),
    (ReactSharedInternals.H =
      null === index || null === index.memoizedState
        ? HooksDispatcherOnMount
        : HooksDispatcherOnUpdate));
  return thenable;
}
function use(usable) {
  if (null !== usable && "object" === typeof usable) {
    if ("function" === typeof usable.then) return useThenable(usable);
    if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
  }
  throw Error(formatProdErrorMessage(438, String(usable)));
}
function useMemoCache(size) {
  var memoCache = null,
    updateQueue = currentlyRenderingFiber.updateQueue;
  null !== updateQueue && (memoCache = updateQueue.memoCache);
  if (null == memoCache) {
    var current = currentlyRenderingFiber.alternate;
    null !== current &&
      ((current = current.updateQueue),
      null !== current &&
        ((current = current.memoCache),
        null != current &&
          (memoCache = {
            data: current.data.map(function (array) {
              return array.slice();
            }),
            index: 0
          })));
  }
  null == memoCache && (memoCache = { data: [], index: 0 });
  null === updateQueue &&
    ((updateQueue = createFunctionComponentUpdateQueue()),
    (currentlyRenderingFiber.updateQueue = updateQueue));
  updateQueue.memoCache = memoCache;
  updateQueue = memoCache.data[memoCache.index];
  if (void 0 === updateQueue)
    for (
      updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0;
      current < size;
      current++
    )
      updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
  memoCache.index++;
  return updateQueue;
}
function basicStateReducer(state, action) {
  return "function" === typeof action ? action(state) : action;
}
function updateReducer(reducer) {
  var hook = updateWorkInProgressHook();
  return updateReducerImpl(hook, currentHook, reducer);
}
function updateReducerImpl(hook, current, reducer) {
  var queue = hook.queue;
  if (null === queue) throw Error(formatProdErrorMessage(311));
  queue.lastRenderedReducer = reducer;
  var baseQueue = hook.baseQueue,
    pendingQueue = queue.pending;
  if (null !== pendingQueue) {
    if (null !== baseQueue) {
      var baseFirst = baseQueue.next;
      baseQueue.next = pendingQueue.next;
      pendingQueue.next = baseFirst;
    }
    current.baseQueue = baseQueue = pendingQueue;
    queue.pending = null;
  }
  pendingQueue = hook.baseState;
  if (null === baseQueue) hook.memoizedState = pendingQueue;
  else {
    current = baseQueue.next;
    var newBaseQueueFirst = (baseFirst = null),
      newBaseQueueLast = null,
      update = current,
      didReadFromEntangledAsyncAction$60 = !1;
    do {
      var updateLane = update.lane & -536870913;
      if (
        updateLane !== update.lane
          ? (workInProgressRootRenderLanes & updateLane) === updateLane
          : (renderLanes & updateLane) === updateLane
      ) {
        var revertLane = update.revertLane;
        if (0 === revertLane)
          null !== newBaseQueueLast &&
            (newBaseQueueLast = newBaseQueueLast.next =
              {
                lane: 0,
                revertLane: 0,
                gesture: null,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }),
            updateLane === currentEntangledLane &&
              (didReadFromEntangledAsyncAction$60 = !0);
        else if ((renderLanes & revertLane) === revertLane) {
          update = update.next;
          revertLane === currentEntangledLane &&
            (didReadFromEntangledAsyncAction$60 = !0);
          continue;
        } else
          (updateLane = {
            lane: 0,
            revertLane: update.revertLane,
            gesture: null,
            action: update.action,
            hasEagerState: update.hasEagerState,
            eagerState: update.eagerState,
            next: null
          }),
            null === newBaseQueueLast
              ? ((newBaseQueueFirst = newBaseQueueLast = updateLane),
                (baseFirst = pendingQueue))
              : (newBaseQueueLast = newBaseQueueLast.next = updateLane),
            (currentlyRenderingFiber.lanes |= revertLane),
            (workInProgressRootSkippedLanes |= revertLane);
        updateLane = update.action;
        shouldDoubleInvokeUserFnsInHooksDEV &&
          reducer(pendingQueue, updateLane);
        pendingQueue = update.hasEagerState
          ? update.eagerState
          : reducer(pendingQueue, updateLane);
      } else
        (revertLane = {
          lane: updateLane,
          revertLane: update.revertLane,
          gesture: update.gesture,
          action: update.action,
          hasEagerState: update.hasEagerState,
          eagerState: update.eagerState,
          next: null
        }),
          null === newBaseQueueLast
            ? ((newBaseQueueFirst = newBaseQueueLast = revertLane),
              (baseFirst = pendingQueue))
            : (newBaseQueueLast = newBaseQueueLast.next = revertLane),
          (currentlyRenderingFiber.lanes |= updateLane),
          (workInProgressRootSkippedLanes |= updateLane);
      update = update.next;
    } while (null !== update && update !== current);
    null === newBaseQueueLast
      ? (baseFirst = pendingQueue)
      : (newBaseQueueLast.next = newBaseQueueFirst);
    if (
      !objectIs(pendingQueue, hook.memoizedState) &&
      ((didReceiveUpdate = !0),
      didReadFromEntangledAsyncAction$60 &&
        ((reducer = currentEntangledActionThenable), null !== reducer))
    )
      throw reducer;
    hook.memoizedState = pendingQueue;
    hook.baseState = baseFirst;
    hook.baseQueue = newBaseQueueLast;
    queue.lastRenderedState = pendingQueue;
  }
  null === baseQueue && (queue.lanes = 0);
  return [hook.memoizedState, queue.dispatch];
}
function rerenderReducer(reducer) {
  var hook = updateWorkInProgressHook(),
    queue = hook.queue;
  if (null === queue) throw Error(formatProdErrorMessage(311));
  queue.lastRenderedReducer = reducer;
  var dispatch = queue.dispatch,
    lastRenderPhaseUpdate = queue.pending,
    newState = hook.memoizedState;
  if (null !== lastRenderPhaseUpdate) {
    queue.pending = null;
    var update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);
    do (newState = reducer(newState, update.action)), (update = update.next);
    while (update !== lastRenderPhaseUpdate);
    objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);
    hook.memoizedState = newState;
    null === hook.baseQueue && (hook.baseState = newState);
    queue.lastRenderedState = newState;
  }
  return [newState, dispatch];
}
function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
  var fiber = currentlyRenderingFiber,
    hook = updateWorkInProgressHook(),
    isHydrating$jscomp$0 = isHydrating;
  if (isHydrating$jscomp$0) {
    if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
    getServerSnapshot = getServerSnapshot();
  } else getServerSnapshot = getSnapshot();
  var snapshotChanged = !objectIs(
    (currentHook || hook).memoizedState,
    getServerSnapshot
  );
  snapshotChanged &&
    ((hook.memoizedState = getServerSnapshot), (didReceiveUpdate = !0));
  hook = hook.queue;
  updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe), [
    subscribe
  ]);
  if (
    hook.getSnapshot !== getSnapshot ||
    snapshotChanged ||
    (null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1)
  ) {
    fiber.flags |= 2048;
    pushSimpleEffect(
      9,
      { destroy: void 0 },
      updateStoreInstance.bind(
        null,
        fiber,
        hook,
        getServerSnapshot,
        getSnapshot
      ),
      null
    );
    if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
    isHydrating$jscomp$0 ||
      0 !== (renderLanes & 127) ||
      pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
  }
  return getServerSnapshot;
}
function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
  fiber.flags |= 16384;
  fiber = { getSnapshot: getSnapshot, value: renderedSnapshot };
  getSnapshot = currentlyRenderingFiber.updateQueue;
  null === getSnapshot
    ? ((getSnapshot = createFunctionComponentUpdateQueue()),
      (currentlyRenderingFiber.updateQueue = getSnapshot),
      (getSnapshot.stores = [fiber]))
    : ((renderedSnapshot = getSnapshot.stores),
      null === renderedSnapshot
        ? (getSnapshot.stores = [fiber])
        : renderedSnapshot.push(fiber));
}
function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
  inst.value = nextSnapshot;
  inst.getSnapshot = getSnapshot;
  checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
}
function subscribeToStore(fiber, inst, subscribe) {
  return subscribe(function () {
    checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
  });
}
function checkIfSnapshotChanged(inst) {
  var latestGetSnapshot = inst.getSnapshot;
  inst = inst.value;
  try {
    var nextValue = latestGetSnapshot();
    return !objectIs(inst, nextValue);
  } catch (error) {
    return !0;
  }
}
function forceStoreRerender(fiber) {
  var root = enqueueConcurrentRenderForLane(fiber, 2);
  null !== root && scheduleUpdateOnFiber(root, fiber, 2);
}
function mountStateImpl(initialState) {
  var hook = mountWorkInProgressHook();
  if ("function" === typeof initialState) {
    var initialStateInitializer = initialState;
    initialState = initialStateInitializer();
    if (shouldDoubleInvokeUserFnsInHooksDEV) {
      setIsStrictModeForDevtools(!0);
      try {
        initialStateInitializer();
      } finally {
        setIsStrictModeForDevtools(!1);
      }
    }
  }
  hook.memoizedState = hook.baseState = initialState;
  hook.queue = {
    pending: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState
  };
  return hook;
}
function updateOptimisticImpl(hook, current, passthrough, reducer) {
  hook.baseState = passthrough;
  return updateReducerImpl(
    hook,
    currentHook,
    "function" === typeof reducer ? reducer : basicStateReducer
  );
}
function dispatchActionState(
  fiber,
  actionQueue,
  setPendingState,
  setState,
  payload
) {
  if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
  fiber = actionQueue.action;
  if (null !== fiber) {
    var actionNode = {
      payload: payload,
      action: fiber,
      next: null,
      isTransition: !0,
      status: "pending",
      value: null,
      reason: null,
      listeners: [],
      then: function (listener) {
        actionNode.listeners.push(listener);
      }
    };
    null !== ReactSharedInternals.T
      ? setPendingState(!0)
      : (actionNode.isTransition = !1);
    setState(actionNode);
    setPendingState = actionQueue.pending;
    null === setPendingState
      ? ((actionNode.next = actionQueue.pending = actionNode),
        runActionStateAction(actionQueue, actionNode))
      : ((actionNode.next = setPendingState.next),
        (actionQueue.pending = setPendingState.next = actionNode));
  }
}
function runActionStateAction(actionQueue, node) {
  var action = node.action,
    payload = node.payload,
    prevState = actionQueue.state;
  if (node.isTransition) {
    var prevTransition = ReactSharedInternals.T,
      currentTransition = {};
    ReactSharedInternals.T = currentTransition;
    try {
      var returnValue = action(prevState, payload),
        onStartTransitionFinish = ReactSharedInternals.S;
      null !== onStartTransitionFinish &&
        onStartTransitionFinish(currentTransition, returnValue);
      handleActionReturnValue(actionQueue, node, returnValue);
    } catch (error) {
      onActionError(actionQueue, node, error);
    } finally {
      null !== prevTransition &&
        null !== currentTransition.types &&
        (prevTransition.types = currentTransition.types),
        (ReactSharedInternals.T = prevTransition);
    }
  } else
    try {
      (prevTransition = action(prevState, payload)),
        handleActionReturnValue(actionQueue, node, prevTransition);
    } catch (error$66) {
      onActionError(actionQueue, node, error$66);
    }
}
function handleActionReturnValue(actionQueue, node, returnValue) {
  null !== returnValue &&
  "object" === typeof returnValue &&
  "function" === typeof returnValue.then
    ? returnValue.then(
        function (nextState) {
          onActionSuccess(actionQueue, node, nextState);
        },
        function (error) {
          return onActionError(actionQueue, node, error);
        }
      )
    : onActionSuccess(actionQueue, node, returnValue);
}
function onActionSuccess(actionQueue, actionNode, nextState) {
  actionNode.status = "fulfilled";
  actionNode.value = nextState;
  notifyActionListeners(actionNode);
  actionQueue.state = nextState;
  actionNode = actionQueue.pending;
  null !== actionNode &&
    ((nextState = actionNode.next),
    nextState === actionNode
      ? (actionQueue.pending = null)
      : ((nextState = nextState.next),
        (actionNode.next = nextState),
        runActionStateAction(actionQueue, nextState)));
}
function onActionError(actionQueue, actionNode, error) {
  var last = actionQueue.pending;
  actionQueue.pending = null;
  if (null !== last) {
    last = last.next;
    do
      (actionNode.status = "rejected"),
        (actionNode.reason = error),
        notifyActionListeners(actionNode),
        (actionNode = actionNode.next);
    while (actionNode !== last);
  }
  actionQueue.action = null;
}
function notifyActionListeners(actionNode) {
  actionNode = actionNode.listeners;
  for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
}
function actionStateReducer(oldState, newState) {
  return newState;
}
function mountActionState(action, initialStateProp) {
  if (isHydrating) {
    var ssrFormState = workInProgressRoot.formState;
    if (null !== ssrFormState) {
      a: {
        var JSCompiler_inline_result = currentlyRenderingFiber;
        if (isHydrating) {
          if (nextHydratableInstance) {
            b: {
              var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
              for (
                var inRootOrSingleton = rootOrSingletonContext;
                8 !== JSCompiler_inline_result$jscomp$0.nodeType;

              ) {
                if (!inRootOrSingleton) {
                  JSCompiler_inline_result$jscomp$0 = null;
                  break b;
                }
                JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                  JSCompiler_inline_result$jscomp$0.nextSibling
                );
                if (null === JSCompiler_inline_result$jscomp$0) {
                  JSCompiler_inline_result$jscomp$0 = null;
                  break b;
                }
              }
              inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
              JSCompiler_inline_result$jscomp$0 =
                "F!" === inRootOrSingleton || "F" === inRootOrSingleton
                  ? JSCompiler_inline_result$jscomp$0
                  : null;
            }
            if (JSCompiler_inline_result$jscomp$0) {
              nextHydratableInstance = getNextHydratable(
                JSCompiler_inline_result$jscomp$0.nextSibling
              );
              JSCompiler_inline_result =
                "F!" === JSCompiler_inline_result$jscomp$0.data;
              break a;
            }
          }
          throwOnHydrationMismatch(JSCompiler_inline_result);
        }
        JSCompiler_inline_result = !1;
      }
      JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
    }
  }
  ssrFormState = mountWorkInProgressHook();
  ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
  JSCompiler_inline_result = {
    pending: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: actionStateReducer,
    lastRenderedState: initialStateProp
  };
  ssrFormState.queue = JSCompiler_inline_result;
  ssrFormState = dispatchSetState.bind(
    null,
    currentlyRenderingFiber,
    JSCompiler_inline_result
  );
  JSCompiler_inline_result.dispatch = ssrFormState;
  JSCompiler_inline_result = mountStateImpl(!1);
  inRootOrSingleton = dispatchOptimisticSetState.bind(
    null,
    currentlyRenderingFiber,
    !1,
    JSCompiler_inline_result.queue
  );
  JSCompiler_inline_result = mountWorkInProgressHook();
  JSCompiler_inline_result$jscomp$0 = {
    state: initialStateProp,
    dispatch: null,
    action: action,
    pending: null
  };
  JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
  ssrFormState = dispatchActionState.bind(
    null,
    currentlyRenderingFiber,
    JSCompiler_inline_result$jscomp$0,
    inRootOrSingleton,
    ssrFormState
  );
  JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
  JSCompiler_inline_result.memoizedState = action;
  return [initialStateProp, ssrFormState, !1];
}
function updateActionState(action) {
  var stateHook = updateWorkInProgressHook();
  return updateActionStateImpl(stateHook, currentHook, action);
}
function updateActionStateImpl(stateHook, currentStateHook, action) {
  currentStateHook = updateReducerImpl(
    stateHook,
    currentStateHook,
    actionStateReducer
  )[0];
  stateHook = updateReducer(basicStateReducer)[0];
  if (
    "object" === typeof currentStateHook &&
    null !== currentStateHook &&
    "function" === typeof currentStateHook.then
  )
    try {
      var state = useThenable(currentStateHook);
    } catch (x) {
      if (x === SuspenseException) throw SuspenseActionException;
      throw x;
    }
  else state = currentStateHook;
  currentStateHook = updateWorkInProgressHook();
  var actionQueue = currentStateHook.queue,
    dispatch = actionQueue.dispatch;
  action !== currentStateHook.memoizedState &&
    ((currentlyRenderingFiber.flags |= 2048),
    pushSimpleEffect(
      9,
      { destroy: void 0 },
      actionStateActionEffect.bind(null, actionQueue, action),
      null
    ));
  return [state, dispatch, stateHook];
}
function actionStateActionEffect(actionQueue, action) {
  actionQueue.action = action;
}
function rerenderActionState(action) {
  var stateHook = updateWorkInProgressHook(),
    currentStateHook = currentHook;
  if (null !== currentStateHook)
    return updateActionStateImpl(stateHook, currentStateHook, action);
  updateWorkInProgressHook();
  stateHook = stateHook.memoizedState;
  currentStateHook = updateWorkInProgressHook();
  var dispatch = currentStateHook.queue.dispatch;
  currentStateHook.memoizedState = action;
  return [stateHook, dispatch, !1];
}
function pushSimpleEffect(tag, inst, create, deps) {
  tag = { tag: tag, create: create, deps: deps, inst: inst, next: null };
  inst = currentlyRenderingFiber.updateQueue;
  null === inst &&
    ((inst = createFunctionComponentUpdateQueue()),
    (currentlyRenderingFiber.updateQueue = inst));
  create = inst.lastEffect;
  null === create
    ? (inst.lastEffect = tag.next = tag)
    : ((deps = create.next),
      (create.next = tag),
      (tag.next = deps),
      (inst.lastEffect = tag));
  return tag;
}
function updateRef() {
  return updateWorkInProgressHook().memoizedState;
}
function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  var hook = mountWorkInProgressHook();
  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushSimpleEffect(
    1 | hookFlags,
    { destroy: void 0 },
    create,
    void 0 === deps ? null : deps
  );
}
function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  var hook = updateWorkInProgressHook();
  deps = void 0 === deps ? null : deps;
  var inst = hook.memoizedState.inst;
  null !== currentHook &&
  null !== deps &&
  areHookInputsEqual(deps, currentHook.memoizedState.deps)
    ? (hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps))
    : ((currentlyRenderingFiber.flags |= fiberFlags),
      (hook.memoizedState = pushSimpleEffect(
        1 | hookFlags,
        inst,
        create,
        deps
      )));
}
function mountEffect(create, deps) {
  mountEffectImpl(8390656, 8, create, deps);
}
function updateEffect(create, deps) {
  updateEffectImpl(2048, 8, create, deps);
}
function useEffectEventImpl(payload) {
  currentlyRenderingFiber.flags |= 4;
  var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
  if (null === componentUpdateQueue)
    (componentUpdateQueue = createFunctionComponentUpdateQueue()),
      (currentlyRenderingFiber.updateQueue = componentUpdateQueue),
      (componentUpdateQueue.events = [payload]);
  else {
    var events = componentUpdateQueue.events;
    null === events
      ? (componentUpdateQueue.events = [payload])
      : events.push(payload);
  }
}
function updateEvent(callback) {
  var ref = updateWorkInProgressHook().memoizedState;
  useEffectEventImpl({ ref: ref, nextImpl: callback });
  return function () {
    if (0 !== (executionContext & 2)) throw Error(formatProdErrorMessage(440));
    return ref.impl.apply(void 0, arguments);
  };
}
function updateInsertionEffect(create, deps) {
  return updateEffectImpl(4, 2, create, deps);
}
function updateLayoutEffect(create, deps) {
  return updateEffectImpl(4, 4, create, deps);
}
function imperativeHandleEffect(create, ref) {
  if ("function" === typeof ref) {
    create = create();
    var refCleanup = ref(create);
    return function () {
      "function" === typeof refCleanup ? refCleanup() : ref(null);
    };
  }
  if (null !== ref && void 0 !== ref)
    return (
      (create = create()),
      (ref.current = create),
      function () {
        ref.current = null;
      }
    );
}
function updateImperativeHandle(ref, create, deps) {
  deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
  updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
}
function mountDebugValue() {}
function updateCallback(callback, deps) {
  var hook = updateWorkInProgressHook();
  deps = void 0 === deps ? null : deps;
  var prevState = hook.memoizedState;
  if (null !== deps && areHookInputsEqual(deps, prevState[1]))
    return prevState[0];
  hook.memoizedState = [callback, deps];
  return callback;
}
function updateMemo(nextCreate, deps) {
  var hook = updateWorkInProgressHook();
  deps = void 0 === deps ? null : deps;
  var prevState = hook.memoizedState;
  if (null !== deps && areHookInputsEqual(deps, prevState[1]))
    return prevState[0];
  prevState = nextCreate();
  if (shouldDoubleInvokeUserFnsInHooksDEV) {
    setIsStrictModeForDevtools(!0);
    try {
      nextCreate();
    } finally {
      setIsStrictModeForDevtools(!1);
    }
  }
  hook.memoizedState = [prevState, deps];
  return prevState;
}
function mountDeferredValueImpl(hook, value, initialValue) {
  if (
    void 0 === initialValue ||
    (0 !== (renderLanes & 1073741824) &&
      0 === (workInProgressRootRenderLanes & 261930))
  )
    return (hook.memoizedState = value);
  hook.memoizedState = initialValue;
  hook = requestDeferredLane();
  currentlyRenderingFiber.lanes |= hook;
  workInProgressRootSkippedLanes |= hook;
  return initialValue;
}
function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
  if (objectIs(value, prevValue)) return value;
  if (null !== currentTreeHiddenStackCursor.current)
    return (
      (hook = mountDeferredValueImpl(hook, value, initialValue)),
      objectIs(hook, prevValue) || (didReceiveUpdate = !0),
      hook
    );
  if (
    0 === (renderLanes & 42) ||
    (0 !== (renderLanes & 1073741824) &&
      0 === (workInProgressRootRenderLanes & 261930))
  )
    return (didReceiveUpdate = !0), (hook.memoizedState = value);
  hook = requestDeferredLane();
  currentlyRenderingFiber.lanes |= hook;
  workInProgressRootSkippedLanes |= hook;
  return prevValue;
}
function startTransition(fiber, queue, pendingState, finishedState, callback) {
  var previousPriority = ReactDOMSharedInternals.p;
  ReactDOMSharedInternals.p =
    0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
  var prevTransition = ReactSharedInternals.T,
    currentTransition = {};
  ReactSharedInternals.T = currentTransition;
  dispatchOptimisticSetState(fiber, !1, queue, pendingState);
  try {
    var returnValue = callback(),
      onStartTransitionFinish = ReactSharedInternals.S;
    null !== onStartTransitionFinish &&
      onStartTransitionFinish(currentTransition, returnValue);
    if (
      null !== returnValue &&
      "object" === typeof returnValue &&
      "function" === typeof returnValue.then
    ) {
      var thenableForFinishedState = chainThenableValue(
        returnValue,
        finishedState
      );
      dispatchSetStateInternal(
        fiber,
        queue,
        thenableForFinishedState,
        requestUpdateLane(fiber)
      );
    } else
      dispatchSetStateInternal(
        fiber,
        queue,
        finishedState,
        requestUpdateLane(fiber)
      );
  } catch (error) {
    dispatchSetStateInternal(
      fiber,
      queue,
      { then: function () {}, status: "rejected", reason: error },
      requestUpdateLane()
    );
  } finally {
    (ReactDOMSharedInternals.p = previousPriority),
      null !== prevTransition &&
        null !== currentTransition.types &&
        (prevTransition.types = currentTransition.types),
      (ReactSharedInternals.T = prevTransition);
  }
}
function noop() {}
function startHostTransition(formFiber, pendingState, action, formData) {
  if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
  var queue = ensureFormComponentIsStateful(formFiber).queue;
  startTransition(
    formFiber,
    queue,
    pendingState,
    sharedNotPendingObject,
    null === action
      ? noop
      : function () {
          requestFormReset$1(formFiber);
          return action(formData);
        }
  );
}
function ensureFormComponentIsStateful(formFiber) {
  var existingStateHook = formFiber.memoizedState;
  if (null !== existingStateHook) return existingStateHook;
  existingStateHook = {
    memoizedState: sharedNotPendingObject,
    baseState: sharedNotPendingObject,
    baseQueue: null,
    queue: {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: sharedNotPendingObject
    },
    next: null
  };
  var initialResetState = {};
  existingStateHook.next = {
    memoizedState: initialResetState,
    baseState: initialResetState,
    baseQueue: null,
    queue: {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: initialResetState
    },
    next: null
  };
  formFiber.memoizedState = existingStateHook;
  formFiber = formFiber.alternate;
  null !== formFiber && (formFiber.memoizedState = existingStateHook);
  return existingStateHook;
}
function requestFormReset$1(formFiber) {
  var stateHook = ensureFormComponentIsStateful(formFiber);
  null === stateHook.next && (stateHook = formFiber.alternate.memoizedState);
  dispatchSetStateInternal(
    formFiber,
    stateHook.next.queue,
    {},
    requestUpdateLane()
  );
}
function useHostTransitionStatus() {
  return readContext(HostTransitionContext);
}
function updateId() {
  return updateWorkInProgressHook().memoizedState;
}
function updateRefresh() {
  return updateWorkInProgressHook().memoizedState;
}
function refreshCache(fiber) {
  for (var provider = fiber.return; null !== provider; ) {
    switch (provider.tag) {
      case 24:
      case 3:
        var lane = requestUpdateLane();
        fiber = createUpdate(lane);
        var root$69 = enqueueUpdate(provider, fiber, lane);
        null !== root$69 &&
          (scheduleUpdateOnFiber(root$69, provider, lane),
          entangleTransitions(root$69, provider, lane));
        provider = { cache: createCache() };
        fiber.payload = provider;
        return;
    }
    provider = provider.return;
  }
}
function dispatchReducerAction(fiber, queue, action) {
  var lane = requestUpdateLane();
  action = {
    lane: lane,
    revertLane: 0,
    gesture: null,
    action: action,
    hasEagerState: !1,
    eagerState: null,
    next: null
  };
  isRenderPhaseUpdate(fiber)
    ? enqueueRenderPhaseUpdate(queue, action)
    : ((action = enqueueConcurrentHookUpdate(fiber, queue, action, lane)),
      null !== action &&
        (scheduleUpdateOnFiber(action, fiber, lane),
        entangleTransitionUpdate(action, queue, lane)));
}
function dispatchSetState(fiber, queue, action) {
  var lane = requestUpdateLane();
  dispatchSetStateInternal(fiber, queue, action, lane);
}
function dispatchSetStateInternal(fiber, queue, action, lane) {
  var update = {
    lane: lane,
    revertLane: 0,
    gesture: null,
    action: action,
    hasEagerState: !1,
    eagerState: null,
    next: null
  };
  if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
  else {
    var alternate = fiber.alternate;
    if (
      0 === fiber.lanes &&
      (null === alternate || 0 === alternate.lanes) &&
      ((alternate = queue.lastRenderedReducer), null !== alternate)
    )
      try {
        var currentState = queue.lastRenderedState,
          eagerState = alternate(currentState, action);
        update.hasEagerState = !0;
        update.eagerState = eagerState;
        if (objectIs(eagerState, currentState))
          return (
            enqueueUpdate$1(fiber, queue, update, 0),
            null === workInProgressRoot && finishQueueingConcurrentUpdates(),
            !1
          );
      } catch (error) {
      } finally {
      }
    action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
    if (null !== action)
      return (
        scheduleUpdateOnFiber(action, fiber, lane),
        entangleTransitionUpdate(action, queue, lane),
        !0
      );
  }
  return !1;
}
function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
  action = {
    lane: 2,
    revertLane: requestTransitionLane(),
    gesture: null,
    action: action,
    hasEagerState: !1,
    eagerState: null,
    next: null
  };
  if (isRenderPhaseUpdate(fiber)) {
    if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
  } else
    (throwIfDuringRender = enqueueConcurrentHookUpdate(
      fiber,
      queue,
      action,
      2
    )),
      null !== throwIfDuringRender &&
        scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
}
function isRenderPhaseUpdate(fiber) {
  var alternate = fiber.alternate;
  return (
    fiber === currentlyRenderingFiber ||
    (null !== alternate && alternate === currentlyRenderingFiber)
  );
}
function enqueueRenderPhaseUpdate(queue, update) {
  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate =
    !0;
  var pending = queue.pending;
  null === pending
    ? (update.next = update)
    : ((update.next = pending.next), (pending.next = update));
  queue.pending = update;
}
function entangleTransitionUpdate(root, queue, lane) {
  if (0 !== (lane & 4194048)) {
    var queueLanes = queue.lanes;
    queueLanes &= root.pendingLanes;
    lane |= queueLanes;
    queue.lanes = lane;
    markRootEntangled(root, lane);
  }
}
var ContextOnlyDispatcher = {
  readContext: readContext,
  use: use,
  useCallback: throwInvalidHookError,
  useContext: throwInvalidHookError,
  useEffect: throwInvalidHookError,
  useImperativeHandle: throwInvalidHookError,
  useLayoutEffect: throwInvalidHookError,
  useInsertionEffect: throwInvalidHookError,
  useMemo: throwInvalidHookError,
  useReducer: throwInvalidHookError,
  useRef: throwInvalidHookError,
  useState: throwInvalidHookError,
  useDebugValue: throwInvalidHookError,
  useDeferredValue: throwInvalidHookError,
  useTransition: throwInvalidHookError,
  useSyncExternalStore: throwInvalidHookError,
  useId: throwInvalidHookError,
  useHostTransitionStatus: throwInvalidHookError,
  useFormState: throwInvalidHookError,
  useActionState: throwInvalidHookError,
  useOptimistic: throwInvalidHookError,
  useMemoCache: throwInvalidHookError,
  useCacheRefresh: throwInvalidHookError
};
ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
var HooksDispatcherOnMount = {
    readContext: readContext,
    use: use,
    useCallback: function (callback, deps) {
      mountWorkInProgressHook().memoizedState = [
        callback,
        void 0 === deps ? null : deps
      ];
      return callback;
    },
    useContext: readContext,
    useEffect: mountEffect,
    useImperativeHandle: function (ref, create, deps) {
      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
      mountEffectImpl(
        4194308,
        4,
        imperativeHandleEffect.bind(null, create, ref),
        deps
      );
    },
    useLayoutEffect: function (create, deps) {
      return mountEffectImpl(4194308, 4, create, deps);
    },
    useInsertionEffect: function (create, deps) {
      mountEffectImpl(4, 2, create, deps);
    },
    useMemo: function (nextCreate, deps) {
      var hook = mountWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var nextValue = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(!0);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
      hook.memoizedState = [nextValue, deps];
      return nextValue;
    },
    useReducer: function (reducer, initialArg, init) {
      var hook = mountWorkInProgressHook();
      if (void 0 !== init) {
        var initialState = init(initialArg);
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(!0);
          try {
            init(initialArg);
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
      } else initialState = initialArg;
      hook.memoizedState = hook.baseState = initialState;
      reducer = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: reducer,
        lastRenderedState: initialState
      };
      hook.queue = reducer;
      reducer = reducer.dispatch = dispatchReducerAction.bind(
        null,
        currentlyRenderingFiber,
        reducer
      );
      return [hook.memoizedState, reducer];
    },
    useRef: function (initialValue) {
      var hook = mountWorkInProgressHook();
      initialValue = { current: initialValue };
      return (hook.memoizedState = initialValue);
    },
    useState: function (initialState) {
      initialState = mountStateImpl(initialState);
      var queue = initialState.queue,
        dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
      queue.dispatch = dispatch;
      return [initialState.memoizedState, dispatch];
    },
    useDebugValue: mountDebugValue,
    useDeferredValue: function (value, initialValue) {
      var hook = mountWorkInProgressHook();
      return mountDeferredValueImpl(hook, value, initialValue);
    },
    useTransition: function () {
      var stateHook = mountStateImpl(!1);
      stateHook = startTransition.bind(
        null,
        currentlyRenderingFiber,
        stateHook.queue,
        !0,
        !1
      );
      mountWorkInProgressHook().memoizedState = stateHook;
      return [!1, stateHook];
    },
    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber,
        hook = mountWorkInProgressHook();
      if (isHydrating) {
        if (void 0 === getServerSnapshot)
          throw Error(formatProdErrorMessage(407));
        getServerSnapshot = getServerSnapshot();
      } else {
        getServerSnapshot = getSnapshot();
        if (null === workInProgressRoot)
          throw Error(formatProdErrorMessage(349));
        0 !== (workInProgressRootRenderLanes & 127) ||
          pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
      }
      hook.memoizedState = getServerSnapshot;
      var inst = { value: getServerSnapshot, getSnapshot: getSnapshot };
      hook.queue = inst;
      mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
        subscribe
      ]);
      fiber.flags |= 2048;
      pushSimpleEffect(
        9,
        { destroy: void 0 },
        updateStoreInstance.bind(
          null,
          fiber,
          inst,
          getServerSnapshot,
          getSnapshot
        ),
        null
      );
      return getServerSnapshot;
    },
    useId: function () {
      var hook = mountWorkInProgressHook(),
        identifierPrefix = workInProgressRoot.identifierPrefix;
      if (isHydrating) {
        var JSCompiler_inline_result = treeContextOverflow;
        var idWithLeadingBit = treeContextId;
        JSCompiler_inline_result =
          (
            idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))
          ).toString(32) + JSCompiler_inline_result;
        identifierPrefix =
          "_" + identifierPrefix + "R_" + JSCompiler_inline_result;
        JSCompiler_inline_result = localIdCounter++;
        0 < JSCompiler_inline_result &&
          (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
        identifierPrefix += "_";
      } else
        (JSCompiler_inline_result = globalClientIdCounter++),
          (identifierPrefix =
            "_" +
            identifierPrefix +
            "r_" +
            JSCompiler_inline_result.toString(32) +
            "_");
      return (hook.memoizedState = identifierPrefix);
    },
    useHostTransitionStatus: useHostTransitionStatus,
    useFormState: mountActionState,
    useActionState: mountActionState,
    useOptimistic: function (passthrough) {
      var hook = mountWorkInProgressHook();
      hook.memoizedState = hook.baseState = passthrough;
      var queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      hook.queue = queue;
      hook = dispatchOptimisticSetState.bind(
        null,
        currentlyRenderingFiber,
        !0,
        queue
      );
      queue.dispatch = hook;
      return [passthrough, hook];
    },
    useMemoCache: useMemoCache,
    useCacheRefresh: function () {
      return (mountWorkInProgressHook().memoizedState = refreshCache.bind(
        null,
        currentlyRenderingFiber
      ));
    },
    useEffectEvent: function (callback) {
      var hook = mountWorkInProgressHook(),
        ref = { impl: callback };
      hook.memoizedState = ref;
      return function () {
        if (0 !== (executionContext & 2))
          throw Error(formatProdErrorMessage(440));
        return ref.impl.apply(void 0, arguments);
      };
    }
  },
  HooksDispatcherOnUpdate = {
    readContext: readContext,
    use: use,
    useCallback: updateCallback,
    useContext: readContext,
    useEffect: updateEffect,
    useImperativeHandle: updateImperativeHandle,
    useInsertionEffect: updateInsertionEffect,
    useLayoutEffect: updateLayoutEffect,
    useMemo: updateMemo,
    useReducer: updateReducer,
    useRef: updateRef,
    useState: function () {
      return updateReducer(basicStateReducer);
    },
    useDebugValue: mountDebugValue,
    useDeferredValue: function (value, initialValue) {
      var hook = updateWorkInProgressHook();
      return updateDeferredValueImpl(
        hook,
        currentHook.memoizedState,
        value,
        initialValue
      );
    },
    useTransition: function () {
      var booleanOrThenable = updateReducer(basicStateReducer)[0],
        start = updateWorkInProgressHook().memoizedState;
      return [
        "boolean" === typeof booleanOrThenable
          ? booleanOrThenable
          : useThenable(booleanOrThenable),
        start
      ];
    },
    useSyncExternalStore: updateSyncExternalStore,
    useId: updateId,
    useHostTransitionStatus: useHostTransitionStatus,
    useFormState: updateActionState,
    useActionState: updateActionState,
    useOptimistic: function (passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
    },
    useMemoCache: useMemoCache,
    useCacheRefresh: updateRefresh
  };
HooksDispatcherOnUpdate.useEffectEvent = updateEvent;
var HooksDispatcherOnRerender = {
  readContext: readContext,
  use: use,
  useCallback: updateCallback,
  useContext: readContext,
  useEffect: updateEffect,
  useImperativeHandle: updateImperativeHandle,
  useInsertionEffect: updateInsertionEffect,
  useLayoutEffect: updateLayoutEffect,
  useMemo: updateMemo,
  useReducer: rerenderReducer,
  useRef: updateRef,
  useState: function () {
    return rerenderReducer(basicStateReducer);
  },
  useDebugValue: mountDebugValue,
  useDeferredValue: function (value, initialValue) {
    var hook = updateWorkInProgressHook();
    return null === currentHook
      ? mountDeferredValueImpl(hook, value, initialValue)
      : updateDeferredValueImpl(
          hook,
          currentHook.memoizedState,
          value,
          initialValue
        );
  },
  useTransition: function () {
    var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
      start = updateWorkInProgressHook().memoizedState;
    return [
      "boolean" === typeof booleanOrThenable
        ? booleanOrThenable
        : useThenable(booleanOrThenable),
      start
    ];
  },
  useSyncExternalStore: updateSyncExternalStore,
  useId: updateId,
  useHostTransitionStatus: useHostTransitionStatus,
  useFormState: rerenderActionState,
  useActionState: rerenderActionState,
  useOptimistic: function (passthrough, reducer) {
    var hook = updateWorkInProgressHook();
    if (null !== currentHook)
      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
    hook.baseState = passthrough;
    return [passthrough, hook.queue.dispatch];
  },
  useMemoCache: useMemoCache,
  useCacheRefresh: updateRefresh
};
HooksDispatcherOnRerender.useEffectEvent = updateEvent;
function applyDerivedStateFromProps(
  workInProgress,
  ctor,
  getDerivedStateFromProps,
  nextProps
) {
  ctor = workInProgress.memoizedState;
  getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
  getDerivedStateFromProps =
    null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps
      ? ctor
      : assign({}, ctor, getDerivedStateFromProps);
  workInProgress.memoizedState = getDerivedStateFromProps;
  0 === workInProgress.lanes &&
    (workInProgress.updateQueue.baseState = getDerivedStateFromProps);
}
var classComponentUpdater = {
  enqueueSetState: function (inst, payload, callback) {
    inst = inst._reactInternals;
    var lane = requestUpdateLane(),
      update = createUpdate(lane);
    update.payload = payload;
    void 0 !== callback && null !== callback && (update.callback = callback);
    payload = enqueueUpdate(inst, update, lane);
    null !== payload &&
      (scheduleUpdateOnFiber(payload, inst, lane),
      entangleTransitions(payload, inst, lane));
  },
  enqueueReplaceState: function (inst, payload, callback) {
    inst = inst._reactInternals;
    var lane = requestUpdateLane(),
      update = createUpdate(lane);
    update.tag = 1;
    update.payload = payload;
    void 0 !== callback && null !== callback && (update.callback = callback);
    payload = enqueueUpdate(inst, update, lane);
    null !== payload &&
      (scheduleUpdateOnFiber(payload, inst, lane),
      entangleTransitions(payload, inst, lane));
  },
  enqueueForceUpdate: function (inst, callback) {
    inst = inst._reactInternals;
    var lane = requestUpdateLane(),
      update = createUpdate(lane);
    update.tag = 2;
    void 0 !== callback && null !== callback && (update.callback = callback);
    callback = enqueueUpdate(inst, update, lane);
    null !== callback &&
      (scheduleUpdateOnFiber(callback, inst, lane),
      entangleTransitions(callback, inst, lane));
  }
};
function checkShouldComponentUpdate(
  workInProgress,
  ctor,
  oldProps,
  newProps,
  oldState,
  newState,
  nextContext
) {
  workInProgress = workInProgress.stateNode;
  return "function" === typeof workInProgress.shouldComponentUpdate
    ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext)
    : ctor.prototype && ctor.prototype.isPureReactComponent
      ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
      : !0;
}
function callComponentWillReceiveProps(
  workInProgress,
  instance,
  newProps,
  nextContext
) {
  workInProgress = instance.state;
  "function" === typeof instance.componentWillReceiveProps &&
    instance.componentWillReceiveProps(newProps, nextContext);
  "function" === typeof instance.UNSAFE_componentWillReceiveProps &&
    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
  instance.state !== workInProgress &&
    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
}
function resolveClassComponentProps(Component, baseProps) {
  var newProps = baseProps;
  if ("ref" in baseProps) {
    newProps = {};
    for (var propName in baseProps)
      "ref" !== propName && (newProps[propName] = baseProps[propName]);
  }
  if ((Component = Component.defaultProps)) {
    newProps === baseProps && (newProps = assign({}, newProps));
    for (var propName$73 in Component)
      void 0 === newProps[propName$73] &&
        (newProps[propName$73] = Component[propName$73]);
  }
  return newProps;
}
function defaultOnUncaughtError(error) {
  reportGlobalError(error);
}
function defaultOnCaughtError(error) {
  console.error(error);
}
function defaultOnRecoverableError(error) {
  reportGlobalError(error);
}
function logUncaughtError(root, errorInfo) {
  try {
    var onUncaughtError = root.onUncaughtError;
    onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
  } catch (e$74) {
    setTimeout(function () {
      throw e$74;
    });
  }
}
function logCaughtError(root, boundary, errorInfo) {
  try {
    var onCaughtError = root.onCaughtError;
    onCaughtError(errorInfo.value, {
      componentStack: errorInfo.stack,
      errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
    });
  } catch (e$75) {
    setTimeout(function () {
      throw e$75;
    });
  }
}
function createRootErrorUpdate(root, errorInfo, lane) {
  lane = createUpdate(lane);
  lane.tag = 3;
  lane.payload = { element: null };
  lane.callback = function () {
    logUncaughtError(root, errorInfo);
  };
  return lane;
}
function createClassErrorUpdate(lane) {
  lane = createUpdate(lane);
  lane.tag = 3;
  return lane;
}
function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
  if ("function" === typeof getDerivedStateFromError) {
    var error = errorInfo.value;
    update.payload = function () {
      return getDerivedStateFromError(error);
    };
    update.callback = function () {
      logCaughtError(root, fiber, errorInfo);
    };
  }
  var inst = fiber.stateNode;
  null !== inst &&
    "function" === typeof inst.componentDidCatch &&
    (update.callback = function () {
      logCaughtError(root, fiber, errorInfo);
      "function" !== typeof getDerivedStateFromError &&
        (null === legacyErrorBoundariesThatAlreadyFailed
          ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))
          : legacyErrorBoundariesThatAlreadyFailed.add(this));
      var stack = errorInfo.stack;
      this.componentDidCatch(errorInfo.value, {
        componentStack: null !== stack ? stack : ""
      });
    });
}
function throwException(
  root,
  returnFiber,
  sourceFiber,
  value,
  rootRenderLanes
) {
  sourceFiber.flags |= 32768;
  if (
    null !== value &&
    "object" === typeof value &&
    "function" === typeof value.then
  ) {
    returnFiber = sourceFiber.alternate;
    null !== returnFiber &&
      propagateParentContextChanges(
        returnFiber,
        sourceFiber,
        rootRenderLanes,
        !0
      );
    sourceFiber = suspenseHandlerStackCursor.current;
    if (null !== sourceFiber) {
      switch (sourceFiber.tag) {
        case 31:
        case 13:
          return (
            null === shellBoundary
              ? renderDidSuspendDelayIfPossible()
              : null === sourceFiber.alternate &&
                0 === workInProgressRootExitStatus &&
                (workInProgressRootExitStatus = 3),
            (sourceFiber.flags &= -257),
            (sourceFiber.flags |= 65536),
            (sourceFiber.lanes = rootRenderLanes),
            value === noopSuspenseyCommitThenable
              ? (sourceFiber.flags |= 16384)
              : ((returnFiber = sourceFiber.updateQueue),
                null === returnFiber
                  ? (sourceFiber.updateQueue = new Set([value]))
                  : returnFiber.add(value),
                attachPingListener(root, value, rootRenderLanes)),
            !1
          );
        case 22:
          return (
            (sourceFiber.flags |= 65536),
            value === noopSuspenseyCommitThenable
              ? (sourceFiber.flags |= 16384)
              : ((returnFiber = sourceFiber.updateQueue),
                null === returnFiber
                  ? ((returnFiber = {
                      transitions: null,
                      markerInstances: null,
                      retryQueue: new Set([value])
                    }),
                    (sourceFiber.updateQueue = returnFiber))
                  : ((sourceFiber = returnFiber.retryQueue),
                    null === sourceFiber
                      ? (returnFiber.retryQueue = new Set([value]))
                      : sourceFiber.add(value)),
                attachPingListener(root, value, rootRenderLanes)),
            !1
          );
      }
      throw Error(formatProdErrorMessage(435, sourceFiber.tag));
    }
    attachPingListener(root, value, rootRenderLanes);
    renderDidSuspendDelayIfPossible();
    return !1;
  }
  if (isHydrating)
    return (
      (returnFiber = suspenseHandlerStackCursor.current),
      null !== returnFiber
        ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256),
          (returnFiber.flags |= 65536),
          (returnFiber.lanes = rootRenderLanes),
          value !== HydrationMismatchException &&
            ((root = Error(formatProdErrorMessage(422), { cause: value })),
            queueHydrationError(createCapturedValueAtFiber(root, sourceFiber))))
        : (value !== HydrationMismatchException &&
            ((returnFiber = Error(formatProdErrorMessage(423), {
              cause: value
            })),
            queueHydrationError(
              createCapturedValueAtFiber(returnFiber, sourceFiber)
            )),
          (root = root.current.alternate),
          (root.flags |= 65536),
          (rootRenderLanes &= -rootRenderLanes),
          (root.lanes |= rootRenderLanes),
          (value = createCapturedValueAtFiber(value, sourceFiber)),
          (rootRenderLanes = createRootErrorUpdate(
            root.stateNode,
            value,
            rootRenderLanes
          )),
          enqueueCapturedUpdate(root, rootRenderLanes),
          4 !== workInProgressRootExitStatus &&
            (workInProgressRootExitStatus = 2)),
      !1
    );
  var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
  wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
  null === workInProgressRootConcurrentErrors
    ? (workInProgressRootConcurrentErrors = [wrapperError])
    : workInProgressRootConcurrentErrors.push(wrapperError);
  4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
  if (null === returnFiber) return !0;
  value = createCapturedValueAtFiber(value, sourceFiber);
  sourceFiber = returnFiber;
  do {
    switch (sourceFiber.tag) {
      case 3:
        return (
          (sourceFiber.flags |= 65536),
          (root = rootRenderLanes & -rootRenderLanes),
          (sourceFiber.lanes |= root),
          (root = createRootErrorUpdate(sourceFiber.stateNode, value, root)),
          enqueueCapturedUpdate(sourceFiber, root),
          !1
        );
      case 1:
        if (
          ((returnFiber = sourceFiber.type),
          (wrapperError = sourceFiber.stateNode),
          0 === (sourceFiber.flags & 128) &&
            ("function" === typeof returnFiber.getDerivedStateFromError ||
              (null !== wrapperError &&
                "function" === typeof wrapperError.componentDidCatch &&
                (null === legacyErrorBoundariesThatAlreadyFailed ||
                  !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError)))))
        )
          return (
            (sourceFiber.flags |= 65536),
            (rootRenderLanes &= -rootRenderLanes),
            (sourceFiber.lanes |= rootRenderLanes),
            (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),
            initializeClassErrorUpdate(
              rootRenderLanes,
              root,
              sourceFiber,
              value
            ),
            enqueueCapturedUpdate(sourceFiber, rootRenderLanes),
            !1
          );
    }
    sourceFiber = sourceFiber.return;
  } while (null !== sourceFiber);
  return !1;
}
var SelectiveHydrationException = Error(formatProdErrorMessage(461)),
  didReceiveUpdate = !1;
function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
  workInProgress.child =
    null === current
      ? mountChildFibers(workInProgress, null, nextChildren, renderLanes)
      : reconcileChildFibers(
          workInProgress,
          current.child,
          nextChildren,
          renderLanes
        );
}
function updateForwardRef(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  Component = Component.render;
  var ref = workInProgress.ref;
  if ("ref" in nextProps) {
    var propsWithoutRef = {};
    for (var key in nextProps)
      "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
  } else propsWithoutRef = nextProps;
  prepareToReadContext(workInProgress);
  nextProps = renderWithHooks(
    current,
    workInProgress,
    Component,
    propsWithoutRef,
    ref,
    renderLanes
  );
  key = checkDidRenderIdHook();
  if (null !== current && !didReceiveUpdate)
    return (
      bailoutHooks(current, workInProgress, renderLanes),
      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
    );
  isHydrating && key && pushMaterializedTreeId(workInProgress);
  workInProgress.flags |= 1;
  reconcileChildren(current, workInProgress, nextProps, renderLanes);
  return workInProgress.child;
}
function updateMemoComponent(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  if (null === current) {
    var type = Component.type;
    if (
      "function" === typeof type &&
      !shouldConstruct(type) &&
      void 0 === type.defaultProps &&
      null === Component.compare
    )
      return (
        (workInProgress.tag = 15),
        (workInProgress.type = type),
        updateSimpleMemoComponent(
          current,
          workInProgress,
          type,
          nextProps,
          renderLanes
        )
      );
    current = createFiberFromTypeAndProps(
      Component.type,
      null,
      nextProps,
      workInProgress,
      workInProgress.mode,
      renderLanes
    );
    current.ref = workInProgress.ref;
    current.return = workInProgress;
    return (workInProgress.child = current);
  }
  type = current.child;
  if (!checkScheduledUpdateOrContext(current, renderLanes)) {
    var prevProps = type.memoizedProps;
    Component = Component.compare;
    Component = null !== Component ? Component : shallowEqual;
    if (Component(prevProps, nextProps) && current.ref === workInProgress.ref)
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }
  workInProgress.flags |= 1;
  current = createWorkInProgress(type, nextProps);
  current.ref = workInProgress.ref;
  current.return = workInProgress;
  return (workInProgress.child = current);
}
function updateSimpleMemoComponent(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  if (null !== current) {
    var prevProps = current.memoizedProps;
    if (
      shallowEqual(prevProps, nextProps) &&
      current.ref === workInProgress.ref
    )
      if (
        ((didReceiveUpdate = !1),
        (workInProgress.pendingProps = nextProps = prevProps),
        checkScheduledUpdateOrContext(current, renderLanes))
      )
        0 !== (current.flags & 131072) && (didReceiveUpdate = !0);
      else
        return (
          (workInProgress.lanes = current.lanes),
          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
        );
  }
  return updateFunctionComponent(
    current,
    workInProgress,
    Component,
    nextProps,
    renderLanes
  );
}
function updateOffscreenComponent(
  current,
  workInProgress,
  renderLanes,
  nextProps
) {
  var nextChildren = nextProps.children,
    prevState = null !== current ? current.memoizedState : null;
  null === current &&
    null === workInProgress.stateNode &&
    (workInProgress.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    });
  if ("hidden" === nextProps.mode) {
    if (0 !== (workInProgress.flags & 128)) {
      prevState =
        null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;
      if (null !== current) {
        nextProps = workInProgress.child = current.child;
        for (nextChildren = 0; null !== nextProps; )
          (nextChildren =
            nextChildren | nextProps.lanes | nextProps.childLanes),
            (nextProps = nextProps.sibling);
        nextProps = nextChildren & ~prevState;
      } else (nextProps = 0), (workInProgress.child = null);
      return deferHiddenOffscreenComponent(
        current,
        workInProgress,
        prevState,
        renderLanes,
        nextProps
      );
    }
    if (0 !== (renderLanes & 536870912))
      (workInProgress.memoizedState = { baseLanes: 0, cachePool: null }),
        null !== current &&
          pushTransition(
            workInProgress,
            null !== prevState ? prevState.cachePool : null
          ),
        null !== prevState
          ? pushHiddenContext(workInProgress, prevState)
          : reuseHiddenContextOnStack(),
        pushOffscreenSuspenseHandler(workInProgress);
    else
      return (
        (nextProps = workInProgress.lanes = 536870912),
        deferHiddenOffscreenComponent(
          current,
          workInProgress,
          null !== prevState ? prevState.baseLanes | renderLanes : renderLanes,
          renderLanes,
          nextProps
        )
      );
  } else
    null !== prevState
      ? (pushTransition(workInProgress, prevState.cachePool),
        pushHiddenContext(workInProgress, prevState),
        reuseSuspenseHandlerOnStack(workInProgress),
        (workInProgress.memoizedState = null))
      : (null !== current && pushTransition(workInProgress, null),
        reuseHiddenContextOnStack(),
        reuseSuspenseHandlerOnStack(workInProgress));
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}
function bailoutOffscreenComponent(current, workInProgress) {
  (null !== current && 22 === current.tag) ||
    null !== workInProgress.stateNode ||
    (workInProgress.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    });
  return workInProgress.sibling;
}
function deferHiddenOffscreenComponent(
  current,
  workInProgress,
  nextBaseLanes,
  renderLanes,
  remainingChildLanes
) {
  var JSCompiler_inline_result = peekCacheFromPool();
  JSCompiler_inline_result =
    null === JSCompiler_inline_result
      ? null
      : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
  workInProgress.memoizedState = {
    baseLanes: nextBaseLanes,
    cachePool: JSCompiler_inline_result
  };
  null !== current && pushTransition(workInProgress, null);
  reuseHiddenContextOnStack();
  pushOffscreenSuspenseHandler(workInProgress);
  null !== current &&
    propagateParentContextChanges(current, workInProgress, renderLanes, !0);
  workInProgress.childLanes = remainingChildLanes;
  return null;
}
function mountActivityChildren(workInProgress, nextProps) {
  nextProps = mountWorkInProgressOffscreenFiber(
    { mode: nextProps.mode, children: nextProps.children },
    workInProgress.mode
  );
  nextProps.ref = workInProgress.ref;
  workInProgress.child = nextProps;
  nextProps.return = workInProgress;
  return nextProps;
}
function retryActivityComponentWithoutHydrating(
  current,
  workInProgress,
  renderLanes
) {
  reconcileChildFibers(workInProgress, current.child, null, renderLanes);
  current = mountActivityChildren(workInProgress, workInProgress.pendingProps);
  current.flags |= 2;
  popSuspenseHandler(workInProgress);
  workInProgress.memoizedState = null;
  return current;
}
function updateActivityComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps,
    didSuspend = 0 !== (workInProgress.flags & 128);
  workInProgress.flags &= -129;
  if (null === current) {
    if (isHydrating) {
      if ("hidden" === nextProps.mode)
        return (
          (current = mountActivityChildren(workInProgress, nextProps)),
          (workInProgress.lanes = 536870912),
          bailoutOffscreenComponent(null, current)
        );
      pushDehydratedActivitySuspenseHandler(workInProgress);
      (current = nextHydratableInstance)
        ? ((current = canHydrateHydrationBoundary(
            current,
            rootOrSingletonContext
          )),
          (current = null !== current && "&" === current.data ? current : null),
          null !== current &&
            ((workInProgress.memoizedState = {
              dehydrated: current,
              treeContext:
                null !== treeContextProvider
                  ? { id: treeContextId, overflow: treeContextOverflow }
                  : null,
              retryLane: 536870912,
              hydrationErrors: null
            }),
            (renderLanes = createFiberFromDehydratedFragment(current)),
            (renderLanes.return = workInProgress),
            (workInProgress.child = renderLanes),
            (hydrationParentFiber = workInProgress),
            (nextHydratableInstance = null)))
        : (current = null);
      if (null === current) throw throwOnHydrationMismatch(workInProgress);
      workInProgress.lanes = 536870912;
      return null;
    }
    return mountActivityChildren(workInProgress, nextProps);
  }
  var prevState = current.memoizedState;
  if (null !== prevState) {
    var dehydrated = prevState.dehydrated;
    pushDehydratedActivitySuspenseHandler(workInProgress);
    if (didSuspend)
      if (workInProgress.flags & 256)
        (workInProgress.flags &= -257),
          (workInProgress = retryActivityComponentWithoutHydrating(
            current,
            workInProgress,
            renderLanes
          ));
      else if (null !== workInProgress.memoizedState)
        (workInProgress.child = current.child),
          (workInProgress.flags |= 128),
          (workInProgress = null);
      else throw Error(formatProdErrorMessage(558));
    else if (
      (didReceiveUpdate ||
        propagateParentContextChanges(current, workInProgress, renderLanes, !1),
      (didSuspend = 0 !== (renderLanes & current.childLanes)),
      didReceiveUpdate || didSuspend)
    ) {
      nextProps = workInProgressRoot;
      if (
        null !== nextProps &&
        ((dehydrated = getBumpedLaneForHydration(nextProps, renderLanes)),
        0 !== dehydrated && dehydrated !== prevState.retryLane)
      )
        throw (
          ((prevState.retryLane = dehydrated),
          enqueueConcurrentRenderForLane(current, dehydrated),
          scheduleUpdateOnFiber(nextProps, current, dehydrated),
          SelectiveHydrationException)
        );
      renderDidSuspendDelayIfPossible();
      workInProgress = retryActivityComponentWithoutHydrating(
        current,
        workInProgress,
        renderLanes
      );
    } else
      (current = prevState.treeContext),
        (nextHydratableInstance = getNextHydratable(dehydrated.nextSibling)),
        (hydrationParentFiber = workInProgress),
        (isHydrating = !0),
        (hydrationErrors = null),
        (rootOrSingletonContext = !1),
        null !== current &&
          restoreSuspendedTreeContext(workInProgress, current),
        (workInProgress = mountActivityChildren(workInProgress, nextProps)),
        (workInProgress.flags |= 4096);
    return workInProgress;
  }
  current = createWorkInProgress(current.child, {
    mode: nextProps.mode,
    children: nextProps.children
  });
  current.ref = workInProgress.ref;
  workInProgress.child = current;
  current.return = workInProgress;
  return current;
}
function markRef(current, workInProgress) {
  var ref = workInProgress.ref;
  if (null === ref)
    null !== current &&
      null !== current.ref &&
      (workInProgress.flags |= 4194816);
  else {
    if ("function" !== typeof ref && "object" !== typeof ref)
      throw Error(formatProdErrorMessage(284));
    if (null === current || current.ref !== ref)
      workInProgress.flags |= 4194816;
  }
}
function updateFunctionComponent(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  prepareToReadContext(workInProgress);
  Component = renderWithHooks(
    current,
    workInProgress,
    Component,
    nextProps,
    void 0,
    renderLanes
  );
  nextProps = checkDidRenderIdHook();
  if (null !== current && !didReceiveUpdate)
    return (
      bailoutHooks(current, workInProgress, renderLanes),
      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
    );
  isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
  workInProgress.flags |= 1;
  reconcileChildren(current, workInProgress, Component, renderLanes);
  return workInProgress.child;
}
function replayFunctionComponent(
  current,
  workInProgress,
  nextProps,
  Component,
  secondArg,
  renderLanes
) {
  prepareToReadContext(workInProgress);
  workInProgress.updateQueue = null;
  nextProps = renderWithHooksAgain(
    workInProgress,
    Component,
    nextProps,
    secondArg
  );
  finishRenderingHooks(current);
  Component = checkDidRenderIdHook();
  if (null !== current && !didReceiveUpdate)
    return (
      bailoutHooks(current, workInProgress, renderLanes),
      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
    );
  isHydrating && Component && pushMaterializedTreeId(workInProgress);
  workInProgress.flags |= 1;
  reconcileChildren(current, workInProgress, nextProps, renderLanes);
  return workInProgress.child;
}
function updateClassComponent(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  prepareToReadContext(workInProgress);
  if (null === workInProgress.stateNode) {
    var context = emptyContextObject,
      contextType = Component.contextType;
    "object" === typeof contextType &&
      null !== contextType &&
      (context = readContext(contextType));
    context = new Component(nextProps, context);
    workInProgress.memoizedState =
      null !== context.state && void 0 !== context.state ? context.state : null;
    context.updater = classComponentUpdater;
    workInProgress.stateNode = context;
    context._reactInternals = workInProgress;
    context = workInProgress.stateNode;
    context.props = nextProps;
    context.state = workInProgress.memoizedState;
    context.refs = {};
    initializeUpdateQueue(workInProgress);
    contextType = Component.contextType;
    context.context =
      "object" === typeof contextType && null !== contextType
        ? readContext(contextType)
        : emptyContextObject;
    context.state = workInProgress.memoizedState;
    contextType = Component.getDerivedStateFromProps;
    "function" === typeof contextType &&
      (applyDerivedStateFromProps(
        workInProgress,
        Component,
        contextType,
        nextProps
      ),
      (context.state = workInProgress.memoizedState));
    "function" === typeof Component.getDerivedStateFromProps ||
      "function" === typeof context.getSnapshotBeforeUpdate ||
      ("function" !== typeof context.UNSAFE_componentWillMount &&
        "function" !== typeof context.componentWillMount) ||
      ((contextType = context.state),
      "function" === typeof context.componentWillMount &&
        context.componentWillMount(),
      "function" === typeof context.UNSAFE_componentWillMount &&
        context.UNSAFE_componentWillMount(),
      contextType !== context.state &&
        classComponentUpdater.enqueueReplaceState(context, context.state, null),
      processUpdateQueue(workInProgress, nextProps, context, renderLanes),
      suspendIfUpdateReadFromEntangledAsyncAction(),
      (context.state = workInProgress.memoizedState));
    "function" === typeof context.componentDidMount &&
      (workInProgress.flags |= 4194308);
    nextProps = !0;
  } else if (null === current) {
    context = workInProgress.stateNode;
    var unresolvedOldProps = workInProgress.memoizedProps,
      oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
    context.props = oldProps;
    var oldContext = context.context,
      contextType$jscomp$0 = Component.contextType;
    contextType = emptyContextObject;
    "object" === typeof contextType$jscomp$0 &&
      null !== contextType$jscomp$0 &&
      (contextType = readContext(contextType$jscomp$0));
    var getDerivedStateFromProps = Component.getDerivedStateFromProps;
    contextType$jscomp$0 =
      "function" === typeof getDerivedStateFromProps ||
      "function" === typeof context.getSnapshotBeforeUpdate;
    unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;
    contextType$jscomp$0 ||
      ("function" !== typeof context.UNSAFE_componentWillReceiveProps &&
        "function" !== typeof context.componentWillReceiveProps) ||
      ((unresolvedOldProps || oldContext !== contextType) &&
        callComponentWillReceiveProps(
          workInProgress,
          context,
          nextProps,
          contextType
        ));
    hasForceUpdate = !1;
    var oldState = workInProgress.memoizedState;
    context.state = oldState;
    processUpdateQueue(workInProgress, nextProps, context, renderLanes);
    suspendIfUpdateReadFromEntangledAsyncAction();
    oldContext = workInProgress.memoizedState;
    unresolvedOldProps || oldState !== oldContext || hasForceUpdate
      ? ("function" === typeof getDerivedStateFromProps &&
          (applyDerivedStateFromProps(
            workInProgress,
            Component,
            getDerivedStateFromProps,
            nextProps
          ),
          (oldContext = workInProgress.memoizedState)),
        (oldProps =
          hasForceUpdate ||
          checkShouldComponentUpdate(
            workInProgress,
            Component,
            oldProps,
            nextProps,
            oldState,
            oldContext,
            contextType
          ))
          ? (contextType$jscomp$0 ||
              ("function" !== typeof context.UNSAFE_componentWillMount &&
                "function" !== typeof context.componentWillMount) ||
              ("function" === typeof context.componentWillMount &&
                context.componentWillMount(),
              "function" === typeof context.UNSAFE_componentWillMount &&
                context.UNSAFE_componentWillMount()),
            "function" === typeof context.componentDidMount &&
              (workInProgress.flags |= 4194308))
          : ("function" === typeof context.componentDidMount &&
              (workInProgress.flags |= 4194308),
            (workInProgress.memoizedProps = nextProps),
            (workInProgress.memoizedState = oldContext)),
        (context.props = nextProps),
        (context.state = oldContext),
        (context.context = contextType),
        (nextProps = oldProps))
      : ("function" === typeof context.componentDidMount &&
          (workInProgress.flags |= 4194308),
        (nextProps = !1));
  } else {
    context = workInProgress.stateNode;
    cloneUpdateQueue(current, workInProgress);
    contextType = workInProgress.memoizedProps;
    contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
    context.props = contextType$jscomp$0;
    getDerivedStateFromProps = workInProgress.pendingProps;
    oldState = context.context;
    oldContext = Component.contextType;
    oldProps = emptyContextObject;
    "object" === typeof oldContext &&
      null !== oldContext &&
      (oldProps = readContext(oldContext));
    unresolvedOldProps = Component.getDerivedStateFromProps;
    (oldContext =
      "function" === typeof unresolvedOldProps ||
      "function" === typeof context.getSnapshotBeforeUpdate) ||
      ("function" !== typeof context.UNSAFE_componentWillReceiveProps &&
        "function" !== typeof context.componentWillReceiveProps) ||
      ((contextType !== getDerivedStateFromProps || oldState !== oldProps) &&
        callComponentWillReceiveProps(
          workInProgress,
          context,
          nextProps,
          oldProps
        ));
    hasForceUpdate = !1;
    oldState = workInProgress.memoizedState;
    context.state = oldState;
    processUpdateQueue(workInProgress, nextProps, context, renderLanes);
    suspendIfUpdateReadFromEntangledAsyncAction();
    var newState = workInProgress.memoizedState;
    contextType !== getDerivedStateFromProps ||
    oldState !== newState ||
    hasForceUpdate ||
    (null !== current &&
      null !== current.dependencies &&
      checkIfContextChanged(current.dependencies))
      ? ("function" === typeof unresolvedOldProps &&
          (applyDerivedStateFromProps(
            workInProgress,
            Component,
            unresolvedOldProps,
            nextProps
          ),
          (newState = workInProgress.memoizedState)),
        (contextType$jscomp$0 =
          hasForceUpdate ||
          checkShouldComponentUpdate(
            workInProgress,
            Component,
            contextType$jscomp$0,
            nextProps,
            oldState,
            newState,
            oldProps
          ) ||
          (null !== current &&
            null !== current.dependencies &&
            checkIfContextChanged(current.dependencies)))
          ? (oldContext ||
              ("function" !== typeof context.UNSAFE_componentWillUpdate &&
                "function" !== typeof context.componentWillUpdate) ||
              ("function" === typeof context.componentWillUpdate &&
                context.componentWillUpdate(nextProps, newState, oldProps),
              "function" === typeof context.UNSAFE_componentWillUpdate &&
                context.UNSAFE_componentWillUpdate(
                  nextProps,
                  newState,
                  oldProps
                )),
            "function" === typeof context.componentDidUpdate &&
              (workInProgress.flags |= 4),
            "function" === typeof context.getSnapshotBeforeUpdate &&
              (workInProgress.flags |= 1024))
          : ("function" !== typeof context.componentDidUpdate ||
              (contextType === current.memoizedProps &&
                oldState === current.memoizedState) ||
              (workInProgress.flags |= 4),
            "function" !== typeof context.getSnapshotBeforeUpdate ||
              (contextType === current.memoizedProps &&
                oldState === current.memoizedState) ||
              (workInProgress.flags |= 1024),
            (workInProgress.memoizedProps = nextProps),
            (workInProgress.memoizedState = newState)),
        (context.props = nextProps),
        (context.state = newState),
        (context.context = oldProps),
        (nextProps = contextType$jscomp$0))
      : ("function" !== typeof context.componentDidUpdate ||
          (contextType === current.memoizedProps &&
            oldState === current.memoizedState) ||
          (workInProgress.flags |= 4),
        "function" !== typeof context.getSnapshotBeforeUpdate ||
          (contextType === current.memoizedProps &&
            oldState === current.memoizedState) ||
          (workInProgress.flags |= 1024),
        (nextProps = !1));
  }
  context = nextProps;
  markRef(current, workInProgress);
  nextProps = 0 !== (workInProgress.flags & 128);
  context || nextProps
    ? ((context = workInProgress.stateNode),
      (Component =
        nextProps && "function" !== typeof Component.getDerivedStateFromError
          ? null
          : context.render()),
      (workInProgress.flags |= 1),
      null !== current && nextProps
        ? ((workInProgress.child = reconcileChildFibers(
            workInProgress,
            current.child,
            null,
            renderLanes
          )),
          (workInProgress.child = reconcileChildFibers(
            workInProgress,
            null,
            Component,
            renderLanes
          )))
        : reconcileChildren(current, workInProgress, Component, renderLanes),
      (workInProgress.memoizedState = context.state),
      (current = workInProgress.child))
    : (current = bailoutOnAlreadyFinishedWork(
        current,
        workInProgress,
        renderLanes
      ));
  return current;
}
function mountHostRootWithoutHydrating(
  current,
  workInProgress,
  nextChildren,
  renderLanes
) {
  resetHydrationState();
  workInProgress.flags |= 256;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}
var SUSPENDED_MARKER = {
  dehydrated: null,
  treeContext: null,
  retryLane: 0,
  hydrationErrors: null
};
function mountSuspenseOffscreenState(renderLanes) {
  return { baseLanes: renderLanes, cachePool: getSuspendedCache() };
}
function getRemainingWorkInPrimaryTree(
  current,
  primaryTreeDidDefer,
  renderLanes
) {
  current = null !== current ? current.childLanes & ~renderLanes : 0;
  primaryTreeDidDefer && (current |= workInProgressDeferredLane);
  return current;
}
function updateSuspenseComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps,
    showFallback = !1,
    didSuspend = 0 !== (workInProgress.flags & 128),
    JSCompiler_temp;
  (JSCompiler_temp = didSuspend) ||
    (JSCompiler_temp =
      null !== current && null === current.memoizedState
        ? !1
        : 0 !== (suspenseStackCursor.current & 2));
  JSCompiler_temp && ((showFallback = !0), (workInProgress.flags &= -129));
  JSCompiler_temp = 0 !== (workInProgress.flags & 32);
  workInProgress.flags &= -33;
  if (null === current) {
    if (isHydrating) {
      showFallback
        ? pushPrimaryTreeSuspenseHandler(workInProgress)
        : reuseSuspenseHandlerOnStack(workInProgress);
      (current = nextHydratableInstance)
        ? ((current = canHydrateHydrationBoundary(
            current,
            rootOrSingletonContext
          )),
          (current = null !== current && "&" !== current.data ? current : null),
          null !== current &&
            ((workInProgress.memoizedState = {
              dehydrated: current,
              treeContext:
                null !== treeContextProvider
                  ? { id: treeContextId, overflow: treeContextOverflow }
                  : null,
              retryLane: 536870912,
              hydrationErrors: null
            }),
            (renderLanes = createFiberFromDehydratedFragment(current)),
            (renderLanes.return = workInProgress),
            (workInProgress.child = renderLanes),
            (hydrationParentFiber = workInProgress),
            (nextHydratableInstance = null)))
        : (current = null);
      if (null === current) throw throwOnHydrationMismatch(workInProgress);
      isSuspenseInstanceFallback(current)
        ? (workInProgress.lanes = 32)
        : (workInProgress.lanes = 536870912);
      return null;
    }
    var nextPrimaryChildren = nextProps.children;
    nextProps = nextProps.fallback;
    if (showFallback)
      return (
        reuseSuspenseHandlerOnStack(workInProgress),
        (showFallback = workInProgress.mode),
        (nextPrimaryChildren = mountWorkInProgressOffscreenFiber(
          { mode: "hidden", children: nextPrimaryChildren },
          showFallback
        )),
        (nextProps = createFiberFromFragment(
          nextProps,
          showFallback,
          renderLanes,
          null
        )),
        (nextPrimaryChildren.return = workInProgress),
        (nextProps.return = workInProgress),
        (nextPrimaryChildren.sibling = nextProps),
        (workInProgress.child = nextPrimaryChildren),
        (nextProps = workInProgress.child),
        (nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes)),
        (nextProps.childLanes = getRemainingWorkInPrimaryTree(
          current,
          JSCompiler_temp,
          renderLanes
        )),
        (workInProgress.memoizedState = SUSPENDED_MARKER),
        bailoutOffscreenComponent(null, nextProps)
      );
    pushPrimaryTreeSuspenseHandler(workInProgress);
    return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren);
  }
  var prevState = current.memoizedState;
  if (
    null !== prevState &&
    ((nextPrimaryChildren = prevState.dehydrated), null !== nextPrimaryChildren)
  ) {
    if (didSuspend)
      workInProgress.flags & 256
        ? (pushPrimaryTreeSuspenseHandler(workInProgress),
          (workInProgress.flags &= -257),
          (workInProgress = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress,
            renderLanes
          )))
        : null !== workInProgress.memoizedState
          ? (reuseSuspenseHandlerOnStack(workInProgress),
            (workInProgress.child = current.child),
            (workInProgress.flags |= 128),
            (workInProgress = null))
          : (reuseSuspenseHandlerOnStack(workInProgress),
            (nextPrimaryChildren = nextProps.fallback),
            (showFallback = workInProgress.mode),
            (nextProps = mountWorkInProgressOffscreenFiber(
              { mode: "visible", children: nextProps.children },
              showFallback
            )),
            (nextPrimaryChildren = createFiberFromFragment(
              nextPrimaryChildren,
              showFallback,
              renderLanes,
              null
            )),
            (nextPrimaryChildren.flags |= 2),
            (nextProps.return = workInProgress),
            (nextPrimaryChildren.return = workInProgress),
            (nextProps.sibling = nextPrimaryChildren),
            (workInProgress.child = nextProps),
            reconcileChildFibers(
              workInProgress,
              current.child,
              null,
              renderLanes
            ),
            (nextProps = workInProgress.child),
            (nextProps.memoizedState =
              mountSuspenseOffscreenState(renderLanes)),
            (nextProps.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes
            )),
            (workInProgress.memoizedState = SUSPENDED_MARKER),
            (workInProgress = bailoutOffscreenComponent(null, nextProps)));
    else if (
      (pushPrimaryTreeSuspenseHandler(workInProgress),
      isSuspenseInstanceFallback(nextPrimaryChildren))
    ) {
      JSCompiler_temp =
        nextPrimaryChildren.nextSibling &&
        nextPrimaryChildren.nextSibling.dataset;
      if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
      JSCompiler_temp = digest;
      nextProps = Error(formatProdErrorMessage(419));
      nextProps.stack = "";
      nextProps.digest = JSCompiler_temp;
      queueHydrationError({ value: nextProps, source: null, stack: null });
      workInProgress = retrySuspenseComponentWithoutHydrating(
        current,
        workInProgress,
        renderLanes
      );
    } else if (
      (didReceiveUpdate ||
        propagateParentContextChanges(current, workInProgress, renderLanes, !1),
      (JSCompiler_temp = 0 !== (renderLanes & current.childLanes)),
      didReceiveUpdate || JSCompiler_temp)
    ) {
      JSCompiler_temp = workInProgressRoot;
      if (
        null !== JSCompiler_temp &&
        ((nextProps = getBumpedLaneForHydration(JSCompiler_temp, renderLanes)),
        0 !== nextProps && nextProps !== prevState.retryLane)
      )
        throw (
          ((prevState.retryLane = nextProps),
          enqueueConcurrentRenderForLane(current, nextProps),
          scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps),
          SelectiveHydrationException)
        );
      isSuspenseInstancePending(nextPrimaryChildren) ||
        renderDidSuspendDelayIfPossible();
      workInProgress = retrySuspenseComponentWithoutHydrating(
        current,
        workInProgress,
        renderLanes
      );
    } else
      isSuspenseInstancePending(nextPrimaryChildren)
        ? ((workInProgress.flags |= 192),
          (workInProgress.child = current.child),
          (workInProgress = null))
        : ((current = prevState.treeContext),
          (nextHydratableInstance = getNextHydratable(
            nextPrimaryChildren.nextSibling
          )),
          (hydrationParentFiber = workInProgress),
          (isHydrating = !0),
          (hydrationErrors = null),
          (rootOrSingletonContext = !1),
          null !== current &&
            restoreSuspendedTreeContext(workInProgress, current),
          (workInProgress = mountSuspensePrimaryChildren(
            workInProgress,
            nextProps.children
          )),
          (workInProgress.flags |= 4096));
    return workInProgress;
  }
  if (showFallback)
    return (
      reuseSuspenseHandlerOnStack(workInProgress),
      (nextPrimaryChildren = nextProps.fallback),
      (showFallback = workInProgress.mode),
      (prevState = current.child),
      (digest = prevState.sibling),
      (nextProps = createWorkInProgress(prevState, {
        mode: "hidden",
        children: nextProps.children
      })),
      (nextProps.subtreeFlags = prevState.subtreeFlags & 65011712),
      null !== digest
        ? (nextPrimaryChildren = createWorkInProgress(
            digest,
            nextPrimaryChildren
          ))
        : ((nextPrimaryChildren = createFiberFromFragment(
            nextPrimaryChildren,
            showFallback,
            renderLanes,
            null
          )),
          (nextPrimaryChildren.flags |= 2)),
      (nextPrimaryChildren.return = workInProgress),
      (nextProps.return = workInProgress),
      (nextProps.sibling = nextPrimaryChildren),
      (workInProgress.child = nextProps),
      bailoutOffscreenComponent(null, nextProps),
      (nextProps = workInProgress.child),
      (nextPrimaryChildren = current.child.memoizedState),
      null === nextPrimaryChildren
        ? (nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes))
        : ((showFallback = nextPrimaryChildren.cachePool),
          null !== showFallback
            ? ((prevState = CacheContext._currentValue),
              (showFallback =
                showFallback.parent !== prevState
                  ? { parent: prevState, pool: prevState }
                  : showFallback))
            : (showFallback = getSuspendedCache()),
          (nextPrimaryChildren = {
            baseLanes: nextPrimaryChildren.baseLanes | renderLanes,
            cachePool: showFallback
          })),
      (nextProps.memoizedState = nextPrimaryChildren),
      (nextProps.childLanes = getRemainingWorkInPrimaryTree(
        current,
        JSCompiler_temp,
        renderLanes
      )),
      (workInProgress.memoizedState = SUSPENDED_MARKER),
      bailoutOffscreenComponent(current.child, nextProps)
    );
  pushPrimaryTreeSuspenseHandler(workInProgress);
  renderLanes = current.child;
  current = renderLanes.sibling;
  renderLanes = createWorkInProgress(renderLanes, {
    mode: "visible",
    children: nextProps.children
  });
  renderLanes.return = workInProgress;
  renderLanes.sibling = null;
  null !== current &&
    ((JSCompiler_temp = workInProgress.deletions),
    null === JSCompiler_temp
      ? ((workInProgress.deletions = [current]), (workInProgress.flags |= 16))
      : JSCompiler_temp.push(current));
  workInProgress.child = renderLanes;
  workInProgress.memoizedState = null;
  return renderLanes;
}
function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
  primaryChildren = mountWorkInProgressOffscreenFiber(
    { mode: "visible", children: primaryChildren },
    workInProgress.mode
  );
  primaryChildren.return = workInProgress;
  return (workInProgress.child = primaryChildren);
}
function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
  offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
  offscreenProps.lanes = 0;
  return offscreenProps;
}
function retrySuspenseComponentWithoutHydrating(
  current,
  workInProgress,
  renderLanes
) {
  reconcileChildFibers(workInProgress, current.child, null, renderLanes);
  current = mountSuspensePrimaryChildren(
    workInProgress,
    workInProgress.pendingProps.children
  );
  current.flags |= 2;
  workInProgress.memoizedState = null;
  return current;
}
function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
  fiber.lanes |= renderLanes;
  var alternate = fiber.alternate;
  null !== alternate && (alternate.lanes |= renderLanes);
  scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);
}
function initSuspenseListRenderState(
  workInProgress,
  isBackwards,
  tail,
  lastContentRow,
  tailMode,
  treeForkCount
) {
  var renderState = workInProgress.memoizedState;
  null === renderState
    ? (workInProgress.memoizedState = {
        isBackwards: isBackwards,
        rendering: null,
        renderingStartTime: 0,
        last: lastContentRow,
        tail: tail,
        tailMode: tailMode,
        treeForkCount: treeForkCount
      })
    : ((renderState.isBackwards = isBackwards),
      (renderState.rendering = null),
      (renderState.renderingStartTime = 0),
      (renderState.last = lastContentRow),
      (renderState.tail = tail),
      (renderState.tailMode = tailMode),
      (renderState.treeForkCount = treeForkCount));
}
function updateSuspenseListComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps,
    revealOrder = nextProps.revealOrder,
    tailMode = nextProps.tail;
  nextProps = nextProps.children;
  var suspenseContext = suspenseStackCursor.current,
    shouldForceFallback = 0 !== (suspenseContext & 2);
  shouldForceFallback
    ? ((suspenseContext = (suspenseContext & 1) | 2),
      (workInProgress.flags |= 128))
    : (suspenseContext &= 1);
  push(suspenseStackCursor, suspenseContext);
  reconcileChildren(current, workInProgress, nextProps, renderLanes);
  nextProps = isHydrating ? treeForkCount : 0;
  if (!shouldForceFallback && null !== current && 0 !== (current.flags & 128))
    a: for (current = workInProgress.child; null !== current; ) {
      if (13 === current.tag)
        null !== current.memoizedState &&
          scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
      else if (19 === current.tag)
        scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);
      else if (null !== current.child) {
        current.child.return = current;
        current = current.child;
        continue;
      }
      if (current === workInProgress) break a;
      for (; null === current.sibling; ) {
        if (null === current.return || current.return === workInProgress)
          break a;
        current = current.return;
      }
      current.sibling.return = current.return;
      current = current.sibling;
    }
  switch (revealOrder) {
    case "forwards":
      renderLanes = workInProgress.child;
      for (revealOrder = null; null !== renderLanes; )
        (current = renderLanes.alternate),
          null !== current &&
            null === findFirstSuspended(current) &&
            (revealOrder = renderLanes),
          (renderLanes = renderLanes.sibling);
      renderLanes = revealOrder;
      null === renderLanes
        ? ((revealOrder = workInProgress.child), (workInProgress.child = null))
        : ((revealOrder = renderLanes.sibling), (renderLanes.sibling = null));
      initSuspenseListRenderState(
        workInProgress,
        !1,
        revealOrder,
        renderLanes,
        tailMode,
        nextProps
      );
      break;
    case "backwards":
    case "unstable_legacy-backwards":
      renderLanes = null;
      revealOrder = workInProgress.child;
      for (workInProgress.child = null; null !== revealOrder; ) {
        current = revealOrder.alternate;
        if (null !== current && null === findFirstSuspended(current)) {
          workInProgress.child = revealOrder;
          break;
        }
        current = revealOrder.sibling;
        revealOrder.sibling = renderLanes;
        renderLanes = revealOrder;
        revealOrder = current;
      }
      initSuspenseListRenderState(
        workInProgress,
        !0,
        renderLanes,
        null,
        tailMode,
        nextProps
      );
      break;
    case "together":
      initSuspenseListRenderState(
        workInProgress,
        !1,
        null,
        null,
        void 0,
        nextProps
      );
      break;
    default:
      workInProgress.memoizedState = null;
  }
  return workInProgress.child;
}
function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
  null !== current && (workInProgress.dependencies = current.dependencies);
  workInProgressRootSkippedLanes |= workInProgress.lanes;
  if (0 === (renderLanes & workInProgress.childLanes))
    if (null !== current) {
      if (
        (propagateParentContextChanges(
          current,
          workInProgress,
          renderLanes,
          !1
        ),
        0 === (renderLanes & workInProgress.childLanes))
      )
        return null;
    } else return null;
  if (null !== current && workInProgress.child !== current.child)
    throw Error(formatProdErrorMessage(153));
  if (null !== workInProgress.child) {
    current = workInProgress.child;
    renderLanes = createWorkInProgress(current, current.pendingProps);
    workInProgress.child = renderLanes;
    for (renderLanes.return = workInProgress; null !== current.sibling; )
      (current = current.sibling),
        (renderLanes = renderLanes.sibling =
          createWorkInProgress(current, current.pendingProps)),
        (renderLanes.return = workInProgress);
    renderLanes.sibling = null;
  }
  return workInProgress.child;
}
function checkScheduledUpdateOrContext(current, renderLanes) {
  if (0 !== (current.lanes & renderLanes)) return !0;
  current = current.dependencies;
  return null !== current && checkIfContextChanged(current) ? !0 : !1;
}
function attemptEarlyBailoutIfNoScheduledUpdate(
  current,
  workInProgress,
  renderLanes
) {
  switch (workInProgress.tag) {
    case 3:
      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
      resetHydrationState();
      break;
    case 27:
    case 5:
      pushHostContext(workInProgress);
      break;
    case 4:
      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
      break;
    case 10:
      pushProvider(
        workInProgress,
        workInProgress.type,
        workInProgress.memoizedProps.value
      );
      break;
    case 31:
      if (null !== workInProgress.memoizedState)
        return (
          (workInProgress.flags |= 128),
          pushDehydratedActivitySuspenseHandler(workInProgress),
          null
        );
      break;
    case 13:
      var state$102 = workInProgress.memoizedState;
      if (null !== state$102) {
        if (null !== state$102.dehydrated)
          return (
            pushPrimaryTreeSuspenseHandler(workInProgress),
            (workInProgress.flags |= 128),
            null
          );
        if (0 !== (renderLanes & workInProgress.child.childLanes))
          return updateSuspenseComponent(current, workInProgress, renderLanes);
        pushPrimaryTreeSuspenseHandler(workInProgress);
        current = bailoutOnAlreadyFinishedWork(
          current,
          workInProgress,
          renderLanes
        );
        return null !== current ? current.sibling : null;
      }
      pushPrimaryTreeSuspenseHandler(workInProgress);
      break;
    case 19:
      var didSuspendBefore = 0 !== (current.flags & 128);
      state$102 = 0 !== (renderLanes & workInProgress.childLanes);
      state$102 ||
        (propagateParentContextChanges(
          current,
          workInProgress,
          renderLanes,
          !1
        ),
        (state$102 = 0 !== (renderLanes & workInProgress.childLanes)));
      if (didSuspendBefore) {
        if (state$102)
          return updateSuspenseListComponent(
            current,
            workInProgress,
            renderLanes
          );
        workInProgress.flags |= 128;
      }
      didSuspendBefore = workInProgress.memoizedState;
      null !== didSuspendBefore &&
        ((didSuspendBefore.rendering = null),
        (didSuspendBefore.tail = null),
        (didSuspendBefore.lastEffect = null));
      push(suspenseStackCursor, suspenseStackCursor.current);
      if (state$102) break;
      else return null;
    case 22:
      return (
        (workInProgress.lanes = 0),
        updateOffscreenComponent(
          current,
          workInProgress,
          renderLanes,
          workInProgress.pendingProps
        )
      );
    case 24:
      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
  }
  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
}
function beginWork(current, workInProgress, renderLanes) {
  if (null !== current)
    if (current.memoizedProps !== workInProgress.pendingProps)
      didReceiveUpdate = !0;
    else {
      if (
        !checkScheduledUpdateOrContext(current, renderLanes) &&
        0 === (workInProgress.flags & 128)
      )
        return (
          (didReceiveUpdate = !1),
          attemptEarlyBailoutIfNoScheduledUpdate(
            current,
            workInProgress,
            renderLanes
          )
        );
      didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
    }
  else
    (didReceiveUpdate = !1),
      isHydrating &&
        0 !== (workInProgress.flags & 1048576) &&
        pushTreeId(workInProgress, treeForkCount, workInProgress.index);
  workInProgress.lanes = 0;
  switch (workInProgress.tag) {
    case 16:
      a: {
        var props = workInProgress.pendingProps;
        current = resolveLazy(workInProgress.elementType);
        workInProgress.type = current;
        if ("function" === typeof current)
          shouldConstruct(current)
            ? ((props = resolveClassComponentProps(current, props)),
              (workInProgress.tag = 1),
              (workInProgress = updateClassComponent(
                null,
                workInProgress,
                current,
                props,
                renderLanes
              )))
            : ((workInProgress.tag = 0),
              (workInProgress = updateFunctionComponent(
                null,
                workInProgress,
                current,
                props,
                renderLanes
              )));
        else {
          if (void 0 !== current && null !== current) {
            var $$typeof = current.$$typeof;
            if ($$typeof === REACT_FORWARD_REF_TYPE) {
              workInProgress.tag = 11;
              workInProgress = updateForwardRef(
                null,
                workInProgress,
                current,
                props,
                renderLanes
              );
              break a;
            } else if ($$typeof === REACT_MEMO_TYPE) {
              workInProgress.tag = 14;
              workInProgress = updateMemoComponent(
                null,
                workInProgress,
                current,
                props,
                renderLanes
              );
              break a;
            }
          }
          workInProgress = getComponentNameFromType(current) || current;
          throw Error(formatProdErrorMessage(306, workInProgress, ""));
        }
      }
      return workInProgress;
    case 0:
      return updateFunctionComponent(
        current,
        workInProgress,
        workInProgress.type,
        workInProgress.pendingProps,
        renderLanes
      );
    case 1:
      return (
        (props = workInProgress.type),
        ($$typeof = resolveClassComponentProps(
          props,
          workInProgress.pendingProps
        )),
        updateClassComponent(
          current,
          workInProgress,
          props,
          $$typeof,
          renderLanes
        )
      );
    case 3:
      a: {
        pushHostContainer(
          workInProgress,
          workInProgress.stateNode.containerInfo
        );
        if (null === current) throw Error(formatProdErrorMessage(387));
        props = workInProgress.pendingProps;
        var prevState = workInProgress.memoizedState;
        $$typeof = prevState.element;
        cloneUpdateQueue(current, workInProgress);
        processUpdateQueue(workInProgress, props, null, renderLanes);
        var nextState = workInProgress.memoizedState;
        props = nextState.cache;
        pushProvider(workInProgress, CacheContext, props);
        props !== prevState.cache &&
          propagateContextChanges(
            workInProgress,
            [CacheContext],
            renderLanes,
            !0
          );
        suspendIfUpdateReadFromEntangledAsyncAction();
        props = nextState.element;
        if (prevState.isDehydrated)
          if (
            ((prevState = {
              element: props,
              isDehydrated: !1,
              cache: nextState.cache
            }),
            (workInProgress.updateQueue.baseState = prevState),
            (workInProgress.memoizedState = prevState),
            workInProgress.flags & 256)
          ) {
            workInProgress = mountHostRootWithoutHydrating(
              current,
              workInProgress,
              props,
              renderLanes
            );
            break a;
          } else if (props !== $$typeof) {
            $$typeof = createCapturedValueAtFiber(
              Error(formatProdErrorMessage(424)),
              workInProgress
            );
            queueHydrationError($$typeof);
            workInProgress = mountHostRootWithoutHydrating(
              current,
              workInProgress,
              props,
              renderLanes
            );
            break a;
          } else {
            current = workInProgress.stateNode.containerInfo;
            switch (current.nodeType) {
              case 9:
                current = current.body;
                break;
              default:
                current =
                  "HTML" === current.nodeName
                    ? current.ownerDocument.body
                    : current;
            }
            nextHydratableInstance = getNextHydratable(current.firstChild);
            hydrationParentFiber = workInProgress;
            isHydrating = !0;
            hydrationErrors = null;
            rootOrSingletonContext = !0;
            renderLanes = mountChildFibers(
              workInProgress,
              null,
              props,
              renderLanes
            );
            for (workInProgress.child = renderLanes; renderLanes; )
              (renderLanes.flags = (renderLanes.flags & -3) | 4096),
                (renderLanes = renderLanes.sibling);
          }
        else {
          resetHydrationState();
          if (props === $$typeof) {
            workInProgress = bailoutOnAlreadyFinishedWork(
              current,
              workInProgress,
              renderLanes
            );
            break a;
          }
          reconcileChildren(current, workInProgress, props, renderLanes);
        }
        workInProgress = workInProgress.child;
      }
      return workInProgress;
    case 26:
      return (
        markRef(current, workInProgress),
        null === current
          ? (renderLanes = getResource(
              workInProgress.type,
              null,
              workInProgress.pendingProps,
              null
            ))
            ? (workInProgress.memoizedState = renderLanes)
            : isHydrating ||
              ((renderLanes = workInProgress.type),
              (current = workInProgress.pendingProps),
              (props = getOwnerDocumentFromRootContainer(
                rootInstanceStackCursor.current
              ).createElement(renderLanes)),
              (props[internalInstanceKey] = workInProgress),
              (props[internalPropsKey] = current),
              setInitialProperties(props, renderLanes, current),
              markNodeAsHoistable(props),
              (workInProgress.stateNode = props))
          : (workInProgress.memoizedState = getResource(
              workInProgress.type,
              current.memoizedProps,
              workInProgress.pendingProps,
              current.memoizedState
            )),
        null
      );
    case 27:
      return (
        pushHostContext(workInProgress),
        null === current &&
          isHydrating &&
          ((props = workInProgress.stateNode =
            resolveSingletonInstance(
              workInProgress.type,
              workInProgress.pendingProps,
              rootInstanceStackCursor.current
            )),
          (hydrationParentFiber = workInProgress),
          (rootOrSingletonContext = !0),
          ($$typeof = nextHydratableInstance),
          isSingletonScope(workInProgress.type)
            ? ((previousHydratableOnEnteringScopedSingleton = $$typeof),
              (nextHydratableInstance = getNextHydratable(props.firstChild)))
            : (nextHydratableInstance = $$typeof)),
        reconcileChildren(
          current,
          workInProgress,
          workInProgress.pendingProps.children,
          renderLanes
        ),
        markRef(current, workInProgress),
        null === current && (workInProgress.flags |= 4194304),
        workInProgress.child
      );
    case 5:
      if (null === current && isHydrating) {
        if (($$typeof = props = nextHydratableInstance))
          (props = canHydrateInstance(
            props,
            workInProgress.type,
            workInProgress.pendingProps,
            rootOrSingletonContext
          )),
            null !== props
              ? ((workInProgress.stateNode = props),
                (hydrationParentFiber = workInProgress),
                (nextHydratableInstance = getNextHydratable(props.firstChild)),
                (rootOrSingletonContext = !1),
                ($$typeof = !0))
              : ($$typeof = !1);
        $$typeof || throwOnHydrationMismatch(workInProgress);
      }
      pushHostContext(workInProgress);
      $$typeof = workInProgress.type;
      prevState = workInProgress.pendingProps;
      nextState = null !== current ? current.memoizedProps : null;
      props = prevState.children;
      shouldSetTextContent($$typeof, prevState)
        ? (props = null)
        : null !== nextState &&
          shouldSetTextContent($$typeof, nextState) &&
          (workInProgress.flags |= 32);
      null !== workInProgress.memoizedState &&
        (($$typeof = renderWithHooks(
          current,
          workInProgress,
          TransitionAwareHostComponent,
          null,
          null,
          renderLanes
        )),
        (HostTransitionContext._currentValue = $$typeof));
      markRef(current, workInProgress);
      reconcileChildren(current, workInProgress, props, renderLanes);
      return workInProgress.child;
    case 6:
      if (null === current && isHydrating) {
        if ((current = renderLanes = nextHydratableInstance))
          (renderLanes = canHydrateTextInstance(
            renderLanes,
            workInProgress.pendingProps,
            rootOrSingletonContext
          )),
            null !== renderLanes
              ? ((workInProgress.stateNode = renderLanes),
                (hydrationParentFiber = workInProgress),
                (nextHydratableInstance = null),
                (current = !0))
              : (current = !1);
        current || throwOnHydrationMismatch(workInProgress);
      }
      return null;
    case 13:
      return updateSuspenseComponent(current, workInProgress, renderLanes);
    case 4:
      return (
        pushHostContainer(
          workInProgress,
          workInProgress.stateNode.containerInfo
        ),
        (props = workInProgress.pendingProps),
        null === current
          ? (workInProgress.child = reconcileChildFibers(
              workInProgress,
              null,
              props,
              renderLanes
            ))
          : reconcileChildren(current, workInProgress, props, renderLanes),
        workInProgress.child
      );
    case 11:
      return updateForwardRef(
        current,
        workInProgress,
        workInProgress.type,
        workInProgress.pendingProps,
        renderLanes
      );
    case 7:
      return (
        reconcileChildren(
          current,
          workInProgress,
          workInProgress.pendingProps,
          renderLanes
        ),
        workInProgress.child
      );
    case 8:
      return (
        reconcileChildren(
          current,
          workInProgress,
          workInProgress.pendingProps.children,
          renderLanes
        ),
        workInProgress.child
      );
    case 12:
      return (
        reconcileChildren(
          current,
          workInProgress,
          workInProgress.pendingProps.children,
          renderLanes
        ),
        workInProgress.child
      );
    case 10:
      return (
        (props = workInProgress.pendingProps),
        pushProvider(workInProgress, workInProgress.type, props.value),
        reconcileChildren(current, workInProgress, props.children, renderLanes),
        workInProgress.child
      );
    case 9:
      return (
        ($$typeof = workInProgress.type._context),
        (props = workInProgress.pendingProps.children),
        prepareToReadContext(workInProgress),
        ($$typeof = readContext($$typeof)),
        (props = props($$typeof)),
        (workInProgress.flags |= 1),
        reconcileChildren(current, workInProgress, props, renderLanes),
        workInProgress.child
      );
    case 14:
      return updateMemoComponent(
        current,
        workInProgress,
        workInProgress.type,
        workInProgress.pendingProps,
        renderLanes
      );
    case 15:
      return updateSimpleMemoComponent(
        current,
        workInProgress,
        workInProgress.type,
        workInProgress.pendingProps,
        renderLanes
      );
    case 19:
      return updateSuspenseListComponent(current, workInProgress, renderLanes);
    case 31:
      return updateActivityComponent(current, workInProgress, renderLanes);
    case 22:
      return updateOffscreenComponent(
        current,
        workInProgress,
        renderLanes,
        workInProgress.pendingProps
      );
    case 24:
      return (
        prepareToReadContext(workInProgress),
        (props = readContext(CacheContext)),
        null === current
          ? (($$typeof = peekCacheFromPool()),
            null === $$typeof &&
              (($$typeof = workInProgressRoot),
              (prevState = createCache()),
              ($$typeof.pooledCache = prevState),
              prevState.refCount++,
              null !== prevState && ($$typeof.pooledCacheLanes |= renderLanes),
              ($$typeof = prevState)),
            (workInProgress.memoizedState = { parent: props, cache: $$typeof }),
            initializeUpdateQueue(workInProgress),
            pushProvider(workInProgress, CacheContext, $$typeof))
          : (0 !== (current.lanes & renderLanes) &&
              (cloneUpdateQueue(current, workInProgress),
              processUpdateQueue(workInProgress, null, null, renderLanes),
              suspendIfUpdateReadFromEntangledAsyncAction()),
            ($$typeof = current.memoizedState),
            (prevState = workInProgress.memoizedState),
            $$typeof.parent !== props
              ? (($$typeof = { parent: props, cache: props }),
                (workInProgress.memoizedState = $$typeof),
                0 === workInProgress.lanes &&
                  (workInProgress.memoizedState =
                    workInProgress.updateQueue.baseState =
                      $$typeof),
                pushProvider(workInProgress, CacheContext, props))
              : ((props = prevState.cache),
                pushProvider(workInProgress, CacheContext, props),
                props !== $$typeof.cache &&
                  propagateContextChanges(
                    workInProgress,
                    [CacheContext],
                    renderLanes,
                    !0
                  ))),
        reconcileChildren(
          current,
          workInProgress,
          workInProgress.pendingProps.children,
          renderLanes
        ),
        workInProgress.child
      );
    case 29:
      throw workInProgress.pendingProps;
  }
  throw Error(formatProdErrorMessage(156, workInProgress.tag));
}
function markUpdate(workInProgress) {
  workInProgress.flags |= 4;
}
function preloadInstanceAndSuspendIfNeeded(
  workInProgress,
  type,
  oldProps,
  newProps,
  renderLanes
) {
  if ((type = 0 !== (workInProgress.mode & 32))) type = !1;
  if (type) {
    if (
      ((workInProgress.flags |= 16777216),
      (renderLanes & 335544128) === renderLanes)
    )
      if (workInProgress.stateNode.complete) workInProgress.flags |= 8192;
      else if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;
      else
        throw (
          ((suspendedThenable = noopSuspenseyCommitThenable),
          SuspenseyCommitException)
        );
  } else workInProgress.flags &= -16777217;
}
function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
  if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
    workInProgress.flags &= -16777217;
  else if (((workInProgress.flags |= 16777216), !preloadResource(resource)))
    if (shouldRemainOnPreviousScreen()) workInProgress.flags |= 8192;
    else
      throw (
        ((suspendedThenable = noopSuspenseyCommitThenable),
        SuspenseyCommitException)
      );
}
function scheduleRetryEffect(workInProgress, retryQueue) {
  null !== retryQueue && (workInProgress.flags |= 4);
  workInProgress.flags & 16384 &&
    ((retryQueue =
      22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),
    (workInProgress.lanes |= retryQueue),
    (workInProgressSuspendedRetryLanes |= retryQueue));
}
function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
  if (!isHydrating)
    switch (renderState.tailMode) {
      case "hidden":
        hasRenderedATailFallback = renderState.tail;
        for (var lastTailNode = null; null !== hasRenderedATailFallback; )
          null !== hasRenderedATailFallback.alternate &&
            (lastTailNode = hasRenderedATailFallback),
            (hasRenderedATailFallback = hasRenderedATailFallback.sibling);
        null === lastTailNode
          ? (renderState.tail = null)
          : (lastTailNode.sibling = null);
        break;
      case "collapsed":
        lastTailNode = renderState.tail;
        for (var lastTailNode$106 = null; null !== lastTailNode; )
          null !== lastTailNode.alternate && (lastTailNode$106 = lastTailNode),
            (lastTailNode = lastTailNode.sibling);
        null === lastTailNode$106
          ? hasRenderedATailFallback || null === renderState.tail
            ? (renderState.tail = null)
            : (renderState.tail.sibling = null)
          : (lastTailNode$106.sibling = null);
    }
}
function bubbleProperties(completedWork) {
  var didBailout =
      null !== completedWork.alternate &&
      completedWork.alternate.child === completedWork.child,
    newChildLanes = 0,
    subtreeFlags = 0;
  if (didBailout)
    for (var child$107 = completedWork.child; null !== child$107; )
      (newChildLanes |= child$107.lanes | child$107.childLanes),
        (subtreeFlags |= child$107.subtreeFlags & 65011712),
        (subtreeFlags |= child$107.flags & 65011712),
        (child$107.return = completedWork),
        (child$107 = child$107.sibling);
  else
    for (child$107 = completedWork.child; null !== child$107; )
      (newChildLanes |= child$107.lanes | child$107.childLanes),
        (subtreeFlags |= child$107.subtreeFlags),
        (subtreeFlags |= child$107.flags),
        (child$107.return = completedWork),
        (child$107 = child$107.sibling);
  completedWork.subtreeFlags |= subtreeFlags;
  completedWork.childLanes = newChildLanes;
  return didBailout;
}
function completeWork(current, workInProgress, renderLanes) {
  var newProps = workInProgress.pendingProps;
  popTreeContext(workInProgress);
  switch (workInProgress.tag) {
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return bubbleProperties(workInProgress), null;
    case 1:
      return bubbleProperties(workInProgress), null;
    case 3:
      renderLanes = workInProgress.stateNode;
      newProps = null;
      null !== current && (newProps = current.memoizedState.cache);
      workInProgress.memoizedState.cache !== newProps &&
        (workInProgress.flags |= 2048);
      popProvider(CacheContext);
      popHostContainer();
      renderLanes.pendingContext &&
        ((renderLanes.context = renderLanes.pendingContext),
        (renderLanes.pendingContext = null));
      if (null === current || null === current.child)
        popHydrationState(workInProgress)
          ? markUpdate(workInProgress)
          : null === current ||
            (current.memoizedState.isDehydrated &&
              0 === (workInProgress.flags & 256)) ||
            ((workInProgress.flags |= 1024),
            upgradeHydrationErrorsToRecoverable());
      bubbleProperties(workInProgress);
      return null;
    case 26:
      var type = workInProgress.type,
        nextResource = workInProgress.memoizedState;
      null === current
        ? (markUpdate(workInProgress),
          null !== nextResource
            ? (bubbleProperties(workInProgress),
              preloadResourceAndSuspendIfNeeded(workInProgress, nextResource))
            : (bubbleProperties(workInProgress),
              preloadInstanceAndSuspendIfNeeded(
                workInProgress,
                type,
                null,
                newProps,
                renderLanes
              )))
        : nextResource
          ? nextResource !== current.memoizedState
            ? (markUpdate(workInProgress),
              bubbleProperties(workInProgress),
              preloadResourceAndSuspendIfNeeded(workInProgress, nextResource))
            : (bubbleProperties(workInProgress),
              (workInProgress.flags &= -16777217))
          : ((current = current.memoizedProps),
            current !== newProps && markUpdate(workInProgress),
            bubbleProperties(workInProgress),
            preloadInstanceAndSuspendIfNeeded(
              workInProgress,
              type,
              current,
              newProps,
              renderLanes
            ));
      return null;
    case 27:
      popHostContext(workInProgress);
      renderLanes = rootInstanceStackCursor.current;
      type = workInProgress.type;
      if (null !== current && null != workInProgress.stateNode)
        current.memoizedProps !== newProps && markUpdate(workInProgress);
      else {
        if (!newProps) {
          if (null === workInProgress.stateNode)
            throw Error(formatProdErrorMessage(166));
          bubbleProperties(workInProgress);
          return null;
        }
        current = contextStackCursor.current;
        popHydrationState(workInProgress)
          ? prepareToHydrateHostInstance(workInProgress, current)
          : ((current = resolveSingletonInstance(type, newProps, renderLanes)),
            (workInProgress.stateNode = current),
            markUpdate(workInProgress));
      }
      bubbleProperties(workInProgress);
      return null;
    case 5:
      popHostContext(workInProgress);
      type = workInProgress.type;
      if (null !== current && null != workInProgress.stateNode)
        current.memoizedProps !== newProps && markUpdate(workInProgress);
      else {
        if (!newProps) {
          if (null === workInProgress.stateNode)
            throw Error(formatProdErrorMessage(166));
          bubbleProperties(workInProgress);
          return null;
        }
        nextResource = contextStackCursor.current;
        if (popHydrationState(workInProgress))
          prepareToHydrateHostInstance(workInProgress, nextResource);
        else {
          var ownerDocument = getOwnerDocumentFromRootContainer(
            rootInstanceStackCursor.current
          );
          switch (nextResource) {
            case 1:
              nextResource = ownerDocument.createElementNS(
                "http://www.w3.org/2000/svg",
                type
              );
              break;
            case 2:
              nextResource = ownerDocument.createElementNS(
                "http://www.w3.org/1998/Math/MathML",
                type
              );
              break;
            default:
              switch (type) {
                case "svg":
                  nextResource = ownerDocument.createElementNS(
                    "http://www.w3.org/2000/svg",
                    type
                  );
                  break;
                case "math":
                  nextResource = ownerDocument.createElementNS(
                    "http://www.w3.org/1998/Math/MathML",
                    type
                  );
                  break;
                case "script":
                  nextResource = ownerDocument.createElement("div");
                  nextResource.innerHTML = "<script>\x3c/script>";
                  nextResource = nextResource.removeChild(
                    nextResource.firstChild
                  );
                  break;
                case "select":
                  nextResource =
                    "string" === typeof newProps.is
                      ? ownerDocument.createElement("select", {
                          is: newProps.is
                        })
                      : ownerDocument.createElement("select");
                  newProps.multiple
                    ? (nextResource.multiple = !0)
                    : newProps.size && (nextResource.size = newProps.size);
                  break;
                default:
                  nextResource =
                    "string" === typeof newProps.is
                      ? ownerDocument.createElement(type, { is: newProps.is })
                      : ownerDocument.createElement(type);
              }
          }
          nextResource[internalInstanceKey] = workInProgress;
          nextResource[internalPropsKey] = newProps;
          a: for (
            ownerDocument = workInProgress.child;
            null !== ownerDocument;

          ) {
            if (5 === ownerDocument.tag || 6 === ownerDocument.tag)
              nextResource.appendChild(ownerDocument.stateNode);
            else if (
              4 !== ownerDocument.tag &&
              27 !== ownerDocument.tag &&
              null !== ownerDocument.child
            ) {
              ownerDocument.child.return = ownerDocument;
              ownerDocument = ownerDocument.child;
              continue;
            }
            if (ownerDocument === workInProgress) break a;
            for (; null === ownerDocument.sibling; ) {
              if (
                null === ownerDocument.return ||
                ownerDocument.return === workInProgress
              )
                break a;
              ownerDocument = ownerDocument.return;
            }
            ownerDocument.sibling.return = ownerDocument.return;
            ownerDocument = ownerDocument.sibling;
          }
          workInProgress.stateNode = nextResource;
          a: switch (
            (setInitialProperties(nextResource, type, newProps), type)
          ) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              newProps = !!newProps.autoFocus;
              break a;
            case "img":
              newProps = !0;
              break a;
            default:
              newProps = !1;
          }
          newProps && markUpdate(workInProgress);
        }
      }
      bubbleProperties(workInProgress);
      preloadInstanceAndSuspendIfNeeded(
        workInProgress,
        workInProgress.type,
        null === current ? null : current.memoizedProps,
        workInProgress.pendingProps,
        renderLanes
      );
      return null;
    case 6:
      if (current && null != workInProgress.stateNode)
        current.memoizedProps !== newProps && markUpdate(workInProgress);
      else {
        if ("string" !== typeof newProps && null === workInProgress.stateNode)
          throw Error(formatProdErrorMessage(166));
        current = rootInstanceStackCursor.current;
        if (popHydrationState(workInProgress)) {
          current = workInProgress.stateNode;
          renderLanes = workInProgress.memoizedProps;
          newProps = null;
          type = hydrationParentFiber;
          if (null !== type)
            switch (type.tag) {
              case 27:
              case 5:
                newProps = type.memoizedProps;
            }
          current[internalInstanceKey] = workInProgress;
          current =
            current.nodeValue === renderLanes ||
            (null !== newProps && !0 === newProps.suppressHydrationWarning) ||
            checkForUnmatchedText(current.nodeValue, renderLanes)
              ? !0
              : !1;
          current || throwOnHydrationMismatch(workInProgress, !0);
        } else
          (current =
            getOwnerDocumentFromRootContainer(current).createTextNode(
              newProps
            )),
            (current[internalInstanceKey] = workInProgress),
            (workInProgress.stateNode = current);
      }
      bubbleProperties(workInProgress);
      return null;
    case 31:
      renderLanes = workInProgress.memoizedState;
      if (null === current || null !== current.memoizedState) {
        newProps = popHydrationState(workInProgress);
        if (null !== renderLanes) {
          if (null === current) {
            if (!newProps) throw Error(formatProdErrorMessage(318));
            current = workInProgress.memoizedState;
            current = null !== current ? current.dehydrated : null;
            if (!current) throw Error(formatProdErrorMessage(557));
            current[internalInstanceKey] = workInProgress;
          } else
            resetHydrationState(),
              0 === (workInProgress.flags & 128) &&
                (workInProgress.memoizedState = null),
              (workInProgress.flags |= 4);
          bubbleProperties(workInProgress);
          current = !1;
        } else
          (renderLanes = upgradeHydrationErrorsToRecoverable()),
            null !== current &&
              null !== current.memoizedState &&
              (current.memoizedState.hydrationErrors = renderLanes),
            (current = !0);
        if (!current) {
          if (workInProgress.flags & 256)
            return popSuspenseHandler(workInProgress), workInProgress;
          popSuspenseHandler(workInProgress);
          return null;
        }
        if (0 !== (workInProgress.flags & 128))
          throw Error(formatProdErrorMessage(558));
      }
      bubbleProperties(workInProgress);
      return null;
    case 13:
      newProps = workInProgress.memoizedState;
      if (
        null === current ||
        (null !== current.memoizedState &&
          null !== current.memoizedState.dehydrated)
      ) {
        type = popHydrationState(workInProgress);
        if (null !== newProps && null !== newProps.dehydrated) {
          if (null === current) {
            if (!type) throw Error(formatProdErrorMessage(318));
            type = workInProgress.memoizedState;
            type = null !== type ? type.dehydrated : null;
            if (!type) throw Error(formatProdErrorMessage(317));
            type[internalInstanceKey] = workInProgress;
          } else
            resetHydrationState(),
              0 === (workInProgress.flags & 128) &&
                (workInProgress.memoizedState = null),
              (workInProgress.flags |= 4);
          bubbleProperties(workInProgress);
          type = !1;
        } else
          (type = upgradeHydrationErrorsToRecoverable()),
            null !== current &&
              null !== current.memoizedState &&
              (current.memoizedState.hydrationErrors = type),
            (type = !0);
        if (!type) {
          if (workInProgress.flags & 256)
            return popSuspenseHandler(workInProgress), workInProgress;
          popSuspenseHandler(workInProgress);
          return null;
        }
      }
      popSuspenseHandler(workInProgress);
      if (0 !== (workInProgress.flags & 128))
        return (workInProgress.lanes = renderLanes), workInProgress;
      renderLanes = null !== newProps;
      current = null !== current && null !== current.memoizedState;
      renderLanes &&
        ((newProps = workInProgress.child),
        (type = null),
        null !== newProps.alternate &&
          null !== newProps.alternate.memoizedState &&
          null !== newProps.alternate.memoizedState.cachePool &&
          (type = newProps.alternate.memoizedState.cachePool.pool),
        (nextResource = null),
        null !== newProps.memoizedState &&
          null !== newProps.memoizedState.cachePool &&
          (nextResource = newProps.memoizedState.cachePool.pool),
        nextResource !== type && (newProps.flags |= 2048));
      renderLanes !== current &&
        renderLanes &&
        (workInProgress.child.flags |= 8192);
      scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
      bubbleProperties(workInProgress);
      return null;
    case 4:
      return (
        popHostContainer(),
        null === current &&
          listenToAllSupportedEvents(workInProgress.stateNode.containerInfo),
        bubbleProperties(workInProgress),
        null
      );
    case 10:
      return (
        popProvider(workInProgress.type), bubbleProperties(workInProgress), null
      );
    case 19:
      pop(suspenseStackCursor);
      newProps = workInProgress.memoizedState;
      if (null === newProps) return bubbleProperties(workInProgress), null;
      type = 0 !== (workInProgress.flags & 128);
      nextResource = newProps.rendering;
      if (null === nextResource)
        if (type) cutOffTailIfNeeded(newProps, !1);
        else {
          if (
            0 !== workInProgressRootExitStatus ||
            (null !== current && 0 !== (current.flags & 128))
          )
            for (current = workInProgress.child; null !== current; ) {
              nextResource = findFirstSuspended(current);
              if (null !== nextResource) {
                workInProgress.flags |= 128;
                cutOffTailIfNeeded(newProps, !1);
                current = nextResource.updateQueue;
                workInProgress.updateQueue = current;
                scheduleRetryEffect(workInProgress, current);
                workInProgress.subtreeFlags = 0;
                current = renderLanes;
                for (renderLanes = workInProgress.child; null !== renderLanes; )
                  resetWorkInProgress(renderLanes, current),
                    (renderLanes = renderLanes.sibling);
                push(
                  suspenseStackCursor,
                  (suspenseStackCursor.current & 1) | 2
                );
                isHydrating &&
                  pushTreeFork(workInProgress, newProps.treeForkCount);
                return workInProgress.child;
              }
              current = current.sibling;
            }
          null !== newProps.tail &&
            now() > workInProgressRootRenderTargetTime &&
            ((workInProgress.flags |= 128),
            (type = !0),
            cutOffTailIfNeeded(newProps, !1),
            (workInProgress.lanes = 4194304));
        }
      else {
        if (!type)
          if (
            ((current = findFirstSuspended(nextResource)), null !== current)
          ) {
            if (
              ((workInProgress.flags |= 128),
              (type = !0),
              (current = current.updateQueue),
              (workInProgress.updateQueue = current),
              scheduleRetryEffect(workInProgress, current),
              cutOffTailIfNeeded(newProps, !0),
              null === newProps.tail &&
                "hidden" === newProps.tailMode &&
                !nextResource.alternate &&
                !isHydrating)
            )
              return bubbleProperties(workInProgress), null;
          } else
            2 * now() - newProps.renderingStartTime >
              workInProgressRootRenderTargetTime &&
              536870912 !== renderLanes &&
              ((workInProgress.flags |= 128),
              (type = !0),
              cutOffTailIfNeeded(newProps, !1),
              (workInProgress.lanes = 4194304));
        newProps.isBackwards
          ? ((nextResource.sibling = workInProgress.child),
            (workInProgress.child = nextResource))
          : ((current = newProps.last),
            null !== current
              ? (current.sibling = nextResource)
              : (workInProgress.child = nextResource),
            (newProps.last = nextResource));
      }
      if (null !== newProps.tail)
        return (
          (current = newProps.tail),
          (newProps.rendering = current),
          (newProps.tail = current.sibling),
          (newProps.renderingStartTime = now()),
          (current.sibling = null),
          (renderLanes = suspenseStackCursor.current),
          push(
            suspenseStackCursor,
            type ? (renderLanes & 1) | 2 : renderLanes & 1
          ),
          isHydrating && pushTreeFork(workInProgress, newProps.treeForkCount),
          current
        );
      bubbleProperties(workInProgress);
      return null;
    case 22:
    case 23:
      return (
        popSuspenseHandler(workInProgress),
        popHiddenContext(),
        (newProps = null !== workInProgress.memoizedState),
        null !== current
          ? (null !== current.memoizedState) !== newProps &&
            (workInProgress.flags |= 8192)
          : newProps && (workInProgress.flags |= 8192),
        newProps
          ? 0 !== (renderLanes & 536870912) &&
            0 === (workInProgress.flags & 128) &&
            (bubbleProperties(workInProgress),
            workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192))
          : bubbleProperties(workInProgress),
        (renderLanes = workInProgress.updateQueue),
        null !== renderLanes &&
          scheduleRetryEffect(workInProgress, renderLanes.retryQueue),
        (renderLanes = null),
        null !== current &&
          null !== current.memoizedState &&
          null !== current.memoizedState.cachePool &&
          (renderLanes = current.memoizedState.cachePool.pool),
        (newProps = null),
        null !== workInProgress.memoizedState &&
          null !== workInProgress.memoizedState.cachePool &&
          (newProps = workInProgress.memoizedState.cachePool.pool),
        newProps !== renderLanes && (workInProgress.flags |= 2048),
        null !== current && pop(resumedCache),
        null
      );
    case 24:
      return (
        (renderLanes = null),
        null !== current && (renderLanes = current.memoizedState.cache),
        workInProgress.memoizedState.cache !== renderLanes &&
          (workInProgress.flags |= 2048),
        popProvider(CacheContext),
        bubbleProperties(workInProgress),
        null
      );
    case 25:
      return null;
    case 30:
      return null;
  }
  throw Error(formatProdErrorMessage(156, workInProgress.tag));
}
function unwindWork(current, workInProgress) {
  popTreeContext(workInProgress);
  switch (workInProgress.tag) {
    case 1:
      return (
        (current = workInProgress.flags),
        current & 65536
          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
          : null
      );
    case 3:
      return (
        popProvider(CacheContext),
        popHostContainer(),
        (current = workInProgress.flags),
        0 !== (current & 65536) && 0 === (current & 128)
          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
          : null
      );
    case 26:
    case 27:
    case 5:
      return popHostContext(workInProgress), null;
    case 31:
      if (null !== workInProgress.memoizedState) {
        popSuspenseHandler(workInProgress);
        if (null === workInProgress.alternate)
          throw Error(formatProdErrorMessage(340));
        resetHydrationState();
      }
      current = workInProgress.flags;
      return current & 65536
        ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
        : null;
    case 13:
      popSuspenseHandler(workInProgress);
      current = workInProgress.memoizedState;
      if (null !== current && null !== current.dehydrated) {
        if (null === workInProgress.alternate)
          throw Error(formatProdErrorMessage(340));
        resetHydrationState();
      }
      current = workInProgress.flags;
      return current & 65536
        ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
        : null;
    case 19:
      return pop(suspenseStackCursor), null;
    case 4:
      return popHostContainer(), null;
    case 10:
      return popProvider(workInProgress.type), null;
    case 22:
    case 23:
      return (
        popSuspenseHandler(workInProgress),
        popHiddenContext(),
        null !== current && pop(resumedCache),
        (current = workInProgress.flags),
        current & 65536
          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
          : null
      );
    case 24:
      return popProvider(CacheContext), null;
    case 25:
      return null;
    default:
      return null;
  }
}
function unwindInterruptedWork(current, interruptedWork) {
  popTreeContext(interruptedWork);
  switch (interruptedWork.tag) {
    case 3:
      popProvider(CacheContext);
      popHostContainer();
      break;
    case 26:
    case 27:
    case 5:
      popHostContext(interruptedWork);
      break;
    case 4:
      popHostContainer();
      break;
    case 31:
      null !== interruptedWork.memoizedState &&
        popSuspenseHandler(interruptedWork);
      break;
    case 13:
      popSuspenseHandler(interruptedWork);
      break;
    case 19:
      pop(suspenseStackCursor);
      break;
    case 10:
      popProvider(interruptedWork.type);
      break;
    case 22:
    case 23:
      popSuspenseHandler(interruptedWork);
      popHiddenContext();
      null !== current && pop(resumedCache);
      break;
    case 24:
      popProvider(CacheContext);
  }
}
function commitHookEffectListMount(flags, finishedWork) {
  try {
    var updateQueue = finishedWork.updateQueue,
      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
    if (null !== lastEffect) {
      var firstEffect = lastEffect.next;
      updateQueue = firstEffect;
      do {
        if ((updateQueue.tag & flags) === flags) {
          lastEffect = void 0;
          var create = updateQueue.create,
            inst = updateQueue.inst;
          lastEffect = create();
          inst.destroy = lastEffect;
        }
        updateQueue = updateQueue.next;
      } while (updateQueue !== firstEffect);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHookEffectListUnmount(
  flags,
  finishedWork,
  nearestMountedAncestor$jscomp$0
) {
  try {
    var updateQueue = finishedWork.updateQueue,
      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
    if (null !== lastEffect) {
      var firstEffect = lastEffect.next;
      updateQueue = firstEffect;
      do {
        if ((updateQueue.tag & flags) === flags) {
          var inst = updateQueue.inst,
            destroy = inst.destroy;
          if (void 0 !== destroy) {
            inst.destroy = void 0;
            lastEffect = finishedWork;
            var nearestMountedAncestor = nearestMountedAncestor$jscomp$0,
              destroy_ = destroy;
            try {
              destroy_();
            } catch (error) {
              captureCommitPhaseError(
                lastEffect,
                nearestMountedAncestor,
                error
              );
            }
          }
        }
        updateQueue = updateQueue.next;
      } while (updateQueue !== firstEffect);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitClassCallbacks(finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  if (null !== updateQueue) {
    var instance = finishedWork.stateNode;
    try {
      commitCallbacks(updateQueue, instance);
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
}
function safelyCallComponentWillUnmount(
  current,
  nearestMountedAncestor,
  instance
) {
  instance.props = resolveClassComponentProps(
    current.type,
    current.memoizedProps
  );
  instance.state = current.memoizedState;
  try {
    instance.componentWillUnmount();
  } catch (error) {
    captureCommitPhaseError(current, nearestMountedAncestor, error);
  }
}
function safelyAttachRef(current, nearestMountedAncestor) {
  try {
    var ref = current.ref;
    if (null !== ref) {
      switch (current.tag) {
        case 26:
        case 27:
        case 5:
          var instanceToUse = current.stateNode;
          break;
        case 30:
          instanceToUse = current.stateNode;
          break;
        default:
          instanceToUse = current.stateNode;
      }
      "function" === typeof ref
        ? (current.refCleanup = ref(instanceToUse))
        : (ref.current = instanceToUse);
    }
  } catch (error) {
    captureCommitPhaseError(current, nearestMountedAncestor, error);
  }
}
function safelyDetachRef(current, nearestMountedAncestor) {
  var ref = current.ref,
    refCleanup = current.refCleanup;
  if (null !== ref)
    if ("function" === typeof refCleanup)
      try {
        refCleanup();
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      } finally {
        (current.refCleanup = null),
          (current = current.alternate),
          null != current && (current.refCleanup = null);
      }
    else if ("function" === typeof ref)
      try {
        ref(null);
      } catch (error$140) {
        captureCommitPhaseError(current, nearestMountedAncestor, error$140);
      }
    else ref.current = null;
}
function commitHostMount(finishedWork) {
  var type = finishedWork.type,
    props = finishedWork.memoizedProps,
    instance = finishedWork.stateNode;
  try {
    a: switch (type) {
      case "button":
      case "input":
      case "select":
      case "textarea":
        props.autoFocus && instance.focus();
        break a;
      case "img":
        props.src
          ? (instance.src = props.src)
          : props.srcSet && (instance.srcset = props.srcSet);
    }
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function commitHostUpdate(finishedWork, newProps, oldProps) {
  try {
    var domElement = finishedWork.stateNode;
    updateProperties(domElement, finishedWork.type, oldProps, newProps);
    domElement[internalPropsKey] = newProps;
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
function isHostParent(fiber) {
  return (
    5 === fiber.tag ||
    3 === fiber.tag ||
    26 === fiber.tag ||
    (27 === fiber.tag && isSingletonScope(fiber.type)) ||
    4 === fiber.tag
  );
}
function getHostSibling(fiber) {
  a: for (;;) {
    for (; null === fiber.sibling; ) {
      if (null === fiber.return || isHostParent(fiber.return)) return null;
      fiber = fiber.return;
    }
    fiber.sibling.return = fiber.return;
    for (
      fiber = fiber.sibling;
      5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;

    ) {
      if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
      if (fiber.flags & 2) continue a;
      if (null === fiber.child || 4 === fiber.tag) continue a;
      else (fiber.child.return = fiber), (fiber = fiber.child);
    }
    if (!(fiber.flags & 2)) return fiber.stateNode;
  }
}
function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
  var tag = node.tag;
  if (5 === tag || 6 === tag)
    (node = node.stateNode),
      before
        ? (9 === parent.nodeType
            ? parent.body
            : "HTML" === parent.nodeName
              ? parent.ownerDocument.body
              : parent
          ).insertBefore(node, before)
        : ((before =
            9 === parent.nodeType
              ? parent.body
              : "HTML" === parent.nodeName
                ? parent.ownerDocument.body
                : parent),
          before.appendChild(node),
          (parent = parent._reactRootContainer),
          (null !== parent && void 0 !== parent) ||
            null !== before.onclick ||
            (before.onclick = noop$1));
  else if (
    4 !== tag &&
    (27 === tag &&
      isSingletonScope(node.type) &&
      ((parent = node.stateNode), (before = null)),
    (node = node.child),
    null !== node)
  )
    for (
      insertOrAppendPlacementNodeIntoContainer(node, before, parent),
        node = node.sibling;
      null !== node;

    )
      insertOrAppendPlacementNodeIntoContainer(node, before, parent),
        (node = node.sibling);
}
function insertOrAppendPlacementNode(node, before, parent) {
  var tag = node.tag;
  if (5 === tag || 6 === tag)
    (node = node.stateNode),
      before ? parent.insertBefore(node, before) : parent.appendChild(node);
  else if (
    4 !== tag &&
    (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode),
    (node = node.child),
    null !== node)
  )
    for (
      insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
      null !== node;

    )
      insertOrAppendPlacementNode(node, before, parent), (node = node.sibling);
}
function commitHostSingletonAcquisition(finishedWork) {
  var singleton = finishedWork.stateNode,
    props = finishedWork.memoizedProps;
  try {
    for (
      var type = finishedWork.type, attributes = singleton.attributes;
      attributes.length;

    )
      singleton.removeAttributeNode(attributes[0]);
    setInitialProperties(singleton, type, props);
    singleton[internalInstanceKey] = finishedWork;
    singleton[internalPropsKey] = props;
  } catch (error) {
    captureCommitPhaseError(finishedWork, finishedWork.return, error);
  }
}
var offscreenSubtreeIsHidden = !1,
  offscreenSubtreeWasHidden = !1,
  needsFormReset = !1,
  PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
  nextEffect = null;
function commitBeforeMutationEffects(root, firstChild) {
  root = root.containerInfo;
  eventsEnabled = _enabled;
  root = getActiveElementDeep(root);
  if (hasSelectionCapabilities(root)) {
    if ("selectionStart" in root)
      var JSCompiler_temp = {
        start: root.selectionStart,
        end: root.selectionEnd
      };
    else
      a: {
        JSCompiler_temp =
          ((JSCompiler_temp = root.ownerDocument) &&
            JSCompiler_temp.defaultView) ||
          window;
        var selection =
          JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
        if (selection && 0 !== selection.rangeCount) {
          JSCompiler_temp = selection.anchorNode;
          var anchorOffset = selection.anchorOffset,
            focusNode = selection.focusNode;
          selection = selection.focusOffset;
          try {
            JSCompiler_temp.nodeType, focusNode.nodeType;
          } catch (e$20) {
            JSCompiler_temp = null;
            break a;
          }
          var length = 0,
            start = -1,
            end = -1,
            indexWithinAnchor = 0,
            indexWithinFocus = 0,
            node = root,
            parentNode = null;
          b: for (;;) {
            for (var next; ; ) {
              node !== JSCompiler_temp ||
                (0 !== anchorOffset && 3 !== node.nodeType) ||
                (start = length + anchorOffset);
              node !== focusNode ||
                (0 !== selection && 3 !== node.nodeType) ||
                (end = length + selection);
              3 === node.nodeType && (length += node.nodeValue.length);
              if (null === (next = node.firstChild)) break;
              parentNode = node;
              node = next;
            }
            for (;;) {
              if (node === root) break b;
              parentNode === JSCompiler_temp &&
                ++indexWithinAnchor === anchorOffset &&
                (start = length);
              parentNode === focusNode &&
                ++indexWithinFocus === selection &&
                (end = length);
              if (null !== (next = node.nextSibling)) break;
              node = parentNode;
              parentNode = node.parentNode;
            }
            node = next;
          }
          JSCompiler_temp =
            -1 === start || -1 === end ? null : { start: start, end: end };
        } else JSCompiler_temp = null;
      }
    JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
  } else JSCompiler_temp = null;
  selectionInformation = { focusedElem: root, selectionRange: JSCompiler_temp };
  _enabled = !1;
  for (nextEffect = firstChild; null !== nextEffect; )
    if (
      ((firstChild = nextEffect),
      (root = firstChild.child),
      0 !== (firstChild.subtreeFlags & 1028) && null !== root)
    )
      (root.return = firstChild), (nextEffect = root);
    else
      for (; null !== nextEffect; ) {
        firstChild = nextEffect;
        focusNode = firstChild.alternate;
        root = firstChild.flags;
        switch (firstChild.tag) {
          case 0:
            if (
              0 !== (root & 4) &&
              ((root = firstChild.updateQueue),
              (root = null !== root ? root.events : null),
              null !== root)
            )
              for (
                JSCompiler_temp = 0;
                JSCompiler_temp < root.length;
                JSCompiler_temp++
              )
                (anchorOffset = root[JSCompiler_temp]),
                  (anchorOffset.ref.impl = anchorOffset.nextImpl);
            break;
          case 11:
          case 15:
            break;
          case 1:
            if (0 !== (root & 1024) && null !== focusNode) {
              root = void 0;
              JSCompiler_temp = firstChild;
              anchorOffset = focusNode.memoizedProps;
              focusNode = focusNode.memoizedState;
              selection = JSCompiler_temp.stateNode;
              try {
                var resolvedPrevProps = resolveClassComponentProps(
                  JSCompiler_temp.type,
                  anchorOffset
                );
                root = selection.getSnapshotBeforeUpdate(
                  resolvedPrevProps,
                  focusNode
                );
                selection.__reactInternalSnapshotBeforeUpdate = root;
              } catch (error) {
                captureCommitPhaseError(
                  JSCompiler_temp,
                  JSCompiler_temp.return,
                  error
                );
              }
            }
            break;
          case 3:
            if (0 !== (root & 1024))
              if (
                ((root = firstChild.stateNode.containerInfo),
                (JSCompiler_temp = root.nodeType),
                9 === JSCompiler_temp)
              )
                clearContainerSparingly(root);
              else if (1 === JSCompiler_temp)
                switch (root.nodeName) {
                  case "HEAD":
                  case "HTML":
                  case "BODY":
                    clearContainerSparingly(root);
                    break;
                  default:
                    root.textContent = "";
                }
            break;
          case 5:
          case 26:
          case 27:
          case 6:
          case 4:
          case 17:
            break;
          default:
            if (0 !== (root & 1024)) throw Error(formatProdErrorMessage(163));
        }
        root = firstChild.sibling;
        if (null !== root) {
          root.return = firstChild.return;
          nextEffect = root;
          break;
        }
        nextEffect = firstChild.return;
      }
}
function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
  var flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 15:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      flags & 4 && commitHookEffectListMount(5, finishedWork);
      break;
    case 1:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      if (flags & 4)
        if (((finishedRoot = finishedWork.stateNode), null === current))
          try {
            finishedRoot.componentDidMount();
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        else {
          var prevProps = resolveClassComponentProps(
            finishedWork.type,
            current.memoizedProps
          );
          current = current.memoizedState;
          try {
            finishedRoot.componentDidUpdate(
              prevProps,
              current,
              finishedRoot.__reactInternalSnapshotBeforeUpdate
            );
          } catch (error$139) {
            captureCommitPhaseError(
              finishedWork,
              finishedWork.return,
              error$139
            );
          }
        }
      flags & 64 && commitClassCallbacks(finishedWork);
      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
      break;
    case 3:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      if (
        flags & 64 &&
        ((finishedRoot = finishedWork.updateQueue), null !== finishedRoot)
      ) {
        current = null;
        if (null !== finishedWork.child)
          switch (finishedWork.child.tag) {
            case 27:
            case 5:
              current = finishedWork.child.stateNode;
              break;
            case 1:
              current = finishedWork.child.stateNode;
          }
        try {
          commitCallbacks(finishedRoot, current);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      break;
    case 27:
      null === current &&
        flags & 4 &&
        commitHostSingletonAcquisition(finishedWork);
    case 26:
    case 5:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      null === current && flags & 4 && commitHostMount(finishedWork);
      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
      break;
    case 12:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      break;
    case 31:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
      break;
    case 13:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
      flags & 64 &&
        ((finishedRoot = finishedWork.memoizedState),
        null !== finishedRoot &&
          ((finishedRoot = finishedRoot.dehydrated),
          null !== finishedRoot &&
            ((finishedWork = retryDehydratedSuspenseBoundary.bind(
              null,
              finishedWork
            )),
            registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
      break;
    case 22:
      flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
      if (!flags) {
        current =
          (null !== current && null !== current.memoizedState) ||
          offscreenSubtreeWasHidden;
        prevProps = offscreenSubtreeIsHidden;
        var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
        offscreenSubtreeIsHidden = flags;
        (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden
          ? recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              0 !== (finishedWork.subtreeFlags & 8772)
            )
          : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        offscreenSubtreeIsHidden = prevProps;
        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
      }
      break;
    case 30:
      break;
    default:
      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
  }
}
function detachFiberAfterEffects(fiber) {
  var alternate = fiber.alternate;
  null !== alternate &&
    ((fiber.alternate = null), detachFiberAfterEffects(alternate));
  fiber.child = null;
  fiber.deletions = null;
  fiber.sibling = null;
  5 === fiber.tag &&
    ((alternate = fiber.stateNode),
    null !== alternate && detachDeletedInstance(alternate));
  fiber.stateNode = null;
  fiber.return = null;
  fiber.dependencies = null;
  fiber.memoizedProps = null;
  fiber.memoizedState = null;
  fiber.pendingProps = null;
  fiber.stateNode = null;
  fiber.updateQueue = null;
}
var hostParent = null,
  hostParentIsContainer = !1;
function recursivelyTraverseDeletionEffects(
  finishedRoot,
  nearestMountedAncestor,
  parent
) {
  for (parent = parent.child; null !== parent; )
    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent),
      (parent = parent.sibling);
}
function commitDeletionEffectsOnFiber(
  finishedRoot,
  nearestMountedAncestor,
  deletedFiber
) {
  if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
    try {
      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
    } catch (err) {}
  switch (deletedFiber.tag) {
    case 26:
      offscreenSubtreeWasHidden ||
        safelyDetachRef(deletedFiber, nearestMountedAncestor);
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      deletedFiber.memoizedState
        ? deletedFiber.memoizedState.count--
        : deletedFiber.stateNode &&
          ((deletedFiber = deletedFiber.stateNode),
          deletedFiber.parentNode.removeChild(deletedFiber));
      break;
    case 27:
      offscreenSubtreeWasHidden ||
        safelyDetachRef(deletedFiber, nearestMountedAncestor);
      var prevHostParent = hostParent,
        prevHostParentIsContainer = hostParentIsContainer;
      isSingletonScope(deletedFiber.type) &&
        ((hostParent = deletedFiber.stateNode), (hostParentIsContainer = !1));
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      releaseSingletonInstance(deletedFiber.stateNode);
      hostParent = prevHostParent;
      hostParentIsContainer = prevHostParentIsContainer;
      break;
    case 5:
      offscreenSubtreeWasHidden ||
        safelyDetachRef(deletedFiber, nearestMountedAncestor);
    case 6:
      prevHostParent = hostParent;
      prevHostParentIsContainer = hostParentIsContainer;
      hostParent = null;
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      hostParent = prevHostParent;
      hostParentIsContainer = prevHostParentIsContainer;
      if (null !== hostParent)
        if (hostParentIsContainer)
          try {
            (9 === hostParent.nodeType
              ? hostParent.body
              : "HTML" === hostParent.nodeName
                ? hostParent.ownerDocument.body
                : hostParent
            ).removeChild(deletedFiber.stateNode);
          } catch (error) {
            captureCommitPhaseError(
              deletedFiber,
              nearestMountedAncestor,
              error
            );
          }
        else
          try {
            hostParent.removeChild(deletedFiber.stateNode);
          } catch (error) {
            captureCommitPhaseError(
              deletedFiber,
              nearestMountedAncestor,
              error
            );
          }
      break;
    case 18:
      null !== hostParent &&
        (hostParentIsContainer
          ? ((finishedRoot = hostParent),
            clearHydrationBoundary(
              9 === finishedRoot.nodeType
                ? finishedRoot.body
                : "HTML" === finishedRoot.nodeName
                  ? finishedRoot.ownerDocument.body
                  : finishedRoot,
              deletedFiber.stateNode
            ),
            retryIfBlockedOn(finishedRoot))
          : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
      break;
    case 4:
      prevHostParent = hostParent;
      prevHostParentIsContainer = hostParentIsContainer;
      hostParent = deletedFiber.stateNode.containerInfo;
      hostParentIsContainer = !0;
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      hostParent = prevHostParent;
      hostParentIsContainer = prevHostParentIsContainer;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
      offscreenSubtreeWasHidden ||
        commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      break;
    case 1:
      offscreenSubtreeWasHidden ||
        (safelyDetachRef(deletedFiber, nearestMountedAncestor),
        (prevHostParent = deletedFiber.stateNode),
        "function" === typeof prevHostParent.componentWillUnmount &&
          safelyCallComponentWillUnmount(
            deletedFiber,
            nearestMountedAncestor,
            prevHostParent
          ));
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      break;
    case 21:
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      break;
    case 22:
      offscreenSubtreeWasHidden =
        (prevHostParent = offscreenSubtreeWasHidden) ||
        null !== deletedFiber.memoizedState;
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
      offscreenSubtreeWasHidden = prevHostParent;
      break;
    default:
      recursivelyTraverseDeletionEffects(
        finishedRoot,
        nearestMountedAncestor,
        deletedFiber
      );
  }
}
function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
  if (
    null === finishedWork.memoizedState &&
    ((finishedRoot = finishedWork.alternate),
    null !== finishedRoot &&
      ((finishedRoot = finishedRoot.memoizedState), null !== finishedRoot))
  ) {
    finishedRoot = finishedRoot.dehydrated;
    try {
      retryIfBlockedOn(finishedRoot);
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
}
function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
  if (
    null === finishedWork.memoizedState &&
    ((finishedRoot = finishedWork.alternate),
    null !== finishedRoot &&
      ((finishedRoot = finishedRoot.memoizedState),
      null !== finishedRoot &&
        ((finishedRoot = finishedRoot.dehydrated), null !== finishedRoot)))
  )
    try {
      retryIfBlockedOn(finishedRoot);
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
}
function getRetryCache(finishedWork) {
  switch (finishedWork.tag) {
    case 31:
    case 13:
    case 19:
      var retryCache = finishedWork.stateNode;
      null === retryCache &&
        (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
      return retryCache;
    case 22:
      return (
        (finishedWork = finishedWork.stateNode),
        (retryCache = finishedWork._retryCache),
        null === retryCache &&
          (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),
        retryCache
      );
    default:
      throw Error(formatProdErrorMessage(435, finishedWork.tag));
  }
}
function attachSuspenseRetryListeners(finishedWork, wakeables) {
  var retryCache = getRetryCache(finishedWork);
  wakeables.forEach(function (wakeable) {
    if (!retryCache.has(wakeable)) {
      retryCache.add(wakeable);
      var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
      wakeable.then(retry, retry);
    }
  });
}
function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
  var deletions = parentFiber.deletions;
  if (null !== deletions)
    for (var i = 0; i < deletions.length; i++) {
      var childToDelete = deletions[i],
        root = root$jscomp$0,
        returnFiber = parentFiber,
        parent = returnFiber;
      a: for (; null !== parent; ) {
        switch (parent.tag) {
          case 27:
            if (isSingletonScope(parent.type)) {
              hostParent = parent.stateNode;
              hostParentIsContainer = !1;
              break a;
            }
            break;
          case 5:
            hostParent = parent.stateNode;
            hostParentIsContainer = !1;
            break a;
          case 3:
          case 4:
            hostParent = parent.stateNode.containerInfo;
            hostParentIsContainer = !0;
            break a;
        }
        parent = parent.return;
      }
      if (null === hostParent) throw Error(formatProdErrorMessage(160));
      commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);
      hostParent = null;
      hostParentIsContainer = !1;
      root = childToDelete.alternate;
      null !== root && (root.return = null);
      childToDelete.return = null;
    }
  if (parentFiber.subtreeFlags & 13886)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),
        (parentFiber = parentFiber.sibling);
}
var currentHoistableRoot = null;
function commitMutationEffectsOnFiber(finishedWork, root) {
  var current = finishedWork.alternate,
    flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 4 &&
        (commitHookEffectListUnmount(3, finishedWork, finishedWork.return),
        commitHookEffectListMount(3, finishedWork),
        commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
      break;
    case 1:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 &&
        (offscreenSubtreeWasHidden ||
          null === current ||
          safelyDetachRef(current, current.return));
      flags & 64 &&
        offscreenSubtreeIsHidden &&
        ((finishedWork = finishedWork.updateQueue),
        null !== finishedWork &&
          ((flags = finishedWork.callbacks),
          null !== flags &&
            ((current = finishedWork.shared.hiddenCallbacks),
            (finishedWork.shared.hiddenCallbacks =
              null === current ? flags : current.concat(flags)))));
      break;
    case 26:
      var hoistableRoot = currentHoistableRoot;
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 &&
        (offscreenSubtreeWasHidden ||
          null === current ||
          safelyDetachRef(current, current.return));
      if (flags & 4) {
        var currentResource = null !== current ? current.memoizedState : null;
        flags = finishedWork.memoizedState;
        if (null === current)
          if (null === flags)
            if (null === finishedWork.stateNode) {
              a: {
                flags = finishedWork.type;
                current = finishedWork.memoizedProps;
                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                b: switch (flags) {
                  case "title":
                    currentResource =
                      hoistableRoot.getElementsByTagName("title")[0];
                    if (
                      !currentResource ||
                      currentResource[internalHoistableMarker] ||
                      currentResource[internalInstanceKey] ||
                      "http://www.w3.org/2000/svg" ===
                        currentResource.namespaceURI ||
                      currentResource.hasAttribute("itemprop")
                    )
                      (currentResource = hoistableRoot.createElement(flags)),
                        hoistableRoot.head.insertBefore(
                          currentResource,
                          hoistableRoot.querySelector("head > title")
                        );
                    setInitialProperties(currentResource, flags, current);
                    currentResource[internalInstanceKey] = finishedWork;
                    markNodeAsHoistable(currentResource);
                    flags = currentResource;
                    break a;
                  case "link":
                    var maybeNodes = getHydratableHoistableCache(
                      "link",
                      "href",
                      hoistableRoot
                    ).get(flags + (current.href || ""));
                    if (maybeNodes)
                      for (var i = 0; i < maybeNodes.length; i++)
                        if (
                          ((currentResource = maybeNodes[i]),
                          currentResource.getAttribute("href") ===
                            (null == current.href || "" === current.href
                              ? null
                              : current.href) &&
                            currentResource.getAttribute("rel") ===
                              (null == current.rel ? null : current.rel) &&
                            currentResource.getAttribute("title") ===
                              (null == current.title ? null : current.title) &&
                            currentResource.getAttribute("crossorigin") ===
                              (null == current.crossOrigin
                                ? null
                                : current.crossOrigin))
                        ) {
                          maybeNodes.splice(i, 1);
                          break b;
                        }
                    currentResource = hoistableRoot.createElement(flags);
                    setInitialProperties(currentResource, flags, current);
                    hoistableRoot.head.appendChild(currentResource);
                    break;
                  case "meta":
                    if (
                      (maybeNodes = getHydratableHoistableCache(
                        "meta",
                        "content",
                        hoistableRoot
                      ).get(flags + (current.content || "")))
                    )
                      for (i = 0; i < maybeNodes.length; i++)
                        if (
                          ((currentResource = maybeNodes[i]),
                          currentResource.getAttribute("content") ===
                            (null == current.content
                              ? null
                              : "" + current.content) &&
                            currentResource.getAttribute("name") ===
                              (null == current.name ? null : current.name) &&
                            currentResource.getAttribute("property") ===
                              (null == current.property
                                ? null
                                : current.property) &&
                            currentResource.getAttribute("http-equiv") ===
                              (null == current.httpEquiv
                                ? null
                                : current.httpEquiv) &&
                            currentResource.getAttribute("charset") ===
                              (null == current.charSet
                                ? null
                                : current.charSet))
                        ) {
                          maybeNodes.splice(i, 1);
                          break b;
                        }
                    currentResource = hoistableRoot.createElement(flags);
                    setInitialProperties(currentResource, flags, current);
                    hoistableRoot.head.appendChild(currentResource);
                    break;
                  default:
                    throw Error(formatProdErrorMessage(468, flags));
                }
                currentResource[internalInstanceKey] = finishedWork;
                markNodeAsHoistable(currentResource);
                flags = currentResource;
              }
              finishedWork.stateNode = flags;
            } else
              mountHoistable(
                hoistableRoot,
                finishedWork.type,
                finishedWork.stateNode
              );
          else
            finishedWork.stateNode = acquireResource(
              hoistableRoot,
              flags,
              finishedWork.memoizedProps
            );
        else
          currentResource !== flags
            ? (null === currentResource
                ? null !== current.stateNode &&
                  ((current = current.stateNode),
                  current.parentNode.removeChild(current))
                : currentResource.count--,
              null === flags
                ? mountHoistable(
                    hoistableRoot,
                    finishedWork.type,
                    finishedWork.stateNode
                  )
                : acquireResource(
                    hoistableRoot,
                    flags,
                    finishedWork.memoizedProps
                  ))
            : null === flags &&
              null !== finishedWork.stateNode &&
              commitHostUpdate(
                finishedWork,
                finishedWork.memoizedProps,
                current.memoizedProps
              );
      }
      break;
    case 27:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 &&
        (offscreenSubtreeWasHidden ||
          null === current ||
          safelyDetachRef(current, current.return));
      null !== current &&
        flags & 4 &&
        commitHostUpdate(
          finishedWork,
          finishedWork.memoizedProps,
          current.memoizedProps
        );
      break;
    case 5:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 512 &&
        (offscreenSubtreeWasHidden ||
          null === current ||
          safelyDetachRef(current, current.return));
      if (finishedWork.flags & 32) {
        hoistableRoot = finishedWork.stateNode;
        try {
          setTextContent(hoistableRoot, "");
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      flags & 4 &&
        null != finishedWork.stateNode &&
        ((hoistableRoot = finishedWork.memoizedProps),
        commitHostUpdate(
          finishedWork,
          hoistableRoot,
          null !== current ? current.memoizedProps : hoistableRoot
        ));
      flags & 1024 && (needsFormReset = !0);
      break;
    case 6:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      if (flags & 4) {
        if (null === finishedWork.stateNode)
          throw Error(formatProdErrorMessage(162));
        flags = finishedWork.memoizedProps;
        current = finishedWork.stateNode;
        try {
          current.nodeValue = flags;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      break;
    case 3:
      tagCaches = null;
      hoistableRoot = currentHoistableRoot;
      currentHoistableRoot = getHoistableRoot(root.containerInfo);
      recursivelyTraverseMutationEffects(root, finishedWork);
      currentHoistableRoot = hoistableRoot;
      commitReconciliationEffects(finishedWork);
      if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
        try {
          retryIfBlockedOn(root.containerInfo);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      needsFormReset &&
        ((needsFormReset = !1), recursivelyResetForms(finishedWork));
      break;
    case 4:
      flags = currentHoistableRoot;
      currentHoistableRoot = getHoistableRoot(
        finishedWork.stateNode.containerInfo
      );
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      currentHoistableRoot = flags;
      break;
    case 12:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      break;
    case 31:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 4 &&
        ((flags = finishedWork.updateQueue),
        null !== flags &&
          ((finishedWork.updateQueue = null),
          attachSuspenseRetryListeners(finishedWork, flags)));
      break;
    case 13:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      finishedWork.child.flags & 8192 &&
        (null !== finishedWork.memoizedState) !==
          (null !== current && null !== current.memoizedState) &&
        (globalMostRecentFallbackTime = now());
      flags & 4 &&
        ((flags = finishedWork.updateQueue),
        null !== flags &&
          ((finishedWork.updateQueue = null),
          attachSuspenseRetryListeners(finishedWork, flags)));
      break;
    case 22:
      hoistableRoot = null !== finishedWork.memoizedState;
      var wasHidden = null !== current && null !== current.memoizedState,
        prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
        prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
      recursivelyTraverseMutationEffects(root, finishedWork);
      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
      commitReconciliationEffects(finishedWork);
      if (flags & 8192)
        a: for (
          root = finishedWork.stateNode,
            root._visibility = hoistableRoot
              ? root._visibility & -2
              : root._visibility | 1,
            hoistableRoot &&
              (null === current ||
                wasHidden ||
                offscreenSubtreeIsHidden ||
                offscreenSubtreeWasHidden ||
                recursivelyTraverseDisappearLayoutEffects(finishedWork)),
            current = null,
            root = finishedWork;
          ;

        ) {
          if (5 === root.tag || 26 === root.tag) {
            if (null === current) {
              wasHidden = current = root;
              try {
                if (((currentResource = wasHidden.stateNode), hoistableRoot))
                  (maybeNodes = currentResource.style),
                    "function" === typeof maybeNodes.setProperty
                      ? maybeNodes.setProperty("display", "none", "important")
                      : (maybeNodes.display = "none");
                else {
                  i = wasHidden.stateNode;
                  var styleProp = wasHidden.memoizedProps.style,
                    display =
                      void 0 !== styleProp &&
                      null !== styleProp &&
                      styleProp.hasOwnProperty("display")
                        ? styleProp.display
                        : null;
                  i.style.display =
                    null == display || "boolean" === typeof display
                      ? ""
                      : ("" + display).trim();
                }
              } catch (error) {
                captureCommitPhaseError(wasHidden, wasHidden.return, error);
              }
            }
          } else if (6 === root.tag) {
            if (null === current) {
              wasHidden = root;
              try {
                wasHidden.stateNode.nodeValue = hoistableRoot
                  ? ""
                  : wasHidden.memoizedProps;
              } catch (error) {
                captureCommitPhaseError(wasHidden, wasHidden.return, error);
              }
            }
          } else if (18 === root.tag) {
            if (null === current) {
              wasHidden = root;
              try {
                var instance = wasHidden.stateNode;
                hoistableRoot
                  ? hideOrUnhideDehydratedBoundary(instance, !0)
                  : hideOrUnhideDehydratedBoundary(wasHidden.stateNode, !1);
              } catch (error) {
                captureCommitPhaseError(wasHidden, wasHidden.return, error);
              }
            }
          } else if (
            ((22 !== root.tag && 23 !== root.tag) ||
              null === root.memoizedState ||
              root === finishedWork) &&
            null !== root.child
          ) {
            root.child.return = root;
            root = root.child;
            continue;
          }
          if (root === finishedWork) break a;
          for (; null === root.sibling; ) {
            if (null === root.return || root.return === finishedWork) break a;
            current === root && (current = null);
            root = root.return;
          }
          current === root && (current = null);
          root.sibling.return = root.return;
          root = root.sibling;
        }
      flags & 4 &&
        ((flags = finishedWork.updateQueue),
        null !== flags &&
          ((current = flags.retryQueue),
          null !== current &&
            ((flags.retryQueue = null),
            attachSuspenseRetryListeners(finishedWork, current))));
      break;
    case 19:
      recursivelyTraverseMutationEffects(root, finishedWork);
      commitReconciliationEffects(finishedWork);
      flags & 4 &&
        ((flags = finishedWork.updateQueue),
        null !== flags &&
          ((finishedWork.updateQueue = null),
          attachSuspenseRetryListeners(finishedWork, flags)));
      break;
    case 30:
      break;
    case 21:
      break;
    default:
      recursivelyTraverseMutationEffects(root, finishedWork),
        commitReconciliationEffects(finishedWork);
  }
}
function commitReconciliationEffects(finishedWork) {
  var flags = finishedWork.flags;
  if (flags & 2) {
    try {
      for (
        var hostParentFiber, parentFiber = finishedWork.return;
        null !== parentFiber;

      ) {
        if (isHostParent(parentFiber)) {
          hostParentFiber = parentFiber;
          break;
        }
        parentFiber = parentFiber.return;
      }
      if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
      switch (hostParentFiber.tag) {
        case 27:
          var parent = hostParentFiber.stateNode,
            before = getHostSibling(finishedWork);
          insertOrAppendPlacementNode(finishedWork, before, parent);
          break;
        case 5:
          var parent$141 = hostParentFiber.stateNode;
          hostParentFiber.flags & 32 &&
            (setTextContent(parent$141, ""), (hostParentFiber.flags &= -33));
          var before$142 = getHostSibling(finishedWork);
          insertOrAppendPlacementNode(finishedWork, before$142, parent$141);
          break;
        case 3:
        case 4:
          var parent$143 = hostParentFiber.stateNode.containerInfo,
            before$144 = getHostSibling(finishedWork);
          insertOrAppendPlacementNodeIntoContainer(
            finishedWork,
            before$144,
            parent$143
          );
          break;
        default:
          throw Error(formatProdErrorMessage(161));
      }
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
    finishedWork.flags &= -3;
  }
  flags & 4096 && (finishedWork.flags &= -4097);
}
function recursivelyResetForms(parentFiber) {
  if (parentFiber.subtreeFlags & 1024)
    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
      var fiber = parentFiber;
      recursivelyResetForms(fiber);
      5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
      parentFiber = parentFiber.sibling;
    }
}
function recursivelyTraverseLayoutEffects(root, parentFiber) {
  if (parentFiber.subtreeFlags & 8772)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),
        (parentFiber = parentFiber.sibling);
}
function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
    var finishedWork = parentFiber;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 1:
        safelyDetachRef(finishedWork, finishedWork.return);
        var instance = finishedWork.stateNode;
        "function" === typeof instance.componentWillUnmount &&
          safelyCallComponentWillUnmount(
            finishedWork,
            finishedWork.return,
            instance
          );
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 27:
        releaseSingletonInstance(finishedWork.stateNode);
      case 26:
      case 5:
        safelyDetachRef(finishedWork, finishedWork.return);
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 22:
        null === finishedWork.memoizedState &&
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 30:
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      default:
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
    }
    parentFiber = parentFiber.sibling;
  }
}
function recursivelyTraverseReappearLayoutEffects(
  finishedRoot$jscomp$0,
  parentFiber,
  includeWorkInProgressEffects
) {
  includeWorkInProgressEffects =
    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
    var current = parentFiber.alternate,
      finishedRoot = finishedRoot$jscomp$0,
      finishedWork = parentFiber,
      flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        commitHookEffectListMount(4, finishedWork);
        break;
      case 1:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        current = finishedWork;
        finishedRoot = current.stateNode;
        if ("function" === typeof finishedRoot.componentDidMount)
          try {
            finishedRoot.componentDidMount();
          } catch (error) {
            captureCommitPhaseError(current, current.return, error);
          }
        current = finishedWork;
        finishedRoot = current.updateQueue;
        if (null !== finishedRoot) {
          var instance = current.stateNode;
          try {
            var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
            if (null !== hiddenCallbacks)
              for (
                finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0;
                finishedRoot < hiddenCallbacks.length;
                finishedRoot++
              )
                callCallback(hiddenCallbacks[finishedRoot], instance);
          } catch (error) {
            captureCommitPhaseError(current, current.return, error);
          }
        }
        includeWorkInProgressEffects &&
          flags & 64 &&
          commitClassCallbacks(finishedWork);
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 27:
        commitHostSingletonAcquisition(finishedWork);
      case 26:
      case 5:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        includeWorkInProgressEffects &&
          null === current &&
          flags & 4 &&
          commitHostMount(finishedWork);
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 12:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        break;
      case 31:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        includeWorkInProgressEffects &&
          flags & 4 &&
          commitActivityHydrationCallbacks(finishedRoot, finishedWork);
        break;
      case 13:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
        includeWorkInProgressEffects &&
          flags & 4 &&
          commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
        break;
      case 22:
        null === finishedWork.memoizedState &&
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 30:
        break;
      default:
        recursivelyTraverseReappearLayoutEffects(
          finishedRoot,
          finishedWork,
          includeWorkInProgressEffects
        );
    }
    parentFiber = parentFiber.sibling;
  }
}
function commitOffscreenPassiveMountEffects(current, finishedWork) {
  var previousCache = null;
  null !== current &&
    null !== current.memoizedState &&
    null !== current.memoizedState.cachePool &&
    (previousCache = current.memoizedState.cachePool.pool);
  current = null;
  null !== finishedWork.memoizedState &&
    null !== finishedWork.memoizedState.cachePool &&
    (current = finishedWork.memoizedState.cachePool.pool);
  current !== previousCache &&
    (null != current && current.refCount++,
    null != previousCache && releaseCache(previousCache));
}
function commitCachePassiveMountEffect(current, finishedWork) {
  current = null;
  null !== finishedWork.alternate &&
    (current = finishedWork.alternate.memoizedState.cache);
  finishedWork = finishedWork.memoizedState.cache;
  finishedWork !== current &&
    (finishedWork.refCount++, null != current && releaseCache(current));
}
function recursivelyTraversePassiveMountEffects(
  root,
  parentFiber,
  committedLanes,
  committedTransitions
) {
  if (parentFiber.subtreeFlags & 10256)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      commitPassiveMountOnFiber(
        root,
        parentFiber,
        committedLanes,
        committedTransitions
      ),
        (parentFiber = parentFiber.sibling);
}
function commitPassiveMountOnFiber(
  finishedRoot,
  finishedWork,
  committedLanes,
  committedTransitions
) {
  var flags = finishedWork.flags;
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 15:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      flags & 2048 && commitHookEffectListMount(9, finishedWork);
      break;
    case 1:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      break;
    case 3:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      flags & 2048 &&
        ((finishedRoot = null),
        null !== finishedWork.alternate &&
          (finishedRoot = finishedWork.alternate.memoizedState.cache),
        (finishedWork = finishedWork.memoizedState.cache),
        finishedWork !== finishedRoot &&
          (finishedWork.refCount++,
          null != finishedRoot && releaseCache(finishedRoot)));
      break;
    case 12:
      if (flags & 2048) {
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
        finishedRoot = finishedWork.stateNode;
        try {
          var _finishedWork$memoize2 = finishedWork.memoizedProps,
            id = _finishedWork$memoize2.id,
            onPostCommit = _finishedWork$memoize2.onPostCommit;
          "function" === typeof onPostCommit &&
            onPostCommit(
              id,
              null === finishedWork.alternate ? "mount" : "update",
              finishedRoot.passiveEffectDuration,
              -0
            );
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      } else
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
      break;
    case 31:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      break;
    case 13:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      break;
    case 23:
      break;
    case 22:
      _finishedWork$memoize2 = finishedWork.stateNode;
      id = finishedWork.alternate;
      null !== finishedWork.memoizedState
        ? _finishedWork$memoize2._visibility & 2
          ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            )
          : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork)
        : _finishedWork$memoize2._visibility & 2
          ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            )
          : ((_finishedWork$memoize2._visibility |= 2),
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              0 !== (finishedWork.subtreeFlags & 10256) || !1
            ));
      flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
      break;
    case 24:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
      flags & 2048 &&
        commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
      break;
    default:
      recursivelyTraversePassiveMountEffects(
        finishedRoot,
        finishedWork,
        committedLanes,
        committedTransitions
      );
  }
}
function recursivelyTraverseReconnectPassiveEffects(
  finishedRoot$jscomp$0,
  parentFiber,
  committedLanes$jscomp$0,
  committedTransitions$jscomp$0,
  includeWorkInProgressEffects
) {
  includeWorkInProgressEffects =
    includeWorkInProgressEffects &&
    (0 !== (parentFiber.subtreeFlags & 10256) || !1);
  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
    var finishedRoot = finishedRoot$jscomp$0,
      finishedWork = parentFiber,
      committedLanes = committedLanes$jscomp$0,
      committedTransitions = committedTransitions$jscomp$0,
      flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraverseReconnectPassiveEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          includeWorkInProgressEffects
        );
        commitHookEffectListMount(8, finishedWork);
        break;
      case 23:
        break;
      case 22:
        var instance = finishedWork.stateNode;
        null !== finishedWork.memoizedState
          ? instance._visibility & 2
            ? recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              )
            : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              )
          : ((instance._visibility |= 2),
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            ));
        includeWorkInProgressEffects &&
          flags & 2048 &&
          commitOffscreenPassiveMountEffects(
            finishedWork.alternate,
            finishedWork
          );
        break;
      case 24:
        recursivelyTraverseReconnectPassiveEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          includeWorkInProgressEffects
        );
        includeWorkInProgressEffects &&
          flags & 2048 &&
          commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
        break;
      default:
        recursivelyTraverseReconnectPassiveEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          includeWorkInProgressEffects
        );
    }
    parentFiber = parentFiber.sibling;
  }
}
function recursivelyTraverseAtomicPassiveEffects(
  finishedRoot$jscomp$0,
  parentFiber
) {
  if (parentFiber.subtreeFlags & 10256)
    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
      var finishedRoot = finishedRoot$jscomp$0,
        finishedWork = parentFiber,
        flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 22:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
          flags & 2048 &&
            commitOffscreenPassiveMountEffects(
              finishedWork.alternate,
              finishedWork
            );
          break;
        case 24:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
          flags & 2048 &&
            commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
      }
      parentFiber = parentFiber.sibling;
    }
}
var suspenseyCommitFlag = 8192;
function recursivelyAccumulateSuspenseyCommit(
  parentFiber,
  committedLanes,
  suspendedState
) {
  if (parentFiber.subtreeFlags & suspenseyCommitFlag)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      accumulateSuspenseyCommitOnFiber(
        parentFiber,
        committedLanes,
        suspendedState
      ),
        (parentFiber = parentFiber.sibling);
}
function accumulateSuspenseyCommitOnFiber(
  fiber,
  committedLanes,
  suspendedState
) {
  switch (fiber.tag) {
    case 26:
      recursivelyAccumulateSuspenseyCommit(
        fiber,
        committedLanes,
        suspendedState
      );
      fiber.flags & suspenseyCommitFlag &&
        null !== fiber.memoizedState &&
        suspendResource(
          suspendedState,
          currentHoistableRoot,
          fiber.memoizedState,
          fiber.memoizedProps
        );
      break;
    case 5:
      recursivelyAccumulateSuspenseyCommit(
        fiber,
        committedLanes,
        suspendedState
      );
      break;
    case 3:
    case 4:
      var previousHoistableRoot = currentHoistableRoot;
      currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
      recursivelyAccumulateSuspenseyCommit(
        fiber,
        committedLanes,
        suspendedState
      );
      currentHoistableRoot = previousHoistableRoot;
      break;
    case 22:
      null === fiber.memoizedState &&
        ((previousHoistableRoot = fiber.alternate),
        null !== previousHoistableRoot &&
        null !== previousHoistableRoot.memoizedState
          ? ((previousHoistableRoot = suspenseyCommitFlag),
            (suspenseyCommitFlag = 16777216),
            recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            ),
            (suspenseyCommitFlag = previousHoistableRoot))
          : recursivelyAccumulateSuspenseyCommit(
              fiber,
              committedLanes,
              suspendedState
            ));
      break;
    default:
      recursivelyAccumulateSuspenseyCommit(
        fiber,
        committedLanes,
        suspendedState
      );
  }
}
function detachAlternateSiblings(parentFiber) {
  var previousFiber = parentFiber.alternate;
  if (
    null !== previousFiber &&
    ((parentFiber = previousFiber.child), null !== parentFiber)
  ) {
    previousFiber.child = null;
    do
      (previousFiber = parentFiber.sibling),
        (parentFiber.sibling = null),
        (parentFiber = previousFiber);
    while (null !== parentFiber);
  }
}
function recursivelyTraversePassiveUnmountEffects(parentFiber) {
  var deletions = parentFiber.deletions;
  if (0 !== (parentFiber.flags & 16)) {
    if (null !== deletions)
      for (var i = 0; i < deletions.length; i++) {
        var childToDelete = deletions[i];
        nextEffect = childToDelete;
        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
          childToDelete,
          parentFiber
        );
      }
    detachAlternateSiblings(parentFiber);
  }
  if (parentFiber.subtreeFlags & 10256)
    for (parentFiber = parentFiber.child; null !== parentFiber; )
      commitPassiveUnmountOnFiber(parentFiber),
        (parentFiber = parentFiber.sibling);
}
function commitPassiveUnmountOnFiber(finishedWork) {
  switch (finishedWork.tag) {
    case 0:
    case 11:
    case 15:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      finishedWork.flags & 2048 &&
        commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
      break;
    case 3:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    case 12:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    case 22:
      var instance = finishedWork.stateNode;
      null !== finishedWork.memoizedState &&
      instance._visibility & 2 &&
      (null === finishedWork.return || 13 !== finishedWork.return.tag)
        ? ((instance._visibility &= -3),
          recursivelyTraverseDisconnectPassiveEffects(finishedWork))
        : recursivelyTraversePassiveUnmountEffects(finishedWork);
      break;
    default:
      recursivelyTraversePassiveUnmountEffects(finishedWork);
  }
}
function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
  var deletions = parentFiber.deletions;
  if (0 !== (parentFiber.flags & 16)) {
    if (null !== deletions)
      for (var i = 0; i < deletions.length; i++) {
        var childToDelete = deletions[i];
        nextEffect = childToDelete;
        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
          childToDelete,
          parentFiber
        );
      }
    detachAlternateSiblings(parentFiber);
  }
  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
    deletions = parentFiber;
    switch (deletions.tag) {
      case 0:
      case 11:
      case 15:
        commitHookEffectListUnmount(8, deletions, deletions.return);
        recursivelyTraverseDisconnectPassiveEffects(deletions);
        break;
      case 22:
        i = deletions.stateNode;
        i._visibility & 2 &&
          ((i._visibility &= -3),
          recursivelyTraverseDisconnectPassiveEffects(deletions));
        break;
      default:
        recursivelyTraverseDisconnectPassiveEffects(deletions);
    }
    parentFiber = parentFiber.sibling;
  }
}
function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
  deletedSubtreeRoot,
  nearestMountedAncestor
) {
  for (; null !== nextEffect; ) {
    var fiber = nextEffect;
    switch (fiber.tag) {
      case 0:
      case 11:
      case 15:
        commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
        break;
      case 23:
      case 22:
        if (
          null !== fiber.memoizedState &&
          null !== fiber.memoizedState.cachePool
        ) {
          var cache = fiber.memoizedState.cachePool.pool;
          null != cache && cache.refCount++;
        }
        break;
      case 24:
        releaseCache(fiber.memoizedState.cache);
    }
    cache = fiber.child;
    if (null !== cache) (cache.return = fiber), (nextEffect = cache);
    else
      a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
        cache = nextEffect;
        var sibling = cache.sibling,
          returnFiber = cache.return;
        detachFiberAfterEffects(cache);
        if (cache === fiber) {
          nextEffect = null;
          break a;
        }
        if (null !== sibling) {
          sibling.return = returnFiber;
          nextEffect = sibling;
          break a;
        }
        nextEffect = returnFiber;
      }
  }
}
var DefaultAsyncDispatcher = {
    getCacheForType: function (resourceType) {
      var cache = readContext(CacheContext),
        cacheForType = cache.data.get(resourceType);
      void 0 === cacheForType &&
        ((cacheForType = resourceType()),
        cache.data.set(resourceType, cacheForType));
      return cacheForType;
    },
    cacheSignal: function () {
      return readContext(CacheContext).controller.signal;
    }
  },
  PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
  executionContext = 0,
  workInProgressRoot = null,
  workInProgress = null,
  workInProgressRootRenderLanes = 0,
  workInProgressSuspendedReason = 0,
  workInProgressThrownValue = null,
  workInProgressRootDidSkipSuspendedSiblings = !1,
  workInProgressRootIsPrerendering = !1,
  workInProgressRootDidAttachPingListener = !1,
  entangledRenderLanes = 0,
  workInProgressRootExitStatus = 0,
  workInProgressRootSkippedLanes = 0,
  workInProgressRootInterleavedUpdatedLanes = 0,
  workInProgressRootPingedLanes = 0,
  workInProgressDeferredLane = 0,
  workInProgressSuspendedRetryLanes = 0,
  workInProgressRootConcurrentErrors = null,
  workInProgressRootRecoverableErrors = null,
  workInProgressRootDidIncludeRecursiveRenderUpdate = !1,
  globalMostRecentFallbackTime = 0,
  globalMostRecentTransitionTime = 0,
  workInProgressRootRenderTargetTime = Infinity,
  workInProgressTransitions = null,
  legacyErrorBoundariesThatAlreadyFailed = null,
  pendingEffectsStatus = 0,
  pendingEffectsRoot = null,
  pendingFinishedWork = null,
  pendingEffectsLanes = 0,
  pendingEffectsRemainingLanes = 0,
  pendingPassiveTransitions = null,
  pendingRecoverableErrors = null,
  nestedUpdateCount = 0,
  rootWithNestedUpdates = null;
function requestUpdateLane() {
  return 0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes
    ? workInProgressRootRenderLanes & -workInProgressRootRenderLanes
    : null !== ReactSharedInternals.T
      ? requestTransitionLane()
      : resolveUpdatePriority();
}
function requestDeferredLane() {
  if (0 === workInProgressDeferredLane)
    if (0 === (workInProgressRootRenderLanes & 536870912) || isHydrating) {
      var lane = nextTransitionDeferredLane;
      nextTransitionDeferredLane <<= 1;
      0 === (nextTransitionDeferredLane & 3932160) &&
        (nextTransitionDeferredLane = 262144);
      workInProgressDeferredLane = lane;
    } else workInProgressDeferredLane = 536870912;
  lane = suspenseHandlerStackCursor.current;
  null !== lane && (lane.flags |= 32);
  return workInProgressDeferredLane;
}
function scheduleUpdateOnFiber(root, fiber, lane) {
  if (
    (root === workInProgressRoot &&
      (2 === workInProgressSuspendedReason ||
        9 === workInProgressSuspendedReason)) ||
    null !== root.cancelPendingCommit
  )
    prepareFreshStack(root, 0),
      markRootSuspended(
        root,
        workInProgressRootRenderLanes,
        workInProgressDeferredLane,
        !1
      );
  markRootUpdated$1(root, lane);
  if (0 === (executionContext & 2) || root !== workInProgressRoot)
    root === workInProgressRoot &&
      (0 === (executionContext & 2) &&
        (workInProgressRootInterleavedUpdatedLanes |= lane),
      4 === workInProgressRootExitStatus &&
        markRootSuspended(
          root,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          !1
        )),
      ensureRootIsScheduled(root);
}
function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
  var shouldTimeSlice =
      (!forceSync &&
        0 === (lanes & 127) &&
        0 === (lanes & root$jscomp$0.expiredLanes)) ||
      checkIfRootIsPrerendering(root$jscomp$0, lanes),
    exitStatus = shouldTimeSlice
      ? renderRootConcurrent(root$jscomp$0, lanes)
      : renderRootSync(root$jscomp$0, lanes, !0),
    renderWasConcurrent = shouldTimeSlice;
  do {
    if (0 === exitStatus) {
      workInProgressRootIsPrerendering &&
        !shouldTimeSlice &&
        markRootSuspended(root$jscomp$0, lanes, 0, !1);
      break;
    } else {
      forceSync = root$jscomp$0.current.alternate;
      if (
        renderWasConcurrent &&
        !isRenderConsistentWithExternalStores(forceSync)
      ) {
        exitStatus = renderRootSync(root$jscomp$0, lanes, !1);
        renderWasConcurrent = !1;
        continue;
      }
      if (2 === exitStatus) {
        renderWasConcurrent = lanes;
        if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
          var JSCompiler_inline_result = 0;
        else
          (JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913),
            (JSCompiler_inline_result =
              0 !== JSCompiler_inline_result
                ? JSCompiler_inline_result
                : JSCompiler_inline_result & 536870912
                  ? 536870912
                  : 0);
        if (0 !== JSCompiler_inline_result) {
          lanes = JSCompiler_inline_result;
          a: {
            var root = root$jscomp$0;
            exitStatus = workInProgressRootConcurrentErrors;
            var wasRootDehydrated = root.current.memoizedState.isDehydrated;
            wasRootDehydrated &&
              (prepareFreshStack(root, JSCompiler_inline_result).flags |= 256);
            JSCompiler_inline_result = renderRootSync(
              root,
              JSCompiler_inline_result,
              !1
            );
            if (2 !== JSCompiler_inline_result) {
              if (
                workInProgressRootDidAttachPingListener &&
                !wasRootDehydrated
              ) {
                root.errorRecoveryDisabledLanes |= renderWasConcurrent;
                workInProgressRootInterleavedUpdatedLanes |=
                  renderWasConcurrent;
                exitStatus = 4;
                break a;
              }
              renderWasConcurrent = workInProgressRootRecoverableErrors;
              workInProgressRootRecoverableErrors = exitStatus;
              null !== renderWasConcurrent &&
                (null === workInProgressRootRecoverableErrors
                  ? (workInProgressRootRecoverableErrors = renderWasConcurrent)
                  : workInProgressRootRecoverableErrors.push.apply(
                      workInProgressRootRecoverableErrors,
                      renderWasConcurrent
                    ));
            }
            exitStatus = JSCompiler_inline_result;
          }
          renderWasConcurrent = !1;
          if (2 !== exitStatus) continue;
        }
      }
      if (1 === exitStatus) {
        prepareFreshStack(root$jscomp$0, 0);
        markRootSuspended(root$jscomp$0, lanes, 0, !0);
        break;
      }
      a: {
        shouldTimeSlice = root$jscomp$0;
        renderWasConcurrent = exitStatus;
        switch (renderWasConcurrent) {
          case 0:
          case 1:
            throw Error(formatProdErrorMessage(345));
          case 4:
            if ((lanes & 4194048) !== lanes) break;
          case 6:
            markRootSuspended(
              shouldTimeSlice,
              lanes,
              workInProgressDeferredLane,
              !workInProgressRootDidSkipSuspendedSiblings
            );
            break a;
          case 2:
            workInProgressRootRecoverableErrors = null;
            break;
          case 3:
          case 5:
            break;
          default:
            throw Error(formatProdErrorMessage(329));
        }
        if (
          (lanes & 62914560) === lanes &&
          ((exitStatus = globalMostRecentFallbackTime + 300 - now()),
          10 < exitStatus)
        ) {
          markRootSuspended(
            shouldTimeSlice,
            lanes,
            workInProgressDeferredLane,
            !workInProgressRootDidSkipSuspendedSiblings
          );
          if (0 !== getNextLanes(shouldTimeSlice, 0, !0)) break a;
          pendingEffectsLanes = lanes;
          shouldTimeSlice.timeoutHandle = scheduleTimeout(
            commitRootWhenReady.bind(
              null,
              shouldTimeSlice,
              forceSync,
              workInProgressRootRecoverableErrors,
              workInProgressTransitions,
              workInProgressRootDidIncludeRecursiveRenderUpdate,
              lanes,
              workInProgressDeferredLane,
              workInProgressRootInterleavedUpdatedLanes,
              workInProgressSuspendedRetryLanes,
              workInProgressRootDidSkipSuspendedSiblings,
              renderWasConcurrent,
              "Throttled",
              -0,
              0
            ),
            exitStatus
          );
          break a;
        }
        commitRootWhenReady(
          shouldTimeSlice,
          forceSync,
          workInProgressRootRecoverableErrors,
          workInProgressTransitions,
          workInProgressRootDidIncludeRecursiveRenderUpdate,
          lanes,
          workInProgressDeferredLane,
          workInProgressRootInterleavedUpdatedLanes,
          workInProgressSuspendedRetryLanes,
          workInProgressRootDidSkipSuspendedSiblings,
          renderWasConcurrent,
          null,
          -0,
          0
        );
      }
    }
    break;
  } while (1);
  ensureRootIsScheduled(root$jscomp$0);
}
function commitRootWhenReady(
  root,
  finishedWork,
  recoverableErrors,
  transitions,
  didIncludeRenderPhaseUpdate,
  lanes,
  spawnedLane,
  updatedLanes,
  suspendedRetryLanes,
  didSkipSuspendedSiblings,
  exitStatus,
  suspendedCommitReason,
  completedRenderStartTime,
  completedRenderEndTime
) {
  root.timeoutHandle = -1;
  suspendedCommitReason = finishedWork.subtreeFlags;
  if (
    suspendedCommitReason & 8192 ||
    16785408 === (suspendedCommitReason & 16785408)
  ) {
    suspendedCommitReason = {
      stylesheets: null,
      count: 0,
      imgCount: 0,
      imgBytes: 0,
      suspenseyImages: [],
      waitingForImages: !0,
      waitingForViewTransition: !1,
      unsuspend: noop$1
    };
    accumulateSuspenseyCommitOnFiber(
      finishedWork,
      lanes,
      suspendedCommitReason
    );
    var timeoutOffset =
      (lanes & 62914560) === lanes
        ? globalMostRecentFallbackTime - now()
        : (lanes & 4194048) === lanes
          ? globalMostRecentTransitionTime - now()
          : 0;
    timeoutOffset = waitForCommitToBeReady(
      suspendedCommitReason,
      timeoutOffset
    );
    if (null !== timeoutOffset) {
      pendingEffectsLanes = lanes;
      root.cancelPendingCommit = timeoutOffset(
        commitRoot.bind(
          null,
          root,
          finishedWork,
          lanes,
          recoverableErrors,
          transitions,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes,
          exitStatus,
          suspendedCommitReason,
          null,
          completedRenderStartTime,
          completedRenderEndTime
        )
      );
      markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);
      return;
    }
  }
  commitRoot(
    root,
    finishedWork,
    lanes,
    recoverableErrors,
    transitions,
    didIncludeRenderPhaseUpdate,
    spawnedLane,
    updatedLanes,
    suspendedRetryLanes
  );
}
function isRenderConsistentWithExternalStores(finishedWork) {
  for (var node = finishedWork; ; ) {
    var tag = node.tag;
    if (
      (0 === tag || 11 === tag || 15 === tag) &&
      node.flags & 16384 &&
      ((tag = node.updateQueue),
      null !== tag && ((tag = tag.stores), null !== tag))
    )
      for (var i = 0; i < tag.length; i++) {
        var check = tag[i],
          getSnapshot = check.getSnapshot;
        check = check.value;
        try {
          if (!objectIs(getSnapshot(), check)) return !1;
        } catch (error) {
          return !1;
        }
      }
    tag = node.child;
    if (node.subtreeFlags & 16384 && null !== tag)
      (tag.return = node), (node = tag);
    else {
      if (node === finishedWork) break;
      for (; null === node.sibling; ) {
        if (null === node.return || node.return === finishedWork) return !0;
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
  }
  return !0;
}
function markRootSuspended(
  root,
  suspendedLanes,
  spawnedLane,
  didAttemptEntireTree
) {
  suspendedLanes &= ~workInProgressRootPingedLanes;
  suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
  root.suspendedLanes |= suspendedLanes;
  root.pingedLanes &= ~suspendedLanes;
  didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
  didAttemptEntireTree = root.expirationTimes;
  for (var lanes = suspendedLanes; 0 < lanes; ) {
    var index$6 = 31 - clz32(lanes),
      lane = 1 << index$6;
    didAttemptEntireTree[index$6] = -1;
    lanes &= ~lane;
  }
  0 !== spawnedLane &&
    markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
}
function flushSyncWork$1() {
  return 0 === (executionContext & 6)
    ? (flushSyncWorkAcrossRoots_impl(0, !1), !1)
    : !0;
}
function resetWorkInProgressStack() {
  if (null !== workInProgress) {
    if (0 === workInProgressSuspendedReason)
      var interruptedWork = workInProgress.return;
    else
      (interruptedWork = workInProgress),
        (lastContextDependency = currentlyRenderingFiber$1 = null),
        resetHooksOnUnwind(interruptedWork),
        (thenableState$1 = null),
        (thenableIndexCounter$1 = 0),
        (interruptedWork = workInProgress);
    for (; null !== interruptedWork; )
      unwindInterruptedWork(interruptedWork.alternate, interruptedWork),
        (interruptedWork = interruptedWork.return);
    workInProgress = null;
  }
}
function prepareFreshStack(root, lanes) {
  var timeoutHandle = root.timeoutHandle;
  -1 !== timeoutHandle &&
    ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));
  timeoutHandle = root.cancelPendingCommit;
  null !== timeoutHandle &&
    ((root.cancelPendingCommit = null), timeoutHandle());
  pendingEffectsLanes = 0;
  resetWorkInProgressStack();
  workInProgressRoot = root;
  workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
  workInProgressRootRenderLanes = lanes;
  workInProgressSuspendedReason = 0;
  workInProgressThrownValue = null;
  workInProgressRootDidSkipSuspendedSiblings = !1;
  workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
  workInProgressRootDidAttachPingListener = !1;
  workInProgressSuspendedRetryLanes =
    workInProgressDeferredLane =
    workInProgressRootPingedLanes =
    workInProgressRootInterleavedUpdatedLanes =
    workInProgressRootSkippedLanes =
    workInProgressRootExitStatus =
      0;
  workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =
    null;
  workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
  0 !== (lanes & 8) && (lanes |= lanes & 32);
  var allEntangledLanes = root.entangledLanes;
  if (0 !== allEntangledLanes)
    for (
      root = root.entanglements, allEntangledLanes &= lanes;
      0 < allEntangledLanes;

    ) {
      var index$4 = 31 - clz32(allEntangledLanes),
        lane = 1 << index$4;
      lanes |= root[index$4];
      allEntangledLanes &= ~lane;
    }
  entangledRenderLanes = lanes;
  finishQueueingConcurrentUpdates();
  return timeoutHandle;
}
function handleThrow(root, thrownValue) {
  currentlyRenderingFiber = null;
  ReactSharedInternals.H = ContextOnlyDispatcher;
  thrownValue === SuspenseException || thrownValue === SuspenseActionException
    ? ((thrownValue = getSuspendedThenable()),
      (workInProgressSuspendedReason = 3))
    : thrownValue === SuspenseyCommitException
      ? ((thrownValue = getSuspendedThenable()),
        (workInProgressSuspendedReason = 4))
      : (workInProgressSuspendedReason =
          thrownValue === SelectiveHydrationException
            ? 8
            : null !== thrownValue &&
                "object" === typeof thrownValue &&
                "function" === typeof thrownValue.then
              ? 6
              : 1);
  workInProgressThrownValue = thrownValue;
  null === workInProgress &&
    ((workInProgressRootExitStatus = 1),
    logUncaughtError(
      root,
      createCapturedValueAtFiber(thrownValue, root.current)
    ));
}
function shouldRemainOnPreviousScreen() {
  var handler = suspenseHandlerStackCursor.current;
  return null === handler
    ? !0
    : (workInProgressRootRenderLanes & 4194048) ===
        workInProgressRootRenderLanes
      ? null === shellBoundary
        ? !0
        : !1
      : (workInProgressRootRenderLanes & 62914560) ===
            workInProgressRootRenderLanes ||
          0 !== (workInProgressRootRenderLanes & 536870912)
        ? handler === shellBoundary
        : !1;
}
function pushDispatcher() {
  var prevDispatcher = ReactSharedInternals.H;
  ReactSharedInternals.H = ContextOnlyDispatcher;
  return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
}
function pushAsyncDispatcher() {
  var prevAsyncDispatcher = ReactSharedInternals.A;
  ReactSharedInternals.A = DefaultAsyncDispatcher;
  return prevAsyncDispatcher;
}
function renderDidSuspendDelayIfPossible() {
  workInProgressRootExitStatus = 4;
  workInProgressRootDidSkipSuspendedSiblings ||
    ((workInProgressRootRenderLanes & 4194048) !==
      workInProgressRootRenderLanes &&
      null !== suspenseHandlerStackCursor.current) ||
    (workInProgressRootIsPrerendering = !0);
  (0 === (workInProgressRootSkippedLanes & 134217727) &&
    0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||
    null === workInProgressRoot ||
    markRootSuspended(
      workInProgressRoot,
      workInProgressRootRenderLanes,
      workInProgressDeferredLane,
      !1
    );
}
function renderRootSync(root, lanes, shouldYieldForPrerendering) {
  var prevExecutionContext = executionContext;
  executionContext |= 2;
  var prevDispatcher = pushDispatcher(),
    prevAsyncDispatcher = pushAsyncDispatcher();
  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes)
    (workInProgressTransitions = null), prepareFreshStack(root, lanes);
  lanes = !1;
  var exitStatus = workInProgressRootExitStatus;
  a: do
    try {
      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
        var unitOfWork = workInProgress,
          thrownValue = workInProgressThrownValue;
        switch (workInProgressSuspendedReason) {
          case 8:
            resetWorkInProgressStack();
            exitStatus = 6;
            break a;
          case 3:
          case 2:
          case 9:
          case 6:
            null === suspenseHandlerStackCursor.current && (lanes = !0);
            var reason = workInProgressSuspendedReason;
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
            if (
              shouldYieldForPrerendering &&
              workInProgressRootIsPrerendering
            ) {
              exitStatus = 0;
              break a;
            }
            break;
          default:
            (reason = workInProgressSuspendedReason),
              (workInProgressSuspendedReason = 0),
              (workInProgressThrownValue = null),
              throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
        }
      }
      workLoopSync();
      exitStatus = workInProgressRootExitStatus;
      break;
    } catch (thrownValue$165) {
      handleThrow(root, thrownValue$165);
    }
  while (1);
  lanes && root.shellSuspendCounter++;
  lastContextDependency = currentlyRenderingFiber$1 = null;
  executionContext = prevExecutionContext;
  ReactSharedInternals.H = prevDispatcher;
  ReactSharedInternals.A = prevAsyncDispatcher;
  null === workInProgress &&
    ((workInProgressRoot = null),
    (workInProgressRootRenderLanes = 0),
    finishQueueingConcurrentUpdates());
  return exitStatus;
}
function workLoopSync() {
  for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
}
function renderRootConcurrent(root, lanes) {
  var prevExecutionContext = executionContext;
  executionContext |= 2;
  var prevDispatcher = pushDispatcher(),
    prevAsyncDispatcher = pushAsyncDispatcher();
  workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes
    ? ((workInProgressTransitions = null),
      (workInProgressRootRenderTargetTime = now() + 500),
      prepareFreshStack(root, lanes))
    : (workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
        root,
        lanes
      ));
  a: do
    try {
      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
        lanes = workInProgress;
        var thrownValue = workInProgressThrownValue;
        b: switch (workInProgressSuspendedReason) {
          case 1:
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, lanes, thrownValue, 1);
            break;
          case 2:
          case 9:
            if (isThenableResolved(thrownValue)) {
              workInProgressSuspendedReason = 0;
              workInProgressThrownValue = null;
              replaySuspendedUnitOfWork(lanes);
              break;
            }
            lanes = function () {
              (2 !== workInProgressSuspendedReason &&
                9 !== workInProgressSuspendedReason) ||
                workInProgressRoot !== root ||
                (workInProgressSuspendedReason = 7);
              ensureRootIsScheduled(root);
            };
            thrownValue.then(lanes, lanes);
            break a;
          case 3:
            workInProgressSuspendedReason = 7;
            break a;
          case 4:
            workInProgressSuspendedReason = 5;
            break a;
          case 7:
            isThenableResolved(thrownValue)
              ? ((workInProgressSuspendedReason = 0),
                (workInProgressThrownValue = null),
                replaySuspendedUnitOfWork(lanes))
              : ((workInProgressSuspendedReason = 0),
                (workInProgressThrownValue = null),
                throwAndUnwindWorkLoop(root, lanes, thrownValue, 7));
            break;
          case 5:
            var resource = null;
            switch (workInProgress.tag) {
              case 26:
                resource = workInProgress.memoizedState;
              case 5:
              case 27:
                var hostFiber = workInProgress;
                if (
                  resource
                    ? preloadResource(resource)
                    : hostFiber.stateNode.complete
                ) {
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  var sibling = hostFiber.sibling;
                  if (null !== sibling) workInProgress = sibling;
                  else {
                    var returnFiber = hostFiber.return;
                    null !== returnFiber
                      ? ((workInProgress = returnFiber),
                        completeUnitOfWork(returnFiber))
                      : (workInProgress = null);
                  }
                  break b;
                }
            }
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, lanes, thrownValue, 5);
            break;
          case 6:
            workInProgressSuspendedReason = 0;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, lanes, thrownValue, 6);
            break;
          case 8:
            resetWorkInProgressStack();
            workInProgressRootExitStatus = 6;
            break a;
          default:
            throw Error(formatProdErrorMessage(462));
        }
      }
      workLoopConcurrentByScheduler();
      break;
    } catch (thrownValue$167) {
      handleThrow(root, thrownValue$167);
    }
  while (1);
  lastContextDependency = currentlyRenderingFiber$1 = null;
  ReactSharedInternals.H = prevDispatcher;
  ReactSharedInternals.A = prevAsyncDispatcher;
  executionContext = prevExecutionContext;
  if (null !== workInProgress) return 0;
  workInProgressRoot = null;
  workInProgressRootRenderLanes = 0;
  finishQueueingConcurrentUpdates();
  return workInProgressRootExitStatus;
}
function workLoopConcurrentByScheduler() {
  for (; null !== workInProgress && !shouldYield(); )
    performUnitOfWork(workInProgress);
}
function performUnitOfWork(unitOfWork) {
  var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
}
function replaySuspendedUnitOfWork(unitOfWork) {
  var next = unitOfWork;
  var current = next.alternate;
  switch (next.tag) {
    case 15:
    case 0:
      next = replayFunctionComponent(
        current,
        next,
        next.pendingProps,
        next.type,
        void 0,
        workInProgressRootRenderLanes
      );
      break;
    case 11:
      next = replayFunctionComponent(
        current,
        next,
        next.pendingProps,
        next.type.render,
        next.ref,
        workInProgressRootRenderLanes
      );
      break;
    case 5:
      resetHooksOnUnwind(next);
    default:
      unwindInterruptedWork(current, next),
        (next = workInProgress =
          resetWorkInProgress(next, entangledRenderLanes)),
        (next = beginWork(current, next, entangledRenderLanes));
  }
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
}
function throwAndUnwindWorkLoop(
  root,
  unitOfWork,
  thrownValue,
  suspendedReason
) {
  lastContextDependency = currentlyRenderingFiber$1 = null;
  resetHooksOnUnwind(unitOfWork);
  thenableState$1 = null;
  thenableIndexCounter$1 = 0;
  var returnFiber = unitOfWork.return;
  try {
    if (
      throwException(
        root,
        returnFiber,
        unitOfWork,
        thrownValue,
        workInProgressRootRenderLanes
      )
    ) {
      workInProgressRootExitStatus = 1;
      logUncaughtError(
        root,
        createCapturedValueAtFiber(thrownValue, root.current)
      );
      workInProgress = null;
      return;
    }
  } catch (error) {
    if (null !== returnFiber) throw ((workInProgress = returnFiber), error);
    workInProgressRootExitStatus = 1;
    logUncaughtError(
      root,
      createCapturedValueAtFiber(thrownValue, root.current)
    );
    workInProgress = null;
    return;
  }
  if (unitOfWork.flags & 32768) {
    if (isHydrating || 1 === suspendedReason) root = !0;
    else if (
      workInProgressRootIsPrerendering ||
      0 !== (workInProgressRootRenderLanes & 536870912)
    )
      root = !1;
    else if (
      ((workInProgressRootDidSkipSuspendedSiblings = root = !0),
      2 === suspendedReason ||
        9 === suspendedReason ||
        3 === suspendedReason ||
        6 === suspendedReason)
    )
      (suspendedReason = suspenseHandlerStackCursor.current),
        null !== suspendedReason &&
          13 === suspendedReason.tag &&
          (suspendedReason.flags |= 16384);
    unwindUnitOfWork(unitOfWork, root);
  } else completeUnitOfWork(unitOfWork);
}
function completeUnitOfWork(unitOfWork) {
  var completedWork = unitOfWork;
  do {
    if (0 !== (completedWork.flags & 32768)) {
      unwindUnitOfWork(
        completedWork,
        workInProgressRootDidSkipSuspendedSiblings
      );
      return;
    }
    unitOfWork = completedWork.return;
    var next = completeWork(
      completedWork.alternate,
      completedWork,
      entangledRenderLanes
    );
    if (null !== next) {
      workInProgress = next;
      return;
    }
    completedWork = completedWork.sibling;
    if (null !== completedWork) {
      workInProgress = completedWork;
      return;
    }
    workInProgress = completedWork = unitOfWork;
  } while (null !== completedWork);
  0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
}
function unwindUnitOfWork(unitOfWork, skipSiblings) {
  do {
    var next = unwindWork(unitOfWork.alternate, unitOfWork);
    if (null !== next) {
      next.flags &= 32767;
      workInProgress = next;
      return;
    }
    next = unitOfWork.return;
    null !== next &&
      ((next.flags |= 32768), (next.subtreeFlags = 0), (next.deletions = null));
    if (
      !skipSiblings &&
      ((unitOfWork = unitOfWork.sibling), null !== unitOfWork)
    ) {
      workInProgress = unitOfWork;
      return;
    }
    workInProgress = unitOfWork = next;
  } while (null !== unitOfWork);
  workInProgressRootExitStatus = 6;
  workInProgress = null;
}
function commitRoot(
  root,
  finishedWork,
  lanes,
  recoverableErrors,
  transitions,
  didIncludeRenderPhaseUpdate,
  spawnedLane,
  updatedLanes,
  suspendedRetryLanes
) {
  root.cancelPendingCommit = null;
  do flushPendingEffects();
  while (0 !== pendingEffectsStatus);
  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
  if (null !== finishedWork) {
    if (finishedWork === root.current) throw Error(formatProdErrorMessage(177));
    didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
    didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
    markRootFinished(
      root,
      lanes,
      didIncludeRenderPhaseUpdate,
      spawnedLane,
      updatedLanes,
      suspendedRetryLanes
    );
    root === workInProgressRoot &&
      ((workInProgress = workInProgressRoot = null),
      (workInProgressRootRenderLanes = 0));
    pendingFinishedWork = finishedWork;
    pendingEffectsRoot = root;
    pendingEffectsLanes = lanes;
    pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
    pendingPassiveTransitions = transitions;
    pendingRecoverableErrors = recoverableErrors;
    0 !== (finishedWork.subtreeFlags & 10256) ||
    0 !== (finishedWork.flags & 10256)
      ? ((root.callbackNode = null),
        (root.callbackPriority = 0),
        scheduleCallback$1(NormalPriority$1, function () {
          flushPassiveEffects();
          return null;
        }))
      : ((root.callbackNode = null), (root.callbackPriority = 0));
    recoverableErrors = 0 !== (finishedWork.flags & 13878);
    if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
      recoverableErrors = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      transitions = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 2;
      spawnedLane = executionContext;
      executionContext |= 4;
      try {
        commitBeforeMutationEffects(root, finishedWork, lanes);
      } finally {
        (executionContext = spawnedLane),
          (ReactDOMSharedInternals.p = transitions),
          (ReactSharedInternals.T = recoverableErrors);
      }
    }
    pendingEffectsStatus = 1;
    flushMutationEffects();
    flushLayoutEffects();
    flushSpawnedWork();
  }
}
function flushMutationEffects() {
  if (1 === pendingEffectsStatus) {
    pendingEffectsStatus = 0;
    var root = pendingEffectsRoot,
      finishedWork = pendingFinishedWork,
      rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
    if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
      rootMutationHasEffect = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 2;
      var prevExecutionContext = executionContext;
      executionContext |= 4;
      try {
        commitMutationEffectsOnFiber(finishedWork, root);
        var priorSelectionInformation = selectionInformation,
          curFocusedElem = getActiveElementDeep(root.containerInfo),
          priorFocusedElem = priorSelectionInformation.focusedElem,
          priorSelectionRange = priorSelectionInformation.selectionRange;
        if (
          curFocusedElem !== priorFocusedElem &&
          priorFocusedElem &&
          priorFocusedElem.ownerDocument &&
          containsNode(
            priorFocusedElem.ownerDocument.documentElement,
            priorFocusedElem
          )
        ) {
          if (
            null !== priorSelectionRange &&
            hasSelectionCapabilities(priorFocusedElem)
          ) {
            var start = priorSelectionRange.start,
              end = priorSelectionRange.end;
            void 0 === end && (end = start);
            if ("selectionStart" in priorFocusedElem)
              (priorFocusedElem.selectionStart = start),
                (priorFocusedElem.selectionEnd = Math.min(
                  end,
                  priorFocusedElem.value.length
                ));
            else {
              var doc = priorFocusedElem.ownerDocument || document,
                win = (doc && doc.defaultView) || window;
              if (win.getSelection) {
                var selection = win.getSelection(),
                  length = priorFocusedElem.textContent.length,
                  start$jscomp$0 = Math.min(priorSelectionRange.start, length),
                  end$jscomp$0 =
                    void 0 === priorSelectionRange.end
                      ? start$jscomp$0
                      : Math.min(priorSelectionRange.end, length);
                !selection.extend &&
                  start$jscomp$0 > end$jscomp$0 &&
                  ((curFocusedElem = end$jscomp$0),
                  (end$jscomp$0 = start$jscomp$0),
                  (start$jscomp$0 = curFocusedElem));
                var startMarker = getNodeForCharacterOffset(
                    priorFocusedElem,
                    start$jscomp$0
                  ),
                  endMarker = getNodeForCharacterOffset(
                    priorFocusedElem,
                    end$jscomp$0
                  );
                if (
                  startMarker &&
                  endMarker &&
                  (1 !== selection.rangeCount ||
                    selection.anchorNode !== startMarker.node ||
                    selection.anchorOffset !== startMarker.offset ||
                    selection.focusNode !== endMarker.node ||
                    selection.focusOffset !== endMarker.offset)
                ) {
                  var range = doc.createRange();
                  range.setStart(startMarker.node, startMarker.offset);
                  selection.removeAllRanges();
                  start$jscomp$0 > end$jscomp$0
                    ? (selection.addRange(range),
                      selection.extend(endMarker.node, endMarker.offset))
                    : (range.setEnd(endMarker.node, endMarker.offset),
                      selection.addRange(range));
                }
              }
            }
          }
          doc = [];
          for (
            selection = priorFocusedElem;
            (selection = selection.parentNode);

          )
            1 === selection.nodeType &&
              doc.push({
                element: selection,
                left: selection.scrollLeft,
                top: selection.scrollTop
              });
          "function" === typeof priorFocusedElem.focus &&
            priorFocusedElem.focus();
          for (
            priorFocusedElem = 0;
            priorFocusedElem < doc.length;
            priorFocusedElem++
          ) {
            var info = doc[priorFocusedElem];
            info.element.scrollLeft = info.left;
            info.element.scrollTop = info.top;
          }
        }
        _enabled = !!eventsEnabled;
        selectionInformation = eventsEnabled = null;
      } finally {
        (executionContext = prevExecutionContext),
          (ReactDOMSharedInternals.p = previousPriority),
          (ReactSharedInternals.T = rootMutationHasEffect);
      }
    }
    root.current = finishedWork;
    pendingEffectsStatus = 2;
  }
}
function flushLayoutEffects() {
  if (2 === pendingEffectsStatus) {
    pendingEffectsStatus = 0;
    var root = pendingEffectsRoot,
      finishedWork = pendingFinishedWork,
      rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
    if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
      rootHasLayoutEffect = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 2;
      var prevExecutionContext = executionContext;
      executionContext |= 4;
      try {
        commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);
      } finally {
        (executionContext = prevExecutionContext),
          (ReactDOMSharedInternals.p = previousPriority),
          (ReactSharedInternals.T = rootHasLayoutEffect);
      }
    }
    pendingEffectsStatus = 3;
  }
}
function flushSpawnedWork() {
  if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
    pendingEffectsStatus = 0;
    requestPaint();
    var root = pendingEffectsRoot,
      finishedWork = pendingFinishedWork,
      lanes = pendingEffectsLanes,
      recoverableErrors = pendingRecoverableErrors;
    0 !== (finishedWork.subtreeFlags & 10256) ||
    0 !== (finishedWork.flags & 10256)
      ? (pendingEffectsStatus = 5)
      : ((pendingEffectsStatus = 0),
        (pendingFinishedWork = pendingEffectsRoot = null),
        releaseRootPooledCache(root, root.pendingLanes));
    var remainingLanes = root.pendingLanes;
    0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
    lanesToEventPriority(lanes);
    finishedWork = finishedWork.stateNode;
    if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
      try {
        injectedHook.onCommitFiberRoot(
          rendererID,
          finishedWork,
          void 0,
          128 === (finishedWork.current.flags & 128)
        );
      } catch (err) {}
    if (null !== recoverableErrors) {
      finishedWork = ReactSharedInternals.T;
      remainingLanes = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 2;
      ReactSharedInternals.T = null;
      try {
        for (
          var onRecoverableError = root.onRecoverableError, i = 0;
          i < recoverableErrors.length;
          i++
        ) {
          var recoverableError = recoverableErrors[i];
          onRecoverableError(recoverableError.value, {
            componentStack: recoverableError.stack
          });
        }
      } finally {
        (ReactSharedInternals.T = finishedWork),
          (ReactDOMSharedInternals.p = remainingLanes);
      }
    }
    0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
    ensureRootIsScheduled(root);
    remainingLanes = root.pendingLanes;
    0 !== (lanes & 261930) && 0 !== (remainingLanes & 42)
      ? root === rootWithNestedUpdates
        ? nestedUpdateCount++
        : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root))
      : (nestedUpdateCount = 0);
    flushSyncWorkAcrossRoots_impl(0, !1);
  }
}
function releaseRootPooledCache(root, remainingLanes) {
  0 === (root.pooledCacheLanes &= remainingLanes) &&
    ((remainingLanes = root.pooledCache),
    null != remainingLanes &&
      ((root.pooledCache = null), releaseCache(remainingLanes)));
}
function flushPendingEffects() {
  flushMutationEffects();
  flushLayoutEffects();
  flushSpawnedWork();
  return flushPassiveEffects();
}
function flushPassiveEffects() {
  if (5 !== pendingEffectsStatus) return !1;
  var root = pendingEffectsRoot,
    remainingLanes = pendingEffectsRemainingLanes;
  pendingEffectsRemainingLanes = 0;
  var renderPriority = lanesToEventPriority(pendingEffectsLanes),
    prevTransition = ReactSharedInternals.T,
    previousPriority = ReactDOMSharedInternals.p;
  try {
    ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
    ReactSharedInternals.T = null;
    renderPriority = pendingPassiveTransitions;
    pendingPassiveTransitions = null;
    var root$jscomp$0 = pendingEffectsRoot,
      lanes = pendingEffectsLanes;
    pendingEffectsStatus = 0;
    pendingFinishedWork = pendingEffectsRoot = null;
    pendingEffectsLanes = 0;
    if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
    var prevExecutionContext = executionContext;
    executionContext |= 4;
    commitPassiveUnmountOnFiber(root$jscomp$0.current);
    commitPassiveMountOnFiber(
      root$jscomp$0,
      root$jscomp$0.current,
      lanes,
      renderPriority
    );
    executionContext = prevExecutionContext;
    flushSyncWorkAcrossRoots_impl(0, !1);
    if (
      injectedHook &&
      "function" === typeof injectedHook.onPostCommitFiberRoot
    )
      try {
        injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
      } catch (err) {}
    return !0;
  } finally {
    (ReactDOMSharedInternals.p = previousPriority),
      (ReactSharedInternals.T = prevTransition),
      releaseRootPooledCache(root, remainingLanes);
  }
}
function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
  sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
  rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
  null !== rootFiber &&
    (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
}
function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
  if (3 === sourceFiber.tag)
    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
  else
    for (; null !== nearestMountedAncestor; ) {
      if (3 === nearestMountedAncestor.tag) {
        captureCommitPhaseErrorOnRoot(
          nearestMountedAncestor,
          sourceFiber,
          error
        );
        break;
      } else if (1 === nearestMountedAncestor.tag) {
        var instance = nearestMountedAncestor.stateNode;
        if (
          "function" ===
            typeof nearestMountedAncestor.type.getDerivedStateFromError ||
          ("function" === typeof instance.componentDidCatch &&
            (null === legacyErrorBoundariesThatAlreadyFailed ||
              !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
        ) {
          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
          error = createClassErrorUpdate(2);
          instance = enqueueUpdate(nearestMountedAncestor, error, 2);
          null !== instance &&
            (initializeClassErrorUpdate(
              error,
              instance,
              nearestMountedAncestor,
              sourceFiber
            ),
            markRootUpdated$1(instance, 2),
            ensureRootIsScheduled(instance));
          break;
        }
      }
      nearestMountedAncestor = nearestMountedAncestor.return;
    }
}
function attachPingListener(root, wakeable, lanes) {
  var pingCache = root.pingCache;
  if (null === pingCache) {
    pingCache = root.pingCache = new PossiblyWeakMap();
    var threadIDs = new Set();
    pingCache.set(wakeable, threadIDs);
  } else
    (threadIDs = pingCache.get(wakeable)),
      void 0 === threadIDs &&
        ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));
  threadIDs.has(lanes) ||
    ((workInProgressRootDidAttachPingListener = !0),
    threadIDs.add(lanes),
    (root = pingSuspendedRoot.bind(null, root, wakeable, lanes)),
    wakeable.then(root, root));
}
function pingSuspendedRoot(root, wakeable, pingedLanes) {
  var pingCache = root.pingCache;
  null !== pingCache && pingCache.delete(wakeable);
  root.pingedLanes |= root.suspendedLanes & pingedLanes;
  root.warmLanes &= ~pingedLanes;
  workInProgressRoot === root &&
    (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
    (4 === workInProgressRootExitStatus ||
    (3 === workInProgressRootExitStatus &&
      (workInProgressRootRenderLanes & 62914560) ===
        workInProgressRootRenderLanes &&
      300 > now() - globalMostRecentFallbackTime)
      ? 0 === (executionContext & 2) && prepareFreshStack(root, 0)
      : (workInProgressRootPingedLanes |= pingedLanes),
    workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes &&
      (workInProgressSuspendedRetryLanes = 0));
  ensureRootIsScheduled(root);
}
function retryTimedOutBoundary(boundaryFiber, retryLane) {
  0 === retryLane && (retryLane = claimNextRetryLane());
  boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
  null !== boundaryFiber &&
    (markRootUpdated$1(boundaryFiber, retryLane),
    ensureRootIsScheduled(boundaryFiber));
}
function retryDehydratedSuspenseBoundary(boundaryFiber) {
  var suspenseState = boundaryFiber.memoizedState,
    retryLane = 0;
  null !== suspenseState && (retryLane = suspenseState.retryLane);
  retryTimedOutBoundary(boundaryFiber, retryLane);
}
function resolveRetryWakeable(boundaryFiber, wakeable) {
  var retryLane = 0;
  switch (boundaryFiber.tag) {
    case 31:
    case 13:
      var retryCache = boundaryFiber.stateNode;
      var suspenseState = boundaryFiber.memoizedState;
      null !== suspenseState && (retryLane = suspenseState.retryLane);
      break;
    case 19:
      retryCache = boundaryFiber.stateNode;
      break;
    case 22:
      retryCache = boundaryFiber.stateNode._retryCache;
      break;
    default:
      throw Error(formatProdErrorMessage(314));
  }
  null !== retryCache && retryCache.delete(wakeable);
  retryTimedOutBoundary(boundaryFiber, retryLane);
}
function scheduleCallback$1(priorityLevel, callback) {
  return scheduleCallback$3(priorityLevel, callback);
}
var firstScheduledRoot = null,
  lastScheduledRoot = null,
  didScheduleMicrotask = !1,
  mightHavePendingSyncWork = !1,
  isFlushingWork = !1,
  currentEventTransitionLane = 0;
function ensureRootIsScheduled(root) {
  root !== lastScheduledRoot &&
    null === root.next &&
    (null === lastScheduledRoot
      ? (firstScheduledRoot = lastScheduledRoot = root)
      : (lastScheduledRoot = lastScheduledRoot.next = root));
  mightHavePendingSyncWork = !0;
  didScheduleMicrotask ||
    ((didScheduleMicrotask = !0), scheduleImmediateRootScheduleTask());
}
function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
  if (!isFlushingWork && mightHavePendingSyncWork) {
    isFlushingWork = !0;
    do {
      var didPerformSomeWork = !1;
      for (var root$170 = firstScheduledRoot; null !== root$170; ) {
        if (!onlyLegacy)
          if (0 !== syncTransitionLanes) {
            var pendingLanes = root$170.pendingLanes;
            if (0 === pendingLanes) var JSCompiler_inline_result = 0;
            else {
              var suspendedLanes = root$170.suspendedLanes,
                pingedLanes = root$170.pingedLanes;
              JSCompiler_inline_result =
                (1 << (31 - clz32(42 | syncTransitionLanes) + 1)) - 1;
              JSCompiler_inline_result &=
                pendingLanes & ~(suspendedLanes & ~pingedLanes);
              JSCompiler_inline_result =
                JSCompiler_inline_result & 201326741
                  ? (JSCompiler_inline_result & 201326741) | 1
                  : JSCompiler_inline_result
                    ? JSCompiler_inline_result | 2
                    : 0;
            }
            0 !== JSCompiler_inline_result &&
              ((didPerformSomeWork = !0),
              performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
          } else
            (JSCompiler_inline_result = workInProgressRootRenderLanes),
              (JSCompiler_inline_result = getNextLanes(
                root$170,
                root$170 === workInProgressRoot ? JSCompiler_inline_result : 0,
                null !== root$170.cancelPendingCommit ||
                  -1 !== root$170.timeoutHandle
              )),
              0 === (JSCompiler_inline_result & 3) ||
                checkIfRootIsPrerendering(root$170, JSCompiler_inline_result) ||
                ((didPerformSomeWork = !0),
                performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
        root$170 = root$170.next;
      }
    } while (didPerformSomeWork);
    isFlushingWork = !1;
  }
}
function processRootScheduleInImmediateTask() {
  processRootScheduleInMicrotask();
}
function processRootScheduleInMicrotask() {
  mightHavePendingSyncWork = didScheduleMicrotask = !1;
  var syncTransitionLanes = 0;
  0 !== currentEventTransitionLane &&
    shouldAttemptEagerTransition() &&
    (syncTransitionLanes = currentEventTransitionLane);
  for (
    var currentTime = now(), prev = null, root = firstScheduledRoot;
    null !== root;

  ) {
    var next = root.next,
      nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
    if (0 === nextLanes)
      (root.next = null),
        null === prev ? (firstScheduledRoot = next) : (prev.next = next),
        null === next && (lastScheduledRoot = prev);
    else if (
      ((prev = root), 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
    )
      mightHavePendingSyncWork = !0;
    root = next;
  }
  (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus) ||
    flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);
  0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);
}
function scheduleTaskForRootDuringMicrotask(root, currentTime) {
  for (
    var suspendedLanes = root.suspendedLanes,
      pingedLanes = root.pingedLanes,
      expirationTimes = root.expirationTimes,
      lanes = root.pendingLanes & -62914561;
    0 < lanes;

  ) {
    var index$5 = 31 - clz32(lanes),
      lane = 1 << index$5,
      expirationTime = expirationTimes[index$5];
    if (-1 === expirationTime) {
      if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
        expirationTimes[index$5] = computeExpirationTime(lane, currentTime);
    } else expirationTime <= currentTime && (root.expiredLanes |= lane);
    lanes &= ~lane;
  }
  currentTime = workInProgressRoot;
  suspendedLanes = workInProgressRootRenderLanes;
  suspendedLanes = getNextLanes(
    root,
    root === currentTime ? suspendedLanes : 0,
    null !== root.cancelPendingCommit || -1 !== root.timeoutHandle
  );
  pingedLanes = root.callbackNode;
  if (
    0 === suspendedLanes ||
    (root === currentTime &&
      (2 === workInProgressSuspendedReason ||
        9 === workInProgressSuspendedReason)) ||
    null !== root.cancelPendingCommit
  )
    return (
      null !== pingedLanes &&
        null !== pingedLanes &&
        cancelCallback$1(pingedLanes),
      (root.callbackNode = null),
      (root.callbackPriority = 0)
    );
  if (
    0 === (suspendedLanes & 3) ||
    checkIfRootIsPrerendering(root, suspendedLanes)
  ) {
    currentTime = suspendedLanes & -suspendedLanes;
    if (currentTime === root.callbackPriority) return currentTime;
    null !== pingedLanes && cancelCallback$1(pingedLanes);
    switch (lanesToEventPriority(suspendedLanes)) {
      case 2:
      case 8:
        suspendedLanes = UserBlockingPriority;
        break;
      case 32:
        suspendedLanes = NormalPriority$1;
        break;
      case 268435456:
        suspendedLanes = IdlePriority;
        break;
      default:
        suspendedLanes = NormalPriority$1;
    }
    pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
    suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
    root.callbackPriority = currentTime;
    root.callbackNode = suspendedLanes;
    return currentTime;
  }
  null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
  root.callbackPriority = 2;
  root.callbackNode = null;
  return 2;
}
function performWorkOnRootViaSchedulerTask(root, didTimeout) {
  if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
    return (root.callbackNode = null), (root.callbackPriority = 0), null;
  var originalCallbackNode = root.callbackNode;
  if (flushPendingEffects() && root.callbackNode !== originalCallbackNode)
    return null;
  var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
  workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
    root,
    root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
    null !== root.cancelPendingCommit || -1 !== root.timeoutHandle
  );
  if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
  performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);
  scheduleTaskForRootDuringMicrotask(root, now());
  return null != root.callbackNode && root.callbackNode === originalCallbackNode
    ? performWorkOnRootViaSchedulerTask.bind(null, root)
    : null;
}
function performSyncWorkOnRoot(root, lanes) {
  if (flushPendingEffects()) return null;
  performWorkOnRoot(root, lanes, !0);
}
function scheduleImmediateRootScheduleTask() {
  scheduleMicrotask(function () {
    0 !== (executionContext & 6)
      ? scheduleCallback$3(
          ImmediatePriority,
          processRootScheduleInImmediateTask
        )
      : processRootScheduleInMicrotask();
  });
}
function requestTransitionLane() {
  if (0 === currentEventTransitionLane) {
    var actionScopeLane = currentEntangledLane;
    0 === actionScopeLane &&
      ((actionScopeLane = nextTransitionUpdateLane),
      (nextTransitionUpdateLane <<= 1),
      0 === (nextTransitionUpdateLane & 261888) &&
        (nextTransitionUpdateLane = 256));
    currentEventTransitionLane = actionScopeLane;
  }
  return currentEventTransitionLane;
}
function coerceFormActionProp(actionProp) {
  return null == actionProp ||
    "symbol" === typeof actionProp ||
    "boolean" === typeof actionProp
    ? null
    : "function" === typeof actionProp
      ? actionProp
      : sanitizeURL("" + actionProp);
}
function createFormDataWithSubmitter(form, submitter) {
  var temp = submitter.ownerDocument.createElement("input");
  temp.name = submitter.name;
  temp.value = submitter.value;
  form.id && temp.setAttribute("form", form.id);
  submitter.parentNode.insertBefore(temp, submitter);
  form = new FormData(form);
  temp.parentNode.removeChild(temp);
  return form;
}
function extractEvents$1(
  dispatchQueue,
  domEventName,
  maybeTargetInst,
  nativeEvent,
  nativeEventTarget
) {
  if (
    "submit" === domEventName &&
    maybeTargetInst &&
    maybeTargetInst.stateNode === nativeEventTarget
  ) {
    var action = coerceFormActionProp(
        (nativeEventTarget[internalPropsKey] || null).action
      ),
      submitter = nativeEvent.submitter;
    submitter &&
      ((domEventName = (domEventName = submitter[internalPropsKey] || null)
        ? coerceFormActionProp(domEventName.formAction)
        : submitter.getAttribute("formAction")),
      null !== domEventName && ((action = domEventName), (submitter = null)));
    var event = new SyntheticEvent(
      "action",
      "action",
      null,
      nativeEvent,
      nativeEventTarget
    );
    dispatchQueue.push({
      event: event,
      listeners: [
        {
          instance: null,
          listener: function () {
            if (nativeEvent.defaultPrevented) {
              if (0 !== currentEventTransitionLane) {
                var formData = submitter
                  ? createFormDataWithSubmitter(nativeEventTarget, submitter)
                  : new FormData(nativeEventTarget);
                startHostTransition(
                  maybeTargetInst,
                  {
                    pending: !0,
                    data: formData,
                    method: nativeEventTarget.method,
                    action: action
                  },
                  null,
                  formData
                );
              }
            } else
              "function" === typeof action &&
                (event.preventDefault(),
                (formData = submitter
                  ? createFormDataWithSubmitter(nativeEventTarget, submitter)
                  : new FormData(nativeEventTarget)),
                startHostTransition(
                  maybeTargetInst,
                  {
                    pending: !0,
                    data: formData,
                    method: nativeEventTarget.method,
                    action: action
                  },
                  action,
                  formData
                ));
          },
          currentTarget: nativeEventTarget
        }
      ]
    });
  }
}
for (
  var i$jscomp$inline_1577 = 0;
  i$jscomp$inline_1577 < simpleEventPluginEvents.length;
  i$jscomp$inline_1577++
) {
  var eventName$jscomp$inline_1578 =
      simpleEventPluginEvents[i$jscomp$inline_1577],
    domEventName$jscomp$inline_1579 =
      eventName$jscomp$inline_1578.toLowerCase(),
    capitalizedEvent$jscomp$inline_1580 =
      eventName$jscomp$inline_1578[0].toUpperCase() +
      eventName$jscomp$inline_1578.slice(1);
  registerSimpleEvent(
    domEventName$jscomp$inline_1579,
    "on" + capitalizedEvent$jscomp$inline_1580
  );
}
registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
registerSimpleEvent(ANIMATION_START, "onAnimationStart");
registerSimpleEvent("dblclick", "onDoubleClick");
registerSimpleEvent("focusin", "onFocus");
registerSimpleEvent("focusout", "onBlur");
registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
registerSimpleEvent(TRANSITION_START, "onTransitionStart");
registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
registerTwoPhaseEvent(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
registerTwoPhaseEvent(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
registerTwoPhaseEvent("onBeforeInput", [
  "compositionend",
  "keypress",
  "textInput",
  "paste"
]);
registerTwoPhaseEvent(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
registerTwoPhaseEvent(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
registerTwoPhaseEvent(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var mediaEventTypes =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  nonDelegatedEvents = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle"
      .split(" ")
      .concat(mediaEventTypes)
  );
function processDispatchQueue(dispatchQueue, eventSystemFlags) {
  eventSystemFlags = 0 !== (eventSystemFlags & 4);
  for (var i = 0; i < dispatchQueue.length; i++) {
    var _dispatchQueue$i = dispatchQueue[i],
      event = _dispatchQueue$i.event;
    _dispatchQueue$i = _dispatchQueue$i.listeners;
    a: {
      var previousInstance = void 0;
      if (eventSystemFlags)
        for (
          var i$jscomp$0 = _dispatchQueue$i.length - 1;
          0 <= i$jscomp$0;
          i$jscomp$0--
        ) {
          var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],
            instance = _dispatchListeners$i.instance,
            currentTarget = _dispatchListeners$i.currentTarget;
          _dispatchListeners$i = _dispatchListeners$i.listener;
          if (instance !== previousInstance && event.isPropagationStopped())
            break a;
          previousInstance = _dispatchListeners$i;
          event.currentTarget = currentTarget;
          try {
            previousInstance(event);
          } catch (error) {
            reportGlobalError(error);
          }
          event.currentTarget = null;
          previousInstance = instance;
        }
      else
        for (
          i$jscomp$0 = 0;
          i$jscomp$0 < _dispatchQueue$i.length;
          i$jscomp$0++
        ) {
          _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
          instance = _dispatchListeners$i.instance;
          currentTarget = _dispatchListeners$i.currentTarget;
          _dispatchListeners$i = _dispatchListeners$i.listener;
          if (instance !== previousInstance && event.isPropagationStopped())
            break a;
          previousInstance = _dispatchListeners$i;
          event.currentTarget = currentTarget;
          try {
            previousInstance(event);
          } catch (error) {
            reportGlobalError(error);
          }
          event.currentTarget = null;
          previousInstance = instance;
        }
    }
  }
}
function listenToNonDelegatedEvent(domEventName, targetElement) {
  var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
  void 0 === JSCompiler_inline_result &&
    (JSCompiler_inline_result = targetElement[internalEventHandlersKey] =
      new Set());
  var listenerSetKey = domEventName + "__bubble";
  JSCompiler_inline_result.has(listenerSetKey) ||
    (addTrappedEventListener(targetElement, domEventName, 2, !1),
    JSCompiler_inline_result.add(listenerSetKey));
}
function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
  var eventSystemFlags = 0;
  isCapturePhaseListener && (eventSystemFlags |= 4);
  addTrappedEventListener(
    target,
    domEventName,
    eventSystemFlags,
    isCapturePhaseListener
  );
}
var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
function listenToAllSupportedEvents(rootContainerElement) {
  if (!rootContainerElement[listeningMarker]) {
    rootContainerElement[listeningMarker] = !0;
    allNativeEvents.forEach(function (domEventName) {
      "selectionchange" !== domEventName &&
        (nonDelegatedEvents.has(domEventName) ||
          listenToNativeEvent(domEventName, !1, rootContainerElement),
        listenToNativeEvent(domEventName, !0, rootContainerElement));
    });
    var ownerDocument =
      9 === rootContainerElement.nodeType
        ? rootContainerElement
        : rootContainerElement.ownerDocument;
    null === ownerDocument ||
      ownerDocument[listeningMarker] ||
      ((ownerDocument[listeningMarker] = !0),
      listenToNativeEvent("selectionchange", !1, ownerDocument));
  }
}
function addTrappedEventListener(
  targetContainer,
  domEventName,
  eventSystemFlags,
  isCapturePhaseListener
) {
  switch (getEventPriority(domEventName)) {
    case 2:
      var listenerWrapper = dispatchDiscreteEvent;
      break;
    case 8:
      listenerWrapper = dispatchContinuousEvent;
      break;
    default:
      listenerWrapper = dispatchEvent;
  }
  eventSystemFlags = listenerWrapper.bind(
    null,
    domEventName,
    eventSystemFlags,
    targetContainer
  );
  listenerWrapper = void 0;
  !passiveBrowserEventsSupported ||
    ("touchstart" !== domEventName &&
      "touchmove" !== domEventName &&
      "wheel" !== domEventName) ||
    (listenerWrapper = !0);
  isCapturePhaseListener
    ? void 0 !== listenerWrapper
      ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          capture: !0,
          passive: listenerWrapper
        })
      : targetContainer.addEventListener(domEventName, eventSystemFlags, !0)
    : void 0 !== listenerWrapper
      ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          passive: listenerWrapper
        })
      : targetContainer.addEventListener(domEventName, eventSystemFlags, !1);
}
function dispatchEventForPluginEventSystem(
  domEventName,
  eventSystemFlags,
  nativeEvent,
  targetInst$jscomp$0,
  targetContainer
) {
  var ancestorInst = targetInst$jscomp$0;
  if (
    0 === (eventSystemFlags & 1) &&
    0 === (eventSystemFlags & 2) &&
    null !== targetInst$jscomp$0
  )
    a: for (;;) {
      if (null === targetInst$jscomp$0) return;
      var nodeTag = targetInst$jscomp$0.tag;
      if (3 === nodeTag || 4 === nodeTag) {
        var container = targetInst$jscomp$0.stateNode.containerInfo;
        if (container === targetContainer) break;
        if (4 === nodeTag)
          for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
            var grandTag = nodeTag.tag;
            if (
              (3 === grandTag || 4 === grandTag) &&
              nodeTag.stateNode.containerInfo === targetContainer
            )
              return;
            nodeTag = nodeTag.return;
          }
        for (; null !== container; ) {
          nodeTag = getClosestInstanceFromNode(container);
          if (null === nodeTag) return;
          grandTag = nodeTag.tag;
          if (
            5 === grandTag ||
            6 === grandTag ||
            26 === grandTag ||
            27 === grandTag
          ) {
            targetInst$jscomp$0 = ancestorInst = nodeTag;
            continue a;
          }
          container = container.parentNode;
        }
      }
      targetInst$jscomp$0 = targetInst$jscomp$0.return;
    }
  batchedUpdates$1(function () {
    var targetInst = ancestorInst,
      nativeEventTarget = getEventTarget(nativeEvent),
      dispatchQueue = [];
    a: {
      var reactName = topLevelEventsToReactNames.get(domEventName);
      if (void 0 !== reactName) {
        var SyntheticEventCtor = SyntheticEvent,
          reactEventType = domEventName;
        switch (domEventName) {
          case "keypress":
            if (0 === getEventCharCode(nativeEvent)) break a;
          case "keydown":
          case "keyup":
            SyntheticEventCtor = SyntheticKeyboardEvent;
            break;
          case "focusin":
            reactEventType = "focus";
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "focusout":
            reactEventType = "blur";
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "beforeblur":
          case "afterblur":
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "click":
            if (2 === nativeEvent.button) break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            SyntheticEventCtor = SyntheticMouseEvent;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            SyntheticEventCtor = SyntheticDragEvent;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            SyntheticEventCtor = SyntheticTouchEvent;
            break;
          case ANIMATION_END:
          case ANIMATION_ITERATION:
          case ANIMATION_START:
            SyntheticEventCtor = SyntheticAnimationEvent;
            break;
          case TRANSITION_END:
            SyntheticEventCtor = SyntheticTransitionEvent;
            break;
          case "scroll":
          case "scrollend":
            SyntheticEventCtor = SyntheticUIEvent;
            break;
          case "wheel":
            SyntheticEventCtor = SyntheticWheelEvent;
            break;
          case "copy":
          case "cut":
          case "paste":
            SyntheticEventCtor = SyntheticClipboardEvent;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            SyntheticEventCtor = SyntheticPointerEvent;
            break;
          case "toggle":
          case "beforetoggle":
            SyntheticEventCtor = SyntheticToggleEvent;
        }
        var inCapturePhase = 0 !== (eventSystemFlags & 4),
          accumulateTargetOnly =
            !inCapturePhase &&
            ("scroll" === domEventName || "scrollend" === domEventName),
          reactEventName = inCapturePhase
            ? null !== reactName
              ? reactName + "Capture"
              : null
            : reactName;
        inCapturePhase = [];
        for (
          var instance = targetInst, lastHostComponent;
          null !== instance;

        ) {
          var _instance = instance;
          lastHostComponent = _instance.stateNode;
          _instance = _instance.tag;
          (5 !== _instance && 26 !== _instance && 27 !== _instance) ||
            null === lastHostComponent ||
            null === reactEventName ||
            ((_instance = getListener(instance, reactEventName)),
            null != _instance &&
              inCapturePhase.push(
                createDispatchListener(instance, _instance, lastHostComponent)
              ));
          if (accumulateTargetOnly) break;
          instance = instance.return;
        }
        0 < inCapturePhase.length &&
          ((reactName = new SyntheticEventCtor(
            reactName,
            reactEventType,
            null,
            nativeEvent,
            nativeEventTarget
          )),
          dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
      }
    }
    if (0 === (eventSystemFlags & 7)) {
      a: {
        reactName =
          "mouseover" === domEventName || "pointerover" === domEventName;
        SyntheticEventCtor =
          "mouseout" === domEventName || "pointerout" === domEventName;
        if (
          reactName &&
          nativeEvent !== currentReplayingEvent &&
          (reactEventType =
            nativeEvent.relatedTarget || nativeEvent.fromElement) &&
          (getClosestInstanceFromNode(reactEventType) ||
            reactEventType[internalContainerInstanceKey])
        )
          break a;
        if (SyntheticEventCtor || reactName) {
          reactName =
            nativeEventTarget.window === nativeEventTarget
              ? nativeEventTarget
              : (reactName = nativeEventTarget.ownerDocument)
                ? reactName.defaultView || reactName.parentWindow
                : window;
          if (SyntheticEventCtor) {
            if (
              ((reactEventType =
                nativeEvent.relatedTarget || nativeEvent.toElement),
              (SyntheticEventCtor = targetInst),
              (reactEventType = reactEventType
                ? getClosestInstanceFromNode(reactEventType)
                : null),
              null !== reactEventType &&
                ((accumulateTargetOnly =
                  getNearestMountedFiber(reactEventType)),
                (inCapturePhase = reactEventType.tag),
                reactEventType !== accumulateTargetOnly ||
                  (5 !== inCapturePhase &&
                    27 !== inCapturePhase &&
                    6 !== inCapturePhase)))
            )
              reactEventType = null;
          } else (SyntheticEventCtor = null), (reactEventType = targetInst);
          if (SyntheticEventCtor !== reactEventType) {
            inCapturePhase = SyntheticMouseEvent;
            _instance = "onMouseLeave";
            reactEventName = "onMouseEnter";
            instance = "mouse";
            if ("pointerout" === domEventName || "pointerover" === domEventName)
              (inCapturePhase = SyntheticPointerEvent),
                (_instance = "onPointerLeave"),
                (reactEventName = "onPointerEnter"),
                (instance = "pointer");
            accumulateTargetOnly =
              null == SyntheticEventCtor
                ? reactName
                : getNodeFromInstance(SyntheticEventCtor);
            lastHostComponent =
              null == reactEventType
                ? reactName
                : getNodeFromInstance(reactEventType);
            reactName = new inCapturePhase(
              _instance,
              instance + "leave",
              SyntheticEventCtor,
              nativeEvent,
              nativeEventTarget
            );
            reactName.target = accumulateTargetOnly;
            reactName.relatedTarget = lastHostComponent;
            _instance = null;
            getClosestInstanceFromNode(nativeEventTarget) === targetInst &&
              ((inCapturePhase = new inCapturePhase(
                reactEventName,
                instance + "enter",
                reactEventType,
                nativeEvent,
                nativeEventTarget
              )),
              (inCapturePhase.target = lastHostComponent),
              (inCapturePhase.relatedTarget = accumulateTargetOnly),
              (_instance = inCapturePhase));
            accumulateTargetOnly = _instance;
            if (SyntheticEventCtor && reactEventType)
              b: {
                inCapturePhase = getParent;
                reactEventName = SyntheticEventCtor;
                instance = reactEventType;
                lastHostComponent = 0;
                for (
                  _instance = reactEventName;
                  _instance;
                  _instance = inCapturePhase(_instance)
                )
                  lastHostComponent++;
                _instance = 0;
                for (var tempB = instance; tempB; tempB = inCapturePhase(tempB))
                  _instance++;
                for (; 0 < lastHostComponent - _instance; )
                  (reactEventName = inCapturePhase(reactEventName)),
                    lastHostComponent--;
                for (; 0 < _instance - lastHostComponent; )
                  (instance = inCapturePhase(instance)), _instance--;
                for (; lastHostComponent--; ) {
                  if (
                    reactEventName === instance ||
                    (null !== instance && reactEventName === instance.alternate)
                  ) {
                    inCapturePhase = reactEventName;
                    break b;
                  }
                  reactEventName = inCapturePhase(reactEventName);
                  instance = inCapturePhase(instance);
                }
                inCapturePhase = null;
              }
            else inCapturePhase = null;
            null !== SyntheticEventCtor &&
              accumulateEnterLeaveListenersForEvent(
                dispatchQueue,
                reactName,
                SyntheticEventCtor,
                inCapturePhase,
                !1
              );
            null !== reactEventType &&
              null !== accumulateTargetOnly &&
              accumulateEnterLeaveListenersForEvent(
                dispatchQueue,
                accumulateTargetOnly,
                reactEventType,
                inCapturePhase,
                !0
              );
          }
        }
      }
      a: {
        reactName = targetInst ? getNodeFromInstance(targetInst) : window;
        SyntheticEventCtor =
          reactName.nodeName && reactName.nodeName.toLowerCase();
        if (
          "select" === SyntheticEventCtor ||
          ("input" === SyntheticEventCtor && "file" === reactName.type)
        )
          var getTargetInstFunc = getTargetInstForChangeEvent;
        else if (isTextInputElement(reactName))
          if (isInputEventSupported)
            getTargetInstFunc = getTargetInstForInputOrChangeEvent;
          else {
            getTargetInstFunc = getTargetInstForInputEventPolyfill;
            var handleEventFunc = handleEventsForInputEventPolyfill;
          }
        else
          (SyntheticEventCtor = reactName.nodeName),
            !SyntheticEventCtor ||
            "input" !== SyntheticEventCtor.toLowerCase() ||
            ("checkbox" !== reactName.type && "radio" !== reactName.type)
              ? targetInst &&
                isCustomElement(targetInst.elementType) &&
                (getTargetInstFunc = getTargetInstForChangeEvent)
              : (getTargetInstFunc = getTargetInstForClickEvent);
        if (
          getTargetInstFunc &&
          (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))
        ) {
          createAndAccumulateChangeEvent(
            dispatchQueue,
            getTargetInstFunc,
            nativeEvent,
            nativeEventTarget
          );
          break a;
        }
        handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
        "focusout" === domEventName &&
          targetInst &&
          "number" === reactName.type &&
          null != targetInst.memoizedProps.value &&
          setDefaultValue(reactName, "number", reactName.value);
      }
      handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
      switch (domEventName) {
        case "focusin":
          if (
            isTextInputElement(handleEventFunc) ||
            "true" === handleEventFunc.contentEditable
          )
            (activeElement = handleEventFunc),
              (activeElementInst = targetInst),
              (lastSelection = null);
          break;
        case "focusout":
          lastSelection = activeElementInst = activeElement = null;
          break;
        case "mousedown":
          mouseDown = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          mouseDown = !1;
          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          break;
        case "selectionchange":
          if (skipSelectionChangeEvent) break;
        case "keydown":
        case "keyup":
          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
      }
      var fallbackData;
      if (canUseCompositionEvent)
        b: {
          switch (domEventName) {
            case "compositionstart":
              var eventType = "onCompositionStart";
              break b;
            case "compositionend":
              eventType = "onCompositionEnd";
              break b;
            case "compositionupdate":
              eventType = "onCompositionUpdate";
              break b;
          }
          eventType = void 0;
        }
      else
        isComposing
          ? isFallbackCompositionEnd(domEventName, nativeEvent) &&
            (eventType = "onCompositionEnd")
          : "keydown" === domEventName &&
            229 === nativeEvent.keyCode &&
            (eventType = "onCompositionStart");
      eventType &&
        (useFallbackCompositionData &&
          "ko" !== nativeEvent.locale &&
          (isComposing || "onCompositionStart" !== eventType
            ? "onCompositionEnd" === eventType &&
              isComposing &&
              (fallbackData = getData())
            : ((root = nativeEventTarget),
              (startText = "value" in root ? root.value : root.textContent),
              (isComposing = !0))),
        (handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType)),
        0 < handleEventFunc.length &&
          ((eventType = new SyntheticCompositionEvent(
            eventType,
            domEventName,
            null,
            nativeEvent,
            nativeEventTarget
          )),
          dispatchQueue.push({ event: eventType, listeners: handleEventFunc }),
          fallbackData
            ? (eventType.data = fallbackData)
            : ((fallbackData = getDataFromCustomEvent(nativeEvent)),
              null !== fallbackData && (eventType.data = fallbackData))));
      if (
        (fallbackData = canUseTextInputEvent
          ? getNativeBeforeInputChars(domEventName, nativeEvent)
          : getFallbackBeforeInputChars(domEventName, nativeEvent))
      )
        (eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput")),
          0 < eventType.length &&
            ((handleEventFunc = new SyntheticCompositionEvent(
              "onBeforeInput",
              "beforeinput",
              null,
              nativeEvent,
              nativeEventTarget
            )),
            dispatchQueue.push({
              event: handleEventFunc,
              listeners: eventType
            }),
            (handleEventFunc.data = fallbackData));
      extractEvents$1(
        dispatchQueue,
        domEventName,
        targetInst,
        nativeEvent,
        nativeEventTarget
      );
    }
    processDispatchQueue(dispatchQueue, eventSystemFlags);
  });
}
function createDispatchListener(instance, listener, currentTarget) {
  return {
    instance: instance,
    listener: listener,
    currentTarget: currentTarget
  };
}
function accumulateTwoPhaseListeners(targetFiber, reactName) {
  for (
    var captureName = reactName + "Capture", listeners = [];
    null !== targetFiber;

  ) {
    var _instance2 = targetFiber,
      stateNode = _instance2.stateNode;
    _instance2 = _instance2.tag;
    (5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2) ||
      null === stateNode ||
      ((_instance2 = getListener(targetFiber, captureName)),
      null != _instance2 &&
        listeners.unshift(
          createDispatchListener(targetFiber, _instance2, stateNode)
        ),
      (_instance2 = getListener(targetFiber, reactName)),
      null != _instance2 &&
        listeners.push(
          createDispatchListener(targetFiber, _instance2, stateNode)
        ));
    if (3 === targetFiber.tag) return listeners;
    targetFiber = targetFiber.return;
  }
  return [];
}
function getParent(inst) {
  if (null === inst) return null;
  do inst = inst.return;
  while (inst && 5 !== inst.tag && 27 !== inst.tag);
  return inst ? inst : null;
}
function accumulateEnterLeaveListenersForEvent(
  dispatchQueue,
  event,
  target,
  common,
  inCapturePhase
) {
  for (
    var registrationName = event._reactName, listeners = [];
    null !== target && target !== common;

  ) {
    var _instance3 = target,
      alternate = _instance3.alternate,
      stateNode = _instance3.stateNode;
    _instance3 = _instance3.tag;
    if (null !== alternate && alternate === common) break;
    (5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3) ||
      null === stateNode ||
      ((alternate = stateNode),
      inCapturePhase
        ? ((stateNode = getListener(target, registrationName)),
          null != stateNode &&
            listeners.unshift(
              createDispatchListener(target, stateNode, alternate)
            ))
        : inCapturePhase ||
          ((stateNode = getListener(target, registrationName)),
          null != stateNode &&
            listeners.push(
              createDispatchListener(target, stateNode, alternate)
            )));
    target = target.return;
  }
  0 !== listeners.length &&
    dispatchQueue.push({ event: event, listeners: listeners });
}
var NORMALIZE_NEWLINES_REGEX = /\r\n?/g,
  NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
function normalizeMarkupForTextOrAttribute(markup) {
  return ("string" === typeof markup ? markup : "" + markup)
    .replace(NORMALIZE_NEWLINES_REGEX, "\n")
    .replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
}
function checkForUnmatchedText(serverText, clientText) {
  clientText = normalizeMarkupForTextOrAttribute(clientText);
  return normalizeMarkupForTextOrAttribute(serverText) === clientText ? !0 : !1;
}
function setProp(domElement, tag, key, value, props, prevValue) {
  switch (key) {
    case "children":
      "string" === typeof value
        ? "body" === tag ||
          ("textarea" === tag && "" === value) ||
          setTextContent(domElement, value)
        : ("number" === typeof value || "bigint" === typeof value) &&
          "body" !== tag &&
          setTextContent(domElement, "" + value);
      break;
    case "className":
      setValueForKnownAttribute(domElement, "class", value);
      break;
    case "tabIndex":
      setValueForKnownAttribute(domElement, "tabindex", value);
      break;
    case "dir":
    case "role":
    case "viewBox":
    case "width":
    case "height":
      setValueForKnownAttribute(domElement, key, value);
      break;
    case "style":
      setValueForStyles(domElement, value, prevValue);
      break;
    case "data":
      if ("object" !== tag) {
        setValueForKnownAttribute(domElement, "data", value);
        break;
      }
    case "src":
    case "href":
      if ("" === value && ("a" !== tag || "href" !== key)) {
        domElement.removeAttribute(key);
        break;
      }
      if (
        null == value ||
        "function" === typeof value ||
        "symbol" === typeof value ||
        "boolean" === typeof value
      ) {
        domElement.removeAttribute(key);
        break;
      }
      value = sanitizeURL("" + value);
      domElement.setAttribute(key, value);
      break;
    case "action":
    case "formAction":
      if ("function" === typeof value) {
        domElement.setAttribute(
          key,
          "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
        );
        break;
      } else
        "function" === typeof prevValue &&
          ("formAction" === key
            ? ("input" !== tag &&
                setProp(domElement, tag, "name", props.name, props, null),
              setProp(
                domElement,
                tag,
                "formEncType",
                props.formEncType,
                props,
                null
              ),
              setProp(
                domElement,
                tag,
                "formMethod",
                props.formMethod,
                props,
                null
              ),
              setProp(
                domElement,
                tag,
                "formTarget",
                props.formTarget,
                props,
                null
              ))
            : (setProp(domElement, tag, "encType", props.encType, props, null),
              setProp(domElement, tag, "method", props.method, props, null),
              setProp(domElement, tag, "target", props.target, props, null)));
      if (
        null == value ||
        "symbol" === typeof value ||
        "boolean" === typeof value
      ) {
        domElement.removeAttribute(key);
        break;
      }
      value = sanitizeURL("" + value);
      domElement.setAttribute(key, value);
      break;
    case "onClick":
      null != value && (domElement.onclick = noop$1);
      break;
    case "onScroll":
      null != value && listenToNonDelegatedEvent("scroll", domElement);
      break;
    case "onScrollEnd":
      null != value && listenToNonDelegatedEvent("scrollend", domElement);
      break;
    case "dangerouslySetInnerHTML":
      if (null != value) {
        if ("object" !== typeof value || !("__html" in value))
          throw Error(formatProdErrorMessage(61));
        key = value.__html;
        if (null != key) {
          if (null != props.children) throw Error(formatProdErrorMessage(60));
          domElement.innerHTML = key;
        }
      }
      break;
    case "multiple":
      domElement.multiple =
        value && "function" !== typeof value && "symbol" !== typeof value;
      break;
    case "muted":
      domElement.muted =
        value && "function" !== typeof value && "symbol" !== typeof value;
      break;
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "defaultValue":
    case "defaultChecked":
    case "innerHTML":
    case "ref":
      break;
    case "autoFocus":
      break;
    case "xlinkHref":
      if (
        null == value ||
        "function" === typeof value ||
        "boolean" === typeof value ||
        "symbol" === typeof value
      ) {
        domElement.removeAttribute("xlink:href");
        break;
      }
      key = sanitizeURL("" + value);
      domElement.setAttributeNS(
        "http://www.w3.org/1999/xlink",
        "xlink:href",
        key
      );
      break;
    case "contentEditable":
    case "spellCheck":
    case "draggable":
    case "value":
    case "autoReverse":
    case "externalResourcesRequired":
    case "focusable":
    case "preserveAlpha":
      null != value && "function" !== typeof value && "symbol" !== typeof value
        ? domElement.setAttribute(key, "" + value)
        : domElement.removeAttribute(key);
      break;
    case "inert":
    case "allowFullScreen":
    case "async":
    case "autoPlay":
    case "controls":
    case "default":
    case "defer":
    case "disabled":
    case "disablePictureInPicture":
    case "disableRemotePlayback":
    case "formNoValidate":
    case "hidden":
    case "loop":
    case "noModule":
    case "noValidate":
    case "open":
    case "playsInline":
    case "readOnly":
    case "required":
    case "reversed":
    case "scoped":
    case "seamless":
    case "itemScope":
      value && "function" !== typeof value && "symbol" !== typeof value
        ? domElement.setAttribute(key, "")
        : domElement.removeAttribute(key);
      break;
    case "capture":
    case "download":
      !0 === value
        ? domElement.setAttribute(key, "")
        : !1 !== value &&
            null != value &&
            "function" !== typeof value &&
            "symbol" !== typeof value
          ? domElement.setAttribute(key, value)
          : domElement.removeAttribute(key);
      break;
    case "cols":
    case "rows":
    case "size":
    case "span":
      null != value &&
      "function" !== typeof value &&
      "symbol" !== typeof value &&
      !isNaN(value) &&
      1 <= value
        ? domElement.setAttribute(key, value)
        : domElement.removeAttribute(key);
      break;
    case "rowSpan":
    case "start":
      null == value ||
      "function" === typeof value ||
      "symbol" === typeof value ||
      isNaN(value)
        ? domElement.removeAttribute(key)
        : domElement.setAttribute(key, value);
      break;
    case "popover":
      listenToNonDelegatedEvent("beforetoggle", domElement);
      listenToNonDelegatedEvent("toggle", domElement);
      setValueForAttribute(domElement, "popover", value);
      break;
    case "xlinkActuate":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:actuate",
        value
      );
      break;
    case "xlinkArcrole":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:arcrole",
        value
      );
      break;
    case "xlinkRole":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:role",
        value
      );
      break;
    case "xlinkShow":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:show",
        value
      );
      break;
    case "xlinkTitle":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:title",
        value
      );
      break;
    case "xlinkType":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/1999/xlink",
        "xlink:type",
        value
      );
      break;
    case "xmlBase":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/XML/1998/namespace",
        "xml:base",
        value
      );
      break;
    case "xmlLang":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/XML/1998/namespace",
        "xml:lang",
        value
      );
      break;
    case "xmlSpace":
      setValueForNamespacedAttribute(
        domElement,
        "http://www.w3.org/XML/1998/namespace",
        "xml:space",
        value
      );
      break;
    case "is":
      setValueForAttribute(domElement, "is", value);
      break;
    case "innerText":
    case "textContent":
      break;
    default:
      if (
        !(2 < key.length) ||
        ("o" !== key[0] && "O" !== key[0]) ||
        ("n" !== key[1] && "N" !== key[1])
      )
        (key = aliases.get(key) || key),
          setValueForAttribute(domElement, key, value);
  }
}
function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
  switch (key) {
    case "style":
      setValueForStyles(domElement, value, prevValue);
      break;
    case "dangerouslySetInnerHTML":
      if (null != value) {
        if ("object" !== typeof value || !("__html" in value))
          throw Error(formatProdErrorMessage(61));
        key = value.__html;
        if (null != key) {
          if (null != props.children) throw Error(formatProdErrorMessage(60));
          domElement.innerHTML = key;
        }
      }
      break;
    case "children":
      "string" === typeof value
        ? setTextContent(domElement, value)
        : ("number" === typeof value || "bigint" === typeof value) &&
          setTextContent(domElement, "" + value);
      break;
    case "onScroll":
      null != value && listenToNonDelegatedEvent("scroll", domElement);
      break;
    case "onScrollEnd":
      null != value && listenToNonDelegatedEvent("scrollend", domElement);
      break;
    case "onClick":
      null != value && (domElement.onclick = noop$1);
      break;
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "innerHTML":
    case "ref":
      break;
    case "innerText":
    case "textContent":
      break;
    default:
      if (!registrationNameDependencies.hasOwnProperty(key))
        a: {
          if (
            "o" === key[0] &&
            "n" === key[1] &&
            ((props = key.endsWith("Capture")),
            (tag = key.slice(2, props ? key.length - 7 : void 0)),
            (prevValue = domElement[internalPropsKey] || null),
            (prevValue = null != prevValue ? prevValue[key] : null),
            "function" === typeof prevValue &&
              domElement.removeEventListener(tag, prevValue, props),
            "function" === typeof value)
          ) {
            "function" !== typeof prevValue &&
              null !== prevValue &&
              (key in domElement
                ? (domElement[key] = null)
                : domElement.hasAttribute(key) &&
                  domElement.removeAttribute(key));
            domElement.addEventListener(tag, value, props);
            break a;
          }
          key in domElement
            ? (domElement[key] = value)
            : !0 === value
              ? domElement.setAttribute(key, "")
              : setValueForAttribute(domElement, key, value);
        }
  }
}
function setInitialProperties(domElement, tag, props) {
  switch (tag) {
    case "div":
    case "span":
    case "svg":
    case "path":
    case "a":
    case "g":
    case "p":
    case "li":
      break;
    case "img":
      listenToNonDelegatedEvent("error", domElement);
      listenToNonDelegatedEvent("load", domElement);
      var hasSrc = !1,
        hasSrcSet = !1,
        propKey;
      for (propKey in props)
        if (props.hasOwnProperty(propKey)) {
          var propValue = props[propKey];
          if (null != propValue)
            switch (propKey) {
              case "src":
                hasSrc = !0;
                break;
              case "srcSet":
                hasSrcSet = !0;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(formatProdErrorMessage(137, tag));
              default:
                setProp(domElement, tag, propKey, propValue, props, null);
            }
        }
      hasSrcSet &&
        setProp(domElement, tag, "srcSet", props.srcSet, props, null);
      hasSrc && setProp(domElement, tag, "src", props.src, props, null);
      return;
    case "input":
      listenToNonDelegatedEvent("invalid", domElement);
      var defaultValue = (propKey = propValue = hasSrcSet = null),
        checked = null,
        defaultChecked = null;
      for (hasSrc in props)
        if (props.hasOwnProperty(hasSrc)) {
          var propValue$184 = props[hasSrc];
          if (null != propValue$184)
            switch (hasSrc) {
              case "name":
                hasSrcSet = propValue$184;
                break;
              case "type":
                propValue = propValue$184;
                break;
              case "checked":
                checked = propValue$184;
                break;
              case "defaultChecked":
                defaultChecked = propValue$184;
                break;
              case "value":
                propKey = propValue$184;
                break;
              case "defaultValue":
                defaultValue = propValue$184;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (null != propValue$184)
                  throw Error(formatProdErrorMessage(137, tag));
                break;
              default:
                setProp(domElement, tag, hasSrc, propValue$184, props, null);
            }
        }
      initInput(
        domElement,
        propKey,
        defaultValue,
        checked,
        defaultChecked,
        propValue,
        hasSrcSet,
        !1
      );
      return;
    case "select":
      listenToNonDelegatedEvent("invalid", domElement);
      hasSrc = propValue = propKey = null;
      for (hasSrcSet in props)
        if (
          props.hasOwnProperty(hasSrcSet) &&
          ((defaultValue = props[hasSrcSet]), null != defaultValue)
        )
          switch (hasSrcSet) {
            case "value":
              propKey = defaultValue;
              break;
            case "defaultValue":
              propValue = defaultValue;
              break;
            case "multiple":
              hasSrc = defaultValue;
            default:
              setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
          }
      tag = propKey;
      props = propValue;
      domElement.multiple = !!hasSrc;
      null != tag
        ? updateOptions(domElement, !!hasSrc, tag, !1)
        : null != props && updateOptions(domElement, !!hasSrc, props, !0);
      return;
    case "textarea":
      listenToNonDelegatedEvent("invalid", domElement);
      propKey = hasSrcSet = hasSrc = null;
      for (propValue in props)
        if (
          props.hasOwnProperty(propValue) &&
          ((defaultValue = props[propValue]), null != defaultValue)
        )
          switch (propValue) {
            case "value":
              hasSrc = defaultValue;
              break;
            case "defaultValue":
              hasSrcSet = defaultValue;
              break;
            case "children":
              propKey = defaultValue;
              break;
            case "dangerouslySetInnerHTML":
              if (null != defaultValue) throw Error(formatProdErrorMessage(91));
              break;
            default:
              setProp(domElement, tag, propValue, defaultValue, props, null);
          }
      initTextarea(domElement, hasSrc, hasSrcSet, propKey);
      return;
    case "option":
      for (checked in props)
        if (
          props.hasOwnProperty(checked) &&
          ((hasSrc = props[checked]), null != hasSrc)
        )
          switch (checked) {
            case "selected":
              domElement.selected =
                hasSrc &&
                "function" !== typeof hasSrc &&
                "symbol" !== typeof hasSrc;
              break;
            default:
              setProp(domElement, tag, checked, hasSrc, props, null);
          }
      return;
    case "dialog":
      listenToNonDelegatedEvent("beforetoggle", domElement);
      listenToNonDelegatedEvent("toggle", domElement);
      listenToNonDelegatedEvent("cancel", domElement);
      listenToNonDelegatedEvent("close", domElement);
      break;
    case "iframe":
    case "object":
      listenToNonDelegatedEvent("load", domElement);
      break;
    case "video":
    case "audio":
      for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
        listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
      break;
    case "image":
      listenToNonDelegatedEvent("error", domElement);
      listenToNonDelegatedEvent("load", domElement);
      break;
    case "details":
      listenToNonDelegatedEvent("toggle", domElement);
      break;
    case "embed":
    case "source":
    case "link":
      listenToNonDelegatedEvent("error", domElement),
        listenToNonDelegatedEvent("load", domElement);
    case "area":
    case "base":
    case "br":
    case "col":
    case "hr":
    case "keygen":
    case "meta":
    case "param":
    case "track":
    case "wbr":
    case "menuitem":
      for (defaultChecked in props)
        if (
          props.hasOwnProperty(defaultChecked) &&
          ((hasSrc = props[defaultChecked]), null != hasSrc)
        )
          switch (defaultChecked) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(formatProdErrorMessage(137, tag));
            default:
              setProp(domElement, tag, defaultChecked, hasSrc, props, null);
          }
      return;
    default:
      if (isCustomElement(tag)) {
        for (propValue$184 in props)
          props.hasOwnProperty(propValue$184) &&
            ((hasSrc = props[propValue$184]),
            void 0 !== hasSrc &&
              setPropOnCustomElement(
                domElement,
                tag,
                propValue$184,
                hasSrc,
                props,
                void 0
              ));
        return;
      }
  }
  for (defaultValue in props)
    props.hasOwnProperty(defaultValue) &&
      ((hasSrc = props[defaultValue]),
      null != hasSrc &&
        setProp(domElement, tag, defaultValue, hasSrc, props, null));
}
function updateProperties(domElement, tag, lastProps, nextProps) {
  switch (tag) {
    case "div":
    case "span":
    case "svg":
    case "path":
    case "a":
    case "g":
    case "p":
    case "li":
      break;
    case "input":
      var name = null,
        type = null,
        value = null,
        defaultValue = null,
        lastDefaultValue = null,
        checked = null,
        defaultChecked = null;
      for (propKey in lastProps) {
        var lastProp = lastProps[propKey];
        if (lastProps.hasOwnProperty(propKey) && null != lastProp)
          switch (propKey) {
            case "checked":
              break;
            case "value":
              break;
            case "defaultValue":
              lastDefaultValue = lastProp;
            default:
              nextProps.hasOwnProperty(propKey) ||
                setProp(domElement, tag, propKey, null, nextProps, lastProp);
          }
      }
      for (var propKey$201 in nextProps) {
        var propKey = nextProps[propKey$201];
        lastProp = lastProps[propKey$201];
        if (
          nextProps.hasOwnProperty(propKey$201) &&
          (null != propKey || null != lastProp)
        )
          switch (propKey$201) {
            case "type":
              type = propKey;
              break;
            case "name":
              name = propKey;
              break;
            case "checked":
              checked = propKey;
              break;
            case "defaultChecked":
              defaultChecked = propKey;
              break;
            case "value":
              value = propKey;
              break;
            case "defaultValue":
              defaultValue = propKey;
              break;
            case "children":
            case "dangerouslySetInnerHTML":
              if (null != propKey)
                throw Error(formatProdErrorMessage(137, tag));
              break;
            default:
              propKey !== lastProp &&
                setProp(
                  domElement,
                  tag,
                  propKey$201,
                  propKey,
                  nextProps,
                  lastProp
                );
          }
      }
      updateInput(
        domElement,
        value,
        defaultValue,
        lastDefaultValue,
        checked,
        defaultChecked,
        type,
        name
      );
      return;
    case "select":
      propKey = value = defaultValue = propKey$201 = null;
      for (type in lastProps)
        if (
          ((lastDefaultValue = lastProps[type]),
          lastProps.hasOwnProperty(type) && null != lastDefaultValue)
        )
          switch (type) {
            case "value":
              break;
            case "multiple":
              propKey = lastDefaultValue;
            default:
              nextProps.hasOwnProperty(type) ||
                setProp(
                  domElement,
                  tag,
                  type,
                  null,
                  nextProps,
                  lastDefaultValue
                );
          }
      for (name in nextProps)
        if (
          ((type = nextProps[name]),
          (lastDefaultValue = lastProps[name]),
          nextProps.hasOwnProperty(name) &&
            (null != type || null != lastDefaultValue))
        )
          switch (name) {
            case "value":
              propKey$201 = type;
              break;
            case "defaultValue":
              defaultValue = type;
              break;
            case "multiple":
              value = type;
            default:
              type !== lastDefaultValue &&
                setProp(
                  domElement,
                  tag,
                  name,
                  type,
                  nextProps,
                  lastDefaultValue
                );
          }
      tag = defaultValue;
      lastProps = value;
      nextProps = propKey;
      null != propKey$201
        ? updateOptions(domElement, !!lastProps, propKey$201, !1)
        : !!nextProps !== !!lastProps &&
          (null != tag
            ? updateOptions(domElement, !!lastProps, tag, !0)
            : updateOptions(domElement, !!lastProps, lastProps ? [] : "", !1));
      return;
    case "textarea":
      propKey = propKey$201 = null;
      for (defaultValue in lastProps)
        if (
          ((name = lastProps[defaultValue]),
          lastProps.hasOwnProperty(defaultValue) &&
            null != name &&
            !nextProps.hasOwnProperty(defaultValue))
        )
          switch (defaultValue) {
            case "value":
              break;
            case "children":
              break;
            default:
              setProp(domElement, tag, defaultValue, null, nextProps, name);
          }
      for (value in nextProps)
        if (
          ((name = nextProps[value]),
          (type = lastProps[value]),
          nextProps.hasOwnProperty(value) && (null != name || null != type))
        )
          switch (value) {
            case "value":
              propKey$201 = name;
              break;
            case "defaultValue":
              propKey = name;
              break;
            case "children":
              break;
            case "dangerouslySetInnerHTML":
              if (null != name) throw Error(formatProdErrorMessage(91));
              break;
            default:
              name !== type &&
                setProp(domElement, tag, value, name, nextProps, type);
          }
      updateTextarea(domElement, propKey$201, propKey);
      return;
    case "option":
      for (var propKey$217 in lastProps)
        if (
          ((propKey$201 = lastProps[propKey$217]),
          lastProps.hasOwnProperty(propKey$217) &&
            null != propKey$201 &&
            !nextProps.hasOwnProperty(propKey$217))
        )
          switch (propKey$217) {
            case "selected":
              domElement.selected = !1;
              break;
            default:
              setProp(
                domElement,
                tag,
                propKey$217,
                null,
                nextProps,
                propKey$201
              );
          }
      for (lastDefaultValue in nextProps)
        if (
          ((propKey$201 = nextProps[lastDefaultValue]),
          (propKey = lastProps[lastDefaultValue]),
          nextProps.hasOwnProperty(lastDefaultValue) &&
            propKey$201 !== propKey &&
            (null != propKey$201 || null != propKey))
        )
          switch (lastDefaultValue) {
            case "selected":
              domElement.selected =
                propKey$201 &&
                "function" !== typeof propKey$201 &&
                "symbol" !== typeof propKey$201;
              break;
            default:
              setProp(
                domElement,
                tag,
                lastDefaultValue,
                propKey$201,
                nextProps,
                propKey
              );
          }
      return;
    case "img":
    case "link":
    case "area":
    case "base":
    case "br":
    case "col":
    case "embed":
    case "hr":
    case "keygen":
    case "meta":
    case "param":
    case "source":
    case "track":
    case "wbr":
    case "menuitem":
      for (var propKey$222 in lastProps)
        (propKey$201 = lastProps[propKey$222]),
          lastProps.hasOwnProperty(propKey$222) &&
            null != propKey$201 &&
            !nextProps.hasOwnProperty(propKey$222) &&
            setProp(domElement, tag, propKey$222, null, nextProps, propKey$201);
      for (checked in nextProps)
        if (
          ((propKey$201 = nextProps[checked]),
          (propKey = lastProps[checked]),
          nextProps.hasOwnProperty(checked) &&
            propKey$201 !== propKey &&
            (null != propKey$201 || null != propKey))
        )
          switch (checked) {
            case "children":
            case "dangerouslySetInnerHTML":
              if (null != propKey$201)
                throw Error(formatProdErrorMessage(137, tag));
              break;
            default:
              setProp(
                domElement,
                tag,
                checked,
                propKey$201,
                nextProps,
                propKey
              );
          }
      return;
    default:
      if (isCustomElement(tag)) {
        for (var propKey$227 in lastProps)
          (propKey$201 = lastProps[propKey$227]),
            lastProps.hasOwnProperty(propKey$227) &&
              void 0 !== propKey$201 &&
              !nextProps.hasOwnProperty(propKey$227) &&
              setPropOnCustomElement(
                domElement,
                tag,
                propKey$227,
                void 0,
                nextProps,
                propKey$201
              );
        for (defaultChecked in nextProps)
          (propKey$201 = nextProps[defaultChecked]),
            (propKey = lastProps[defaultChecked]),
            !nextProps.hasOwnProperty(defaultChecked) ||
              propKey$201 === propKey ||
              (void 0 === propKey$201 && void 0 === propKey) ||
              setPropOnCustomElement(
                domElement,
                tag,
                defaultChecked,
                propKey$201,
                nextProps,
                propKey
              );
        return;
      }
  }
  for (var propKey$232 in lastProps)
    (propKey$201 = lastProps[propKey$232]),
      lastProps.hasOwnProperty(propKey$232) &&
        null != propKey$201 &&
        !nextProps.hasOwnProperty(propKey$232) &&
        setProp(domElement, tag, propKey$232, null, nextProps, propKey$201);
  for (lastProp in nextProps)
    (propKey$201 = nextProps[lastProp]),
      (propKey = lastProps[lastProp]),
      !nextProps.hasOwnProperty(lastProp) ||
        propKey$201 === propKey ||
        (null == propKey$201 && null == propKey) ||
        setProp(domElement, tag, lastProp, propKey$201, nextProps, propKey);
}
function isLikelyStaticResource(initiatorType) {
  switch (initiatorType) {
    case "css":
    case "script":
    case "font":
    case "img":
    case "image":
    case "input":
    case "link":
      return !0;
    default:
      return !1;
  }
}
function estimateBandwidth() {
  if ("function" === typeof performance.getEntriesByType) {
    for (
      var count = 0,
        bits = 0,
        resourceEntries = performance.getEntriesByType("resource"),
        i = 0;
      i < resourceEntries.length;
      i++
    ) {
      var entry = resourceEntries[i],
        transferSize = entry.transferSize,
        initiatorType = entry.initiatorType,
        duration = entry.duration;
      if (transferSize && duration && isLikelyStaticResource(initiatorType)) {
        initiatorType = 0;
        duration = entry.responseEnd;
        for (i += 1; i < resourceEntries.length; i++) {
          var overlapEntry = resourceEntries[i],
            overlapStartTime = overlapEntry.startTime;
          if (overlapStartTime > duration) break;
          var overlapTransferSize = overlapEntry.transferSize,
            overlapInitiatorType = overlapEntry.initiatorType;
          overlapTransferSize &&
            isLikelyStaticResource(overlapInitiatorType) &&
            ((overlapEntry = overlapEntry.responseEnd),
            (initiatorType +=
              overlapTransferSize *
              (overlapEntry < duration
                ? 1
                : (duration - overlapStartTime) /
                  (overlapEntry - overlapStartTime))));
        }
        --i;
        bits += (8 * (transferSize + initiatorType)) / (entry.duration / 1e3);
        count++;
        if (10 < count) break;
      }
    }
    if (0 < count) return bits / count / 1e6;
  }
  return navigator.connection &&
    ((count = navigator.connection.downlink), "number" === typeof count)
    ? count
    : 5;
}
var eventsEnabled = null,
  selectionInformation = null;
function getOwnerDocumentFromRootContainer(rootContainerElement) {
  return 9 === rootContainerElement.nodeType
    ? rootContainerElement
    : rootContainerElement.ownerDocument;
}
function getOwnHostContext(namespaceURI) {
  switch (namespaceURI) {
    case "http://www.w3.org/2000/svg":
      return 1;
    case "http://www.w3.org/1998/Math/MathML":
      return 2;
    default:
      return 0;
  }
}
function getChildHostContextProd(parentNamespace, type) {
  if (0 === parentNamespace)
    switch (type) {
      case "svg":
        return 1;
      case "math":
        return 2;
      default:
        return 0;
    }
  return 1 === parentNamespace && "foreignObject" === type
    ? 0
    : parentNamespace;
}
function shouldSetTextContent(type, props) {
  return (
    "textarea" === type ||
    "noscript" === type ||
    "string" === typeof props.children ||
    "number" === typeof props.children ||
    "bigint" === typeof props.children ||
    ("object" === typeof props.dangerouslySetInnerHTML &&
      null !== props.dangerouslySetInnerHTML &&
      null != props.dangerouslySetInnerHTML.__html)
  );
}
var currentPopstateTransitionEvent = null;
function shouldAttemptEagerTransition() {
  var event = window.event;
  if (event && "popstate" === event.type) {
    if (event === currentPopstateTransitionEvent) return !1;
    currentPopstateTransitionEvent = event;
    return !0;
  }
  currentPopstateTransitionEvent = null;
  return !1;
}
var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0,
  cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0,
  localPromise = "function" === typeof Promise ? Promise : void 0,
  scheduleMicrotask =
    "function" === typeof queueMicrotask
      ? queueMicrotask
      : "undefined" !== typeof localPromise
        ? function (callback) {
            return localPromise
              .resolve(null)
              .then(callback)
              .catch(handleErrorInNextTick);
          }
        : scheduleTimeout;
function handleErrorInNextTick(error) {
  setTimeout(function () {
    throw error;
  });
}
function isSingletonScope(type) {
  return "head" === type;
}
function clearHydrationBoundary(parentInstance, hydrationInstance) {
  var node = hydrationInstance,
    depth = 0;
  do {
    var nextNode = node.nextSibling;
    parentInstance.removeChild(node);
    if (nextNode && 8 === nextNode.nodeType)
      if (((node = nextNode.data), "/$" === node || "/&" === node)) {
        if (0 === depth) {
          parentInstance.removeChild(nextNode);
          retryIfBlockedOn(hydrationInstance);
          return;
        }
        depth--;
      } else if (
        "$" === node ||
        "$?" === node ||
        "$~" === node ||
        "$!" === node ||
        "&" === node
      )
        depth++;
      else if ("html" === node)
        releaseSingletonInstance(parentInstance.ownerDocument.documentElement);
      else if ("head" === node) {
        node = parentInstance.ownerDocument.head;
        releaseSingletonInstance(node);
        for (var node$jscomp$0 = node.firstChild; node$jscomp$0; ) {
          var nextNode$jscomp$0 = node$jscomp$0.nextSibling,
            nodeName = node$jscomp$0.nodeName;
          node$jscomp$0[internalHoistableMarker] ||
            "SCRIPT" === nodeName ||
            "STYLE" === nodeName ||
            ("LINK" === nodeName &&
              "stylesheet" === node$jscomp$0.rel.toLowerCase()) ||
            node.removeChild(node$jscomp$0);
          node$jscomp$0 = nextNode$jscomp$0;
        }
      } else
        "body" === node &&
          releaseSingletonInstance(parentInstance.ownerDocument.body);
    node = nextNode;
  } while (node);
  retryIfBlockedOn(hydrationInstance);
}
function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden) {
  var node = suspenseInstance;
  suspenseInstance = 0;
  do {
    var nextNode = node.nextSibling;
    1 === node.nodeType
      ? isHidden
        ? ((node._stashedDisplay = node.style.display),
          (node.style.display = "none"))
        : ((node.style.display = node._stashedDisplay || ""),
          "" === node.getAttribute("style") && node.removeAttribute("style"))
      : 3 === node.nodeType &&
        (isHidden
          ? ((node._stashedText = node.nodeValue), (node.nodeValue = ""))
          : (node.nodeValue = node._stashedText || ""));
    if (nextNode && 8 === nextNode.nodeType)
      if (((node = nextNode.data), "/$" === node))
        if (0 === suspenseInstance) break;
        else suspenseInstance--;
      else
        ("$" !== node && "$?" !== node && "$~" !== node && "$!" !== node) ||
          suspenseInstance++;
    node = nextNode;
  } while (node);
}
function clearContainerSparingly(container) {
  var nextNode = container.firstChild;
  nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
  for (; nextNode; ) {
    var node = nextNode;
    nextNode = nextNode.nextSibling;
    switch (node.nodeName) {
      case "HTML":
      case "HEAD":
      case "BODY":
        clearContainerSparingly(node);
        detachDeletedInstance(node);
        continue;
      case "SCRIPT":
      case "STYLE":
        continue;
      case "LINK":
        if ("stylesheet" === node.rel.toLowerCase()) continue;
    }
    container.removeChild(node);
  }
}
function canHydrateInstance(instance, type, props, inRootOrSingleton) {
  for (; 1 === instance.nodeType; ) {
    var anyProps = props;
    if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
      if (
        !inRootOrSingleton &&
        ("INPUT" !== instance.nodeName || "hidden" !== instance.type)
      )
        break;
    } else if (!inRootOrSingleton)
      if ("input" === type && "hidden" === instance.type) {
        var name = null == anyProps.name ? null : "" + anyProps.name;
        if (
          "hidden" === anyProps.type &&
          instance.getAttribute("name") === name
        )
          return instance;
      } else return instance;
    else if (!instance[internalHoistableMarker])
      switch (type) {
        case "meta":
          if (!instance.hasAttribute("itemprop")) break;
          return instance;
        case "link":
          name = instance.getAttribute("rel");
          if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
            break;
          else if (
            name !== anyProps.rel ||
            instance.getAttribute("href") !==
              (null == anyProps.href || "" === anyProps.href
                ? null
                : anyProps.href) ||
            instance.getAttribute("crossorigin") !==
              (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) ||
            instance.getAttribute("title") !==
              (null == anyProps.title ? null : anyProps.title)
          )
            break;
          return instance;
        case "style":
          if (instance.hasAttribute("data-precedence")) break;
          return instance;
        case "script":
          name = instance.getAttribute("src");
          if (
            (name !== (null == anyProps.src ? null : anyProps.src) ||
              instance.getAttribute("type") !==
                (null == anyProps.type ? null : anyProps.type) ||
              instance.getAttribute("crossorigin") !==
                (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) &&
            name &&
            instance.hasAttribute("async") &&
            !instance.hasAttribute("itemprop")
          )
            break;
          return instance;
        default:
          return instance;
      }
    instance = getNextHydratable(instance.nextSibling);
    if (null === instance) break;
  }
  return null;
}
function canHydrateTextInstance(instance, text, inRootOrSingleton) {
  if ("" === text) return null;
  for (; 3 !== instance.nodeType; ) {
    if (
      (1 !== instance.nodeType ||
        "INPUT" !== instance.nodeName ||
        "hidden" !== instance.type) &&
      !inRootOrSingleton
    )
      return null;
    instance = getNextHydratable(instance.nextSibling);
    if (null === instance) return null;
  }
  return instance;
}
function canHydrateHydrationBoundary(instance, inRootOrSingleton) {
  for (; 8 !== instance.nodeType; ) {
    if (
      (1 !== instance.nodeType ||
        "INPUT" !== instance.nodeName ||
        "hidden" !== instance.type) &&
      !inRootOrSingleton
    )
      return null;
    instance = getNextHydratable(instance.nextSibling);
    if (null === instance) return null;
  }
  return instance;
}
function isSuspenseInstancePending(instance) {
  return "$?" === instance.data || "$~" === instance.data;
}
function isSuspenseInstanceFallback(instance) {
  return (
    "$!" === instance.data ||
    ("$?" === instance.data && "loading" !== instance.ownerDocument.readyState)
  );
}
function registerSuspenseInstanceRetry(instance, callback) {
  var ownerDocument = instance.ownerDocument;
  if ("$~" === instance.data) instance._reactRetry = callback;
  else if ("$?" !== instance.data || "loading" !== ownerDocument.readyState)
    callback();
  else {
    var listener = function () {
      callback();
      ownerDocument.removeEventListener("DOMContentLoaded", listener);
    };
    ownerDocument.addEventListener("DOMContentLoaded", listener);
    instance._reactRetry = listener;
  }
}
function getNextHydratable(node) {
  for (; null != node; node = node.nextSibling) {
    var nodeType = node.nodeType;
    if (1 === nodeType || 3 === nodeType) break;
    if (8 === nodeType) {
      nodeType = node.data;
      if (
        "$" === nodeType ||
        "$!" === nodeType ||
        "$?" === nodeType ||
        "$~" === nodeType ||
        "&" === nodeType ||
        "F!" === nodeType ||
        "F" === nodeType
      )
        break;
      if ("/$" === nodeType || "/&" === nodeType) return null;
    }
  }
  return node;
}
var previousHydratableOnEnteringScopedSingleton = null;
function getNextHydratableInstanceAfterHydrationBoundary(hydrationInstance) {
  hydrationInstance = hydrationInstance.nextSibling;
  for (var depth = 0; hydrationInstance; ) {
    if (8 === hydrationInstance.nodeType) {
      var data = hydrationInstance.data;
      if ("/$" === data || "/&" === data) {
        if (0 === depth)
          return getNextHydratable(hydrationInstance.nextSibling);
        depth--;
      } else
        ("$" !== data &&
          "$!" !== data &&
          "$?" !== data &&
          "$~" !== data &&
          "&" !== data) ||
          depth++;
    }
    hydrationInstance = hydrationInstance.nextSibling;
  }
  return null;
}
function getParentHydrationBoundary(targetInstance) {
  targetInstance = targetInstance.previousSibling;
  for (var depth = 0; targetInstance; ) {
    if (8 === targetInstance.nodeType) {
      var data = targetInstance.data;
      if (
        "$" === data ||
        "$!" === data ||
        "$?" === data ||
        "$~" === data ||
        "&" === data
      ) {
        if (0 === depth) return targetInstance;
        depth--;
      } else ("/$" !== data && "/&" !== data) || depth++;
    }
    targetInstance = targetInstance.previousSibling;
  }
  return null;
}
function resolveSingletonInstance(type, props, rootContainerInstance) {
  props = getOwnerDocumentFromRootContainer(rootContainerInstance);
  switch (type) {
    case "html":
      type = props.documentElement;
      if (!type) throw Error(formatProdErrorMessage(452));
      return type;
    case "head":
      type = props.head;
      if (!type) throw Error(formatProdErrorMessage(453));
      return type;
    case "body":
      type = props.body;
      if (!type) throw Error(formatProdErrorMessage(454));
      return type;
    default:
      throw Error(formatProdErrorMessage(451));
  }
}
function releaseSingletonInstance(instance) {
  for (var attributes = instance.attributes; attributes.length; )
    instance.removeAttributeNode(attributes[0]);
  detachDeletedInstance(instance);
}
var preloadPropsMap = new Map(),
  preconnectsSet = new Set();
function getHoistableRoot(container) {
  return "function" === typeof container.getRootNode
    ? container.getRootNode()
    : 9 === container.nodeType
      ? container
      : container.ownerDocument;
}
var previousDispatcher = ReactDOMSharedInternals.d;
ReactDOMSharedInternals.d = {
  f: flushSyncWork,
  r: requestFormReset,
  D: prefetchDNS,
  C: preconnect,
  L: preload,
  m: preloadModule,
  X: preinitScript,
  S: preinitStyle,
  M: preinitModuleScript
};
function flushSyncWork() {
  var previousWasRendering = previousDispatcher.f(),
    wasRendering = flushSyncWork$1();
  return previousWasRendering || wasRendering;
}
function requestFormReset(form) {
  var formInst = getInstanceFromNode(form);
  null !== formInst && 5 === formInst.tag && "form" === formInst.type
    ? requestFormReset$1(formInst)
    : previousDispatcher.r(form);
}
var globalDocument = "undefined" === typeof document ? null : document;
function preconnectAs(rel, href, crossOrigin) {
  var ownerDocument = globalDocument;
  if (ownerDocument && "string" === typeof href && href) {
    var limitedEscapedHref =
      escapeSelectorAttributeValueInsideDoubleQuotes(href);
    limitedEscapedHref =
      'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
    "string" === typeof crossOrigin &&
      (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
    preconnectsSet.has(limitedEscapedHref) ||
      (preconnectsSet.add(limitedEscapedHref),
      (rel = { rel: rel, crossOrigin: crossOrigin, href: href }),
      null === ownerDocument.querySelector(limitedEscapedHref) &&
        ((href = ownerDocument.createElement("link")),
        setInitialProperties(href, "link", rel),
        markNodeAsHoistable(href),
        ownerDocument.head.appendChild(href)));
  }
}
function prefetchDNS(href) {
  previousDispatcher.D(href);
  preconnectAs("dns-prefetch", href, null);
}
function preconnect(href, crossOrigin) {
  previousDispatcher.C(href, crossOrigin);
  preconnectAs("preconnect", href, crossOrigin);
}
function preload(href, as, options) {
  previousDispatcher.L(href, as, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && href && as) {
    var preloadSelector =
      'link[rel="preload"][as="' +
      escapeSelectorAttributeValueInsideDoubleQuotes(as) +
      '"]';
    "image" === as
      ? options && options.imageSrcSet
        ? ((preloadSelector +=
            '[imagesrcset="' +
            escapeSelectorAttributeValueInsideDoubleQuotes(
              options.imageSrcSet
            ) +
            '"]'),
          "string" === typeof options.imageSizes &&
            (preloadSelector +=
              '[imagesizes="' +
              escapeSelectorAttributeValueInsideDoubleQuotes(
                options.imageSizes
              ) +
              '"]'))
        : (preloadSelector +=
            '[href="' +
            escapeSelectorAttributeValueInsideDoubleQuotes(href) +
            '"]')
      : (preloadSelector +=
          '[href="' +
          escapeSelectorAttributeValueInsideDoubleQuotes(href) +
          '"]');
    var key = preloadSelector;
    switch (as) {
      case "style":
        key = getStyleKey(href);
        break;
      case "script":
        key = getScriptKey(href);
    }
    preloadPropsMap.has(key) ||
      ((href = assign(
        {
          rel: "preload",
          href:
            "image" === as && options && options.imageSrcSet ? void 0 : href,
          as: as
        },
        options
      )),
      preloadPropsMap.set(key, href),
      null !== ownerDocument.querySelector(preloadSelector) ||
        ("style" === as &&
          ownerDocument.querySelector(getStylesheetSelectorFromKey(key))) ||
        ("script" === as &&
          ownerDocument.querySelector(getScriptSelectorFromKey(key))) ||
        ((as = ownerDocument.createElement("link")),
        setInitialProperties(as, "link", href),
        markNodeAsHoistable(as),
        ownerDocument.head.appendChild(as)));
  }
}
function preloadModule(href, options) {
  previousDispatcher.m(href, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && href) {
    var as = options && "string" === typeof options.as ? options.as : "script",
      preloadSelector =
        'link[rel="modulepreload"][as="' +
        escapeSelectorAttributeValueInsideDoubleQuotes(as) +
        '"][href="' +
        escapeSelectorAttributeValueInsideDoubleQuotes(href) +
        '"]',
      key = preloadSelector;
    switch (as) {
      case "audioworklet":
      case "paintworklet":
      case "serviceworker":
      case "sharedworker":
      case "worker":
      case "script":
        key = getScriptKey(href);
    }
    if (
      !preloadPropsMap.has(key) &&
      ((href = assign({ rel: "modulepreload", href: href }, options)),
      preloadPropsMap.set(key, href),
      null === ownerDocument.querySelector(preloadSelector))
    ) {
      switch (as) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
            return;
      }
      as = ownerDocument.createElement("link");
      setInitialProperties(as, "link", href);
      markNodeAsHoistable(as);
      ownerDocument.head.appendChild(as);
    }
  }
}
function preinitStyle(href, precedence, options) {
  previousDispatcher.S(href, precedence, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && href) {
    var styles = getResourcesFromRoot(ownerDocument).hoistableStyles,
      key = getStyleKey(href);
    precedence = precedence || "default";
    var resource = styles.get(key);
    if (!resource) {
      var state = { loading: 0, preload: null };
      if (
        (resource = ownerDocument.querySelector(
          getStylesheetSelectorFromKey(key)
        ))
      )
        state.loading = 5;
      else {
        href = assign(
          { rel: "stylesheet", href: href, "data-precedence": precedence },
          options
        );
        (options = preloadPropsMap.get(key)) &&
          adoptPreloadPropsForStylesheet(href, options);
        var link = (resource = ownerDocument.createElement("link"));
        markNodeAsHoistable(link);
        setInitialProperties(link, "link", href);
        link._p = new Promise(function (resolve, reject) {
          link.onload = resolve;
          link.onerror = reject;
        });
        link.addEventListener("load", function () {
          state.loading |= 1;
        });
        link.addEventListener("error", function () {
          state.loading |= 2;
        });
        state.loading |= 4;
        insertStylesheet(resource, precedence, ownerDocument);
      }
      resource = {
        type: "stylesheet",
        instance: resource,
        count: 1,
        state: state
      };
      styles.set(key, resource);
    }
  }
}
function preinitScript(src, options) {
  previousDispatcher.X(src, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && src) {
    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
      key = getScriptKey(src),
      resource = scripts.get(key);
    resource ||
      ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),
      resource ||
        ((src = assign({ src: src, async: !0 }, options)),
        (options = preloadPropsMap.get(key)) &&
          adoptPreloadPropsForScript(src, options),
        (resource = ownerDocument.createElement("script")),
        markNodeAsHoistable(resource),
        setInitialProperties(resource, "link", src),
        ownerDocument.head.appendChild(resource)),
      (resource = {
        type: "script",
        instance: resource,
        count: 1,
        state: null
      }),
      scripts.set(key, resource));
  }
}
function preinitModuleScript(src, options) {
  previousDispatcher.M(src, options);
  var ownerDocument = globalDocument;
  if (ownerDocument && src) {
    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
      key = getScriptKey(src),
      resource = scripts.get(key);
    resource ||
      ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),
      resource ||
        ((src = assign({ src: src, async: !0, type: "module" }, options)),
        (options = preloadPropsMap.get(key)) &&
          adoptPreloadPropsForScript(src, options),
        (resource = ownerDocument.createElement("script")),
        markNodeAsHoistable(resource),
        setInitialProperties(resource, "link", src),
        ownerDocument.head.appendChild(resource)),
      (resource = {
        type: "script",
        instance: resource,
        count: 1,
        state: null
      }),
      scripts.set(key, resource));
  }
}
function getResource(type, currentProps, pendingProps, currentResource) {
  var JSCompiler_inline_result = (JSCompiler_inline_result =
    rootInstanceStackCursor.current)
    ? getHoistableRoot(JSCompiler_inline_result)
    : null;
  if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
  switch (type) {
    case "meta":
    case "title":
      return null;
    case "style":
      return "string" === typeof pendingProps.precedence &&
        "string" === typeof pendingProps.href
        ? ((currentProps = getStyleKey(pendingProps.href)),
          (pendingProps = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableStyles),
          (currentResource = pendingProps.get(currentProps)),
          currentResource ||
            ((currentResource = {
              type: "style",
              instance: null,
              count: 0,
              state: null
            }),
            pendingProps.set(currentProps, currentResource)),
          currentResource)
        : { type: "void", instance: null, count: 0, state: null };
    case "link":
      if (
        "stylesheet" === pendingProps.rel &&
        "string" === typeof pendingProps.href &&
        "string" === typeof pendingProps.precedence
      ) {
        type = getStyleKey(pendingProps.href);
        var styles$243 = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableStyles,
          resource$244 = styles$243.get(type);
        resource$244 ||
          ((JSCompiler_inline_result =
            JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result),
          (resource$244 = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }),
          styles$243.set(type, resource$244),
          (styles$243 = JSCompiler_inline_result.querySelector(
            getStylesheetSelectorFromKey(type)
          )) &&
            !styles$243._p &&
            ((resource$244.instance = styles$243),
            (resource$244.state.loading = 5)),
          preloadPropsMap.has(type) ||
            ((pendingProps = {
              rel: "preload",
              as: "style",
              href: pendingProps.href,
              crossOrigin: pendingProps.crossOrigin,
              integrity: pendingProps.integrity,
              media: pendingProps.media,
              hrefLang: pendingProps.hrefLang,
              referrerPolicy: pendingProps.referrerPolicy
            }),
            preloadPropsMap.set(type, pendingProps),
            styles$243 ||
              preloadStylesheet(
                JSCompiler_inline_result,
                type,
                pendingProps,
                resource$244.state
              )));
        if (currentProps && null === currentResource)
          throw Error(formatProdErrorMessage(528, ""));
        return resource$244;
      }
      if (currentProps && null !== currentResource)
        throw Error(formatProdErrorMessage(529, ""));
      return null;
    case "script":
      return (
        (currentProps = pendingProps.async),
        (pendingProps = pendingProps.src),
        "string" === typeof pendingProps &&
        currentProps &&
        "function" !== typeof currentProps &&
        "symbol" !== typeof currentProps
          ? ((currentProps = getScriptKey(pendingProps)),
            (pendingProps = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableScripts),
            (currentResource = pendingProps.get(currentProps)),
            currentResource ||
              ((currentResource = {
                type: "script",
                instance: null,
                count: 0,
                state: null
              }),
              pendingProps.set(currentProps, currentResource)),
            currentResource)
          : { type: "void", instance: null, count: 0, state: null }
      );
    default:
      throw Error(formatProdErrorMessage(444, type));
  }
}
function getStyleKey(href) {
  return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
}
function getStylesheetSelectorFromKey(key) {
  return 'link[rel="stylesheet"][' + key + "]";
}
function stylesheetPropsFromRawProps(rawProps) {
  return assign({}, rawProps, {
    "data-precedence": rawProps.precedence,
    precedence: null
  });
}
function preloadStylesheet(ownerDocument, key, preloadProps, state) {
  ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]")
    ? (state.loading = 1)
    : ((key = ownerDocument.createElement("link")),
      (state.preload = key),
      key.addEventListener("load", function () {
        return (state.loading |= 1);
      }),
      key.addEventListener("error", function () {
        return (state.loading |= 2);
      }),
      setInitialProperties(key, "link", preloadProps),
      markNodeAsHoistable(key),
      ownerDocument.head.appendChild(key));
}
function getScriptKey(src) {
  return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
}
function getScriptSelectorFromKey(key) {
  return "script[async]" + key;
}
function acquireResource(hoistableRoot, resource, props) {
  resource.count++;
  if (null === resource.instance)
    switch (resource.type) {
      case "style":
        var instance = hoistableRoot.querySelector(
          'style[data-href~="' +
            escapeSelectorAttributeValueInsideDoubleQuotes(props.href) +
            '"]'
        );
        if (instance)
          return (
            (resource.instance = instance),
            markNodeAsHoistable(instance),
            instance
          );
        var styleProps = assign({}, props, {
          "data-href": props.href,
          "data-precedence": props.precedence,
          href: null,
          precedence: null
        });
        instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
          "style"
        );
        markNodeAsHoistable(instance);
        setInitialProperties(instance, "style", styleProps);
        insertStylesheet(instance, props.precedence, hoistableRoot);
        return (resource.instance = instance);
      case "stylesheet":
        styleProps = getStyleKey(props.href);
        var instance$249 = hoistableRoot.querySelector(
          getStylesheetSelectorFromKey(styleProps)
        );
        if (instance$249)
          return (
            (resource.state.loading |= 4),
            (resource.instance = instance$249),
            markNodeAsHoistable(instance$249),
            instance$249
          );
        instance = stylesheetPropsFromRawProps(props);
        (styleProps = preloadPropsMap.get(styleProps)) &&
          adoptPreloadPropsForStylesheet(instance, styleProps);
        instance$249 = (
          hoistableRoot.ownerDocument || hoistableRoot
        ).createElement("link");
        markNodeAsHoistable(instance$249);
        var linkInstance = instance$249;
        linkInstance._p = new Promise(function (resolve, reject) {
          linkInstance.onload = resolve;
          linkInstance.onerror = reject;
        });
        setInitialProperties(instance$249, "link", instance);
        resource.state.loading |= 4;
        insertStylesheet(instance$249, props.precedence, hoistableRoot);
        return (resource.instance = instance$249);
      case "script":
        instance$249 = getScriptKey(props.src);
        if (
          (styleProps = hoistableRoot.querySelector(
            getScriptSelectorFromKey(instance$249)
          ))
        )
          return (
            (resource.instance = styleProps),
            markNodeAsHoistable(styleProps),
            styleProps
          );
        instance = props;
        if ((styleProps = preloadPropsMap.get(instance$249)))
          (instance = assign({}, props)),
            adoptPreloadPropsForScript(instance, styleProps);
        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
        styleProps = hoistableRoot.createElement("script");
        markNodeAsHoistable(styleProps);
        setInitialProperties(styleProps, "link", instance);
        hoistableRoot.head.appendChild(styleProps);
        return (resource.instance = styleProps);
      case "void":
        return null;
      default:
        throw Error(formatProdErrorMessage(443, resource.type));
    }
  else
    "stylesheet" === resource.type &&
      0 === (resource.state.loading & 4) &&
      ((instance = resource.instance),
      (resource.state.loading |= 4),
      insertStylesheet(instance, props.precedence, hoistableRoot));
  return resource.instance;
}
function insertStylesheet(instance, precedence, root) {
  for (
    var nodes = root.querySelectorAll(
        'link[rel="stylesheet"][data-precedence],style[data-precedence]'
      ),
      last = nodes.length ? nodes[nodes.length - 1] : null,
      prior = last,
      i = 0;
    i < nodes.length;
    i++
  ) {
    var node = nodes[i];
    if (node.dataset.precedence === precedence) prior = node;
    else if (prior !== last) break;
  }
  prior
    ? prior.parentNode.insertBefore(instance, prior.nextSibling)
    : ((precedence = 9 === root.nodeType ? root.head : root),
      precedence.insertBefore(instance, precedence.firstChild));
}
function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
  null == stylesheetProps.crossOrigin &&
    (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
  null == stylesheetProps.referrerPolicy &&
    (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
  null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
}
function adoptPreloadPropsForScript(scriptProps, preloadProps) {
  null == scriptProps.crossOrigin &&
    (scriptProps.crossOrigin = preloadProps.crossOrigin);
  null == scriptProps.referrerPolicy &&
    (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
  null == scriptProps.integrity &&
    (scriptProps.integrity = preloadProps.integrity);
}
var tagCaches = null;
function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
  if (null === tagCaches) {
    var cache = new Map();
    var caches = (tagCaches = new Map());
    caches.set(ownerDocument, cache);
  } else
    (caches = tagCaches),
      (cache = caches.get(ownerDocument)),
      cache || ((cache = new Map()), caches.set(ownerDocument, cache));
  if (cache.has(type)) return cache;
  cache.set(type, null);
  ownerDocument = ownerDocument.getElementsByTagName(type);
  for (caches = 0; caches < ownerDocument.length; caches++) {
    var node = ownerDocument[caches];
    if (
      !(
        node[internalHoistableMarker] ||
        node[internalInstanceKey] ||
        ("link" === type && "stylesheet" === node.getAttribute("rel"))
      ) &&
      "http://www.w3.org/2000/svg" !== node.namespaceURI
    ) {
      var nodeKey = node.getAttribute(keyAttribute) || "";
      nodeKey = type + nodeKey;
      var existing = cache.get(nodeKey);
      existing ? existing.push(node) : cache.set(nodeKey, [node]);
    }
  }
  return cache;
}
function mountHoistable(hoistableRoot, type, instance) {
  hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
  hoistableRoot.head.insertBefore(
    instance,
    "title" === type ? hoistableRoot.querySelector("head > title") : null
  );
}
function isHostHoistableType(type, props, hostContext) {
  if (1 === hostContext || null != props.itemProp) return !1;
  switch (type) {
    case "meta":
    case "title":
      return !0;
    case "style":
      if (
        "string" !== typeof props.precedence ||
        "string" !== typeof props.href ||
        "" === props.href
      )
        break;
      return !0;
    case "link":
      if (
        "string" !== typeof props.rel ||
        "string" !== typeof props.href ||
        "" === props.href ||
        props.onLoad ||
        props.onError
      )
        break;
      switch (props.rel) {
        case "stylesheet":
          return (
            (type = props.disabled),
            "string" === typeof props.precedence && null == type
          );
        default:
          return !0;
      }
    case "script":
      if (
        props.async &&
        "function" !== typeof props.async &&
        "symbol" !== typeof props.async &&
        !props.onLoad &&
        !props.onError &&
        props.src &&
        "string" === typeof props.src
      )
        return !0;
  }
  return !1;
}
function preloadResource(resource) {
  return "stylesheet" === resource.type && 0 === (resource.state.loading & 3)
    ? !1
    : !0;
}
function suspendResource(state, hoistableRoot, resource, props) {
  if (
    "stylesheet" === resource.type &&
    ("string" !== typeof props.media ||
      !1 !== matchMedia(props.media).matches) &&
    0 === (resource.state.loading & 4)
  ) {
    if (null === resource.instance) {
      var key = getStyleKey(props.href),
        instance = hoistableRoot.querySelector(
          getStylesheetSelectorFromKey(key)
        );
      if (instance) {
        hoistableRoot = instance._p;
        null !== hoistableRoot &&
          "object" === typeof hoistableRoot &&
          "function" === typeof hoistableRoot.then &&
          (state.count++,
          (state = onUnsuspend.bind(state)),
          hoistableRoot.then(state, state));
        resource.state.loading |= 4;
        resource.instance = instance;
        markNodeAsHoistable(instance);
        return;
      }
      instance = hoistableRoot.ownerDocument || hoistableRoot;
      props = stylesheetPropsFromRawProps(props);
      (key = preloadPropsMap.get(key)) &&
        adoptPreloadPropsForStylesheet(props, key);
      instance = instance.createElement("link");
      markNodeAsHoistable(instance);
      var linkInstance = instance;
      linkInstance._p = new Promise(function (resolve, reject) {
        linkInstance.onload = resolve;
        linkInstance.onerror = reject;
      });
      setInitialProperties(instance, "link", props);
      resource.instance = instance;
    }
    null === state.stylesheets && (state.stylesheets = new Map());
    state.stylesheets.set(resource, hoistableRoot);
    (hoistableRoot = resource.state.preload) &&
      0 === (resource.state.loading & 3) &&
      (state.count++,
      (resource = onUnsuspend.bind(state)),
      hoistableRoot.addEventListener("load", resource),
      hoistableRoot.addEventListener("error", resource));
  }
}
var estimatedBytesWithinLimit = 0;
function waitForCommitToBeReady(state, timeoutOffset) {
  state.stylesheets &&
    0 === state.count &&
    insertSuspendedStylesheets(state, state.stylesheets);
  return 0 < state.count || 0 < state.imgCount
    ? function (commit) {
        var stylesheetTimer = setTimeout(function () {
          state.stylesheets &&
            insertSuspendedStylesheets(state, state.stylesheets);
          if (state.unsuspend) {
            var unsuspend = state.unsuspend;
            state.unsuspend = null;
            unsuspend();
          }
        }, 6e4 + timeoutOffset);
        0 < state.imgBytes &&
          0 === estimatedBytesWithinLimit &&
          (estimatedBytesWithinLimit = 62500 * estimateBandwidth());
        var imgTimer = setTimeout(
          function () {
            state.waitingForImages = !1;
            if (
              0 === state.count &&
              (state.stylesheets &&
                insertSuspendedStylesheets(state, state.stylesheets),
              state.unsuspend)
            ) {
              var unsuspend = state.unsuspend;
              state.unsuspend = null;
              unsuspend();
            }
          },
          (state.imgBytes > estimatedBytesWithinLimit ? 50 : 800) +
            timeoutOffset
        );
        state.unsuspend = commit;
        return function () {
          state.unsuspend = null;
          clearTimeout(stylesheetTimer);
          clearTimeout(imgTimer);
        };
      }
    : null;
}
function onUnsuspend() {
  this.count--;
  if (0 === this.count && (0 === this.imgCount || !this.waitingForImages))
    if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
    else if (this.unsuspend) {
      var unsuspend = this.unsuspend;
      this.unsuspend = null;
      unsuspend();
    }
}
var precedencesByRoot = null;
function insertSuspendedStylesheets(state, resources) {
  state.stylesheets = null;
  null !== state.unsuspend &&
    (state.count++,
    (precedencesByRoot = new Map()),
    resources.forEach(insertStylesheetIntoRoot, state),
    (precedencesByRoot = null),
    onUnsuspend.call(state));
}
function insertStylesheetIntoRoot(root, resource) {
  if (!(resource.state.loading & 4)) {
    var precedences = precedencesByRoot.get(root);
    if (precedences) var last = precedences.get(null);
    else {
      precedences = new Map();
      precedencesByRoot.set(root, precedences);
      for (
        var nodes = root.querySelectorAll(
            "link[data-precedence],style[data-precedence]"
          ),
          i = 0;
        i < nodes.length;
        i++
      ) {
        var node = nodes[i];
        if (
          "LINK" === node.nodeName ||
          "not all" !== node.getAttribute("media")
        )
          precedences.set(node.dataset.precedence, node), (last = node);
      }
      last && precedences.set(null, last);
    }
    nodes = resource.instance;
    node = nodes.getAttribute("data-precedence");
    i = precedences.get(node) || last;
    i === last && precedences.set(null, nodes);
    precedences.set(node, nodes);
    this.count++;
    last = onUnsuspend.bind(this);
    nodes.addEventListener("load", last);
    nodes.addEventListener("error", last);
    i
      ? i.parentNode.insertBefore(nodes, i.nextSibling)
      : ((root = 9 === root.nodeType ? root.head : root),
        root.insertBefore(nodes, root.firstChild));
    resource.state.loading |= 4;
  }
}
var HostTransitionContext = {
  $$typeof: REACT_CONTEXT_TYPE,
  Provider: null,
  Consumer: null,
  _currentValue: sharedNotPendingObject,
  _currentValue2: sharedNotPendingObject,
  _threadCount: 0
};
function FiberRootNode(
  containerInfo,
  tag,
  hydrate,
  identifierPrefix,
  onUncaughtError,
  onCaughtError,
  onRecoverableError,
  onDefaultTransitionIndicator,
  formState
) {
  this.tag = 1;
  this.containerInfo = containerInfo;
  this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode =
    this.next =
    this.pendingContext =
    this.context =
    this.cancelPendingCommit =
      null;
  this.callbackPriority = 0;
  this.expirationTimes = createLaneMap(-1);
  this.entangledLanes =
    this.shellSuspendCounter =
    this.errorRecoveryDisabledLanes =
    this.expiredLanes =
    this.warmLanes =
    this.pingedLanes =
    this.suspendedLanes =
    this.pendingLanes =
      0;
  this.entanglements = createLaneMap(0);
  this.hiddenUpdates = createLaneMap(null);
  this.identifierPrefix = identifierPrefix;
  this.onUncaughtError = onUncaughtError;
  this.onCaughtError = onCaughtError;
  this.onRecoverableError = onRecoverableError;
  this.pooledCache = null;
  this.pooledCacheLanes = 0;
  this.formState = formState;
  this.incompleteTransitions = new Map();
}
function createFiberRoot(
  containerInfo,
  tag,
  hydrate,
  initialChildren,
  hydrationCallbacks,
  isStrictMode,
  identifierPrefix,
  formState,
  onUncaughtError,
  onCaughtError,
  onRecoverableError,
  onDefaultTransitionIndicator
) {
  containerInfo = new FiberRootNode(
    containerInfo,
    tag,
    hydrate,
    identifierPrefix,
    onUncaughtError,
    onCaughtError,
    onRecoverableError,
    onDefaultTransitionIndicator,
    formState
  );
  tag = 1;
  !0 === isStrictMode && (tag |= 24);
  isStrictMode = createFiberImplClass(3, null, null, tag);
  containerInfo.current = isStrictMode;
  isStrictMode.stateNode = containerInfo;
  tag = createCache();
  tag.refCount++;
  containerInfo.pooledCache = tag;
  tag.refCount++;
  isStrictMode.memoizedState = {
    element: initialChildren,
    isDehydrated: hydrate,
    cache: tag
  };
  initializeUpdateQueue(isStrictMode);
  return containerInfo;
}
function getContextForSubtree(parentComponent) {
  if (!parentComponent) return emptyContextObject;
  parentComponent = emptyContextObject;
  return parentComponent;
}
function updateContainerImpl(
  rootFiber,
  lane,
  element,
  container,
  parentComponent,
  callback
) {
  parentComponent = getContextForSubtree(parentComponent);
  null === container.context
    ? (container.context = parentComponent)
    : (container.pendingContext = parentComponent);
  container = createUpdate(lane);
  container.payload = { element: element };
  callback = void 0 === callback ? null : callback;
  null !== callback && (container.callback = callback);
  element = enqueueUpdate(rootFiber, container, lane);
  null !== element &&
    (scheduleUpdateOnFiber(element, rootFiber, lane),
    entangleTransitions(element, rootFiber, lane));
}
function markRetryLaneImpl(fiber, retryLane) {
  fiber = fiber.memoizedState;
  if (null !== fiber && null !== fiber.dehydrated) {
    var a = fiber.retryLane;
    fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
  }
}
function markRetryLaneIfNotHydrated(fiber, retryLane) {
  markRetryLaneImpl(fiber, retryLane);
  (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
}
function attemptContinuousHydration(fiber) {
  if (13 === fiber.tag || 31 === fiber.tag) {
    var root = enqueueConcurrentRenderForLane(fiber, 67108864);
    null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
    markRetryLaneIfNotHydrated(fiber, 67108864);
  }
}
function attemptHydrationAtCurrentPriority(fiber) {
  if (13 === fiber.tag || 31 === fiber.tag) {
    var lane = requestUpdateLane();
    lane = getBumpedLaneForHydrationByLane(lane);
    var root = enqueueConcurrentRenderForLane(fiber, lane);
    null !== root && scheduleUpdateOnFiber(root, fiber, lane);
    markRetryLaneIfNotHydrated(fiber, lane);
  }
}
var _enabled = !0;
function dispatchDiscreteEvent(
  domEventName,
  eventSystemFlags,
  container,
  nativeEvent
) {
  var prevTransition = ReactSharedInternals.T;
  ReactSharedInternals.T = null;
  var previousPriority = ReactDOMSharedInternals.p;
  try {
    (ReactDOMSharedInternals.p = 2),
      dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
  } finally {
    (ReactDOMSharedInternals.p = previousPriority),
      (ReactSharedInternals.T = prevTransition);
  }
}
function dispatchContinuousEvent(
  domEventName,
  eventSystemFlags,
  container,
  nativeEvent
) {
  var prevTransition = ReactSharedInternals.T;
  ReactSharedInternals.T = null;
  var previousPriority = ReactDOMSharedInternals.p;
  try {
    (ReactDOMSharedInternals.p = 8),
      dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
  } finally {
    (ReactDOMSharedInternals.p = previousPriority),
      (ReactSharedInternals.T = prevTransition);
  }
}
function dispatchEvent(
  domEventName,
  eventSystemFlags,
  targetContainer,
  nativeEvent
) {
  if (_enabled) {
    var blockedOn = findInstanceBlockingEvent(nativeEvent);
    if (null === blockedOn)
      dispatchEventForPluginEventSystem(
        domEventName,
        eventSystemFlags,
        nativeEvent,
        return_targetInst,
        targetContainer
      ),
        clearIfContinuousEvent(domEventName, nativeEvent);
    else if (
      queueIfContinuousEvent(
        blockedOn,
        domEventName,
        eventSystemFlags,
        targetContainer,
        nativeEvent
      )
    )
      nativeEvent.stopPropagation();
    else if (
      (clearIfContinuousEvent(domEventName, nativeEvent),
      eventSystemFlags & 4 &&
        -1 < discreteReplayableEvents.indexOf(domEventName))
    ) {
      for (; null !== blockedOn; ) {
        var fiber = getInstanceFromNode(blockedOn);
        if (null !== fiber)
          switch (fiber.tag) {
            case 3:
              fiber = fiber.stateNode;
              if (fiber.current.memoizedState.isDehydrated) {
                var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                if (0 !== lanes) {
                  var root = fiber;
                  root.pendingLanes |= 2;
                  for (root.entangledLanes |= 2; lanes; ) {
                    var lane = 1 << (31 - clz32(lanes));
                    root.entanglements[1] |= lane;
                    lanes &= ~lane;
                  }
                  ensureRootIsScheduled(fiber);
                  0 === (executionContext & 6) &&
                    ((workInProgressRootRenderTargetTime = now() + 500),
                    flushSyncWorkAcrossRoots_impl(0, !1));
                }
              }
              break;
            case 31:
            case 13:
              (root = enqueueConcurrentRenderForLane(fiber, 2)),
                null !== root && scheduleUpdateOnFiber(root, fiber, 2),
                flushSyncWork$1(),
                markRetryLaneIfNotHydrated(fiber, 2);
          }
        fiber = findInstanceBlockingEvent(nativeEvent);
        null === fiber &&
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            return_targetInst,
            targetContainer
          );
        if (fiber === blockedOn) break;
        blockedOn = fiber;
      }
      null !== blockedOn && nativeEvent.stopPropagation();
    } else
      dispatchEventForPluginEventSystem(
        domEventName,
        eventSystemFlags,
        nativeEvent,
        null,
        targetContainer
      );
  }
}
function findInstanceBlockingEvent(nativeEvent) {
  nativeEvent = getEventTarget(nativeEvent);
  return findInstanceBlockingTarget(nativeEvent);
}
var return_targetInst = null;
function findInstanceBlockingTarget(targetNode) {
  return_targetInst = null;
  targetNode = getClosestInstanceFromNode(targetNode);
  if (null !== targetNode) {
    var nearestMounted = getNearestMountedFiber(targetNode);
    if (null === nearestMounted) targetNode = null;
    else {
      var tag = nearestMounted.tag;
      if (13 === tag) {
        targetNode = getSuspenseInstanceFromFiber(nearestMounted);
        if (null !== targetNode) return targetNode;
        targetNode = null;
      } else if (31 === tag) {
        targetNode = getActivityInstanceFromFiber(nearestMounted);
        if (null !== targetNode) return targetNode;
        targetNode = null;
      } else if (3 === tag) {
        if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
          return 3 === nearestMounted.tag
            ? nearestMounted.stateNode.containerInfo
            : null;
        targetNode = null;
      } else nearestMounted !== targetNode && (targetNode = null);
    }
  }
  return_targetInst = targetNode;
  return null;
}
function getEventPriority(domEventName) {
  switch (domEventName) {
    case "beforetoggle":
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "toggle":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 2;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 8;
    case "message":
      switch (getCurrentPriorityLevel()) {
        case ImmediatePriority:
          return 2;
        case UserBlockingPriority:
          return 8;
        case NormalPriority$1:
        case LowPriority:
          return 32;
        case IdlePriority:
          return 268435456;
        default:
          return 32;
      }
    default:
      return 32;
  }
}
var hasScheduledReplayAttempt = !1,
  queuedFocus = null,
  queuedDrag = null,
  queuedMouse = null,
  queuedPointers = new Map(),
  queuedPointerCaptures = new Map(),
  queuedExplicitHydrationTargets = [],
  discreteReplayableEvents =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
      " "
    );
function clearIfContinuousEvent(domEventName, nativeEvent) {
  switch (domEventName) {
    case "focusin":
    case "focusout":
      queuedFocus = null;
      break;
    case "dragenter":
    case "dragleave":
      queuedDrag = null;
      break;
    case "mouseover":
    case "mouseout":
      queuedMouse = null;
      break;
    case "pointerover":
    case "pointerout":
      queuedPointers.delete(nativeEvent.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      queuedPointerCaptures.delete(nativeEvent.pointerId);
  }
}
function accumulateOrCreateContinuousQueuedReplayableEvent(
  existingQueuedEvent,
  blockedOn,
  domEventName,
  eventSystemFlags,
  targetContainer,
  nativeEvent
) {
  if (
    null === existingQueuedEvent ||
    existingQueuedEvent.nativeEvent !== nativeEvent
  )
    return (
      (existingQueuedEvent = {
        blockedOn: blockedOn,
        domEventName: domEventName,
        eventSystemFlags: eventSystemFlags,
        nativeEvent: nativeEvent,
        targetContainers: [targetContainer]
      }),
      null !== blockedOn &&
        ((blockedOn = getInstanceFromNode(blockedOn)),
        null !== blockedOn && attemptContinuousHydration(blockedOn)),
      existingQueuedEvent
    );
  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
  blockedOn = existingQueuedEvent.targetContainers;
  null !== targetContainer &&
    -1 === blockedOn.indexOf(targetContainer) &&
    blockedOn.push(targetContainer);
  return existingQueuedEvent;
}
function queueIfContinuousEvent(
  blockedOn,
  domEventName,
  eventSystemFlags,
  targetContainer,
  nativeEvent
) {
  switch (domEventName) {
    case "focusin":
      return (
        (queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedFocus,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        )),
        !0
      );
    case "dragenter":
      return (
        (queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedDrag,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        )),
        !0
      );
    case "mouseover":
      return (
        (queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedMouse,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        )),
        !0
      );
    case "pointerover":
      var pointerId = nativeEvent.pointerId;
      queuedPointers.set(
        pointerId,
        accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedPointers.get(pointerId) || null,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        )
      );
      return !0;
    case "gotpointercapture":
      return (
        (pointerId = nativeEvent.pointerId),
        queuedPointerCaptures.set(
          pointerId,
          accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedPointerCaptures.get(pointerId) || null,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          )
        ),
        !0
      );
  }
  return !1;
}
function attemptExplicitHydrationTarget(queuedTarget) {
  var targetInst = getClosestInstanceFromNode(queuedTarget.target);
  if (null !== targetInst) {
    var nearestMounted = getNearestMountedFiber(targetInst);
    if (null !== nearestMounted)
      if (((targetInst = nearestMounted.tag), 13 === targetInst)) {
        if (
          ((targetInst = getSuspenseInstanceFromFiber(nearestMounted)),
          null !== targetInst)
        ) {
          queuedTarget.blockedOn = targetInst;
          runWithPriority(queuedTarget.priority, function () {
            attemptHydrationAtCurrentPriority(nearestMounted);
          });
          return;
        }
      } else if (31 === targetInst) {
        if (
          ((targetInst = getActivityInstanceFromFiber(nearestMounted)),
          null !== targetInst)
        ) {
          queuedTarget.blockedOn = targetInst;
          runWithPriority(queuedTarget.priority, function () {
            attemptHydrationAtCurrentPriority(nearestMounted);
          });
          return;
        }
      } else if (
        3 === targetInst &&
        nearestMounted.stateNode.current.memoizedState.isDehydrated
      ) {
        queuedTarget.blockedOn =
          3 === nearestMounted.tag
            ? nearestMounted.stateNode.containerInfo
            : null;
        return;
      }
  }
  queuedTarget.blockedOn = null;
}
function attemptReplayContinuousQueuedEvent(queuedEvent) {
  if (null !== queuedEvent.blockedOn) return !1;
  for (
    var targetContainers = queuedEvent.targetContainers;
    0 < targetContainers.length;

  ) {
    var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
    if (null === nextBlockedOn) {
      nextBlockedOn = queuedEvent.nativeEvent;
      var nativeEventClone = new nextBlockedOn.constructor(
        nextBlockedOn.type,
        nextBlockedOn
      );
      currentReplayingEvent = nativeEventClone;
      nextBlockedOn.target.dispatchEvent(nativeEventClone);
      currentReplayingEvent = null;
    } else
      return (
        (targetContainers = getInstanceFromNode(nextBlockedOn)),
        null !== targetContainers &&
          attemptContinuousHydration(targetContainers),
        (queuedEvent.blockedOn = nextBlockedOn),
        !1
      );
    targetContainers.shift();
  }
  return !0;
}
function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
  attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
}
function replayUnblockedEvents() {
  hasScheduledReplayAttempt = !1;
  null !== queuedFocus &&
    attemptReplayContinuousQueuedEvent(queuedFocus) &&
    (queuedFocus = null);
  null !== queuedDrag &&
    attemptReplayContinuousQueuedEvent(queuedDrag) &&
    (queuedDrag = null);
  null !== queuedMouse &&
    attemptReplayContinuousQueuedEvent(queuedMouse) &&
    (queuedMouse = null);
  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
}
function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
  queuedEvent.blockedOn === unblocked &&
    ((queuedEvent.blockedOn = null),
    hasScheduledReplayAttempt ||
      ((hasScheduledReplayAttempt = !0),
      Scheduler.unstable_scheduleCallback(
        Scheduler.unstable_NormalPriority,
        replayUnblockedEvents
      )));
}
var lastScheduledReplayQueue = null;
function scheduleReplayQueueIfNeeded(formReplayingQueue) {
  lastScheduledReplayQueue !== formReplayingQueue &&
    ((lastScheduledReplayQueue = formReplayingQueue),
    Scheduler.unstable_scheduleCallback(
      Scheduler.unstable_NormalPriority,
      function () {
        lastScheduledReplayQueue === formReplayingQueue &&
          (lastScheduledReplayQueue = null);
        for (var i = 0; i < formReplayingQueue.length; i += 3) {
          var form = formReplayingQueue[i],
            submitterOrAction = formReplayingQueue[i + 1],
            formData = formReplayingQueue[i + 2];
          if ("function" !== typeof submitterOrAction)
            if (null === findInstanceBlockingTarget(submitterOrAction || form))
              continue;
            else break;
          var formInst = getInstanceFromNode(form);
          null !== formInst &&
            (formReplayingQueue.splice(i, 3),
            (i -= 3),
            startHostTransition(
              formInst,
              {
                pending: !0,
                data: formData,
                method: form.method,
                action: submitterOrAction
              },
              submitterOrAction,
              formData
            ));
        }
      }
    ));
}
function retryIfBlockedOn(unblocked) {
  function unblock(queuedEvent) {
    return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
  }
  null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
  null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
  null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
  queuedPointers.forEach(unblock);
  queuedPointerCaptures.forEach(unblock);
  for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
    var queuedTarget = queuedExplicitHydrationTargets[i];
    queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
  }
  for (
    ;
    0 < queuedExplicitHydrationTargets.length &&
    ((i = queuedExplicitHydrationTargets[0]), null === i.blockedOn);

  )
    attemptExplicitHydrationTarget(i),
      null === i.blockedOn && queuedExplicitHydrationTargets.shift();
  i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
  if (null != i)
    for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
      var form = i[queuedTarget],
        submitterOrAction = i[queuedTarget + 1],
        formProps = form[internalPropsKey] || null;
      if ("function" === typeof submitterOrAction)
        formProps || scheduleReplayQueueIfNeeded(i);
      else if (formProps) {
        var action = null;
        if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
          if (
            ((form = submitterOrAction),
            (formProps = submitterOrAction[internalPropsKey] || null))
          )
            action = formProps.formAction;
          else {
            if (null !== findInstanceBlockingTarget(form)) continue;
          }
        else action = formProps.action;
        "function" === typeof action
          ? (i[queuedTarget + 1] = action)
          : (i.splice(queuedTarget, 3), (queuedTarget -= 3));
        scheduleReplayQueueIfNeeded(i);
      }
    }
}
function defaultOnDefaultTransitionIndicator() {
  function handleNavigate(event) {
    event.canIntercept &&
      "react-transition" === event.info &&
      event.intercept({
        handler: function () {
          return new Promise(function (resolve) {
            return (pendingResolve = resolve);
          });
        },
        focusReset: "manual",
        scroll: "manual"
      });
  }
  function handleNavigateComplete() {
    null !== pendingResolve && (pendingResolve(), (pendingResolve = null));
    isCancelled || setTimeout(startFakeNavigation, 20);
  }
  function startFakeNavigation() {
    if (!isCancelled && !navigation.transition) {
      var currentEntry = navigation.currentEntry;
      currentEntry &&
        null != currentEntry.url &&
        navigation.navigate(currentEntry.url, {
          state: currentEntry.getState(),
          info: "react-transition",
          history: "replace"
        });
    }
  }
  if ("object" === typeof navigation) {
    var isCancelled = !1,
      pendingResolve = null;
    navigation.addEventListener("navigate", handleNavigate);
    navigation.addEventListener("navigatesuccess", handleNavigateComplete);
    navigation.addEventListener("navigateerror", handleNavigateComplete);
    setTimeout(startFakeNavigation, 100);
    return function () {
      isCancelled = !0;
      navigation.removeEventListener("navigate", handleNavigate);
      navigation.removeEventListener("navigatesuccess", handleNavigateComplete);
      navigation.removeEventListener("navigateerror", handleNavigateComplete);
      null !== pendingResolve && (pendingResolve(), (pendingResolve = null));
    };
  }
}
function ReactDOMRoot(internalRoot) {
  this._internalRoot = internalRoot;
}
ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =
  function (children) {
    var root = this._internalRoot;
    if (null === root) throw Error(formatProdErrorMessage(409));
    var current = root.current,
      lane = requestUpdateLane();
    updateContainerImpl(current, lane, children, root, null, null);
  };
ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount =
  function () {
    var root = this._internalRoot;
    if (null !== root) {
      this._internalRoot = null;
      var container = root.containerInfo;
      updateContainerImpl(root.current, 2, null, root, null, null);
      flushSyncWork$1();
      container[internalContainerInstanceKey] = null;
    }
  };
function ReactDOMHydrationRoot(internalRoot) {
  this._internalRoot = internalRoot;
}
ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {
  if (target) {
    var updatePriority = resolveUpdatePriority();
    target = { blockedOn: null, target: target, priority: updatePriority };
    for (
      var i = 0;
      i < queuedExplicitHydrationTargets.length &&
      0 !== updatePriority &&
      updatePriority < queuedExplicitHydrationTargets[i].priority;
      i++
    );
    queuedExplicitHydrationTargets.splice(i, 0, target);
    0 === i && attemptExplicitHydrationTarget(target);
  }
};
var isomorphicReactPackageVersion$jscomp$inline_1840 = React.version;
if (
  "19.2.0" !==
  isomorphicReactPackageVersion$jscomp$inline_1840
)
  throw Error(
    formatProdErrorMessage(
      527,
      isomorphicReactPackageVersion$jscomp$inline_1840,
      "19.2.0"
    )
  );
ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {
  var fiber = componentOrElement._reactInternals;
  if (void 0 === fiber) {
    if ("function" === typeof componentOrElement.render)
      throw Error(formatProdErrorMessage(188));
    componentOrElement = Object.keys(componentOrElement).join(",");
    throw Error(formatProdErrorMessage(268, componentOrElement));
  }
  componentOrElement = findCurrentFiberUsingSlowPath(fiber);
  componentOrElement =
    null !== componentOrElement
      ? findCurrentHostFiberImpl(componentOrElement)
      : null;
  componentOrElement =
    null === componentOrElement ? null : componentOrElement.stateNode;
  return componentOrElement;
};
var internals$jscomp$inline_2347 = {
  bundleType: 0,
  version: "19.2.0",
  rendererPackageName: "react-dom",
  currentDispatcherRef: ReactSharedInternals,
  reconcilerVersion: "19.2.0"
};
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var hook$jscomp$inline_2348 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (
    !hook$jscomp$inline_2348.isDisabled &&
    hook$jscomp$inline_2348.supportsFiber
  )
    try {
      (rendererID = hook$jscomp$inline_2348.inject(
        internals$jscomp$inline_2347
      )),
        (injectedHook = hook$jscomp$inline_2348);
    } catch (err) {}
}
exports.createRoot = function (container, options) {
  if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
  var isStrictMode = !1,
    identifierPrefix = "",
    onUncaughtError = defaultOnUncaughtError,
    onCaughtError = defaultOnCaughtError,
    onRecoverableError = defaultOnRecoverableError;
  null !== options &&
    void 0 !== options &&
    (!0 === options.unstable_strictMode && (isStrictMode = !0),
    void 0 !== options.identifierPrefix &&
      (identifierPrefix = options.identifierPrefix),
    void 0 !== options.onUncaughtError &&
      (onUncaughtError = options.onUncaughtError),
    void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError),
    void 0 !== options.onRecoverableError &&
      (onRecoverableError = options.onRecoverableError));
  options = createFiberRoot(
    container,
    1,
    !1,
    null,
    null,
    isStrictMode,
    identifierPrefix,
    null,
    onUncaughtError,
    onCaughtError,
    onRecoverableError,
    defaultOnDefaultTransitionIndicator
  );
  container[internalContainerInstanceKey] = options.current;
  listenToAllSupportedEvents(container);
  return new ReactDOMRoot(options);
};
exports.hydrateRoot = function (container, initialChildren, options) {
  if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
  var isStrictMode = !1,
    identifierPrefix = "",
    onUncaughtError = defaultOnUncaughtError,
    onCaughtError = defaultOnCaughtError,
    onRecoverableError = defaultOnRecoverableError,
    formState = null;
  null !== options &&
    void 0 !== options &&
    (!0 === options.unstable_strictMode && (isStrictMode = !0),
    void 0 !== options.identifierPrefix &&
      (identifierPrefix = options.identifierPrefix),
    void 0 !== options.onUncaughtError &&
      (onUncaughtError = options.onUncaughtError),
    void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError),
    void 0 !== options.onRecoverableError &&
      (onRecoverableError = options.onRecoverableError),
    void 0 !== options.formState && (formState = options.formState));
  initialChildren = createFiberRoot(
    container,
    1,
    !0,
    initialChildren,
    null != options ? options : null,
    isStrictMode,
    identifierPrefix,
    formState,
    onUncaughtError,
    onCaughtError,
    onRecoverableError,
    defaultOnDefaultTransitionIndicator
  );
  initialChildren.context = getContextForSubtree(null);
  options = initialChildren.current;
  isStrictMode = requestUpdateLane();
  isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
  identifierPrefix = createUpdate(isStrictMode);
  identifierPrefix.callback = null;
  enqueueUpdate(options, identifierPrefix, isStrictMode);
  options = isStrictMode;
  initialChildren.current.lanes = options;
  markRootUpdated$1(initialChildren, options);
  ensureRootIsScheduled(initialChildren);
  container[internalContainerInstanceKey] = initialChildren.current;
  listenToAllSupportedEvents(container);
  return new ReactDOMHydrationRoot(initialChildren);
};
exports.version = "19.2.0";


}),
6221: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var React = __webpack_require__(96540);
function formatProdErrorMessage(code) {
  var url = "https://react.dev/errors/" + code;
  if (1 < arguments.length) {
    url += "?args[]=" + encodeURIComponent(arguments[1]);
    for (var i = 2; i < arguments.length; i++)
      url += "&args[]=" + encodeURIComponent(arguments[i]);
  }
  return (
    "Minified React error #" +
    code +
    "; visit " +
    url +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
function noop() {}
var Internals = {
    d: {
      f: noop,
      r: function () {
        throw Error(formatProdErrorMessage(522));
      },
      D: noop,
      C: noop,
      L: noop,
      m: noop,
      X: noop,
      S: noop,
      M: noop
    },
    p: 0,
    findDOMNode: null
  },
  REACT_PORTAL_TYPE = Symbol.for("react.portal");
function createPortal$1(children, containerInfo, implementation) {
  var key =
    3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return {
    $$typeof: REACT_PORTAL_TYPE,
    key: null == key ? null : "" + key,
    children: children,
    containerInfo: containerInfo,
    implementation: implementation
  };
}
var ReactSharedInternals =
  React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
function getCrossOriginStringAs(as, input) {
  if ("font" === as) return "";
  if ("string" === typeof input)
    return "use-credentials" === input ? input : "";
}
exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
  Internals;
exports.createPortal = function (children, container) {
  var key =
    2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (
    !container ||
    (1 !== container.nodeType &&
      9 !== container.nodeType &&
      11 !== container.nodeType)
  )
    throw Error(formatProdErrorMessage(299));
  return createPortal$1(children, container, null, key);
};
exports.flushSync = function (fn) {
  var previousTransition = ReactSharedInternals.T,
    previousUpdatePriority = Internals.p;
  try {
    if (((ReactSharedInternals.T = null), (Internals.p = 2), fn)) return fn();
  } finally {
    (ReactSharedInternals.T = previousTransition),
      (Internals.p = previousUpdatePriority),
      Internals.d.f();
  }
};
exports.preconnect = function (href, options) {
  "string" === typeof href &&
    (options
      ? ((options = options.crossOrigin),
        (options =
          "string" === typeof options
            ? "use-credentials" === options
              ? options
              : ""
            : void 0))
      : (options = null),
    Internals.d.C(href, options));
};
exports.prefetchDNS = function (href) {
  "string" === typeof href && Internals.d.D(href);
};
exports.preinit = function (href, options) {
  if ("string" === typeof href && options && "string" === typeof options.as) {
    var as = options.as,
      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),
      integrity =
        "string" === typeof options.integrity ? options.integrity : void 0,
      fetchPriority =
        "string" === typeof options.fetchPriority
          ? options.fetchPriority
          : void 0;
    "style" === as
      ? Internals.d.S(
          href,
          "string" === typeof options.precedence ? options.precedence : void 0,
          {
            crossOrigin: crossOrigin,
            integrity: integrity,
            fetchPriority: fetchPriority
          }
        )
      : "script" === as &&
        Internals.d.X(href, {
          crossOrigin: crossOrigin,
          integrity: integrity,
          fetchPriority: fetchPriority,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0
        });
  }
};
exports.preinitModule = function (href, options) {
  if ("string" === typeof href)
    if ("object" === typeof options && null !== options) {
      if (null == options.as || "script" === options.as) {
        var crossOrigin = getCrossOriginStringAs(
          options.as,
          options.crossOrigin
        );
        Internals.d.M(href, {
          crossOrigin: crossOrigin,
          integrity:
            "string" === typeof options.integrity ? options.integrity : void 0,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0
        });
      }
    } else null == options && Internals.d.M(href);
};
exports.preload = function (href, options) {
  if (
    "string" === typeof href &&
    "object" === typeof options &&
    null !== options &&
    "string" === typeof options.as
  ) {
    var as = options.as,
      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
    Internals.d.L(href, as, {
      crossOrigin: crossOrigin,
      integrity:
        "string" === typeof options.integrity ? options.integrity : void 0,
      nonce: "string" === typeof options.nonce ? options.nonce : void 0,
      type: "string" === typeof options.type ? options.type : void 0,
      fetchPriority:
        "string" === typeof options.fetchPriority
          ? options.fetchPriority
          : void 0,
      referrerPolicy:
        "string" === typeof options.referrerPolicy
          ? options.referrerPolicy
          : void 0,
      imageSrcSet:
        "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
      imageSizes:
        "string" === typeof options.imageSizes ? options.imageSizes : void 0,
      media: "string" === typeof options.media ? options.media : void 0
    });
  }
};
exports.preloadModule = function (href, options) {
  if ("string" === typeof href)
    if (options) {
      var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
      Internals.d.m(href, {
        as:
          "string" === typeof options.as && "script" !== options.as
            ? options.as
            : void 0,
        crossOrigin: crossOrigin,
        integrity:
          "string" === typeof options.integrity ? options.integrity : void 0
      });
    } else Internals.d.m(href);
};
exports.requestFormReset = function (form) {
  Internals.d.r(form);
};
exports.unstable_batchedUpdates = function (fn, a) {
  return fn(a);
};
exports.useFormState = function (action, initialState, permalink) {
  return ReactSharedInternals.H.useFormState(action, initialState, permalink);
};
exports.useFormStatus = function () {
  return ReactSharedInternals.H.useHostTransitionStatus();
};
exports.version = "19.2.0";


}),
5338: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (false) {}
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (true) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(31247);
} else {}


}),
40961: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (false) {}
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (true) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(6221);
} else {}


}),
30115: (function (module) {
/* global Map:readonly, Set:readonly, ArrayBuffer:readonly */

var hasElementType = typeof Element !== 'undefined';
var hasMap = typeof Map === 'function';
var hasSet = typeof Set === 'function';
var hasArrayBuffer = typeof ArrayBuffer === 'function' && !!ArrayBuffer.isView;

// Note: We **don't** need `envHasBigInt64Array` in fde es6/index.js

function equal(a, b) {
  // START: fast-deep-equal es6/index.js 3.1.3
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }

    // START: Modifications:
    // 1. Extra `has<Type> &&` helpers in initial condition allow es6 code
    //    to co-exist with es5.
    // 2. Replace `for of` with es5 compliant iteration using `for`.
    //    Basically, take:
    //
    //    ```js
    //    for (i of a.entries())
    //      if (!b.has(i[0])) return false;
    //    ```
    //
    //    ... and convert to:
    //
    //    ```js
    //    it = a.entries();
    //    while (!(i = it.next()).done)
    //      if (!b.has(i.value[0])) return false;
    //    ```
    //
    //    **Note**: `i` access switches to `i.value`.
    var it;
    if (hasMap && (a instanceof Map) && (b instanceof Map)) {
      if (a.size !== b.size) return false;
      it = a.entries();
      while (!(i = it.next()).done)
        if (!b.has(i.value[0])) return false;
      it = a.entries();
      while (!(i = it.next()).done)
        if (!equal(i.value[1], b.get(i.value[0]))) return false;
      return true;
    }

    if (hasSet && (a instanceof Set) && (b instanceof Set)) {
      if (a.size !== b.size) return false;
      it = a.entries();
      while (!(i = it.next()).done)
        if (!b.has(i.value[0])) return false;
      return true;
    }
    // END: Modifications

    if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (a[i] !== b[i]) return false;
      return true;
    }

    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    // START: Modifications:
    // Apply guards for `Object.create(null)` handling. See:
    // - https://github.com/FormidableLabs/react-fast-compare/issues/64
    // - https://github.com/epoberezkin/fast-deep-equal/issues/49
    if (a.valueOf !== Object.prototype.valueOf && typeof a.valueOf === 'function' && typeof b.valueOf === 'function') return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString && typeof a.toString === 'function' && typeof b.toString === 'function') return a.toString() === b.toString();
    // END: Modifications

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
    // END: fast-deep-equal

    // START: react-fast-compare
    // custom handling for DOM elements
    if (hasElementType && a instanceof Element) return false;

    // custom handling for React/Preact
    for (i = length; i-- !== 0;) {
      if ((keys[i] === '_owner' || keys[i] === '__v' || keys[i] === '__o') && a.$$typeof) {
        // React-specific: avoid traversing React elements' _owner
        // Preact-specific: avoid traversing Preact elements' __v and __o
        //    __v = $_original / $_vnode
        //    __o = $_owner
        // These properties contain circular references and are not needed when
        // comparing the actual elements (and not their owners)
        // .$$typeof and ._store on just reasonable markers of elements

        continue;
      }

      // all other properties should be traversed as usual
      if (!equal(a[keys[i]], b[keys[i]])) return false;
    }
    // END: react-fast-compare

    // START: fast-deep-equal
    return true;
  }

  return a !== a && b !== b;
}
// end fast-deep-equal

module.exports = function isEqual(a, b) {
  try {
    return equal(a, b);
  } catch (error) {
    if (((error.message || '').match(/stack|recursion/i))) {
      // warn on circular references, don't crash
      // browsers give this different errors name and messages:
      // chrome/safari: "RangeError", "Maximum call stack size exceeded"
      // firefox: "InternalError", too much recursion"
      // edge: "Error", "Out of stack space"
      console.warn('react-fast-compare cannot handle circular refs');
      return false;
    }
    // some other error. we should definitely know about these
    throw error;
  }
};


}),
80545: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  mg: () => (W),
  vd: () => (q)
});
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var prop_types__rspack_import_4 = __webpack_require__(5556);
/* import */ var prop_types__rspack_import_4_default = /*#__PURE__*/__webpack_require__.n(prop_types__rspack_import_4);
/* import */ var react_fast_compare__rspack_import_1 = __webpack_require__(30115);
/* import */ var react_fast_compare__rspack_import_1_default = /*#__PURE__*/__webpack_require__.n(react_fast_compare__rspack_import_1);
/* import */ var invariant__rspack_import_2 = __webpack_require__(20311);
/* import */ var invariant__rspack_import_2_default = /*#__PURE__*/__webpack_require__.n(invariant__rspack_import_2);
/* import */ var shallowequal__rspack_import_3 = __webpack_require__(2833);
/* import */ var shallowequal__rspack_import_3_default = /*#__PURE__*/__webpack_require__.n(shallowequal__rspack_import_3);
function a(){return a=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(t[n]=r[n])}return t},a.apply(this,arguments)}function s(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t,c(t,e)}function c(t,e){return c=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t},c(t,e)}function u(t,e){if(null==t)return{};var r,n,i={},o=Object.keys(t);for(n=0;n<o.length;n++)e.indexOf(r=o[n])>=0||(i[r]=t[r]);return i}var l={BASE:"base",BODY:"body",HEAD:"head",HTML:"html",LINK:"link",META:"meta",NOSCRIPT:"noscript",SCRIPT:"script",STYLE:"style",TITLE:"title",FRAGMENT:"Symbol(react.fragment)"},p={rel:["amphtml","canonical","alternate"]},f={type:["application/ld+json"]},d={charset:"",name:["robots","description"],property:["og:type","og:title","og:url","og:image","og:image:alt","og:description","twitter:url","twitter:title","twitter:description","twitter:image","twitter:image:alt","twitter:card","twitter:site"]},h=Object.keys(l).map(function(t){return l[t]}),m={accesskey:"accessKey",charset:"charSet",class:"className",contenteditable:"contentEditable",contextmenu:"contextMenu","http-equiv":"httpEquiv",itemprop:"itemProp",tabindex:"tabIndex"},y=Object.keys(m).reduce(function(t,e){return t[m[e]]=e,t},{}),T=function(t,e){for(var r=t.length-1;r>=0;r-=1){var n=t[r];if(Object.prototype.hasOwnProperty.call(n,e))return n[e]}return null},g=function(t){var e=T(t,l.TITLE),r=T(t,"titleTemplate");if(Array.isArray(e)&&(e=e.join("")),r&&e)return r.replace(/%s/g,function(){return e});var n=T(t,"defaultTitle");return e||n||void 0},b=function(t){return T(t,"onChangeClientState")||function(){}},v=function(t,e){return e.filter(function(e){return void 0!==e[t]}).map(function(e){return e[t]}).reduce(function(t,e){return a({},t,e)},{})},A=function(t,e){return e.filter(function(t){return void 0!==t[l.BASE]}).map(function(t){return t[l.BASE]}).reverse().reduce(function(e,r){if(!e.length)for(var n=Object.keys(r),i=0;i<n.length;i+=1){var o=n[i].toLowerCase();if(-1!==t.indexOf(o)&&r[o])return e.concat(r)}return e},[])},C=function(t,e,r){var n={};return r.filter(function(e){return!!Array.isArray(e[t])||(void 0!==e[t]&&console&&"function"==typeof console.warn&&console.warn("Helmet: "+t+' should be of type "Array". Instead found type "'+typeof e[t]+'"'),!1)}).map(function(e){return e[t]}).reverse().reduce(function(t,r){var i={};r.filter(function(t){for(var r,o=Object.keys(t),a=0;a<o.length;a+=1){var s=o[a],c=s.toLowerCase();-1===e.indexOf(c)||"rel"===r&&"canonical"===t[r].toLowerCase()||"rel"===c&&"stylesheet"===t[c].toLowerCase()||(r=c),-1===e.indexOf(s)||"innerHTML"!==s&&"cssText"!==s&&"itemprop"!==s||(r=s)}if(!r||!t[r])return!1;var u=t[r].toLowerCase();return n[r]||(n[r]={}),i[r]||(i[r]={}),!n[r][u]&&(i[r][u]=!0,!0)}).reverse().forEach(function(e){return t.push(e)});for(var o=Object.keys(i),s=0;s<o.length;s+=1){var c=o[s],u=a({},n[c],i[c]);n[c]=u}return t},[]).reverse()},O=function(t,e){if(Array.isArray(t)&&t.length)for(var r=0;r<t.length;r+=1)if(t[r][e])return!0;return!1},S=function(t){return Array.isArray(t)?t.join(""):t},E=function(t,e){return Array.isArray(t)?t.reduce(function(t,r){return function(t,e){for(var r=Object.keys(t),n=0;n<r.length;n+=1)if(e[r[n]]&&e[r[n]].includes(t[r[n]]))return!0;return!1}(r,e)?t.priority.push(r):t.default.push(r),t},{priority:[],default:[]}):{default:t}},I=function(t,e){var r;return a({},t,((r={})[e]=void 0,r))},P=[l.NOSCRIPT,l.SCRIPT,l.STYLE],w=function(t,e){return void 0===e&&(e=!0),!1===e?String(t):String(t).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#x27;")},x=function(t){return Object.keys(t).reduce(function(e,r){var n=void 0!==t[r]?r+'="'+t[r]+'"':""+r;return e?e+" "+n:n},"")},L=function(t,e){return void 0===e&&(e={}),Object.keys(t).reduce(function(e,r){return e[m[r]||r]=t[r],e},e)},j=function(e,r){return r.map(function(r,n){var i,o=((i={key:n})["data-rh"]=!0,i);return Object.keys(r).forEach(function(t){var e=m[t]||t;"innerHTML"===e||"cssText"===e?o.dangerouslySetInnerHTML={__html:r.innerHTML||r.cssText}:o[e]=r[t]}),react__rspack_import_0.createElement(e,o)})},M=function(e,r,n){switch(e){case l.TITLE:return{toComponent:function(){return n=r.titleAttributes,(i={key:e=r.title})["data-rh"]=!0,o=L(n,i),[react__rspack_import_0.createElement(l.TITLE,o,e)];var e,n,i,o},toString:function(){return function(t,e,r,n){var i=x(r),o=S(e);return i?"<"+t+' data-rh="true" '+i+">"+w(o,n)+"</"+t+">":"<"+t+' data-rh="true">'+w(o,n)+"</"+t+">"}(e,r.title,r.titleAttributes,n)}};case"bodyAttributes":case"htmlAttributes":return{toComponent:function(){return L(r)},toString:function(){return x(r)}};default:return{toComponent:function(){return j(e,r)},toString:function(){return function(t,e,r){return e.reduce(function(e,n){var i=Object.keys(n).filter(function(t){return!("innerHTML"===t||"cssText"===t)}).reduce(function(t,e){var i=void 0===n[e]?e:e+'="'+w(n[e],r)+'"';return t?t+" "+i:i},""),o=n.innerHTML||n.cssText||"",a=-1===P.indexOf(t);return e+"<"+t+' data-rh="true" '+i+(a?"/>":">"+o+"</"+t+">")},"")}(e,r,n)}}}},k=function(t){var e=t.baseTag,r=t.bodyAttributes,n=t.encode,i=t.htmlAttributes,o=t.noscriptTags,a=t.styleTags,s=t.title,c=void 0===s?"":s,u=t.titleAttributes,h=t.linkTags,m=t.metaTags,y=t.scriptTags,T={toComponent:function(){},toString:function(){return""}};if(t.prioritizeSeoTags){var g=function(t){var e=t.linkTags,r=t.scriptTags,n=t.encode,i=E(t.metaTags,d),o=E(e,p),a=E(r,f);return{priorityMethods:{toComponent:function(){return[].concat(j(l.META,i.priority),j(l.LINK,o.priority),j(l.SCRIPT,a.priority))},toString:function(){return M(l.META,i.priority,n)+" "+M(l.LINK,o.priority,n)+" "+M(l.SCRIPT,a.priority,n)}},metaTags:i.default,linkTags:o.default,scriptTags:a.default}}(t);T=g.priorityMethods,h=g.linkTags,m=g.metaTags,y=g.scriptTags}return{priority:T,base:M(l.BASE,e,n),bodyAttributes:M("bodyAttributes",r,n),htmlAttributes:M("htmlAttributes",i,n),link:M(l.LINK,h,n),meta:M(l.META,m,n),noscript:M(l.NOSCRIPT,o,n),script:M(l.SCRIPT,y,n),style:M(l.STYLE,a,n),title:M(l.TITLE,{title:c,titleAttributes:u},n)}},H=[],N=function(t,e){var r=this;void 0===e&&(e="undefined"!=typeof document),this.instances=[],this.value={setHelmet:function(t){r.context.helmet=t},helmetInstances:{get:function(){return r.canUseDOM?H:r.instances},add:function(t){(r.canUseDOM?H:r.instances).push(t)},remove:function(t){var e=(r.canUseDOM?H:r.instances).indexOf(t);(r.canUseDOM?H:r.instances).splice(e,1)}}},this.context=t,this.canUseDOM=e,e||(t.helmet=k({baseTag:[],bodyAttributes:{},encodeSpecialCharacters:!0,htmlAttributes:{},linkTags:[],metaTags:[],noscriptTags:[],scriptTags:[],styleTags:[],title:"",titleAttributes:{}}))},R=react__rspack_import_0.createContext({}),D=prop_types__rspack_import_4_default().shape({setHelmet:(prop_types__rspack_import_4_default().func),helmetInstances:prop_types__rspack_import_4_default().shape({get:(prop_types__rspack_import_4_default().func),add:(prop_types__rspack_import_4_default().func),remove:(prop_types__rspack_import_4_default().func)})}),U="undefined"!=typeof document,q=/*#__PURE__*/function(e){function r(t){var n;return(n=e.call(this,t)||this).helmetData=new N(n.props.context,r.canUseDOM),n}return s(r,e),r.prototype.render=function(){/*#__PURE__*/return react__rspack_import_0.createElement(R.Provider,{value:this.helmetData.value},this.props.children)},r}(react__rspack_import_0.Component);q.canUseDOM=U,q.propTypes={context:prop_types__rspack_import_4_default().shape({helmet:prop_types__rspack_import_4_default().shape()}),children:(prop_types__rspack_import_4_default().node.isRequired)},q.defaultProps={context:{}},q.displayName="HelmetProvider";var Y=function(t,e){var r,n=document.head||document.querySelector(l.HEAD),i=n.querySelectorAll(t+"[data-rh]"),o=[].slice.call(i),a=[];return e&&e.length&&e.forEach(function(e){var n=document.createElement(t);for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&("innerHTML"===i?n.innerHTML=e.innerHTML:"cssText"===i?n.styleSheet?n.styleSheet.cssText=e.cssText:n.appendChild(document.createTextNode(e.cssText)):n.setAttribute(i,void 0===e[i]?"":e[i]));n.setAttribute("data-rh","true"),o.some(function(t,e){return r=e,n.isEqualNode(t)})?o.splice(r,1):a.push(n)}),o.forEach(function(t){return t.parentNode.removeChild(t)}),a.forEach(function(t){return n.appendChild(t)}),{oldTags:o,newTags:a}},B=function(t,e){var r=document.getElementsByTagName(t)[0];if(r){for(var n=r.getAttribute("data-rh"),i=n?n.split(","):[],o=[].concat(i),a=Object.keys(e),s=0;s<a.length;s+=1){var c=a[s],u=e[c]||"";r.getAttribute(c)!==u&&r.setAttribute(c,u),-1===i.indexOf(c)&&i.push(c);var l=o.indexOf(c);-1!==l&&o.splice(l,1)}for(var p=o.length-1;p>=0;p-=1)r.removeAttribute(o[p]);i.length===o.length?r.removeAttribute("data-rh"):r.getAttribute("data-rh")!==a.join(",")&&r.setAttribute("data-rh",a.join(","))}},K=function(t,e){var r=t.baseTag,n=t.htmlAttributes,i=t.linkTags,o=t.metaTags,a=t.noscriptTags,s=t.onChangeClientState,c=t.scriptTags,u=t.styleTags,p=t.title,f=t.titleAttributes;B(l.BODY,t.bodyAttributes),B(l.HTML,n),function(t,e){void 0!==t&&document.title!==t&&(document.title=S(t)),B(l.TITLE,e)}(p,f);var d={baseTag:Y(l.BASE,r),linkTags:Y(l.LINK,i),metaTags:Y(l.META,o),noscriptTags:Y(l.NOSCRIPT,a),scriptTags:Y(l.SCRIPT,c),styleTags:Y(l.STYLE,u)},h={},m={};Object.keys(d).forEach(function(t){var e=d[t],r=e.newTags,n=e.oldTags;r.length&&(h[t]=r),n.length&&(m[t]=d[t].oldTags)}),e&&e(),s(t,h,m)},_=null,z=/*#__PURE__*/function(t){function e(){for(var e,r=arguments.length,n=new Array(r),i=0;i<r;i++)n[i]=arguments[i];return(e=t.call.apply(t,[this].concat(n))||this).rendered=!1,e}s(e,t);var r=e.prototype;return r.shouldComponentUpdate=function(t){return!shallowequal__rspack_import_3_default()(t,this.props)},r.componentDidUpdate=function(){this.emitChange()},r.componentWillUnmount=function(){this.props.context.helmetInstances.remove(this),this.emitChange()},r.emitChange=function(){var t,e,r=this.props.context,n=r.setHelmet,i=null,o=(t=r.helmetInstances.get().map(function(t){var e=a({},t.props);return delete e.context,e}),{baseTag:A(["href"],t),bodyAttributes:v("bodyAttributes",t),defer:T(t,"defer"),encode:T(t,"encodeSpecialCharacters"),htmlAttributes:v("htmlAttributes",t),linkTags:C(l.LINK,["rel","href"],t),metaTags:C(l.META,["name","charset","http-equiv","property","itemprop"],t),noscriptTags:C(l.NOSCRIPT,["innerHTML"],t),onChangeClientState:b(t),scriptTags:C(l.SCRIPT,["src","innerHTML"],t),styleTags:C(l.STYLE,["cssText"],t),title:g(t),titleAttributes:v("titleAttributes",t),prioritizeSeoTags:O(t,"prioritizeSeoTags")});q.canUseDOM?(e=o,_&&cancelAnimationFrame(_),e.defer?_=requestAnimationFrame(function(){K(e,function(){_=null})}):(K(e),_=null)):k&&(i=k(o)),n(i)},r.init=function(){this.rendered||(this.rendered=!0,this.props.context.helmetInstances.add(this),this.emitChange())},r.render=function(){return this.init(),null},e}(react__rspack_import_0.Component);z.propTypes={context:D.isRequired},z.displayName="HelmetDispatcher";var F=["children"],G=["children"],W=/*#__PURE__*/function(e){function r(){return e.apply(this,arguments)||this}s(r,e);var o=r.prototype;return o.shouldComponentUpdate=function(t){return!react_fast_compare__rspack_import_1_default()(I(this.props,"helmetData"),I(t,"helmetData"))},o.mapNestedChildrenToProps=function(t,e){if(!e)return null;switch(t.type){case l.SCRIPT:case l.NOSCRIPT:return{innerHTML:e};case l.STYLE:return{cssText:e};default:throw new Error("<"+t.type+" /> elements are self-closing and can not contain children. Refer to our API for more information.")}},o.flattenArrayTypeChildren=function(t){var e,r=t.child,n=t.arrayTypeChildren;return a({},n,((e={})[r.type]=[].concat(n[r.type]||[],[a({},t.newChildProps,this.mapNestedChildrenToProps(r,t.nestedChildren))]),e))},o.mapObjectTypeChildren=function(t){var e,r,n=t.child,i=t.newProps,o=t.newChildProps,s=t.nestedChildren;switch(n.type){case l.TITLE:return a({},i,((e={})[n.type]=s,e.titleAttributes=a({},o),e));case l.BODY:return a({},i,{bodyAttributes:a({},o)});case l.HTML:return a({},i,{htmlAttributes:a({},o)});default:return a({},i,((r={})[n.type]=a({},o),r))}},o.mapArrayTypeChildrenToProps=function(t,e){var r=a({},e);return Object.keys(t).forEach(function(e){var n;r=a({},r,((n={})[e]=t[e],n))}),r},o.warnOnInvalidChildren=function(t,e){return invariant__rspack_import_2_default()(h.some(function(e){return t.type===e}),"function"==typeof t.type?"You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information.":"Only elements types "+h.join(", ")+" are allowed. Helmet does not support rendering <"+t.type+"> elements. Refer to our API for more information."),invariant__rspack_import_2_default()(!e||"string"==typeof e||Array.isArray(e)&&!e.some(function(t){return"string"!=typeof t}),"Helmet expects a string as a child of <"+t.type+">. Did you forget to wrap your children in braces? ( <"+t.type+">{``}</"+t.type+"> ) Refer to our API for more information."),!0},o.mapChildrenToProps=function(e,r){var n=this,i={};return react__rspack_import_0.Children.forEach(e,function(t){if(t&&t.props){var e=t.props,o=e.children,a=u(e,F),s=Object.keys(a).reduce(function(t,e){return t[y[e]||e]=a[e],t},{}),c=t.type;switch("symbol"==typeof c?c=c.toString():n.warnOnInvalidChildren(t,o),c){case l.FRAGMENT:r=n.mapChildrenToProps(o,r);break;case l.LINK:case l.META:case l.NOSCRIPT:case l.SCRIPT:case l.STYLE:i=n.flattenArrayTypeChildren({child:t,arrayTypeChildren:i,newChildProps:s,nestedChildren:o});break;default:r=n.mapObjectTypeChildren({child:t,newProps:r,newChildProps:s,nestedChildren:o})}}}),this.mapArrayTypeChildrenToProps(i,r)},o.render=function(){var e=this.props,r=e.children,n=u(e,G),i=a({},n),o=n.helmetData;return r&&(i=this.mapChildrenToProps(r,i)),!o||o instanceof N||(o=new N(o.context,o.instances)),o?/*#__PURE__*/react__rspack_import_0.createElement(z,a({},i,{context:o.value,helmetData:void 0})):/*#__PURE__*/react__rspack_import_0.createElement(R.Consumer,null,function(e){/*#__PURE__*/return react__rspack_import_0.createElement(z,a({},i,{context:e}))})},r}(react__rspack_import_0.Component);W.propTypes={base:(prop_types__rspack_import_4_default().object),bodyAttributes:(prop_types__rspack_import_4_default().object),children:prop_types__rspack_import_4_default().oneOfType([prop_types__rspack_import_4_default().arrayOf((prop_types__rspack_import_4_default().node)),(prop_types__rspack_import_4_default().node)]),defaultTitle:(prop_types__rspack_import_4_default().string),defer:(prop_types__rspack_import_4_default().bool),encodeSpecialCharacters:(prop_types__rspack_import_4_default().bool),htmlAttributes:(prop_types__rspack_import_4_default().object),link:prop_types__rspack_import_4_default().arrayOf((prop_types__rspack_import_4_default().object)),meta:prop_types__rspack_import_4_default().arrayOf((prop_types__rspack_import_4_default().object)),noscript:prop_types__rspack_import_4_default().arrayOf((prop_types__rspack_import_4_default().object)),onChangeClientState:(prop_types__rspack_import_4_default().func),script:prop_types__rspack_import_4_default().arrayOf((prop_types__rspack_import_4_default().object)),style:prop_types__rspack_import_4_default().arrayOf((prop_types__rspack_import_4_default().object)),title:(prop_types__rspack_import_4_default().string),titleAttributes:(prop_types__rspack_import_4_default().object),titleTemplate:(prop_types__rspack_import_4_default().string),prioritizeSeoTags:(prop_types__rspack_import_4_default().bool),helmetData:(prop_types__rspack_import_4_default().object)},W.defaultProps={defer:!0,encodeSpecialCharacters:!0,prioritizeSeoTags:!1},W.displayName="Helmet";
//# sourceMappingURL=index.module.js.map


}),
22799: (function (__unused_webpack_module, exports) {
"use strict";
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;exports.Fragment=e;exports.Lazy=t;exports.Memo=r;exports.Portal=d;
exports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isAsyncMode=function(a){return A(a)||z(a)===l};exports.isConcurrentMode=A;exports.isContextConsumer=function(a){return z(a)===k};exports.isContextProvider=function(a){return z(a)===h};exports.isElement=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return z(a)===n};exports.isFragment=function(a){return z(a)===e};exports.isLazy=function(a){return z(a)===t};
exports.isMemo=function(a){return z(a)===r};exports.isPortal=function(a){return z(a)===d};exports.isProfiler=function(a){return z(a)===g};exports.isStrictMode=function(a){return z(a)===f};exports.isSuspense=function(a){return z(a)===p};
exports.isValidElementType=function(a){return"string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};exports.typeOf=z;


}),
44363: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


if (true) {
  module.exports = __webpack_require__(22799);
} else {}


}),
53259: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var React = __webpack_require__(96540);

var ALL_INITIALIZERS = [];
var READY_INITIALIZERS = [];

function isWebpackReady(getModuleIds) {
  if (false) {}

  return getModuleIds().every(function (moduleId) {
    return typeof moduleId !== "undefined" && typeof __webpack_require__.m[moduleId] !== "undefined";
  });
}

var LoadableCaptureContext = React.createContext(null);

function load(loader) {
  var promise = loader();
  var state = {
    loading: true,
    loaded: null,
    error: null
  };
  state.promise = promise.then(function (loaded) {
    state.loading = false;
    state.loaded = loaded;
    return loaded;
  }).catch(function (err) {
    state.loading = false;
    state.error = err;
    throw err;
  });
  return state;
}

function loadMap(obj) {
  var state = {
    loading: false,
    loaded: {},
    error: null
  };
  var promises = [];

  try {
    Object.keys(obj).forEach(function (key) {
      var result = load(obj[key]);

      if (!result.loading) {
        state.loaded[key] = result.loaded;
        state.error = result.error;
      } else {
        state.loading = true;
      }

      promises.push(result.promise);
      result.promise.then(function (res) {
        state.loaded[key] = res;
      }).catch(function (err) {
        state.error = err;
      });
    });
  } catch (err) {
    state.error = err;
  }

  state.promise = Promise.all(promises).then(function (res) {
    state.loading = false;
    return res;
  }).catch(function (err) {
    state.loading = false;
    throw err;
  });
  return state;
}

function resolve(obj) {
  return obj && obj.__esModule ? obj.default : obj;
}

function render(loaded, props) {
  return React.createElement(resolve(loaded), props);
}

function createLoadableComponent(loadFn, options) {
  var _class, _temp;

  if (!options.loading) {
    throw new Error("react-loadable requires a `loading` component");
  }

  var opts = _extends({
    loader: null,
    loading: null,
    delay: 200,
    timeout: null,
    render: render,
    webpack: null,
    modules: null
  }, options);

  var res = null;

  function init() {
    if (!res) {
      res = loadFn(opts.loader);
    }

    return res.promise;
  }

  ALL_INITIALIZERS.push(init);

  if (typeof opts.webpack === "function") {
    READY_INITIALIZERS.push(function () {
      if (isWebpackReady(opts.webpack)) {
        return init();
      }
    });
  }

  return _temp = _class =
  /*#__PURE__*/
  function (_React$Component) {
    _inheritsLoose(LoadableComponent, _React$Component);

    function LoadableComponent(props) {
      var _this;

      _this = _React$Component.call(this, props) || this;

      _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "retry", function () {
        _this.setState({
          error: null,
          loading: true,
          timedOut: false
        });

        res = loadFn(opts.loader);

        _this._loadModule();
      });

      init();
      _this.state = {
        error: res.error,
        pastDelay: false,
        timedOut: false,
        loading: res.loading,
        loaded: res.loaded
      };
      return _this;
    }

    LoadableComponent.preload = function preload() {
      return init();
    };

    var _proto = LoadableComponent.prototype;

    _proto.UNSAFE_componentWillMount = function UNSAFE_componentWillMount() {
      this._loadModule();
    };

    _proto.componentDidMount = function componentDidMount() {
      this._mounted = true;
    };

    _proto._loadModule = function _loadModule() {
      var _this2 = this;

      if (this.context && Array.isArray(opts.modules)) {
        opts.modules.forEach(function (moduleName) {
          _this2.context.report(moduleName);
        });
      }

      if (!res.loading) {
        return;
      }

      var setStateWithMountCheck = function setStateWithMountCheck(newState) {
        if (!_this2._mounted) {
          return;
        }

        _this2.setState(newState);
      };

      if (typeof opts.delay === 'number') {
        if (opts.delay === 0) {
          this.setState({
            pastDelay: true
          });
        } else {
          this._delay = setTimeout(function () {
            setStateWithMountCheck({
              pastDelay: true
            });
          }, opts.delay);
        }
      }

      if (typeof opts.timeout === "number") {
        this._timeout = setTimeout(function () {
          setStateWithMountCheck({
            timedOut: true
          });
        }, opts.timeout);
      }

      var update = function update() {
        setStateWithMountCheck({
          error: res.error,
          loaded: res.loaded,
          loading: res.loading
        });

        _this2._clearTimeouts();
      };

      res.promise.then(function () {
        update();
        return null;
      }).catch(function (err) {
        update();
        return null;
      });
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this._mounted = false;

      this._clearTimeouts();
    };

    _proto._clearTimeouts = function _clearTimeouts() {
      clearTimeout(this._delay);
      clearTimeout(this._timeout);
    };

    _proto.render = function render() {
      if (this.state.loading || this.state.error) {
        return React.createElement(opts.loading, {
          isLoading: this.state.loading,
          pastDelay: this.state.pastDelay,
          timedOut: this.state.timedOut,
          error: this.state.error,
          retry: this.retry
        });
      } else if (this.state.loaded) {
        return opts.render(this.state.loaded, this.props);
      } else {
        return null;
      }
    };

    return LoadableComponent;
  }(React.Component), _defineProperty(_class, "contextType", LoadableCaptureContext), _temp;
}

function Loadable(opts) {
  return createLoadableComponent(load, opts);
}

function LoadableMap(opts) {
  if (typeof opts.render !== "function") {
    throw new Error("LoadableMap requires a `render(loaded, props)` function");
  }

  return createLoadableComponent(loadMap, opts);
}

Loadable.Map = LoadableMap;

var Capture =
/*#__PURE__*/
function (_React$Component2) {
  _inheritsLoose(Capture, _React$Component2);

  function Capture() {
    return _React$Component2.apply(this, arguments) || this;
  }

  var _proto2 = Capture.prototype;

  _proto2.render = function render() {
    return React.createElement(LoadableCaptureContext.Provider, {
      value: {
        report: this.props.report
      }
    }, React.Children.only(this.props.children));
  };

  return Capture;
}(React.Component);

Loadable.Capture = Capture;

function flushInitializers(initializers) {
  var promises = [];

  while (initializers.length) {
    var init = initializers.pop();
    promises.push(init());
  }

  return Promise.all(promises).then(function () {
    if (initializers.length) {
      return flushInitializers(initializers);
    }
  });
}

Loadable.preloadAll = function () {
  return new Promise(function (resolve, reject) {
    flushInitializers(ALL_INITIALIZERS).then(resolve, reject);
  });
};

Loadable.preloadReady = function () {
  return new Promise(function (resolve, reject) {
    // We always will resolve, errors should be handled within loading UIs.
    flushInitializers(READY_INITIALIZERS).then(resolve, resolve);
  });
};

module.exports = Loadable;

}),
22831: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  u: () => (matchRoutes),
  v: () => (renderRoutes)
});
/* import */ var react_router__rspack_import_1 = __webpack_require__(56347);
/* import */ var _babel_runtime_helpers_esm_extends__rspack_import_2 = __webpack_require__(58168);
/* import */ var react__rspack_import_0 = __webpack_require__(96540);




function matchRoutes(routes, pathname,
/*not public API*/
branch) {
  if (branch === void 0) {
    branch = [];
  }

  routes.some(function (route) {
    var match = route.path ? (0,react_router__rspack_import_1/* .matchPath */.B6)(pathname, route) : branch.length ? branch[branch.length - 1].match // use parent match
    : react_router__rspack_import_1/* .Router.computeRootMatch */.Ix.computeRootMatch(pathname); // use default "root" match

    if (match) {
      branch.push({
        route: route,
        match: match
      });

      if (route.routes) {
        matchRoutes(route.routes, pathname, branch);
      }
    }

    return match;
  });
  return branch;
}

function renderRoutes(routes, extraProps, switchProps) {
  if (extraProps === void 0) {
    extraProps = {};
  }

  if (switchProps === void 0) {
    switchProps = {};
  }

  return routes ? react__rspack_import_0.createElement(react_router__rspack_import_1/* .Switch */.dO, switchProps, routes.map(function (route, i) {
    return react__rspack_import_0.createElement(react_router__rspack_import_1/* .Route */.qh, {
      key: route.key || i,
      path: route.path,
      exact: route.exact,
      strict: route.strict,
      render: function render(props) {
        return route.render ? route.render((0,_babel_runtime_helpers_esm_extends__rspack_import_2/* ["default"] */.A)({}, props, {}, extraProps, {
          route: route
        })) : react__rspack_import_0.createElement(route.component, (0,_babel_runtime_helpers_esm_extends__rspack_import_2/* ["default"] */.A)({}, props, extraProps, {
          route: route
        }));
      }
    });
  })) : null;
}


//# sourceMappingURL=react-router-config.js.map


}),
54625: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  I9: () => (HashRouter),
  Kd: () => (BrowserRouter),
  N_: () => (Link),
  k2: () => (NavLink)
});
/* import */ var react_router__rspack_import_4 = __webpack_require__(56347);
/* import */ var _babel_runtime_helpers_esm_inheritsLoose__rspack_import_2 = __webpack_require__(77387);
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var history__rspack_import_3 = __webpack_require__(33328);
/* import */ var _babel_runtime_helpers_esm_extends__rspack_import_6 = __webpack_require__(58168);
/* import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__rspack_import_5 = __webpack_require__(98587);
/* import */ var tiny_invariant__rspack_import_1 = __webpack_require__(11561);











/**
 * The public API for a <Router> that uses HTML5 history.
 */

var BrowserRouter = /*#__PURE__*/function (_React$Component) {
  (0,_babel_runtime_helpers_esm_inheritsLoose__rspack_import_2/* ["default"] */.A)(BrowserRouter, _React$Component);

  function BrowserRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = (0,history__rspack_import_3/* .createBrowserHistory */.zR)(_this.props);
    return _this;
  }

  var _proto = BrowserRouter.prototype;

  _proto.render = function render() {
    return /*#__PURE__*/react__rspack_import_0.createElement(react_router__rspack_import_4/* .Router */.Ix, {
      history: this.history,
      children: this.props.children
    });
  };

  return BrowserRouter;
}(react__rspack_import_0.Component);

if (false) {}

/**
 * The public API for a <Router> that uses window.location.hash.
 */

var HashRouter = /*#__PURE__*/function (_React$Component) {
  (0,_babel_runtime_helpers_esm_inheritsLoose__rspack_import_2/* ["default"] */.A)(HashRouter, _React$Component);

  function HashRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = (0,history__rspack_import_3/* .createHashHistory */.TM)(_this.props);
    return _this;
  }

  var _proto = HashRouter.prototype;

  _proto.render = function render() {
    return /*#__PURE__*/react__rspack_import_0.createElement(react_router__rspack_import_4/* .Router */.Ix, {
      history: this.history,
      children: this.props.children
    });
  };

  return HashRouter;
}(react__rspack_import_0.Component);

if (false) {}

var resolveToLocation = function resolveToLocation(to, currentLocation) {
  return typeof to === "function" ? to(currentLocation) : to;
};
var normalizeToLocation = function normalizeToLocation(to, currentLocation) {
  return typeof to === "string" ? (0,history__rspack_import_3/* .createLocation */.yJ)(to, null, null, currentLocation) : to;
};

var forwardRefShim = function forwardRefShim(C) {
  return C;
};

var forwardRef = react__rspack_import_0.forwardRef;

if (typeof forwardRef === "undefined") {
  forwardRef = forwardRefShim;
}

function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}

var LinkAnchor = forwardRef(function (_ref, forwardedRef) {
  var innerRef = _ref.innerRef,
      navigate = _ref.navigate,
      _onClick = _ref.onClick,
      rest = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__rspack_import_5/* ["default"] */.A)(_ref, ["innerRef", "navigate", "onClick"]);

  var target = rest.target;

  var props = (0,_babel_runtime_helpers_esm_extends__rspack_import_6/* ["default"] */.A)({}, rest, {
    onClick: function onClick(event) {
      try {
        if (_onClick) _onClick(event);
      } catch (ex) {
        event.preventDefault();
        throw ex;
      }

      if (!event.defaultPrevented && // onClick prevented default
      event.button === 0 && ( // ignore everything but left clicks
      !target || target === "_self") && // let browser handle "target=_blank" etc.
      !isModifiedEvent(event) // ignore clicks with modifier keys
      ) {
          event.preventDefault();
          navigate();
        }
    }
  }); // React 15 compat


  if (forwardRefShim !== forwardRef) {
    props.ref = forwardedRef || innerRef;
  } else {
    props.ref = innerRef;
  }
  /* eslint-disable-next-line jsx-a11y/anchor-has-content */


  return /*#__PURE__*/react__rspack_import_0.createElement("a", props);
});

if (false) {}
/**
 * The public API for rendering a history-aware <a>.
 */


var Link = forwardRef(function (_ref2, forwardedRef) {
  var _ref2$component = _ref2.component,
      component = _ref2$component === void 0 ? LinkAnchor : _ref2$component,
      replace = _ref2.replace,
      to = _ref2.to,
      innerRef = _ref2.innerRef,
      rest = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__rspack_import_5/* ["default"] */.A)(_ref2, ["component", "replace", "to", "innerRef"]);

  return /*#__PURE__*/react__rspack_import_0.createElement(react_router__rspack_import_4/* .__RouterContext.Consumer */.XZ.Consumer, null, function (context) {
    !context ?  false ? 0 : (0,tiny_invariant__rspack_import_1/* ["default"] */.A)(false) : void 0;
    var history = context.history;
    var location = normalizeToLocation(resolveToLocation(to, context.location), context.location);
    var href = location ? history.createHref(location) : "";

    var props = (0,_babel_runtime_helpers_esm_extends__rspack_import_6/* ["default"] */.A)({}, rest, {
      href: href,
      navigate: function navigate() {
        var location = resolveToLocation(to, context.location);
        var isDuplicateNavigation = (0,history__rspack_import_3/* .createPath */.AO)(context.location) === (0,history__rspack_import_3/* .createPath */.AO)(normalizeToLocation(location));
        var method = replace || isDuplicateNavigation ? history.replace : history.push;
        method(location);
      }
    }); // React 15 compat


    if (forwardRefShim !== forwardRef) {
      props.ref = forwardedRef || innerRef;
    } else {
      props.innerRef = innerRef;
    }

    return /*#__PURE__*/react__rspack_import_0.createElement(component, props);
  });
});

if (false) { var refType, toType }

var forwardRefShim$1 = function forwardRefShim(C) {
  return C;
};

var forwardRef$1 = react__rspack_import_0.forwardRef;

if (typeof forwardRef$1 === "undefined") {
  forwardRef$1 = forwardRefShim$1;
}

function joinClassnames() {
  for (var _len = arguments.length, classnames = new Array(_len), _key = 0; _key < _len; _key++) {
    classnames[_key] = arguments[_key];
  }

  return classnames.filter(function (i) {
    return i;
  }).join(" ");
}
/**
 * A <Link> wrapper that knows if it's "active" or not.
 */


var NavLink = forwardRef$1(function (_ref, forwardedRef) {
  var _ref$ariaCurrent = _ref["aria-current"],
      ariaCurrent = _ref$ariaCurrent === void 0 ? "page" : _ref$ariaCurrent,
      _ref$activeClassName = _ref.activeClassName,
      activeClassName = _ref$activeClassName === void 0 ? "active" : _ref$activeClassName,
      activeStyle = _ref.activeStyle,
      classNameProp = _ref.className,
      exact = _ref.exact,
      isActiveProp = _ref.isActive,
      locationProp = _ref.location,
      sensitive = _ref.sensitive,
      strict = _ref.strict,
      styleProp = _ref.style,
      to = _ref.to,
      innerRef = _ref.innerRef,
      rest = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__rspack_import_5/* ["default"] */.A)(_ref, ["aria-current", "activeClassName", "activeStyle", "className", "exact", "isActive", "location", "sensitive", "strict", "style", "to", "innerRef"]);

  return /*#__PURE__*/react__rspack_import_0.createElement(react_router__rspack_import_4/* .__RouterContext.Consumer */.XZ.Consumer, null, function (context) {
    !context ?  false ? 0 : (0,tiny_invariant__rspack_import_1/* ["default"] */.A)(false) : void 0;
    var currentLocation = locationProp || context.location;
    var toLocation = normalizeToLocation(resolveToLocation(to, currentLocation), currentLocation);
    var path = toLocation.pathname; // Regex taken from: https://github.com/pillarjs/path-to-regexp/blob/master/index.js#L202

    var escapedPath = path && path.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
    var match = escapedPath ? (0,react_router__rspack_import_4/* .matchPath */.B6)(currentLocation.pathname, {
      path: escapedPath,
      exact: exact,
      sensitive: sensitive,
      strict: strict
    }) : null;
    var isActive = !!(isActiveProp ? isActiveProp(match, currentLocation) : match);
    var className = typeof classNameProp === "function" ? classNameProp(isActive) : classNameProp;
    var style = typeof styleProp === "function" ? styleProp(isActive) : styleProp;

    if (isActive) {
      className = joinClassnames(className, activeClassName);
      style = (0,_babel_runtime_helpers_esm_extends__rspack_import_6/* ["default"] */.A)({}, style, activeStyle);
    }

    var props = (0,_babel_runtime_helpers_esm_extends__rspack_import_6/* ["default"] */.A)({
      "aria-current": isActive && ariaCurrent || null,
      className: className,
      style: style,
      to: toLocation
    }, rest); // React 15 compat


    if (forwardRefShim$1 !== forwardRef$1) {
      props.ref = forwardedRef || innerRef;
    } else {
      props.innerRef = innerRef;
    }

    return /*#__PURE__*/react__rspack_import_0.createElement(Link, props);
  });
});

if (false) { var ariaCurrentType }


//# sourceMappingURL=react-router-dom.js.map


}),
56347: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  B6: () => (matchPath),
  Ix: () => (Router),
  W6: () => (useHistory),
  XZ: () => (context),
  dO: () => (Switch),
  qh: () => (Route),
  zy: () => (useLocation)
});
/* import */ var _babel_runtime_helpers_esm_inheritsLoose__rspack_import_5 = __webpack_require__(77387);
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var prop_types__rspack_import_6 = __webpack_require__(5556);
/* import */ var prop_types__rspack_import_6_default = /*#__PURE__*/__webpack_require__.n(prop_types__rspack_import_6);
/* import */ var history__rspack_import_7 = __webpack_require__(33328);
/* import */ var tiny_invariant__rspack_import_1 = __webpack_require__(11561);
/* import */ var _babel_runtime_helpers_esm_extends__rspack_import_8 = __webpack_require__(58168);
/* import */ var path_to_regexp__rspack_import_2 = __webpack_require__(8505);
/* import */ var path_to_regexp__rspack_import_2_default = /*#__PURE__*/__webpack_require__.n(path_to_regexp__rspack_import_2);
/* import */ var react_is__rspack_import_3 = __webpack_require__(44363);
/* import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__rspack_import_9 = __webpack_require__(98587);
/* import */ var hoist_non_react_statics__rspack_import_4 = __webpack_require__(4146);
/* import */ var hoist_non_react_statics__rspack_import_4_default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics__rspack_import_4);












var MAX_SIGNED_31_BIT_INT = 1073741823;
var commonjsGlobal = typeof globalThis !== "undefined" // 'global proper'
? // eslint-disable-next-line no-undef
globalThis : typeof window !== "undefined" ? window // Browser
: typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g // node.js
: {};

function getUniqueId() {
  var key = "__global_unique_id__";
  return commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1;
} // Inlined Object.is polyfill.
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is


function objectIs(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    // eslint-disable-next-line no-self-compare
    return x !== x && y !== y;
  }
}

function createEventEmitter(value) {
  var handlers = [];
  return {
    on: function on(handler) {
      handlers.push(handler);
    },
    off: function off(handler) {
      handlers = handlers.filter(function (h) {
        return h !== handler;
      });
    },
    get: function get() {
      return value;
    },
    set: function set(newValue, changedBits) {
      value = newValue;
      handlers.forEach(function (handler) {
        return handler(value, changedBits);
      });
    }
  };
}

function onlyChild(children) {
  return Array.isArray(children) ? children[0] : children;
}

function createReactContext(defaultValue, calculateChangedBits) {
  var _Provider$childContex, _Consumer$contextType;

  var contextProp = "__create-react-context-" + getUniqueId() + "__";

  var Provider = /*#__PURE__*/function (_React$Component) {
    (0,_babel_runtime_helpers_esm_inheritsLoose__rspack_import_5/* ["default"] */.A)(Provider, _React$Component);

    function Provider() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.emitter = createEventEmitter(_this.props.value);
      return _this;
    }

    var _proto = Provider.prototype;

    _proto.getChildContext = function getChildContext() {
      var _ref;

      return _ref = {}, _ref[contextProp] = this.emitter, _ref;
    };

    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if (this.props.value !== nextProps.value) {
        var oldValue = this.props.value;
        var newValue = nextProps.value;
        var changedBits;

        if (objectIs(oldValue, newValue)) {
          changedBits = 0; // No change
        } else {
          changedBits = typeof calculateChangedBits === "function" ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;

          if (false) {}

          changedBits |= 0;

          if (changedBits !== 0) {
            this.emitter.set(nextProps.value, changedBits);
          }
        }
      }
    };

    _proto.render = function render() {
      return this.props.children;
    };

    return Provider;
  }(react__rspack_import_0.Component);

  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = (prop_types__rspack_import_6_default().object.isRequired), _Provider$childContex);

  var Consumer = /*#__PURE__*/function (_React$Component2) {
    (0,_babel_runtime_helpers_esm_inheritsLoose__rspack_import_5/* ["default"] */.A)(Consumer, _React$Component2);

    function Consumer() {
      var _this2;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      _this2 = _React$Component2.call.apply(_React$Component2, [this].concat(args)) || this;
      _this2.observedBits = void 0;
      _this2.state = {
        value: _this2.getValue()
      };

      _this2.onUpdate = function (newValue, changedBits) {
        var observedBits = _this2.observedBits | 0;

        if ((observedBits & changedBits) !== 0) {
          _this2.setState({
            value: _this2.getValue()
          });
        }
      };

      return _this2;
    }

    var _proto2 = Consumer.prototype;

    _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var observedBits = nextProps.observedBits;
      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT // Subscribe to all changes by default
      : observedBits;
    };

    _proto2.componentDidMount = function componentDidMount() {
      if (this.context[contextProp]) {
        this.context[contextProp].on(this.onUpdate);
      }

      var observedBits = this.props.observedBits;
      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT // Subscribe to all changes by default
      : observedBits;
    };

    _proto2.componentWillUnmount = function componentWillUnmount() {
      if (this.context[contextProp]) {
        this.context[contextProp].off(this.onUpdate);
      }
    };

    _proto2.getValue = function getValue() {
      if (this.context[contextProp]) {
        return this.context[contextProp].get();
      } else {
        return defaultValue;
      }
    };

    _proto2.render = function render() {
      return onlyChild(this.props.children)(this.state.value);
    };

    return Consumer;
  }(react__rspack_import_0.Component);

  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = (prop_types__rspack_import_6_default().object), _Consumer$contextType);
  return {
    Provider: Provider,
    Consumer: Consumer
  };
}

// MIT License
var createContext = react__rspack_import_0.createContext || createReactContext;

// TODO: Replace with React.createContext once we can assume React 16+

var createNamedContext = function createNamedContext(name) {
  var context = createContext();
  context.displayName = name;
  return context;
};

var historyContext = /*#__PURE__*/createNamedContext("Router-History");

var context = /*#__PURE__*/createNamedContext("Router");

/**
 * The public API for putting history on context.
 */

var Router = /*#__PURE__*/function (_React$Component) {
  (0,_babel_runtime_helpers_esm_inheritsLoose__rspack_import_5/* ["default"] */.A)(Router, _React$Component);

  Router.computeRootMatch = function computeRootMatch(pathname) {
    return {
      path: "/",
      url: "/",
      params: {},
      isExact: pathname === "/"
    };
  };

  function Router(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.state = {
      location: props.history.location
    }; // This is a bit of a hack. We have to start listening for location
    // changes here in the constructor in case there are any <Redirect>s
    // on the initial render. If there are, they will replace/push when
    // they mount and since cDM fires in children before parents, we may
    // get a new location before the <Router> is mounted.

    _this._isMounted = false;
    _this._pendingLocation = null;

    if (!props.staticContext) {
      _this.unlisten = props.history.listen(function (location) {
        _this._pendingLocation = location;
      });
    }

    return _this;
  }

  var _proto = Router.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;

    this._isMounted = true;

    if (this.unlisten) {
      // Any pre-mount location changes have been captured at
      // this point, so unregister the listener.
      this.unlisten();
    }

    if (!this.props.staticContext) {
      this.unlisten = this.props.history.listen(function (location) {
        if (_this2._isMounted) {
          _this2.setState({
            location: location
          });
        }
      });
    }

    if (this._pendingLocation) {
      this.setState({
        location: this._pendingLocation
      });
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.unlisten) {
      this.unlisten();
      this._isMounted = false;
      this._pendingLocation = null;
    }
  };

  _proto.render = function render() {
    return /*#__PURE__*/react__rspack_import_0.createElement(context.Provider, {
      value: {
        history: this.props.history,
        location: this.state.location,
        match: Router.computeRootMatch(this.state.location.pathname),
        staticContext: this.props.staticContext
      }
    }, /*#__PURE__*/react__rspack_import_0.createElement(historyContext.Provider, {
      children: this.props.children || null,
      value: this.props.history
    }));
  };

  return Router;
}(react__rspack_import_0.Component);

if (false) {}

/**
 * The public API for a <Router> that stores location in memory.
 */

var MemoryRouter = /*#__PURE__*/function (_React$Component) {
  (0,_babel_runtime_helpers_esm_inheritsLoose__rspack_import_5/* ["default"] */.A)(MemoryRouter, _React$Component);

  function MemoryRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = (0,history__rspack_import_7/* .createMemoryHistory */.sC)(_this.props);
    return _this;
  }

  var _proto = MemoryRouter.prototype;

  _proto.render = function render() {
    return /*#__PURE__*/react__rspack_import_0.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };

  return MemoryRouter;
}(react__rspack_import_0.Component);

if (false) {}

var Lifecycle = /*#__PURE__*/function (_React$Component) {
  (0,_babel_runtime_helpers_esm_inheritsLoose__rspack_import_5/* ["default"] */.A)(Lifecycle, _React$Component);

  function Lifecycle() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = Lifecycle.prototype;

  _proto.componentDidMount = function componentDidMount() {
    if (this.props.onMount) this.props.onMount.call(this, this);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.onUpdate) this.props.onUpdate.call(this, this, prevProps);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.props.onUnmount) this.props.onUnmount.call(this, this);
  };

  _proto.render = function render() {
    return null;
  };

  return Lifecycle;
}(react__rspack_import_0.Component);

/**
 * The public API for prompting the user before navigating away from a screen.
 */

function Prompt(_ref) {
  var message = _ref.message,
      _ref$when = _ref.when,
      when = _ref$when === void 0 ? true : _ref$when;
  return /*#__PURE__*/React.createElement(context.Consumer, null, function (context) {
    !context ?  false ? 0 : invariant(false) : void 0;
    if (!when || context.staticContext) return null;
    var method = context.history.block;
    return /*#__PURE__*/React.createElement(Lifecycle, {
      onMount: function onMount(self) {
        self.release = method(message);
      },
      onUpdate: function onUpdate(self, prevProps) {
        if (prevProps.message !== message) {
          self.release();
          self.release = method(message);
        }
      },
      onUnmount: function onUnmount(self) {
        self.release();
      },
      message: message
    });
  });
}

if (false) { var messageType }

var cache = (/* unused pure expression or super */ null && ({}));
var cacheLimit = 10000;
var cacheCount = 0;

function compilePath(path) {
  if (cache[path]) return cache[path];
  var generator = pathToRegexp.compile(path);

  if (cacheCount < cacheLimit) {
    cache[path] = generator;
    cacheCount++;
  }

  return generator;
}
/**
 * Public API for generating a URL pathname from a path and parameters.
 */


function generatePath(path, params) {
  if (path === void 0) {
    path = "/";
  }

  if (params === void 0) {
    params = {};
  }

  return path === "/" ? path : compilePath(path)(params, {
    pretty: true
  });
}

/**
 * The public API for navigating programmatically with a component.
 */

function Redirect(_ref) {
  var computedMatch = _ref.computedMatch,
      to = _ref.to,
      _ref$push = _ref.push,
      push = _ref$push === void 0 ? false : _ref$push;
  return /*#__PURE__*/React.createElement(context.Consumer, null, function (context) {
    !context ?  false ? 0 : invariant(false) : void 0;
    var history = context.history,
        staticContext = context.staticContext;
    var method = push ? history.push : history.replace;
    var location = createLocation(computedMatch ? typeof to === "string" ? generatePath(to, computedMatch.params) : _extends({}, to, {
      pathname: generatePath(to.pathname, computedMatch.params)
    }) : to); // When rendering in a static context,
    // set the new location immediately.

    if (staticContext) {
      method(location);
      return null;
    }

    return /*#__PURE__*/React.createElement(Lifecycle, {
      onMount: function onMount() {
        method(location);
      },
      onUpdate: function onUpdate(self, prevProps) {
        var prevLocation = createLocation(prevProps.to);

        if (!locationsAreEqual(prevLocation, _extends({}, location, {
          key: prevLocation.key
        }))) {
          method(location);
        }
      },
      to: to
    });
  });
}

if (false) {}

var cache$1 = {};
var cacheLimit$1 = 10000;
var cacheCount$1 = 0;

function compilePath$1(path, options) {
  var cacheKey = "" + options.end + options.strict + options.sensitive;
  var pathCache = cache$1[cacheKey] || (cache$1[cacheKey] = {});
  if (pathCache[path]) return pathCache[path];
  var keys = [];
  var regexp = path_to_regexp__rspack_import_2_default()(path, keys, options);
  var result = {
    regexp: regexp,
    keys: keys
  };

  if (cacheCount$1 < cacheLimit$1) {
    pathCache[path] = result;
    cacheCount$1++;
  }

  return result;
}
/**
 * Public API for matching a URL pathname to a path.
 */


function matchPath(pathname, options) {
  if (options === void 0) {
    options = {};
  }

  if (typeof options === "string" || Array.isArray(options)) {
    options = {
      path: options
    };
  }

  var _options = options,
      path = _options.path,
      _options$exact = _options.exact,
      exact = _options$exact === void 0 ? false : _options$exact,
      _options$strict = _options.strict,
      strict = _options$strict === void 0 ? false : _options$strict,
      _options$sensitive = _options.sensitive,
      sensitive = _options$sensitive === void 0 ? false : _options$sensitive;
  var paths = [].concat(path);
  return paths.reduce(function (matched, path) {
    if (!path && path !== "") return null;
    if (matched) return matched;

    var _compilePath = compilePath$1(path, {
      end: exact,
      strict: strict,
      sensitive: sensitive
    }),
        regexp = _compilePath.regexp,
        keys = _compilePath.keys;

    var match = regexp.exec(pathname);
    if (!match) return null;
    var url = match[0],
        values = match.slice(1);
    var isExact = pathname === url;
    if (exact && !isExact) return null;
    return {
      path: path,
      // the path used to match
      url: path === "/" && url === "" ? "/" : url,
      // the matched portion of the URL
      isExact: isExact,
      // whether or not we matched exactly
      params: keys.reduce(function (memo, key, index) {
        memo[key.name] = values[index];
        return memo;
      }, {})
    };
  }, null);
}

function isEmptyChildren(children) {
  return react__rspack_import_0.Children.count(children) === 0;
}

function evalChildrenDev(children, props, path) {
  var value = children(props);
   false ? 0 : void 0;
  return value || null;
}
/**
 * The public API for matching a single path and rendering.
 */


var Route = /*#__PURE__*/function (_React$Component) {
  (0,_babel_runtime_helpers_esm_inheritsLoose__rspack_import_5/* ["default"] */.A)(Route, _React$Component);

  function Route() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = Route.prototype;

  _proto.render = function render() {
    var _this = this;

    return /*#__PURE__*/react__rspack_import_0.createElement(context.Consumer, null, function (context$1) {
      !context$1 ?  false ? 0 : (0,tiny_invariant__rspack_import_1/* ["default"] */.A)(false) : void 0;
      var location = _this.props.location || context$1.location;
      var match = _this.props.computedMatch ? _this.props.computedMatch // <Switch> already computed the match for us
      : _this.props.path ? matchPath(location.pathname, _this.props) : context$1.match;

      var props = (0,_babel_runtime_helpers_esm_extends__rspack_import_8/* ["default"] */.A)({}, context$1, {
        location: location,
        match: match
      });

      var _this$props = _this.props,
          children = _this$props.children,
          component = _this$props.component,
          render = _this$props.render; // Preact uses an empty array as children by
      // default, so use null if that's the case.

      if (Array.isArray(children) && isEmptyChildren(children)) {
        children = null;
      }

      return /*#__PURE__*/react__rspack_import_0.createElement(context.Provider, {
        value: props
      }, props.match ? children ? typeof children === "function" ?  false ? 0 : children(props) : children : component ? /*#__PURE__*/react__rspack_import_0.createElement(component, props) : render ? render(props) : null : typeof children === "function" ?  false ? 0 : children(props) : null);
    });
  };

  return Route;
}(react__rspack_import_0.Component);

if (false) {}

function addLeadingSlash(path) {
  return path.charAt(0) === "/" ? path : "/" + path;
}

function addBasename(basename, location) {
  if (!basename) return location;
  return (0,_babel_runtime_helpers_esm_extends__rspack_import_8/* ["default"] */.A)({}, location, {
    pathname: addLeadingSlash(basename) + location.pathname
  });
}

function stripBasename(basename, location) {
  if (!basename) return location;
  var base = addLeadingSlash(basename);
  if (location.pathname.indexOf(base) !== 0) return location;
  return (0,_babel_runtime_helpers_esm_extends__rspack_import_8/* ["default"] */.A)({}, location, {
    pathname: location.pathname.substr(base.length)
  });
}

function createURL(location) {
  return typeof location === "string" ? location : (0,history__rspack_import_7/* .createPath */.AO)(location);
}

function staticHandler(methodName) {
  return function () {
      false ? 0 : (0,tiny_invariant__rspack_import_1/* ["default"] */.A)(false) ;
  };
}

function noop() {}
/**
 * The public top-level API for a "static" <Router>, so-called because it
 * can't actually change the current location. Instead, it just records
 * location changes in a context object. Useful mainly in testing and
 * server-rendering scenarios.
 */


var StaticRouter = /*#__PURE__*/function (_React$Component) {
  (0,_babel_runtime_helpers_esm_inheritsLoose__rspack_import_5/* ["default"] */.A)(StaticRouter, _React$Component);

  function StaticRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

    _this.handlePush = function (location) {
      return _this.navigateTo(location, "PUSH");
    };

    _this.handleReplace = function (location) {
      return _this.navigateTo(location, "REPLACE");
    };

    _this.handleListen = function () {
      return noop;
    };

    _this.handleBlock = function () {
      return noop;
    };

    return _this;
  }

  var _proto = StaticRouter.prototype;

  _proto.navigateTo = function navigateTo(location, action) {
    var _this$props = this.props,
        _this$props$basename = _this$props.basename,
        basename = _this$props$basename === void 0 ? "" : _this$props$basename,
        _this$props$context = _this$props.context,
        context = _this$props$context === void 0 ? {} : _this$props$context;
    context.action = action;
    context.location = addBasename(basename, (0,history__rspack_import_7/* .createLocation */.yJ)(location));
    context.url = createURL(context.location);
  };

  _proto.render = function render() {
    var _this$props2 = this.props,
        _this$props2$basename = _this$props2.basename,
        basename = _this$props2$basename === void 0 ? "" : _this$props2$basename,
        _this$props2$context = _this$props2.context,
        context = _this$props2$context === void 0 ? {} : _this$props2$context,
        _this$props2$location = _this$props2.location,
        location = _this$props2$location === void 0 ? "/" : _this$props2$location,
        rest = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__rspack_import_9/* ["default"] */.A)(_this$props2, ["basename", "context", "location"]);

    var history = {
      createHref: function createHref(path) {
        return addLeadingSlash(basename + createURL(path));
      },
      action: "POP",
      location: stripBasename(basename, (0,history__rspack_import_7/* .createLocation */.yJ)(location)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler("go"),
      goBack: staticHandler("goBack"),
      goForward: staticHandler("goForward"),
      listen: this.handleListen,
      block: this.handleBlock
    };
    return /*#__PURE__*/react__rspack_import_0.createElement(Router, (0,_babel_runtime_helpers_esm_extends__rspack_import_8/* ["default"] */.A)({}, rest, {
      history: history,
      staticContext: context
    }));
  };

  return StaticRouter;
}(react__rspack_import_0.Component);

if (false) {}

/**
 * The public API for rendering the first <Route> that matches.
 */

var Switch = /*#__PURE__*/function (_React$Component) {
  (0,_babel_runtime_helpers_esm_inheritsLoose__rspack_import_5/* ["default"] */.A)(Switch, _React$Component);

  function Switch() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = Switch.prototype;

  _proto.render = function render() {
    var _this = this;

    return /*#__PURE__*/react__rspack_import_0.createElement(context.Consumer, null, function (context) {
      !context ?  false ? 0 : (0,tiny_invariant__rspack_import_1/* ["default"] */.A)(false) : void 0;
      var location = _this.props.location || context.location;
      var element, match; // We use React.Children.forEach instead of React.Children.toArray().find()
      // here because toArray adds keys to all child elements and we do not want
      // to trigger an unmount/remount for two <Route>s that render the same
      // component at different URLs.

      react__rspack_import_0.Children.forEach(_this.props.children, function (child) {
        if (match == null && /*#__PURE__*/react__rspack_import_0.isValidElement(child)) {
          element = child;
          var path = child.props.path || child.props.from;
          match = path ? matchPath(location.pathname, (0,_babel_runtime_helpers_esm_extends__rspack_import_8/* ["default"] */.A)({}, child.props, {
            path: path
          })) : context.match;
        }
      });
      return match ? /*#__PURE__*/react__rspack_import_0.cloneElement(element, {
        location: location,
        computedMatch: match
      }) : null;
    });
  };

  return Switch;
}(react__rspack_import_0.Component);

if (false) {}

/**
 * A public higher-order component to access the imperative API
 */

function withRouter(Component) {
  var displayName = "withRouter(" + (Component.displayName || Component.name) + ")";

  var C = function C(props) {
    var wrappedComponentRef = props.wrappedComponentRef,
        remainingProps = _objectWithoutPropertiesLoose(props, ["wrappedComponentRef"]);

    return /*#__PURE__*/React.createElement(context.Consumer, null, function (context) {
      !context ?  false ? 0 : invariant(false) : void 0;
      return /*#__PURE__*/React.createElement(Component, _extends({}, remainingProps, context, {
        ref: wrappedComponentRef
      }));
    });
  };

  C.displayName = displayName;
  C.WrappedComponent = Component;

  if (false) {}

  return hoistStatics(C, Component);
}

var useContext = react__rspack_import_0.useContext;
function useHistory() {
  if (false) {}

  return useContext(historyContext);
}
function useLocation() {
  if (false) {}

  return useContext(context).location;
}
function useParams() {
  if (false) {}

  var match = useContext(context).match;
  return match ? match.params : {};
}
function useRouteMatch(path) {
  if (false) {}

  var location = useLocation();
  var match = useContext(context).match;
  return path ? matchPath(location.pathname, path) : match;
}

if (false) { var global$1, buildNames, secondaryBuildName, initialBuildName, key }


//# sourceMappingURL=react-router.js.map


}),
8505: (function (module, __unused_webpack_exports, __webpack_require__) {
var isarray = __webpack_require__(64634)

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp
module.exports.parse = parse
module.exports.compile = compile
module.exports.tokensToFunction = tokensToFunction
module.exports.tokensToRegExp = tokensToRegExp

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g')

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = []
  var key = 0
  var index = 0
  var path = ''
  var defaultDelimiter = options && options.delimiter || '/'
  var res

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0]
    var escaped = res[1]
    var offset = res.index
    path += str.slice(index, offset)
    index = offset + m.length

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1]
      continue
    }

    var next = str[index]
    var prefix = res[2]
    var name = res[3]
    var capture = res[4]
    var group = res[5]
    var modifier = res[6]
    var asterisk = res[7]

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path)
      path = ''
    }

    var partial = prefix != null && next != null && next !== prefix
    var repeat = modifier === '+' || modifier === '*'
    var optional = modifier === '?' || modifier === '*'
    var delimiter = prefix || defaultDelimiter
    var pattern = capture || group
    var prevText = prefix || (typeof tokens[tokens.length - 1] === 'string' ? tokens[tokens.length - 1] : '')

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : restrictBacktrack(delimiter, prevText))
    })
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index)
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path)
  }

  return tokens
}

function restrictBacktrack(delimiter, prevText) {
  if (!prevText || prevText.indexOf(delimiter) > -1) {
    return '[^' + escapeString(delimiter) + ']+?'
  }

  return escapeString(prevText) + '|(?:(?!' + escapeString(prevText) + ')[^' + escapeString(delimiter) + '])+?'
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options), options)
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty (str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk (str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens, options) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length)

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options))
    }
  }

  return function (obj, opts) {
    var path = ''
    var data = obj || {}
    var options = opts || {}
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i]

      if (typeof token === 'string') {
        path += token

        continue
      }

      var value = data[token.name]
      var segment

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix
          }

          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j])

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment
        }

        continue
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value)

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options && options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g)

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      })
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = []

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source)
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  var strict = options.strict
  var end = options.end !== false
  var route = ''

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i]

    if (typeof token === 'string') {
      route += escapeString(token)
    } else {
      var prefix = escapeString(token.prefix)
      var capture = '(?:' + token.pattern + ')'

      keys.push(token)

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*'
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?'
        } else {
          capture = prefix + '(' + capture + ')?'
        }
      } else {
        capture = prefix + '(' + capture + ')'
      }

      route += capture
    }
  }

  var delimiter = escapeString(options.delimiter || '/')
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'
  }

  if (end) {
    route += '$'
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys)
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */ (keys))
  }

  if (isarray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
  }

  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
}


}),
29698: (function (__unused_webpack_module, exports) {
"use strict";
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
function jsxProd(type, config, maybeKey) {
  var key = null;
  void 0 !== maybeKey && (key = "" + maybeKey);
  void 0 !== config.key && (key = "" + config.key);
  if ("key" in config) {
    maybeKey = {};
    for (var propName in config)
      "key" !== propName && (maybeKey[propName] = config[propName]);
  } else maybeKey = config;
  config = maybeKey.ref;
  return {
    $$typeof: REACT_ELEMENT_TYPE,
    type: type,
    key: key,
    ref: void 0 !== config ? config : null,
    props: maybeKey
  };
}
exports.Fragment = REACT_FRAGMENT_TYPE;
exports.jsx = jsxProd;
exports.jsxs = jsxProd;


}),
29869: (function (__unused_webpack_module, exports) {
"use strict";
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
  REACT_PORTAL_TYPE = Symbol.for("react.portal"),
  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
  REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
  REACT_CONTEXT_TYPE = Symbol.for("react.context"),
  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
  REACT_MEMO_TYPE = Symbol.for("react.memo"),
  REACT_LAZY_TYPE = Symbol.for("react.lazy"),
  REACT_ACTIVITY_TYPE = Symbol.for("react.activity"),
  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
function getIteratorFn(maybeIterable) {
  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
  maybeIterable =
    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||
    maybeIterable["@@iterator"];
  return "function" === typeof maybeIterable ? maybeIterable : null;
}
var ReactNoopUpdateQueue = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {}
  },
  assign = Object.assign,
  emptyObject = {};
function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}
Component.prototype.isReactComponent = {};
Component.prototype.setState = function (partialState, callback) {
  if (
    "object" !== typeof partialState &&
    "function" !== typeof partialState &&
    null != partialState
  )
    throw Error(
      "takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, partialState, callback, "setState");
};
Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
};
function ComponentDummy() {}
ComponentDummy.prototype = Component.prototype;
function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}
var pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());
pureComponentPrototype.constructor = PureComponent;
assign(pureComponentPrototype, Component.prototype);
pureComponentPrototype.isPureReactComponent = !0;
var isArrayImpl = Array.isArray;
function noop() {}
var ReactSharedInternals = { H: null, A: null, T: null, S: null },
  hasOwnProperty = Object.prototype.hasOwnProperty;
function ReactElement(type, key, props) {
  var refProp = props.ref;
  return {
    $$typeof: REACT_ELEMENT_TYPE,
    type: type,
    key: key,
    ref: void 0 !== refProp ? refProp : null,
    props: props
  };
}
function cloneAndReplaceKey(oldElement, newKey) {
  return ReactElement(oldElement.type, newKey, oldElement.props);
}
function isValidElement(object) {
  return (
    "object" === typeof object &&
    null !== object &&
    object.$$typeof === REACT_ELEMENT_TYPE
  );
}
function escape(key) {
  var escaperLookup = { "=": "=0", ":": "=2" };
  return (
    "$" +
    key.replace(/[=:]/g, function (match) {
      return escaperLookup[match];
    })
  );
}
var userProvidedKeyEscapeRegex = /\/+/g;
function getElementKey(element, index) {
  return "object" === typeof element && null !== element && null != element.key
    ? escape("" + element.key)
    : index.toString(36);
}
function resolveThenable(thenable) {
  switch (thenable.status) {
    case "fulfilled":
      return thenable.value;
    case "rejected":
      throw thenable.reason;
    default:
      switch (
        ("string" === typeof thenable.status
          ? thenable.then(noop, noop)
          : ((thenable.status = "pending"),
            thenable.then(
              function (fulfilledValue) {
                "pending" === thenable.status &&
                  ((thenable.status = "fulfilled"),
                  (thenable.value = fulfilledValue));
              },
              function (error) {
                "pending" === thenable.status &&
                  ((thenable.status = "rejected"), (thenable.reason = error));
              }
            )),
        thenable.status)
      ) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
      }
  }
  throw thenable;
}
function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
  var type = typeof children;
  if ("undefined" === type || "boolean" === type) children = null;
  var invokeCallback = !1;
  if (null === children) invokeCallback = !0;
  else
    switch (type) {
      case "bigint":
      case "string":
      case "number":
        invokeCallback = !0;
        break;
      case "object":
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = !0;
            break;
          case REACT_LAZY_TYPE:
            return (
              (invokeCallback = children._init),
              mapIntoArray(
                invokeCallback(children._payload),
                array,
                escapedPrefix,
                nameSoFar,
                callback
              )
            );
        }
    }
  if (invokeCallback)
    return (
      (callback = callback(children)),
      (invokeCallback =
        "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar),
      isArrayImpl(callback)
        ? ((escapedPrefix = ""),
          null != invokeCallback &&
            (escapedPrefix =
              invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"),
          mapIntoArray(callback, array, escapedPrefix, "", function (c) {
            return c;
          }))
        : null != callback &&
          (isValidElement(callback) &&
            (callback = cloneAndReplaceKey(
              callback,
              escapedPrefix +
                (null == callback.key ||
                (children && children.key === callback.key)
                  ? ""
                  : ("" + callback.key).replace(
                      userProvidedKeyEscapeRegex,
                      "$&/"
                    ) + "/") +
                invokeCallback
            )),
          array.push(callback)),
      1
    );
  invokeCallback = 0;
  var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
  if (isArrayImpl(children))
    for (var i = 0; i < children.length; i++)
      (nameSoFar = children[i]),
        (type = nextNamePrefix + getElementKey(nameSoFar, i)),
        (invokeCallback += mapIntoArray(
          nameSoFar,
          array,
          escapedPrefix,
          type,
          callback
        ));
  else if (((i = getIteratorFn(children)), "function" === typeof i))
    for (
      children = i.call(children), i = 0;
      !(nameSoFar = children.next()).done;

    )
      (nameSoFar = nameSoFar.value),
        (type = nextNamePrefix + getElementKey(nameSoFar, i++)),
        (invokeCallback += mapIntoArray(
          nameSoFar,
          array,
          escapedPrefix,
          type,
          callback
        ));
  else if ("object" === type) {
    if ("function" === typeof children.then)
      return mapIntoArray(
        resolveThenable(children),
        array,
        escapedPrefix,
        nameSoFar,
        callback
      );
    array = String(children);
    throw Error(
      "Objects are not valid as a React child (found: " +
        ("[object Object]" === array
          ? "object with keys {" + Object.keys(children).join(", ") + "}"
          : array) +
        "). If you meant to render a collection of children, use an array instead."
    );
  }
  return invokeCallback;
}
function mapChildren(children, func, context) {
  if (null == children) return children;
  var result = [],
    count = 0;
  mapIntoArray(children, result, "", "", function (child) {
    return func.call(context, child, count++);
  });
  return result;
}
function lazyInitializer(payload) {
  if (-1 === payload._status) {
    var ctor = payload._result;
    ctor = ctor();
    ctor.then(
      function (moduleObject) {
        if (0 === payload._status || -1 === payload._status)
          (payload._status = 1), (payload._result = moduleObject);
      },
      function (error) {
        if (0 === payload._status || -1 === payload._status)
          (payload._status = 2), (payload._result = error);
      }
    );
    -1 === payload._status && ((payload._status = 0), (payload._result = ctor));
  }
  if (1 === payload._status) return payload._result.default;
  throw payload._result;
}
var reportGlobalError =
    "function" === typeof reportError
      ? reportError
      : function (error) {
          if (
            "object" === typeof window &&
            "function" === typeof window.ErrorEvent
          ) {
            var event = new window.ErrorEvent("error", {
              bubbles: !0,
              cancelable: !0,
              message:
                "object" === typeof error &&
                null !== error &&
                "string" === typeof error.message
                  ? String(error.message)
                  : String(error),
              error: error
            });
            if (!window.dispatchEvent(event)) return;
          } else if (
            "object" === typeof process &&
            "function" === typeof process.emit
          ) {
            process.emit("uncaughtException", error);
            return;
          }
          console.error(error);
        },
  Children = {
    map: mapChildren,
    forEach: function (children, forEachFunc, forEachContext) {
      mapChildren(
        children,
        function () {
          forEachFunc.apply(this, arguments);
        },
        forEachContext
      );
    },
    count: function (children) {
      var n = 0;
      mapChildren(children, function () {
        n++;
      });
      return n;
    },
    toArray: function (children) {
      return (
        mapChildren(children, function (child) {
          return child;
        }) || []
      );
    },
    only: function (children) {
      if (!isValidElement(children))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return children;
    }
  };
exports.Activity = REACT_ACTIVITY_TYPE;
exports.Children = Children;
exports.Component = Component;
exports.Fragment = REACT_FRAGMENT_TYPE;
exports.Profiler = REACT_PROFILER_TYPE;
exports.PureComponent = PureComponent;
exports.StrictMode = REACT_STRICT_MODE_TYPE;
exports.Suspense = REACT_SUSPENSE_TYPE;
exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
  ReactSharedInternals;
exports.__COMPILER_RUNTIME = {
  __proto__: null,
  c: function (size) {
    return ReactSharedInternals.H.useMemoCache(size);
  }
};
exports.cache = function (fn) {
  return function () {
    return fn.apply(null, arguments);
  };
};
exports.cacheSignal = function () {
  return null;
};
exports.cloneElement = function (element, config, children) {
  if (null === element || void 0 === element)
    throw Error(
      "The argument must be a React element, but you passed " + element + "."
    );
  var props = assign({}, element.props),
    key = element.key;
  if (null != config)
    for (propName in (void 0 !== config.key && (key = "" + config.key), config))
      !hasOwnProperty.call(config, propName) ||
        "key" === propName ||
        "__self" === propName ||
        "__source" === propName ||
        ("ref" === propName && void 0 === config.ref) ||
        (props[propName] = config[propName]);
  var propName = arguments.length - 2;
  if (1 === propName) props.children = children;
  else if (1 < propName) {
    for (var childArray = Array(propName), i = 0; i < propName; i++)
      childArray[i] = arguments[i + 2];
    props.children = childArray;
  }
  return ReactElement(element.type, key, props);
};
exports.createContext = function (defaultValue) {
  defaultValue = {
    $$typeof: REACT_CONTEXT_TYPE,
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    _threadCount: 0,
    Provider: null,
    Consumer: null
  };
  defaultValue.Provider = defaultValue;
  defaultValue.Consumer = {
    $$typeof: REACT_CONSUMER_TYPE,
    _context: defaultValue
  };
  return defaultValue;
};
exports.createElement = function (type, config, children) {
  var propName,
    props = {},
    key = null;
  if (null != config)
    for (propName in (void 0 !== config.key && (key = "" + config.key), config))
      hasOwnProperty.call(config, propName) &&
        "key" !== propName &&
        "__self" !== propName &&
        "__source" !== propName &&
        (props[propName] = config[propName]);
  var childrenLength = arguments.length - 2;
  if (1 === childrenLength) props.children = children;
  else if (1 < childrenLength) {
    for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
      childArray[i] = arguments[i + 2];
    props.children = childArray;
  }
  if (type && type.defaultProps)
    for (propName in ((childrenLength = type.defaultProps), childrenLength))
      void 0 === props[propName] &&
        (props[propName] = childrenLength[propName]);
  return ReactElement(type, key, props);
};
exports.createRef = function () {
  return { current: null };
};
exports.forwardRef = function (render) {
  return { $$typeof: REACT_FORWARD_REF_TYPE, render: render };
};
exports.isValidElement = isValidElement;
exports.lazy = function (ctor) {
  return {
    $$typeof: REACT_LAZY_TYPE,
    _payload: { _status: -1, _result: ctor },
    _init: lazyInitializer
  };
};
exports.memo = function (type, compare) {
  return {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: void 0 === compare ? null : compare
  };
};
exports.startTransition = function (scope) {
  var prevTransition = ReactSharedInternals.T,
    currentTransition = {};
  ReactSharedInternals.T = currentTransition;
  try {
    var returnValue = scope(),
      onStartTransitionFinish = ReactSharedInternals.S;
    null !== onStartTransitionFinish &&
      onStartTransitionFinish(currentTransition, returnValue);
    "object" === typeof returnValue &&
      null !== returnValue &&
      "function" === typeof returnValue.then &&
      returnValue.then(noop, reportGlobalError);
  } catch (error) {
    reportGlobalError(error);
  } finally {
    null !== prevTransition &&
      null !== currentTransition.types &&
      (prevTransition.types = currentTransition.types),
      (ReactSharedInternals.T = prevTransition);
  }
};
exports.unstable_useCacheRefresh = function () {
  return ReactSharedInternals.H.useCacheRefresh();
};
exports.use = function (usable) {
  return ReactSharedInternals.H.use(usable);
};
exports.useActionState = function (action, initialState, permalink) {
  return ReactSharedInternals.H.useActionState(action, initialState, permalink);
};
exports.useCallback = function (callback, deps) {
  return ReactSharedInternals.H.useCallback(callback, deps);
};
exports.useContext = function (Context) {
  return ReactSharedInternals.H.useContext(Context);
};
exports.useDebugValue = function () {};
exports.useDeferredValue = function (value, initialValue) {
  return ReactSharedInternals.H.useDeferredValue(value, initialValue);
};
exports.useEffect = function (create, deps) {
  return ReactSharedInternals.H.useEffect(create, deps);
};
exports.useEffectEvent = function (callback) {
  return ReactSharedInternals.H.useEffectEvent(callback);
};
exports.useId = function () {
  return ReactSharedInternals.H.useId();
};
exports.useImperativeHandle = function (ref, create, deps) {
  return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
};
exports.useInsertionEffect = function (create, deps) {
  return ReactSharedInternals.H.useInsertionEffect(create, deps);
};
exports.useLayoutEffect = function (create, deps) {
  return ReactSharedInternals.H.useLayoutEffect(create, deps);
};
exports.useMemo = function (create, deps) {
  return ReactSharedInternals.H.useMemo(create, deps);
};
exports.useOptimistic = function (passthrough, reducer) {
  return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
};
exports.useReducer = function (reducer, initialArg, init) {
  return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
};
exports.useRef = function (initialValue) {
  return ReactSharedInternals.H.useRef(initialValue);
};
exports.useState = function (initialState) {
  return ReactSharedInternals.H.useState(initialState);
};
exports.useSyncExternalStore = function (
  subscribe,
  getSnapshot,
  getServerSnapshot
) {
  return ReactSharedInternals.H.useSyncExternalStore(
    subscribe,
    getSnapshot,
    getServerSnapshot
  );
};
exports.useTransition = function () {
  return ReactSharedInternals.H.useTransition();
};
exports.version = "19.2.0";


}),
96540: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


if (true) {
  module.exports = __webpack_require__(29869);
} else {}


}),
74848: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


if (true) {
  module.exports = __webpack_require__(29698);
} else {}


}),
4477: (function (__unused_webpack_module, exports) {
"use strict";
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


function push(heap, node) {
  var index = heap.length;
  heap.push(node);
  a: for (; 0 < index; ) {
    var parentIndex = (index - 1) >>> 1,
      parent = heap[parentIndex];
    if (0 < compare(parent, node))
      (heap[parentIndex] = node), (heap[index] = parent), (index = parentIndex);
    else break a;
  }
}
function peek(heap) {
  return 0 === heap.length ? null : heap[0];
}
function pop(heap) {
  if (0 === heap.length) return null;
  var first = heap[0],
    last = heap.pop();
  if (last !== first) {
    heap[0] = last;
    a: for (
      var index = 0, length = heap.length, halfLength = length >>> 1;
      index < halfLength;

    ) {
      var leftIndex = 2 * (index + 1) - 1,
        left = heap[leftIndex],
        rightIndex = leftIndex + 1,
        right = heap[rightIndex];
      if (0 > compare(left, last))
        rightIndex < length && 0 > compare(right, left)
          ? ((heap[index] = right),
            (heap[rightIndex] = last),
            (index = rightIndex))
          : ((heap[index] = left),
            (heap[leftIndex] = last),
            (index = leftIndex));
      else if (rightIndex < length && 0 > compare(right, last))
        (heap[index] = right), (heap[rightIndex] = last), (index = rightIndex);
      else break a;
    }
  }
  return first;
}
function compare(a, b) {
  var diff = a.sortIndex - b.sortIndex;
  return 0 !== diff ? diff : a.id - b.id;
}
exports.unstable_now = void 0;
if ("object" === typeof performance && "function" === typeof performance.now) {
  var localPerformance = performance;
  exports.unstable_now = function () {
    return localPerformance.now();
  };
} else {
  var localDate = Date,
    initialTime = localDate.now();
  exports.unstable_now = function () {
    return localDate.now() - initialTime;
  };
}
var taskQueue = [],
  timerQueue = [],
  taskIdCounter = 1,
  currentTask = null,
  currentPriorityLevel = 3,
  isPerformingWork = !1,
  isHostCallbackScheduled = !1,
  isHostTimeoutScheduled = !1,
  needsPaint = !1,
  localSetTimeout = "function" === typeof setTimeout ? setTimeout : null,
  localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null,
  localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
function advanceTimers(currentTime) {
  for (var timer = peek(timerQueue); null !== timer; ) {
    if (null === timer.callback) pop(timerQueue);
    else if (timer.startTime <= currentTime)
      pop(timerQueue),
        (timer.sortIndex = timer.expirationTime),
        push(taskQueue, timer);
    else break;
    timer = peek(timerQueue);
  }
}
function handleTimeout(currentTime) {
  isHostTimeoutScheduled = !1;
  advanceTimers(currentTime);
  if (!isHostCallbackScheduled)
    if (null !== peek(taskQueue))
      (isHostCallbackScheduled = !0),
        isMessageLoopRunning ||
          ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline());
    else {
      var firstTimer = peek(timerQueue);
      null !== firstTimer &&
        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    }
}
var isMessageLoopRunning = !1,
  taskTimeoutID = -1,
  frameInterval = 5,
  startTime = -1;
function shouldYieldToHost() {
  return needsPaint
    ? !0
    : exports.unstable_now() - startTime < frameInterval
      ? !1
      : !0;
}
function performWorkUntilDeadline() {
  needsPaint = !1;
  if (isMessageLoopRunning) {
    var currentTime = exports.unstable_now();
    startTime = currentTime;
    var hasMoreWork = !0;
    try {
      a: {
        isHostCallbackScheduled = !1;
        isHostTimeoutScheduled &&
          ((isHostTimeoutScheduled = !1),
          localClearTimeout(taskTimeoutID),
          (taskTimeoutID = -1));
        isPerformingWork = !0;
        var previousPriorityLevel = currentPriorityLevel;
        try {
          b: {
            advanceTimers(currentTime);
            for (
              currentTask = peek(taskQueue);
              null !== currentTask &&
              !(
                currentTask.expirationTime > currentTime && shouldYieldToHost()
              );

            ) {
              var callback = currentTask.callback;
              if ("function" === typeof callback) {
                currentTask.callback = null;
                currentPriorityLevel = currentTask.priorityLevel;
                var continuationCallback = callback(
                  currentTask.expirationTime <= currentTime
                );
                currentTime = exports.unstable_now();
                if ("function" === typeof continuationCallback) {
                  currentTask.callback = continuationCallback;
                  advanceTimers(currentTime);
                  hasMoreWork = !0;
                  break b;
                }
                currentTask === peek(taskQueue) && pop(taskQueue);
                advanceTimers(currentTime);
              } else pop(taskQueue);
              currentTask = peek(taskQueue);
            }
            if (null !== currentTask) hasMoreWork = !0;
            else {
              var firstTimer = peek(timerQueue);
              null !== firstTimer &&
                requestHostTimeout(
                  handleTimeout,
                  firstTimer.startTime - currentTime
                );
              hasMoreWork = !1;
            }
          }
          break a;
        } finally {
          (currentTask = null),
            (currentPriorityLevel = previousPriorityLevel),
            (isPerformingWork = !1);
        }
        hasMoreWork = void 0;
      }
    } finally {
      hasMoreWork
        ? schedulePerformWorkUntilDeadline()
        : (isMessageLoopRunning = !1);
    }
  }
}
var schedulePerformWorkUntilDeadline;
if ("function" === typeof localSetImmediate)
  schedulePerformWorkUntilDeadline = function () {
    localSetImmediate(performWorkUntilDeadline);
  };
else if ("undefined" !== typeof MessageChannel) {
  var channel = new MessageChannel(),
    port = channel.port2;
  channel.port1.onmessage = performWorkUntilDeadline;
  schedulePerformWorkUntilDeadline = function () {
    port.postMessage(null);
  };
} else
  schedulePerformWorkUntilDeadline = function () {
    localSetTimeout(performWorkUntilDeadline, 0);
  };
function requestHostTimeout(callback, ms) {
  taskTimeoutID = localSetTimeout(function () {
    callback(exports.unstable_now());
  }, ms);
}
exports.unstable_IdlePriority = 5;
exports.unstable_ImmediatePriority = 1;
exports.unstable_LowPriority = 4;
exports.unstable_NormalPriority = 3;
exports.unstable_Profiling = null;
exports.unstable_UserBlockingPriority = 2;
exports.unstable_cancelCallback = function (task) {
  task.callback = null;
};
exports.unstable_forceFrameRate = function (fps) {
  0 > fps || 125 < fps
    ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      )
    : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);
};
exports.unstable_getCurrentPriorityLevel = function () {
  return currentPriorityLevel;
};
exports.unstable_next = function (eventHandler) {
  switch (currentPriorityLevel) {
    case 1:
    case 2:
    case 3:
      var priorityLevel = 3;
      break;
    default:
      priorityLevel = currentPriorityLevel;
  }
  var previousPriorityLevel = currentPriorityLevel;
  currentPriorityLevel = priorityLevel;
  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
};
exports.unstable_requestPaint = function () {
  needsPaint = !0;
};
exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {
  switch (priorityLevel) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      break;
    default:
      priorityLevel = 3;
  }
  var previousPriorityLevel = currentPriorityLevel;
  currentPriorityLevel = priorityLevel;
  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
};
exports.unstable_scheduleCallback = function (
  priorityLevel,
  callback,
  options
) {
  var currentTime = exports.unstable_now();
  "object" === typeof options && null !== options
    ? ((options = options.delay),
      (options =
        "number" === typeof options && 0 < options
          ? currentTime + options
          : currentTime))
    : (options = currentTime);
  switch (priorityLevel) {
    case 1:
      var timeout = -1;
      break;
    case 2:
      timeout = 250;
      break;
    case 5:
      timeout = 1073741823;
      break;
    case 4:
      timeout = 1e4;
      break;
    default:
      timeout = 5e3;
  }
  timeout = options + timeout;
  priorityLevel = {
    id: taskIdCounter++,
    callback: callback,
    priorityLevel: priorityLevel,
    startTime: options,
    expirationTime: timeout,
    sortIndex: -1
  };
  options > currentTime
    ? ((priorityLevel.sortIndex = options),
      push(timerQueue, priorityLevel),
      null === peek(taskQueue) &&
        priorityLevel === peek(timerQueue) &&
        (isHostTimeoutScheduled
          ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))
          : (isHostTimeoutScheduled = !0),
        requestHostTimeout(handleTimeout, options - currentTime)))
    : ((priorityLevel.sortIndex = timeout),
      push(taskQueue, priorityLevel),
      isHostCallbackScheduled ||
        isPerformingWork ||
        ((isHostCallbackScheduled = !0),
        isMessageLoopRunning ||
          ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline())));
  return priorityLevel;
};
exports.unstable_shouldYield = shouldYieldToHost;
exports.unstable_wrapCallback = function (callback) {
  var parentPriorityLevel = currentPriorityLevel;
  return function () {
    var previousPriorityLevel = currentPriorityLevel;
    currentPriorityLevel = parentPriorityLevel;
    try {
      return callback.apply(this, arguments);
    } finally {
      currentPriorityLevel = previousPriorityLevel;
    }
  };
};


}),
69982: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";


if (true) {
  module.exports = __webpack_require__(4477);
} else {}


}),
2833: (function (module) {
//

module.exports = function shallowEqual(objA, objB, compare, compareContext) {
  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

  if (ret !== void 0) {
    return !!ret;
  }

  if (objA === objB) {
    return true;
  }

  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);

  // Test for A's keys different from B.
  for (var idx = 0; idx < keysA.length; idx++) {
    var key = keysA[idx];

    if (!bHasOwnProperty(key)) {
      return false;
    }

    var valueA = objA[key];
    var valueB = objB[key];

    ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;

    if (ret === false || (ret === void 0 && valueA !== valueB)) {
      return false;
    }
  }

  return true;
};


}),
58460: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ routes)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(74848);
// EXTERNAL MODULE: ./node_modules/react-loadable/lib/index.js
var lib = __webpack_require__(53259);
var lib_default = /*#__PURE__*/__webpack_require__.n(lib);
// EXTERNAL MODULE: ./.docusaurus/routesChunkNames.json
var routesChunkNames = __webpack_require__(84054);
;// CONCATENATED MODULE: ./.docusaurus/registry.js
/* export default */ const registry = ({
    "01a85c17": [
        ()=>Promise.all(/* import() | 01a85c17 */ [__webpack_require__.e("4014"), __webpack_require__.e("9786")]).then(__webpack_require__.bind(__webpack_require__, 73084)),
        "@theme/BlogTagsListPage",
        /*require.resolve*/(73084)
    ],
    "01f3df1d": [
        ()=>__webpack_require__.e(/* import() | 01f3df1d */ "2083").then(__webpack_require__.t.bind(__webpack_require__, 26576, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-account-settings-323.json",
        /*require.resolve*/(26576)
    ],
    "01fb8007": [
        ()=>__webpack_require__.e(/* import() | 01fb8007 */ "9978").then(__webpack_require__.bind(__webpack_require__, 49840)),
        "@site/blog/2025-04-06-indicadores-clave-de-rendimiento-kpi-para-medir-el-exito.md?truncated=true",
        /*require.resolve*/(49840)
    ],
    "02e16c96": [
        ()=>__webpack_require__.e(/* import() | 02e16c96 */ "728").then(__webpack_require__.bind(__webpack_require__, 73674)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/list-view/list-view.md",
        /*require.resolve*/(73674)
    ],
    "03b5480e": [
        ()=>__webpack_require__.e(/* import() | 03b5480e */ "2779").then(__webpack_require__.bind(__webpack_require__, 56153)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/importing-data/updating-fintesk-data-with-a-spreadsheet.md",
        /*require.resolve*/(56153)
    ],
    "05a627cd": [
        ()=>__webpack_require__.e(/* import() | 05a627cd */ "812").then(__webpack_require__.bind(__webpack_require__, 44797)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/troubleshooting/troubleshooting-fintesk-web-app.md",
        /*require.resolve*/(44797)
    ],
    "05bbc94d": [
        ()=>__webpack_require__.e(/* import() | 05bbc94d */ "9591").then(__webpack_require__.t.bind(__webpack_require__, 55785, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-data-fields-d05.json",
        /*require.resolve*/(55785)
    ],
    "05e71aeb": [
        ()=>__webpack_require__.e(/* import() | 05e71aeb */ "9310").then(__webpack_require__.t.bind(__webpack_require__, 12259, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-contacts-b72.json",
        /*require.resolve*/(12259)
    ],
    "066309a2": [
        ()=>__webpack_require__.e(/* import() | 066309a2 */ "8649").then(__webpack_require__.t.bind(__webpack_require__, 73231, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-activities-6d3.json",
        /*require.resolve*/(73231)
    ],
    "08067cb9": [
        ()=>__webpack_require__.e(/* import() | 08067cb9 */ "173").then(__webpack_require__.bind(__webpack_require__, 39806)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/pipelines/how-can-i-customize-my-pipeline-stages.md",
        /*require.resolve*/(39806)
    ],
    "0896d7e9": [
        ()=>__webpack_require__.e(/* import() | 0896d7e9 */ "8688").then(__webpack_require__.bind(__webpack_require__, 24742)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/billing/billing-information/what-happens-to-my-billing-when-i-change-my-billing-frequency.md",
        /*require.resolve*/(24742)
    ],
    "08f7d8b0": [
        ()=>__webpack_require__.e(/* import() | 08f7d8b0 */ "4669").then(__webpack_require__.bind(__webpack_require__, 31025)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/deals/filtering-for-my-won-lost-or-deleted-deals.md",
        /*require.resolve*/(31025)
    ],
    "09ccb4b0": [
        ()=>__webpack_require__.e(/* import() | 09ccb4b0 */ "6525").then(__webpack_require__.bind(__webpack_require__, 8003)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/products/can-i-add-extra-fields-to-the-add-new-product-modal.md",
        /*require.resolve*/(8003)
    ],
    "0b34a5b0": [
        ()=>__webpack_require__.e(/* import() | 0b34a5b0 */ "7457").then(__webpack_require__.t.bind(__webpack_require__, 46456, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-contacts-287.json",
        /*require.resolve*/(46456)
    ],
    "0c69ec8d": [
        ()=>__webpack_require__.e(/* import() | 0c69ec8d */ "4796").then(__webpack_require__.t.bind(__webpack_require__, 40087, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/es-blog-tags-1b0.json",
        /*require.resolve*/(40087)
    ],
    "0cab6d25": [
        ()=>__webpack_require__.e(/* import() | 0cab6d25 */ "7545").then(__webpack_require__.bind(__webpack_require__, 63935)),
        "@site/blog/2025-04-05-alineando-marketing-y-ventas-para-una-conversion-optima.md?truncated=true",
        /*require.resolve*/(63935)
    ],
    "0cd7de29": [
        ()=>__webpack_require__.e(/* import() | 0cd7de29 */ "1418").then(__webpack_require__.bind(__webpack_require__, 72050)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/personal-settings/how-can-i-free-up-space.md",
        /*require.resolve*/(72050)
    ],
    "0cd9735e": [
        ()=>__webpack_require__.e(/* import() | 0cd9735e */ "7278").then(__webpack_require__.t.bind(__webpack_require__, 16596, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-filtering-423.json",
        /*require.resolve*/(16596)
    ],
    "0df994e7": [
        ()=>Promise.all(/* import() | 0df994e7 */ [__webpack_require__.e("4014"), __webpack_require__.e("513"), __webpack_require__.e("472")]).then(__webpack_require__.bind(__webpack_require__, 42092)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/fintesk/v1.mdx",
        /*require.resolve*/(42092)
    ],
    "1143fd4d": [
        ()=>__webpack_require__.e(/* import() | 1143fd4d */ "6773").then(__webpack_require__.t.bind(__webpack_require__, 79731, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-detail-view-db8.json",
        /*require.resolve*/(79731)
    ],
    "1192796a": [
        ()=>__webpack_require__.e(/* import() | 1192796a */ "684").then(__webpack_require__.t.bind(__webpack_require__, 67858, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-company-settings-0ce.json",
        /*require.resolve*/(67858)
    ],
    "14eb3368": [
        ()=>Promise.all(/* import() | 14eb3368 */ [__webpack_require__.e("4014"), __webpack_require__.e("7234")]).then(__webpack_require__.bind(__webpack_require__, 53838)),
        "@theme/DocCategoryGeneratedIndexPage",
        /*require.resolve*/(53838)
    ],
    "16b98190": [
        ()=>__webpack_require__.e(/* import() | 16b98190 */ "7300").then(__webpack_require__.t.bind(__webpack_require__, 77336, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-browser-8e8.json",
        /*require.resolve*/(77336)
    ],
    "17896441": [
        ()=>Promise.all(/* import() | 17896441 */ [__webpack_require__.e("4014"), __webpack_require__.e("4473"), __webpack_require__.e("106")]).then(__webpack_require__.bind(__webpack_require__, 46627)),
        "@theme/DocItem",
        /*require.resolve*/(46627)
    ],
    "17977e16": [
        ()=>__webpack_require__.e(/* import() | 17977e16 */ "8459").then(__webpack_require__.t.bind(__webpack_require__, 61437, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/es-blog-tags-leads-alta-calidad-c9e.json",
        /*require.resolve*/(61437)
    ],
    "18c45cef": [
        ()=>__webpack_require__.e(/* import() | 18c45cef */ "1645").then(__webpack_require__.bind(__webpack_require__, 12532)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/importing-data/importing-data-into-fintesk-with-spreadsheets.md",
        /*require.resolve*/(12532)
    ],
    "19280e3f": [
        ()=>__webpack_require__.e(/* import() | 19280e3f */ "2186").then(__webpack_require__.bind(__webpack_require__, 2972)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/getting-started/fintesk-user-vs-company-account.md",
        /*require.resolve*/(2972)
    ],
    "192c9132": [
        ()=>__webpack_require__.e(/* import() | 192c9132 */ "1530").then(__webpack_require__.t.bind(__webpack_require__, 70542, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-troubleshooting-cff.json",
        /*require.resolve*/(70542)
    ],
    "1a0d2f85": [
        ()=>__webpack_require__.e(/* import() | 1a0d2f85 */ "7657").then(__webpack_require__.bind(__webpack_require__, 67937)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/importing-data/importing-mandatory-fields.md",
        /*require.resolve*/(67937)
    ],
    "1a12e3f7": [
        ()=>__webpack_require__.e(/* import() | 1a12e3f7 */ "3138").then(__webpack_require__.t.bind(__webpack_require__, 77558, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-pipeline-view-2dc.json",
        /*require.resolve*/(77558)
    ],
    "1aa09a11": [
        ()=>__webpack_require__.e(/* import() | 1aa09a11 */ "7651").then(__webpack_require__.bind(__webpack_require__, 9854)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/list-view/how-can-i-edit-a-field-in-the-list-view.md",
        /*require.resolve*/(9854)
    ],
    "1d432d14": [
        ()=>__webpack_require__.e(/* import() | 1d432d14 */ "7631").then(__webpack_require__.t.bind(__webpack_require__, 99043, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/es-blog-tags-como-elegir-crm-2f2.json",
        /*require.resolve*/(99043)
    ],
    "1e83810f": [
        ()=>__webpack_require__.e(/* import() | 1e83810f */ "9686").then(__webpack_require__.t.bind(__webpack_require__, 1392, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/es-blog-tags-leads-eef.json",
        /*require.resolve*/(1392)
    ],
    "1e936633": [
        ()=>__webpack_require__.e(/* import() | 1e936633 */ "5644").then(__webpack_require__.t.bind(__webpack_require__, 3163, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-0c8.json",
        /*require.resolve*/(3163)
    ],
    "1f391b9e": [
        ()=>Promise.all(/* import() | 1f391b9e */ [__webpack_require__.e("4014"), __webpack_require__.e("4473"), __webpack_require__.e("7182")]).then(__webpack_require__.bind(__webpack_require__, 70155)),
        "@theme/MDXPage",
        /*require.resolve*/(70155)
    ],
    "1fc72748": [
        ()=>__webpack_require__.e(/* import() | 1fc72748 */ "6230").then(__webpack_require__.t.bind(__webpack_require__, 63983, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-privacy-091.json",
        /*require.resolve*/(63983)
    ],
    "20e4b877": [
        ()=>__webpack_require__.e(/* import() | 20e4b877 */ "7827").then(__webpack_require__.bind(__webpack_require__, 42669)),
        "@site/blog/2025-04-06-crm-vs-excel-un-analisis-comparativo.md",
        /*require.resolve*/(42669)
    ],
    "22641f6c": [
        ()=>__webpack_require__.e(/* import() | 22641f6c */ "2630").then(__webpack_require__.bind(__webpack_require__, 59891)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/pipelines/how-can-i-add-a-stage-to-my-pipeline.md",
        /*require.resolve*/(59891)
    ],
    "26a0f5a1": [
        ()=>__webpack_require__.e(/* import() | 26a0f5a1 */ "3326").then(__webpack_require__.bind(__webpack_require__, 59151)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/getting-started/fintesk-glossary.md",
        /*require.resolve*/(59151)
    ],
    "2743f5c7": [
        ()=>__webpack_require__.e(/* import() | 2743f5c7 */ "6365").then(__webpack_require__.bind(__webpack_require__, 43027)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/privacy/privacy.md",
        /*require.resolve*/(43027)
    ],
    "2e4f5518": [
        ()=>__webpack_require__.e(/* import() | 2e4f5518 */ "8764").then(__webpack_require__.bind(__webpack_require__, 75010)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/list-view/customizing-the-columns-in-the-list-view.md",
        /*require.resolve*/(75010)
    ],
    "306e4764": [
        ()=>__webpack_require__.e(/* import() | 306e4764 */ "9217").then(__webpack_require__.t.bind(__webpack_require__, 64867, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-company-settings-6d4.json",
        /*require.resolve*/(64867)
    ],
    "311c2599": [
        ()=>__webpack_require__.e(/* import() | 311c2599 */ "6867").then(__webpack_require__.t.bind(__webpack_require__, 30790, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-fintesk-api-c74.json",
        /*require.resolve*/(30790)
    ],
    "3344bb77": [
        ()=>__webpack_require__.e(/* import() | 3344bb77 */ "6512").then(__webpack_require__.t.bind(__webpack_require__, 45806, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-billing-242.json",
        /*require.resolve*/(45806)
    ],
    "335b9b91": [
        ()=>__webpack_require__.e(/* import() | 335b9b91 */ "3748").then(__webpack_require__.bind(__webpack_require__, 59948)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/users-and-permissions/what-is-a-regular-user.md",
        /*require.resolve*/(59948)
    ],
    "3379c1c0": [
        ()=>__webpack_require__.e(/* import() | 3379c1c0 */ "2469").then(__webpack_require__.bind(__webpack_require__, 28367)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/deals/editing-the-contact-linked-to-a-deal.md",
        /*require.resolve*/(28367)
    ],
    "347e304f": [
        ()=>__webpack_require__.e(/* import() | 347e304f */ "3582").then(__webpack_require__.bind(__webpack_require__, 31623)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/personal-settings/fintesk-settings.md",
        /*require.resolve*/(31623)
    ],
    "348d668f": [
        ()=>__webpack_require__.e(/* import() | 348d668f */ "297").then(__webpack_require__.t.bind(__webpack_require__, 30123, 19)),
        "/Users/fabo/Documents/code/documentacion-fintesk/.docusaurus/docusaurus-plugin-redoc/fintesk-v1/redocApiSpecV1.2-fintesk-v1.json",
        /*require.resolve*/(30123)
    ],
    "34b54ed9": [
        ()=>__webpack_require__.e(/* import() | 34b54ed9 */ "8562").then(__webpack_require__.t.bind(__webpack_require__, 79501, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-core-api-concepts-4e9.json",
        /*require.resolve*/(79501)
    ],
    "34ed2666": [
        ()=>__webpack_require__.e(/* import() | 34ed2666 */ "5814").then(__webpack_require__.bind(__webpack_require__, 44408)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/products/can-i-have-one-product-in-different-price-variations.md",
        /*require.resolve*/(44408)
    ],
    "351c1b1f": [
        ()=>__webpack_require__.e(/* import() | 351c1b1f */ "9708").then(__webpack_require__.t.bind(__webpack_require__, 54512, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/es-blog-tags-ventas-7d3.json",
        /*require.resolve*/(54512)
    ],
    "36994c47": [
        ()=>__webpack_require__.e(/* import() | 36994c47 */ "191").then(__webpack_require__.t.bind(__webpack_require__, 45516, 19)),
        "@generated/docusaurus-plugin-content-blog/default/__plugin.json",
        /*require.resolve*/(45516)
    ],
    "3720c009": [
        ()=>Promise.all(/* import() | 3720c009 */ [__webpack_require__.e("4014"), __webpack_require__.e("5616")]).then(__webpack_require__.bind(__webpack_require__, 77610)),
        "@theme/DocTagsListPage",
        /*require.resolve*/(77610)
    ],
    "38cdae4e": [
        ()=>__webpack_require__.e(/* import() | 38cdae4e */ "973").then(__webpack_require__.t.bind(__webpack_require__, 56514, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-pipelines-127.json",
        /*require.resolve*/(56514)
    ],
    "393be207": [
        ()=>__webpack_require__.e(/* import() | 393be207 */ "3627").then(__webpack_require__.bind(__webpack_require__, 66301)),
        "@site/src/pages/markdown-page.md",
        /*require.resolve*/(66301)
    ],
    "39f5392f": [
        ()=>__webpack_require__.e(/* import() | 39f5392f */ "8553").then(__webpack_require__.t.bind(__webpack_require__, 65468, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-your-fintesk-subscription-plan-e1a.json",
        /*require.resolve*/(65468)
    ],
    "3c72dbd0": [
        ()=>__webpack_require__.e(/* import() | 3c72dbd0 */ "1381").then(__webpack_require__.t.bind(__webpack_require__, 19422, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-pipeline-view-033.json",
        /*require.resolve*/(19422)
    ],
    "3c864e55": [
        ()=>__webpack_require__.e(/* import() | 3c864e55 */ "7305").then(__webpack_require__.bind(__webpack_require__, 69890)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/importing-data/importing-advanced-mapping.md",
        /*require.resolve*/(69890)
    ],
    "3df48dd7": [
        ()=>__webpack_require__.e(/* import() | 3df48dd7 */ "636").then(__webpack_require__.t.bind(__webpack_require__, 24818, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-privacy-b71.json",
        /*require.resolve*/(24818)
    ],
    "3e0612ca": [
        ()=>__webpack_require__.e(/* import() | 3e0612ca */ "2133").then(__webpack_require__.bind(__webpack_require__, 75676)),
        "@site/blog/2025-04-09-estrategias-para-atraer-leads-de-alta-calidad.md?truncated=true",
        /*require.resolve*/(75676)
    ],
    "40d927e6": [
        ()=>__webpack_require__.e(/* import() | 40d927e6 */ "8979").then(__webpack_require__.bind(__webpack_require__, 68840)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/users-and-permissions/how-can-i-replace-users-in-my-fintesk-company-account.md",
        /*require.resolve*/(68840)
    ],
    "42702193": [
        ()=>__webpack_require__.e(/* import() | 42702193 */ "3368").then(__webpack_require__.bind(__webpack_require__, 35293)),
        "@site/blog/2025-04-05-alineando-marketing-y-ventas-para-una-conversion-optima.md",
        /*require.resolve*/(35293)
    ],
    "427f9635": [
        ()=>__webpack_require__.e(/* import() | 427f9635 */ "4832").then(__webpack_require__.bind(__webpack_require__, 49614)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/importing-data/why-do-my-imported-currency-values-appear-as-0.md",
        /*require.resolve*/(49614)
    ],
    "42c3d2c2": [
        ()=>__webpack_require__.e(/* import() | 42c3d2c2 */ "7307").then(__webpack_require__.bind(__webpack_require__, 93440)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/contacts/contact-detail-view.md",
        /*require.resolve*/(93440)
    ],
    "42dbfab1": [
        ()=>__webpack_require__.e(/* import() | 42dbfab1 */ "5836").then(__webpack_require__.bind(__webpack_require__, 57168)),
        "@site/blog/2025-04-09-estrategias-para-atraer-leads-de-alta-calidad.md",
        /*require.resolve*/(57168)
    ],
    "43a94161": [
        ()=>__webpack_require__.e(/* import() | 43a94161 */ "2681").then(__webpack_require__.bind(__webpack_require__, 16967)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/tos/terms-of-service.md",
        /*require.resolve*/(16967)
    ],
    "480bbaae": [
        ()=>__webpack_require__.e(/* import() | 480bbaae */ "9705").then(__webpack_require__.t.bind(__webpack_require__, 79585, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-billing-information-c17.json",
        /*require.resolve*/(79585)
    ],
    "49653484": [
        ()=>__webpack_require__.e(/* import() | 49653484 */ "4373").then(__webpack_require__.bind(__webpack_require__, 94282)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/company-settings/how-can-i-create-a-custom-currency.md",
        /*require.resolve*/(94282)
    ],
    "497e7b2b": [
        ()=>__webpack_require__.e(/* import() | 497e7b2b */ "4910").then(__webpack_require__.bind(__webpack_require__, 13209)),
        "@site/docs/developers/core-api-concepts/core-api-concepts-about-fintesk-api.md",
        /*require.resolve*/(13209)
    ],
    "4b3a3f77": [
        ()=>__webpack_require__.e(/* import() | 4b3a3f77 */ "6769").then(__webpack_require__.bind(__webpack_require__, 46837)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/users-and-permissions/how-can-i-add-a-user.md",
        /*require.resolve*/(46837)
    ],
    "4c41c86d": [
        ()=>__webpack_require__.e(/* import() | 4c41c86d */ "775").then(__webpack_require__.bind(__webpack_require__, 73426)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/getting-started/organization-vs-company-account.md",
        /*require.resolve*/(73426)
    ],
    "4f5dbec8": [
        ()=>__webpack_require__.e(/* import() | 4f5dbec8 */ "7937").then(__webpack_require__.bind(__webpack_require__, 65933)),
        "@site/docs/developers/core-api-concepts/core-api-concepts-http-status-codes.md",
        /*require.resolve*/(65933)
    ],
    "514ed3f9": [
        ()=>__webpack_require__.e(/* import() | 514ed3f9 */ "2289").then(__webpack_require__.bind(__webpack_require__, 34783)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/pipeline-view/how-can-i-see-deals-in-a-different-pipeline.md",
        /*require.resolve*/(34783)
    ],
    "526b8dd9": [
        ()=>__webpack_require__.e(/* import() | 526b8dd9 */ "1240").then(__webpack_require__.t.bind(__webpack_require__, 75699, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-billing-information-899.json",
        /*require.resolve*/(75699)
    ],
    "5624265d": [
        ()=>__webpack_require__.e(/* import() | 5624265d */ "7572").then(__webpack_require__.bind(__webpack_require__, 91187)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/pipelines/how-can-i-have-multiple-pipelines.md",
        /*require.resolve*/(91187)
    ],
    "564fb8f7": [
        ()=>__webpack_require__.e(/* import() | 564fb8f7 */ "68").then(__webpack_require__.bind(__webpack_require__, 12938)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/list-view/fintesk-system-ids.md",
        /*require.resolve*/(12938)
    ],
    "57536add": [
        ()=>__webpack_require__.e(/* import() | 57536add */ "2917").then(__webpack_require__.bind(__webpack_require__, 21251)),
        "@site/docs/developers/core-api-concepts/changes-to-the-api.md",
        /*require.resolve*/(21251)
    ],
    "57886a6f": [
        ()=>__webpack_require__.e(/* import() | 57886a6f */ "1269").then(__webpack_require__.bind(__webpack_require__, 90288)),
        "@site/blog/2025-04-05-mejora-de-las-tasas-de-conversion-a-traves-del-embudo-de-marketing-y-ventas.md",
        /*require.resolve*/(90288)
    ],
    "57fa3476": [
        ()=>__webpack_require__.e(/* import() | 57fa3476 */ "9811").then(__webpack_require__.bind(__webpack_require__, 17015)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/billing/billing-information/what-happens-to-my-billing-when-i-change-my-fintesk-subscription-plan.md",
        /*require.resolve*/(17015)
    ],
    "59423c55": [
        ()=>__webpack_require__.e(/* import() | 59423c55 */ "1068").then(__webpack_require__.bind(__webpack_require__, 72680)),
        "@site/blog/2025-04-06-las-desventajas-de-usar-excel-para-la-nutricion-y-el-seguimiento-de-leads.md?truncated=true",
        /*require.resolve*/(72680)
    ],
    "597d3170": [
        ()=>__webpack_require__.e(/* import() | 597d3170 */ "3433").then(__webpack_require__.bind(__webpack_require__, 27748)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/filtering/filtering.md",
        /*require.resolve*/(27748)
    ],
    "59b710f0": [
        ()=>__webpack_require__.e(/* import() | 59b710f0 */ "4978").then(__webpack_require__.bind(__webpack_require__, 29244)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/pipeline-view/pipeline-view.md",
        /*require.resolve*/(29244)
    ],
    "5ced9c79": [
        ()=>__webpack_require__.e(/* import() | 5ced9c79 */ "2725").then(__webpack_require__.bind(__webpack_require__, 14787)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/exporting-data/exporting-data-from-fintesk.md",
        /*require.resolve*/(14787)
    ],
    "5db51138": [
        ()=>__webpack_require__.e(/* import() | 5db51138 */ "5405").then(__webpack_require__.t.bind(__webpack_require__, 59990, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-contact-support-0f9.json",
        /*require.resolve*/(59990)
    ],
    "5e0a7532": [
        ()=>__webpack_require__.e(/* import() | 5e0a7532 */ "6916").then(__webpack_require__.bind(__webpack_require__, 32930)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/data-fields/how-can-i-add-data-fields-to-an-add-deal-contact-or-product-modal.md",
        /*require.resolve*/(32930)
    ],
    "5e95c892": [
        ()=>__webpack_require__.e(/* import() | 5e95c892 */ "1668").then(__webpack_require__.bind(__webpack_require__, 86569)),
        "@theme/DocsRoot",
        /*require.resolve*/(86569)
    ],
    "5f61064d": [
        ()=>__webpack_require__.e(/* import() | 5f61064d */ "5352").then(__webpack_require__.t.bind(__webpack_require__, 97332, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-pipelines-944.json",
        /*require.resolve*/(97332)
    ],
    "5fabbca8": [
        ()=>__webpack_require__.e(/* import() | 5fabbca8 */ "8094").then(__webpack_require__.t.bind(__webpack_require__, 39403, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-filtering-4fe.json",
        /*require.resolve*/(39403)
    ],
    "6114d855": [
        ()=>__webpack_require__.e(/* import() | 6114d855 */ "1906").then(__webpack_require__.bind(__webpack_require__, 83367)),
        "@site/blog/2025-04-06-comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel.md?truncated=true",
        /*require.resolve*/(83367)
    ],
    "621db11d": [
        ()=>Promise.all(/* import() | 621db11d */ [__webpack_require__.e("4014"), __webpack_require__.e("6726"), __webpack_require__.e("1221")]).then(__webpack_require__.bind(__webpack_require__, 86433)),
        "@theme/Blog/Pages/BlogAuthorsListPage",
        /*require.resolve*/(86433)
    ],
    "63bbb5f6": [
        ()=>__webpack_require__.e(/* import() | 63bbb5f6 */ "2166").then(__webpack_require__.t.bind(__webpack_require__, 86892, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/es-blog-tags-excel-7d3.json",
        /*require.resolve*/(86892)
    ],
    "64c3b18e": [
        ()=>__webpack_require__.e(/* import() | 64c3b18e */ "3810").then(__webpack_require__.bind(__webpack_require__, 51855)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/company-settings/how-can-i-enable-predefined-lost-reasons.md",
        /*require.resolve*/(51855)
    ],
    "65a663a3": [
        ()=>__webpack_require__.e(/* import() | 65a663a3 */ "7557").then(__webpack_require__.bind(__webpack_require__, 76075)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/data-fields/custom-fields.md",
        /*require.resolve*/(76075)
    ],
    "66e3fb8b": [
        ()=>__webpack_require__.e(/* import() | 66e3fb8b */ "8334").then(__webpack_require__.bind(__webpack_require__, 58705)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/detail-view/detail-view.md",
        /*require.resolve*/(58705)
    ],
    "67b951d4": [
        ()=>__webpack_require__.e(/* import() | 67b951d4 */ "7512").then(__webpack_require__.bind(__webpack_require__, 83263)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/troubleshooting/which-browser-is-best-for-fintesk.md",
        /*require.resolve*/(83263)
    ],
    "6875c492": [
        ()=>Promise.all(/* import() | 6875c492 */ [__webpack_require__.e("4014"), __webpack_require__.e("4473"), __webpack_require__.e("6726"), __webpack_require__.e("766")]).then(__webpack_require__.bind(__webpack_require__, 20149)),
        "@theme/BlogTagsPostsPage",
        /*require.resolve*/(20149)
    ],
    "68d382cf": [
        ()=>__webpack_require__.e(/* import() | 68d382cf */ "7224").then(__webpack_require__.bind(__webpack_require__, 24125)),
        "@site/blog/2025-04-05-estrategias-para-mejorar-las-tasas-de-conversion-en-cada-etapa-del-embudo.md",
        /*require.resolve*/(24125)
    ],
    "6a26327e": [
        ()=>__webpack_require__.e(/* import() | 6a26327e */ "1052").then(__webpack_require__.bind(__webpack_require__, 33020)),
        "@site/blog/2025-04-05-mejora-de-las-tasas-de-conversion-a-traves-del-embudo-de-marketing-y-ventas.md?truncated=true",
        /*require.resolve*/(33020)
    ],
    "6a4af112": [
        ()=>__webpack_require__.e(/* import() | 6a4af112 */ "5228").then(__webpack_require__.bind(__webpack_require__, 61605)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/billing/your-fintesk-subscription-plan/what-features-do-the-fintesk-plans-have.md",
        /*require.resolve*/(61605)
    ],
    "6bb703b2": [
        ()=>__webpack_require__.e(/* import() | 6bb703b2 */ "4342").then(__webpack_require__.bind(__webpack_require__, 29105)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/company-settings/lost-reasons.md",
        /*require.resolve*/(29105)
    ],
    "6de61594": [
        ()=>__webpack_require__.e(/* import() | 6de61594 */ "2990").then(__webpack_require__.bind(__webpack_require__, 17343)),
        "@site/blog/2025-04-05-estrategias-para-mejorar-las-tasas-de-conversion-en-cada-etapa-del-embudo.md?truncated=true",
        /*require.resolve*/(17343)
    ],
    "6e372507": [
        ()=>__webpack_require__.e(/* import() | 6e372507 */ "1515").then(__webpack_require__.bind(__webpack_require__, 56570)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/activities/how-can-i-link-my-activities-with-multiple-contact-persons.md",
        /*require.resolve*/(56570)
    ],
    "6ed99495": [
        ()=>__webpack_require__.e(/* import() | 6ed99495 */ "6017").then(__webpack_require__.bind(__webpack_require__, 40682)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/troubleshooting/how-can-i-take-a-screenshot.md",
        /*require.resolve*/(40682)
    ],
    "6f7c36fa": [
        ()=>__webpack_require__.e(/* import() | 6f7c36fa */ "6618").then(__webpack_require__.bind(__webpack_require__, 13416)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/importing-data/changing-the-field-type-of-a-custom-field.md",
        /*require.resolve*/(13416)
    ],
    "7061144e": [
        ()=>__webpack_require__.e(/* import() | 7061144e */ "5876").then(__webpack_require__.t.bind(__webpack_require__, 89511, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/es-blog-tags-tasa-de-conversion-dc9.json",
        /*require.resolve*/(89511)
    ],
    "71b694a8": [
        ()=>__webpack_require__.e(/* import() | 71b694a8 */ "4556").then(__webpack_require__.bind(__webpack_require__, 94736)),
        "@site/blog/2025-04-08-como-elegir-el-crm-o-software-de-gestion-de-ventas.md?truncated=true",
        /*require.resolve*/(94736)
    ],
    "71e5d3ca": [
        ()=>__webpack_require__.e(/* import() | 71e5d3ca */ "3075").then(__webpack_require__.bind(__webpack_require__, 84616)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/activities/activities.md",
        /*require.resolve*/(84616)
    ],
    "75e617f2": [
        ()=>__webpack_require__.e(/* import() | 75e617f2 */ "5583").then(__webpack_require__.bind(__webpack_require__, 95488)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/contacts/how-can-i-add-related-persons-or-organizations-to-a-deal.md",
        /*require.resolve*/(95488)
    ],
    "7711c30d": [
        ()=>__webpack_require__.e(/* import() | 7711c30d */ "3990").then(__webpack_require__.t.bind(__webpack_require__, 70248, 19)),
        "/Users/fabo/Documents/code/documentacion-fintesk/.docusaurus/docusaurus-plugin-redoc/fintesk-v1/redocApiLayoutV1-fintesk-v1.json",
        /*require.resolve*/(70248)
    ],
    "7bf6386c": [
        ()=>__webpack_require__.e(/* import() | 7bf6386c */ "7909").then(__webpack_require__.t.bind(__webpack_require__, 54104, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-exporting-data-126.json",
        /*require.resolve*/(54104)
    ],
    "7c522049": [
        ()=>__webpack_require__.e(/* import() | 7c522049 */ "780").then(__webpack_require__.bind(__webpack_require__, 3365)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/list-view/how-can-i-add-or-remove-columns-in-the-list-view.md",
        /*require.resolve*/(3365)
    ],
    "7c6c2975": [
        ()=>__webpack_require__.e(/* import() | 7c6c2975 */ "4936").then(__webpack_require__.t.bind(__webpack_require__, 88871, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-fintesk-api-183.json",
        /*require.resolve*/(88871)
    ],
    "7e188a67": [
        ()=>__webpack_require__.e(/* import() | 7e188a67 */ "153").then(__webpack_require__.bind(__webpack_require__, 63658)),
        "@site/docs/developers/core-api-concepts/core-api-concepts-custom-fields.md",
        /*require.resolve*/(63658)
    ],
    "80e033a9": [
        ()=>__webpack_require__.e(/* import() | 80e033a9 */ "517").then(__webpack_require__.t.bind(__webpack_require__, 17955, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-core-api-concepts-fbb.json",
        /*require.resolve*/(17955)
    ],
    "80f99bf8": [
        ()=>__webpack_require__.e(/* import() | 80f99bf8 */ "8524").then(__webpack_require__.t.bind(__webpack_require__, 57514, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-developers-54d.json",
        /*require.resolve*/(57514)
    ],
    "814f3328": [
        ()=>__webpack_require__.e(/* import() | 814f3328 */ "1833").then(__webpack_require__.t.bind(__webpack_require__, 55513, 19)),
        "~blog/default/blog-post-list-prop-default.json",
        /*require.resolve*/(55513)
    ],
    "828ae484": [
        ()=>__webpack_require__.e(/* import() | 828ae484 */ "4176").then(__webpack_require__.t.bind(__webpack_require__, 19225, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-troubleshooting-the-web-app-111.json",
        /*require.resolve*/(19225)
    ],
    "8296a943": [
        ()=>__webpack_require__.e(/* import() | 8296a943 */ "7786").then(__webpack_require__.bind(__webpack_require__, 89847)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/deals/how-can-i-restore-deleted-deals.md",
        /*require.resolve*/(89847)
    ],
    "82ac4542": [
        ()=>__webpack_require__.e(/* import() | 82ac4542 */ "6731").then(__webpack_require__.bind(__webpack_require__, 22650)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/importing-data/import-fields.md",
        /*require.resolve*/(22650)
    ],
    "82f61879": [
        ()=>__webpack_require__.e(/* import() | 82f61879 */ "9247").then(__webpack_require__.bind(__webpack_require__, 18009)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/troubleshooting/how-do-i-open-my-browser-console.md",
        /*require.resolve*/(18009)
    ],
    "84f8754a": [
        ()=>__webpack_require__.e(/* import() | 84f8754a */ "8497").then(__webpack_require__.t.bind(__webpack_require__, 39229, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-data-fields-1a8.json",
        /*require.resolve*/(39229)
    ],
    "85de7318": [
        ()=>__webpack_require__.e(/* import() | 85de7318 */ "3307").then(__webpack_require__.bind(__webpack_require__, 36603)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/contacts/linking-persons-and-organizations.md",
        /*require.resolve*/(36603)
    ],
    "88f67a13": [
        ()=>__webpack_require__.e(/* import() | 88f67a13 */ "7327").then(__webpack_require__.bind(__webpack_require__, 99134)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/billing/your-fintesk-subscription-plan/how-can-i-switch-to-a-different-fintesk-plan-or-change-my-billing-frequency.md",
        /*require.resolve*/(99134)
    ],
    "89afde3e": [
        ()=>__webpack_require__.e(/* import() | 89afde3e */ "9403").then(__webpack_require__.bind(__webpack_require__, 51000)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/activities/how-can-i-filter-my-activities-in-the-list-view.md",
        /*require.resolve*/(51000)
    ],
    "8a90ab5e": [
        ()=>__webpack_require__.e(/* import() | 8a90ab5e */ "8003").then(__webpack_require__.bind(__webpack_require__, 92736)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/activities/activity-marked-as-done-logic.md",
        /*require.resolve*/(92736)
    ],
    "8a97b6a3": [
        ()=>__webpack_require__.e(/* import() | 8a97b6a3 */ "9687").then(__webpack_require__.bind(__webpack_require__, 50665)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/privacy/dpa.md",
        /*require.resolve*/(50665)
    ],
    "8b0b5d87": [
        ()=>__webpack_require__.e(/* import() | 8b0b5d87 */ "1256").then(__webpack_require__.t.bind(__webpack_require__, 53981, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-getting-started-916.json",
        /*require.resolve*/(53981)
    ],
    "8b20138e": [
        ()=>__webpack_require__.e(/* import() | 8b20138e */ "743").then(__webpack_require__.t.bind(__webpack_require__, 85140, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/es-blog-43c.json",
        /*require.resolve*/(85140)
    ],
    "8b261a88": [
        ()=>__webpack_require__.e(/* import() | 8b261a88 */ "4972").then(__webpack_require__.bind(__webpack_require__, 54232)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/products/products.md",
        /*require.resolve*/(54232)
    ],
    "8b36d413": [
        ()=>__webpack_require__.e(/* import() | 8b36d413 */ "7243").then(__webpack_require__.t.bind(__webpack_require__, 30303, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-changelog-383.json",
        /*require.resolve*/(30303)
    ],
    "8bea8cac": [
        ()=>__webpack_require__.e(/* import() | 8bea8cac */ "5469").then(__webpack_require__.bind(__webpack_require__, 22366)),
        "@site/docs/developers/core-api-concepts/core-api-concepts-pagination.md",
        /*require.resolve*/(22366)
    ],
    "904aa57c": [
        ()=>__webpack_require__.e(/* import() | 904aa57c */ "1858").then(__webpack_require__.bind(__webpack_require__, 94080)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/detail-view/deal-detail-view.md",
        /*require.resolve*/(94080)
    ],
    "908f8316": [
        ()=>__webpack_require__.e(/* import() | 908f8316 */ "73").then(__webpack_require__.bind(__webpack_require__, 39554)),
        "@site/blog/2025-04-08-software-crm-popular-en-el-mercado-estadounidense.md?truncated=true",
        /*require.resolve*/(39554)
    ],
    "9165223e": [
        ()=>__webpack_require__.e(/* import() | 9165223e */ "12").then(__webpack_require__.t.bind(__webpack_require__, 62954, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-list-view-reporting-a50.json",
        /*require.resolve*/(62954)
    ],
    "9373caed": [
        ()=>__webpack_require__.e(/* import() | 9373caed */ "8791").then(__webpack_require__.bind(__webpack_require__, 29647)),
        "@site/blog/2025-04-06-crm-vs-excel-un-analisis-comparativo.md?truncated=true",
        /*require.resolve*/(29647)
    ],
    "94739f67": [
        ()=>__webpack_require__.e(/* import() | 94739f67 */ "1539").then(__webpack_require__.bind(__webpack_require__, 30707)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/importing-data/importing-mapping-your-fields.md",
        /*require.resolve*/(30707)
    ],
    "94fb5502": [
        ()=>__webpack_require__.e(/* import() | 94fb5502 */ "7041").then(__webpack_require__.t.bind(__webpack_require__, 60793, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-users-and-permissions-710.json",
        /*require.resolve*/(60793)
    ],
    "96eb2e13": [
        ()=>__webpack_require__.e(/* import() | 96eb2e13 */ "8733").then(__webpack_require__.t.bind(__webpack_require__, 51877, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-f09.json",
        /*require.resolve*/(51877)
    ],
    "9837289d": [
        ()=>__webpack_require__.e(/* import() | 9837289d */ "3744").then(__webpack_require__.t.bind(__webpack_require__, 93396, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-organizing-your-data-e96.json",
        /*require.resolve*/(93396)
    ],
    "99d4904e": [
        ()=>__webpack_require__.e(/* import() | 99d4904e */ "4000").then(__webpack_require__.t.bind(__webpack_require__, 62241, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-overview-7be.json",
        /*require.resolve*/(62241)
    ],
    "9b4f3099": [
        ()=>__webpack_require__.e(/* import() | 9b4f3099 */ "9624").then(__webpack_require__.t.bind(__webpack_require__, 7962, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-your-fintesk-subscription-plan-ba9.json",
        /*require.resolve*/(7962)
    ],
    "9bf80d53": [
        ()=>__webpack_require__.e(/* import() | 9bf80d53 */ "6877").then(__webpack_require__.bind(__webpack_require__, 17842)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/personal-settings/how-can-i-change-or-reset-my-password.md",
        /*require.resolve*/(17842)
    ],
    "9e4087bc": [
        ()=>__webpack_require__.e(/* import() | 9e4087bc */ "9660").then(__webpack_require__.bind(__webpack_require__, 87243)),
        "@theme/BlogArchivePage",
        /*require.resolve*/(87243)
    ],
    "9eac8549": [
        ()=>__webpack_require__.e(/* import() | 9eac8549 */ "2078").then(__webpack_require__.t.bind(__webpack_require__, 22309, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/es-blog-tags-crm-983.json",
        /*require.resolve*/(22309)
    ],
    "9f23735e": [
        ()=>__webpack_require__.e(/* import() | 9f23735e */ "568").then(__webpack_require__.bind(__webpack_require__, 47756)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/deals/adding-deals-in-bulk.md",
        /*require.resolve*/(47756)
    ],
    "9f82584d": [
        ()=>__webpack_require__.e(/* import() | 9f82584d */ "2028").then(__webpack_require__.bind(__webpack_require__, 99259)),
        "@site/docs/developers/core-api-concepts/core-api-concepts-requests.md",
        /*require.resolve*/(99259)
    ],
    "a08363ee": [
        ()=>__webpack_require__.e(/* import() | a08363ee */ "21").then(__webpack_require__.bind(__webpack_require__, 27415)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/detail-view/how-can-i-add-notes-to-a-deal-or-contact.md",
        /*require.resolve*/(27415)
    ],
    "a5b7cc07": [
        ()=>__webpack_require__.e(/* import() | a5b7cc07 */ "274").then(__webpack_require__.bind(__webpack_require__, 92843)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/personal-settings/usage-limits-in-fintesk.md",
        /*require.resolve*/(92843)
    ],
    "a65d8cc7": [
        ()=>__webpack_require__.e(/* import() | a65d8cc7 */ "7413").then(__webpack_require__.t.bind(__webpack_require__, 45058, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/es-blog-tags-ventas-page-2-e00.json",
        /*require.resolve*/(45058)
    ],
    "a6aa9e1f": [
        ()=>Promise.all(/* import() | a6aa9e1f */ [__webpack_require__.e("4014"), __webpack_require__.e("4473"), __webpack_require__.e("6726"), __webpack_require__.e("7496")]).then(__webpack_require__.bind(__webpack_require__, 92152)),
        "@theme/BlogListPage",
        /*require.resolve*/(92152)
    ],
    "a723be2d": [
        ()=>__webpack_require__.e(/* import() | a723be2d */ "9300").then(__webpack_require__.bind(__webpack_require__, 19578)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/importing-data/transferring-data-to-a-different-fintesk-company-account.md",
        /*require.resolve*/(19578)
    ],
    "a7456010": [
        ()=>__webpack_require__.e(/* import() | a7456010 */ "3056").then(__webpack_require__.t.bind(__webpack_require__, 88552, 19)),
        "@generated/docusaurus-plugin-content-pages/default/__plugin.json",
        /*require.resolve*/(88552)
    ],
    "a7bd4aaa": [
        ()=>__webpack_require__.e(/* import() | a7bd4aaa */ "5575").then(__webpack_require__.bind(__webpack_require__, 60524)),
        "@theme/DocVersionRoot",
        /*require.resolve*/(60524)
    ],
    "a94703ab": [
        ()=>Promise.all(/* import() | a94703ab */ [__webpack_require__.e("4014"), __webpack_require__.e("6785")]).then(__webpack_require__.bind(__webpack_require__, 81399)),
        "@theme/DocRoot",
        /*require.resolve*/(81399)
    ],
    "aaa3b165": [
        ()=>__webpack_require__.e(/* import() | aaa3b165 */ "5758").then(__webpack_require__.t.bind(__webpack_require__, 95604, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-basic-concepts-74d.json",
        /*require.resolve*/(95604)
    ],
    "aba21aa0": [
        ()=>__webpack_require__.e(/* import() | aba21aa0 */ "3747").then(__webpack_require__.t.bind(__webpack_require__, 27093, 19)),
        "@generated/docusaurus-plugin-content-docs/default/__plugin.json",
        /*require.resolve*/(27093)
    ],
    "ac075ab0": [
        ()=>__webpack_require__.e(/* import() | ac075ab0 */ "1377").then(__webpack_require__.bind(__webpack_require__, 98300)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/pipeline-view/how-can-i-delete-a-deal-in-the-pipeline-view.md",
        /*require.resolve*/(98300)
    ],
    "acecf23e": [
        ()=>__webpack_require__.e(/* import() | acecf23e */ "3220").then(__webpack_require__.t.bind(__webpack_require__, 1912, 19)),
        "~blog/default/blogMetadata-default.json",
        /*require.resolve*/(1912)
    ],
    "add6720e": [
        ()=>__webpack_require__.e(/* import() | add6720e */ "5629").then(__webpack_require__.bind(__webpack_require__, 21429)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/billing/billing-information/what-happens-to-my-billing-when-i-add-a-user-in-fintesk.md",
        /*require.resolve*/(21429)
    ],
    "aee47763": [
        ()=>__webpack_require__.e(/* import() | aee47763 */ "6802").then(__webpack_require__.t.bind(__webpack_require__, 80649, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-personal-settings-e36.json",
        /*require.resolve*/(80649)
    ],
    "b0bc9003": [
        ()=>__webpack_require__.e(/* import() | b0bc9003 */ "5429").then(__webpack_require__.t.bind(__webpack_require__, 30915, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-products-7af.json",
        /*require.resolve*/(30915)
    ],
    "b1c21d6c": [
        ()=>__webpack_require__.e(/* import() | b1c21d6c */ "4898").then(__webpack_require__.bind(__webpack_require__, 37310)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/contacts/contacts-persons-and-organizations.md",
        /*require.resolve*/(37310)
    ],
    "b2a5f17d": [
        ()=>__webpack_require__.e(/* import() | b2a5f17d */ "5280").then(__webpack_require__.bind(__webpack_require__, 4038)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/deals/how-can-i-move-a-deal-to-another-pipeline.md",
        /*require.resolve*/(4038)
    ],
    "b2d6b5e2": [
        ()=>__webpack_require__.e(/* import() | b2d6b5e2 */ "5440").then(__webpack_require__.bind(__webpack_require__, 9378)),
        "@site/blog/2025-04-06-las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads.md",
        /*require.resolve*/(9378)
    ],
    "b3361e2b": [
        ()=>__webpack_require__.e(/* import() | b3361e2b */ "140").then(__webpack_require__.bind(__webpack_require__, 70196)),
        "@site/blog/2025-04-06-indicadores-clave-de-rendimiento-kpi-para-medir-el-exito.md",
        /*require.resolve*/(70196)
    ],
    "b8387ec1": [
        ()=>__webpack_require__.e(/* import() | b8387ec1 */ "3277").then(__webpack_require__.t.bind(__webpack_require__, 5210, 19)),
        "@generated/docusaurus-plugin-redoc/fintesk-v1/__plugin.json",
        /*require.resolve*/(5210)
    ],
    "b8a74deb": [
        ()=>__webpack_require__.e(/* import() | b8a74deb */ "333").then(__webpack_require__.bind(__webpack_require__, 11272)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/billing/billing-information/what-happens-to-my-billing-when-i-deactivate-a-user-in-fintesk.md",
        /*require.resolve*/(11272)
    ],
    "bc525906": [
        ()=>__webpack_require__.e(/* import() | bc525906 */ "6900").then(__webpack_require__.bind(__webpack_require__, 25149)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/getting-started/what-is-the-difference-between-a-user-and-a-seat.md",
        /*require.resolve*/(25149)
    ],
    "bcb7ac82": [
        ()=>__webpack_require__.e(/* import() | bcb7ac82 */ "6982").then(__webpack_require__.bind(__webpack_require__, 63184)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/users-and-permissions/global-user-management.md",
        /*require.resolve*/(63184)
    ],
    "bddaa4da": [
        ()=>__webpack_require__.e(/* import() | bddaa4da */ "9115").then(__webpack_require__.t.bind(__webpack_require__, 83287, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/es-blog-page-2-a16.json",
        /*require.resolve*/(83287)
    ],
    "be1b61f6": [
        ()=>__webpack_require__.e(/* import() | be1b61f6 */ "3295").then(__webpack_require__.bind(__webpack_require__, 98871)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/activities/how-can-i-see-done-activities.md",
        /*require.resolve*/(98871)
    ],
    "c17ac11c": [
        ()=>__webpack_require__.e(/* import() | c17ac11c */ "6412").then(__webpack_require__.bind(__webpack_require__, 32507)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/data-fields/what-types-of-custom-fields-are-there.md",
        /*require.resolve*/(32507)
    ],
    "c238e8e5": [
        ()=>__webpack_require__.e(/* import() | c238e8e5 */ "1493").then(__webpack_require__.bind(__webpack_require__, 97440)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/troubleshooting/can-fintesk-be-used-offline.md",
        /*require.resolve*/(97440)
    ],
    "c438431a": [
        ()=>__webpack_require__.e(/* import() | c438431a */ "323").then(__webpack_require__.t.bind(__webpack_require__, 36480, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-knowledge-base-a70.json",
        /*require.resolve*/(36480)
    ],
    "c5b25b1f": [
        ()=>__webpack_require__.e(/* import() | c5b25b1f */ "2408").then(__webpack_require__.bind(__webpack_require__, 73701)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/products/how-can-i-link-products-to-a-deal.md",
        /*require.resolve*/(73701)
    ],
    "c5cdb8f8": [
        ()=>__webpack_require__.e(/* import() | c5cdb8f8 */ "8735").then(__webpack_require__.t.bind(__webpack_require__, 26592, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-terms-of-service-7aa.json",
        /*require.resolve*/(26592)
    ],
    "c9857b17": [
        ()=>__webpack_require__.e(/* import() | c9857b17 */ "3222").then(__webpack_require__.t.bind(__webpack_require__, 92700, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-personal-settings-efa.json",
        /*require.resolve*/(92700)
    ],
    "cab78a59": [
        ()=>__webpack_require__.e(/* import() | cab78a59 */ "8626").then(__webpack_require__.bind(__webpack_require__, 52245)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/deals/deals-what-they-are-and-how-to-add-them.md",
        /*require.resolve*/(52245)
    ],
    "cb625aae": [
        ()=>__webpack_require__.e(/* import() | cb625aae */ "9013").then(__webpack_require__.t.bind(__webpack_require__, 44908, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-importing-data-f3c.json",
        /*require.resolve*/(44908)
    ],
    "ccc49370": [
        ()=>Promise.all(/* import() | ccc49370 */ [__webpack_require__.e("4014"), __webpack_require__.e("4473"), __webpack_require__.e("6726"), __webpack_require__.e("6074")]).then(__webpack_require__.bind(__webpack_require__, 2063)),
        "@theme/BlogPostPage",
        /*require.resolve*/(2063)
    ],
    "cdd26b62": [
        ()=>__webpack_require__.e(/* import() | cdd26b62 */ "3561").then(__webpack_require__.bind(__webpack_require__, 62207)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/data-fields/data-fields-in-fintesk.md",
        /*require.resolve*/(62207)
    ],
    "cddaf021": [
        ()=>__webpack_require__.e(/* import() | cddaf021 */ "51").then(__webpack_require__.t.bind(__webpack_require__, 10025, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-products-c7c.json",
        /*require.resolve*/(10025)
    ],
    "ce08bd4c": [
        ()=>__webpack_require__.e(/* import() | ce08bd4c */ "9291").then(__webpack_require__.t.bind(__webpack_require__, 60831, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-manage-users-747.json",
        /*require.resolve*/(60831)
    ],
    "ce72740e": [
        ()=>__webpack_require__.e(/* import() | ce72740e */ "6433").then(__webpack_require__.bind(__webpack_require__, 32670)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/importing-data/how-can-i-format-dates-to-import-into-fintesk.md",
        /*require.resolve*/(32670)
    ],
    "cf1e8ef5": [
        ()=>__webpack_require__.e(/* import() | cf1e8ef5 */ "5349").then(__webpack_require__.bind(__webpack_require__, 82277)),
        "@site/blog/2025-04-06-comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel.md",
        /*require.resolve*/(82277)
    ],
    "d01a6831": [
        ()=>__webpack_require__.e(/* import() | d01a6831 */ "7616").then(__webpack_require__.bind(__webpack_require__, 79041)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/users-and-permissions/updating-user-information.md",
        /*require.resolve*/(79041)
    ],
    "d217ec42": [
        ()=>__webpack_require__.e(/* import() | d217ec42 */ "5572").then(__webpack_require__.bind(__webpack_require__, 85019)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/activities/how-can-i-create-activities-in-bulk.md",
        /*require.resolve*/(85019)
    ],
    "d24de678": [
        ()=>__webpack_require__.e(/* import() | d24de678 */ "3738").then(__webpack_require__.t.bind(__webpack_require__, 29403, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-deals-13d.json",
        /*require.resolve*/(29403)
    ],
    "d3d9c1cc": [
        ()=>__webpack_require__.e(/* import() | d3d9c1cc */ "8516").then(__webpack_require__.bind(__webpack_require__, 88829)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/troubleshooting/how-do-i-clear-my-browser-s-cache-and-cookies.md",
        /*require.resolve*/(88829)
    ],
    "d4adaca3": [
        ()=>__webpack_require__.e(/* import() | d4adaca3 */ "1598").then(__webpack_require__.bind(__webpack_require__, 49044)),
        "@site/blog/2025-04-08-como-elegir-el-crm-o-software-de-gestion-de-ventas.md",
        /*require.resolve*/(49044)
    ],
    "d8a6de9e": [
        ()=>__webpack_require__.e(/* import() | d8a6de9e */ "4434").then(__webpack_require__.bind(__webpack_require__, 16310)),
        "@site/blog/2025-04-06-las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads.md?truncated=true",
        /*require.resolve*/(16310)
    ],
    "d9320b6b": [
        ()=>__webpack_require__.e(/* import() | d9320b6b */ "8600").then(__webpack_require__.t.bind(__webpack_require__, 2204, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-tos-7b4.json",
        /*require.resolve*/(2204)
    ],
    "d9ce5890": [
        ()=>__webpack_require__.e(/* import() | d9ce5890 */ "1651").then(__webpack_require__.t.bind(__webpack_require__, 19857, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-deals-d85.json",
        /*require.resolve*/(19857)
    ],
    "dcdbbd91": [
        ()=>__webpack_require__.e(/* import() | dcdbbd91 */ "7147").then(__webpack_require__.bind(__webpack_require__, 43755)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/users-and-permissions/users.md",
        /*require.resolve*/(43755)
    ],
    "dd6f6a38": [
        ()=>__webpack_require__.e(/* import() | dd6f6a38 */ "4386").then(__webpack_require__.bind(__webpack_require__, 69683)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/fintesk/changelog.md",
        /*require.resolve*/(69683)
    ],
    "ddd73e7e": [
        ()=>__webpack_require__.e(/* import() | ddd73e7e */ "3921").then(__webpack_require__.t.bind(__webpack_require__, 66137, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-users-and-permissions-e60.json",
        /*require.resolve*/(66137)
    ],
    "ddeeebad": [
        ()=>__webpack_require__.e(/* import() | ddeeebad */ "192").then(__webpack_require__.bind(__webpack_require__, 3721)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/getting-started/interface-in-fintesk.md",
        /*require.resolve*/(3721)
    ],
    "de1495e0": [
        ()=>__webpack_require__.e(/* import() | de1495e0 */ "3937").then(__webpack_require__.bind(__webpack_require__, 33399)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/activities/creating-custom-activity-types.md",
        /*require.resolve*/(33399)
    ],
    "de1c1b0d": [
        ()=>__webpack_require__.e(/* import() | de1c1b0d */ "7400").then(__webpack_require__.bind(__webpack_require__, 74324)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/getting-started/how-can-i-delete-items-in-fintesk.md",
        /*require.resolve*/(74324)
    ],
    "de5288b6": [
        ()=>__webpack_require__.e(/* import() | de5288b6 */ "1312").then(__webpack_require__.bind(__webpack_require__, 71786)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/getting-started/how-is-fintesk-data-organized.md",
        /*require.resolve*/(71786)
    ],
    "df203c0f": [
        ()=>Promise.all(/* import() | df203c0f */ [__webpack_require__.e("4014"), __webpack_require__.e("4380")]).then(__webpack_require__.bind(__webpack_require__, 32761)),
        "@theme/DocTagDocListPage",
        /*require.resolve*/(32761)
    ],
    "dfed01cf": [
        ()=>__webpack_require__.e(/* import() | dfed01cf */ "4665").then(__webpack_require__.t.bind(__webpack_require__, 27888, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/es-blog-archive-ea1.json",
        /*require.resolve*/(27888)
    ],
    "e0fede9b": [
        ()=>__webpack_require__.e(/* import() | e0fede9b */ "5528").then(__webpack_require__.bind(__webpack_require__, 73004)),
        "@site/blog/2025-04-06-las-desventajas-de-usar-excel-para-la-nutricion-y-el-seguimiento-de-leads.md",
        /*require.resolve*/(73004)
    ],
    "e1173dc6": [
        ()=>__webpack_require__.e(/* import() | e1173dc6 */ "4096").then(__webpack_require__.t.bind(__webpack_require__, 4261, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-features-62e.json",
        /*require.resolve*/(4261)
    ],
    "e12988e0": [
        ()=>__webpack_require__.e(/* import() | e12988e0 */ "5394").then(__webpack_require__.t.bind(__webpack_require__, 63859, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-activities-444.json",
        /*require.resolve*/(63859)
    ],
    "e29280ac": [
        ()=>__webpack_require__.e(/* import() | e29280ac */ "6724").then(__webpack_require__.t.bind(__webpack_require__, 33086, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-billing-a60.json",
        /*require.resolve*/(33086)
    ],
    "e4884af1": [
        ()=>__webpack_require__.e(/* import() | e4884af1 */ "8651").then(__webpack_require__.t.bind(__webpack_require__, 23301, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/es-blog-tags-embudo-marketing-db5.json",
        /*require.resolve*/(23301)
    ],
    "e4905158": [
        ()=>__webpack_require__.e(/* import() | e4905158 */ "4559").then(__webpack_require__.t.bind(__webpack_require__, 18197, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-developers-dda.json",
        /*require.resolve*/(18197)
    ],
    "e4ebf854": [
        ()=>__webpack_require__.e(/* import() | e4ebf854 */ "3869").then(__webpack_require__.bind(__webpack_require__, 32798)),
        "@site/blog/2025-04-08-software-crm-popular-en-el-mercado-estadounidense.md",
        /*require.resolve*/(32798)
    ],
    "e50797ea": [
        ()=>__webpack_require__.e(/* import() | e50797ea */ "1649").then(__webpack_require__.bind(__webpack_require__, 14276)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/users-and-permissions/who-is-the-admin-user-of-my-account.md",
        /*require.resolve*/(14276)
    ],
    "e5fc8ef8": [
        ()=>__webpack_require__.e(/* import() | e5fc8ef8 */ "968").then(__webpack_require__.bind(__webpack_require__, 9816)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/getting-started/search-finding-what-you-need.md",
        /*require.resolve*/(9816)
    ],
    "e663daef": [
        ()=>__webpack_require__.e(/* import() | e663daef */ "9956").then(__webpack_require__.t.bind(__webpack_require__, 51881, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/es-blog-tags-crm-page-2-83f.json",
        /*require.resolve*/(51881)
    ],
    "e67eab86": [
        ()=>__webpack_require__.e(/* import() | e67eab86 */ "4522").then(__webpack_require__.bind(__webpack_require__, 22074)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/products/can-i-import-products-and-automatically-link-them-to-deals.md",
        /*require.resolve*/(22074)
    ],
    "e76bb3ad": [
        ()=>__webpack_require__.e(/* import() | e76bb3ad */ "4186").then(__webpack_require__.t.bind(__webpack_require__, 32420, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-getting-started-f15.json",
        /*require.resolve*/(32420)
    ],
    "e7f529da": [
        ()=>__webpack_require__.e(/* import() | e7f529da */ "8419").then(__webpack_require__.bind(__webpack_require__, 83686)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/products/where-do-i-activate-or-deactivate-individual-products.md",
        /*require.resolve*/(83686)
    ],
    "e86ce71c": [
        ()=>__webpack_require__.e(/* import() | e86ce71c */ "6194").then(__webpack_require__.t.bind(__webpack_require__, 1829, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-list-view-980.json",
        /*require.resolve*/(1829)
    ],
    "e8f4a039": [
        ()=>__webpack_require__.e(/* import() | e8f4a039 */ "8922").then(__webpack_require__.t.bind(__webpack_require__, 7260, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-list-view-8c0.json",
        /*require.resolve*/(7260)
    ],
    "ead47cb0": [
        ()=>__webpack_require__.e(/* import() | ead47cb0 */ "1318").then(__webpack_require__.t.bind(__webpack_require__, 72406, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-detail-view-0f4.json",
        /*require.resolve*/(72406)
    ],
    "ebfe9078": [
        ()=>__webpack_require__.e(/* import() | ebfe9078 */ "1072").then(__webpack_require__.t.bind(__webpack_require__, 91321, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/es-blog-tags-excel-vs-crm-ea8.json",
        /*require.resolve*/(91321)
    ],
    "ec4249a1": [
        ()=>__webpack_require__.e(/* import() | ec4249a1 */ "6151").then(__webpack_require__.bind(__webpack_require__, 99908)),
        "@site/docs/developers/core-api-concepts/core-api-concepts-date-format.md",
        /*require.resolve*/(99908)
    ],
    "eda2513a": [
        ()=>__webpack_require__.e(/* import() | eda2513a */ "4784").then(__webpack_require__.bind(__webpack_require__, 93736)),
        "@site/docs/developers/overview/getting-started.md",
        /*require.resolve*/(93736)
    ],
    "f0ad3fbb": [
        ()=>Promise.all(/* import() | f0ad3fbb */ [__webpack_require__.e("4014"), __webpack_require__.e("513"), __webpack_require__.e("8354")]).then(__webpack_require__.bind(__webpack_require__, 88418)),
        "@theme/ApiDoc",
        /*require.resolve*/(88418)
    ],
    "f3dc583f": [
        ()=>__webpack_require__.e(/* import() | f3dc583f */ "8230").then(__webpack_require__.t.bind(__webpack_require__, 84123, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-category-troubleshooting-2ab.json",
        /*require.resolve*/(84123)
    ],
    "f5d11d20": [
        ()=>__webpack_require__.e(/* import() | f5d11d20 */ "5117").then(__webpack_require__.t.bind(__webpack_require__, 28521, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/es-blog-tags-embudo-ventas-17d.json",
        /*require.resolve*/(28521)
    ],
    "f601d5af": [
        ()=>__webpack_require__.e(/* import() | f601d5af */ "2135").then(__webpack_require__.t.bind(__webpack_require__, 76400, 19)),
        "@generated/docusaurus-plugin-content-blog/default/p/es-blog-authors-be4.json",
        /*require.resolve*/(76400)
    ],
    "f7552a49": [
        ()=>__webpack_require__.e(/* import() | f7552a49 */ "8207").then(__webpack_require__.t.bind(__webpack_require__, 78215, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-importing-data-130.json",
        /*require.resolve*/(78215)
    ],
    "f902ee87": [
        ()=>__webpack_require__.e(/* import() | f902ee87 */ "6168").then(__webpack_require__.bind(__webpack_require__, 83580)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/list-view/how-can-i-set-default-columns-for-all-my-users-in-the-list-view.md",
        /*require.resolve*/(83580)
    ],
    "faaef88a": [
        ()=>__webpack_require__.e(/* import() | faaef88a */ "6078").then(__webpack_require__.bind(__webpack_require__, 30725)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/filtering/filters-common-uses.md",
        /*require.resolve*/(30725)
    ],
    "fae417d8": [
        ()=>__webpack_require__.e(/* import() | fae417d8 */ "4984").then(__webpack_require__.bind(__webpack_require__, 6176)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/importing-data/importing-sample-import-spreadsheets.md",
        /*require.resolve*/(6176)
    ],
    "fbb6c010": [
        ()=>__webpack_require__.e(/* import() | fbb6c010 */ "3382").then(__webpack_require__.bind(__webpack_require__, 37578)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/pipeline-view/the-rotting-feature.md",
        /*require.resolve*/(37578)
    ],
    "fc8c514c": [
        ()=>__webpack_require__.e(/* import() | fc8c514c */ "6517").then(__webpack_require__.bind(__webpack_require__, 11335)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user.md",
        /*require.resolve*/(11335)
    ],
    "fd988e86": [
        ()=>__webpack_require__.e(/* import() | fd988e86 */ "954").then(__webpack_require__.bind(__webpack_require__, 95472)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/privacy/fintesk-data-sub-processors.md",
        /*require.resolve*/(95472)
    ],
    "fd9df2c6": [
        ()=>__webpack_require__.e(/* import() | fd9df2c6 */ "8798").then(__webpack_require__.bind(__webpack_require__, 81853)),
        "@site/i18n/es/docusaurus-plugin-content-docs/current/kb/detail-view/updating-items-in-the-detail-view.md",
        /*require.resolve*/(81853)
    ],
    "fe269359": [
        ()=>__webpack_require__.e(/* import() | fe269359 */ "6119").then(__webpack_require__.t.bind(__webpack_require__, 85601, 19)),
        "@generated/docusaurus-plugin-content-docs/default/p/es-tags-progress-a31.json",
        /*require.resolve*/(85601)
    ]
});

;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/theme-fallback/Loading/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ // Should we translate theme-fallback?
/* eslint-disable @docusaurus/no-untranslated-text */ 

function Loading({ error, retry, pastDelay }) {
    if (error) {
        return /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
            style: {
                textAlign: 'center',
                color: '#fff',
                backgroundColor: '#fa383e',
                borderColor: '#fa383e',
                borderStyle: 'solid',
                borderRadius: '0.25rem',
                borderWidth: '1px',
                boxSizing: 'border-box',
                display: 'block',
                padding: '1rem',
                flex: '0 0 50%',
                marginLeft: '25%',
                marginRight: '25%',
                marginTop: '5rem',
                maxWidth: '50%',
                width: '100%'
            },
            children: [
                /*#__PURE__*/ (0,jsx_runtime.jsx)("p", {
                    children: String(error)
                }),
                /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
                    children: /*#__PURE__*/ (0,jsx_runtime.jsx)("button", {
                        type: "button",
                        onClick: retry,
                        children: "Retry"
                    })
                })
            ]
        });
    }
    if (pastDelay) {
        return /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
            style: {
                display: 'flex',
                justifyContent: 'center',
                alignItems: 'center',
                height: '100vh'
            },
            children: /*#__PURE__*/ (0,jsx_runtime.jsx)("svg", {
                id: "loader",
                style: {
                    width: 128,
                    height: 110,
                    position: 'absolute',
                    top: 'calc(100vh - 64%)'
                },
                viewBox: "0 0 45 45",
                xmlns: "http://www.w3.org/2000/svg",
                stroke: "#61dafb",
                children: /*#__PURE__*/ (0,jsx_runtime.jsxs)("g", {
                    fill: "none",
                    fillRule: "evenodd",
                    transform: "translate(1 1)",
                    strokeWidth: "2",
                    children: [
                        /*#__PURE__*/ (0,jsx_runtime.jsxs)("circle", {
                            cx: "22",
                            cy: "22",
                            r: "6",
                            strokeOpacity: "0",
                            children: [
                                /*#__PURE__*/ (0,jsx_runtime.jsx)("animate", {
                                    attributeName: "r",
                                    begin: "1.5s",
                                    dur: "3s",
                                    values: "6;22",
                                    calcMode: "linear",
                                    repeatCount: "indefinite"
                                }),
                                /*#__PURE__*/ (0,jsx_runtime.jsx)("animate", {
                                    attributeName: "stroke-opacity",
                                    begin: "1.5s",
                                    dur: "3s",
                                    values: "1;0",
                                    calcMode: "linear",
                                    repeatCount: "indefinite"
                                }),
                                /*#__PURE__*/ (0,jsx_runtime.jsx)("animate", {
                                    attributeName: "stroke-width",
                                    begin: "1.5s",
                                    dur: "3s",
                                    values: "2;0",
                                    calcMode: "linear",
                                    repeatCount: "indefinite"
                                })
                            ]
                        }),
                        /*#__PURE__*/ (0,jsx_runtime.jsxs)("circle", {
                            cx: "22",
                            cy: "22",
                            r: "6",
                            strokeOpacity: "0",
                            children: [
                                /*#__PURE__*/ (0,jsx_runtime.jsx)("animate", {
                                    attributeName: "r",
                                    begin: "3s",
                                    dur: "3s",
                                    values: "6;22",
                                    calcMode: "linear",
                                    repeatCount: "indefinite"
                                }),
                                /*#__PURE__*/ (0,jsx_runtime.jsx)("animate", {
                                    attributeName: "stroke-opacity",
                                    begin: "3s",
                                    dur: "3s",
                                    values: "1;0",
                                    calcMode: "linear",
                                    repeatCount: "indefinite"
                                }),
                                /*#__PURE__*/ (0,jsx_runtime.jsx)("animate", {
                                    attributeName: "stroke-width",
                                    begin: "3s",
                                    dur: "3s",
                                    values: "2;0",
                                    calcMode: "linear",
                                    repeatCount: "indefinite"
                                })
                            ]
                        }),
                        /*#__PURE__*/ (0,jsx_runtime.jsx)("circle", {
                            cx: "22",
                            cy: "22",
                            r: "8",
                            children: /*#__PURE__*/ (0,jsx_runtime.jsx)("animate", {
                                attributeName: "r",
                                begin: "0s",
                                dur: "1.5s",
                                values: "6;1;2;3;4;5;6",
                                calcMode: "linear",
                                repeatCount: "indefinite"
                            })
                        })
                    ]
                })
            })
        });
    }
    return null;
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/flat.js
var flat = __webpack_require__(27665);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/routeContext.js
var client_routeContext = __webpack_require__(97574);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/exports/ComponentCreator.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 







function ComponentCreator(path, hash) {
    // 404 page
    if (path === '*') {
        return lib_default()({
            loading: Loading,
            loader: ()=>__webpack_require__.e(/* import() */ "5062").then(__webpack_require__.bind(__webpack_require__, 70629)),
            modules: [
                '@theme/NotFound'
            ],
            webpack: ()=>[
                    /*require.resolve*/(70629)
                ],
            render (loaded, props) {
                const NotFound = loaded.default;
                return /*#__PURE__*/ (0,jsx_runtime.jsx)(client_routeContext/* .RouteContextProvider */.W, {
                    // Do we want a better name than native-default?
                    value: {
                        plugin: {
                            name: 'native',
                            id: 'default'
                        }
                    },
                    children: /*#__PURE__*/ (0,jsx_runtime.jsx)(NotFound, {
                        ...props
                    })
                });
            }
        });
    }
    const chunkNames = routesChunkNames[`${path}-${hash}`];
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const loader = {};
    const modules = [];
    const optsWebpack = [];
    // A map from prop names to chunk names.
    // e.g. Suppose the plugin added this as route:
    //   { __comp: "...", prop: { foo: "..." }, items: ["...", "..."] }
    // It will become:
    //   { __comp: "...", "prop.foo": "...", "items.0": "...", "items.1": ... }
    // Loadable.Map will _map_ over `loader` and load each key.
    const flatChunkNames = (0,flat/* ["default"] */.A)(chunkNames);
    Object.entries(flatChunkNames).forEach(([keyPath, chunkName])=>{
        const chunkRegistry = registry[chunkName];
        if (chunkRegistry) {
            loader[keyPath] = chunkRegistry[0];
            modules.push(chunkRegistry[1]);
            optsWebpack.push(chunkRegistry[2]);
        }
    });
    return lib_default().Map({
        loading: Loading,
        loader,
        modules,
        webpack: ()=>optsWebpack,
        render (loaded, props) {
            // `loaded` will be a map from key path (as returned from the flattened
            // chunk names) to the modules loaded from the loaders. We now have to
            // restore the chunk names' previous shape from this flat record.
            // We do so by taking advantage of the existing `chunkNames` and replacing
            // each chunk name with its loaded module, so we don't create another
            // object from scratch.
            const loadedModules = JSON.parse(JSON.stringify(chunkNames));
            Object.entries(loaded).forEach(([keyPath, loadedModule])=>{
                // JSON modules are also loaded as `{ default: ... }` (`import()`
                // semantics) but we just want to pass the actual value to props.
                const chunk = loadedModule.default;
                // One loaded chunk can only be one of two things: a module (props) or a
                // component. Modules are always JSON, so `default` always exists. This
                // could only happen with a user-defined component.
                if (!chunk) {
                    throw new Error(`The page component at ${path} doesn't have a default export. This makes it impossible to render anything. Consider default-exporting a React component.`);
                }
                // A module can be a primitive, for example, if the user stored a string
                // as a prop. However, there seems to be a bug with swc-loader's CJS
                // logic, in that it would load a JSON module with content "foo" as
                // `{ default: "foo", 0: "f", 1: "o", 2: "o" }`. Just to be safe, we
                // first make sure that the chunk is non-primitive.
                if (typeof chunk === 'object' || typeof chunk === 'function') {
                    Object.keys(loadedModule).filter((k)=>k !== 'default').forEach((nonDefaultKey)=>{
                        chunk[nonDefaultKey] = loadedModule[nonDefaultKey];
                    });
                }
                // We now have this chunk prepared. Go down the key path and replace the
                // chunk name with the actual chunk.
                let val = loadedModules;
                const keyPaths = keyPath.split('.');
                keyPaths.slice(0, -1).forEach((k)=>{
                    val = val[k];
                });
                val[keyPaths[keyPaths.length - 1]] = chunk;
            });
            /* eslint-disable no-underscore-dangle */ const Component = loadedModules.__comp;
            delete loadedModules.__comp;
            const routeContext = loadedModules.__context;
            delete loadedModules.__context;
            const routeProps = loadedModules.__props;
            delete loadedModules.__props;
            /* eslint-enable no-underscore-dangle */ // Is there any way to put this RouteContextProvider upper in the tree?
            return /*#__PURE__*/ (0,jsx_runtime.jsx)(client_routeContext/* .RouteContextProvider */.W, {
                value: routeContext,
                children: /*#__PURE__*/ (0,jsx_runtime.jsx)(Component, {
                    ...loadedModules,
                    ...routeProps,
                    ...props
                })
            });
        }
    });
}

;// CONCATENATED MODULE: ./.docusaurus/routes.js


/* export default */ const routes = ([
    {
        path: '/es/blog',
        component: ComponentCreator('/es/blog', 'c84'),
        exact: true
    },
    {
        path: '/es/blog/alineando-marketing-y-ventas-para-una-conversion-optima',
        component: ComponentCreator('/es/blog/alineando-marketing-y-ventas-para-una-conversion-optima', 'd5b'),
        exact: true
    },
    {
        path: '/es/blog/archive',
        component: ComponentCreator('/es/blog/archive', 'c1d'),
        exact: true
    },
    {
        path: '/es/blog/authors',
        component: ComponentCreator('/es/blog/authors', 'e39'),
        exact: true
    },
    {
        path: '/es/blog/como-elegir-el-crm-o-software-de-gestion-de-ventas-adecuado-para-su-empresa',
        component: ComponentCreator('/es/blog/como-elegir-el-crm-o-software-de-gestion-de-ventas-adecuado-para-su-empresa', '04d'),
        exact: true
    },
    {
        path: '/es/blog/comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel',
        component: ComponentCreator('/es/blog/comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel', '018'),
        exact: true
    },
    {
        path: '/es/blog/crm-vs-excel-un-analisis-comparativo',
        component: ComponentCreator('/es/blog/crm-vs-excel-un-analisis-comparativo', '843'),
        exact: true
    },
    {
        path: '/es/blog/estrategias-para-atraer-leads-de-alta-calidad',
        component: ComponentCreator('/es/blog/estrategias-para-atraer-leads-de-alta-calidad', '072'),
        exact: true
    },
    {
        path: '/es/blog/estrategias-para-mejorar-las-tasas-de-conversion-en-cada-etapa-del-embudo',
        component: ComponentCreator('/es/blog/estrategias-para-mejorar-las-tasas-de-conversion-en-cada-etapa-del-embudo', '615'),
        exact: true
    },
    {
        path: '/es/blog/indicadores-clave-de-rendimiento-kpi-para-medir-el-exito',
        component: ComponentCreator('/es/blog/indicadores-clave-de-rendimiento-kpi-para-medir-el-exito', '4d9'),
        exact: true
    },
    {
        path: '/es/blog/las-desventajas-de-usar-excel-para-la-nutricion-y-el-seguimiento-de-leads',
        component: ComponentCreator('/es/blog/las-desventajas-de-usar-excel-para-la-nutricion-y-el-seguimiento-de-leads', 'fd2'),
        exact: true
    },
    {
        path: '/es/blog/las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads',
        component: ComponentCreator('/es/blog/las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads', '444'),
        exact: true
    },
    {
        path: '/es/blog/mejora-de-las-tasas-de-conversion-a-traves-del-embudo-de-marketing-y-ventas',
        component: ComponentCreator('/es/blog/mejora-de-las-tasas-de-conversion-a-traves-del-embudo-de-marketing-y-ventas', '440'),
        exact: true
    },
    {
        path: '/es/blog/page/2',
        component: ComponentCreator('/es/blog/page/2', 'e2d'),
        exact: true
    },
    {
        path: '/es/blog/software-crm-popular-en-el-mercado-estadounidense',
        component: ComponentCreator('/es/blog/software-crm-popular-en-el-mercado-estadounidense', '303'),
        exact: true
    },
    {
        path: '/es/blog/tags',
        component: ComponentCreator('/es/blog/tags', 'b1d'),
        exact: true
    },
    {
        path: '/es/blog/tags/como-elegir-crm',
        component: ComponentCreator('/es/blog/tags/como-elegir-crm', '0ca'),
        exact: true
    },
    {
        path: '/es/blog/tags/crm',
        component: ComponentCreator('/es/blog/tags/crm', '897'),
        exact: true
    },
    {
        path: '/es/blog/tags/crm/page/2',
        component: ComponentCreator('/es/blog/tags/crm/page/2', '7d1'),
        exact: true
    },
    {
        path: '/es/blog/tags/embudo-marketing',
        component: ComponentCreator('/es/blog/tags/embudo-marketing', '297'),
        exact: true
    },
    {
        path: '/es/blog/tags/embudo-ventas',
        component: ComponentCreator('/es/blog/tags/embudo-ventas', '38d'),
        exact: true
    },
    {
        path: '/es/blog/tags/excel',
        component: ComponentCreator('/es/blog/tags/excel', 'cb6'),
        exact: true
    },
    {
        path: '/es/blog/tags/excel-vs-crm',
        component: ComponentCreator('/es/blog/tags/excel-vs-crm', '620'),
        exact: true
    },
    {
        path: '/es/blog/tags/leads',
        component: ComponentCreator('/es/blog/tags/leads', '82f'),
        exact: true
    },
    {
        path: '/es/blog/tags/leads-alta-calidad',
        component: ComponentCreator('/es/blog/tags/leads-alta-calidad', '8c8'),
        exact: true
    },
    {
        path: '/es/blog/tags/tasa-de-conversion',
        component: ComponentCreator('/es/blog/tags/tasa-de-conversion', '08c'),
        exact: true
    },
    {
        path: '/es/blog/tags/ventas',
        component: ComponentCreator('/es/blog/tags/ventas', '310'),
        exact: true
    },
    {
        path: '/es/blog/tags/ventas/page/2',
        component: ComponentCreator('/es/blog/tags/ventas/page/2', '488'),
        exact: true
    },
    {
        path: '/es/docs/fintesk-v1',
        component: ComponentCreator('/es/docs/fintesk-v1', '479'),
        exact: true
    },
    {
        path: '/es/markdown-page',
        component: ComponentCreator('/es/markdown-page', '724'),
        exact: true
    },
    {
        path: '/es/',
        component: ComponentCreator('/es/', 'c69'),
        routes: [
            {
                path: '/es/',
                component: ComponentCreator('/es/', 'a81'),
                routes: [
                    {
                        path: '/es/tags',
                        component: ComponentCreator('/es/tags', 'bf6'),
                        exact: true
                    },
                    {
                        path: '/es/tags/account-settings',
                        component: ComponentCreator('/es/tags/account-settings', '164'),
                        exact: true
                    },
                    {
                        path: '/es/tags/activities',
                        component: ComponentCreator('/es/tags/activities', '8a6'),
                        exact: true
                    },
                    {
                        path: '/es/tags/basic-concepts',
                        component: ComponentCreator('/es/tags/basic-concepts', '7fd'),
                        exact: true
                    },
                    {
                        path: '/es/tags/billing',
                        component: ComponentCreator('/es/tags/billing', 'beb'),
                        exact: true
                    },
                    {
                        path: '/es/tags/billing-information',
                        component: ComponentCreator('/es/tags/billing-information', 'a59'),
                        exact: true
                    },
                    {
                        path: '/es/tags/browser',
                        component: ComponentCreator('/es/tags/browser', '71b'),
                        exact: true
                    },
                    {
                        path: '/es/tags/changelog',
                        component: ComponentCreator('/es/tags/changelog', 'a47'),
                        exact: true
                    },
                    {
                        path: '/es/tags/company-settings',
                        component: ComponentCreator('/es/tags/company-settings', 'b37'),
                        exact: true
                    },
                    {
                        path: '/es/tags/contact-support',
                        component: ComponentCreator('/es/tags/contact-support', '52a'),
                        exact: true
                    },
                    {
                        path: '/es/tags/contacts',
                        component: ComponentCreator('/es/tags/contacts', '247'),
                        exact: true
                    },
                    {
                        path: '/es/tags/core-api-concepts',
                        component: ComponentCreator('/es/tags/core-api-concepts', 'dfc'),
                        exact: true
                    },
                    {
                        path: '/es/tags/data-fields',
                        component: ComponentCreator('/es/tags/data-fields', 'ec4'),
                        exact: true
                    },
                    {
                        path: '/es/tags/deals',
                        component: ComponentCreator('/es/tags/deals', '415'),
                        exact: true
                    },
                    {
                        path: '/es/tags/detail-view',
                        component: ComponentCreator('/es/tags/detail-view', '5ab'),
                        exact: true
                    },
                    {
                        path: '/es/tags/developers',
                        component: ComponentCreator('/es/tags/developers', 'e5c'),
                        exact: true
                    },
                    {
                        path: '/es/tags/features',
                        component: ComponentCreator('/es/tags/features', '69f'),
                        exact: true
                    },
                    {
                        path: '/es/tags/filtering',
                        component: ComponentCreator('/es/tags/filtering', '488'),
                        exact: true
                    },
                    {
                        path: '/es/tags/fintesk-api',
                        component: ComponentCreator('/es/tags/fintesk-api', 'd3b'),
                        exact: true
                    },
                    {
                        path: '/es/tags/getting-started',
                        component: ComponentCreator('/es/tags/getting-started', '751'),
                        exact: true
                    },
                    {
                        path: '/es/tags/importing-data',
                        component: ComponentCreator('/es/tags/importing-data', '7f2'),
                        exact: true
                    },
                    {
                        path: '/es/tags/list-view',
                        component: ComponentCreator('/es/tags/list-view', 'd6c'),
                        exact: true
                    },
                    {
                        path: '/es/tags/list-view-reporting',
                        component: ComponentCreator('/es/tags/list-view-reporting', 'ecc'),
                        exact: true
                    },
                    {
                        path: '/es/tags/manage-users',
                        component: ComponentCreator('/es/tags/manage-users', 'a54'),
                        exact: true
                    },
                    {
                        path: '/es/tags/organizing-your-data',
                        component: ComponentCreator('/es/tags/organizing-your-data', 'ffc'),
                        exact: true
                    },
                    {
                        path: '/es/tags/personal-settings',
                        component: ComponentCreator('/es/tags/personal-settings', '3f5'),
                        exact: true
                    },
                    {
                        path: '/es/tags/pipeline-view',
                        component: ComponentCreator('/es/tags/pipeline-view', 'e8c'),
                        exact: true
                    },
                    {
                        path: '/es/tags/pipelines',
                        component: ComponentCreator('/es/tags/pipelines', '9b1'),
                        exact: true
                    },
                    {
                        path: '/es/tags/privacy',
                        component: ComponentCreator('/es/tags/privacy', '92a'),
                        exact: true
                    },
                    {
                        path: '/es/tags/products',
                        component: ComponentCreator('/es/tags/products', '7f3'),
                        exact: true
                    },
                    {
                        path: '/es/tags/progress',
                        component: ComponentCreator('/es/tags/progress', 'c98'),
                        exact: true
                    },
                    {
                        path: '/es/tags/tos',
                        component: ComponentCreator('/es/tags/tos', '556'),
                        exact: true
                    },
                    {
                        path: '/es/tags/troubleshooting',
                        component: ComponentCreator('/es/tags/troubleshooting', '441'),
                        exact: true
                    },
                    {
                        path: '/es/tags/troubleshooting-the-web-app',
                        component: ComponentCreator('/es/tags/troubleshooting-the-web-app', 'a93'),
                        exact: true
                    },
                    {
                        path: '/es/tags/users-and-permissions',
                        component: ComponentCreator('/es/tags/users-and-permissions', 'a9b'),
                        exact: true
                    },
                    {
                        path: '/es/tags/your-fintesk-subscription-plan',
                        component: ComponentCreator('/es/tags/your-fintesk-subscription-plan', 'e83'),
                        exact: true
                    },
                    {
                        path: '/es/',
                        component: ComponentCreator('/es/', '547'),
                        routes: [
                            {
                                path: '/es/billing/billing-information/what-happens-to-my-billing-when-i-add-a-user-in-fintesk',
                                component: ComponentCreator('/es/billing/billing-information/what-happens-to-my-billing-when-i-add-a-user-in-fintesk', '5ec'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/billing/billing-information/what-happens-to-my-billing-when-i-change-my-billing-frequency',
                                component: ComponentCreator('/es/billing/billing-information/what-happens-to-my-billing-when-i-change-my-billing-frequency', '6ec'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/billing/billing-information/what-happens-to-my-billing-when-i-change-my-fintesk-subscription-plan',
                                component: ComponentCreator('/es/billing/billing-information/what-happens-to-my-billing-when-i-change-my-fintesk-subscription-plan', '0af'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/billing/billing-information/what-happens-to-my-billing-when-i-deactivate-a-user-in-fintesk',
                                component: ComponentCreator('/es/billing/billing-information/what-happens-to-my-billing-when-i-deactivate-a-user-in-fintesk', '25f'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/billing/your-fintesk-subscription-plan/how-can-i-switch-to-a-different-fintesk-plan-or-change-my-billing-frequency',
                                component: ComponentCreator('/es/billing/your-fintesk-subscription-plan/how-can-i-switch-to-a-different-fintesk-plan-or-change-my-billing-frequency', '76f'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/billing/your-fintesk-subscription-plan/what-features-do-the-fintesk-plans-have',
                                component: ComponentCreator('/es/billing/your-fintesk-subscription-plan/what-features-do-the-fintesk-plans-have', '3d4'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/activities',
                                component: ComponentCreator('/es/category/activities', '818'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/billing',
                                component: ComponentCreator('/es/category/billing', 'ce5'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/billing-information',
                                component: ComponentCreator('/es/category/billing-information', '0cb'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/company-settings',
                                component: ComponentCreator('/es/category/company-settings', '21e'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/contacts',
                                component: ComponentCreator('/es/category/contacts', '81c'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/core-api-concepts',
                                component: ComponentCreator('/es/category/core-api-concepts', 'a2c'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/data-fields',
                                component: ComponentCreator('/es/category/data-fields', '238'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/deals',
                                component: ComponentCreator('/es/category/deals', '277'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/detail-view',
                                component: ComponentCreator('/es/category/detail-view', 'a34'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/developers',
                                component: ComponentCreator('/es/category/developers', 'd03'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/exporting-data',
                                component: ComponentCreator('/es/category/exporting-data', 'a0b'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/filtering',
                                component: ComponentCreator('/es/category/filtering', '1a1'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/fintesk-api',
                                component: ComponentCreator('/es/category/fintesk-api', '594'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/getting-started',
                                component: ComponentCreator('/es/category/getting-started', '111'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/importing-data',
                                component: ComponentCreator('/es/category/importing-data', 'c88'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/knowledge-base',
                                component: ComponentCreator('/es/category/knowledge-base', '05d'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/list-view',
                                component: ComponentCreator('/es/category/list-view', '25c'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/overview',
                                component: ComponentCreator('/es/category/overview', 'c8b'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/personal-settings',
                                component: ComponentCreator('/es/category/personal-settings', '808'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/pipeline-view',
                                component: ComponentCreator('/es/category/pipeline-view', '428'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/pipelines',
                                component: ComponentCreator('/es/category/pipelines', 'b3f'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/privacy',
                                component: ComponentCreator('/es/category/privacy', '748'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/products',
                                component: ComponentCreator('/es/category/products', '3cf'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/terms-of-service',
                                component: ComponentCreator('/es/category/terms-of-service', '4f2'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/troubleshooting',
                                component: ComponentCreator('/es/category/troubleshooting', '417'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/users-and-permissions',
                                component: ComponentCreator('/es/category/users-and-permissions', '598'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/category/your-fintesk-subscription-plan',
                                component: ComponentCreator('/es/category/your-fintesk-subscription-plan', '9de'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/developers/core-api-concepts/changes-to-the-api',
                                component: ComponentCreator('/es/developers/core-api-concepts/changes-to-the-api', '0e4'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/developers/core-api-concepts/core-api-concepts-about-fintesk-api',
                                component: ComponentCreator('/es/developers/core-api-concepts/core-api-concepts-about-fintesk-api', 'c9b'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/developers/core-api-concepts/core-api-concepts-custom-fields',
                                component: ComponentCreator('/es/developers/core-api-concepts/core-api-concepts-custom-fields', 'ea4'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/developers/core-api-concepts/core-api-concepts-date-format',
                                component: ComponentCreator('/es/developers/core-api-concepts/core-api-concepts-date-format', '9b2'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/developers/core-api-concepts/core-api-concepts-http-status-codes',
                                component: ComponentCreator('/es/developers/core-api-concepts/core-api-concepts-http-status-codes', '634'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/developers/core-api-concepts/core-api-concepts-pagination',
                                component: ComponentCreator('/es/developers/core-api-concepts/core-api-concepts-pagination', '43b'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/developers/core-api-concepts/core-api-concepts-requests',
                                component: ComponentCreator('/es/developers/core-api-concepts/core-api-concepts-requests', '1c6'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/developers/overview/getting-started',
                                component: ComponentCreator('/es/developers/overview/getting-started', '95b'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/fintesk/api-v1',
                                component: ComponentCreator('/es/fintesk/api-v1', 'f8c'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/fintesk/changelog',
                                component: ComponentCreator('/es/fintesk/changelog', 'b8a'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/activities',
                                component: ComponentCreator('/es/kb/activities', '06c'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/activities/activity-marked-as-done-logic',
                                component: ComponentCreator('/es/kb/activities/activity-marked-as-done-logic', 'fa4'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/activities/creating-custom-activity-types',
                                component: ComponentCreator('/es/kb/activities/creating-custom-activity-types', '34d'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/activities/how-can-i-create-activities-in-bulk',
                                component: ComponentCreator('/es/kb/activities/how-can-i-create-activities-in-bulk', '85a'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/activities/how-can-i-filter-my-activities-in-the-list-view',
                                component: ComponentCreator('/es/kb/activities/how-can-i-filter-my-activities-in-the-list-view', '6c8'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/activities/how-can-i-link-my-activities-with-multiple-contact-persons',
                                component: ComponentCreator('/es/kb/activities/how-can-i-link-my-activities-with-multiple-contact-persons', 'd9c'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/activities/how-can-i-see-done-activities',
                                component: ComponentCreator('/es/kb/activities/how-can-i-see-done-activities', 'd1a'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/company-settings/how-can-i-create-a-custom-currency',
                                component: ComponentCreator('/es/kb/company-settings/how-can-i-create-a-custom-currency', '13f'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/company-settings/how-can-i-enable-predefined-lost-reasons',
                                component: ComponentCreator('/es/kb/company-settings/how-can-i-enable-predefined-lost-reasons', 'e2f'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/company-settings/lost-reasons',
                                component: ComponentCreator('/es/kb/company-settings/lost-reasons', '30c'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/contacts/contact-detail-view',
                                component: ComponentCreator('/es/kb/contacts/contact-detail-view', '26e'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/contacts/contacts-persons-and-organizations',
                                component: ComponentCreator('/es/kb/contacts/contacts-persons-and-organizations', 'dfc'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/contacts/how-can-i-add-related-persons-or-organizations-to-a-deal',
                                component: ComponentCreator('/es/kb/contacts/how-can-i-add-related-persons-or-organizations-to-a-deal', 'eb3'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/contacts/linking-persons-and-organizations',
                                component: ComponentCreator('/es/kb/contacts/linking-persons-and-organizations', '847'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/data-fields/custom-fields',
                                component: ComponentCreator('/es/kb/data-fields/custom-fields', '531'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/data-fields/data-fields-in-fintesk',
                                component: ComponentCreator('/es/kb/data-fields/data-fields-in-fintesk', 'eeb'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/data-fields/how-can-i-add-data-fields-to-an-add-deal-contact-or-product-modal',
                                component: ComponentCreator('/es/kb/data-fields/how-can-i-add-data-fields-to-an-add-deal-contact-or-product-modal', '96a'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/data-fields/what-types-of-custom-fields-are-there',
                                component: ComponentCreator('/es/kb/data-fields/what-types-of-custom-fields-are-there', '231'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/deals/adding-deals-in-bulk',
                                component: ComponentCreator('/es/kb/deals/adding-deals-in-bulk', 'cb5'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/deals/deals-what-they-are-and-how-to-add-them',
                                component: ComponentCreator('/es/kb/deals/deals-what-they-are-and-how-to-add-them', '1ba'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/deals/editing-the-contact-linked-to-a-deal',
                                component: ComponentCreator('/es/kb/deals/editing-the-contact-linked-to-a-deal', 'db0'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/deals/filtering-for-my-won-lost-or-deleted-deals',
                                component: ComponentCreator('/es/kb/deals/filtering-for-my-won-lost-or-deleted-deals', '7cb'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/deals/how-can-i-move-a-deal-to-another-pipeline',
                                component: ComponentCreator('/es/kb/deals/how-can-i-move-a-deal-to-another-pipeline', 'f5b'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/deals/how-can-i-restore-deleted-deals',
                                component: ComponentCreator('/es/kb/deals/how-can-i-restore-deleted-deals', 'c42'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/detail-view',
                                component: ComponentCreator('/es/kb/detail-view', '998'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/detail-view/deal-detail-view',
                                component: ComponentCreator('/es/kb/detail-view/deal-detail-view', '658'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/detail-view/how-can-i-add-notes-to-a-deal-or-contact',
                                component: ComponentCreator('/es/kb/detail-view/how-can-i-add-notes-to-a-deal-or-contact', '32e'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/detail-view/updating-items-in-the-detail-view',
                                component: ComponentCreator('/es/kb/detail-view/updating-items-in-the-detail-view', '7a3'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/exporting-data/exporting-data-from-fintesk',
                                component: ComponentCreator('/es/kb/exporting-data/exporting-data-from-fintesk', 'bf0'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/filtering',
                                component: ComponentCreator('/es/kb/filtering', 'bcf'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/filtering/filters-common-uses',
                                component: ComponentCreator('/es/kb/filtering/filters-common-uses', 'db5'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/getting-started/fintesk-glossary',
                                component: ComponentCreator('/es/kb/getting-started/fintesk-glossary', 'cee'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/getting-started/fintesk-user-vs-company-account',
                                component: ComponentCreator('/es/kb/getting-started/fintesk-user-vs-company-account', 'caf'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/getting-started/how-can-i-delete-items-in-fintesk',
                                component: ComponentCreator('/es/kb/getting-started/how-can-i-delete-items-in-fintesk', '46e'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/getting-started/interface-in-fintesk',
                                component: ComponentCreator('/es/kb/getting-started/interface-in-fintesk', '1e6'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/getting-started/organization-vs-company-account',
                                component: ComponentCreator('/es/kb/getting-started/organization-vs-company-account', 'd1d'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/getting-started/search-finding-what-you-need',
                                component: ComponentCreator('/es/kb/getting-started/search-finding-what-you-need', '9ce'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/getting-started/what-is-the-difference-between-a-user-and-a-seat',
                                component: ComponentCreator('/es/kb/getting-started/what-is-the-difference-between-a-user-and-a-seat', 'a1e'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/importing-data/changing-the-field-type-of-a-custom-field',
                                component: ComponentCreator('/es/kb/importing-data/changing-the-field-type-of-a-custom-field', '15f'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/importing-data/how-can-i-format-dates-to-import-into-fintesk',
                                component: ComponentCreator('/es/kb/importing-data/how-can-i-format-dates-to-import-into-fintesk', '027'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/importing-data/import-fields',
                                component: ComponentCreator('/es/kb/importing-data/import-fields', '1d6'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/importing-data/importing-advanced-mapping',
                                component: ComponentCreator('/es/kb/importing-data/importing-advanced-mapping', 'a82'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/importing-data/importing-data-into-fintesk-with-spreadsheets',
                                component: ComponentCreator('/es/kb/importing-data/importing-data-into-fintesk-with-spreadsheets', 'fb8'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/importing-data/importing-mandatory-fields',
                                component: ComponentCreator('/es/kb/importing-data/importing-mandatory-fields', 'fbd'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/importing-data/importing-mapping-your-fields',
                                component: ComponentCreator('/es/kb/importing-data/importing-mapping-your-fields', '818'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/importing-data/importing-sample-import-spreadsheets',
                                component: ComponentCreator('/es/kb/importing-data/importing-sample-import-spreadsheets', 'f13'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/importing-data/transferring-data-to-a-different-fintesk-company-account',
                                component: ComponentCreator('/es/kb/importing-data/transferring-data-to-a-different-fintesk-company-account', '8c6'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/importing-data/updating-fintesk-data-with-a-spreadsheet',
                                component: ComponentCreator('/es/kb/importing-data/updating-fintesk-data-with-a-spreadsheet', 'e3e'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/importing-data/why-do-my-imported-currency-values-appear-as-0',
                                component: ComponentCreator('/es/kb/importing-data/why-do-my-imported-currency-values-appear-as-0', 'cb5'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/list-view',
                                component: ComponentCreator('/es/kb/list-view', '324'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/list-view/customizing-the-columns-in-the-list-view',
                                component: ComponentCreator('/es/kb/list-view/customizing-the-columns-in-the-list-view', 'b67'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/list-view/fintesk-system-ids',
                                component: ComponentCreator('/es/kb/list-view/fintesk-system-ids', 'bdd'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/list-view/how-can-i-add-or-remove-columns-in-the-list-view',
                                component: ComponentCreator('/es/kb/list-view/how-can-i-add-or-remove-columns-in-the-list-view', 'a65'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/list-view/how-can-i-edit-a-field-in-the-list-view',
                                component: ComponentCreator('/es/kb/list-view/how-can-i-edit-a-field-in-the-list-view', '297'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/list-view/how-can-i-set-default-columns-for-all-my-users-in-the-list-view',
                                component: ComponentCreator('/es/kb/list-view/how-can-i-set-default-columns-for-all-my-users-in-the-list-view', 'f13'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/personal-settings/fintesk-settings',
                                component: ComponentCreator('/es/kb/personal-settings/fintesk-settings', 'e58'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/personal-settings/how-can-i-change-or-reset-my-password',
                                component: ComponentCreator('/es/kb/personal-settings/how-can-i-change-or-reset-my-password', '9fc'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/personal-settings/how-can-i-free-up-space',
                                component: ComponentCreator('/es/kb/personal-settings/how-can-i-free-up-space', '556'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/personal-settings/usage-limits-in-fintesk',
                                component: ComponentCreator('/es/kb/personal-settings/usage-limits-in-fintesk', '81b'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/pipeline-view',
                                component: ComponentCreator('/es/kb/pipeline-view', 'abe'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/pipeline-view/how-can-i-delete-a-deal-in-the-pipeline-view',
                                component: ComponentCreator('/es/kb/pipeline-view/how-can-i-delete-a-deal-in-the-pipeline-view', 'e3e'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/pipeline-view/how-can-i-see-deals-in-a-different-pipeline',
                                component: ComponentCreator('/es/kb/pipeline-view/how-can-i-see-deals-in-a-different-pipeline', '6bb'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/pipeline-view/the-rotting-feature',
                                component: ComponentCreator('/es/kb/pipeline-view/the-rotting-feature', '2e9'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/pipelines/how-can-i-add-a-stage-to-my-pipeline',
                                component: ComponentCreator('/es/kb/pipelines/how-can-i-add-a-stage-to-my-pipeline', '6bf'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/pipelines/how-can-i-customize-my-pipeline-stages',
                                component: ComponentCreator('/es/kb/pipelines/how-can-i-customize-my-pipeline-stages', 'd30'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/pipelines/how-can-i-have-multiple-pipelines',
                                component: ComponentCreator('/es/kb/pipelines/how-can-i-have-multiple-pipelines', 'd47'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/products',
                                component: ComponentCreator('/es/kb/products', 'd71'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/products/can-i-add-extra-fields-to-the-add-new-product-modal',
                                component: ComponentCreator('/es/kb/products/can-i-add-extra-fields-to-the-add-new-product-modal', 'e57'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/products/can-i-have-one-product-in-different-price-variations',
                                component: ComponentCreator('/es/kb/products/can-i-have-one-product-in-different-price-variations', '0e2'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/products/can-i-import-products-and-automatically-link-them-to-deals',
                                component: ComponentCreator('/es/kb/products/can-i-import-products-and-automatically-link-them-to-deals', '179'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/products/how-can-i-link-products-to-a-deal',
                                component: ComponentCreator('/es/kb/products/how-can-i-link-products-to-a-deal', 'd65'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/products/where-do-i-activate-or-deactivate-individual-products',
                                component: ComponentCreator('/es/kb/products/where-do-i-activate-or-deactivate-individual-products', '83e'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/troubleshooting/can-fintesk-be-used-offline',
                                component: ComponentCreator('/es/kb/troubleshooting/can-fintesk-be-used-offline', '0e4'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/troubleshooting/how-can-i-take-a-screenshot',
                                component: ComponentCreator('/es/kb/troubleshooting/how-can-i-take-a-screenshot', 'dbf'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/troubleshooting/how-do-i-clear-my-browser-s-cache-and-cookies',
                                component: ComponentCreator('/es/kb/troubleshooting/how-do-i-clear-my-browser-s-cache-and-cookies', '5af'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/troubleshooting/how-do-i-open-my-browser-console',
                                component: ComponentCreator('/es/kb/troubleshooting/how-do-i-open-my-browser-console', 'f1c'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/troubleshooting/troubleshooting-fintesk-web-app',
                                component: ComponentCreator('/es/kb/troubleshooting/troubleshooting-fintesk-web-app', '265'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/troubleshooting/which-browser-is-best-for-fintesk',
                                component: ComponentCreator('/es/kb/troubleshooting/which-browser-is-best-for-fintesk', 'e99'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/users-and-permissions/global-user-management',
                                component: ComponentCreator('/es/kb/users-and-permissions/global-user-management', '9fb'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/users-and-permissions/how-can-i-add-a-user',
                                component: ComponentCreator('/es/kb/users-and-permissions/how-can-i-add-a-user', '8f6'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user',
                                component: ComponentCreator('/es/kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user', '619'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/users-and-permissions/how-can-i-replace-users-in-my-fintesk-company-account',
                                component: ComponentCreator('/es/kb/users-and-permissions/how-can-i-replace-users-in-my-fintesk-company-account', '67a'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/users-and-permissions/updating-user-information',
                                component: ComponentCreator('/es/kb/users-and-permissions/updating-user-information', 'ca7'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/users-and-permissions/users',
                                component: ComponentCreator('/es/kb/users-and-permissions/users', 'f34'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/users-and-permissions/what-is-a-regular-user',
                                component: ComponentCreator('/es/kb/users-and-permissions/what-is-a-regular-user', 'e9e'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/kb/users-and-permissions/who-is-the-admin-user-of-my-account',
                                component: ComponentCreator('/es/kb/users-and-permissions/who-is-the-admin-user-of-my-account', '4fd'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/privacy',
                                component: ComponentCreator('/es/privacy', '5b2'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/privacy/dpa',
                                component: ComponentCreator('/es/privacy/dpa', '1fb'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/privacy/fintesk-data-sub-processors',
                                component: ComponentCreator('/es/privacy/fintesk-data-sub-processors', '810'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/tos/terms-of-service',
                                component: ComponentCreator('/es/tos/terms-of-service', 'ead'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            },
                            {
                                path: '/es/',
                                component: ComponentCreator('/es/', 'c45'),
                                exact: true,
                                sidebar: "tutorialSidebar"
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        path: '*',
        component: ComponentCreator('*')
    }
]);


}),
91173: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  o: () => (Context),
  x: () => (BrowserContextProvider)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

// Encapsulate the logic to avoid React hydration problems
// See https://www.joshwcomeau.com/react/the-perils-of-rehydration/
// On first client-side render, we need to render exactly as the server rendered
// isBrowser is set to true only after a successful hydration
// Note, isBrowser is not part of useDocusaurusContext() for perf reasons
// Using useDocusaurusContext() (much more common need) should not trigger
// re-rendering after a successful hydration
const Context = /*#__PURE__*/ react__rspack_import_1.createContext(false);
function BrowserContextProvider({ children }) {
    const [isBrowser, setIsBrowser] = (0,react__rspack_import_1.useState)(false);
    (0,react__rspack_import_1.useEffect)(()=>{
        setIsBrowser(true);
    }, []);
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(Context.Provider, {
        value: isBrowser,
        children: children
    });
}


}),
10354: (function (__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) {
"use strict";

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(74848);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/react-dom/client.js
var client = __webpack_require__(5338);
// EXTERNAL MODULE: ./node_modules/react-helmet-async/lib/index.module.js
var index_module = __webpack_require__(80545);
// EXTERNAL MODULE: ./node_modules/react-router-dom/esm/react-router-dom.js
var react_router_dom = __webpack_require__(54625);
// EXTERNAL MODULE: ./.docusaurus/docusaurus.config.mjs
var docusaurus_config = __webpack_require__(4784);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/ExecutionEnvironment.js
var ExecutionEnvironment = __webpack_require__(91289);
;// CONCATENATED MODULE: ./.docusaurus/client-modules.js
/* export default */ const client_modules = ([
    __webpack_require__(77612),
    __webpack_require__(56464),
    __webpack_require__(32489),
    __webpack_require__(33678),
    __webpack_require__(16448),
    __webpack_require__(87570),
    __webpack_require__(70630),
    __webpack_require__(56814)
]);

// EXTERNAL MODULE: ./.docusaurus/routes.js + 3 modules
var routes = __webpack_require__(58460);
// EXTERNAL MODULE: ./node_modules/react-router/esm/react-router.js
var react_router = __webpack_require__(56347);
// EXTERNAL MODULE: ./node_modules/react-router-config/esm/react-router-config.js
var react_router_config = __webpack_require__(22831);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/theme-fallback/Root/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

// Wrapper at the very top of the app, that is applied constantly
// and does not depend on current route (unlike the layout)
//
// Gives the opportunity to add stateful providers on top of the app
// and these providers won't reset state when we navigate
//
// See https://github.com/facebook/docusaurus/issues/3919
function Root({ children }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
        children: children
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/titleFormatterUtils.js
var titleFormatterUtils = __webpack_require__(3899);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/ThemeProvider/TitleFormatter/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


const formatter = (params)=>{
    // Add your own title formatting logic here!
    return params.defaultFormatter(params);
};
function ThemeProviderTitleFormatter({ children }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(titleFormatterUtils/* .TitleFormatterProvider */.AL, {
        formatter: formatter,
        children: children
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/ThemeProvider/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


function ThemeProvider({ children }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(ThemeProviderTitleFormatter, {
        children: children
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/Head.js
var Head = __webpack_require__(53572);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/useDocusaurusContext.js
var useDocusaurusContext = __webpack_require__(10898);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/useBaseUrl.js
var useBaseUrl = __webpack_require__(66497);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/useThemeConfig.js
var useThemeConfig = __webpack_require__(61022);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/metadataUtils.js
var metadataUtils = __webpack_require__(34308);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/useAlternatePageUtils.js
var useAlternatePageUtils = __webpack_require__(5243);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/hooks/useKeyboardNavigation.js + 1 modules
var useKeyboardNavigation = __webpack_require__(23433);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/searchUtils.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ const DEFAULT_SEARCH_TAG = 'default'; //# sourceMappingURL=searchUtils.js.map

// EXTERNAL MODULE: ./node_modules/@docusaurus/utils-common/lib/index.js
var lib = __webpack_require__(5248);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/SearchMetadata/index.js
var SearchMetadata = __webpack_require__(54175);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/SiteMetadata/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 









// TODO move to SiteMetadataDefaults or theme-common ?
// Useful for i18n/SEO
// See https://developers.google.com/search/docs/advanced/crawling/localized-versions
// See https://github.com/facebook/docusaurus/issues/3317
function AlternateLangHeaders() {
    const { i18n: { currentLocale, defaultLocale, localeConfigs } } = (0,useDocusaurusContext/* ["default"] */.A)();
    const alternatePageUtils = (0,useAlternatePageUtils/* .useAlternatePageUtils */.o)();
    const currentHtmlLang = localeConfigs[currentLocale].htmlLang;
    // HTML lang is a BCP 47 tag, but the Open Graph protocol requires
    // using underscores instead of dashes.
    // See https://ogp.me/#optional
    // See https://en.wikipedia.org/wiki/IETF_language_tag)
    const bcp47ToOpenGraphLocale = (code)=>code.replace('-', '_');
    // Note: it is fine to use both "x-default" and "en" to target the same url
    // See https://www.searchviu.com/en/multiple-hreflang-tags-one-url/
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)(Head/* ["default"] */.A, {
        children: [
            Object.entries(localeConfigs).map(([locale, { htmlLang }])=>/*#__PURE__*/ (0,jsx_runtime.jsx)("link", {
                    rel: "alternate",
                    href: alternatePageUtils.createUrl({
                        locale,
                        fullyQualified: true
                    }),
                    hrefLang: htmlLang
                }, locale)),
            /*#__PURE__*/ (0,jsx_runtime.jsx)("link", {
                rel: "alternate",
                href: alternatePageUtils.createUrl({
                    locale: defaultLocale,
                    fullyQualified: true
                }),
                hrefLang: "x-default"
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)("meta", {
                property: "og:locale",
                content: bcp47ToOpenGraphLocale(currentHtmlLang)
            }),
            Object.values(localeConfigs).filter((config)=>currentHtmlLang !== config.htmlLang).map((config)=>/*#__PURE__*/ (0,jsx_runtime.jsx)("meta", {
                    property: "og:locale:alternate",
                    content: bcp47ToOpenGraphLocale(config.htmlLang)
                }, `meta-og-${config.htmlLang}`))
        ]
    });
}
// Default canonical url inferred from current page location pathname
function useDefaultCanonicalUrl() {
    const { siteConfig: { url: siteUrl, baseUrl, trailingSlash } } = (0,useDocusaurusContext/* ["default"] */.A)();
    // TODO using useLocation().pathname is not a super idea
    // See https://github.com/facebook/docusaurus/issues/9170
    const { pathname } = (0,react_router/* .useLocation */.zy)();
    const canonicalPathname = (0,lib.applyTrailingSlash)((0,useBaseUrl/* ["default"] */.Ay)(pathname), {
        trailingSlash,
        baseUrl
    });
    return siteUrl + canonicalPathname;
}
// TODO move to SiteMetadataDefaults or theme-common ?
function CanonicalUrlHeaders({ permalink }) {
    const { siteConfig: { url: siteUrl } } = (0,useDocusaurusContext/* ["default"] */.A)();
    const defaultCanonicalUrl = useDefaultCanonicalUrl();
    const canonicalUrl = permalink ? `${siteUrl}${permalink}` : defaultCanonicalUrl;
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)(Head/* ["default"] */.A, {
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsx)("meta", {
                property: "og:url",
                content: canonicalUrl
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)("link", {
                rel: "canonical",
                href: canonicalUrl
            })
        ]
    });
}
function SiteMetadata() {
    const { i18n: { currentLocale } } = (0,useDocusaurusContext/* ["default"] */.A)();
    // TODO maybe move these 2 themeConfig to siteConfig?
    // These seems useful for other themes as well
    const { metadata, image: defaultImage } = (0,useThemeConfig/* .useThemeConfig */.p)();
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsxs)(Head/* ["default"] */.A, {
                children: [
                    /*#__PURE__*/ (0,jsx_runtime.jsx)("meta", {
                        name: "twitter:card",
                        content: "summary_large_image"
                    }),
                    /*#__PURE__*/ (0,jsx_runtime.jsx)("body", {
                        className: useKeyboardNavigation/* .keyboardFocusedClassName */.w
                    })
                ]
            }),
            defaultImage && /*#__PURE__*/ (0,jsx_runtime.jsx)(metadataUtils/* .PageMetadata */.be, {
                image: defaultImage
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(CanonicalUrlHeaders, {}),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(AlternateLangHeaders, {}),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(SearchMetadata/* ["default"] */.A, {
                tag: DEFAULT_SEARCH_TAG,
                locale: currentLocale
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(Head/* ["default"] */.A, {
                children: metadata.map((metadatum, i)=>/*#__PURE__*/ (0,jsx_runtime.jsx)("meta", {
                        ...metadatum
                    }, i))
            })
        ]
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/normalizeLocation.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

// Memoize previously normalized pathnames.
const pathnames = new Map();
function normalizeLocation(location) {
    if (pathnames.has(location.pathname)) {
        return {
            ...location,
            pathname: pathnames.get(location.pathname)
        };
    }
    // If the location was registered with an `.html` extension, we don't strip it
    // away, or it will render to a 404 page.
    const matchedRoutes = (0,react_router_config/* .matchRoutes */.u)(routes/* ["default"] */.A, location.pathname);
    if (matchedRoutes.some(({ route })=>route.exact === true)) {
        pathnames.set(location.pathname, location.pathname);
        return location;
    }
    const pathname = location.pathname.trim().replace(/(?:\/index)?\.html$/, '') || '/';
    pathnames.set(location.pathname, pathname);
    return {
        ...location,
        pathname
    };
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/browserContext.js
var browserContext = __webpack_require__(91173);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/docusaurusContext.js + 3 modules
var docusaurusContext = __webpack_require__(93587);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/useIsomorphicLayoutEffect.js
var useIsomorphicLayoutEffect = __webpack_require__(99989);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/ClientLifecyclesDispatcher.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

function dispatchLifecycleAction(lifecycleAction, ...args) {
    const callbacks = client_modules.map((clientModule)=>{
        const lifecycleFunction = clientModule.default?.[lifecycleAction] ?? clientModule[lifecycleAction];
        return lifecycleFunction?.(...args);
    });
    return ()=>callbacks.forEach((cb)=>cb?.());
}
function scrollAfterNavigation({ location, previousLocation }) {
    if (!previousLocation) {
        return; // no-op: use native browser feature
    }
    const samePathname = location.pathname === previousLocation.pathname;
    const sameHash = location.hash === previousLocation.hash;
    const sameSearch = location.search === previousLocation.search;
    // Query-string changes: do not scroll to top/hash
    if (samePathname && sameHash && !sameSearch) {
        return;
    }
    const { hash } = location;
    if (!hash) {
        window.scrollTo(0, 0);
    } else {
        const id = decodeURIComponent(hash.substring(1));
        const element = document.getElementById(id);
        element?.scrollIntoView();
    }
}
function ClientLifecyclesDispatcher({ children, location, previousLocation }) {
    (0,useIsomorphicLayoutEffect/* ["default"] */.A)(()=>{
        if (previousLocation !== location) {
            scrollAfterNavigation({
                location,
                previousLocation
            });
            dispatchLifecycleAction('onRouteDidUpdate', {
                previousLocation,
                location
            });
        }
    }, [
        previousLocation,
        location
    ]);
    return children;
}
/* export default */ const client_ClientLifecyclesDispatcher = (ClientLifecyclesDispatcher);

;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/preload.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

/**
 * Helper function to make sure all async components for that particular route
 * is preloaded before rendering. This is especially useful to avoid loading
 * screens.
 *
 * @param pathname the route pathname, example: /docs/installation
 * @returns Promise object represents whether pathname has been preloaded
 */ function preload(pathname) {
    const matches = Array.from(new Set([
        pathname,
        decodeURI(pathname)
    ])).map((p)=>(0,react_router_config/* .matchRoutes */.u)(routes/* ["default"] */.A, p)).flat();
    return Promise.all(matches.map((match)=>match.route.component.preload?.()));
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/PendingNavigation.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 





class PendingNavigation extends react.Component {
    previousLocation;
    routeUpdateCleanupCb;
    constructor(props){
        super(props);
        // previousLocation doesn't affect rendering, hence not stored in state.
        this.previousLocation = null;
        this.routeUpdateCleanupCb = ExecutionEnvironment["default"].canUseDOM ? dispatchLifecycleAction('onRouteUpdate', {
            previousLocation: null,
            location: this.props.location
        }) : ()=>{};
        this.state = {
            nextRouteHasLoaded: true
        };
    }
    // Intercept location update and still show current route until next route
    // is done loading.
    shouldComponentUpdate(nextProps, nextState) {
        if (nextProps.location === this.props.location) {
            // `nextRouteHasLoaded` is false means there's a pending route transition.
            // Don't update until it's done.
            return nextState.nextRouteHasLoaded;
        }
        // props.location being different means the router is trying to navigate to
        // a new route. We will preload the new route.
        const nextLocation = nextProps.location;
        // Save the location first.
        this.previousLocation = this.props.location;
        this.setState({
            nextRouteHasLoaded: false
        });
        this.routeUpdateCleanupCb = dispatchLifecycleAction('onRouteUpdate', {
            previousLocation: this.previousLocation,
            location: nextLocation
        });
        // Load data while the old screen remains. Force preload instead of using
        // `window.docusaurus`, because we want to avoid loading screen even when
        // user is on saveData
        preload(nextLocation.pathname).then(()=>{
            this.routeUpdateCleanupCb();
            this.setState({
                nextRouteHasLoaded: true
            });
        }).catch((e)=>{
            console.warn(e);
            // If chunk loading failed, it could be because the path to a chunk
            // no longer exists due to a new deployment. Force refresh the page
            // instead of just not navigating.
            window.location.reload();
        });
        return false;
    }
    render() {
        const { children, location } = this.props;
        // Use a controlled <Route> to trick all descendants into rendering the old
        // location.
        return /*#__PURE__*/ (0,jsx_runtime.jsx)(client_ClientLifecyclesDispatcher, {
            previousLocation: this.previousLocation,
            location: location,
            children: /*#__PURE__*/ (0,jsx_runtime.jsx)(react_router/* .Route */.qh, {
                location: location,
                render: ()=>children
            })
        });
    }
}
/* export default */ const client_PendingNavigation = (PendingNavigation);

;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/BaseUrlIssueBanner/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 





// Double-security: critical CSS will hide the banner if CSS can load!

// __ prefix allows search crawlers (Algolia/DocSearch) to ignore anchors
// https://github.com/facebook/docusaurus/issues/8883#issuecomment-1516328368
const BannerContainerId = '__docusaurus-base-url-issue-banner-container';
const BannerId = '__docusaurus-base-url-issue-banner';
const SuggestionContainerId = '__docusaurus-base-url-issue-banner-suggestion-container';
// It is important to not use React to render this banner
// otherwise Google would index it, even if it's hidden with some critical CSS!
// See https://github.com/facebook/docusaurus/issues/4028
// - We can't SSR (or it would be indexed)
// - We can't CSR (as it means the baseurl is correct)
function createInlineHtmlBanner(baseUrl) {
    return `
<div id="${BannerId}" style="border: thick solid red; background-color: rgb(255, 230, 179); margin: 20px; padding: 20px; font-size: 20px;">
   <p style="font-weight: bold; font-size: 30px;">Your Docusaurus site did not load properly.</p>
   <p>A very common reason is a wrong site <a href="https://docusaurus.io/docs/docusaurus.config.js/#baseUrl" style="font-weight: bold;">baseUrl configuration</a>.</p>
   <p>Current configured baseUrl = <span style="font-weight: bold; color: red;">${baseUrl}</span> ${baseUrl === '/' ? ' (default value)' : ''}</p>
   <p>We suggest trying baseUrl = <span id="${SuggestionContainerId}" style="font-weight: bold; color: green;"></span></p>
</div>
`;
}
// Needs to work for older browsers!
function createInlineScript(baseUrl) {
    /* language=js */ return `
document.addEventListener('DOMContentLoaded', function maybeInsertBanner() {
  var shouldInsert = typeof window['docusaurus'] === 'undefined';
  shouldInsert && insertBanner();
});

function insertBanner() {
  var bannerContainer = document.createElement('div');
  bannerContainer.id = '${BannerContainerId}';
  var bannerHtml = ${JSON.stringify(createInlineHtmlBanner(baseUrl))// See https://redux.js.org/recipes/server-rendering/#security-considerations
    .replace(/</g, '\\\u003c')};
  bannerContainer.innerHTML = bannerHtml;
  document.body.prepend(bannerContainer);
  var suggestionContainer = document.getElementById('${SuggestionContainerId}');
  var actualHomePagePath = window.location.pathname;
  var suggestedBaseUrl = actualHomePagePath.substr(-1) === '/'
        ? actualHomePagePath
        : actualHomePagePath + '/';
  suggestionContainer.innerHTML = suggestedBaseUrl;
}
`;
}
function BaseUrlIssueBanner() {
    const { siteConfig: { baseUrl } } = (0,useDocusaurusContext/* ["default"] */.A)();
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
        children: !ExecutionEnvironment["default"].canUseDOM && // Safe to use `ExecutionEnvironment`, because `Head` is purely
        // side-effect and doesn't affect hydration
        /*#__PURE__*/ (0,jsx_runtime.jsx)(Head/* ["default"] */.A, {
            children: /*#__PURE__*/ (0,jsx_runtime.jsx)("script", {
                children: createInlineScript(baseUrl)
            })
        })
    });
}
/**
 * We want to help the users with a bad baseUrl configuration (very common
 * error). Help message is inlined, and hidden if JS or CSS is able to load.
 *
 * This component only inserts the base URL banner for the homepage, to avoid
 * polluting every statically rendered page.
 *
 * Note: it might create false positives (ie network failures): not a big deal
 *
 * @see https://github.com/facebook/docusaurus/pull/3621
 */ function MaybeBaseUrlIssueBanner() {
    const { siteConfig: { baseUrl, baseUrlIssueBanner } } = (0,useDocusaurusContext/* ["default"] */.A)();
    const { pathname } = (0,react_router/* .useLocation */.zy)();
    const isHomePage = pathname === baseUrl;
    const enabled = baseUrlIssueBanner && isHomePage;
    return enabled ? /*#__PURE__*/ (0,jsx_runtime.jsx)(BaseUrlIssueBanner, {}) : null;
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/SiteMetadataDefaults.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




function SiteMetadataDefaults() {
    const { siteConfig: { favicon, title, noIndex }, i18n: { currentLocale, localeConfigs } } = (0,useDocusaurusContext/* ["default"] */.A)();
    const faviconUrl = (0,useBaseUrl/* ["default"] */.Ay)(favicon);
    const { htmlLang, direction: htmlDir } = localeConfigs[currentLocale];
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)(Head/* ["default"] */.A, {
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsx)("html", {
                lang: htmlLang,
                dir: htmlDir
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)("title", {
                children: title
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)("meta", {
                property: "og:title",
                content: title
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)("meta", {
                name: "viewport",
                content: "width=device-width, initial-scale=1.0"
            }),
            noIndex && /*#__PURE__*/ (0,jsx_runtime.jsx)("meta", {
                name: "robots",
                content: "noindex, nofollow"
            }),
            favicon && /*#__PURE__*/ (0,jsx_runtime.jsx)("link", {
                rel: "icon",
                href: faviconUrl
            })
        ]
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/ErrorBoundary.js + 1 modules
var ErrorBoundary = __webpack_require__(11701);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/useIsBrowser.js
var useIsBrowser = __webpack_require__(19863);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/hasHydratedDataAttribute.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



// See https://github.com/facebook/docusaurus/pull/9256
// Docusaurus adds a <html data-has-hydrated="true"> after hydration
function HasHydratedDataAttribute() {
    const isBrowser = (0,useIsBrowser/* ["default"] */.A)();
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(Head/* ["default"] */.A, {
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)("html", {
            "data-has-hydrated": isBrowser
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/App.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 














// TODO, quick fix for CSS insertion order
// eslint-disable-next-line import/order


const routesElement = (0,react_router_config/* .renderRoutes */.v)(routes/* ["default"] */.A);
function AppNavigation() {
    const location = (0,react_router/* .useLocation */.zy)();
    const normalizedLocation = normalizeLocation(location);
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(client_PendingNavigation, {
        location: normalizedLocation,
        children: routesElement
    });
}
function App() {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(ErrorBoundary/* ["default"] */.A, {
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(docusaurusContext/* .DocusaurusContextProvider */.l, {
            children: /*#__PURE__*/ (0,jsx_runtime.jsxs)(browserContext/* .BrowserContextProvider */.x, {
                children: [
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(Root, {
                        children: /*#__PURE__*/ (0,jsx_runtime.jsxs)(ThemeProvider, {
                            children: [
                                /*#__PURE__*/ (0,jsx_runtime.jsx)(SiteMetadataDefaults, {}),
                                /*#__PURE__*/ (0,jsx_runtime.jsx)(SiteMetadata, {}),
                                /*#__PURE__*/ (0,jsx_runtime.jsx)(MaybeBaseUrlIssueBanner, {}),
                                /*#__PURE__*/ (0,jsx_runtime.jsx)(AppNavigation, {})
                            ]
                        })
                    }),
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(HasHydratedDataAttribute, {})
                ]
            })
        })
    });
}

// EXTERNAL MODULE: ./.docusaurus/routesChunkNames.json
var routesChunkNames = __webpack_require__(84054);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/prefetch.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ function supports(feature) {
    try {
        const fakeLink = document.createElement('link');
        return fakeLink.relList.supports(feature);
    } catch  {
        return false;
    }
}
function linkPrefetchStrategy(url) {
    return new Promise((resolve, reject)=>{
        if (typeof document === 'undefined') {
            reject();
            return;
        }
        const link = document.createElement('link');
        link.setAttribute('rel', 'prefetch');
        link.setAttribute('href', url);
        link.onload = ()=>resolve();
        link.onerror = ()=>reject();
        const parentElement = document.getElementsByTagName('head')[0] ?? document.getElementsByName('script')[0]?.parentNode;
        parentElement?.appendChild(link);
    });
}
function xhrPrefetchStrategy(url) {
    return new Promise((resolve, reject)=>{
        const req = new XMLHttpRequest();
        req.open('GET', url, true);
        req.withCredentials = true;
        req.onload = ()=>{
            if (req.status === 200) {
                resolve();
            } else {
                reject();
            }
        };
        req.send(null);
    });
}
const supportedPrefetchStrategy = supports('prefetch') ? linkPrefetchStrategy : xhrPrefetchStrategy;
function prefetch(url) {
    return supportedPrefetchStrategy(url).catch(()=>{}); // 404s are logged to the console anyway.
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/flat.js
var flat = __webpack_require__(27665);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/docusaurus.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 





const fetched = new Set();
const loaded = new Set();
// If user is on slow or constrained connection.
const isSlowConnection = ()=>navigator.connection?.effectiveType.includes('2g') || navigator.connection?.saveData;
const canPrefetch = (routePath)=>!isSlowConnection() && !loaded.has(routePath) && !fetched.has(routePath);
const canPreload = (routePath)=>!isSlowConnection() && !loaded.has(routePath);
const getChunkNamesToLoad = (path)=>Object.entries(routesChunkNames).filter(// Remove the last part containing the route hash
    // input: /blog/2018/12/14/Happy-First-Birthday-Slash-fe9
    // output: /blog/2018/12/14/Happy-First-Birthday-Slash
    ([routeNameWithHash])=>routeNameWithHash.replace(/-[^-]+$/, '') === path).flatMap(([, routeChunks])=>Object.values((0,flat/* ["default"] */.A)(routeChunks)));
const docusaurus_prefetch = (routePath)=>{
    if (!canPrefetch(routePath)) {
        return false;
    }
    fetched.add(routePath);
    // Find all webpack chunk names needed.
    const matches = (0,react_router_config/* .matchRoutes */.u)(routes/* ["default"] */.A, routePath);
    const chunkNamesNeeded = matches.flatMap((match)=>getChunkNamesToLoad(match.route.path));
    // Prefetch all webpack chunk assets file needed.
    return Promise.all(chunkNamesNeeded.map((chunkName)=>{
        // "__webpack_require__.gca" is injected by ChunkAssetPlugin. Pass it
        // the name of the chunk you want to load and it will return its URL.
        // eslint-disable-next-line camelcase
        const chunkAsset = __webpack_require__.gca(chunkName);
        // In some cases, webpack might decide to optimize further, leading to
        // the chunk assets being merged to another chunk. In this case, we can
        // safely filter it out and don't need to load it.
        if (chunkAsset && !chunkAsset.includes('undefined')) {
            return prefetch(chunkAsset);
        }
        return Promise.resolve();
    }));
};
const docusaurus_preload = (routePath)=>{
    if (!canPreload(routePath)) {
        return false;
    }
    loaded.add(routePath);
    return preload(routePath);
};
const docusaurus = {
    prefetch: docusaurus_prefetch,
    preload: docusaurus_preload
};
// This object is directly mounted onto window, better freeze it
/* export default */ const client_docusaurus = (Object.freeze(docusaurus));

;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/clientEntry.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 









function Router({ children }) {
    return docusaurus_config/* ["default"].future.experimental_router */.A.future.experimental_router === 'hash' ? /*#__PURE__*/ (0,jsx_runtime.jsx)(react_router_dom/* .HashRouter */.I9, {
        children: children
    }) : /*#__PURE__*/ (0,jsx_runtime.jsx)(react_router_dom/* .BrowserRouter */.Kd, {
        children: children
    });
}
const hydrate = Boolean(true);
// Client-side render (e.g: running in browser) to become single-page
// application (SPA).
if (ExecutionEnvironment["default"].canUseDOM) {
    window.docusaurus = client_docusaurus;
    const container = document.getElementById('__docusaurus');
    const app = /*#__PURE__*/ (0,jsx_runtime.jsx)(index_module/* .HelmetProvider */.vd, {
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(Router, {
            children: /*#__PURE__*/ (0,jsx_runtime.jsx)(App, {})
        })
    });
    const onRecoverableError = (error, errorInfo)=>{
        console.error('Docusaurus React Root onRecoverableError:', error, errorInfo);
    };
    const renderApp = ()=>{
        if (window.docusaurusRoot) {
            window.docusaurusRoot.render(app);
            return;
        }
        if (hydrate) {
            window.docusaurusRoot = client.hydrateRoot(container, app, {
                onRecoverableError
            });
        } else {
            const root = client.createRoot(container, {
                onRecoverableError
            });
            root.render(app);
            window.docusaurusRoot = root;
        }
    };
    preload(window.location.pathname).then(()=>{
        (0,react.startTransition)(renderApp);
    });
    // Webpack Hot Module Replacement API
    if (false) {}
}


}),
93587: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  l: () => (/* binding */ DocusaurusContextProvider),
  o: () => (/* binding */ Context)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(74848);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./.docusaurus/docusaurus.config.mjs
var docusaurus_config = __webpack_require__(4784);
;// CONCATENATED MODULE: ./.docusaurus/globalData.json
var globalData_namespaceObject = JSON.parse('{"docusaurus-plugin-content-docs":{"default":{"path":"/es/","versions":[{"name":"current","label":"Próximo","isLast":true,"path":"/es/","mainDocId":"kb/getting-started/how-is-fintesk-data-organized","docs":[{"id":"billing/billing-information/what-happens-to-my-billing-when-i-add-a-user-in-fintesk","path":"/es/billing/billing-information/what-happens-to-my-billing-when-i-add-a-user-in-fintesk","sidebar":"tutorialSidebar"},{"id":"billing/billing-information/what-happens-to-my-billing-when-i-change-my-billing-frequency","path":"/es/billing/billing-information/what-happens-to-my-billing-when-i-change-my-billing-frequency","sidebar":"tutorialSidebar"},{"id":"billing/billing-information/what-happens-to-my-billing-when-i-change-my-fintesk-subscription-plan","path":"/es/billing/billing-information/what-happens-to-my-billing-when-i-change-my-fintesk-subscription-plan","sidebar":"tutorialSidebar"},{"id":"billing/billing-information/what-happens-to-my-billing-when-i-deactivate-a-user-in-fintesk","path":"/es/billing/billing-information/what-happens-to-my-billing-when-i-deactivate-a-user-in-fintesk","sidebar":"tutorialSidebar"},{"id":"billing/your-fintesk-subscription-plan/how-can-i-switch-to-a-different-fintesk-plan-or-change-my-billing-frequency","path":"/es/billing/your-fintesk-subscription-plan/how-can-i-switch-to-a-different-fintesk-plan-or-change-my-billing-frequency","sidebar":"tutorialSidebar"},{"id":"billing/your-fintesk-subscription-plan/what-features-do-the-fintesk-plans-have","path":"/es/billing/your-fintesk-subscription-plan/what-features-do-the-fintesk-plans-have","sidebar":"tutorialSidebar"},{"id":"developers/core-api-concepts/changes-to-the-api","path":"/es/developers/core-api-concepts/changes-to-the-api","sidebar":"tutorialSidebar"},{"id":"developers/core-api-concepts/core-api-concepts-about-fintesk-api","path":"/es/developers/core-api-concepts/core-api-concepts-about-fintesk-api","sidebar":"tutorialSidebar"},{"id":"developers/core-api-concepts/core-api-concepts-custom-fields","path":"/es/developers/core-api-concepts/core-api-concepts-custom-fields","sidebar":"tutorialSidebar"},{"id":"developers/core-api-concepts/core-api-concepts-date-format","path":"/es/developers/core-api-concepts/core-api-concepts-date-format","sidebar":"tutorialSidebar"},{"id":"developers/core-api-concepts/core-api-concepts-http-status-codes","path":"/es/developers/core-api-concepts/core-api-concepts-http-status-codes","sidebar":"tutorialSidebar"},{"id":"developers/core-api-concepts/core-api-concepts-pagination","path":"/es/developers/core-api-concepts/core-api-concepts-pagination","sidebar":"tutorialSidebar"},{"id":"developers/core-api-concepts/core-api-concepts-requests","path":"/es/developers/core-api-concepts/core-api-concepts-requests","sidebar":"tutorialSidebar"},{"id":"developers/overview/getting-started","path":"/es/developers/overview/getting-started","sidebar":"tutorialSidebar"},{"id":"fintesk/api-v1","path":"/es/fintesk/api-v1","sidebar":"tutorialSidebar"},{"id":"fintesk/changelog","path":"/es/fintesk/changelog","sidebar":"tutorialSidebar"},{"id":"kb/activities/activities","path":"/es/kb/activities/","sidebar":"tutorialSidebar"},{"id":"kb/activities/activity-marked-as-done-logic","path":"/es/kb/activities/activity-marked-as-done-logic","sidebar":"tutorialSidebar"},{"id":"kb/activities/creating-custom-activity-types","path":"/es/kb/activities/creating-custom-activity-types","sidebar":"tutorialSidebar"},{"id":"kb/activities/how-can-i-create-activities-in-bulk","path":"/es/kb/activities/how-can-i-create-activities-in-bulk","sidebar":"tutorialSidebar"},{"id":"kb/activities/how-can-i-filter-my-activities-in-the-list-view","path":"/es/kb/activities/how-can-i-filter-my-activities-in-the-list-view","sidebar":"tutorialSidebar"},{"id":"kb/activities/how-can-i-link-my-activities-with-multiple-contact-persons","path":"/es/kb/activities/how-can-i-link-my-activities-with-multiple-contact-persons","sidebar":"tutorialSidebar"},{"id":"kb/activities/how-can-i-see-done-activities","path":"/es/kb/activities/how-can-i-see-done-activities","sidebar":"tutorialSidebar"},{"id":"kb/company-settings/how-can-i-create-a-custom-currency","path":"/es/kb/company-settings/how-can-i-create-a-custom-currency","sidebar":"tutorialSidebar"},{"id":"kb/company-settings/how-can-i-enable-predefined-lost-reasons","path":"/es/kb/company-settings/how-can-i-enable-predefined-lost-reasons","sidebar":"tutorialSidebar"},{"id":"kb/company-settings/lost-reasons","path":"/es/kb/company-settings/lost-reasons","sidebar":"tutorialSidebar"},{"id":"kb/contacts/contact-detail-view","path":"/es/kb/contacts/contact-detail-view","sidebar":"tutorialSidebar"},{"id":"kb/contacts/contacts-persons-and-organizations","path":"/es/kb/contacts/contacts-persons-and-organizations","sidebar":"tutorialSidebar"},{"id":"kb/contacts/how-can-i-add-related-persons-or-organizations-to-a-deal","path":"/es/kb/contacts/how-can-i-add-related-persons-or-organizations-to-a-deal","sidebar":"tutorialSidebar"},{"id":"kb/contacts/linking-persons-and-organizations","path":"/es/kb/contacts/linking-persons-and-organizations","sidebar":"tutorialSidebar"},{"id":"kb/data-fields/custom-fields","path":"/es/kb/data-fields/custom-fields","sidebar":"tutorialSidebar"},{"id":"kb/data-fields/data-fields-in-fintesk","path":"/es/kb/data-fields/data-fields-in-fintesk","sidebar":"tutorialSidebar"},{"id":"kb/data-fields/how-can-i-add-data-fields-to-an-add-deal-contact-or-product-modal","path":"/es/kb/data-fields/how-can-i-add-data-fields-to-an-add-deal-contact-or-product-modal","sidebar":"tutorialSidebar"},{"id":"kb/data-fields/what-types-of-custom-fields-are-there","path":"/es/kb/data-fields/what-types-of-custom-fields-are-there","sidebar":"tutorialSidebar"},{"id":"kb/deals/adding-deals-in-bulk","path":"/es/kb/deals/adding-deals-in-bulk","sidebar":"tutorialSidebar"},{"id":"kb/deals/deals-what-they-are-and-how-to-add-them","path":"/es/kb/deals/deals-what-they-are-and-how-to-add-them","sidebar":"tutorialSidebar"},{"id":"kb/deals/editing-the-contact-linked-to-a-deal","path":"/es/kb/deals/editing-the-contact-linked-to-a-deal","sidebar":"tutorialSidebar"},{"id":"kb/deals/filtering-for-my-won-lost-or-deleted-deals","path":"/es/kb/deals/filtering-for-my-won-lost-or-deleted-deals","sidebar":"tutorialSidebar"},{"id":"kb/deals/how-can-i-move-a-deal-to-another-pipeline","path":"/es/kb/deals/how-can-i-move-a-deal-to-another-pipeline","sidebar":"tutorialSidebar"},{"id":"kb/deals/how-can-i-restore-deleted-deals","path":"/es/kb/deals/how-can-i-restore-deleted-deals","sidebar":"tutorialSidebar"},{"id":"kb/detail-view/deal-detail-view","path":"/es/kb/detail-view/deal-detail-view","sidebar":"tutorialSidebar"},{"id":"kb/detail-view/detail-view","path":"/es/kb/detail-view/","sidebar":"tutorialSidebar"},{"id":"kb/detail-view/how-can-i-add-notes-to-a-deal-or-contact","path":"/es/kb/detail-view/how-can-i-add-notes-to-a-deal-or-contact","sidebar":"tutorialSidebar"},{"id":"kb/detail-view/updating-items-in-the-detail-view","path":"/es/kb/detail-view/updating-items-in-the-detail-view","sidebar":"tutorialSidebar"},{"id":"kb/exporting-data/exporting-data-from-fintesk","path":"/es/kb/exporting-data/exporting-data-from-fintesk","sidebar":"tutorialSidebar"},{"id":"kb/filtering/filtering","path":"/es/kb/filtering/","sidebar":"tutorialSidebar"},{"id":"kb/filtering/filters-common-uses","path":"/es/kb/filtering/filters-common-uses","sidebar":"tutorialSidebar"},{"id":"kb/getting-started/fintesk-glossary","path":"/es/kb/getting-started/fintesk-glossary","sidebar":"tutorialSidebar"},{"id":"kb/getting-started/fintesk-user-vs-company-account","path":"/es/kb/getting-started/fintesk-user-vs-company-account","sidebar":"tutorialSidebar"},{"id":"kb/getting-started/how-can-i-delete-items-in-fintesk","path":"/es/kb/getting-started/how-can-i-delete-items-in-fintesk","sidebar":"tutorialSidebar"},{"id":"kb/getting-started/how-is-fintesk-data-organized","path":"/es/","sidebar":"tutorialSidebar"},{"id":"kb/getting-started/interface-in-fintesk","path":"/es/kb/getting-started/interface-in-fintesk","sidebar":"tutorialSidebar"},{"id":"kb/getting-started/organization-vs-company-account","path":"/es/kb/getting-started/organization-vs-company-account","sidebar":"tutorialSidebar"},{"id":"kb/getting-started/search-finding-what-you-need","path":"/es/kb/getting-started/search-finding-what-you-need","sidebar":"tutorialSidebar"},{"id":"kb/getting-started/what-is-the-difference-between-a-user-and-a-seat","path":"/es/kb/getting-started/what-is-the-difference-between-a-user-and-a-seat","sidebar":"tutorialSidebar"},{"id":"kb/importing-data/changing-the-field-type-of-a-custom-field","path":"/es/kb/importing-data/changing-the-field-type-of-a-custom-field","sidebar":"tutorialSidebar"},{"id":"kb/importing-data/how-can-i-format-dates-to-import-into-fintesk","path":"/es/kb/importing-data/how-can-i-format-dates-to-import-into-fintesk","sidebar":"tutorialSidebar"},{"id":"kb/importing-data/import-fields","path":"/es/kb/importing-data/import-fields","sidebar":"tutorialSidebar"},{"id":"kb/importing-data/importing-advanced-mapping","path":"/es/kb/importing-data/importing-advanced-mapping","sidebar":"tutorialSidebar"},{"id":"kb/importing-data/importing-data-into-fintesk-with-spreadsheets","path":"/es/kb/importing-data/importing-data-into-fintesk-with-spreadsheets","sidebar":"tutorialSidebar"},{"id":"kb/importing-data/importing-mandatory-fields","path":"/es/kb/importing-data/importing-mandatory-fields","sidebar":"tutorialSidebar"},{"id":"kb/importing-data/importing-mapping-your-fields","path":"/es/kb/importing-data/importing-mapping-your-fields","sidebar":"tutorialSidebar"},{"id":"kb/importing-data/importing-sample-import-spreadsheets","path":"/es/kb/importing-data/importing-sample-import-spreadsheets","sidebar":"tutorialSidebar"},{"id":"kb/importing-data/transferring-data-to-a-different-fintesk-company-account","path":"/es/kb/importing-data/transferring-data-to-a-different-fintesk-company-account","sidebar":"tutorialSidebar"},{"id":"kb/importing-data/updating-fintesk-data-with-a-spreadsheet","path":"/es/kb/importing-data/updating-fintesk-data-with-a-spreadsheet","sidebar":"tutorialSidebar"},{"id":"kb/importing-data/why-do-my-imported-currency-values-appear-as-0","path":"/es/kb/importing-data/why-do-my-imported-currency-values-appear-as-0","sidebar":"tutorialSidebar"},{"id":"kb/list-view/customizing-the-columns-in-the-list-view","path":"/es/kb/list-view/customizing-the-columns-in-the-list-view","sidebar":"tutorialSidebar"},{"id":"kb/list-view/fintesk-system-ids","path":"/es/kb/list-view/fintesk-system-ids","sidebar":"tutorialSidebar"},{"id":"kb/list-view/how-can-i-add-or-remove-columns-in-the-list-view","path":"/es/kb/list-view/how-can-i-add-or-remove-columns-in-the-list-view","sidebar":"tutorialSidebar"},{"id":"kb/list-view/how-can-i-edit-a-field-in-the-list-view","path":"/es/kb/list-view/how-can-i-edit-a-field-in-the-list-view","sidebar":"tutorialSidebar"},{"id":"kb/list-view/how-can-i-set-default-columns-for-all-my-users-in-the-list-view","path":"/es/kb/list-view/how-can-i-set-default-columns-for-all-my-users-in-the-list-view","sidebar":"tutorialSidebar"},{"id":"kb/list-view/list-view","path":"/es/kb/list-view/","sidebar":"tutorialSidebar"},{"id":"kb/personal-settings/fintesk-settings","path":"/es/kb/personal-settings/fintesk-settings","sidebar":"tutorialSidebar"},{"id":"kb/personal-settings/how-can-i-change-or-reset-my-password","path":"/es/kb/personal-settings/how-can-i-change-or-reset-my-password","sidebar":"tutorialSidebar"},{"id":"kb/personal-settings/how-can-i-free-up-space","path":"/es/kb/personal-settings/how-can-i-free-up-space","sidebar":"tutorialSidebar"},{"id":"kb/personal-settings/usage-limits-in-fintesk","path":"/es/kb/personal-settings/usage-limits-in-fintesk","sidebar":"tutorialSidebar"},{"id":"kb/pipeline-view/how-can-i-delete-a-deal-in-the-pipeline-view","path":"/es/kb/pipeline-view/how-can-i-delete-a-deal-in-the-pipeline-view","sidebar":"tutorialSidebar"},{"id":"kb/pipeline-view/how-can-i-see-deals-in-a-different-pipeline","path":"/es/kb/pipeline-view/how-can-i-see-deals-in-a-different-pipeline","sidebar":"tutorialSidebar"},{"id":"kb/pipeline-view/pipeline-view","path":"/es/kb/pipeline-view/","sidebar":"tutorialSidebar"},{"id":"kb/pipeline-view/the-rotting-feature","path":"/es/kb/pipeline-view/the-rotting-feature","sidebar":"tutorialSidebar"},{"id":"kb/pipelines/how-can-i-add-a-stage-to-my-pipeline","path":"/es/kb/pipelines/how-can-i-add-a-stage-to-my-pipeline","sidebar":"tutorialSidebar"},{"id":"kb/pipelines/how-can-i-customize-my-pipeline-stages","path":"/es/kb/pipelines/how-can-i-customize-my-pipeline-stages","sidebar":"tutorialSidebar"},{"id":"kb/pipelines/how-can-i-have-multiple-pipelines","path":"/es/kb/pipelines/how-can-i-have-multiple-pipelines","sidebar":"tutorialSidebar"},{"id":"kb/products/can-i-add-extra-fields-to-the-add-new-product-modal","path":"/es/kb/products/can-i-add-extra-fields-to-the-add-new-product-modal","sidebar":"tutorialSidebar"},{"id":"kb/products/can-i-have-one-product-in-different-price-variations","path":"/es/kb/products/can-i-have-one-product-in-different-price-variations","sidebar":"tutorialSidebar"},{"id":"kb/products/can-i-import-products-and-automatically-link-them-to-deals","path":"/es/kb/products/can-i-import-products-and-automatically-link-them-to-deals","sidebar":"tutorialSidebar"},{"id":"kb/products/how-can-i-link-products-to-a-deal","path":"/es/kb/products/how-can-i-link-products-to-a-deal","sidebar":"tutorialSidebar"},{"id":"kb/products/products","path":"/es/kb/products/","sidebar":"tutorialSidebar"},{"id":"kb/products/where-do-i-activate-or-deactivate-individual-products","path":"/es/kb/products/where-do-i-activate-or-deactivate-individual-products","sidebar":"tutorialSidebar"},{"id":"kb/troubleshooting/can-fintesk-be-used-offline","path":"/es/kb/troubleshooting/can-fintesk-be-used-offline","sidebar":"tutorialSidebar"},{"id":"kb/troubleshooting/how-can-i-take-a-screenshot","path":"/es/kb/troubleshooting/how-can-i-take-a-screenshot","sidebar":"tutorialSidebar"},{"id":"kb/troubleshooting/how-do-i-clear-my-browser-s-cache-and-cookies","path":"/es/kb/troubleshooting/how-do-i-clear-my-browser-s-cache-and-cookies","sidebar":"tutorialSidebar"},{"id":"kb/troubleshooting/how-do-i-open-my-browser-console","path":"/es/kb/troubleshooting/how-do-i-open-my-browser-console","sidebar":"tutorialSidebar"},{"id":"kb/troubleshooting/troubleshooting-fintesk-web-app","path":"/es/kb/troubleshooting/troubleshooting-fintesk-web-app","sidebar":"tutorialSidebar"},{"id":"kb/troubleshooting/which-browser-is-best-for-fintesk","path":"/es/kb/troubleshooting/which-browser-is-best-for-fintesk","sidebar":"tutorialSidebar"},{"id":"kb/users-and-permissions/global-user-management","path":"/es/kb/users-and-permissions/global-user-management","sidebar":"tutorialSidebar"},{"id":"kb/users-and-permissions/how-can-i-add-a-user","path":"/es/kb/users-and-permissions/how-can-i-add-a-user","sidebar":"tutorialSidebar"},{"id":"kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user","path":"/es/kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user","sidebar":"tutorialSidebar"},{"id":"kb/users-and-permissions/how-can-i-replace-users-in-my-fintesk-company-account","path":"/es/kb/users-and-permissions/how-can-i-replace-users-in-my-fintesk-company-account","sidebar":"tutorialSidebar"},{"id":"kb/users-and-permissions/updating-user-information","path":"/es/kb/users-and-permissions/updating-user-information","sidebar":"tutorialSidebar"},{"id":"kb/users-and-permissions/users","path":"/es/kb/users-and-permissions/users","sidebar":"tutorialSidebar"},{"id":"kb/users-and-permissions/what-is-a-regular-user","path":"/es/kb/users-and-permissions/what-is-a-regular-user","sidebar":"tutorialSidebar"},{"id":"kb/users-and-permissions/who-is-the-admin-user-of-my-account","path":"/es/kb/users-and-permissions/who-is-the-admin-user-of-my-account","sidebar":"tutorialSidebar"},{"id":"privacy/dpa","path":"/es/privacy/dpa","sidebar":"tutorialSidebar"},{"id":"privacy/fintesk-data-sub-processors","path":"/es/privacy/fintesk-data-sub-processors","sidebar":"tutorialSidebar"},{"id":"privacy/privacy-notice","path":"/es/privacy/","sidebar":"tutorialSidebar"},{"id":"tos/terms-of-service","path":"/es/tos/terms-of-service","sidebar":"tutorialSidebar"},{"id":"/category/developers","path":"/es/category/developers","sidebar":"tutorialSidebar"},{"id":"/category/overview","path":"/es/category/overview","sidebar":"tutorialSidebar"},{"id":"/category/core-api-concepts","path":"/es/category/core-api-concepts","sidebar":"tutorialSidebar"},{"id":"/category/knowledge-base","path":"/es/category/knowledge-base","sidebar":"tutorialSidebar"},{"id":"/category/getting-started","path":"/es/category/getting-started","sidebar":"tutorialSidebar"},{"id":"/category/exporting-data","path":"/es/category/exporting-data","sidebar":"tutorialSidebar"},{"id":"/category/importing-data","path":"/es/category/importing-data","sidebar":"tutorialSidebar"},{"id":"/category/pipeline-view","path":"/es/category/pipeline-view","sidebar":"tutorialSidebar"},{"id":"/category/pipelines","path":"/es/category/pipelines","sidebar":"tutorialSidebar"},{"id":"/category/data-fields","path":"/es/category/data-fields","sidebar":"tutorialSidebar"},{"id":"/category/list-view","path":"/es/category/list-view","sidebar":"tutorialSidebar"},{"id":"/category/detail-view","path":"/es/category/detail-view","sidebar":"tutorialSidebar"},{"id":"/category/filtering","path":"/es/category/filtering","sidebar":"tutorialSidebar"},{"id":"/category/deals","path":"/es/category/deals","sidebar":"tutorialSidebar"},{"id":"/category/activities","path":"/es/category/activities","sidebar":"tutorialSidebar"},{"id":"/category/contacts","path":"/es/category/contacts","sidebar":"tutorialSidebar"},{"id":"/category/users-and-permissions","path":"/es/category/users-and-permissions","sidebar":"tutorialSidebar"},{"id":"/category/personal-settings","path":"/es/category/personal-settings","sidebar":"tutorialSidebar"},{"id":"/category/company-settings","path":"/es/category/company-settings","sidebar":"tutorialSidebar"},{"id":"/category/products","path":"/es/category/products","sidebar":"tutorialSidebar"},{"id":"/category/troubleshooting","path":"/es/category/troubleshooting","sidebar":"tutorialSidebar"},{"id":"/category/billing","path":"/es/category/billing","sidebar":"tutorialSidebar"},{"id":"/category/billing-information","path":"/es/category/billing-information","sidebar":"tutorialSidebar"},{"id":"/category/your-fintesk-subscription-plan","path":"/es/category/your-fintesk-subscription-plan","sidebar":"tutorialSidebar"},{"id":"/category/fintesk-api","path":"/es/category/fintesk-api","sidebar":"tutorialSidebar"},{"id":"/category/privacy","path":"/es/category/privacy","sidebar":"tutorialSidebar"},{"id":"/category/terms-of-service","path":"/es/category/terms-of-service","sidebar":"tutorialSidebar"}],"draftIds":["billing/billing-information/billing-troubleshooting","billing/billing-information/booster-packs","billing/billing-information/how-can-i-cancel-my-trial","billing/billing-information/how-can-i-remove-seats","billing/billing-information/how-can-i-update-my-billing-details-in-fintesk","billing/billing-information/paying-for-fintesk-with-a-local-credit-card-brazil","billing/billing-information/what-are-the-accepted-payment-methods-for-fintesk","billing/billing-information/who-can-access-the-billing-information-on-my-fintesk-account","billing/billing-information/why-do-i-need-to-re-submit-my-payment-details-for-subscription-renewals-india","billing/invoices/adding-my-vat-abn-or-gst-number-to-fintesk","billing/invoices/can-i-change-the-information-in-a-past-fintesk-invoice","billing/invoices/how-can-i-view-my-past-fintesk-invoices","billing/invoices/how-is-the-subscription-cost-of-the-fintesk-invoice-calculated","billing/invoices/how-will-i-receive-my-fintesk-invoice","billing/invoices/what-happens-when-my-fintesk-invoice-is-marked-as-past-due","billing/invoices/what-vendor-name-will-appear-on-my-bank-statements","billing/invoices/when-does-my-fintesk-invoice-need-to-be-paid-by","billing/invoices/why-do-my-invoices-say-taxamo","billing/your-fintesk-subscription-plan/can-i-delete-my-account","billing/your-fintesk-subscription-plan/how-can-i-cancel-my-paid-fintesk-account","billing/your-fintesk-subscription-plan/how-can-i-regain-access-to-a-closed-fintesk-account","billing/your-fintesk-subscription-plan/how-can-i-start-paying-for-fintesk","billing/your-fintesk-subscription-plan/how-does-pricing-work-in-fintesk","billing/your-fintesk-subscription-plan/what-happens-when-my-fintesk-trial-expires","billing/your-fintesk-subscription-plan/what-is-the-difference-between-annual-and-monthly-billing-in-fintesk","developers/coming-soon/enabling-api-for-company-users","developers/coming-soon/how-to-find-the-api-token","developers/coming-soon/how-to-get-the-company-domain","developers/coming-soon/merging-deals-via-api","developers/coming-soon/merging-two-organizations-via-api","developers/coming-soon/merging-two-persons-via-api","developers/coming-soon/working-with-labels","developers/core-api-concepts/core-api-concepts-authentication","developers/core-api-concepts/core-api-concepts-rate-limiting","developers/faq/faq","developers/overview/run-fintesk-api-in-postman-or-insomnia","developers/quick-start/add-custom-field-via-api","developers/quick-start/adding-a-filter-via-fintesk-api","developers/quick-start/adding-a-product","developers/quick-start/adding-an-activity-via-api","developers/quick-start/adding-an-organization-via-api","developers/quick-start/assigning-a-deal-to-a-certain-user-via-api","developers/quick-start/create-a-deal-via-api","developers/quick-start/delete-custom-field-via-api","developers/quick-start/get-deals-via-api","developers/quick-start/getting-details-of-a-deal-via-api","developers/quick-start/pagination-via-api","developers/quick-start/update-a-deal-via-api","developers/quick-start/update-custom-field-via-api","developers/quick-start/updating-a-person-via-api","integrations/contact-sync/contact-sync","integrations/zapier/zapier-add-new-facebook-ad-leads-as-people-in-fintesk","integrations/zapier/zapier-creating-a-new-person-in-fintesk-from-a-business-card-in-contacts","integrations/zapier/zapier-creating-fintesk-deals-with-gravity-forms","integrations/zapier/zapier-creating-fintesk-deals-with-wufoo-forms","integrations/zapier/zapier-creating-new-fintesk-deals-from-hubspot-form-submissions","integrations/zapier/zapier-creating-new-fintesk-deals-from-mailchimp-subscribers","integrations/zapier/zapier-get-notifications-in-slack-of-new-fintesk-deals","integrations/zapier/zapier-saving-new-rows-in-google-sheets-as-new-deals-in-fintesk","integrations/zapier/zapier-saving-unbounce-leads-to-fintesk","integrations/zapier/zapier-sending-fintesk-contacts-to-mailchimp-subscribers","integrations/zapier/zapier-sending-gmail-emails-about-new-fintesk-deals","integrations/zapier/zapier-what-it-is-and-how-to-use-it","kb/activities/activity-invites","kb/activities/activity-priority-labels","kb/activities/activity-reminder-emails","kb/activities/add-activities-bulk","kb/activities/calendar-sync","kb/activities/calendar-view","kb/activities/can-i-see-activities-that-have-been-assigned-to-me","kb/activities/contextual-view-activities","kb/activities/how-can-i-disable-the-follow-up-activity-pop-up","kb/activities/how-can-i-propose-my-general-availability-in-the-scheduler","kb/activities/how-can-i-propose-my-specific-times-in-the-scheduler","kb/activities/meeting-scheduler","kb/activities/private-activities","kb/activities/recurring-activities","kb/activities/troubleshooting-the-calendar-sync-feature","kb/activities/what-is-the-red-number-on-the-activities-icon","kb/activities/why-are-emails-that-i-ve-sent-or-received-not-in-the-list-view-of-activities","kb/company-settings/changing-a-company-domain-in-fintesk","kb/company-settings/changing-the-name-of-a-company-account","kb/company-settings/restore-data","kb/contacts/address-fields-in-fitnesk","kb/contacts/contact-labels","kb/contacts/contacts-timeline","kb/contacts/how-can-i-add-a-picture-to-a-person-in-fintesk","kb/contacts/how-can-i-create-a-person-contact-from-a-received-email","kb/contacts/related-organizations","kb/contacts/show-on-map-feature","kb/contacts/timeline-view-follow-up-frequency","kb/data-fields/important-fields","kb/data-fields/required-fields","kb/deals/can-multiple-contact-be-linked-to-a-deal","kb/deals/deal-labels","kb/deals/deals-waitlist","kb/deals/how-can-i-duplicate-a-deal","kb/deals/how-can-i-edit-the-deal-created-date","kb/deals/how-can-i-edit-the-deal-won-time","kb/deals/how-can-i-see-the-total-value-of-my-deals-by-stage-or-pipeline","kb/deals/leads-vs-deals","kb/detail-view/detail-view-sidebar","kb/detail-view/followers","kb/detail-view/how-can-i-upload-a-file-to-a-deal-or-a-contact","kb/detail-view/mentions-and-comments","kb/detail-view/participants","kb/detail-view/why-are-emails-not-showing-on-the-detail-view-of-the-deal","kb/detail-view/why-are-items-shown-as-hidden","kb/detail-view/why-are-my-emails-not-showing-on-the-organization-page-but-appear-in-the-deal-and-contact","kb/email/archiving-and-deleting-emails","kb/email/can-i-sync-multiple-email-addresses-to-one-user","kb/email/changing-your-email-sender-name","kb/email/email-labels","kb/email/email-privacy-and-sharing-emails-in-fintesk","kb/email/email-provider-vs-email-client","kb/email/email-signature","kb/email/email-sync","kb/email/email-templates","kb/email/email-tracking-reports-with-gmail-and-apple","kb/email/email-tracking","kb/email/group-emailing","kb/email/how-are-emails-threaded-in-fintesk","kb/email/how-are-first-and-last-names-separated-in-email-template-merge-fields","kb/email/how-can-i-find-my-imap-and-smtp-information","kb/email/how-can-i-re-authenticate-my-email-sync-in-fintesk","kb/email/how-can-i-set-up-the-email-sync","kb/email/how-to-link-emails-to-fintesk-items","kb/email/schedule-emails-for-later","kb/email/syncing-multiple-email-accounts","kb/email/which-provider-is-best-for-email-sync","kb/email/why-are-my-emails-appearing-with-different-formatting-when-i-send-them","kb/features/how-does-the-merge-duplicates-feature-identify-duplicates-in-fintesk","kb/features/merge-duplicates","kb/features/recurring-revenue-feature","kb/filtering/how-can-i-favorite-filters","kb/filtering/viewing-and-reassigning-the-data-of-a-deactivated-user","kb/forecast-view/how-are-deals-ordered-in-the-forecast-view","kb/forecast-view/how-can-i-see-projected-revenue-for-my-colleagues-deals-in-the-forecast-view","kb/forecast-view/how-can-i-sort-deals-in-the-forecast-view-by-a-different-timeframe","kb/forecast-view/the-forecast-view-revenue-projection","kb/forecast-view/what-is-the-green-bar-on-the-bottom-of-a-deal-in-the-forecast-view","kb/forecast-view/why-can-t-i-see-won-deals-in-the-forecast-view","kb/importing-data/how-to-avoid-duplicates-during-an-import","kb/importing-data/importing-deals-into-a-specific-stage-or-pipeline","kb/importing-data/importing-errors-and-skip-files","kb/importing-data/importing-followers-and-participants","kb/leads/adding-leads-to-my-leads-inbox","kb/leads/converting-deals-to-leads","kb/leads/emails-in-leads","kb/leads/how-can-i-import-leads","kb/leads/how-can-i-update-my-leads","kb/leads/lead-labels","kb/leads/leads-inbox","kb/leads/messaging-inbox","kb/leads/troubleshooting-messaging-inbox","kb/leads/visibility-groups-for-leads","kb/leads/when-should-a-lead-become-a-deal","kb/list-view/bulk-deleting-items-in-the-list-view","kb/list-view/bulk-editing-and-filtering","kb/list-view/how-can-i-reassign-items-owned-by-one-user-to-another-user","kb/list-view/sorting-by-multiple-columns-in-list-view","kb/list-view/why-can-t-i-see-my-colleagues-items-in-the-list-view","kb/notifications/how-can-i-enable-or-disable-desktop-notifications","kb/notifications/notifications","kb/notifications/sales-assistant-notifications","kb/notifications/sales-assistant","kb/personal-settings/can-all-users-access-the-fintesk-api","kb/personal-settings/can-i-be-in-multiple-fintesk-company-accounts","kb/personal-settings/can-i-change-my-displayed-timezone","kb/personal-settings/changing-or-updating-login-credentials","kb/personal-settings/convert-phone-numbers-to-us-format","kb/personal-settings/deactivated-users-data","kb/personal-settings/how-can-i-change-my-language-or-date-number-format","kb/personal-settings/how-can-i-compose-emails-in-a-separate-browser-tab","kb/personal-settings/how-can-i-find-my-personal-api-key","kb/personal-settings/how-can-i-switch-between-multiple-fintesk-accounts","kb/personal-settings/user-overview","kb/personal-settings/webhooks","kb/personal-settings/what-is-the-api-key-for","kb/pipeline-view/can-i-change-the-order-of-my-deals-in-the-pipeline-view","kb/pipeline-view/deal-card-customization-sorting","kb/pipeline-view/how-are-deals-ordered-in-the-pipeline-view","kb/pipeline-view/why-can-t-i-see-my-colleagues-deals-in-the-pipeline-view","kb/pipelines/how-can-i-set-deal-probability","kb/pipelines/how-can-i-set-stage-probability","kb/pipelines/pipeline-visibility","kb/pipelines/probability-in-fintesk","kb/privacy-and-security/2fa-two-factor-authentication","kb/privacy-and-security/how-can-i-log-myself-out-of-fintesk-on-my-connected-devices","kb/privacy-and-security/how-can-i-see-which-devices-i-have-used-to-access-fintesk","kb/privacy-and-security/how-can-i-sync-outlook-when-i-have-2fa-enabled","kb/privacy-and-security/how-is-data-backed-up-in-fintesk","kb/privacy-and-security/logging-into-fintesk-using-google","kb/privacy-and-security/security-alerts","kb/privacy-and-security/security-dashboard","kb/privacy-and-security/security-features-in-fintesk","kb/privacy-and-security/security-locked-out-of-account-after-failed-login-attempts","kb/privacy-and-security/security-rules-access-restrictions","kb/privacy-and-security/security-rules","kb/privacy-and-security/single-sign-on-entra-id","kb/privacy-and-security/single-sign-on-okta","kb/privacy-and-security/single-sign-on","kb/privacy-and-security/using-sso-single-sign-on-with-security-rules","kb/privacy-and-security/why-does-fintesk-log-me-out","kb/products/product-duration","kb/products/recurring-products","kb/tags-internal","kb/troubleshooting/how-can-i-generate-a-har-file","kb/troubleshooting/what-if-fintesk-support-is-not-available-in-the-app","kb/users-and-permissions/data-deleted-deactivated-user","kb/users-and-permissions/how-can-i-follow-items-owned-by-other-fintesk-users","kb/users-and-permissions/how-can-i-make-a-user-into-an-admin-user","kb/users-and-permissions/how-to-change-the-visibility-of-items","kb/users-and-permissions/permission-sets","kb/users-and-permissions/teams","kb/users-and-permissions/types-of-users-in-fintesk","kb/users-and-permissions/viewing-last-log-in-time-by-user","kb/users-and-permissions/visibility-groups","kb/users-and-permissions/what-happens-when-a-user-gets-deactivated"],"sidebars":{"tutorialSidebar":{"link":{"path":"/es/category/developers","label":"Desarrolladores"}}}}],"breadcrumbs":true}},"docusaurus-plugin-redoc":{"fintesk-v1":{"url":"redocusaurus/fintesk-v1.yaml","themeId":"theme-redoc","isSpecFile":true,"normalizeUrl":true,"spec":{"openapi":"3.0.1","info":{"title":"Fintesk API v2","version":"2.0.27"},"servers":[{"url":"{protocol}://api.fintesk.com","variables":{"protocol":{"enum":["http","https"],"default":"https"}}}],"tags":[{"name":"Activities","description":"Activities are appointments/tasks/events on a calendar that can be associated with a deal, a lead, a person and an organization. \\nActivities can be of different type (such as call, meeting, lunch or a custom type - see ActivityTypes object) and can be assigned to a particular user. \\nNote that activities can also be created without a specific date/time.\\n"},{"name":"ActivityFields","description":"Activity fields represent different fields that an activity has.\\n"},{"name":"ActivityTypes","description":"Activity types represent different kinds of activities that can be stored.\\nEach activity type is presented to the user with an icon and a name.\\nAdditionally, a color can be defined (not implemented in the Fintesk app as of today). \\nActivity types are linked to activities via  `ActivityType.key_string = Activity.type`. \\nThe `key_string` will be generated by the API based on the given name of the  activity type upon creation, and cannot be changed. \\nActivity types should be presented to the user in an ordered manner, using the `ActivityType.order_nr` value.\\n"},{"name":"Currencies","description":"Supported currencies which can be used to represent the monetary value of a deal, or a value of any monetary type custom field. \\nThe `Currency.code` field must be used to point to a currency. \\n`Currency.code` is the ISO-4217 format currency code for non-custom currencies. \\nYou can differentiate custom and non-custom currencies using the  `is_custom_flag` property. \\n"},{"name":"DealFields","description":"Deal fields represent the near-complete schema for a deal in the context of the company of the authorized user. \\nEach company can have a different schema for their deals, with various custom fields. \\nIn the context of using deal fields as a schema for defining the data fields  of a deal, it must be kept in mind that some types of custom fields can have  additional data fields which are not separate deal fields per se. Such is the case with monetary, daterange and timerange fields  – each of these fields will have one additional data field in addition to  the one presented in the context of deal fields. \\nFor example, if there is a monetary field with the key `ffk9s9` stored on  the account, `ffk9s9` would hold the numeric value of the field,  and `ffk9s9_currency` would hold the ISO currency code that goes along with the numeric value. \\nTo find out which data fields are available, fetch one deal and list its keys.\\n"},{"name":"Deals","description":"Deals represent ongoing, lost or won sales to an organization or to a person. \\nEach deal has a monetary value and must be placed in a stage.\\nDeals can be owned by a user.\\nEach deal consists of standard data fields but can also contain a number of custom fields. \\nThe custom fields can be recognized by long hashes as keys. \\nThese hashes can be mapped against `DealField.key`. \\nThe corresponding label for each such custom field can be obtained from `DealField.name`.\\n"},{"name":"Filters","description":"Each filter is essentially a set of data validation conditions. \\nA filter of the same kind can be applied when fetching a list of deals, persons, organizations or products in the context of a pipeline. \\nFilters are limited to a maximum of 16 conditions. \\nWhen applied, only items matching the conditions of the filter are returned. \\nDetailed definitions of filter conditions and additional functionality is not yet available.\\n"},{"name":"ItemSearch","description":"Ordered reference objects, pointing to either deals, persons, organizations, or products.\\n"},{"name":"OrganizationFields","description":"Organization fields represent the near-complete schema for an organization in the context of the company of the authorized user. \\nEach company can have a different schema for their organizations,  with various custom fields. \\nIn the context of using organization fields as a schema for defining the data  fields of an organization, it must be kept in mind that some types of custom  fields can have additional data fields which are not separate organization  fields per se. \\nSuch is the case with monetary, daterange and timerange fields - each of these  fields will have one additional data field in addition to the one presented  in the context of organization fields. \\nFor example, if there is a monetary field with the key `ffk9s9` stored on the  account, `ffk9s9` would hold the numeric value of the field,  and `ffk9s9_currency` would hold the ISO currency code that goes along with the numeric value. \\nTo find out which data fields are available, fetch one organization  and list its keys.\\n"},{"name":"OrganizationRelationships","description":"Organization relationships represent how different organizations are related to each other. \\nThe relationship can be hierarchical (parent-child companies) or lateral as defined by the `type` field - either `parent` or `related`.\\n","deprecated":true},{"name":"Organizations","description":"Organizations are companies and other kinds of organizations you are making deals with. Persons can be associated with organizations so that each organization can contain one or more persons.\\n"},{"name":"PersonFields","description":"Person fields represent the near-complete schema for a person in the context of the company of the authorized user. \\nEach company can have a different schema for their persons,  with various custom fields. \\nIn the context of using person fields as a schema for defining the data  fields of a person, it must be kept in mind that some types of custom fields  can have additional data fields which are not separate person fields per se.\\nSuch is the case with monetary, daterange and timerange fields – each of these fields will have one additional data field in addition to the one presented in the context of person fields. \\nFor example, if there is a monetary field with the key `ffk9s9` stored on the  account, `ffk9s9` would hold the numeric value of the field,  and `ffk9s9_currency` would hold the ISO currency code that  goes along with the numeric value. \\nTo find out which data fields are available, fetch one person and list its keys.\\n"},{"name":"Persons","description":"Persons are your contacts, the customers you are doing deals with. \\nEach person can belong to an organization. \\nPersons should not be confused with users.\\n"},{"name":"Pipelines","description":"Pipelines are essentially ordered collections of stages.\\n"},{"name":"ProductFields","description":"Product fields represent the near-complete schema for a product in the context of the company of the authorized user. \\nEach company can have a different schema for their products, with various  custom fields. \\nIn the context of using product fields as a schema for  defining the data fields of a product, it must be kept in mind that some  types of custom fields can have additional data fields which are  not separate product fields per se.\\nSuch is the case with monetary, daterange and timerange fields – each of these fields will have one additional data field in addition to the one presented in the context of product fields. \\nFor example, if there is a monetary field with the key `ffk9s9`  stored on the account, `ffk9s9` would hold the numeric value of the field,  and `ffk9s9_currency` would hold the ISO currency code that goes along  with the numeric value. \\nTo find out which data fields are available, fetch one product and list its keys.\\n"},{"name":"Products","description":"Products are the goods or services you are dealing with.\\nEach product can have N different price points - firstly, each product can  have a price in N different currencies, and secondly, each product can have  N variations of itself, each having N prices in different currencies.\\n \\nNote that only one price per variation per currency is supported. \\nProducts can be instantiated to deals. \\nIn the context of instatiation, a custom price, quantity, duration and discount  can be applied.\\n"},{"name":"Recents","description":"Recent changes across all item types in Fintesk (deals, persons, etc).\\n"},{"name":"Roles","description":"Roles are a part of the Visibility groups’ feature that allow the admin user to categorize other users and dictate what items they will be allowed access to see.\\n"},{"name":"Stages","description":"Stage is a logical component of a pipeline, and essentially a bucket that can hold a number of deals. \\nIn the context of the pipeline a stage belongs to, it has an order number which defines the order of stages in that pipeline.\\n"},{"name":"Users","description":"Users are people with access to your Fintesk account. A user may belong to one or many Fintesk accounts, so deleting a user from one Fintesk account will not remove the user from the data store if he/she is connected to multiple accounts. \\nUsers should not be confused with persons.\\n"}],"paths":{"/oauth/authorize":{"get":{"summary":"Requesting authorization","description":"Authorize a user by redirecting them to the Pipedrive OAuth authorization page and request their permissions to act on their behalf. This step is necessary to implement only when you allow app installation outside of the Marketplace.","operationId":"authorize","deprecated":true,"servers":[{"url":"https://oauth.fintesk.com"}],"tags":["Oauth"],"parameters":[{"in":"query","name":"client_id","required":true,"schema":{"type":"string"},"description":"The client ID provided to you by the Pipedrive Marketplace when you register your app"},{"in":"query","name":"redirect_uri","required":true,"schema":{"type":"string"},"description":"The callback URL you provided when you registered your app. Authorization code will be sent to that URL (if it matches with the value you entered in the registration form) if a user approves the app install. Or, if a customer declines, the corresponding error will also be sent to this URL."},{"in":"query","name":"state","schema":{"type":"string"},"description":"You may pass any random string as the state parameter and the same string will be returned to your app after a user authorizes access. It may be used to store the user\'s session ID from your app or distinguish different responses. Using state may increase security; see RFC-6749. \\n"}],"responses":{"200":{"description":"Authorize user in the app.","content":{"text/html":{"example":"As a result of the request, the customer will see a page with the confirmation dialog, which will present the details of your app (title, company name, icon) and explain the permission scopes that you have set for the app. Customers should confirm their wish to install the app by clicking \\"Allow and install\\" or deny authorization by clicking \\"Cancel\\".\\n"}}}}}},"/oauth/token":{"post":{"summary":"Getting the tokens","description":"After the customer has confirmed the app installation, you will need to exchange the `authorization_code` to a pair of access and refresh tokens. Using an access token, you can access the user\'s data through the API.","operationId":"get-tokens","deprecated":true,"servers":[{"url":"https://oauth.fintesk.com"}],"tags":["Oauth"],"security":[{"basic_authentication":[]}],"parameters":[{"in":"header","name":"Authorization","required":true,"schema":{"type":"string"},"description":"Base 64 encoded string containing the `client_id` and `client_secret` values. The header value should be `Basic <base64(client_id:client_secret)>`."}],"requestBody":{"content":{"application/x-www-form-urlencoded":{"schema":{"title":"getTokensRequest","type":"object","properties":{"grant_type":{"type":"string","enum":["authorization_code","refresh_token"],"default":"authorization_code","description":"Since you are trying to exchange an authorization code for a pair of tokens, you must use the value \\"authorization_code\\""},"code":{"type":"string","description":"The authorization code that you received after the user confirmed app installation"},"redirect_uri":{"type":"string","description":"The callback URL you provided when you registered your app"}}}}}},"responses":{"200":{"description":"Returns user Oauth2 tokens.","content":{"application/json":{"schema":{"title":"getTokensResponse200","type":"object","properties":{"access_token":{"type":"string","description":"You need to use an `access_token` for accessing the user\'s data via API. You will need to refresh the access token if the `access_token` becomes invalid."},"token_type":{"type":"string","description":"The format of the token. Always \\"Bearer\\"."},"refresh_token":{"type":"string","description":"A refresh token is needed when you refresh the access token. refresh_token will expire if it isn\'t used in 60 days. Each time refresh_token is used, its expiry date is reset back to 60 days."},"scope":{"type":"string","description":"List of scopes to which users have agreed to grant access within this `access_token`"},"expires_in":{"type":"integer","description":"The maximum time in seconds until the `access_token` expires"},"api_domain":{"type":"string","description":"The base URL path, including the company_domain, where the requests can be sent to"}}}}}}}}},"/oauth/token/":{"post":{"summary":"Refreshing the tokens","description":"The `access_token` has a lifetime. After a period of time, which was returned to you in `expires_in` JSON property, the `access_token` will be invalid, and you can no longer use it to get data from our API. To refresh the `access_token`, you must use the `refresh_token`.","operationId":"refresh-tokens","deprecated":true,"servers":[{"url":"https://oauth.fintesk.com"}],"tags":["Oauth"],"security":[{"basic_authentication":[]}],"parameters":[{"in":"header","name":"Authorization","required":true,"schema":{"type":"string"},"description":"Base 64 encoded string containing the `client_id` and `client_secret` values. The header value should be `Basic <base64(client_id:client_secret)>`."}],"requestBody":{"content":{"application/x-www-form-urlencoded":{"schema":{"title":"getTokensRequest","type":"object","properties":{"grant_type":{"type":"string","enum":["authorization_code","refresh_token"],"default":"refresh_token","description":"Since you are to refresh your access_token, you must use the value \\"refresh_token\\""},"refresh_token":{"type":"string","description":"The refresh token that you received after you exchanged the authorization code"}}}}}},"responses":{"200":{"description":"Returns user Oauth2 tokens.","content":{"application/json":{"schema":{"title":"getTokensResponse200","type":"object","properties":{"access_token":{"type":"string","description":"You need to use an `access_token` for accessing the user\'s data via API. You will need to refresh the access token if the `access_token` becomes invalid."},"token_type":{"type":"string","description":"The format of the token. Always \\"Bearer\\"."},"refresh_token":{"type":"string","description":"A refresh token is needed when you refresh the access token. refresh_token will expire if it isn\'t used in 60 days. Each time refresh_token is used, its expiry date is reset back to 60 days."},"scope":{"type":"string","description":"List of scopes to which users have agreed to grant access within this `access_token`"},"expires_in":{"type":"integer","description":"The maximum time in seconds until the `access_token` expires"},"api_domain":{"type":"string","description":"The base URL path, including the company_domain, where the requests can be sent to"}}}}}}}}},"/activities":{"delete":{"summary":"Delete multiple activities in bulk","description":"Marks multiple activities as deleted. After 30 days, the activities will be permanently deleted.","operationId":"deleteActivities","tags":["Activities"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_ids"}],"responses":{"200":{"description":"Success Deleting multiple activities in bulk","content":{"application/json":{"schema":{"title":"deleteActivitiesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted_list"}}}]}}}}}},"get":{"summary":"Get all activities assigned to a particular user","description":"Returns all activities assigned to a particular user.","operationId":"getActivities","tags":["Activities"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_activity_user_id"},{"$ref":"#/components/parameters/p_query_filter_id"},{"$ref":"#/components/parameters/p_query_activity_type"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_activity_start_date"},{"$ref":"#/components/parameters/p_query_activity_end_date"},{"$ref":"#/components/parameters/p_query_activity_done"}],"responses":{"200":{"description":"Success getting all activities assigned to a particular user","content":{"application/json":{"schema":{"title":"getActivitiesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"title":"activityResponseObject","allOf":[{"$ref":"#/components/schemas/s_activity_extended"},{"$ref":"#/components/schemas/s_activity"}]}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_3E_U"}}}]}}}}}},"post":{"summary":"Add an activity","description":"Adds a new activity. Includes `more_activities_scheduled_in_context` property in response\'s `additional_data` which indicates whether there are more undone activities scheduled with the same deal, person or organization (depending on the supplied data). For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/adding-an-activity\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">adding an activity</a>.","operationId":"addActivity","tags":["Activities"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"title":"addActivityRequest","allOf":[{"$ref":"#/components/schemas/s_activity_extended"},{"$ref":"#/components/schemas/s_activity"}]}}}},"responses":{"201":{"description":"Success Adding an activity","content":{"application/json":{"schema":{"title":"addActivityResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"title":"activityResponseObject","allOf":[{"$ref":"#/components/schemas/s_activity_extended"},{"$ref":"#/components/schemas/s_activity"}]},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_3E_U"}}}]}}}}}}},"/activities/{id}":{"delete":{"summary":"Delete an activity","description":"Marks an activity as deleted. After 30 days, the activity will be permanently deleted.","operationId":"deleteActivity","tags":["Activities"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"The activity was successfully deleted","content":{"application/json":{"schema":{"title":"deleteActivityResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted"}}}]}}}}}},"get":{"summary":"Get details of an activity","description":"Returns the details of a specific activity.","operationId":"getActivity","tags":["Activities"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success getting details of an activity","content":{"application/json":{"schema":{"title":"getActivityResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"title":"activityResponseObject","allOf":[{"$ref":"#/components/schemas/s_activity_extended"},{"$ref":"#/components/schemas/s_activity"}]},"related_objects":{"$ref":"#/components/schemas/s_related_objects_3E_U"}}}]}}}}}},"put":{"summary":"Update an activity","description":"Updates an activity. Includes `more_activities_scheduled_in_context` property in response\'s `additional_data` which indicates whether there are more undone activities scheduled with the same deal, person or organization (depending on the supplied data).","operationId":"updateActivity","tags":["Activities"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"title":"updateActivityRequest","allOf":[{"$ref":"#/components/schemas/s_activity_extended"},{"$ref":"#/components/schemas/s_activity"}]}}}},"responses":{"200":{"description":"Success updating an activity","content":{"application/json":{"schema":{"title":"updateActivityResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"title":"activityResponseObject","allOf":[{"$ref":"#/components/schemas/s_activity_extended"},{"$ref":"#/components/schemas/s_activity"}]},"related_objects":{"$ref":"#/components/schemas/s_related_objects_3E_U"}}}]}}}}}}},"/activityFields":{"get":{"summary":"Get all activity fields","description":"Returns all activity fields.","operationId":"getActivityFields","tags":["ActivityFields"],"security":[{"bearerAuth":[]}],"responses":{"200":{"description":"Success Getting all activity fields","content":{"application/json":{"schema":{"title":"fieldsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":[{"$ref":"#/components/schemas/s_field"}]},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}}},"/activityTypes":{"delete":{"summary":"Delete multiple activity types in bulk","description":"Marks multiple activity types as deleted.","operationId":"deleteActivityTypes","tags":["ActivityTypes"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_ids"}],"responses":{"200":{"description":"Success Deleting multiple activity types in bulk","content":{"application/json":{"schema":{"title":"deleteActivityTypesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"object","properties":{"type":"object","title":"deletedListID","properties":{"id":{"type":"array","description":"Array of all the IDs of the deleted items.","items":{"type":"integer"}}}}}}}]}}}}}},"get":{"summary":"Get all activity types","description":"Returns all activity types.","operationId":"getActivityTypes","tags":["ActivityTypes"],"security":[{"bearerAuth":[]}],"responses":{"200":{"description":"Success Getting all activity types","content":{"application/json":{"schema":{"title":"getActivityTypesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":[{"$ref":"#/components/schemas/s_activity_type"}],"description":"The array of activity types"}}}]}}}}}},"post":{"summary":"Add new activity type","description":"Adds a new activity type.","operationId":"addActivityType","tags":["ActivityTypes"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"title":"addActivityTypeRequest","allOf":[{"type":"object","required":["name","icon_key"]},{"$ref":"#/components/schemas/s_activity_type_put"}]}}}},"responses":{"200":{"description":"Success Adding new activity type","content":{"application/json":{"schema":{"title":"createActivityTypeResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_activity_type"}}}]}}}}}}},"/activityTypes/{id}":{"delete":{"summary":"Delete an activity type","description":"Marks an activity type as deleted.","operationId":"deleteActivityType","tags":["ActivityTypes"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success deleting an activity type","content":{"application/json":{"schema":{"title":"DeleteActivityTypeResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_activity_type"}}}]}}}}}},"put":{"summary":"Update an activity type","description":"Updates an activity type.","operationId":"updateActivityType","tags":["ActivityTypes"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"title":"updateActivityTypeRequest","$ref":"#/components/schemas/s_activity_type_put"}}}},"responses":{"200":{"description":"Success Updating an activity type","content":{"application/json":{"schema":{"title":"UpdateActivityTypeResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_activity_type"}}}]}}}}}}},"/currencies":{"get":{"summary":"Get all supported currencies","description":"Returns all supported currencies in given account which should be used when saving monetary values with other objects. The `code` parameter of the returning objects is the currency code according to ISO 4217 for all non-custom currencies.","operationId":"getCurrencies","tags":["Currencies"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_currency_term"}],"responses":{"200":{"description":"Success Getting all supported currencies","content":{"application/json":{"schema":{"title":"getCurrenciesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_currency"}}}]}}}}}}},"/deals":{"get":{"summary":"Get all deals","description":"Returns all deals. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/getting-all-deals\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">getting all deals</a>.","operationId":"getDeals","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_deal_user_id"},{"$ref":"#/components/parameters/p_query_filter_id"},{"$ref":"#/components/parameters/p_query_deal_stage_id"},{"$ref":"#/components/parameters/p_query_status"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_sort"},{"$ref":"#/components/parameters/p_query_deal_owned_by_you"}],"responses":{"200":{"description":"Success getting all deals","content":{"application/json":{"schema":{"title":"getDealsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"$ref":"#/components/schemas/s_deal_non_strict"}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_2E_U_S_P"}}}]}}}}}},"post":{"summary":"Add a deal","description":"Adds a new deal. All deals created through the Pipedrive API will have a `origin` set to `API`. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the dealFields and look for `key` values. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/creating-a-deal\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">adding a deal</a>.","operationId":"addDeal","tags":["Deals"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"title":"addDealRequest","allOf":[{"$ref":"#/components/schemas/s_attr_deal_title"},{"title":"requredTitleParameter","type":"object","required":["title"]},{"$ref":"#/components/schemas/s_deal_request_cru"},{"$ref":"#/components/schemas/s_deal_request_cru_basic"}]}}}},"responses":{"201":{"description":"Success Adding a deal","content":{"application/json":{"schema":{"title":"addDealResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_deal_non_strict"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_2E_U_S_P"}}}]}}}}}},"delete":{"summary":"Delete multiple deals in bulk","description":"Marks multiple deals as deleted. After 30 days, the deals will be permanently deleted.","operationId":"deleteDeals","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_ids"}],"responses":{"200":{"description":"Delete multiple deals in bulk","content":{"application/json":{"schema":{"title":"deleteDealsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted_list"}}}]}}}}}}},"/deals/search":{"get":{"summary":"Search deals","description":"Searches all deals by title, notes and/or custom fields. This endpoint is a wrapper of [/v1/itemSearch](../../fintesk/api/v1#tag/ItemSearch) with a narrower OAuth scope. Found deals can be filtered by the person ID and the organization ID.","operationId":"searchDeals","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_is_term"},{"$ref":"#/components/parameters/p_query_deal_fields"},{"$ref":"#/components/parameters/p_query_is_exact_match"},{"$ref":"#/components/parameters/p_query_is_person_id"},{"$ref":"#/components/parameters/p_query_is_organization_id"},{"$ref":"#/components/parameters/p_query_status"},{"$ref":"#/components/parameters/p_query_is_start"},{"$ref":"#/components/parameters/p_query_limit"}],"responses":{"200":{"description":"Success Searching deals","content":{"application/json":{"schema":{"title":"searchDealsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"object","properties":{"items":{"type":"array","description":"The array of deals","items":{"allOf":[{"$ref":"#/components/schemas/s_search_result_score"},{"type":"object","properties":{"item":{"$ref":"#/components/schemas/s_search_item_deal"}}}]}}}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}}},"/deals/summary":{"get":{"summary":"Get deals summary","description":"Returns a summary of all the deals.","operationId":"getDealsSummary","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_deal_filter_id"},{"$ref":"#/components/parameters/p_query_deal_user_id"},{"$ref":"#/components/parameters/p_query_deal_stage_id"}],"responses":{"200":{"description":"Success Getting the summary of the deals","content":{"application/json":{"schema":{"title":"getDealsSummaryResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_deals_summary"}}}]}}}}}}},"/deals/timeline":{"get":{"summary":"Get deals timeline","deprecated":true,"description":"Returns open and won deals, grouped by a defined interval of time set in a date-type dealField (`field_key`)  - e.g. when month is the chosen interval,  and 3 months are asked starting from January 1st, 2023,  deals are returned grouped into 3 groups - January, February and March - based on the value of the given `field_key`.","operationId":"getDealsTimeline","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_deal_start_date"},{"$ref":"#/components/parameters/p_query_deal_interval"},{"$ref":"#/components/parameters/p_query_deal_amount"},{"$ref":"#/components/parameters/p_query_deal_field_key"},{"$ref":"#/components/parameters/p_query_deal_user_id"},{"$ref":"#/components/parameters/p_query_deal_pipeline_id"},{"$ref":"#/components/parameters/p_query_filter_id"},{"$ref":"#/components/parameters/p_query_deal_exclude_deals"},{"$ref":"#/components/parameters/p_query_pipeline_totals_convert_currency"}],"responses":{"200":{"description":"Get open and won deals, grouped by the defined interval of time","content":{"application/json":{"schema":{"title":"getDealsTimelineResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_deals_timeline_grouped"}}}]}}}}}}},"/deals/{id}":{"delete":{"summary":"Delete a deal","description":"Marks a deal as deleted. After 30 days, the deal will be permanently deleted.","operationId":"deleteDeal","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Delete a deal","content":{"application/json":{"schema":{"title":"deleteDealResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted"}}}]}}}}}},"get":{"summary":"Get details of a deal","description":"Returns the details of a specific deal. Note that this also returns some additional fields which are not present when asking for all deals – such as deal age and stay in pipeline stages. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of dealFields. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/getting-details-of-a-deal\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">getting details of a deal</a>.","operationId":"getDeal","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success getting a deal by it\'s ID","content":{"application/json":{"schema":{"title":"getDealResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_deal"},"additional_data":{"allOf":[{"type":"object"}]},"related_objects":{"$ref":"#/components/schemas/s_related_objects_2E_U_S_P"}}}]}}}}}},"put":{"summary":"Update a deal","description":"Updates the properties of a deal. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/updating-a-deal\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">updating a deal</a>.","operationId":"updateDeal","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"title":"updateDealRequest","type":"object","allOf":[{"$ref":"#/components/schemas/s_attr_deal_title"},{"$ref":"#/components/schemas/s_deal_request_cru"},{"$ref":"#/components/schemas/s_deal_request_cru_basic"}]}}}},"responses":{"200":{"description":"Success Updating a deal","content":{"application/json":{"schema":{"title":"UpdateDealResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_deal_non_strict"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_2E_U_S_P"}}}]}}}}}}},"/deals/{id}/activities":{"get":{"summary":"List activities associated with a deal","description":"Lists activities associated with a deal.","operationId":"getDealActivities","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_activity_done"},{"$ref":"#/components/parameters/p_query_activity_exclude"}],"responses":{"200":{"description":"Success listing activities associated with a deal","content":{"application/json":{"schema":{"title":"getDealActivitiesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"title":"activityResponseObject","allOf":[{"$ref":"#/components/schemas/s_activity_extended"},{"$ref":"#/components/schemas/s_activity"}]},"description":"The array of activities"},"additional_data":{"title":"activityDistributionDataWithAdditionalData","allOf":[{"$ref":"#/components/schemas/s_additional_data_pagination"}]},"related_objects":{"$ref":"#/components/schemas/s_related_objects_3E_U"}}}]}}}}}}},"/deals/{id}/flow":{"get":{"summary":"List updates about a deal","description":"Lists updates about a deal.","operationId":"getDealUpdates","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_all_changes"},{"$ref":"#/components/parameters/p_query_deal_items"}],"responses":{"200":{"description":"Get the deal updates","content":{"application/json":{"schema":{"title":"getDealUpdatesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"type":"object","properties":{"object":{"type":"string","description":"The type of the deal update. (Possible object types - dealChange, note, activity, mailMessage, invoice, document, file)"},"timestamp":{"type":"string","description":"The creation date and time of the update"},"data":{"type":"object","description":"The data related to the update"}}}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_3E_U"}}}]}}}}}}},"/deals/{id}/persons":{"get":{"summary":"List all persons associated with a deal","description":"Lists all persons associated with a deal, regardless of whether the person is the primary contact of the deal, or added as a participant.","operationId":"getDealPersons","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"}],"responses":{"200":{"description":"Success listing all persons associated with a deal","content":{"application/json":{"schema":{"title":"listPersonsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"type":"object","title":"personItem","allOf":[{"$ref":"#/components/schemas/s_person_item"},{"$ref":"#/components/schemas/s_person_additional_info"}]},"description":"The array of persons"},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_O_U"}}}]}}}}}}},"/deals/{id}/products":{"get":{"summary":"List products attached to a deal","description":"Lists products attached to a deal.","operationId":"getDealProducts","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_deal_include_product_data"}],"responses":{"200":{"description":"Success listing products attached to a deal","content":{"application/json":{"schema":{"title":"listProductsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"The array of products","items":{"$ref":"#/components/schemas/s_deal_product_extended"}},"additional_data":{"allOf":[{"$ref":"#/components/schemas/s_deal_product_totals"},{"$ref":"#/components/schemas/s_additional_data_pagination"}]},"related_objects":{"$ref":"#/components/schemas/s_related_objects_USER"}}}]}}}}}},"post":{"summary":"Add a product to a deal","description":"Adds a product to a deal, creating a new item called a deal-product.","operationId":"addDealProduct","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"title":"addDealProductRequest","type":"object","allOf":[{"type":"object","title":"dealProductRequestBasic","required":["product_id","item_price","quantity"]},{"$ref":"#/components/schemas/s_deal_product_request"}]}}}},"responses":{"200":{"description":"Success Adding a product to a deal","content":{"application/json":{"schema":{"title":"getAddProductAttachementResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"description":"The added product object attached to the deal","allOf":[{"allOf":[{"allOf":[{"title":"basicDealProductRequest","type":"object","allOf":[{"$ref":"#/components/schemas/s_product_response"}]},{"$ref":"#/components/schemas/s_deal_product_basic"}]},{"$ref":"#/components/schemas/prod_attr_product_attachment_id"}]}]}}}]}}}}}}},"/deals/{id}/products/{product_attachment_id}":{"put":{"summary":"Update the product attached to a deal","description":"Updates the details of the product that has been attached to a deal.","operationId":"updateDealProduct","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_path_product_attachment_id"}],"requestBody":{"content":{"application/json":{"schema":{"title":"UpdateDealProductRequest","type":"object","allOf":[{"$ref":"#/components/schemas/s_deal_product_request"}]}}}},"responses":{"200":{"description":"Update product attachment details","content":{"application/json":{"schema":{"title":"getProductAttachementResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"description":"The updated product object attached to the deal","allOf":[{"title":"basicDealProductRequest","type":"object"},{"$ref":"#/components/schemas/s_product_response"},{"$ref":"#/components/schemas/s_deal_product_basic"}]}}}]}}}}}},"delete":{"summary":"Delete an attached product from a deal","description":"Deletes a product attachment from a deal, using the `product_attachment_id`.","operationId":"deleteDealProduct","tags":["Deals"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_path_product_attachment_id"}],"responses":{"200":{"description":"Delete an attached product from a deal","content":{"application/json":{"schema":{"title":"deleteDealProductResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted"}}}]}}}}}}},"/dealFields":{"get":{"summary":"Get all deal fields","description":"Returns data about all deal fields.","operationId":"getDealFields","parameters":[{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_start"}],"tags":["DealFields"],"security":[{"bearerAuth":[]}],"responses":{"200":{"description":"Success getting all deal fields","content":{"application/json":{"schema":{"title":"fieldsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"data":{"$ref":"#/components/schemas/s_field"}}}]}}}}}},"post":{"summary":"Add a new deal field","description":"Adds a new deal field. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">adding a new custom field</a>.","operationId":"addDealField","tags":["DealFields"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"title":"createFieldRequest","allOf":[{"$ref":"#/components/schemas/s_field_post_body"}]}}}},"responses":{"200":{"description":"Success adding a new deal field","content":{"application/json":{"schema":{"title":"fieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field"}}}]}}}}}},"delete":{"summary":"Delete multiple deal fields in bulk","description":"Marks multiple deal fields as deleted.","operationId":"deleteDealFields","tags":["DealFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_ids"}],"responses":{"200":{"description":"Success deleting multiple deal fields in bulk","content":{"application/json":{"schema":{"title":"deleteFieldsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted_list"}}}]}}}}}}},"/dealFields/{id}":{"get":{"summary":"Get one deal field","description":"Returns data about a specific deal field.","operationId":"getDealField","tags":["DealFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_field_id"}],"responses":{"200":{"description":"Success getting one deal field","content":{"application/json":{"schema":{"title":"fieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field"}}}]}}}}}},"delete":{"summary":"Delete a deal field","description":"Marks a field as deleted. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/deleting-a-custom-field\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">deleting a custom field</a>.","operationId":"deleteDealField","tags":["DealFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_field_id"}],"responses":{"200":{"description":"Success Deleting a deal field","content":{"application/json":{"schema":{"title":"deleteFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field_response_delete_id"}}}]}}}}}},"put":{"summary":"Update a deal field","description":"Updates a deal field. For more information, see the tutorial for <a href=\\" https://pipedrive.readme.io/docs/updating-custom-field-value \\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">updating custom fields\' values</a>.","operationId":"updateDealField","tags":["DealFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_field_id"}],"requestBody":{"content":{"application/json":{"schema":{"title":"updateFieldRequest","allOf":[{"$ref":"#/components/schemas/s_field_put_body"}]}}}},"responses":{"200":{"description":"Success updating a deal field","content":{"application/json":{"schema":{"title":"fieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field"}}}]}}}}}}},"/filters":{"delete":{"summary":"Delete multiple filters in bulk","description":"Marks multiple filters as deleted.","operationId":"deleteFilters","tags":["Filters"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_ids"}],"responses":{"200":{"description":"Success Deleting multiple filters in bulk","content":{"application/json":{"schema":{"title":"deleteFiltersResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted_list"}}}]}}}}}},"get":{"summary":"Get all filters","description":"Returns data about all filters.","operationId":"getFilters","tags":["Filters"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_filter_type"}],"responses":{"200":{"description":"Success Getting all filters","content":{"application/json":{"schema":{"title":"getFiltersResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"properties":{"data":{"type":"array","description":"The array of filters","items":{"$ref":"#/components/schemas/s_filter_base"}}}}]}}}}}},"post":{"summary":"Add a new filter","description":"Adds a new filter, returns the ID upon success. Note that in the conditions JSON object only one first-level condition group is supported, and it must be glued with \'AND\', and only two second level condition groups are supported of which one must be glued with \'AND\' and the second with \'OR\'. Other combinations do not work (yet) but the syntax supports introducing them in future. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/adding-a-filter\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">adding a filter</a>.","operationId":"addFilter","tags":["Filters"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_filter_request_add"}}}},"responses":{"200":{"description":"Success Adding a new filter","content":{"application/json":{"schema":{"title":"postFilterResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_filter_w_conditions"}}}]}}}}}}},"/filters/helpers":{"get":{"summary":"Get all filter helpers","description":"Returns all supported filter helpers. It helps to know what conditions and helpers are available when you want to <a href=\\"/docs/api/v1/Filters#addFilter\\">add</a> or <a href=\\"/docs/api/v1/Filters#updateFilter\\">update</a> filters. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/adding-a-filter\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">adding a filter</a>.","operationId":"getFilterHelpers","tags":["Filters"],"security":[{"bearerAuth":[]}],"responses":{"200":{"description":"Success Getting all filter helpers","content":{"application/json":{"schema":{"title":"getFilterHelpersResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"object","description":"The rules for filters"}}}]}}}}}}},"/filters/{id}":{"delete":{"summary":"Delete a filter","description":"Marks a filter as deleted.","operationId":"deleteFilter","tags":["Filters"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success Deleting a filter","content":{"application/json":{"schema":{"title":"deleteFilterResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted"}}}]}}}}}},"get":{"summary":"Get one filter","description":"Returns data about a specific filter. Note that this also returns the condition lines of the filter.","operationId":"getFilter","tags":["Filters"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success Getting one filter","content":{"application/json":{"schema":{"title":"getFilterResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_filter_base"}}}]}}}}}},"put":{"summary":"Update a filter","description":"Updates an existing filter.","operationId":"updateFilter","tags":["Filters"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_filter_request_upd"}}}},"responses":{"200":{"description":"Success Updating a filter","content":{"application/json":{"schema":{"title":"postFilterResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_filter_w_conditions"}}}]}}}}}}},"/itemSearch":{"get":{"summary":"Perform a search from multiple item types","description":"Performs a search from your choice of item types and fields.","operationId":"searchItem","tags":["ItemSearch"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_is_item_types"},{"$ref":"#/components/parameters/p_query_is_fields"},{"$ref":"#/components/parameters/p_query_is_search_for_related_items"},{"$ref":"#/components/parameters/p_query_is_include_fields"},{"$ref":"#/components/parameters/p_query_is_term"},{"$ref":"#/components/parameters/p_query_is_exact_match"},{"$ref":"#/components/parameters/p_query_is_start"},{"$ref":"#/components/parameters/p_query_limit"}],"responses":{"200":{"description":"Success searching from multiple item types","content":{"application/json":{"schema":{"title":"searchItemResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"object","properties":{"items":{"type":"array","description":"The array of found items","items":{"allOf":[{"$ref":"#/components/schemas/s_search_result_score"},{"type":"object","properties":{"item":{"type":"object","description":"Item"}}}]}},"related_items":{"type":"array","description":"The array of related items if `search_for_related_items` was enabled","items":{"allOf":[{"$ref":"#/components/schemas/s_search_result_score"},{"type":"object","properties":{"item":{"type":"object","description":"Item"}}}]}}}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}}},"/itemSearch/field":{"get":{"summary":"Perform a search using a specific field from an item type","description":"Performs a search from the values of a specific field. Results can either be the distinct values of the field (useful for searching autocomplete field values), or the IDs of actual items (deals, leads, persons, organizations or products).","operationId":"searchItemByField","tags":["ItemSearch"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_is_field_type"},{"$ref":"#/components/parameters/p_query_is_field_key"},{"$ref":"#/components/parameters/p_query_is_return_item_ids"},{"$ref":"#/components/parameters/p_query_is_term"},{"$ref":"#/components/parameters/p_query_is_exact_match"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"}],"responses":{"200":{"description":"Success searching a specific field","content":{"application/json":{"schema":{"title":"searchItemByFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"The array of results","items":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the item"},"$field_key":{"description":"The value of the searched `field_key`"}}}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}}},"/notes":{"get":{"summary":"Get all notes","description":"Returns all notes.","operationId":"getNotes","deprecated":true,"tags":["Notes"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_note_user_id"},{"$ref":"#/components/parameters/p_query_note_deal_id"},{"$ref":"#/components/parameters/p_query_note_person_id"},{"$ref":"#/components/parameters/p_query_note_org_id"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_note_sort"},{"$ref":"#/components/parameters/p_query_note_start_date"},{"$ref":"#/components/parameters/p_query_note_end_date"},{"$ref":"#/components/parameters/p_query_note_pinned_to_deal_flag"},{"$ref":"#/components/parameters/p_query_note_pinned_to_organization_flag"},{"$ref":"#/components/parameters/p_query_note_pinned_to_person_flag"}],"responses":{"200":{"description":"Success Getting all notes","content":{"application/json":{"schema":{"title":"getNotesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"The array of notes","items":{"$ref":"#/components/schemas/s_note_w_objects"}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_3E_U"}}}]}}}}}},"post":{"summary":"Add a note","description":"Adds a new note.","operationId":"addNote","deprecated":true,"tags":["Notes"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_note_request"}}}},"responses":{"200":{"description":"Success Adding a note","content":{"application/json":{"schema":{"title":"addNoteResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_note_w_objects"}}}]}}}}}}},"/notes/{id}":{"delete":{"summary":"Delete a note","description":"Deletes a specific note.","operationId":"deleteNote","deprecated":true,"tags":["Notes"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success Deleting a note","content":{"application/json":{"schema":{"title":"deleteNoteResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"boolean","description":"If the response is successful or not"}}}]}}}}}},"get":{"summary":"Get one note","description":"Returns details about a specific note.","operationId":"getNote","deprecated":true,"tags":["Notes"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success Getting one note","content":{"application/json":{"schema":{"title":"getNoteResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_note_w_objects"}}}]}}}}}},"put":{"summary":"Update a note","description":"Updates a note.","operationId":"updateNote","deprecated":true,"tags":["Notes"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_note_request"}}}},"responses":{"200":{"description":"Success Updating a note","content":{"application/json":{"schema":{"title":"updateNoteResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_note_w_objects"}}}]}}}}}}},"/notes/{id}/comments":{"get":{"summary":"Get all comments for a note","description":"Returns all comments associated with a note.","operationId":"getNoteComments","deprecated":true,"tags":["Notes"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_start"}],"responses":{"200":{"description":"Success Getting all comments for a note","content":{"application/json":{"schema":{"title":"getCommentsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"The array of comments","items":{"$ref":"#/components/schemas/s_note_w_comment"}},"related_objects":{"$ref":"#/components/schemas/s_related_objects_3E_U"},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}},"post":{"summary":"Add a comment to a note","description":"Adds a new comment to a note.","operationId":"addNoteComment","deprecated":true,"tags":["Notes"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"allOf":[{"title":"CommentPostPutObject","type":"object","required":["content"]},{"$ref":"#/components/schemas/s_note_request_content"}]}}}},"responses":{"200":{"description":"Success Adding a comment to a note","content":{"application/json":{"schema":{"title":"oneCommentResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_note_w_comment"}}}]}}}}}}},"/notes/{id}/comments/{commentId}":{"get":{"summary":"Get one comment","description":"Returns the details of a comment.","operationId":"getComment","deprecated":true,"tags":["Notes"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_path_note_comment_id"}],"responses":{"200":{"description":"Success Getting one comment","content":{"application/json":{"schema":{"title":"oneCommentResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_note_w_comment"}}}]}}}}}},"put":{"summary":"Update a comment related to a note","description":"Updates a comment related to a note.","operationId":"updateCommentForNote","deprecated":true,"tags":["Notes"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_path_note_comment_id"}],"requestBody":{"content":{"application/json":{"schema":{"allOf":[{"title":"CommentPostPutObject","type":"object","required":["content"]},{"$ref":"#/components/schemas/s_note_request_content"}]}}}},"responses":{"200":{"description":"Success Updating a comment related to a note","content":{"application/json":{"schema":{"title":"oneCommentResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_note_w_comment"}}}]}}}}}},"delete":{"summary":"Delete a comment related to a note","description":"Deletes a comment.","operationId":"deleteComment","deprecated":true,"tags":["Notes"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_path_note_comment_id"}],"responses":{"200":{"description":"Success Deleting a comment related to a note","content":{"application/json":{"schema":{"title":"deleteCommentResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"boolean","description":"If the response is successful or not"}}}]}}}}}}},"/noteFields":{"get":{"summary":"Get all note fields","description":"Returns data about all note fields.","operationId":"getNoteFields","deprecated":true,"tags":["NoteFields"],"security":[{"bearerAuth":[]}],"responses":{"200":{"description":"Success getting all note fields","content":{"application/json":{"schema":{"title":"getNoteFieldsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":[{"$ref":"#/components/schemas/s_field"}]},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}}},"/organizations":{"delete":{"summary":"Delete multiple organizations in bulk","description":"Marks multiple organizations as deleted. After 30 days, the organizations will be permanently deleted.","operationId":"deleteOrganizations","tags":["Organizations"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_ids"}],"responses":{"200":{"description":"Success","content":{"application/json":{"schema":{"title":"deleteOrganizationsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted_list"}}}]}}}}}},"get":{"summary":"Get all organizations","description":"Returns all organizations.","operationId":"getOrganizations","tags":["Organizations"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_org_user_id"},{"$ref":"#/components/parameters/p_query_filter_id"},{"$ref":"#/components/parameters/p_query_first_char"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_sort"}],"responses":{"200":{"description":"Success Getting all organizations","content":{"application/json":{"schema":{"title":"getOrganizationsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"The array of organizations","items":{"$ref":"#/components/schemas/s_organization_base"}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_O_U_Pic"}}}]}}}}}},"post":{"summary":"Add an organization","description":"Adds a new organization. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the organizationFields and look for `key` values. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/adding-an-organization\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">adding an organization</a>.","operationId":"addOrganization","tags":["Organizations"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"title":"addOrganizationRequest","allOf":[{"$ref":"#/components/schemas/s_attr_organization_name"},{"type":"object","required":["name"],"properties":{"add_time":{"type":"string","description":"The optional creation date & time of the organization in UTC. Requires admin user API token. Format: YYYY-MM-DD HH:MM:SS"}}},{"title":"basicOrganization","type":"object","properties":{"allOf":[{"$ref":"../../Organizations/schemas/s_attr_organization_owner_id.yaml"},{"$ref":"../../_components/schemas_entities/s_attr_label_array.yaml"},{"type":"object"}]}}]}}}},"responses":{"201":{"description":"Success Adding an organization","content":{"application/json":{"schema":{"title":"addOrganizationResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_organization_w_edit_name"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_O_U_Pic"}}}]}}}}}}},"/organizations/search":{"get":{"summary":"Search organizations","description":"Searches all organizations by name, address, notes and/or custom fields. This endpoint is a wrapper of [/v1/itemSearch](../../fintesk/api/v1#tag/ItemSearch) with a narrower OAuth scope.","operationId":"searchOrganization","tags":["Organizations"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_is_term"},{"$ref":"#/components/parameters/p_query_org_fields"},{"$ref":"#/components/parameters/p_query_is_exact_match"},{"$ref":"#/components/parameters/p_query_is_start"},{"$ref":"#/components/parameters/p_query_limit"}],"responses":{"200":{"description":"Success Searching organizations","content":{"application/json":{"schema":{"title":"searchOrganizationResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"object","properties":{"items":{"type":"array","description":"The array of found items","items":{"allOf":[{"$ref":"#/components/schemas/s_search_result_score"},{"type":"object","properties":{"item":{"$ref":"#/components/schemas/s_search_item_organization"}}}]}}}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}}},"/organizations/{id}":{"delete":{"summary":"Delete an organization","description":"Marks an organization as deleted. After 30 days, the organization will be permanently deleted.","operationId":"deleteOrganization","tags":["Organizations"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success deleting an organization","content":{"application/json":{"schema":{"title":"deleteOrganizationResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted"}}}]}}}}}},"get":{"summary":"Get details of an organization","description":"Returns the details of an organization. Note that this also returns some additional fields which are not present when asking for all organizations. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of organizationFields.","operationId":"getOrganization","tags":["Organizations"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success getting details of an organization","content":{"application/json":{"schema":{"title":"getOrganizationResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_organization_item"},"additional_data":{"allOf":[{"$ref":"#/components/schemas/s_organization_item_follower"},{"$ref":"#/components/schemas/s_additional_data_pagination"}]},"related_objects":{"$ref":"#/components/schemas/s_related_objects_O_U_Pic"}}}]}}}}}},"put":{"summary":"Update an organization","description":"Updates the properties of an organization.","operationId":"updateOrganization","tags":["Organizations"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"title":"updateOrganizationRequest","allOf":[{"$ref":"#/components/schemas/s_attr_organization_name"},{"title":"basicOrganization","type":"object","properties":{"allOf":[{"$ref":"../../Organizations/schemas/s_attr_organization_owner_id.yaml"},{"$ref":"../../_components/schemas_entities/s_attr_label_array.yaml"},{"type":"object"}]}}]}}}},"responses":{"200":{"description":"Success updating an organization","content":{"application/json":{"schema":{"title":"updateOrganizationResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_organization_base"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_O_U_Pic"}}}]}}}}}}},"/organizations/{id}/activities":{"get":{"summary":"List activities associated with an organization","description":"Lists activities associated with an organization.","operationId":"getOrganizationActivities","tags":["Organizations"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_activity_done"},{"$ref":"#/components/parameters/p_query_activity_exclude"}],"responses":{"200":{"description":"Success listing activities associated with an organization","content":{"application/json":{"schema":{"title":"getAssociatedActivitiesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"title":"activityResponseObject","allOf":[{"$ref":"#/components/schemas/s_activity_extended"},{"$ref":"#/components/schemas/s_activity"}]},"description":"The array of activities"},"additional_data":{"title":"activityDistributionDataWithAdditionalData","allOf":[{"$ref":"#/components/schemas/s_additional_data_pagination"}]}}}]}}}}}}},"/organizations/{id}/deals":{"get":{"summary":"List deals associated with an organization","description":"Lists deals associated with an organization.","operationId":"getOrganizationDeals","tags":["Organizations"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_status"},{"$ref":"#/components/parameters/p_query_sort"}],"responses":{"200":{"description":"Success Listing deals associated with an organization","content":{"application/json":{"schema":{"title":"getAssociatedDealsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"The array of deals","items":{"$ref":"#/components/schemas/s_deal_non_strict"}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_2E_U_S_P"}}}]}}}}}}},"/organizations/{id}/files":{"get":{"summary":"List files attached to an organization","description":"Lists files associated with an organization.","operationId":"getOrganizationFiles","deprecated":true,"tags":["Organizations"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_org_sort"},{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"}],"responses":{"200":{"description":"Success Listing files attached to an organization","content":{"application/json":{"schema":{"title":"getAssociatedFilesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"$ref":"#/components/schemas/s_file"},"description":"The array of files"},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}}},"/organizations/{id}/flow":{"get":{"summary":"List updates about an organization","description":"Lists updates about an organization.","operationId":"getOrganizationUpdates","tags":["Organizations"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_all_changes"},{"$ref":"#/components/parameters/p_query_org_items"}],"responses":{"200":{"description":"Get the organization updates","content":{"application/json":{"schema":{"title":"getAssociatedUpdatesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"type":"object","properties":{"object":{"type":"string","description":"The type of the person update. (Possible object types - organizationChange, dealChange, file, activity)"},"timestamp":{"type":"string","description":"The creation date and time of the update"},"data":{"type":"object","description":"The data related to the update"}}}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_O_U"}}}]}}}}}}},"/organizations/{id}/persons":{"get":{"summary":"List persons of an organization","description":"Lists persons associated with an organization.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.","operationId":"getOrganizationPersons","tags":["Organizations"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"}],"responses":{"200":{"description":"Success Listing persons of an organization","content":{"application/json":{"schema":{"title":"listPersonsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"type":"object","title":"personItem","allOf":[{"$ref":"#/components/schemas/s_person_item"},{"$ref":"#/components/schemas/s_person_additional_info"}]},"description":"The array of persons"},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_O_U"}}}]}}}}}}},"/organizationFields":{"get":{"summary":"Get all organization fields","description":"Returns data about all organization fields.","operationId":"getOrganizationFields","parameters":[{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_start"}],"tags":["OrganizationFields"],"security":[{"bearerAuth":[]}],"responses":{"200":{"description":"Success getting all organization fields","content":{"application/json":{"schema":{"title":"getOrganizationFieldsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":[{"$ref":"#/components/schemas/s_field"}]},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}},"post":{"summary":"Add a new organization field","description":"Adds a new organization field. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">adding a new custom field</a>.","operationId":"addOrganizationField","tags":["OrganizationFields"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"title":"createFieldRequest","allOf":[{"$ref":"#/components/schemas/s_field_post_body"}]}}}},"responses":{"200":{"description":"Success adding a new organization field","content":{"application/json":{"schema":{"title":"addOrganizationFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field"}}}]}}}}}},"delete":{"summary":"Delete multiple organization fields in bulk","description":"Marks multiple fields as deleted.","operationId":"deleteOrganizationFields","tags":["OrganizationFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_ids"}],"responses":{"200":{"description":"Success deleting multiple organization fields in bulk","content":{"application/json":{"schema":{"title":"deleteOrganizationFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted_list"}}}]}}}}}}},"/organizationFields/{id}":{"get":{"summary":"Get one organization field","description":"Returns data about a specific organization field.","operationId":"getOrganizationField","tags":["OrganizationFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_field_id"}],"responses":{"200":{"description":"Success getting one organization field","content":{"application/json":{"schema":{"title":"getOrganizationFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"data":{"$ref":"#/components/schemas/s_field"}}}]}}}}}},"delete":{"summary":"Delete an organization field","description":"Marks a field as deleted. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/deleting-a-custom-field\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">deleting a custom field</a>.","operationId":"deleteOrganizationField","tags":["OrganizationFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_field_id"}],"responses":{"200":{"description":"Success deleting an organization field","content":{"application/json":{"schema":{"title":"deleteOrganizationFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field_response_delete_id"}}}]}}}}}},"put":{"summary":"Update an organization field","description":"Updates an organization field. For more information, see the tutorial for <a href=\\" https://pipedrive.readme.io/docs/updating-custom-field-value \\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">updating custom fields\' values</a>.","operationId":"updateOrganizationField","tags":["OrganizationFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_field_id"}],"requestBody":{"content":{"application/json":{"schema":{"title":"updateFieldRequest","allOf":[{"$ref":"#/components/schemas/s_field_put_body"}]}}}},"responses":{"200":{"description":"Success updating an organization field","content":{"application/json":{"schema":{"title":"updateOrganizationFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field"}}}]}}}}}}},"/persons":{"delete":{"summary":"Delete multiple persons in bulk","description":"Marks multiple persons as deleted. After 30 days, the persons will be permanently deleted.","operationId":"deletePersons","tags":["Persons"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_ids"}],"responses":{"200":{"description":"Success","content":{"application/json":{"schema":{"title":"deletePersonsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted_list"}}}]}}}}}},"get":{"summary":"Get all persons","description":"Returns all persons.","operationId":"getPersons","tags":["Persons"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_person_user_id"},{"$ref":"#/components/parameters/p_query_filter_id"},{"$ref":"#/components/parameters/p_query_first_char"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_sort"}],"responses":{"200":{"description":"Success Getting all persons","content":{"application/json":{"schema":{"title":"getPersonsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"allOf":[{"$ref":"#/components/schemas/s_person_item"},{"$ref":"#/components/schemas/s_person_additional_info"}]},"description":"The array of persons"},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_O_U_Pic"}}}]}}}}}},"post":{"summary":"Add a person","description":"Adds a new person. Note that you can supply additional custom fields along with the request that are not described here. These custom fields are different for each Pipedrive account and can be recognized by long hashes as keys. To determine which custom fields exists, fetch the personFields and look for `key` values.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also accept and return the `data.marketing_status` field.","operationId":"addPerson","tags":["Persons"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"title":"addPersonRequest","allOf":[{"$ref":"#/components/schemas/s_person_request"}]}}}},"responses":{"201":{"description":"Success","content":{"application/json":{"schema":{"title":"addPersonResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"object","title":"personItem","allOf":[{"$ref":"#/components/schemas/s_person_item"},{"$ref":"#/components/schemas/s_person_additional_info"}]},"related_objects":{"$ref":"#/components/schemas/s_related_objects_USER"}}}]}}}}}}},"/persons/search":{"get":{"summary":"Search persons","description":"Searches all persons by name, email, phone, notes and/or custom fields. This endpoint is a wrapper of [/v1/itemSearch](../../fintesk/api/v1#tag/ItemSearch) with a narrower OAuth scope. Found persons can be filtered by organization ID.","operationId":"searchPersons","tags":["Persons"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_is_term"},{"$ref":"#/components/parameters/p_query_fields"},{"$ref":"#/components/parameters/p_query_is_exact_match"},{"$ref":"#/components/parameters/p_query_is_organization_id"},{"$ref":"#/components/parameters/p_query_include_fields"},{"$ref":"#/components/parameters/p_query_is_start"},{"$ref":"#/components/parameters/p_query_limit"}],"responses":{"200":{"description":"Success Searching persons","content":{"application/json":{"schema":{"title":"searchPersonsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"object","properties":{"items":{"type":"array","description":"The array of found items","items":{"allOf":[{"$ref":"#/components/schemas/s_search_result_score"},{"type":"object","properties":{"item":{"$ref":"#/components/schemas/s_search_item_person"}}}]}}}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}}},"/persons/{id}":{"delete":{"summary":"Delete a person","description":"Marks a person as deleted. After 30 days, the person will be permanently deleted.","operationId":"deletePerson","tags":["Persons"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success","content":{"application/json":{"schema":{"title":"deletePersonResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted"}}}]}}}}}},"get":{"summary":"Get details of a person","description":"Returns the details of a person. Note that this also returns some additional fields which are not present when asking for all persons. Also note that custom fields appear as long hashes in the resulting data. These hashes can be mapped against the `key` value of personFields.","operationId":"getPerson","tags":["Persons"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success Getting details of a person","content":{"application/json":{"schema":{"title":"getPersonResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"object","title":"personItem","allOf":[{"$ref":"#/components/schemas/s_person_item"},{"$ref":"#/components/schemas/s_person_additional_info"}]},"additional_data":{"allOf":[{"type":"object"}]},"related_objects":{"$ref":"#/components/schemas/s_related_objects_O_U_Pic"}}}]}}}}}},"put":{"summary":"Update a person","description":"Updates the properties of a person.  For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/updating-a-person\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">updating a person</a>.","operationId":"updatePerson","tags":["Persons"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"title":"updatePersonRequest","allOf":[{"$ref":"#/components/schemas/s_person_request"}]}}}},"responses":{"200":{"description":"Success","content":{"application/json":{"schema":{"title":"updatePersonResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"object","title":"personItem","allOf":[{"$ref":"#/components/schemas/s_person_item"},{"$ref":"#/components/schemas/s_person_additional_info"}]},"related_objects":{"$ref":"#/components/schemas/s_related_objects_USER"}}}]}}}}}}},"/persons/{id}/activities":{"get":{"summary":"List activities associated with a person","description":"Lists activities associated with a person.","operationId":"getPersonActivities","tags":["Persons"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_activity_done"},{"$ref":"#/components/parameters/p_query_activity_exclude"}],"responses":{"200":{"description":"Success","content":{"application/json":{"schema":{"title":"getAssociatedActivitiesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"title":"activityResponseObject","allOf":[{"$ref":"#/components/schemas/s_activity_extended"},{"$ref":"#/components/schemas/s_activity"}]},"description":"The array of activities"},"additional_data":{"title":"activityDistributionDataWithAdditionalData","allOf":[{"$ref":"#/components/schemas/s_additional_data_pagination"}]}}}]}}}}}}},"/persons/{id}/deals":{"get":{"summary":"List deals associated with a person","description":"Lists deals associated with a person.","operationId":"getPersonDeals","tags":["Persons"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_status"},{"$ref":"#/components/parameters/p_query_sort"}],"responses":{"200":{"description":"Success Listing deals associated with a person","content":{"application/json":{"schema":{"title":"getAssociatedDealsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"The array of deals","items":{"$ref":"#/components/schemas/s_deal_non_strict"}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_2E_U_S_P"}}}]}}}}}}},"/persons/{id}/flow":{"get":{"summary":"List updates about a person","description":"Lists updates about a person.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint\'s response will also include updates for the `marketing_status` field.","operationId":"getPersonUpdates","tags":["Persons"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_all_changes"},{"$ref":"#/components/parameters/p_query_person_items"}],"responses":{"200":{"description":"Success Listing updates about a person","content":{"application/json":{"schema":{"title":"getAssociatedPersonUpdatesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"type":"object","properties":{"object":{"type":"string","description":"The type of the person update."},"timestamp":{"type":"string","description":"The creation date and time of the update"},"data":{"type":"object","description":"The data related to the update"}}}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_3E_U"}}}]}}}}}}},"/persons/{id}/products":{"get":{"summary":"List products associated with a person","description":"Lists products associated with a person.","operationId":"getPersonProducts","tags":["Persons"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"}],"responses":{"200":{"description":"Success Listing products associated with a person","content":{"application/json":{"schema":{"title":"getPersonProductsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"The array of deal products","items":{"$ref":"#/components/schemas/s_person_products"}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}}},"/personFields":{"get":{"summary":"Get all person fields","description":"Returns data about all person fields.<br>If a company uses the [Campaigns product](https://pipedrive.readme.io/docs/campaigns-in-pipedrive-api), then this endpoint will also return the `data.marketing_status` field.","operationId":"getPersonFields","parameters":[{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_start"}],"tags":["PersonFields"],"security":[{"bearerAuth":[]}],"responses":{"200":{"description":"Success getting all person fields","content":{"application/json":{"schema":{"title":"getPersonFieldsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"data":{"$ref":"#/components/schemas/s_field"}}}]}}}}}},"post":{"summary":"Add a new person field","description":"Adds a new person field. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">adding a new custom field</a>.","operationId":"addPersonField","tags":["PersonFields"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"title":"createFieldRequest","allOf":[{"$ref":"#/components/schemas/s_field_post_body"}]}}}},"responses":{"200":{"description":"Success adding a new person field","content":{"application/json":{"schema":{"title":"AddPersonFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field"}}}]}}}}}},"delete":{"summary":"Delete multiple person fields in bulk","description":"Marks multiple fields as deleted.","operationId":"deletePersonFields","tags":["PersonFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_ids"}],"responses":{"200":{"description":"Success deleting multiple person fields in bulk","content":{"application/json":{"schema":{"title":"deletePersonFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted_list"}}}]}}}}}}},"/personFields/{id}":{"get":{"summary":"Get one person field","description":"Returns data about a specific person field.","operationId":"getPersonField","tags":["PersonFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_field_id"}],"responses":{"200":{"description":"Success getting one person field","content":{"application/json":{"schema":{"title":"getPersonFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field"}}}]}}}}}},"delete":{"summary":"Delete a person field","description":"Marks a field as deleted. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/deleting-a-custom-field\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">deleting a custom field</a>.","operationId":"deletePersonField","tags":["PersonFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_field_id"}],"responses":{"200":{"description":"Success deleting a person field","content":{"application/json":{"schema":{"title":"deletePersonFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field_response_delete_id"}}}]}}}}}},"put":{"summary":"Update a person field","description":"Updates a person field. For more information, see the tutorial for <a href=\\" https://pipedrive.readme.io/docs/updating-custom-field-value \\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">updating custom fields\' values</a>.","operationId":"updatePersonField","tags":["PersonFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_field_id"}],"requestBody":{"content":{"application/json":{"schema":{"title":"updateFieldRequest","allOf":[{"$ref":"#/components/schemas/s_field_put_body"}]}}}},"responses":{"200":{"description":"Success updating a person field","content":{"application/json":{"schema":{"title":"updatePersonFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field"}}}]}}}}}}},"/pipelines":{"get":{"summary":"Get all pipelines","description":"Returns data about all pipelines.","operationId":"getPipelines","tags":["Pipelines"],"security":[{"bearerAuth":[]}],"responses":{"200":{"description":"Get all pipelines","content":{"application/json":{"schema":{"type":"object","title":"getPipelinesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"Pipelines array","items":{"type":"object","title":"basePipelineWithSelectedFlag","allOf":[{"$ref":"#/components/schemas/s_pipeline_base_w_selected_flag"}]}}}}]}}}}}},"post":{"summary":"Add a new pipeline","description":"Adds a new pipeline.","operationId":"addPipeline","tags":["Pipelines"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"allOf":[{"type":"object","title":"pipelineRequestRequiredName","required":["name"]},{"$ref":"#/components/schemas/s_pipeline_request"}]}}}},"responses":{"200":{"description":"Success Adding a new pipeline","content":{"application/json":{"schema":{"type":"object","title":"addPipelineResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_pipeline_base"}}}]}}}}}}},"/pipelines/{id}":{"delete":{"summary":"Delete a pipeline","description":"Marks a pipeline as deleted.","operationId":"deletePipeline","tags":["Pipelines"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success Deleting a pipeline","content":{"application/json":{"schema":{"title":"deletePipelineResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted"}}}]}}}}}},"get":{"summary":"Get one pipeline","description":"Returns data about a specific pipeline.  Also returns the summary of the deals in this pipeline across its stages.","operationId":"getPipeline","tags":["Pipelines"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_pipeline_totals_convert_currency"}],"responses":{"200":{"description":"Success Getting one pipeline","content":{"application/json":{"schema":{"type":"object","title":"getPipelineResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"object","description":"The pipeline object","title":"pipelineDetails","allOf":[{"$ref":"#/components/schemas/s_pipeline_base_w_selected_flag"}]}}}]}}}}}},"put":{"summary":"Update a pipeline","description":"Updates the properties of a pipeline.","operationId":"updatePipeline","tags":["Pipelines"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_pipeline_request"}}}},"responses":{"200":{"description":"Success Updating a pipeline","content":{"application/json":{"schema":{"type":"object","title":"updatePipelineResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"object","description":"The pipeline object","allOf":[{"$ref":"#/components/schemas/s_pipeline_base_w_selected_flag"}]}}}]}}}}}}},"/pipelines/{id}/deals":{"get":{"summary":"Get deals in a pipeline","description":"Lists deals in a specific pipeline across all its stages.","operationId":"getPipelineDeals","tags":["Pipelines"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_filter_id"},{"$ref":"#/components/parameters/p_query_pipeline_user_id"},{"$ref":"#/components/parameters/p_query_pipeline_everyone"},{"$ref":"#/components/parameters/p_query_deal_stage_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_pipeline_get_summary"},{"$ref":"#/components/parameters/p_query_pipeline_totals_convert_currency"}],"responses":{"200":{"description":"Success Get deals in a pipeline","content":{"application/json":{"schema":{"title":"getStageDealsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"The array of deals","items":{"$ref":"#/components/schemas/s_deal_strict"}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}}},"/products":{"get":{"summary":"Get all products","description":"Returns data about all products.","operationId":"getProducts","tags":["Products"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_product_user_id"},{"$ref":"#/components/parameters/p_query_filter_id"},{"$ref":"#/components/parameters/p_query_product_ids"},{"$ref":"#/components/parameters/p_query_first_char"},{"$ref":"#/components/parameters/p_query_product_get_summary"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"}],"responses":{"200":{"description":"Success Getting all products","content":{"application/json":{"schema":{"title":"getProductsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"Array containing data for all products","items":{"title":"subGetProductResponseCode200","type":"object","properties":{"data":{"$ref":"#/components/schemas/s_product_w_owner_obj"}}}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_3E_U"}}}]}}}}}},"post":{"summary":"Add a product","description":"Adds a new product to the Products inventory.  For more information, see the tutorial for <a  href=\\"https://pipedrive.readme.io/docs/adding-a-product\\"  target=\\"_blank\\" rel=\\"noopener noreferrer\\">adding a product</a>.","operationId":"addProduct","tags":["Products"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"allOf":[{"type":"object","title":"addProductRequest"},{"$ref":"#/components/schemas/s_product_request_crud"}]}}}},"responses":{"201":{"description":"Success Adding product data","content":{"application/json":{"schema":{"title":"getproductResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_product_w_owner_obj"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_3E_U"}}}]}}}}}}},"/products/{id}":{"delete":{"summary":"Delete a product","description":"Marks a product as deleted.","operationId":"deleteProduct","tags":["Products"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success Deleting a product","content":{"application/json":{"schema":{"title":"deleteProductResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted"}}}]}}}}}},"get":{"summary":"Get one product","description":"Returns data about a specific product.","operationId":"getProduct","tags":["Products"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success Getting one product","content":{"application/json":{"schema":{"title":"getproductResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_product_w_owner_obj"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_3E_U"}}}]}}}}}},"put":{"summary":"Update a product","description":"Updates product data.","operationId":"updateProduct","tags":["Products"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"allOf":[{"type":"object","title":"updateProductRequest"},{"$ref":"#/components/schemas/s_product_request_crud"}]}}}},"responses":{"200":{"description":"Updates product data","content":{"application/json":{"schema":{"title":"updateProductResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_product_w_owner_obj"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_3E_U"}}}]}}}}}}},"/products/{id}/deals":{"get":{"summary":"Get deals where a product is attached to","description":"Returns data about deals that have a product attached to it.","operationId":"getProductDeals","tags":["Products"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_status"}],"responses":{"200":{"description":"The data of deals that have a product attached","content":{"application/json":{"schema":{"title":"getAssociatedDealsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"The array of deals","items":{"$ref":"#/components/schemas/s_deal_non_strict"}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"},"related_objects":{"$ref":"#/components/schemas/s_related_objects_2E_U_S_P"}}}]}}}}}}},"/productFields":{"delete":{"summary":"Delete multiple product fields in bulk","description":"Marks multiple fields as deleted.","operationId":"deleteProductFields","tags":["ProductFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_ids"}],"responses":{"200":{"description":"Success deleting multiple product fields in bulk","content":{"application/json":{"schema":{"title":"deleteProductFieldsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted_list"}}}]}}}}}},"get":{"summary":"Get all product fields","description":"Returns data about all product fields.","operationId":"getProductFields","parameters":[{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_start"}],"tags":["ProductFields"],"security":[{"bearerAuth":[]}],"responses":{"200":{"description":"Success getting all product fields","content":{"application/json":{"schema":{"title":"getProductFieldsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"Array containing data for all product fields","items":[{"$ref":"#/components/schemas/s_field"}]},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}},"post":{"summary":"Add a new product field","description":"Adds a new product field. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/adding-a-new-custom-field\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">adding a new custom field</a>.","operationId":"addProductField","tags":["ProductFields"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_field_post_body"}}}},"responses":{"201":{"description":"Success adding a new product field","content":{"application/json":{"schema":{"title":"getProductFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field"}}}]}}}}}}},"/productFields/{id}":{"delete":{"summary":"Delete a product field","description":"Marks a product field as deleted. For more information, see the tutorial for <a href=\\"https://pipedrive.readme.io/docs/deleting-a-custom-field\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">deleting a custom field</a>.","operationId":"deleteProductField","tags":["ProductFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_field_id"}],"responses":{"200":{"description":"Success deleting a product field","content":{"application/json":{"schema":{"title":"deleteProductFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted"}}}]}}}},"410":{"description":"The product field with the specified ID does not exist or is inaccessible","content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_fail_response"}}}}}},"get":{"summary":"Get one product field","description":"Returns data about a specific product field.","operationId":"getProductField","tags":["ProductFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_field_id"}],"responses":{"200":{"description":"Success getting one product field","content":{"application/json":{"schema":{"title":"getProductFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field"}}}]}}}},"410":{"description":"The product field with the specified ID does not exist or is inaccessible","content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_fail_response"}}}}}},"put":{"summary":"Update a product field","description":"Updates a product field. For more information, see the tutorial for <a href=\\" https://pipedrive.readme.io/docs/updating-custom-field-value \\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">updating custom fields\' values</a>.","operationId":"updateProductField","tags":["ProductFields"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_field_id"}],"requestBody":{"content":{"application/json":{"schema":{"allOf":[{"$ref":"#/components/schemas/s_attr_field_options"},{"$ref":"#/components/schemas/s_attr_field_name"},{"title":"UpdateProductFieldResponse200","type":"object"}]}}}},"responses":{"200":{"description":"Success updating a product field","content":{"application/json":{"schema":{"title":"getProductFieldResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_field"}}}]}}}}}}},"/recents":{"get":{"summary":"Get recents","description":"Returns data about all recent changes occurred after the given timestamp.","operationId":"getRecents","deprecated":true,"tags":["Recents"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_recent_since_timestamp"},{"$ref":"#/components/parameters/p_query_recent_items"},{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_start"}],"responses":{"200":{"description":"List of items changed since \\"since_timestamp\\"","content":{"application/json":{"schema":{"title":"getRecentsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"anyOf":[{"$ref":"#/components/schemas/s_item_activity"},{"$ref":"#/components/schemas/s_item_activity_type"},{"$ref":"#/components/schemas/s_item_deal"},{"$ref":"#/components/schemas/s_item_file"},{"$ref":"#/components/schemas/s_item_filter"},{"$ref":"#/components/schemas/s_item_note"},{"$ref":"#/components/schemas/s_item_person"},{"$ref":"#/components/schemas/s_item_organization"},{"$ref":"#/components/schemas/s_item_pipeline"},{"$ref":"#/components/schemas/s_item_product"},{"$ref":"#/components/schemas/s_item_stage"},{"$ref":"#/components/schemas/s_item_user"}]}},"additional_data":{"allOf":[{"type":"object","properties":{"since_timestamp":{"type":"string","description":"The timestamp in UTC. Format: YYYY-MM-DD HH:MM:SS"},"last_timestamp_on_page":{"type":"string","description":"The timestamp in UTC. Format: YYYY-MM-DD HH:MM:SS"}}},{"$ref":"#/components/schemas/s_additional_data_pagination"}]}}}]}}}}}}},"/roles":{"get":{"summary":"Get all roles","description":"Returns all the roles within the company.","operationId":"getRoles","tags":["Roles"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_limit"},{"$ref":"#/components/parameters/p_query_start"}],"responses":{"200":{"description":"Success Getting all roles","content":{"application/json":{"schema":{"title":"getRolesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"$ref":"#/components/schemas/s_role_fullrole"},"description":"The array of roles"},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}},"post":{"summary":"Add a role","description":"Adds a new role.","operationId":"addRole","tags":["Roles"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"allOf":[{"$ref":"#/components/schemas/s_attr_role_name"},{"$ref":"#/components/schemas/s_attr_role_parent_role_id"},{"type":"object","title":"addRoleRequest","description":"The details of the role","required":["name"]}]}}}},"responses":{"200":{"description":"Success Adding a role","content":{"application/json":{"schema":{"title":"addRoleResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_created"}}}]}}}}}}},"/roles/{id}":{"delete":{"summary":"Delete a role","description":"Marks a role as deleted.","operationId":"deleteRole","tags":["Roles"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success Deleting a role","content":{"application/json":{"schema":{"title":"deleteRoleResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted"}}}]}}}}}},"get":{"summary":"Get one role","description":"Returns the details of a specific role.","operationId":"getRole","tags":["Roles"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success Getting one role","content":{"application/json":{"schema":{"title":"getRoleResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_role_subrole"},"additional_data":{"type":"object","description":"The additional data in the role","properties":{"settings":{"$ref":"#/components/schemas/s_role_settings_default_visibility"}}}}}]}}}}}},"put":{"summary":"Update role details","description":"Updates the parent role and/or the name of a specific role.","operationId":"updateRole","tags":["Roles"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_role_base_request"}}}},"responses":{"200":{"description":"Success Updating role details","content":{"application/json":{"schema":{"title":"updateRoleResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_updated"}}}]}}}}}}},"/roles/{id}/assignments":{"delete":{"summary":"Delete a role assignment","description":"Removes the assigned user from a role and adds to the default role.","operationId":"deleteRoleAssignment","deprecated":true,"tags":["Roles"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"allOf":[{"$ref":"#/components/schemas/s_attr_user_user_id"},{"title":"deleteRoleAssignmentRequest","type":"object","required":["user_id"]}]}}}},"responses":{"200":{"description":"Delete assignment from a role","content":{"application/json":{"schema":{"title":"deleteRoleAssignmentResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted"}}}]}}}}}},"get":{"summary":"List role assignments","description":"Returns all users assigned to a role.","operationId":"getRoleAssignments","deprecated":true,"tags":["Roles"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"}],"responses":{"200":{"description":"Success Listing role assignments","content":{"application/json":{"schema":{"title":"getUserRoleAssignmentsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"$ref":"#/components/schemas/s_role_assignment"},"description":"The role assignments"},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}},"post":{"summary":"Add role assignment","description":"Assigns a user to a role.","operationId":"addRoleAssignment","deprecated":true,"tags":["Roles"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"allOf":[{"$ref":"#/components/schemas/s_attr_user_user_id"},{"title":"addRoleAssignmentRequest","type":"object","required":["user_id"]}]}}}},"responses":{"200":{"description":"Success Adding a role assignment","content":{"application/json":{"schema":{"title":"addRoleAssignmentResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"allOf":[{"$ref":"#/components/schemas/s_attr_user_role_id"},{"$ref":"#/components/schemas/s_attr_user_user_id"}]}}}]}}}}}}},"/roles/{id}/settings":{"get":{"summary":"List role settings","description":"Returns the visibility settings of a specific role.","operationId":"getRoleSettings","deprecated":true,"tags":["Roles"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success Listing role settings","content":{"application/json":{"schema":{"title":"getRoleSettingsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_role_settings_default_visibility"}}}]}}}}}},"post":{"summary":"Add or update role setting","description":"Adds or updates the visibility setting for a role.","operationId":"addOrUpdateRoleSetting","deprecated":true,"tags":["Roles"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_role_setting_post"}}}},"responses":{"200":{"description":"List role settings","content":{"application/json":{"schema":{"title":"addOrUpdateRoleSettingResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"allOf":[{"$ref":"#/components/schemas/s_attr_role_id"},{"type":"object","properties":{"deal_default_visibility":{"type":"number","enum":[1,3,5,7],"description":"The setting"}}}],"description":"The response data"}}}]}}}}}}},"/roles/{id}/pipelines":{"get":{"summary":"List pipeline visibility for a role","description":"Returns the list of either visible or hidden pipeline IDs for a specific role.  For more information on pipeline visibility, please refer to the <a href=\\"https://support.pipedrive.com/en/article/visibility-groups\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Visibility groups article</a>.","operationId":"getRolePipelines","deprecated":true,"tags":["Roles"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_visible"}],"responses":{"200":{"description":"Get either visible or hidden pipeline ids for a role","content":{"application/json":{"schema":{"title":"getRolePipelinesCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_role_pipelines"}}}]}}}}}},"put":{"summary":"Update pipeline visibility for a role","description":"Updates the specified pipelines to be visible and/or hidden for a specific role. For more information on pipeline visibility, please refer to the <a href=\\"https://support.pipedrive.com/en/article/visibility-groups\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Visibility groups article</a>.","operationId":"updateRolePipelines","deprecated":true,"tags":["Roles"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_attr_role_visible_pipeline_ids"}}}},"responses":{"200":{"description":"Update pipeline visibility for a role","content":{"application/json":{"schema":{"title":"getRolePipelinesCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_role_pipelines"}}}]}}}}}}},"/stages":{"delete":{"summary":"Delete multiple stages in bulk","description":"Marks multiple stages as deleted.","operationId":"deleteStages","tags":["Stages"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_ids"}],"responses":{"200":{"description":"Delete multiple stages","content":{"application/json":{"schema":{"title":"deleteStagesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted_list"}}}]}}}}}},"get":{"summary":"Get all stages","description":"Returns data about all stages.","operationId":"getStages","tags":["Stages"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_stage_pipeline_id"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"}],"responses":{"200":{"description":"Success Getting all stages","content":{"application/json":{"schema":{"title":"getStagesResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"The array of stages","items":{"$ref":"#/components/schemas/s_stage"}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}},"post":{"summary":"Add a new stage","description":"Adds a new stage, returns the ID upon success.","operationId":"addStage","tags":["Stages"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"allOf":[{"title":"addStageRequest","required":["name","pipeline_id"],"type":"object"},{"$ref":"#/components/schemas/s_stage_request_basic"}]}}}},"responses":{"200":{"description":"Success Adding a new stage","content":{"application/json":{"schema":{"title":"stageResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","description":"Updated stage object","properties":{"data":{"$ref":"#/components/schemas/s_stage_base"}}}]}}}}}}},"/stages/{id}":{"delete":{"summary":"Delete a stage","description":"Marks a stage as deleted.","operationId":"deleteStage","tags":["Stages"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Delete stage","content":{"application/json":{"schema":{"title":"deleteStageResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_attr_id_deleted"}}}]}}}}}},"get":{"summary":"Get one stage","description":"Returns data about a specific stage.","operationId":"getStage","tags":["Stages"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_stage_everyone"}],"responses":{"200":{"description":"Success Gettting a stage","content":{"application/json":{"schema":{"title":"getStageResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"object","description":"The stage object","allOf":[{"$ref":"#/components/schemas/s_stage_base"},{"$ref":"#/components/schemas/s_deal_summary"}]}}}]}}}}}},"put":{"summary":"Update stage details","description":"Updates the properties of a stage.","operationId":"updateStage","tags":["Stages"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"title":"updateStageRequest","$ref":"#/components/schemas/s_stage_request_w_order_nbr"}}}},"responses":{"200":{"description":"Success Updating stage details","content":{"application/json":{"schema":{"title":"stageResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","description":"Updated stage object","properties":{"data":{"$ref":"#/components/schemas/s_stage_base"}}}]}}}}}}},"/stages/{id}/deals":{"get":{"summary":"Get deals in a stage","description":"Lists deals in a specific stage.","operationId":"getStageDeals","deprecated":true,"tags":["Stages"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"},{"$ref":"#/components/parameters/p_query_filter_id"},{"$ref":"#/components/parameters/p_query_stage_user_id"},{"$ref":"#/components/parameters/p_query_pipeline_everyone"},{"$ref":"#/components/parameters/p_query_start"},{"$ref":"#/components/parameters/p_query_limit"}],"responses":{"200":{"description":"Success Getting deals in a stage","content":{"application/json":{"schema":{"title":"getStageDealsResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","description":"The array of deals","items":{"$ref":"#/components/schemas/s_deal_strict"}},"additional_data":{"$ref":"#/components/schemas/s_additional_data_pagination"}}}]}}}}}}},"/users":{"get":{"summary":"Get all users","description":"Returns data about all users within the company.","operationId":"getUsers","tags":["Users"],"security":[{"bearerAuth":[]}],"responses":{"200":{"description":"The list of user objects","content":{"application/json":{"schema":{"title":"usersResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"$ref":"#/components/schemas/s_user"}}}}]}}}}}},"post":{"summary":"Add a new user","description":"Adds a new user to the company, returns the ID upon success.","operationId":"addUser","tags":["Users"],"security":[{"bearerAuth":[]}],"requestBody":{"content":{"application/json":{"schema":{"title":"addUserRequest","type":"object","required":["email"],"allOf":[{"$ref":"#/components/schemas/s_user_access"},{"$ref":"#/components/schemas/s_attr_user_email"},{"$ref":"#/components/schemas/s_attr_active_flag"}]}}}},"responses":{"200":{"description":"The data of the user","content":{"application/json":{"schema":{"title":"userResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_user"}}}]}}}},"403":{"description":"Forbidden response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_fail_response"}}}}}}},"/users/find":{"get":{"summary":"Find users by name","description":"Finds users by their name.","operationId":"findUsersByName","tags":["Users"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_query_is_term"},{"$ref":"#/components/parameters/p_query_user_search_by_email"}],"responses":{"200":{"description":"The list of user objects","content":{"application/json":{"schema":{"title":"usersResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"type":"array","items":{"$ref":"#/components/schemas/s_user"}}}}]}}}}}}},"/users/me":{"get":{"summary":"Get current user data","description":"Returns data about an authorized user within the company with bound company data: company ID, company name, and domain. Note that the `locale` property means \'Date/number format\' in the Pipedrive account settings, not the chosen language.","operationId":"getCurrentUser","tags":["Users"],"security":[{"bearerAuth":[]}],"responses":{"200":{"description":"The data of the logged in user","content":{"application/json":{"schema":{"title":"getCurrentUserResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_user_w_company"}}}]}}}},"401":{"description":"Unauthorized response","content":{"application/json":{"schema":{"allOf":[{"type":"object","title":"unathorizedResponse"},{"$ref":"#/components/schemas/s_fail_response"}]}}}}}}},"/users/{id}":{"get":{"summary":"Get one user","description":"Returns data about a specific user within the company.","operationId":"getUser","tags":["Users"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"responses":{"200":{"description":"Success Getting one user","content":{"application/json":{"schema":{"title":"userResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_user"}}}]}}}},"404":{"description":"User with specified ID does not exist or is inaccessible","content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_fail_response"}}}}}},"put":{"summary":"Update user details","description":"Updates the properties of a user. Currently, only `active_flag` can be updated.","operationId":"updateUser","tags":["Users"],"security":[{"bearerAuth":[]}],"parameters":[{"$ref":"#/components/parameters/p_path_id"}],"requestBody":{"content":{"application/json":{"schema":{"allOf":[{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"title":"updateUserRequest","type":"object","required":["active_flag"]}]}}}},"responses":{"200":{"description":"Success Updating user details","content":{"application/json":{"schema":{"title":"userResponseCode200","allOf":[{"$ref":"#/components/schemas/s_base_response"},{"type":"object","properties":{"data":{"$ref":"#/components/schemas/s_user"}}}]}}}},"403":{"description":"Forbidden response","content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_fail_response"}}}},"404":{"description":"User with specified ID does not exist or is inaccessible","content":{"application/json":{"schema":{"$ref":"#/components/schemas/s_fail_response"}}}}}}}},"components":{"securitySchemes":{"bearerAuth":{"type":"http","scheme":"bearer","bearerFormat":"JWT","description":"Enter the token with the `Bearer: ` prefix, e.g. \\"Bearer abcde12345\\"."}},"parameters":{"p_query_activity_user_id":{"in":"query","name":"user_id","required":false,"schema":{"type":"integer"},"description":"The ID of the user whose activities will be fetched. If omitted, the user associated with the API token will be used. If 0, activities for all company users will be fetched based on the permission sets."},"p_query_filter_id":{"in":"query","name":"filter_id","required":false,"schema":{"type":"integer"},"description":"The ID of the filter to use (will narrow down results if used together with `user_id` parameter)"},"p_query_activity_type":{"in":"query","name":"type","required":false,"schema":{"type":"string"},"description":"The type of the activity, can be one type or multiple types separated by a comma. This is in correlation with the `key_string` parameter of ActivityTypes."},"p_query_limit":{"name":"limit","in":"query","description":"Limits the number of returned results. If not provided, 100 items will be returned.","required":false,"schema":{"type":"integer","format":"int32","minimum":1,"default":100,"example":100}},"p_query_start":{"in":"query","name":"start","description":"For pagination, the position that represents the first result for the page.","schema":{"type":"integer","default":0}},"p_query_activity_start_date":{"in":"query","name":"start_date","required":false,"schema":{"type":"string","format":"date"},"description":"Use the activity due date where you wish to begin fetching activities from. Insert due date in YYYY-MM-DD format."},"p_query_activity_end_date":{"in":"query","name":"end_date","required":false,"schema":{"type":"string","format":"date"},"description":"Use the activity due date where you wish to stop fetching activities from. Insert due date in YYYY-MM-DD format."},"p_query_activity_done":{"in":"query","name":"done","schema":{"title":"doneNumberBoolean","type":"number","enum":[0,1]},"description":"Whether the activity is done or not. 0 = Not done, 1 = Done. If omitted, returns both Done and Not done activities."},"p_query_ids":{"in":"query","name":"ids","required":true,"description":"The comma-separated IDs that will be deleted","schema":{"type":"string"}},"p_path_id":{"in":"path","name":"id","description":"The ID of the Entity we want to retrieve.","required":true,"schema":{"type":"integer"}},"p_query_currency_term":{"in":"query","name":"term","description":"Optional search term that is searched for from currency\'s name and/or code","schema":{"type":"string"}},"p_query_deal_user_id":{"in":"query","name":"user_id","schema":{"type":"integer"},"description":"If supplied, only deals matching the given user will be returned. However, `filter_id` and `owned_by_you` takes precedence over `user_id` when supplied (if any of them apply for this endpoint)."},"p_query_deal_stage_id":{"in":"query","name":"stage_id","schema":{"type":"integer"},"description":"If supplied, only deals within the given stage will be returned"},"p_query_status":{"in":"query","name":"status","schema":{"type":"string","default":"all_not_deleted","enum":["open","won","lost","deleted","all_not_deleted"]},"description":"Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included. The upper limit of found deals  associated with the status is 2000."},"p_query_sort":{"in":"query","name":"sort","schema":{"type":"string"},"description":"The field names and sorting mode separated by a comma  (`field_name_1 ASC`, `field_name_2 DESC`).  Only first-level field keys are supported (no nested keys)."},"p_query_deal_owned_by_you":{"in":"query","name":"owned_by_you","description":"When supplied, only deals owned by you are returned. However, `filter_id` takes precedence over `owned_by_you` when both are supplied.","schema":{"title":"ownedNumberBoolean","type":"number","enum":[0,1]}},"p_query_is_term":{"in":"query","name":"term","required":true,"schema":{"type":"string"},"description":"The search term to look for. Minimum 2 characters (or 1 if using `exact_match`). Please note that the search term has to be URL encoded."},"p_query_deal_fields":{"in":"query","name":"fields","schema":{"type":"string","enum":["custom_fields","notes","title"]},"description":"A comma-separated string array. \\nThe fields to perform the search from. \\nDefaults to all of them. \\nOnly the following custom field types are searchable:  `address`, `varchar`, `text`, and `phone`. \\nRead more about searching by custom fields [here](../../kb/getting-started/search-finding-what-you-need#searching-by-custom-fields)"},"p_query_is_exact_match":{"in":"query","name":"exact_match","schema":{"type":"boolean"},"description":"When enabled, only full exact matches against the given term are returned. It is <b>not</b> case sensitive."},"p_query_is_person_id":{"in":"query","name":"person_id","schema":{"type":"integer"},"description":"Will filter deals by the provided person ID. The upper limit of found deals associated with the person is 2000."},"p_query_is_organization_id":{"in":"query","name":"organization_id","schema":{"type":"integer"},"description":"Will filter items by the provided organization ID. The upper limit of found items associated with the organization is 2000."},"p_query_is_start":{"in":"query","name":"start","description":"For pagination, the position that represents the first result for the page. Note that the pagination is based on main results and does not include related items when using `search_for_related_items` parameter.","schema":{"type":"integer","default":0}},"p_query_deal_filter_id":{"in":"query","name":"filter_id","schema":{"type":"integer"},"description":"<code>user_id</code> will not be considered. Only deals matching the given filter will be returned."},"p_query_deal_start_date":{"in":"query","name":"start_date","required":true,"schema":{"type":"string","format":"date"},"description":"The date when the first interval starts. Format: YYYY-MM-DD."},"p_query_deal_interval":{"in":"query","name":"interval","required":true,"schema":{"type":"string","enum":["day","week","month","quarter"]},"description":"The type of the interval<table><tr><th>Value</th><th>Description</th></tr><tr><td>`day`</td><td>Day</td></tr><tr><td>`week`</td><td>A full week (7 days) starting from `start_date`</td></tr><tr><td>`month`</td><td>A full month (depending on the number of days in given month) starting from `start_date`</td></tr><tr><td>`quarter`</td><td>A full quarter (3 months) starting from `start_date`</td></tr></table>"},"p_query_deal_amount":{"in":"query","name":"amount","required":true,"schema":{"type":"integer"},"description":"The number of given intervals, starting from `start_date`, to fetch. E.g. 3 (months)."},"p_query_deal_field_key":{"in":"query","name":"field_key","required":true,"schema":{"type":"string"},"description":"The date field key which deals will be retrieved from"},"p_query_deal_pipeline_id":{"in":"query","name":"pipeline_id","schema":{"type":"integer"},"description":"If supplied, only deals matching the given pipeline will be returned"},"p_query_deal_exclude_deals":{"in":"query","name":"exclude_deals","schema":{"title":"excludeNumberBoolean","type":"number","enum":[0,1]},"description":"Whether to exclude deals list (1) or not (0). Note that when deals are excluded, the timeline summary (counts and values) is still returned."},"p_query_pipeline_totals_convert_currency":{"in":"query","name":"totals_convert_currency","schema":{"type":"string"},"description":"The 3-letter currency code of any of the supported currencies. When supplied, `per_stages_converted` is returned inside `deals_summary` inside `additional_data` which contains the currency-converted total amounts in the given currency per each stage. You may also set this parameter to `default_currency` in which case users default currency is used. If `get_summary` is present in this endpoint, Only works  when `get_summary` parameter flag is enabled."},"p_query_activity_exclude":{"in":"query","name":"exclude","schema":{"type":"string"},"description":"A comma-separated string of activity IDs to exclude from result"},"p_query_all_changes":{"in":"query","name":"all_changes","description":"Whether to show custom field updates or not. 1 = Include custom field changes. If omitted, returns changes without custom field updates.","schema":{"type":"string"}},"p_query_deal_items":{"in":"query","name":"items","description":"A comma-separated string for filtering out item specific updates. (Possible values - activity, note, deal, dealChange, personChange, organizationChange).","schema":{"type":"string"}},"p_query_deal_include_product_data":{"in":"query","name":"include_product_data","description":"Whether to fetch product data along with each attached product (1) or not (0, default)","schema":{"title":"queryNumberBoolean","type":"number","enum":[0,1]}},"p_path_product_attachment_id":{"in":"path","name":"product_attachment_id","required":true,"schema":{"type":"integer"},"description":"The ID of the deal-product (the ID of the product attached to the deal)"},"p_path_field_id":{"in":"path","name":"id","description":"The ID of the Entity Field we want to retrieve.","required":true,"schema":{"type":"integer"}},"p_query_filter_type":{"in":"query","name":"type","schema":{"type":"string","enum":["deals","org","persons","products","activity"]},"description":"The types of filters to fetch"},"p_query_is_item_types":{"in":"query","name":"item_types","schema":{"type":"string","enum":["deal","person","organization","product","lead","file","mail_attachment","project"]},"description":"A comma-separated string array. The type of items to perform the search from. Defaults to all."},"p_query_is_fields":{"in":"query","name":"fields","schema":{"type":"string","enum":["address","code","custom_fields","email","name","notes","organization_name","person_name","phone","title","description"]},"description":"A comma-separated string array. The fields to perform the search from. Defaults to all. Relevant for each item type are:\\n<br>  <table>\\n  <tr>\\n      <th><b>Item type</b></th>\\n      <th><b>Field</b></th>\\n  </tr>\\n  <tr>\\n      <td>Deal</td>\\n      <td>`custom_fields`, `notes`, `title`\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>Person</td>\\n      <td>`custom_fields`, `email`, `name`, `notes`, `phone`\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>Organization</td>\\n      <td>`address`, `custom_fields`, `name`, `notes`\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>Product</td>\\n      <td>`code`, `custom_fields`, `name`\\n      </td>\\n  </tr>\\n</table> <br>\\nOnly the following custom field types are searchable:  `address`, `varchar`, `text`, and `phone`. \\nRead more about searching by custom fields  [here](../../kb/getting-started/search-finding-what-you-need#searching-by-custom-fields)."},"p_query_is_search_for_related_items":{"in":"query","name":"search_for_related_items","schema":{"type":"boolean"},"description":"When enabled, the response will include up to 100 newest related leads and 100 newest related deals for each found person and organization and up to 100 newest related persons for each found organization"},"p_query_is_include_fields":{"in":"query","name":"include_fields","schema":{"type":"string","enum":["deal.cc_email","person.picture","product.price"]},"description":"A comma-separated string array. Supports including optional fields in the results which are not provided by default."},"p_query_is_field_type":{"in":"query","name":"field_type","required":true,"schema":{"type":"string","enum":["dealField","personField","organizationField","productField"]},"description":"The type of the field to perform the search from"},"p_query_is_field_key":{"in":"query","name":"field_key","required":true,"schema":{"type":"string"},"description":"The key of the field to search from. \\nThe field key can be obtained by fetching the list of  the fields using any of the fields\' API GET methods (dealFields, personFields, etc.). \\nOnly the following custom field types are searchable:  `address`, `varchar`, `text`, and `phone`. \\nRead more about searching by custom fields  [here](../../kb/getting-started/search-finding-what-you-need#searching-by-custom-fields)."},"p_query_is_return_item_ids":{"in":"query","name":"return_item_ids","schema":{"type":"boolean"},"description":"Whether to return the IDs of the matching items or not. When not set or set to `0` or `false`, only distinct values of the searched field are returned. When set to `1` or `true`, the ID of each found item is returned."},"p_query_note_user_id":{"in":"query","name":"user_id","schema":{"type":"integer"},"description":"The ID of the user whose notes to fetch. If omitted, notes by all users will be returned."},"p_query_note_deal_id":{"in":"query","name":"deal_id","schema":{"type":"integer"},"description":"The ID of the deal which notes to fetch. If omitted, notes about all deals will be returned."},"p_query_note_person_id":{"in":"query","name":"person_id","schema":{"type":"integer"},"description":"The ID of the person whose notes to fetch. If omitted, notes about all persons will be returned."},"p_query_note_org_id":{"in":"query","name":"org_id","schema":{"type":"integer"},"description":"The ID of the organization which notes to fetch. If omitted, notes about all organizations will be returned."},"p_query_note_sort":{"in":"query","name":"sort","schema":{"type":"string"},"description":"The field names and sorting mode separated by a comma (`field_name_1 ASC`, `field_name_2 DESC`).  Only first-level field keys are supported (no nested keys).  Supported fields:  `id`, `user_id`, `deal_id`, `person_id`, `org_id`, `content`,  `add_time`, `update_time`."},"p_query_note_start_date":{"in":"query","name":"start_date","schema":{"type":"string","format":"date"},"description":"The date in format of YYYY-MM-DD from which notes to fetch"},"p_query_note_end_date":{"in":"query","name":"end_date","schema":{"type":"string","format":"date"},"description":"The date in format of YYYY-MM-DD until which notes to fetch to"},"p_query_note_pinned_to_deal_flag":{"in":"query","name":"pinned_to_deal_flag","schema":{"title":"numberBoolean","type":"number","enum":[0,1]},"description":"If set, the results are filtered by note to deal pinning state"},"p_query_note_pinned_to_organization_flag":{"in":"query","name":"pinned_to_organization_flag","schema":{"title":"numberBoolean","type":"number","enum":[0,1]},"description":"If set, the results are filtered by note to organization pinning state"},"p_query_note_pinned_to_person_flag":{"in":"query","name":"pinned_to_person_flag","schema":{"title":"numberBoolean","type":"number","enum":[0,1]},"description":"If set, the results are filtered by note to person pinning state"},"p_path_note_comment_id":{"in":"path","name":"commentId","description":"The ID of the comment","required":true,"schema":{"type":"string","format":"uuid"}},"p_query_org_user_id":{"in":"query","name":"user_id","schema":{"type":"integer"},"description":"If supplied, only organizations owned by the given user will be returned. However, `filter_id` takes precedence over `user_id` when both are supplied."},"p_query_first_char":{"in":"query","name":"first_char","schema":{"type":"string"},"description":"If supplied, only entities whose name starts with the specified letter will be returned (case-insensitive)"},"p_query_org_fields":{"in":"query","name":"fields","schema":{"type":"string","enum":["address","custom_fields","notes","name"]},"description":"A comma-separated string array. \\nThe fields to perform the search from. \\nDefaults to all of them. \\nOnly the following custom field types are searchable:  `address`, `varchar`, `text`, and `phone`. \\nRead more about searching by custom fields  [here](../../kb/getting-started/search-finding-what-you-need#searching-by-custom-fields)."},"p_query_org_sort":{"in":"query","name":"sort","schema":{"type":"string"},"description":"The field names and sorting mode separated by a comma  (`field_name_1 ASC`, `field_name_2 DESC`).  Only first-level field keys are supported (no nested keys).  Supported fields:  `id`, `user_id`,  `deal_id`, `person_id`, `org_id`, `product_id`,  `add_time`, `update_time`, `comment`."},"p_query_org_items":{"in":"query","name":"items","description":"A comma-separated string for filtering out item specific updates. (Possible values - activity, note, deal).","schema":{"type":"string"}},"p_query_person_user_id":{"in":"query","name":"user_id","schema":{"type":"integer"},"description":"If supplied, only persons owned by the given user will be returned. However, `filter_id` takes precedence over `user_id` when both are supplied."},"p_query_fields":{"in":"query","name":"fields","schema":{"type":"string","enum":["custom_fields","email","notes","phone","name"]},"description":"A comma-separated string array. The fields to perform the search from. Defaults to all of them. \\nOnly the following custom field types are searchable:  `address`, `varchar`, `text`, and `phone`. \\nRead more about searching by custom fields  [here](../../kb/getting-started/search-finding-what-you-need#searching-by-custom-fields)."},"p_query_include_fields":{"in":"query","name":"include_fields","schema":{"type":"string","enum":["person.picture"]},"description":"Supports including optional fields in the results which are not provided by default"},"p_query_person_items":{"in":"query","name":"items","description":"A comma-separated string for filtering out item specific updates. (Possible values - activity, note, deal).","schema":{"type":"string"}},"p_query_pipeline_user_id":{"in":"query","name":"user_id","schema":{"type":"integer"},"description":"If supplied, `filter_id` will not be considered and only deals owned by the given user will be returned. If omitted, deals owned by the authorized user will be returned."},"p_query_pipeline_everyone":{"in":"query","name":"everyone","schema":{"title":"numberBoolean","type":"number","enum":[0,1]},"description":"If supplied, `filter_id` and `user_id` will not be considered – instead, deals owned by everyone will be returned"},"p_query_pipeline_get_summary":{"in":"query","name":"get_summary","schema":{"title":"numberBoolean","type":"number","enum":[0,1]},"description":"Whether to include a summary of the pipeline in the `additional_data` or not"},"p_query_product_user_id":{"in":"query","name":"user_id","schema":{"type":"integer"},"description":"If supplied, only products owned by the given user will be returned"},"p_query_product_ids":{"in":"query","name":"ids","schema":{"type":"array","items":{"type":"integer"}},"description":"An array of integers with the IDs of the products that should be returned in the response"},"p_query_product_get_summary":{"in":"query","name":"get_summary","schema":{"type":"boolean"},"description":"If supplied, the response will return the total numbers of products in the `additional_data.summary.total_count` property"},"p_query_recent_since_timestamp":{"in":"query","name":"since_timestamp","required":true,"schema":{"type":"string"},"description":"The timestamp in UTC. Format: YYYY-MM-DD HH:MM:SS."},"p_query_recent_items":{"in":"query","name":"items","schema":{"type":"string","enum":["activity","activityType","deal","filter","note","person","organization","pipeline","product","stage","user"]},"description":"Multiple selection of item types to include in the  query (optional)"},"p_query_visible":{"in":"query","name":"visible","schema":{"type":"boolean","default":true},"description":"Whether to return the visible or hidden pipelines  for the role"},"p_query_stage_pipeline_id":{"in":"query","name":"pipeline_id","schema":{"type":"integer"},"description":"The ID of the pipeline to fetch stages for. If omitted, stages for all pipelines will be fetched."},"p_query_stage_everyone":{"in":"query","name":"everyone","schema":{"title":"stageNumberBoolean","type":"number","enum":[0,1]},"description":"If `everyone=1` is provided, deals summary will return deals owned by every user"},"p_query_stage_user_id":{"in":"query","name":"user_id","schema":{"type":"integer"},"description":"If supplied, `filter_id` will not be considered and only deals owned by the given user will be returned. If omitted, deals owned by the authorized user will be returned."},"p_query_user_search_by_email":{"in":"query","name":"search_by_email","schema":{"title":"numberBooleanDefault0","type":"number","default":0,"enum":[0,1]},"description":"When enabled, the term will only be matched against email addresses of users. Default: `false`."}},"schemas":{"s_base_response":{"title":"baseResponse","type":"object","properties":{"success":{"type":"boolean","description":"If the response is successful or not"}}},"s_attr_person_id_ref":{"type":"object","properties":{"person_id":{"description":"The ID of the person this Item is associated with","type":"integer"}}},"s_attr_deal_id_ref":{"type":"object","properties":{"deal_id":{"description":"The ID of the deal this Item is associated with","type":"integer"}}},"s_attr_org_id":{"type":"object","properties":{"org_id":{"description":"The ID of the organization this Item is associated with","type":"integer"}}},"s_activity_extended":{"allOf":[{"$ref":"#/components/schemas/s_attr_person_id_ref"},{"$ref":"#/components/schemas/s_attr_deal_id_ref"},{"$ref":"#/components/schemas/s_attr_org_id"},{"type":"object","properties":{"due_date":{"description":"\\"The due date of the activity. Format: YYYY-MM-DD\\"","type":"string","format":"date"},"due_time":{"description":"\\"The due time of the activity in UTC. Format: HH:MM\\"","type":"string"},"duration":{"description":"\\"The duration of the activity. Format: HH:MM\\"","type":"string"}}}]},"s_attr_active_flag":{"type":"object","title":"entityActiveFlag","properties":{"active_flag":{"type":"boolean","description":"Whether the entity is active or not. false = Not activated, true = Activated"}}},"s_attr_created_by_user_id":{"type":"object","properties":{"created_by_user_id":{"type":"integer","description":"The ID of the user who created the  item."}}},"s_basic_entity_attributes":{"allOf":[{"$ref":"#/components/schemas/s_attr_active_flag"},{"$ref":"#/components/schemas/s_attr_created_by_user_id"},{"type":"object","title":"entityBasicSchema","properties":{"add_time":{"type":"string","format":"date-time","description":"The creation time in UTC. Format: YYYY-MM-DD HH:MM:SS"},"update_time":{"type":"string","format":"date-time","description":"The last update time in UTC. Format: YYYY-MM-DD HH:MM:SS"},"last_updated_by_user_id":{"type":"integer","description":"The ID of the user who created or most recently updated the item."}}}]},"s_attr_organization_org_name":{"type":"object","title":"organizationOrgName","properties":{"org_name":{"type":"string","description":"The name of the organization associated with the entity"}}},"s_attr_person_person_name":{"type":"object","title":"personPersonName","properties":{"person_name":{"type":"string","description":"The name of the peson associated with the entity"}}},"s_attr_user_owner_name":{"type":"object","properties":{"owner_name":{"type":"string","description":"The name of the owner associated with the entity"}}},"s_attr_deal_deal_title":{"type":"object","title":"dealDealTitle","properties":{"deal_name":{"description":"The name of the deal this entity is associated with","type":"string"}}},"s_activity_redundant":{"allOf":[{"$ref":"#/components/schemas/s_attr_organization_org_name"},{"$ref":"#/components/schemas/s_attr_person_person_name"},{"$ref":"#/components/schemas/s_attr_user_owner_name"},{"$ref":"#/components/schemas/s_attr_deal_deal_title"},{"type":"object","title":"activityRedundant"}]},"s_basic_company_id":{"type":"object","properties":{"company_id":{"type":"integer","description":"The ID of the company"}}},"s_attr_activity_id":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the activity, generated when the activity was created"}}},"s_activity":{"allOf":[{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_activity_redundant"},{"$ref":"#/components/schemas/s_basic_company_id"},{"$ref":"#/components/schemas/s_attr_activity_id"},{"type":"object","properties":{"done":{"allOf":[{"title":"doneNumberBoolean","type":"number","enum":[0,1]}],"description":"Whether the activity is done or not. 0 = Not done, 1 = Done"},"subject":{"description":"The subject of the activity","type":"string"},"type":{"description":"The type of the activity. This is in correlation with the `key_string` parameter of ActivityTypes.","type":"string"},"assigned_to_user_id":{"description":"The ID of the user to whom the activity is assigned to. Equal to `user_id`.","type":"integer"},"user_id":{"description":"The ID of the user whom the activity is assigned to","type":"integer"},"participants":{"description":"List of multiple persons (participants) this activity is associated with.  It requires a structure as follows: `[{\\"person_id\\":1,\\"primary_flag\\":true}]`","type":"array","nullable":true,"items":{"type":"object"}},"marked_as_done_time":{"type":"string","description":"The date and time this activity was marked as done. Format: YYYY-MM-DD HH:MM:SS."}}}]},"s_additional_data_pagination":{"type":"object","description":"The additional data of the list","properties":{"pagination":{"description":"Pagination details of the list","type":"object","properties":{"start":{"type":"integer","description":"Pagination start"},"limit":{"type":"integer","description":"Items shown per page"},"more_items_in_collection":{"type":"boolean","description":"Whether there are more list items in the collection than displayed"},"next_start":{"type":"integer","description":"Next pagination start"}}}}},"s_attr_user_email":{"type":"object","properties":{"email":{"type":"string","description":"The user email"}}},"s_attr_user_id":{"type":"object","properties":{"id":{"type":"string","description":"The ID of the user"}}},"s_attr_user_name":{"type":"object","properties":{"name":{"type":"string","description":"The name of the user"}}},"s_basic_user_id":{"type":"object","title":"userBasicData","allOf":[{"type":"object","description":"The user who is associated with the Entity"},{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_attr_user_email"},{"$ref":"#/components/schemas/s_attr_user_id"},{"$ref":"#/components/schemas/s_attr_user_name"}]},"s_ro_user":{"type":"object","properties":{"user":{"type":"object","properties":{"USER_ID":{"$ref":"#/components/schemas/s_basic_user_id"}}}}},"s_person_item_email_array":{"type":"object","properties":{"value":{"type":"string","description":"The Email"},"primary":{"type":"boolean","description":"Boolean that indicates if email is primary for the person or not"},"label":{"type":"string","description":"The label that indicates the type of the email. (Possible values - work, home or other)"}}},"s_person_item_phone_array":{"type":"object","properties":{"value":{"type":"string","description":"The phone number"},"primary":{"type":"boolean","description":"Boolean that indicates if phone number is primary for the person or not"},"label":{"type":"string","description":"The label that indicates the type of the phone number. (Possible values - work, home, mobile or other)"}}},"s_basic_person":{"type":"object","title":"personBasicData","description":"The person associated with the entity (whitout ID)","allOf":[{"type":"object","properties":{"name":{"type":"string","description":"The name of the person associated with the entity"},"email":{"type":"array","description":"The emails of the person associated with the entity","items":{"$ref":"#/components/schemas/s_person_item_email_array"}},"phone":{"type":"array","description":"The phone numbers of the person associated with the entity","items":{"$ref":"#/components/schemas/s_person_item_phone_array"}},"owner_id":{"type":"integer","description":"The ID of the user owner of the person that is associated with the entity"}}}]},"s_basic_person_id":{"type":"object","title":"personBasicDataWithID","description":"The ID of the person associated with the  entity","allOf":[{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the person associated with the entity"}}},{"$ref":"#/components/schemas/s_basic_person"}]},"s_ro_person":{"type":"object","properties":{"person":{"type":"object","properties":{"PERSON_ID":{"$ref":"#/components/schemas/s_basic_person_id"}}}}},"s_attr_organization_address":{"type":"object","title":"organizationAddress","properties":{"address":{"type":"string","description":"The full address of the organization"}}},"s_basic_organization":{"allOf":[{"$ref":"#/components/schemas/s_attr_organization_address"},{"type":"object","title":"organizationBasicData","description":"The Organization associated with the entity (Without ID)","properties":{"name":{"type":"string","description":"The name of the organization associated with the entity"},"people_count":{"type":"integer","description":"The number of people connected with the organization that is associated with the entity"},"owner_id":{"type":"integer","description":"The ID of the user owner of the organization that is associated with the entity"}}}]},"s_basic_organization_id":{"type":"object","title":"organizationBasicDataWithID","description":"The ID of the organization associated with the entity","allOf":[{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the organization associated with the entity"}}},{"$ref":"#/components/schemas/s_basic_organization"}]},"s_ro_organization":{"type":"object","properties":{"organization":{"type":"object","properties":{"ORGANIZATION_ID":{"$ref":"#/components/schemas/s_basic_organization_id"}}}}},"s_attr_deal_stage_id":{"type":"object","properties":{"stage_id":{"type":"integer","description":"The ID of the stage the deal is currently at"}}},"s_attr_deal_pipeline_id":{"type":"object","properties":{"pipeline_id":{"type":"integer","description":"The ID of the pipeline associated with the deal"}}},"s_attr_deal_currency":{"type":"object","properties":{"currency":{"type":"string","description":"The currency of the deal value"}}},"s_attr_deal_value":{"type":"object","properties":{"value":{"type":"number","description":"The value of the deal"}}},"s_basic_deal_id":{"allOf":[{"$ref":"#/components/schemas/s_attr_deal_stage_id"},{"$ref":"#/components/schemas/s_attr_deal_pipeline_id"},{"$ref":"#/components/schemas/s_attr_deal_currency"},{"$ref":"#/components/schemas/s_attr_deal_value"},{"type":"object","title":"dealBasicData","description":"The ID of the deal which is associated with the entity","properties":{"id":{"type":"integer","description":"The ID of the deal associated with the entity"},"name":{"type":"string","description":"The name of the deal associated with the entity"},"status":{"type":"string","description":"The status of the deal associated with the entity"}}}]},"s_ro_deal":{"type":"object","properties":{"deal":{"type":"object","properties":{"DEAL_ID":{"$ref":"#/components/schemas/s_basic_deal_id"}}}}},"s_related_objects_3E_U":{"allOf":[{"$ref":"#/components/schemas/s_ro_user"},{"$ref":"#/components/schemas/s_ro_person"},{"$ref":"#/components/schemas/s_ro_organization"},{"$ref":"#/components/schemas/s_ro_deal"}]},"s_attr_id_deleted_list":{"type":"object","title":"deletedListID","properties":{"id":{"type":"array","description":"Array of all the IDs of the deleted items.","items":{"type":"integer"}}}},"s_attr_id_deleted":{"type":"object","title":"deletedID","properties":{"id":{"type":"integer","description":"The ID of the deleted item."}}},"s_attr_field_options":{"type":"object","properties":{"options":{"type":"array","nullable":true,"items":{"type":"object"},"description":"The options of the field. When there are no options, `null` is returned.  When `field_type` is either `set` or `enum`, possible options must be supplied as a JSON-encoded sequential array of objects. All active items must be supplied and already existing items must have their ID supplied. New items only require a label. Example:  `[{\\"id\\":123,\\"label\\":\\"Existing Item\\"},{\\"label\\":\\"New Item\\"}]`"}}},"s_attr_field_name":{"type":"object","properties":{"name":{"type":"string","description":"The name of the field"}}},"s_fields_create":{"allOf":[{"$ref":"#/components/schemas/s_attr_field_options"},{"$ref":"#/components/schemas/s_attr_field_name"},{"type":"object","description":"Entity\'s Add Operation Field Schema","required":["name"],"properties":{"add_visible_flag":{"type":"boolean","default":true,"description":"Whether the field is available in the \'add new\' modal or not (in the web app)"}}}]},"s_field_type":{"type":"object","required":["field_type"],"properties":{"field_type":{"allOf":[{"type":"string","enum":["date","daterange","double","enum","monetary","org","person","phone","set","text","time","timerange","user","varchar"],"description":"The type of the  field <table>\\n  <tr>\\n      <th>Value</th>\\n      <th>Description</th>\\n  </tr>\\n  <tr>\\n      <td>`date`</td>\\n      <td>Date (format YYYY-MM-DD)\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>`daterange`</td>\\n      <td>Date-range\\n        field (has a start date and end date value, both YYYY-MM-DD)\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>`double`</td>\\n      <td>Numeric value\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>`enum`</td>\\n      <td>Options\\n        field with a single possible chosen option\\n      </td>\\n  </tr>\\n  <tr></tr>\\n  <tr>\\n      <td>`monetary`</td>\\n      <td>Monetary\\n        field (has a numeric value and a currency value)\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>`org`</td>\\n      <td>Organization\\n        field (contains an organization ID which is stored on the same\\n        account)\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>`person`</td>\\n      <td>Person\\n        field (contains a person ID which is stored on the same\\n        account)\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>`phone`</td>\\n      <td>Phone field (up to 255 numbers and/or characters)\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>`set`</td>\\n      <td>Options\\n        field with a possibility of having multiple chosen\\n        options\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>`text`</td>\\n      <td>Long\\n        text (up to 65k characters)\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>`time`</td>\\n      <td>Time field (format HH:MM:SS)\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>`timerange`</td>\\n      <td>Time-range\\n        field (has a start time and end time value, both HH:MM:SS)\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>`user`</td>\\n      <td>User\\n        field (contains a user ID of another Fintesk user)\\n      </td>\\n  </tr>\\n  <tr>\\n      <td>`varchar`</td>\\n      <td>Text (up to 255 characters)\\n      </td>\\n  </tr>\\n \\n\\n</table>"}]}}},"s_attr_field_order_nbr":{"type":"object","properties":{"order_nbr":{"type":"integer","description":"The position (index) of the Item. First order (`order_nbr=0`) is the default."}}},"s_field":{"allOf":[{"$ref":"#/components/schemas/s_fields_create"},{"$ref":"#/components/schemas/s_field_type"},{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_attr_field_order_nbr"},{"type":"object","description":"Entity\'s Field Schema","properties":{"id":{"type":"integer","description":"The ID of the field. Value is `null` in case of subfields."},"key":{"type":"string","description":"The key of the field. For custom fields this is generated upon creation."},"edit_flag":{"type":"boolean","description":"Whether or not the field and metadata is editable"},"index_visible_flag":{"type":"boolean","description":"Not used"},"details_visible_flag":{"type":"boolean","description":"Not used"},"important_flag":{"type":"boolean","description":"Whether or not the field is marked as important"},"bulk_edit_allowed":{"type":"boolean","description":"Whether or not the field of an item can be edited in bulk"},"searchable_flag":{"type":"boolean","description":"Whether or not items can be searched by this field"},"filtering_allowed":{"type":"boolean","description":"Whether or not items can be filtered by this field"},"sortable_flag":{"type":"boolean","description":"Whether or not items can be sorted by this field"},"mandatory_flag":{"type":"boolean","description":"Whether or not the field is mandatory"},"is_subfield":{"type":"boolean","description":"Whether or not the field is a subfield of another field. Only present if field is subfield."},"subfields":{"type":"array","items":{"type":"object"},"description":"The subfields of the field. Only present when the field has subfields."}}}]},"s_attr_activity_type_id":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the activity type"}}},"s_activity_type_put":{"allOf":[{"$ref":"#/components/schemas/s_attr_field_order_nbr"},{"type":"object","properties":{"name":{"type":"string","description":"The name of the activity type"},"icon_key":{"type":"string","description":"Icon graphic to use for representing this activity type","enum":["task","email","meeting","deadline","call","lunch","calendar","downarrow","document","smartphone","camera","scissors","cogs","bubble","uparrow","checkbox","signpost","shuffle","addressbook","linegraph","picture","car","world","search","clip","sound","brush","key","padlock","pricetag","suitcase","finish","plane","loop","wifi","truck","cart","bulb","bell","presentation"]},"color":{"type":"string","description":"A designated color for the activity type in 6-character HEX format (e.g. `FFFFFF` for white, `000000` for black)"}}}]},"s_activity_type":{"allOf":[{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_attr_activity_type_id"},{"type":"object","properties":{"key_string":{"type":"string","description":"A string that is generated by the API based on the given name of the activity type upon creation"},"is_custom_flag":{"type":"boolean","description":"Whether the activity type is a custom one or not"}}},{"$ref":"#/components/schemas/s_activity_type_put"}]},"s_attr_currency_id":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the currency"}}},"s_currency":{"type":"array","description":"The array of currencies","items":{"allOf":[{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_attr_currency_id"},{"type":"object","properties":{"code":{"type":"string","description":"The code of the currency"},"name":{"type":"string","description":"The name of the currency"},"decimal_points":{"type":"integer","description":"The amount of decimal points of the currency"},"symbol":{"type":"string","description":"The symbol of the currency"},"is_custom_flag":{"type":"boolean","description":"Whether the currency is a custom one or not"}}}]}},"s_attr_deal_id":{"type":"object","properties":{"id":{"type":"string","description":"The ID of the deal"}}},"s_basic_user_id_w_value":{"title":"userDataWithId","allOf":[{"description":"The user who is associated with the entity"},{"$ref":"#/components/schemas/s_basic_user_id"},{"type":"object","properties":{"value":{"type":"integer","description":"The ID of the user associated with the entity"}}}]},"s_basic_person_w_value":{"title":"personDataWithId","allOf":[{"description":"The person who is associated with the Entity"},{"$ref":"#/components/schemas/s_basic_person"},{"type":"object","properties":{"value":{"type":"integer","description":"The ID of the person associated with the Entity"}}}]},"s_basic_organization_w_value":{"title":"organizationDataWithId","allOf":[{"description":"The organization who is associated with the Entity"},{"$ref":"#/components/schemas/s_basic_organization"},{"type":"object","properties":{"value":{"type":"integer","description":"The ID of the organization associated with the Entity"}}}]},"s_deal_non_strict_objects":{"allOf":[{"$ref":"#/components/schemas/s_attr_deal_id"},{"type":"object","title":"dealNonStrict","properties":{"creator_user_id":{"allOf":[{"description":"The User who created the deal"},{"$ref":"#/components/schemas/s_basic_user_id_w_value"}]},"user_id":{"allOf":[{"description":"The user who is associated with the deal"},{"$ref":"#/components/schemas/s_basic_user_id_w_value"}]},"person_id":{"allOf":[{"description":"The person who is associated with the deal"},{"$ref":"#/components/schemas/s_basic_person_w_value"}]},"org_id":{"allOf":[{"description":"The organization who is associated with the deal"},{"$ref":"#/components/schemas/s_basic_organization_w_value"}]}}}]},"s_deal_next_activity_info":{"type":"object","properties":{"next_activity_date":{"type":"string","nullable":true,"description":"The date of the next activity associated with the deal"},"next_activity_time":{"type":"string","nullable":true,"description":"The time of the next activity associated with the deal"},"next_activity_id":{"type":"integer","nullable":true,"description":"The ID of the next activity associated with the deal"},"next_activity_subject":{"type":"string","description":"The subject of the next activity associated with the deal"},"next_activity_type":{"type":"string","description":"The type of the next activity associated with the deal"},"next_activity_duration":{"type":"string","description":"The duration of the next activity associated with the deal"},"next_activity_note":{"type":"string","description":"The note of the next activity associated with the deal"}}},"s_deal_last_activity_info":{"type":"object","properties":{"last_activity_id":{"type":"integer","nullable":true,"description":"The ID of the last activity associated with the deal"},"last_activity_date":{"type":"string","nullable":true,"description":"The date of the last activity associated with the deal"}}},"s_deals_activity_info":{"allOf":[{"$ref":"#/components/schemas/s_deal_next_activity_info"},{"$ref":"#/components/schemas/s_deal_last_activity_info"}]},"s_attr_deal_title":{"type":"object","title":"dealTitleParam","properties":{"name":{"type":"string","description":"The name of the deal"}}},"s_mailbox_last_incoming_mail_time":{"type":"object","properties":{"last_incoming_mail_time":{"type":"string","description":"The date and time of the last incoming email associated with the Item"}}},"s_mailbox_last_outgoing_mail_time":{"type":"object","properties":{"last_outgoing_mail_time":{"type":"string","description":"The date and time of the last outgoing email associated with the Item"}}},"s_attr_deal_status":{"type":"object","properties":{"status":{"type":"string","description":"The status of the deal"}}},"s_deals_get_basic":{"allOf":[{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_attr_deal_title"},{"$ref":"#/components/schemas/s_mailbox_last_incoming_mail_time"},{"$ref":"#/components/schemas/s_mailbox_last_outgoing_mail_time"},{"$ref":"#/components/schemas/s_attr_deal_pipeline_id"},{"$ref":"#/components/schemas/s_attr_deal_stage_id"},{"$ref":"#/components/schemas/s_attr_deal_status"},{"$ref":"#/components/schemas/s_attr_deal_currency"},{"$ref":"#/components/schemas/s_attr_deal_value"},{"title":"getDealBasic","type":"object","properties":{"stage_change_time":{"type":"string","description":"The last updated date and time of the deal stage"},"probability":{"type":"number","nullable":true,"description":"The success probability percentage of the deal"},"lost_reason":{"type":"string","nullable":true,"description":"The reason for losing the deal"},"close_time":{"type":"string","nullable":true,"description":"The date and time of closing the deal"},"won_time":{"type":"string","description":"The date and time of changing the deal status as won"},"first_won_time":{"type":"string","description":"The date and time of the first time changing the deal status as won"},"lost_time":{"type":"string","description":"The date and time of changing the deal status as lost"},"expected_close_date":{"type":"string","format":"date","description":"The expected close date of the deal"}}}]},"s_attr_deal_person_hidden":{"type":"object","properties":{"person_hidden":{"type":"boolean","description":"If the person that is associated with the deal is hidden or not"}}},"s_attr_deal_weighted_value_formatted":{"type":"object","properties":{"weighted_value_formatted":{"type":"string","description":"The weighted_value formatted with selected currency. E.g. US$500"}}},"s_attr_deal_weighted_value":{"type":"object","properties":{"weighted_value":{"type":"number","description":"Probability times deal value. Probability can either be deal probability or if not set, then stage probability."}}},"s_deals_get_redundant":{"allOf":[{"$ref":"#/components/schemas/s_attr_deal_person_hidden"},{"$ref":"#/components/schemas/s_attr_organization_org_name"},{"$ref":"#/components/schemas/s_attr_user_owner_name"},{"$ref":"#/components/schemas/s_attr_person_person_name"},{"$ref":"#/components/schemas/s_attr_deal_weighted_value_formatted"},{"$ref":"#/components/schemas/s_attr_deal_weighted_value"},{"type":"object","title":"getDealRedundant","properties":{"stage_order_nbr":{"type":"integer","description":"The order number of the deal stage associated with the deal"},"value_formatted":{"type":"string","description":"The deal value formatted with selected currency. E.g. US$500"},"weighted_value_currency":{"type":"string","description":"The currency associated with the deal"},"rotten_time":{"type":"string","nullable":true,"description":"The date and time of changing the deal status as rotten"}}}]},"s_deal_get_base":{"allOf":[{"$ref":"#/components/schemas/s_deals_activity_info"},{"$ref":"#/components/schemas/s_deals_get_basic"},{"$ref":"#/components/schemas/s_deals_get_redundant"}]},"s_deal_non_strict":{"title":"dealNonStrict","allOf":[{"$ref":"#/components/schemas/s_deal_non_strict_objects"},{"$ref":"#/components/schemas/s_deal_get_base"}]},"s_attr_stage_name":{"type":"object","properties":{"name":{"type":"string","description":"The name of the stage"}}},"s_attr_stage_id":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the stage"}}},"s_stage_base":{"allOf":[{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_attr_field_order_nbr"},{"$ref":"#/components/schemas/s_attr_deal_pipeline_id"},{"$ref":"#/components/schemas/s_attr_stage_name"},{"$ref":"#/components/schemas/s_attr_stage_id"},{"type":"object","title":"stageBase"}]},"s_pipeline_attr_deal_probability":{"type":"object","properties":{"deal_probability":{"allOf":[{"title":"numberBoolean","type":"number","enum":[0,1]}],"description":"Whether deal probability is disabled or enabled for this pipeline"}}},"s_attr_pipeline_name":{"type":"object","properties":{"name":{"type":"string","description":"The name of the pipeline"}}},"s_attr_pipeline_id":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the pipeline"}}},"s_pipeline_base":{"allOf":[{"$ref":"#/components/schemas/s_attr_field_order_nbr"},{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_pipeline_attr_deal_probability"},{"$ref":"#/components/schemas/s_attr_pipeline_name"},{"$ref":"#/components/schemas/s_attr_pipeline_id"},{"type":"object","title":"basePipeline","description":"The pipeline object"}]},"s_related_objects_2E_U_S_P":{"allOf":[{"$ref":"#/components/schemas/s_ro_user"},{"$ref":"#/components/schemas/s_ro_person"},{"$ref":"#/components/schemas/s_ro_organization"},{"type":"object","properties":{"stage":{"$ref":"#/components/schemas/s_stage_base"},"pipeline":{"$ref":"#/components/schemas/s_pipeline_base"}}}]},"s_deal_request_cru_channel":{"title":"cruDealRequestChannel","type":"object","properties":{"origin_id":{"type":"string","nullable":true,"description":"The optional ID to further distinguish the origin of the deal - e.g. Which API integration created this deal. If omitted, `origin_id` will be set to null."},"channel":{"type":"integer","nullable":true,"description":"The ID of Marketing channel this deal was created from. Provided value must be one of the channels configured for your company. You can fetch allowed values with  [GET /v1/dealFields](../../fintesk/api/v1#tag/DealFields/operation/getDealField) If omitted, channel will be set to null."},"channel_id":{"type":"string","nullable":true,"description":"The optional ID to further distinguish the Marketing channel. If omitted, `channel_id` will be set to null."}}},"s_attr_add_time_request":{"title":"addTimeRequest","type":"object","properties":{"add_time":{"type":"string","description":"The optional creation date & time of the Item in UTC. Can be set in the past or in the future. Requires admin user API token. Format: YYYY-MM-DD HH:MM:SS"}}},"s_deal_request_cru":{"allOf":[{"$ref":"#/components/schemas/s_deal_request_cru_channel"},{"$ref":"#/components/schemas/s_attr_add_time_request"},{"title":"cruDealParameters","type":"object","properties":{"value":{"type":"string","description":"The value of the deal. If omitted,  value will be set to 0."},"currency":{"type":"string","description":"The currency of the deal. Accepts a 3-character currency code. Adding a new Deal:  if omitted, currency will be set to the default currency of the authorized user."},"user_id":{"type":"integer","description":"The ID of the user which will be the owner of the created deal. Adding a new Deal:  If not provided, the user making the request will be used."},"person_id":{"type":"integer","description":"The ID of a person which this deal will be linked to. If the person does not exist yet, it needs to be created first. Adding a new Deal:  This property is required unless `org_id` is specified."},"org_id":{"type":"integer","description":"The ID of an organization which this deal will be linked to. If the organization does not exist yet, it needs to be created first. Adding a new Deal: This property is required unless `person_id` is specified."},"pipeline_id":{"type":"integer","description":"The ID of the pipeline this deal will be added to. By default, the deal will be added to the first stage of the specified pipeline. Please note that `pipeline_id` and `stage_id` should not be used together as `pipeline_id` will be ignored."},"stage_id":{"type":"integer","description":"The ID of the stage this deal will be added to. Please note that a pipeline will be assigned automatically based on the `stage_id`. Adding a new Deal: If omitted, the deal will be placed in the first stage of the default pipeline."},"status":{"type":"string","enum":["open","won","lost","deleted"],"description":"open = Open, won = Won, lost = Lost, deleted = Deleted. Adding a new Deal: If omitted, status will be set to open."}}}]},"s_deal_request_cru_basic":{"title":"basicDeal","type":"object","properties":{"won_time":{"type":"string","description":"The optional date and time of changing the deal status as won in UTC. Format: YYYY-MM-DD HH:MM:SS. Can be set only when deal `status` is already Won. Can not be used together with `lost_time`."},"lost_time":{"type":"string","description":"The optional date and time of changing the deal status as lost in UTC. Format: YYYY-MM-DD HH:MM:SS. Can be set only when deal `status` is already Lost. Can not be used together with `won_time`."},"close_time":{"type":"string","nullable":true,"description":"The optional date and time of closing the deal in UTC. Format: YYYY-MM-DD HH:MM:SS."},"expected_close_date":{"type":"string","format":"date","description":"The expected close date of the deal. In ISO 8601 format: YYYY-MM-DD."},"probability":{"type":"number","description":"The success probability percentage of the deal. Used/shown only when `deal_probability` for the pipeline of the deal is enabled."},"lost_reason":{"type":"string","description":"The optional message about why the deal was lost (to be used when status = lost)"}}},"s_search_result_score":{"type":"object","properties":{"result_score":{"type":"number","description":"Search result relevancy"}}},"s_search_item_base":{"allOf":[{"type":"object","title":"baseSearchResults","properties":{"id":{"type":"integer","description":"The ID of the Entity"},"type":{"type":"string","description":"The type of the Entity\'s item"},"name":{"type":"string","description":"The name of the Entity"},"owner":{"allOf":[{"$ref":"#/components/schemas/s_attr_user_id"}]},"custom_fields":{"type":"array","items":{"type":"string"},"description":"The custom fields"}}}]},"s_search_item_field_notes":{"type":"object","title":"itemSearchResultFieldNotes","properties":{"notes":{"type":"array","description":"An array of notes","items":{"type":"string"}}}},"s_search_item_field_organization":{"type":"object","title":"itemSearchResultFieldOrganization","properties":{"organization":{"type":"object","nullable":true,"properties":{"id":{"type":"integer","description":"The ID of the organization the deal is associated with"},"name":{"type":"string","description":"The name of the organization the deal is associated with"}}}}},"s_search_item_field_person":{"type":"object","title":"itemSearchResultFieldPerson","properties":{"person":{"type":"object","nullable":true,"properties":{"id":{"type":"integer","description":"The ID of the person the deal is associated with"},"name":{"type":"string","description":"The name of the person the deal is associated with"}}}}},"s_search_item_deal":{"allOf":[{"$ref":"#/components/schemas/s_search_item_base"},{"$ref":"#/components/schemas/s_search_item_field_notes"},{"$ref":"#/components/schemas/s_search_item_field_organization"},{"$ref":"#/components/schemas/s_search_item_field_person"},{"$ref":"#/components/schemas/s_attr_deal_title"},{"$ref":"#/components/schemas/s_attr_deal_status"},{"$ref":"#/components/schemas/s_attr_deal_currency"},{"$ref":"#/components/schemas/s_attr_deal_value"},{"type":"object","title":"itemDealSearchResults","properties":{"stage":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the stage of the deal"},"name":{"type":"string","description":"The name of the stage of the deal"}}}}}]},"s_deals_summary_total_count":{"type":"object","properties":{"total_count":{"type":"integer","description":"The total number of deals"}}},"s_deals_summary_values_total":{"type":"object","description":"The total values of the deals grouped by deal currency","properties":{"value":{"type":"number","description":"The total value of deals in the deal currency group"},"count":{"type":"integer","description":"The number of deals in the deal currency group"},"value_converted":{"type":"number","description":"The total value of deals converted into the company default currency"},"value_formatted":{"type":"string","description":"The total value of deals formatted with deal currency. E.g. €50"},"value_converted_formatted":{"type":"string","description":"The value_converted formatted with deal currency. E.g. US$50.10"}}},"s_deals_summary_weighted_values_total":{"type":"object","description":"The total weighted values of the deals grouped by deal currency. The weighted value is calculated as probability times deal value.","properties":{"value":{"type":"number","description":"The total weighted value of the deals in the deal currency group"},"count":{"type":"integer","description":"The number of deals in the deal currency group"},"value_formatted":{"type":"string","description":"The total weighted value of the deals formatted with deal currency. E.g. €50"}}},"s_deals_summary":{"allOf":[{"$ref":"#/components/schemas/s_deals_summary_total_count"},{"type":"object","description":"The summary of deals","properties":{"values_total":{"$ref":"#/components/schemas/s_deals_summary_values_total"},"weighted_values_total":{"$ref":"#/components/schemas/s_deals_summary_weighted_values_total"},"total_currency_converted_value":{"type":"number","description":"The total value of deals converted into the company default currency"},"total_weighted_currency_converted_value":{"type":"number","description":"The total weighted value of deals converted into the company default currency"},"total_currency_converted_value_formatted":{"type":"string","description":"The total converted value of deals formatted with the company default currency. E.g. US$5,100.96"},"total_weighted_currency_converted_value_formatted":{"type":"string","description":"The total weighted value of deals formatted with the company default currency. E.g. US$5,100.96"}}}]},"s_attr_user_user_id":{"type":"object","properties":{"user_id":{"type":"string","description":"The ID of the user"}}},"s_deal_strict_ids":{"allOf":[{"$ref":"#/components/schemas/s_attr_created_by_user_id"},{"$ref":"#/components/schemas/s_attr_deal_id"},{"$ref":"#/components/schemas/s_attr_user_user_id"},{"$ref":"#/components/schemas/s_attr_org_id"},{"type":"object","title":"dealStrictIds","properties":{"person_id":{"type":"integer","description":"The ID of the person associated with the deal"}}}]},"s_deal_strict":{"title":"dealStrict","allOf":[{"$ref":"#/components/schemas/s_deal_strict_ids"},{"$ref":"#/components/schemas/s_deal_get_base"}]},"s_deals_timeline_grouped":{"type":"object","description":"Open and won deals grouped into periods by defined interval, amount and date-type dealField (`field_key`)","properties":{"period_start":{"type":"string","description":"The start date and time of the period"},"period_end":{"type":"string","description":"The end date and time of the period"},"deals":{"type":"array","items":{"$ref":"#/components/schemas/s_deal_strict"}},"totals":{"type":"object","description":"The total values of deals for the given period","properties":{"count":{"type":"integer","description":"The number of deals for the given period"},"values":{"type":"object","description":"The total values of deals grouped by deal currency"},"weighted_values":{"type":"object","description":"The total weighted values of deals for the given period grouped by deal currency. The weighted value of a deal is calculated as probability times deal value."},"open_count":{"type":"integer","description":"The number of open deals for the given period"},"open_values":{"type":"object","description":"The total values of open deals for the given period grouped by deal currency"},"weighted_open_values":{"type":"object","description":"The total weighted values of open deals for the given period grouped by deal currency. The weighted value of a deal is calculated as probability times deal value."},"won_count":{"type":"integer","description":"The number of won deals for the given period"},"won_values":{"type":"object","description":"The total values of won deals for the given period grouped by deal currency"}}}}},"s_deal_get_extended":{"type":"object","properties":{"average_time_to_won":{"type":"object","description":"The average time to win the deal","properties":{"y":{"type":"integer","description":"Years"},"m":{"type":"integer","description":"Months"},"d":{"type":"integer","description":"Days"},"h":{"type":"integer","description":"Hours"},"i":{"type":"integer","description":"Minutes"},"s":{"type":"integer","description":"Seconds"},"total_seconds":{"type":"integer","description":"The total time in seconds"}},"example":{"y":0,"m":0,"d":0,"h":0,"i":20,"s":48,"total_seconds":1249}},"average_stage_progress":{"type":"number","description":"The average of the deal stage progression"},"age":{"type":"object","description":"The lifetime of the deal","properties":{"y":{"type":"integer","description":"Years"},"m":{"type":"integer","description":"Months"},"d":{"type":"integer","description":"Days"},"h":{"type":"integer","description":"Hours"},"i":{"type":"integer","description":"Minutes"},"s":{"type":"integer","description":"Seconds"},"total_seconds":{"type":"integer","description":"The total time in seconds"}}},"stay_in_pipeline_stages":{"type":"object","description":"The details of the duration of the deal being in each stage of the pipeline","properties":{"times_in_stages":{"type":"object","description":"The number of seconds a deal has been in each stage of the pipeline"},"order_of_stages":{"type":"array","description":"The order of the deal progression through the pipeline stages","items":{"type":"integer"}}}},"last_activity":{"type":"object","nullable":true,"description":"The details of the last activity associated with the deal"},"next_activity":{"type":"object","nullable":true,"description":"The details of the next activity associated with the deal"}}},"s_deal":{"title":"dealNonStrictWithDetails","allOf":[{"title":"dealNonStrict","allOf":[{"$ref":"#/components/schemas/s_deal_non_strict_objects"},{"$ref":"#/components/schemas/s_deal_get_base"}]},{"$ref":"#/components/schemas/s_deal_get_extended"}]},"s_person_item_arrays":{"type":"object","title":"personItemArraysEmailAndPhone","properties":{"phone":{"type":"array","description":"A phone number supplied as a string or an array of phone objects related to the person. The structure of the array is as follows: `[{ \\"value\\": \\"12345\\", \\"primary\\": \\"true\\", \\"label\\": \\"mobile\\" }]`. Please note that only `value` is required.","items":{"$ref":"#/components/schemas/s_person_item_phone_array"}},"email":{"type":"array","description":"An email address as a string or an array of email objects related to the person.  The structure of the array is as follows:  `[{ \\"value\\": \\"mail@example.com\\", \\"primary\\": \\"true\\", \\"label\\": \\"main\\" }]`.  Please note that only `value` is required.","items":{"$ref":"#/components/schemas/s_person_item_email_array"}}}},"s_person_redundant":{"type":"object","title":"personRedundant","allOf":[{"$ref":"#/components/schemas/s_attr_organization_org_name"},{"$ref":"#/components/schemas/s_attr_person_person_name"},{"$ref":"#/components/schemas/s_attr_user_owner_name"}]},"s_attr_first_char":{"type":"object","properties":{"first_char":{"type":"string","description":"The first character of the entity name"}}},"s_attr_person_id":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the person"}}},"s_attr_label":{"type":"object","properties":{"label":{"type":"string","description":"The label or multiple labels assigned to the entity"}}},"s_person_item":{"type":"object","title":"personItem","allOf":[{"$ref":"#/components/schemas/s_person_item_arrays"},{"$ref":"#/components/schemas/s_basic_company_id"},{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_person_redundant"},{"$ref":"#/components/schemas/s_attr_first_char"},{"$ref":"#/components/schemas/s_attr_person_id"},{"$ref":"#/components/schemas/s_attr_label"}]},"s_attr_person_name":{"type":"object","properties":{"name":{"type":"string","description":"The name of the person"}}},"s_person_full_name":{"allOf":[{"$ref":"#/components/schemas/s_attr_person_name"},{"type":"object","properties":{"first_name":{"type":"string","description":"The first name of the person"},"last_name":{"type":"string","description":"The last name of the person"}}}]},"s_person_count_email_deal_and_activity_info":[{"type":"object","title":"personCountEmailDealAndActivityInfo","allOf":[{"$ref":"./s_person_count_and_email_info.yaml"},{"$ref":"../../Deals/schemas/s_deal_count_and_activity_info.yaml"}]}],"s_person_additional_info":{"type":"object","title":"additionalPersonInfo","allOf":[{"type":"object","title":"personNameInfoWithOrgAndOwnerId","allOf":[{"$ref":"#/components/schemas/s_person_full_name"},{"type":"object","properties":{"owner_id":{"allOf":[{"description":"The User who is associated with the person"},{"$ref":"#/components/schemas/s_basic_user_id_w_value"}]},"org_id":{"title":"relationshipOrganizationInfoItemWithActiveFlag","allOf":[{"description":"The Organization who is associated with the person"},{"title":"relationshipOrganizationInfoItem","allOf":[{"$ref":"#/components/schemas/s_basic_organization_w_value"},{"$ref":"#/components/schemas/s_attr_active_flag"}]}]}}}]},{"$ref":"#/components/schemas/s_person_count_email_deal_and_activity_info"}]},"s_related_objects_O_U":{"allOf":[{"$ref":"#/components/schemas/s_ro_user"},{"$ref":"#/components/schemas/s_ro_person"}]},"prod_attr_product_id":{"type":"object","properties":{"product_id":{"type":"integer","description":"The ID of the product"}}},"prod_attr_duration_unit":{"type":"object","properties":{"duration_unit":{"type":"string","description":"The unit duration of the product","allOf":[{"title":"dealProductUnitDuration","type":"string","enum":["hourly","daily","weekly","monthly","yearly"]}]}}},"prod_attr_tax":{"type":"object","properties":{"tax":{"type":"number","description":"The tax percentage","default":0}}},"s_r_deal_product_basic":{"allOf":[{"$ref":"#/components/schemas/prod_attr_product_id"},{"$ref":"#/components/schemas/prod_attr_duration_unit"},{"$ref":"#/components/schemas/prod_attr_tax"},{"type":"object","title":"dealProductBasicInternal"}]},"dealprod_attr_id":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the deal-product (the ID of the product attached to the deal)"}}},"prod_attr_name":{"type":"object","properties":{"name":{"type":"string","description":"The name of the product"}}},"dealprod_attr_deal_id":{"type":"object","properties":{"deal_id":{"type":"integer","description":"The ID of the deal"}}},"dealprod_attr_sum":{"type":"object","properties":{"sum":{"type":"number","description":"The sum of all the products attached to the deal"}}},"dealprod_attr_currency":{"type":"object","properties":{"currency":{"type":"string","description":"The currency associated with the deal product"}}},"dealprod_attr_last_edit":{"type":"object","properties":{"last_edit":{"type":"string","description":"The date and time when the deal product was last edited"}}},"s_deal_product_basic":{"allOf":[{"$ref":"#/components/schemas/s_basic_company_id"},{"type":"object","title":"dealProductBasicCompany"},{"$ref":"#/components/schemas/s_r_deal_product_basic"},{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"type":"object","title":"dealProductExtended"},{"$ref":"#/components/schemas/dealprod_attr_id"},{"$ref":"#/components/schemas/prod_attr_name"},{"$ref":"#/components/schemas/dealprod_attr_deal_id"},{"$ref":"#/components/schemas/dealprod_attr_sum"},{"$ref":"#/components/schemas/dealprod_attr_currency"},{"$ref":"#/components/schemas/dealprod_attr_last_edit"}]},"prod_attr_discount":{"type":"object","properties":{"discount":{"type":"number","default":0,"description":"The value of the discount. The `discount_type` field can be used to specify whether the value is an amount or a percentage"}}},"prod_attr_discount_type":{"type":"object","properties":{"discount_type":{"type":"string","enum":["percentage","amount"],"default":"percentage","description":"The type of the discount\'s value"}}},"prod_attr_product_variation_id":{"type":"object","properties":{"product_variation_id":{"type":"integer","nullable":true,"description":"The ID of the product variation. When omitted, no variation will be used"}}},"prod_attr_duration":{"type":"object","properties":{"duration":{"type":"integer","description":"The duration of the product","default":1}}},"prod_attr_quantity":{"type":"object","properties":{"quantity":{"type":"integer","description":"How many items of this product will be added to the deal"}}},"prod_attr_item_price":{"type":"object","properties":{"item_price":{"type":"number","description":"The price at which this product will be added to the deal"}}},"prod_attr_comments":{"type":"object","properties":{"comments":{"type":"string","description":"A textual comment associated with this product-deal attachment"}}},"prod_attr_tax_method":{"type":"object","properties":{"tax_method":{"type":"string","enum":["exclusive","inclusive","none"],"description":"The tax option to be applied to the products. \\nWhen using `inclusive`, the tax percentage will already be included in the price. \\nWhen using `exclusive`, the tax will not be included in the price. \\nWhen using `none`, no tax will be added. \\nUse the `tax` field for defining the tax percentage amount. \\nBy default, the user setting value for  tax options will be used. \\nChanging this in one product affects the rest of the  products attached to the deal"}}},"prod_attr_enabled_flag":{"type":"object","properties":{"enabled_flag":{"type":"boolean","default":true,"description":"Whether the product is enabled or not. This makes it possible to add products to a deal with a specific price and discount criteria, but keep them disabled, which refrains them from being included in the deal value calculation. When omitted, the product will be marked as enabled by default"}}},"s_r_deal_product_extended":{"allOf":[{"type":"object","title":"dealProductExtendedInternal"},{"$ref":"#/components/schemas/prod_attr_discount"},{"$ref":"#/components/schemas/prod_attr_discount_type"},{"$ref":"#/components/schemas/prod_attr_product_variation_id"},{"$ref":"#/components/schemas/prod_attr_duration"},{"$ref":"#/components/schemas/prod_attr_quantity"},{"$ref":"#/components/schemas/prod_attr_item_price"},{"$ref":"#/components/schemas/prod_attr_comments"},{"$ref":"#/components/schemas/prod_attr_tax_method"},{"$ref":"#/components/schemas/prod_attr_enabled_flag"}]},"prod_attr_code":{"type":"object","properties":{"code":{"type":"string","description":"The product code"}}},"prod_attr_prices":{"type":"object","properties":{"prices":{"type":"array","items":{"type":"object"},"description":"An array of objects, each containing:  `currency` (string),  `price` (number),  `cost` (number, optional), `overhead_cost` (number, optional). \\nNote that there can only be one price per product per currency.  When `prices` is omitted altogether,  a default price of 0 and a default currency based  on the company\'s currency will be assigned."}}},"prod_attr_unit":{"type":"object","properties":{"unit":{"type":"string","description":"The unit in which this product is sold"}}},"prod_attr_selectable":{"type":"object","properties":{"selectable":{"type":"boolean","description":"Whether this product is selected in deals or not","default":true}}},"prod_attr_id":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the product"}}},"s_product_w_owner_obj":{"type":"object","title":"baseProductResponse","allOf":[{"$ref":"#/components/schemas/prod_attr_name"},{"$ref":"#/components/schemas/s_attr_active_flag"},{"$ref":"#/components/schemas/prod_attr_code"},{"$ref":"#/components/schemas/prod_attr_prices"},{"$ref":"#/components/schemas/prod_attr_unit"},{"$ref":"#/components/schemas/prod_attr_tax"},{"$ref":"#/components/schemas/prod_attr_selectable"},{"$ref":"#/components/schemas/prod_attr_id"},{"type":"object","properties":{"owner_id":{"allOf":[{"description":"Information about the user who owns the product"},{"$ref":"#/components/schemas/s_basic_user_id_w_value"}]}}}]},"s_deal_product_extended":{"allOf":[{"$ref":"#/components/schemas/s_deal_product_basic"},{"$ref":"#/components/schemas/s_r_deal_product_extended"},{"$ref":"#/components/schemas/s_attr_field_order_nbr"},{"type":"object","properties":{"sum_formatted":{"type":"string","description":"The formatted sum of the product"},"quantity_formatted":{"type":"string","description":"The formatted quantity of the product"},"product":{"$ref":"#/components/schemas/s_product_w_owner_obj"}}}]},"s_deal_product_totals":{"type":"object","title":"dealProductTotals","properties":{"products_quantity_total":{"type":"integer","description":"The total quantity of the products"},"products_sum_total":{"type":"integer","description":"The total sum of the products"},"products_quantity_total_formatted":{"type":"string","description":"The total formatted quantity of the products"},"products_sum_total_formatted":{"type":"string","description":"The total formatted sum of the products"}}},"s_related_objects_USER":{"allOf":[{"$ref":"#/components/schemas/s_ro_user"}]},"s_i_product_request_basic":{"allOf":[{"$ref":"#/components/schemas/prod_attr_product_id"},{"$ref":"#/components/schemas/prod_attr_duration_unit"},{"$ref":"#/components/schemas/prod_attr_tax"},{"type":"object","title":"dealProductRequestBasic"}]},"s_i_product_request_extended":{"allOf":[{"$ref":"#/components/schemas/prod_attr_duration"},{"$ref":"#/components/schemas/prod_attr_discount"},{"$ref":"#/components/schemas/prod_attr_discount_type"},{"$ref":"#/components/schemas/prod_attr_product_variation_id"},{"$ref":"#/components/schemas/prod_attr_tax_method"},{"$ref":"#/components/schemas/prod_attr_enabled_flag"},{"$ref":"#/components/schemas/prod_attr_item_price"},{"$ref":"#/components/schemas/prod_attr_quantity"},{"$ref":"#/components/schemas/prod_attr_comments"},{"type":"object","title":"dealProductRequestExtended"}]},"s_deal_product_request":{"type":"object","title":"basicDealProductRequest","allOf":[{"$ref":"#/components/schemas/s_i_product_request_basic"},{"$ref":"#/components/schemas/s_i_product_request_extended"}]},"s_product_response":{"type":"object","title":"basicDealProductResponse","allOf":[{"$ref":"#/components/schemas/s_r_deal_product_basic"},{"$ref":"#/components/schemas/s_r_deal_product_extended"}]},"prod_attr_product_attachment_id":{"type":"object","properties":{"product_attachment_id":{"type":"integer","description":"The ID of the deal-product (the ID of the product attached to the deal)"}}},"s_field_post_body":{"allOf":[{"$ref":"#/components/schemas/s_fields_create"},{"$ref":"#/components/schemas/s_field_type"}]},"s_field_put_body":{"allOf":[{"$ref":"#/components/schemas/s_fields_create"}]},"s_field_response_delete_id":{"allOf":[{"$ref":"#/components/schemas/s_attr_id_deleted"}]},"s_filter_visible":{"allOf":[{"type":"object","title":"filterVisible"}]},"s_attr_filter_name":{"type":"object","properties":{"name":{"type":"string","description":"The name of the filter"}}},"s_attr_filter_id":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the filter"}}},"s_filter_base":{"allOf":[{"$ref":"#/components/schemas/s_filter_visible"},{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_attr_filter_name"},{"$ref":"#/components/schemas/s_attr_filter_id"},{"$ref":"#/components/schemas/s_attr_user_user_id"},{"type":"object","description":"The filter object","properties":{"type":{"type":"string","enum":["deals","org","persons","products","activity"],"description":"The type of the item"}}}]},"s_filter_request":{"allOf":[{"$ref":"#/components/schemas/s_attr_filter_name"},{"type":"object","title":"FilterRequest","properties":{"conditions":{"type":"object","description":"The conditions of the filter as a JSON object. \\nPlease note that a maximum of 16 conditions is allowed per filter and `date` values must be supplied in the `YYYY-MM-DD` format.\\nIt requires a minimum structure as follows: `{\\"glue\\":\\"and\\",\\"conditions\\":\\n  [{\\n    \\"glue\\":\\"and\\",\\n    \\"conditions\\":\\n      [CONDITION_OBJECTS]\\n    },\\n    {\\"glue\\":\\"or\\",\\n    \\"conditions\\":\\n      [CONDITION_OBJECTS]\\n    }]\\n}`. Replace `CONDITION_OBJECTS` with JSON objects of the following structure: \\n  `{\\"object\\":\\"\\",\\n    \\"field_id\\":\\"\\",\\n    \\"operator\\":\\"\\",\\n    \\"value\\":\\"\\", \\n    \\"extra_value\\":\\"\\"\\n  }` \\nor leave the array empty. \\nDepending on the object type you should use another API endpoint to get `field_id`. \\nThere are five types of objects you can choose from:  `\\"person\\"`,  `\\"deal\\"`, `\\"organization\\"`,  `\\"product\\"`,  `\\"activity\\"`  and you can use these types of operators depending on what type of a field you have:  `\\"IS NOT NULL\\"`,  `\\"IS NULL\\"`,  `\\"<=\\"`, `\\">=\\"`, `\\"<\\"`, `\\">\\"`,  `\\"!=\\"`, `\\"=\\"`,  `\\"LIKE \'$%\'\\"`, `\\"LIKE \'%$%\'\\"`, `\\"NOT LIKE \'$%\'\\"`. \\nTo get a better understanding of how filters work try creating them directly from the Fintesk application."}}}]},"s_filter_request_add":{"allOf":[{"type":"object","title":"addFilterRequestRequired","required":["name","conditions","type"]},{"$ref":"#/components/schemas/s_filter_request"},{"type":"object","title":"addFilterRequestType","properties":{"type":{"type":"string","allOf":[{"type":"string","enum":["deals","org","persons","products","activity"]}],"description":"The type of filter to create"}}}]},"s_filter_conditions":{"description":"The filter conditions","type":"object","properties":{"temporary_flag":{"type":"boolean","description":"If the created filter is temporary or not"},"conditions":{"type":"object","description":"The created filter conditions object"}}},"s_filter_w_conditions":{"title":"filterWithConditions","allOf":[{"$ref":"#/components/schemas/s_filter_base"},{"$ref":"#/components/schemas/s_filter_conditions"}]},"s_filter_request_upd":{"allOf":[{"type":"object","title":"updateFilterRequestRequired","required":["conditions"]},{"$ref":"#/components/schemas/s_filter_request"}]},"s_note_request_content":{"type":"object","title":"noteContent","properties":{"content":{"type":"string","description":"The content of the note in HTML format. Subject to sanitization on the back-end."}}},"s_note_response_basic":{"allOf":[{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_attr_user_user_id"},{"type":"object","title":"noteResponseBasic"},{"$ref":"#/components/schemas/s_note_request_content"}]},"s_note_pinned_response":{"type":"object","properties":{"pinned_to_deal_flag":{"type":"boolean","description":"If true, the results are filtered by note to deal pinning state"},"pinned_to_organization_flag":{"type":"boolean","description":"If true, the results are filtered by note to organization pinning state"},"pinned_to_person_flag":{"type":"boolean","description":"If true, the results are filtered by note to person pinning state"}}},"s_attr_note_id":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the note"}}},"s_attr_note_deal_title":{"type":"object","description":"The deal this note is attached to","properties":{"name":{"type":"string","description":"The name of the deal this note is attached to"}}},"s_attr_organization_name":{"type":"object","properties":{"name":{"type":"string","description":"The name of the organization"}}},"s_attr_user_icon_url":{"type":"object","properties":{"icon_url":{"type":"string","nullable":true,"description":"The URL of the note creator avatar picture"}}},"s_note_response_objects":{"allOf":[{"$ref":"#/components/schemas/s_note_pinned_response"},{"$ref":"#/components/schemas/s_attr_person_id_ref"},{"$ref":"#/components/schemas/s_attr_deal_id_ref"},{"$ref":"#/components/schemas/s_attr_org_id"},{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_attr_note_id"},{"type":"object","title":"noteResponseObjects","properties":{"deal":{"$ref":"#/components/schemas/s_attr_note_deal_title"},"organization":{"allOf":[{"$ref":"#/components/schemas/s_attr_organization_name"},{"type":"object","description":"The organization the note is attached to"}]},"person":{"allOf":[{"$ref":"#/components/schemas/s_person_full_name"},{"type":"object","description":"The person the note is attached to"}]},"user":{"allOf":[{"$ref":"#/components/schemas/s_attr_user_icon_url"},{"$ref":"#/components/schemas/s_attr_user_email"},{"type":"object","description":"The user who created the note","properties":{"is_you":{"type":"boolean","description":"Whether the note is created by you or not"},"name":{"type":"string","description":"The name of the note creator"}}}]}}}]},"s_note_w_objects":{"allOf":[{"$ref":"#/components/schemas/s_note_response_basic"},{"$ref":"#/components/schemas/s_note_response_objects"}]},"s_note_request_ids":{"type":"object","title":"noteRequestReferenceIds","properties":{"deal_id":{"type":"integer","description":"The ID of the deal the note will be attached to. This property is required unless one of (`person_id/org_id`) is specified."},"person_id":{"type":"integer","description":"The ID of the person the note will be attached to. This property is required unless one of (`deal_id/org_id`) is specified."},"org_id":{"type":"integer","description":"The ID of the organization the note will be attached  to. This property is required unless one of (`deal_id/person_id`) is specified."}}},"s_note_pinned_request":{"type":"object","properties":{"pinned_to_deal_flag":{"allOf":[{"title":"numberBoolean","type":"number","enum":[0,1]}],"description":"If set, the results are filtered by note to deal pinning state (`deal_id` is also required)"},"pinned_to_organization_flag":{"allOf":[{"title":"numberBoolean","type":"number","enum":[0,1]}],"description":"If set, the results are filtered by note to organization pinning state (`org_id` is also required)"},"pinned_to_person_flag":{"allOf":[{"title":"numberBoolean","type":"number","enum":[0,1]}],"description":"If set, the results are filtered by note to person pinning state (`person_id` is also required)"}}},"s_note_request_pin":{"allOf":[{"$ref":"#/components/schemas/s_attr_add_time_request"},{"$ref":"#/components/schemas/s_note_pinned_request"},{"type":"object","title":"noteRequestPin","properties":{"user_id":{"type":"integer","description":"The ID of the user who will be marked as the author of the note. Only an admin can change the author."}}}]},"s_note_request":{"type":"object","title":"noteRequest","allOf":[{"$ref":"#/components/schemas/s_note_request_content"},{"$ref":"#/components/schemas/s_note_request_ids"},{"$ref":"#/components/schemas/s_note_request_pin"}]},"s_note_response_comment":{"allOf":[{"type":"object","title":"noteResponseComment","properties":{"uuid":{"type":"string","format":"uuid","description":"The ID of the note"},"object_id":{"type":"string","description":"The ID of the object that the comment is attached to, will be the id of the note"},"object_type":{"type":"string","description":"The type of object that the comment is attached to, will be \\"note\\""},"updater_id":{"type":"integer","description":"The ID of the user who last updated the comment"}}},{"$ref":"#/components/schemas/s_basic_company_id"}]},"s_note_w_comment":{"allOf":[{"$ref":"#/components/schemas/s_note_response_basic"},{"$ref":"#/components/schemas/s_note_response_comment"}]},"s_related_picture_id":{"type":"object","description":"The ID of the picture","allOf":[{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"allOf":[{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the picture associated with the item"}}},{"type":"object","properties":{"item_type":{"type":"string","description":"The type of item the picture is related to"},"item_id":{"type":"integer","description":"The ID of related item"},"added_by_user_id":{"type":"integer","description":"The ID of the user who added the picture"},"pictures":{"type":"object","properties":{"128":{"type":"string","description":"The URL of the 128*128 picture"},"512":{"type":"string","description":"The URL of the 512*512 picture"}}}}}]}]},"s_organization_picture_id":{"type":"object","title":"organizationPictureId","properties":{"picture_id":{"$ref":"#/components/schemas/s_related_picture_id"}}},"s_organization_redundant":{"allOf":[{"$ref":"#/components/schemas/s_attr_user_owner_name"},{"type":"object","title":"organizationRedundant"}]},"s_attr_organization_label":{"allOf":[{"type":"object","title":"organizationLabel"}]},"s_attr_organization_id":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the organization"}}},"s_organization_address":{"allOf":[{"$ref":"#/components/schemas/s_attr_organization_address"},{"type":"object","title":"organizationAddressInfo","properties":{"country_code":{"type":"string","nullable":true,"description":"The country code of the organization"},"address_subpremise":{"type":"string","description":"The sub-premise of the organization location"},"address_street_number":{"type":"string","description":"The street number of the organization location"},"address_route":{"type":"string","description":"The route of the organization location"},"address_sublocality":{"type":"string","description":"The sub-locality of the organization location"},"address_locality":{"type":"string","description":"The locality of the organization location"},"address_admin_area_level_1":{"type":"string","description":"The level 1 admin area of the organization location"},"address_admin_area_level_2":{"type":"string","description":"The level 2 admin area of the organization location"},"address_country":{"type":"string","description":"The country of the organization location"},"address_postal_code":{"type":"string","description":"The postal code of the organization location"},"address_formatted_address":{"type":"string","description":"The formatted organization location"}}}]},"s_organization_count_and_address_info":{"type":"object","title":"organizationCountAndAddressInfo","allOf":[{"$ref":"#/components/schemas/s_organization_address"}]},"s_deal_count_and_activity_info":{"type":"object","title":"dealsCountAndActivityInfo","allOf":[{"$ref":"#/components/schemas/s_deals_activity_info"}]},"s_organization_base":{"type":"object","title":"baseOrganizationItem","allOf":[{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_attr_organization_address"},{"$ref":"#/components/schemas/s_organization_picture_id"},{"$ref":"#/components/schemas/s_organization_redundant"},{"$ref":"#/components/schemas/s_attr_organization_label"},{"$ref":"#/components/schemas/s_basic_company_id"},{"$ref":"#/components/schemas/s_attr_first_char"},{"$ref":"#/components/schemas/s_attr_organization_name"},{"$ref":"#/components/schemas/s_attr_organization_id"},{"type":"object","properties":{"owner_id":{"allOf":[{"description":"The User who is associated with the organization"},{"$ref":"#/components/schemas/s_basic_user_id_w_value"}]}}},{"type":"object","title":"additionalBaseOrganizationItemInfo","allOf":[{"$ref":"#/components/schemas/s_organization_count_and_address_info"},{"$ref":"#/components/schemas/s_deal_count_and_activity_info"}]}]},"s_related_objects_O_U_Pic":{"allOf":[{"$ref":"#/components/schemas/s_ro_user"},{"$ref":"#/components/schemas/s_ro_person"},{"type":"object","properties":{"picture":{"type":"object","description":"The picture that is associated with the item","properties":{"PICTURE_ID":{"$ref":"#/components/schemas/s_related_picture_id"}}}}}]},"s_organization_w_edit_name":{"title":"baseOrganizationItemWithEditNameFlag","allOf":[{"$ref":"#/components/schemas/s_organization_base"}]},"s_search_item_organization":{"allOf":[{"$ref":"#/components/schemas/s_search_item_base"},{"$ref":"#/components/schemas/s_attr_organization_address"},{"type":"object","title":"itemOrganizationSearchResults","properties":{"notes":{"type":"array","description":"An array of notes","items":{"type":"string"}}}}]},"s_organization_activity_object":{"type":"object","title":"organizationActivityObject","properties":{"last_activity":{"type":"object","nullable":true,"description":"Please refer to response schema of  [Activity](../../fintesk/api/v1#tag/Activities/operation/getActivity)"},"next_activity":{"type":"object","nullable":true,"description":"Please refer to response schema of  [Activity](../../fintesk/api/v1#tag/Activities/operation/getActivity)"}}},"s_organization_item":{"title":"organizationItem","allOf":[{"$ref":"#/components/schemas/s_organization_w_edit_name"},{"$ref":"#/components/schemas/s_organization_activity_object"}]},"s_organization_item_follower":{"allOf":[{"type":"object","title":"organizationFollower"}]},"s_attr_product_id_ref":{"type":"object","properties":{"product_id":{"description":"The ID of the product this Item is associated with","type":"integer"}}},"s_attr_activity_id_ref":{"type":"object","properties":{"activity_id":{"description":"The ID of the activity this Item is associated with","type":"integer"}}},"s_attr_user_id_ref":{"type":"object","properties":{"user_id":{"type":"integer","description":"The ID of the user this Item is associated with"}}},"s_file_reference":{"allOf":[{"$ref":"#/components/schemas/s_attr_person_id_ref"},{"$ref":"#/components/schemas/s_attr_deal_id_ref"},{"$ref":"#/components/schemas/s_attr_org_id"},{"$ref":"#/components/schemas/s_attr_product_id_ref"},{"$ref":"#/components/schemas/s_attr_activity_id_ref"},{"$ref":"#/components/schemas/s_attr_user_id_ref"},{"type":"object","title":"fileReferences"}]},"prod_attr_product_name":{"type":"object","title":"productProductName","properties":{"product_name":{"type":"string","description":"The name of the product associated with the entity"}}},"s_file_redundant":{"allOf":[{"$ref":"#/components/schemas/s_attr_organization_org_name"},{"$ref":"#/components/schemas/s_attr_person_person_name"},{"$ref":"#/components/schemas/s_attr_deal_deal_title"},{"$ref":"#/components/schemas/s_attr_organization_org_name"},{"$ref":"#/components/schemas/prod_attr_product_name"},{"type":"object","title":"fileRedundant"}]},"s_file_bucket":{"type":"object","title":"fileBucket","properties":{"url":{"type":"string","description":"The URL of the download file"},"file_name":{"type":"string","description":"The original name of the file"},"file_size":{"type":"integer","description":"The size of the file"},"inline_flag":{"type":"boolean","description":"Whether the file was uploaded as inline or not"},"remote_location":{"type":"string","description":"The location type to send the file to. Only googledrive is supported at the moment."},"remote_id":{"type":"string","description":"The ID of the remote item"},"cid":{"type":"string","description":"The ID of the inline attachment"},"s3_bucket":{"type":"string","description":"The location of the cloud storage"}}},"s_attr_file_id":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the file"}}},"s_file":{"allOf":[{"$ref":"#/components/schemas/s_file_reference"},{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_file_redundant"},{"$ref":"#/components/schemas/s_file_bucket"},{"$ref":"#/components/schemas/s_attr_file_id"},{"type":"object","description":"The file data","properties":{"name":{"type":"string","description":"The visible name of the file"},"description":{"type":"string","description":"The description of the file"}}}]},"s_person_request":{"allOf":[{"$ref":"#/components/schemas/s_person_item_arrays"},{"$ref":"#/components/schemas/s_attr_person_name"},{"$ref":"#/components/schemas/s_attr_add_time_request"},{"$ref":"#/components/schemas/s_attr_org_id"},{"title":"basicPersonRequest","type":"object","properties":{"owner_id":{"type":"integer","description":"The ID of the user who will be marked as the owner of this person.  When omitted, the authorized user ID will be used."}}}]},"s_search_item_person":{"allOf":[{"$ref":"#/components/schemas/s_search_item_base"},{"$ref":"#/components/schemas/s_search_item_field_notes"},{"$ref":"#/components/schemas/s_search_item_field_organization"},{"type":"object","title":"itemPersonSearchResults","properties":{"phones":{"type":"array","description":"An array of phone numbers","items":{"type":"string"}},"emails":{"type":"array","description":"An array of email addresses","items":{"type":"string"}}}}]},"prod_attr_owner_id":{"type":"object","title":"owner_id","properties":{"owner_id":{"type":"integer","description":"The ID of the user who will be marked as the owner of this product. When omitted, the authorized user ID will be used"}}},"prod_attr_description":{"type":"object","properties":{"description":{"type":"string","description":"The description of the product"}}},"prod_attr_category":{"type":"object","properties":{"category":{"type":"string","description":"The category of the product"}}},"prod_attr_files_count":{"type":"object","properties":{"files_count":{"type":"integer","description":"The count of files"}}},"prod_attr_first_char":{"allOf":[{"$ref":"#/components/schemas/s_attr_first_char"}]},"s_product_base":{"allOf":[{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_basic_company_id"},{"$ref":"#/components/schemas/prod_attr_id"},{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/prod_attr_owner_id"},{"$ref":"#/components/schemas/prod_attr_name"},{"$ref":"#/components/schemas/prod_attr_tax"},{"$ref":"#/components/schemas/prod_attr_code"},{"$ref":"#/components/schemas/prod_attr_description"},{"$ref":"#/components/schemas/prod_attr_unit"},{"$ref":"#/components/schemas/prod_attr_category"},{"$ref":"#/components/schemas/prod_attr_selectable"},{"$ref":"#/components/schemas/prod_attr_files_count"},{"$ref":"#/components/schemas/prod_attr_first_char"}]},"s_product_base_w_deal_id":{"allOf":[{"$ref":"#/components/schemas/s_product_base"},{"$ref":"#/components/schemas/dealprod_attr_deal_id"}]},"s_person_products":{"type":"object","properties":{"DEAL_ID":{"type":"object","properties":{"deal":{"properties":{"allOf":[{"$ref":"../../_components/schemas_entities/s_attr_person_id_ref.yaml"},{"$ref":"../../_components/schemas_entities/s_attr_org_id.yaml"},{"$ref":"../../_components/schemas_entities/s_attr_user_id_ref.yaml"},{"$ref":"../../Deals/schemas/s_deals_activity_info.yaml"},{"$ref":"../../Deals/schemas/s_deals_get_basic.yaml"},{"$ref":"../../_components/schemas_entities/s_basic_company_id.yaml"},{"$ref":"../../Deals/schemas/s_attr_deal_id.yaml"},{"type":"object","properties":{"first_add_time":{"type":"string","description":"The first creation date and time of the deal"}}}],"product":{"$ref":"#/components/schemas/s_product_base_w_deal_id"}}}}}}},"s_pipeline_base_w_selected_flag":{"type":"object","title":"basePipelineWithSelectedFlag","allOf":[{"$ref":"#/components/schemas/s_pipeline_base"},{"type":"object","properties":{"selected":{"type":"boolean","description":"A boolean that shows if the pipeline is selected from a filter or not"}}}]},"s_pipeline_request":{"allOf":[{"$ref":"#/components/schemas/s_attr_field_order_nbr"},{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_pipeline_attr_deal_probability"},{"$ref":"#/components/schemas/s_attr_pipeline_name"},{"type":"object","title":"pipelineRequest"}]},"s_product_request":{"allOf":[{"$ref":"#/components/schemas/prod_attr_code"},{"$ref":"#/components/schemas/prod_attr_prices"},{"$ref":"#/components/schemas/prod_attr_unit"},{"$ref":"#/components/schemas/prod_attr_tax"},{"$ref":"#/components/schemas/prod_attr_selectable"},{"$ref":"#/components/schemas/s_attr_active_flag"},{"title":"productRequest","type":"object"},{"$ref":"#/components/schemas/prod_attr_owner_id"}]},"s_product_request_crud":{"type":"object","title":"updateProductRequest","allOf":[{"$ref":"#/components/schemas/s_product_request"},{"$ref":"#/components/schemas/prod_attr_name"}]},"s_fail_response":{"title":"failResponse","type":"object","properties":{"success":{"type":"boolean","description":"If the response is successful or not"},"error":{"type":"string","description":"The error message"},"errorCode":{"type":"integer","description":"The response error code"}}},"s_attr_item_id":{"type":"object","properties":{"id":{"type":"integer","description":"The ID of the Item"}}},"s_item_activity":{"allOf":[{"$ref":"#/components/schemas/s_attr_item_id"},{"type":"object","title":"activity","properties":{"item":{"type":"string","enum":["activity"]},"data":{"title":"activityResponseObject","allOf":[{"$ref":"#/components/schemas/s_activity_extended"},{"$ref":"#/components/schemas/s_activity"}]}}}]},"s_item_activity_type":{"allOf":[{"$ref":"#/components/schemas/s_attr_item_id"},{"type":"object","title":"activityType","properties":{"item":{"type":"string","enum":["activityType"]},"data":{"$ref":"#/components/schemas/s_activity_type"}}}]},"s_item_deal":{"allOf":[{"$ref":"#/components/schemas/s_attr_item_id"},{"type":"object","title":"deal","properties":{"item":{"type":"string","enum":["deal"]},"data":{"$ref":"#/components/schemas/s_deal_strict"}}}]},"s_item_file":{"allOf":[{"$ref":"#/components/schemas/s_attr_item_id"},{"type":"object","title":"file","properties":{"item":{"type":"string","enum":["file"]},"data":{"$ref":"#/components/schemas/s_file"}}}]},"s_item_filter":{"allOf":[{"$ref":"#/components/schemas/s_attr_item_id"},{"type":"object","title":"filter","properties":{"item":{"type":"string","enum":["filter"]},"data":{"$ref":"#/components/schemas/s_filter_base"}}}]},"s_item_note":{"allOf":[{"$ref":"#/components/schemas/s_attr_item_id"},{"type":"object","title":"note","properties":{"item":{"type":"string","enum":["note"]},"data":{"$ref":"#/components/schemas/s_note_w_objects"}}}]},"s_recents_merge_person_info":{"type":"object","title":"mergePersonItem","allOf":[{"$ref":"#/components/schemas/s_person_item"},{"type":"object","title":"additionalMergePersonInfo","allOf":["../../Persons/schemas/s_recents_person_name_count_and_email_info_with_ids.yaml","../../Persons/schemas/s_recents_merge_person_deal_related_info.yaml"]}]},"s_item_person":{"allOf":[{"$ref":"#/components/schemas/s_attr_item_id"},{"type":"object","title":"person","properties":{"item":{"type":"string","enum":["person"]},"data":{"$ref":"#/components/schemas/s_recents_merge_person_info"}}}]},"s_item_organization":{"allOf":[{"$ref":"#/components/schemas/s_attr_item_id"},{"type":"object","title":"organization","properties":{"item":{"type":"string","enum":["organization"]},"data":{"$ref":"#/components/schemas/s_organization_base"}}}]},"s_item_pipeline":{"allOf":[{"$ref":"#/components/schemas/s_attr_item_id"},{"type":"object","title":"pipeline","properties":{"item":{"type":"string","enum":["pipeline"]},"data":{"$ref":"#/components/schemas/s_pipeline_base"}}}]},"s_product_base_w_prices":{"allOf":[{"$ref":"#/components/schemas/s_product_base"},{"$ref":"#/components/schemas/prod_attr_prices"}]},"s_item_product":{"allOf":[{"$ref":"#/components/schemas/s_attr_item_id"},{"type":"object","title":"product","properties":{"item":{"type":"string","enum":["product"]},"data":{"$ref":"#/components/schemas/s_product_base_w_prices"}}}]},"s_item_stage":{"allOf":[{"$ref":"#/components/schemas/s_attr_item_id"},{"type":"object","title":"stage","properties":{"item":{"type":"string","enum":["stage"]},"data":{"$ref":"#/components/schemas/s_stage_base"}}}]},"s_user_locale":{"type":"object","title":"userTimezone","properties":{"timezone_name":{"type":"string","description":"The user timezone name"},"timezone_offset":{"type":"string","description":"The user timezone offset"},"locale":{"type":"string","description":"The user locale"},"lang":{"type":"integer","description":"The user language ID"}}},"s_attr_user_role_id":{"type":"object","properties":{"role_id":{"type":"integer","description":"The ID of the role the user was added to"}}},"s_user":{"allOf":[{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"$ref":"#/components/schemas/s_user_locale"},{"$ref":"#/components/schemas/s_attr_user_email"},{"$ref":"#/components/schemas/s_attr_user_role_id"},{"$ref":"#/components/schemas/s_attr_user_icon_url"},{"$ref":"#/components/schemas/s_attr_user_name"},{"$ref":"#/components/schemas/s_attr_user_id"},{"type":"object","title":"baseUser","properties":{"default_currency":{"type":"string","description":"The user default currency"},"phone":{"type":"string","nullable":true,"description":"The user phone"},"last_login":{"type":"string","description":"The last login date and time of the user. Format: YYYY-MM-DD HH:MM:SS"},"is_you":{"type":"boolean","description":"Boolean that indicates if the requested user is the same which is logged in (in this case, always true)"}}}]},"s_item_user":{"allOf":[{"$ref":"#/components/schemas/s_attr_item_id"},{"type":"object","title":"user","properties":{"item":{"type":"string","enum":["user"]},"data":{"$ref":"#/components/schemas/s_user"}}}]},"s_attr_role_name":{"type":"object","properties":{"name":{"type":"string","description":"The name of the role"}}},"s_attr_role_parent_role_id":{"type":"object","properties":{"parent_role_id":{"type":"integer","description":"The ID of the parent role"}}},"s_role_base_request":{"allOf":[{"$ref":"#/components/schemas/s_attr_role_name"},{"$ref":"#/components/schemas/s_attr_role_parent_role_id"},{"type":"object","title":"baseRoleRequest"}]},"s_attr_role_id":{"type":"object","properties":{"id":{"type":"string","description":"The ID of the role"}}},"s_role_subrole_counts":{"allOf":[{"$ref":"#/components/schemas/s_attr_role_id"},{"$ref":"#/components/schemas/s_basic_entity_attributes"},{"type":"object","properties":{"assignment_count":{"type":"string","description":"The number of users assigned to this role"},"sub_role_count":{"type":"string","description":"The number of sub-roles"}}}]},"s_role_subrole":{"allOf":[{"type":"object","title":"subRole","description":"The details of the sub-role"},{"$ref":"#/components/schemas/s_role_base_request"},{"$ref":"#/components/schemas/s_role_subrole_counts"}]},"s_role_fullrole":{"title":"fullRole","allOf":[{"$ref":"#/components/schemas/s_role_subrole"},{"type":"object","properties":{"level":{"type":"integer","description":"The level of role in the role hierarchy"}}}]},"s_attr_id_created":{"type":"object","title":"createdID","properties":{"id":{"type":"integer","description":"The ID of the created item."}}},"s_role_settings_default_visibility":{"description":"The settings for the role","type":"object","properties":{"deal_default_visibility":{"type":"number","description":"The default visibility level of the deals for the role"},"org_default_visibility":{"type":"number","description":"The default visibility level of the organizations for the role"},"person_default_visibility":{"type":"number","description":"The default visibility level of the persons for the role"},"product_default_visibility":{"type":"number","description":"The default visibility level of the products for the role"},"deal_access_level":{"type":"number","description":"The access level of the deals for the role (only for default role)"},"org_access_level":{"type":"number","description":"The access level of the organizations for the role (only for default role)"},"person_access_level":{"type":"number","description":"The access level of the persons for the role (only for default role)"},"product_access_level":{"type":"number","description":"The access level of the products for the role (only for default role)"}}},"s_attr_id_updated":{"type":"object","title":"updatedID","properties":{"id":{"type":"integer","description":"The ID of the updated item."}}},"s_role_assignment":{"title":"roleAssignment","allOf":[{"$ref":"#/components/schemas/s_role_base_request"},{"$ref":"#/components/schemas/s_attr_user_role_id"},{"$ref":"#/components/schemas/s_attr_user_user_id"},{"type":"object","properties":{"active_flag":{"type":"boolean","description":"Whether the role is active or not"},"type":{"type":"string","description":"The assignment type"}}}],"description":"The assignment data of the role"},"s_role_setting_post":{"title":"addOrUpdateRoleSettingRequest","type":"object","required":["setting_key","value"],"properties":{"setting_key":{"type":"string","enum":["deal_default_visibility","org_default_visibility","person_default_visibility","product_default_visibility"]},"value":{"type":"integer","enum":[1,3,5,7],"description":"Possible values for the `default_visibility` setting depending on the subscription plan: <br> <table class=\'role-setting\'>\\n  <caption>\\n    <b>Essential / Advanced plan</b>\\n  </caption>\\n  <tr>\\n    <th>\\n      <b>Value</b>\\n    </th>\\n    <th>\\n      <b>Description</b>\\n    </th>\\n  </tr>\\n  <tr>\\n    <td>`1`</td>\\n    <td>Owner & Followers</td>\\n  </tr>\\n  <tr>\\n    <td>`3`</td>\\n    <td>Entire company</td>\\n  </tr>\\n</table> <br>\\n  <table class=\'role-setting\'>\\n    <caption>\\n      <b>Professional / Enterprise plan</b>\\n    </caption>\\n    <tr>\\n      <th>\\n        <b>Value</b>\\n      </th>\\n      <th>\\n        <b>Description</b>\\n      </th>\\n    </tr>\\n    <tr>\\n      <td>`1`</td>\\n      <td>Owner only</td>\\n    </tr>\\n    <tr>\\n      <td>`3`</td>\\n      <td>Owner&#39;s visibility group</td>\\n    </tr>\\n    <tr>\\n      <td>`5`</td>\\n      <td>Owner&#39;s visibility group and sub-groups</td>\\n    </tr>\\n    <tr>\\n      <td>`7`</td>\\n      <td>Entire company</td>\\n    </tr>\\n  </table>\\n  <br> Read more about visibility  groups \\n  <a href=\'https://support.pipedrive.com/en/article/visibility-groups\'>here</a>."}}},"s_role_pipelines":{"type":"object","properties":{"pipeline_ids":{"type":"array","items":{"type":"number","description":"The ID of the pipeline"},"description":"Either visible or hidden pipeline ids"},"visible":{"type":"boolean","description":"Whether visible or hidden pipeline ids were returned"}},"description":"The response data"},"s_attr_role_visible_pipeline_ids":{"type":"object","properties":{"visible_pipeline_ids":{"type":"object","description":"The pipeline IDs to make the pipelines visible (add) and/or hidden (remove) for the specified role.  It requires the following JSON structure:  `{ \\"add\\": \\"[1]\\", \\"remove\\": \\"[3,4]\\" }`."}}},"s_stage_pipeline_attr":{"type":"object","properties":{"pipeline_name":{"type":"string","description":"The name of the pipeline"},"pipeline_deal_probability":{"type":"boolean","description":"The pipeline deal probability. When `true`, overrides the stage probability."}}},"s_stage_attr_deal_probability":{"type":"object","properties":{"deal_probability":{"type":"integer","description":"The success probability percentage of the deal. Used/shown when the deal weighted values are used."}}},"s_stage_deal_attr":{"allOf":[{"$ref":"#/components/schemas/s_stage_attr_deal_probability"},{"type":"object","title":"stageRotten","properties":{"rotten_flag":{"type":"boolean","description":"Whether deals in this stage can become rotten"},"rotten_days":{"type":"integer","description":"The number of days the deals not updated in this stage would become rotten. Applies only if the `rotten_flag` is set."}}}]},"s_stage":{"title":"stageResponse","allOf":[{"$ref":"#/components/schemas/s_stage_base"},{"$ref":"#/components/schemas/s_stage_pipeline_attr"},{"$ref":"#/components/schemas/s_stage_deal_attr"}]},"s_stage_request_basic":{"allOf":[{"$ref":"#/components/schemas/s_attr_deal_pipeline_id"},{"$ref":"#/components/schemas/s_stage_attr_deal_probability"},{"$ref":"#/components/schemas/s_attr_stage_name"},{"type":"object","title":"stageBasicRequest","properties":{"rotten_flag":{"type":"boolean","description":"Whether deals in this stage can become rotten"},"rotten_days":{"type":"integer","description":"The number of days the deals not updated in this stage would become rotten. Applies only if the `rotten_flag` is set."}}}]},"s_attr_deal_summary_count":{"type":"object","properties":{"count":{"type":"integer","description":"Deals count per currency"}}},"s_attr_deal_summary_value":{"type":"object","properties":{"value":{"type":"integer","description":"Deals value per currency"}}},"s_deal_summary":{"type":"object","title":"dealSummary","properties":{"deals_summary":{"type":"object","description":"Deals summary","properties":{"per_stages":{"type":"object","description":"The stage objects containing deals currency information","properties":{"STAGE_ID":{"type":"object","description":"The currency summaries per stage. This parameter is dynamic and  changes according to `stage_id` value.","properties":{"CURRENCY_ID":{"allOf":[{"$ref":"#/components/schemas/s_attr_deal_weighted_value_formatted"},{"$ref":"#/components/schemas/s_attr_deal_weighted_value"},{"$ref":"#/components/schemas/s_attr_deal_summary_count"},{"$ref":"#/components/schemas/s_attr_deal_summary_value"},{"type":"object","description":"The currency summary. This parameter is dynamic and  changes according to `currency_id` value.","properties":{"value_formatted":{"type":"string","description":"Deals value formatted per currency"}}}]}}}}},"per_currency":{"type":"object","description":"The currency count summary","properties":{"CURRENCY_ID":{"type":"integer","description":"Deals count per currency. This parameter is dynamic and changes  according to `currency_id` value."}}},"total_count":{"type":"integer","description":"Deals count"},"per_currency_full":{"type":"object","description":"Full currency summaries","properties":{"CURRENCY_ID":{"allOf":[{"$ref":"#/components/schemas/s_attr_deal_summary_count"},{"$ref":"#/components/schemas/s_attr_deal_summary_value"},{"type":"object","description":"The currency summary. This parameter is dynamic and changes  according to `currency_id` value."}]}}}}}}},"s_stage_request_w_order_nbr":{"title":"stageWOrderNbr","allOf":[{"$ref":"#/components/schemas/s_stage_request_basic"},{"type":"object","properties":{"order_nbr":{"type":"integer","description":"An order number for this stage. Order numbers should be used to order the stages in the pipeline."}}}]},"s_user_access":{"type":"object","title":"userAccess","properties":{"access":{"type":"array","items":{"type":"object","properties":{"app":{"type":"string","enum":["sales","global","account_settings"]},"admin":{"type":"boolean"},"permission_set_id":{"type":"string"}},"required":["app"],"description":"The access given to the user. Each item in the array represents access to a specific app. Optionally may include either admin flag or permission set ID to specify which access to give within the app. If both are omitted, the default access for the corresponding app will be used. It requires structure as follows: `[{ app: \'sales\', permission_set_id: \'62cc4d7f-4038-4352-abf3-a8c1c822b631\' }, { app: \'global\', admin: true }, { app: \'account_settings\' }]`\\n","default":[{"app":"sales"}]}}}},"s_user_company":{"allOf":[{"$ref":"#/components/schemas/s_basic_company_id"},{"type":"object","title":"userCompany","properties":{"company_name":{"type":"string","description":"The user company name"},"company_domain":{"type":"string","description":"The user company domain"},"company_country":{"type":"string","description":"The user company country"},"company_industry":{"type":"string","description":"The user company industry"},"language":{"type":"object","description":"The user language details","properties":{"language_code":{"type":"string","description":"The language code. E.g. en"},"country_code":{"type":"string","description":"The country code. E.g. US"}}}}}]},"s_user_w_company":{"title":"userWithCompany","allOf":[{"$ref":"#/components/schemas/s_user"},{"$ref":"#/components/schemas/s_user_company"}]}}}}}},"docusaurus-theme-redoc":{"theme-redoc":{"lightTheme":{"typography":{"fontFamily":"var(--ifm-font-family-base)","fontSize":"var(--ifm-font-size-base)","lineHeight":"var(--ifm-line-height-base)","fontWeightLight":"var(--ifm-font-weight-light)","fontWeightRegular":"var(--ifm-font-weight-base)","fontWeightBold":"var(--ifm-font-weight-bold)","headings":{"fontFamily":"var(--ifm-heading-font-family)","fontWeight":"var(--ifm-heading-font-weight)","lineHeight":"var(--ifm-heading-line-height)"},"code":{"fontFamily":"var(--ifm-font-family-monospace)","lineHeight":"var(--ifm-pre-line-height)"}},"sidebar":{"width":"300px","backgroundColor":"#ffffff"},"rightPanel":{"backgroundColor":"#303846"},"colors":{"primary":{"main":"#1890ff"}},"theme":{"prism":{"additionalLanguages":["scala"]}}},"darkTheme":{"typography":{"fontFamily":"var(--ifm-font-family-base)","fontSize":"var(--ifm-font-size-base)","lineHeight":"var(--ifm-line-height-base)","fontWeightLight":"var(--ifm-font-weight-light)","fontWeightRegular":"var(--ifm-font-weight-base)","fontWeightBold":"var(--ifm-font-weight-bold)","headings":{"fontFamily":"var(--ifm-heading-font-family)","fontWeight":"var(--ifm-heading-font-weight)","lineHeight":"var(--ifm-heading-line-height)"},"code":{"fontFamily":"var(--ifm-font-family-monospace)","lineHeight":"var(--ifm-pre-line-height)"}},"sidebar":{"width":"300px","backgroundColor":"rgb(24, 25, 26)","textColor":"#f5f6f7","arrow":{"color":"#f5f6f7"}},"colors":{"text":{"primary":"#f5f6f7","secondary":"rgba(255, 255, 255, 1)"},"gray":{"50":"#FAFAFA","100":"#F5F5F5"},"border":{"dark":"#ffffff","light":"rgba(0,0,0, 0.1)"},"primary":{"main":"#1890ff"}},"schema":{"nestedBackground":"rgb(24, 25, 26)","typeNameColor":"rgba(255, 255, 255, 1)","typeTitleColor":"rgba(255, 255, 255, 1)"},"theme":{"prism":{"additionalLanguages":["scala"]}}},"options":{"scrollYOffset":"nav.navbar","expandSingleSchemaField":true,"menuToggle":true,"suppressWarnings":true}}},"docusaurus-plugin-google-tag-manager":{"default":{"containerId":"GTM-MFMP7WDH","id":"default"}},"@orama/plugin-docusaurus-v3":{"default":{"oramaMode":"oss","oramaDocs":[{"title":"¿Qué le sucede a mi facturación cuando agrego un usuario en Fintesk?","content":"<p>&lt;!-- ../../billing/billing-information/what-happens-to-my-billing-when-i-add-a-user-in-fintesk.md --&gt;</p>\\n<p>&lt;!-- # What happens to my billing when I add a user in Fintesk? --&gt;</p>\\n<p>Cuando invita a un usuario a unirse a su cuenta de Fintesk y darles <a href=\\"../../kb/users-and-permissions/global-user-management\\">Acceso a los negocios</a>, ese nuevo usuario ocupará un asiento en su cuenta de Fintesk.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202023-03-20%20at%2013.55.53.png\\" alt=\\"1\\"> --&gt;</p>\\n<ul>\\n<li>\\n<p><strong>Si agrega un nuevo usuario y ya tiene un asiento abierto en su cuenta</strong>, entonces ese usuario ocupará ese asiento abierto. En este caso, nada en la información de facturación de la cuenta cambiará.</p>\\n</li>\\n<li>\\n<p><strong>Si no tiene un asiento abierto en su cuenta</strong>, agregar un usuario aumentará el recuento de asientos facturados en su suscripción. Esto significa que se le facturará inmediatamente después de que el asiento se haya agregado a su cuenta. El cargo que vea será un cargo prorrateado que refleje el tiempo restante en su ciclo de suscripción actual.</p>\\n</li>\\n</ul>\\n<p>Por ejemplo, si su plan de facturación <strong>Plan avanzado</strong> comenzó el 5 de marzo y agrega un asiento adicional el 20 de marzo, se le cobrará el 20 de marzo la cantidad prorrateada del tiempo que queda del ciclo actual para su asiento adicional. El 5 de abril, se le facturará el monto total para los usuarios en el plan avanzado mensual.</p>\\n<p>Verá estos cambios y su actualización de facturación en su resumen de pago.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202023-03-20%20at%2016.43.09.png\\" alt=\\"1\\"> --&gt;</p>\\n<p>Obtenga más información sobre la diferencia entre un asiento facturado y un usuario de Fintesk en <a href=\\"../../kb/getting-started/what-is-the-difference-between-a-user-and-a-seat\\">este artículo</a> y encuentre más información sobre los precios en nuestra <a href=\\"https://fintesk.com/es/precios/?utm_source=fintesk-docs\\">página de precios</a>.</p>\\n","section":"¿Qué le sucede a mi facturación cuando agrego un usuario en Fintesk?","version":"current","path":"/es/billing/billing-information/what-happens-to-my-billing-when-i-add-a-user-in-fintesk","category":"default"},{"title":"Mensual a anual","content":"Si cambia de mensual a anual la facturación, los cambios entrarán en vigencia al comienzo del próximo ciclo de facturación.\\nEjemplo:\\nUn usuario está en un ciclo de facturación mensual renovado el 1 de enero y cambia de facturación mensual a facturación anual el 15 de enero.\\nEl usuario estará en el ciclo de facturación mensual para el resto del período de facturación y se le cobrará por la suscripción anual de facturación el 1 de febrero.\\n<!--\\nWhile the change is pending, you will see a banner at the top of your billing overview page specifying the scheduled update. -->\\n\\n","section":"¿Qué sucede con mi facturación cuando cambio mi frecuencia de facturación?","version":"current","path":"/es/billing/billing-information/what-happens-to-my-billing-when-i-change-my-billing-frequency#mensual-a-anual","category":"default"},{"title":"Anual a mensual","content":"Si cambia la facturación de anual a mensual, los cambios entrarán en vigencia a partir de la próxima fecha de renovación.\\nEjemplo:\\nUn usuario está en un plan de facturación anual renovado el 1 de enero y cambia a facturación mensual el 30 de junio.\\nEl usuario mantendrá el ciclo de facturación anual con el descuento asociado para el resto del período de facturación y se le cobrará por la suscripción de facturación mensual el 1 de enero (del año siguiente).\\n<!-- While this change is pending, you will see a banner at the top of your billing overview page specifying the scheduled update. -->\\n","section":"¿Qué sucede con mi facturación cuando cambio mi frecuencia de facturación?","version":"current","path":"/es/billing/billing-information/what-happens-to-my-billing-when-i-change-my-billing-frequency#anual-a-mensual","category":"default"},{"title":"Actualizando planes","content":"Si está actualizando un plan, el nuevo plan se aplicará de inmediato y recibirá una nota de crédito y una factura. La nota de crédito será para el saldo restante en el período actual del plan original.\\nLuego recibirás una factura de cobro por el nuevo plan para el resto del ciclo de facturación. El balance de la nota de crédito se aplicará completamente a la factura para tu nuevo plan.\\nEjemplo:\\nUn usuario en el Plan avanzado facturado mensualmente se cambia al Plan profesional a mitad de camino en su ciclo de facturación.\\nNota de crédito:\\nUna nota de crédito para el tiempo restante (2 semanas) en el ciclo mensual para el plan avanzado\\nFactura:\\nUna factura para el plan profesional para el tiempo restante (2 semanas) en el ciclo de facturación. El saldo de la nota de crédito se aplicará para pagar parcialmente esta nueva factura.\\n\\n","section":"¿Qué sucede con mi facturación cuando cambio mi plan de suscripción de Fintesk?","version":"current","path":"/es/billing/billing-information/what-happens-to-my-billing-when-i-change-my-fintesk-subscription-plan#actualizando-planes","category":"default"},{"title":"Bajando planes","content":"Si quieres bajar un plan, los cambios entrarán en vigencia al comienzo del próximo ciclo de facturación, cuando se emite la próxima factura de renovación.\\nOtros cambios de suscripción realizados antes del final del ciclo de facturación actual pueden anular el cambio programado.\\nEjemplo:\\nUn usuario en el Plan profesional facturandose mensualmente, se cambia al Plan avanzado a mitad del ciclo de facturación.\\nEl usuario estará en el Plan profesional para el resto del ciclo de facturación y se le cobrará por el nuevo plan al comienzo del nuevo ciclo\\n<!-- While the change is pending, you’ll see a banner at the top of your billing overview page specifying the scheduled update.\\n-->\\n","section":"¿Qué sucede con mi facturación cuando cambio mi plan de suscripción de Fintesk?","version":"current","path":"/es/billing/billing-information/what-happens-to-my-billing-when-i-change-my-fintesk-subscription-plan#bajando-planes","category":"default"},{"title":"¿Qué sucede con mi facturación cuando desactivo a un usuario en Fintesk?","content":"<p>&lt;!-- ../../billing/billing-information/what-happens-to-my-billing-when-i-deactivate-a-user-in-fintesk.md --&gt;</p>\\n<p>:::tip\\n<strong>Nota:</strong> Esta acción solo está disponible para usuarios con acceso de <strong>Configuración de la cuenta</strong>.\\n:::</p>\\n<p>Cuando <a href=\\"../../kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user\\">desactivas a un usuario</a>, verá una ventana emergente con la información asignada a ese usuario, así como la opción de eliminar ese asiento no utilizado.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202023-03-14%20at%2012.05.34.png\\" alt=\\"1\\"> --&gt;</p>\\n<ul>\\n<li><strong>Si elimina este asiento no utilizado</strong>, los cambios entrarán en vigencia al comienzo de su próximo ciclo de facturación. Si llena los asientos con nuevos usuarios antes de esta fecha, los asientos no se eliminarán.</li>\\n<li><strong>Si no quita este asiento no utilizado</strong>, el asiento aún existirá en su cuenta y la facturación permanece sin cambios.</li>\\n</ul>\\n<p>Si desea eliminar los asientos de su cuenta después de desactivar a los usuarios en el pasado, vaya a su sección de facturación y haga clic en &quot;<strong>Administrar asientos</strong>&quot;.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202023-03-14%20at%2011.48.56.png\\" alt=\\"1\\"> --&gt;</p>\\n<p>Luego, elija el número deseado de asientos. Los cambios para la rebaja del asiento entrarán en vigencia al comienzo de su próximo ciclo de facturación. Si llena los asientos con nuevos usuarios antes de esta fecha, los asientos no se eliminarán de su facturación.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202023-03-14%20at%2011.50.36.png\\" alt=\\"1\\"> --&gt;</p>\\n","section":"¿Qué sucede con mi facturación cuando desactivo a un usuario en Fintesk?","version":"current","path":"/es/billing/billing-information/what-happens-to-my-billing-when-i-deactivate-a-user-in-fintesk","category":"default"},{"title":"¿Cómo puedo cambiar a un plan Fintesk diferente o cambiar mi frecuencia de facturación??","content":"<p>&lt;!-- billing/your-fintesk-subscription-plan/how-can-i-switch-to-a-different-fintesk-plan-or-change-my-billing-frequency.md --&gt;</p>\\n<p>&lt;!-- # How can I switch to a different Fintesk plan or change my billing frequency? --&gt;</p>\\n<p>:::tip\\n<strong>Nota:</strong> Esta acción solo está disponible para usuarios con acceso <strong>Configuración de la cuenta</strong>.\\n:::</p>\\n<p>&lt;!-- If you would like to switch to a different Fintesk plan or change your billing frequency, you can easily do so at any time in your billing cycle by going to your <a href=\\"https://app.pipedrive.com/settings/subscription\\">Billing tab</a> and clicking on “<strong>Manage subscription</strong>”. --&gt;</p>\\n<p>Si desea cambiar a un plan Fintesk diferente o cambiar su frecuencia de facturación, puede hacerlo fácilmente en cualquier momento de su ciclo de facturación yendo a su pestaña de <strong>facturación</strong> y haciendo clic en &quot;<strong>Administrar suscripción</strong>&quot;.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202023-05-05%20at%2013.48.37.png\\" alt=\\"1\\"> --&gt;</p>\\n<p>Desde aquí, verá la opción de alternar entre los planes o cambiar entre <strong>mensualmente</strong> o ciclos de facturación <strong>anuales</strong>.</p>\\n<p>Haga clic en &quot;<strong>Continuar</strong>&quot; (si está en prueba gratuita) o &quot;<strong>proceda a pagar</strong>&quot; (si ya está pagando) para confirmar su cambio.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/billing%20select%20plans.png\\" alt=\\"1\\"> --&gt;</p>\\n<p>Su facturación puede actualizarse para reflejar los cambios que realizó.</p>\\n<p>Puede leer sobre lo que le sucede a su facturación cuando cambia a un plan de Fintesk diferente <a href=\\"../../billing/billing-information/what-happens-to-my-billing-when-i-change-my-fintesk-subscription-plan\\">en este artículo</a> Y qué sucede con su facturación cuando cambia las frecuencias de facturación <a href=\\"../../billing/billing-information/what-happens-to-my-billing-when-i-change-my-billing-frequency\\">en este artículo</a>.</p>\\n","section":"¿Cómo puedo cambiar a un plan Fintesk diferente o cambiar mi frecuencia de facturación??","version":"current","path":"/es/billing/your-fintesk-subscription-plan/how-can-i-switch-to-a-different-fintesk-plan-or-change-my-billing-frequency","category":"default"},{"title":"Características disponibles en cada plan","content":":::tip\\nNota: El número de negocios abiertos, campos personalizados e informes que puede tener depende del plan en el que se encuentre. Obtenga más información en este artículo.\\n:::\\n<table>\\n<tr>\\n<td>Feature</td>\\n<td>Free</td>\\n<td>Essential</td>\\n<td>Advanced</td>\\n<td>Professional</td>\\n</tr>\\n<tr>\\n<td>Vista de embudos</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Múltiples embudos</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Embudos personalizables, Campos personalizables y actividades</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Vistas de detalle</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Negocios estancados</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Actividades y registro de actividad</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<!-- <tr>\\n<td>Campos personalizados específicos de embudos</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n</tr> -->\\n<tr>\\n<td>\\n:::info [Cooming soon]\\nFusionar duplicados\\n:::\\n</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Productos</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Soporte por correo electrónico</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Soporte de chat</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Soporte telefónico</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>Incorporación</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td></td>\\n</tr>\\n<!-- <tr>\\n<td>Email templates</td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Email open and click tracking</td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Important fields</td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Group emailing</td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Scheduled emails</td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Recurring products</td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Required fields</td>\\n<td></td>\\n<td></td>\\n<td> </td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Contacts timeline</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Revenue Forecast report</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Deal Forecasting</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>Teams</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>3 teams</td>\\nSigue incrementando los teams en planes superiores 3,15, ilimitado\\n</tr> -->\\n<!-- <tr>\\n<td>Custom permission sets</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>2 sets</td>\\nSigue incrementando los sets en planes superiores 2, 10, ilimitado\\n</tr> -->\\n<!-- <tr>\\n<td>Custom visibility groups</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>3 groups</td>\\nSigue incrementando los sets en planes superiores 3, 15, ilimitado\\n</tr> -->\\n<!-- <tr>\\n<td>Calendar View for activities</td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>Marketplace with 350+ apps and integrations</td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>Contact, Calendar and Google Drive sync</td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>Top-rated iOS and Android apps</td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>Sales Assistant</td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>\\nActivity invite\\n:::info\\nNote: Active calendar sync is required to send activity invites.\\n:::\\n</td>\\n<td>Branded</td>\\n<td>Branded</td>\\n<td>Unbranded</td>\\n<td>Unbranded</td>\\n</tr> -->\\n<!-- <tr>\\n<td>Insights reporting</td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>Insights dashboard</td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>SSO/SAML</td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>Smart Bcc</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>Security dashboard</td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>AI SmartApp recommendations</td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>AI-powered Marketplace search</td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>Email sync with all major providers</td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr> -->\\n<!-- <tr>\\n<td>Scheduler</td>\\n<td></td>\\n<td></td>\\n<td>✔️ One general availability link</td>\\n<td>✔️ Unlimited general availability links</td>\\n</tr> -->\\n<!-- <tr>\\n<td>Smart Contact Data</td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Automations</td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Smart Docs</td>\\n<td></td>\\n<td>Paid add-on</td>\\n<td>Paid add-on</td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Custom fields in Insights</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>eSignatures</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Multiple Insights dashboards</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>AI email creation</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>AI email summarization</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>AI Sales Assistant</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n</tr>\\n<tr>\\n<td>Projects</td>\\n<td></td>\\n<td>Paid add-on</td>\\n<td>Paid add-on</td>\\n<td>Paid add-on</td>\\n</tr>\\n<tr>\\n<td>Security rules</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>Security alerts</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td></td>\\n</tr> -->\\n</table>\\n\\n","section":"¿Qué características tienen los planes Fintesk?","version":"current","path":"/es/billing/your-fintesk-subscription-plan/what-features-do-the-fintesk-plans-have#características-disponibles-en-cada-plan","category":"default"},{"title":"Características adicionales","content":"Fintesk ofrecerá una serie de funciones adicionales que están disponibles en cualquier plan para un costo adicional.\\n<!-- You can click on any of the feature names below to read more information about them. -->\\n<!-- LeadBooster add-on: -->\\n<!-- - Chatbot – allows your customers to better qualify themselves as potential customers of your company directly from your website. -->\\n<!-- - Live Chat – live chat functionality added to your Chatbot playbook flow that will allow you to engage directly with your website visitors and personalize your lead qualification process. -->\\n<!-- - Web Forms – Create your own personalized, embeddable forms for your website to collect your website visitors’ information and funnel them into Fintesk as deals or leads. -->\\n<!-- - Prospector – An outbound lead generation tool that will allow you to search for and gather high-quality leads based on set criteria. -->\\n<!-- - Scheduler – Unlimited “General availability” links -->\\n<!-- Separate add-ons: -->\\n<!-- - Web Visitors – Allows you to track visitor activity on your website to track and identify the companies who are most engaged with your website and most likely to turn into customers. -->\\n<!-- - Smart Docs – Comes with any Professional or higher subscription. However, it can also be used as an add-on for Essential or Advanced plans. -->\\n<!-- - Projects – Comes with any Power or higher subscription. Lets you manage post-sales activities for your deals, so you can continue to interact with and set objectives for closed, as well as open deals.\\nCampaigns – Lets you create beautiful email marketing templates, engage your customers and manage all of your data directly in your Fintesk account. -->\\n","section":"¿Qué características tienen los planes Fintesk?","version":"current","path":"/es/billing/your-fintesk-subscription-plan/what-features-do-the-fintesk-plans-have#características-adicionales","category":"default"},{"title":"Changes to the API","content":"Fintesk’s API together with our Developer Platform is constantly evolving to cover additional product functionality. By introducing changes to the API, we aim to enhance your API experience by adding new features and functionality.\\nDo take note that from time to time, we may introduce breaking changes in order to improve the API. Read on to find out how we communicate changes and what types of changes we introduce.\\n:::info\\nAll changes to the Fintesk API are announced via our Changelog. Make sure to subscribe to stay up to date!\\n:::\\n:::warning\\nOccasionally, we announce new API endpoints in the Beta version with the goal of gathering customer feedback. Please note that Beta endpoints may be subject to breaking changes.\\n:::\\n\\n","section":"Changes to the API","version":"current","path":"/es/developers/core-api-concepts/changes-to-the-api","category":"default"},{"title":"Types of changes","content":"\\n\\nChanges to the Fintesk API can be divided into breaking and non-breaking changes.\\nA breaking change is a backward incompatible change that may require updating your app.\\nA non-breaking change is typically a new addition to the API that can be implemented at your own pace and choosing.\\n:::warning\\nWe aim to announce breaking changes via our Changelog at least 60 days in advance to give you adequate time to adopt the changes.\\n:::\\nBreaking changes\\nNon-breaking changes\\n\\n\\n\\n\\nRemoving a resource\\nAdding a new endpoint\\n\\n\\nRemoving an endpoint\\nAdding a new optional parameter\\n\\n\\nRemoving a parameter\\nAdding a new response field\\n\\n\\nRemoving a response field\\nChanging the order of response fields\\n\\n\\nModifying an endpoint’s URI\\nChanging an error message\\n\\n\\nModifying the name of a parameter or field\\nFixing an HTTP response code\\n\\n\\nModifying required parameters\\n\\n\\n\\nAdding a required parameter\\n\\n\\n\\nChanging the data type of an existing field or parameter\\n\\n\\n\\nReducing API limits\\n\\n\\n\\nRestricting OAuth scopes\\n\\n\\n\\nIntroducing a new validation\\n","section":"Changes to the API","version":"current","path":"/es/developers/core-api-concepts/changes-to-the-api#types-of-changes","category":"default"},{"title":"About the Fintesk API","content":":::tip\\nAn application programming interface (API) is a set of functionalities that a service owner provides so team\'s member can use its features and/or build software applications. An API details how a user makes requests and the responses they receive in return.\\n:::\\n<!-- Fintesk is a sales CRM with an intuitive RESTful API and webhooks, to help you build [an app]. -->\\nFintesk is a sales CRM with an intuitive RESTful API, to help you build [an app].\\n\\n","section":"About the Fintesk API","version":"current","path":"/es/developers/core-api-concepts/core-api-concepts-about-fintesk-api","category":"default"},{"title":"Fintesk RESTful API","content":"\\n\\nOur Fintesk RESTful API Reference can be accessed via our API, where you will find a list of endpoints and their descriptions.\\n<!-- Calls to our API are validated against an API token or an access_token when using OAuth 2.0.  -->\\nOur API supports UTF-8 for character encoding.\\n<!-- Learn how to find and use the api_token with the practical task here. -->\\n\\nFintesk Entity Relationship Diagram (ERD)\\n<!-- ### Webhooks\\n\\nWebhooks enable you to obtain real-time, programmatic notifications from Fintesk regarding changes to your data as they happen. Instead of pulling information via our API, webhooks will push information to your endpoint.\\nYou can create webhooks via the web app and our API. You can create a webhook programmatically by making a POST request to the webhook’s endpoint. Fintesk will then send a notification when an event is triggered (e.g., a new lead is added) as an HTTP post with a JSON body to the endpoint(s) you have specified. Find out more about webhooks here. -->\\n\\n","section":"About the Fintesk API","version":"current","path":"/es/developers/core-api-concepts/core-api-concepts-about-fintesk-api#fintesk-restful-api","category":"default"},{"title":"How Fintesk API works","content":"\\n\\n:::tip\\nDo take note that entity/entities may be called “item/items” or “type of item/items” for the end user in the Fintesk web.\\n<!-- and mobile app. -->\\n:::\\n<!-- At the base of your Fintesk account is a customer relationship management (CRM) database of your sales pipeline, processes and relationships. As organizing sales data is essential for sales activities, Fintesk helps to organize and link your data together for better visibility through the core and adjacent entities. -->\\nAt the base of your Fintesk account is a customer relationship management (CRM) database of your sales pipeline, processes and relationships. As organizing sales data is essential for sales activities, Fintesk helps to organize and link your data together for better visibility through the core and adjacent entities.\\n","section":"About the Fintesk API","version":"current","path":"/es/developers/core-api-concepts/core-api-concepts-about-fintesk-api#how-fintesk-api-works","category":"default"},{"title":"Core entities","content":"\\nWithin the Fintesk API, we have core entities that consist of multiple endpoints. These core entities represent a larger area inside Fintesk and can be found in navbar menu in the Fintesk web app. Tied to them are adjacent entities that contain supplementary information relevant to the core entities.\\n\\nFintesk core entities ERD\\nThe ERD above shows how core entities are connected within Fintesk.\\n<!-- - As leads can be converted to deals, they are sometimes used in place of each other. For example, in the case of activities, an activity can be associated with either a lead or a deal. This goes the same for products. -->\\nFor example, in the case of activities, an activity can be associated with a deal. This goes the same for products.\\nPersons and organizations are considered contacts and are often grouped together.\\n<!-- Mailbox, found in the Mail tab of the Fintesk web app, is the email control hub inside Fintesk that stores all the emails a user decides to keep a record of. Mail is tracked and associated with persons and deals through Fintesk’s email sync and Smart Bcc features. -->\\n[Entity] Fields endpoints allow you to obtain the near-complete schema of the respective core entities. You can add, update and delete main and custom fields through these adjacent entities.\\n<!-- Read on to discover how leads, deals, persons and organizations (contacts), activities, products and users are further connected to other core and adjacent entities. -->\\nRead on to discover how deals, persons and organizations (contacts), activities, products and users are further connected to other core and adjacent entities.\\n","section":"About the Fintesk API","version":"current","path":"/es/developers/core-api-concepts/core-api-concepts-about-fintesk-api#core-entities","category":"default"},{"title":"Deals","content":"\\n\\nDeals ERD\\n<!-- https://developers.pipedrive.com/developers/create-a-deal-pipedrive-api -->\\n<!-- TODO: agregar los API guias para cada entdidad -->\\n[Deals] are ongoing transactions pursued with a person or an organization. It’s tracked and processed through the Stages of a pipeline until it’s won or lost. Deals can be converted from leads via the Fintesk web app.\\n<!-- In Fintesk, deals contain all actions taken towards closing a sale, for example, activities, and notes and files, and have their own custom fields (DealFields). Products and subscriptions can also be attached to deals. -->\\nIn Fintesk, deals contain all actions taken towards closing a sale, for example, activities, and notes, and have their own custom fields (DealFields). Products can also be attached to deals.\\nA deal can be linked with either a person or organization (contacts) but it must always have one contact linked with them. As a deal is associated with a contact, it will pull all information from the linked contact and, likewise, associate all actions performed on the deal with the linked contact.\\n","section":"About the Fintesk API","version":"current","path":"/es/developers/core-api-concepts/core-api-concepts-about-fintesk-api#deals","category":"default"},{"title":"Persons & organizations (contacts)","content":"\\n\\nPersons & organizations (contacts) ERD\\n<!-- TODO: agregar los API guias para cada entdidad -->\\nPersons are the specific customers of the sales process, while [organizations] are the companies that the persons work at. Persons and organizations are considered contacts and they rest in one centralized hub in the Fintesk web app. The ERD above depicts how different core and adjacent entities can either relate to contacts as a whole or persons/organizations specifically.\\nBoth persons and organizations can have activities, notes and files attached to them and their respective main fields and custom fields (PersonFields and OrganizationFields).\\n<!-- Emails (Mailbox) and products can only be linked to persons while  -->\\nOrganizationRelationships can only be linked to organizations.\\nKey aspects of Persons and organizations (contacts):\\nA person can only be linked to one organization\\n<!-- - A lead or a deal must always have a person or an organization linked to it -->\\nA deal must always have a person or an organization linked to it\\nBoth persons and organizations can have multiple deals open for them at the same time\\n","section":"About the Fintesk API","version":"current","path":"/es/developers/core-api-concepts/core-api-concepts-about-fintesk-api#persons--organizations-contacts","category":"default"},{"title":"Activities","content":"\\n\\nActivities ERD\\n<!-- TODO: agregar los API guias para cada entdidad -->\\n[Activities] are any actions a user does towards the closing of a sale. There are different types of activities (ActivityTypes) that can be performed, e.g. a phone call, a meeting or a task. You can have custom activity types and custom fields (ActivityFields) for activities. Users can schedule activities in relation to a person, an organization or a deal.\\nKey aspects of activities:\\nAssociating an activity with a deal will also associate the activity with the person and/or organization linked to the deal\\n<!-- - Currently, Files can only be added to activities via the API -->\\n","section":"About the Fintesk API","version":"current","path":"/es/developers/core-api-concepts/core-api-concepts-about-fintesk-api#activities","category":"default"},{"title":"Products","content":"\\n\\nProducts ERD\\n<!-- TODO: agregar los API guias para cada entdidad -->\\n[Products] are goods and/or services that your company deals with. Products can have their own custom fields (ProductFields) and be attached to deals. Persons (contacts) can be added as participants and users can be added as followers for a product.\\n<!-- Files can also be added to products. -->\\n","section":"About the Fintesk API","version":"current","path":"/es/developers/core-api-concepts/core-api-concepts-about-fintesk-api#products","category":"default"},{"title":"Users","content":"\\n\\nUsers ERD\\nA Company within fintesk comprises Users who may be grouped into teams. The ERD above depicts how different core and adjacent entities can relate to a company as a whole or users/teams specifically.\\n<!-- Goals may be related to a company, a team and/or a user.  -->\\nUsers and teams can have their own specific PermissionSets and Roles, which are a part of the visibility groups’ feature. Users can also have their own UserSettings.\\n<!-- and UserConnections. -->\\n<!-- 2 main types of webhooks can be created: webhooks related to a company and webhooks for apps. When querying webhooks, a user can obtain the webhooks they’ve created, while apps can only see and delete webhooks that have the type set as type= \'application\'. -->\\n","section":"About the Fintesk API","version":"current","path":"/es/developers/core-api-concepts/core-api-concepts-about-fintesk-api#users","category":"default"},{"title":"Custom fields","content":"Custom fields allow you to add additional data to your Fintesk account that isn\'t included by default. Each deal, organization, person, and product item can contain custom fields. We have 16 different field types available, each with its own uses.\\n\\n","section":"Custom fields","version":"current","path":"/es/developers/core-api-concepts/core-api-concepts-custom-fields","category":"default"},{"title":"Creating a custom field","content":"\\n\\n<!-- TODO: crear esta pagina -->\\n<!-- See our creating a new custom field tutorial to add a custom field programmatically. -->\\nMethod\\nURL\\nUseful for\\n\\n\\n\\n\\nPOST\\n/dealFields\\nAdding a new deal field.\\n\\n\\nPOST\\n/organizationFields\\nAdding a new organization field\\n\\n\\nPOST\\n/personFields\\nAdding a new person field\\n\\n\\nPOST\\n/productFields\\nAdding a new product field\\n:::tip\\nNote that custom fields cannot be duplicated to multiple different Fintesk accounts. You can add the custom fields with the same name and field type to different accounts but they\'ll have different values for key parameters referenced in our API.\\n:::\\n\\n","section":"Custom fields","version":"current","path":"/es/developers/core-api-concepts/core-api-concepts-custom-fields#creating-a-custom-field","category":"default"},{"title":"Naming a custom field","content":"\\n\\nAll custom fields are referenced as randomly generated 24-character hashes in the dataset, for example, 671a4610084c309cd93e5939 - it may look like our office cat walked across the laptop, but this actually is a key for a custom field in our API dataset.\\n:::warning\\nThese 24-character custom fields (for example, 671a4610084c309cd93e5939) are not shown in our API Reference as they differ for each Fintesk account, but they can be seen in the API requests and responses as well as used in the requests when adding new items or updating existing ones.\\n:::\\nYou can’t rename the reference of the custom field (the field API key), but you can rename the name of a custom field that’s visible to the User.\\nInside Fintesk, you can find the API key of a field by going to Settings > Data fields and choosing the entity (deal/person/organization/product). When you hover over the row of a custom field, a three-dot menu appears on the right-hand side. From there, choose Copy API key.\\n<!-- TODO: hacer el documento cuando tengak API keys -->\\n<!--\\nFinding the API key of a custom field -->\\n","section":"Custom fields","version":"current","path":"/es/developers/core-api-concepts/core-api-concepts-custom-fields#naming-a-custom-field","category":"default"},{"title":"{#}","content":"<!--\\n","section":"Custom fields","version":"current","path":"/es/developers/core-api-concepts/core-api-concepts-custom-fields#undefined","category":"default"},{"title":"Referencing a custom field","content":"\\n\\nHere’s how you use an example key for a custom field in an example POST request to /deals (make sure you replace the example key with yours before making the request):\\n<?php $api_token = \'Your API token goes here\';\\n\\n$deal = array (\\n    \'title\' => \'New deal with a custom field\',\\n    \'value\' => \'500\',\\n    \'currency\' => \'USD\',\\n    \'671a4610084c309cd93e5939\' => \'A new field value for an existing example custom field key\'\\n);\\n\\n$url = \'https://companydomain.pipedrive.com/api/v1/deals?api_token=\' . $api_token;\\n$ch = curl_init();\\ncurl_setopt($ch, CURLOPT_URL, $url);\\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\\ncurl_setopt($ch, CURLOPT_POST, true);\\ncurl_setopt($ch, CURLOPT_POSTFIELDS, $deal);\\n$output = curl_exec($ch);\\ncurl_close($ch);\\n\\n$result = json_decode($output, true);\\n// Check if an ID came back, if did print it out\\nif (!empty($result[\'data\'][\'id\']))\\n{ echo \'Deal was added successfully!\' . PHP_EOL; }\\nEach custom field type corresponds to a specific data format. To determine in which format you need to submit data into a custom field, make a GET request for the same kind of object and check the format of the value of that field. You can find the list of field_type in the table below.\\n-->\\n\\n","section":"Custom fields","version":"current","path":"/es/developers/core-api-concepts/core-api-concepts-custom-fields#referencing-a-custom-field","category":"default"},{"title":"Updating a custom field","content":"\\n\\n<!-- TODO: hacer el documento -->\\n<!-- See our updating custom fields’ values tutorial to update a custom field programmatically. -->\\nMethod\\nURL\\nUseful for\\n\\n\\n\\n\\nPUT\\n/dealFields/{id}\\nUpdating a Deal field.\\n\\n\\nPUT\\n/organizationFields/{id}\\nUpdating an organization field\\n\\n\\nPUT\\n/personFields/{id}\\nUpdating a person field\\n\\n\\nPUT\\n/productFields/{id}\\nUpdating a product field\\n\\n","section":"Custom fields","version":"current","path":"/es/developers/core-api-concepts/core-api-concepts-custom-fields#updating-a-custom-field","category":"default"},{"title":"Deleting a custom field","content":"\\n\\n:::warning\\nWe don\'t recommend deleting a custom field, because it might permanently remove all data. In case you do delete by mistake, there\'s a chance that you can get it back by contacting our awesome support team.\\n:::\\n<!-- TODO: hacer el documento -->\\n<!-- See our deleting a custom field tutorial to delete a custom field programmatically. -->\\nMethod\\nURL\\nUseful for\\n\\n\\n\\n\\nDELETE\\n/dealFields/{id}\\nMarking a deal field as deleted.\\n\\n\\nDELETE\\n/organizationFields/{id}\\nMarking an organization field as deleted\\n\\n\\nDELETE\\n/personFields/{id}\\nMarking a person field as deleted\\n\\n\\nDELETE\\n/productFields/{id}\\nMarking a product field as deleted\\nAfter a custom field is deleted, it will no longer appear in API responses. All POST requests mentioning a custom field will ignore it.\\n\\n","section":"Custom fields","version":"current","path":"/es/developers/core-api-concepts/core-api-concepts-custom-fields#deleting-a-custom-field","category":"default"},{"title":"Types of custom fields","content":"\\n\\nSee below the 16 different types of custom fields available:\\nType\\nfield_type\\nDescription\\nUseful for\\nAdditional info\\n\\n\\n\\n\\nText\\nVarcharField\\nThe text field is used to store texts up to 255 characters\\nBilling addresses, (short) comments, email addresses\\n\\n\\n\\nLarge text\\nTextField\\nThe large text field is used to store texts longer than usual\\nComments, descriptions\\n\\n\\n\\nNumerical\\nNumberField\\nThe numeric field is used to store data such as the amount of commission or other custom numerical data\\nCommission, priority level\\nThe value should be numeric with a maximum precision (decimal places) of 16. If a number exceeds the maximum precision, it will stay without the full precision.\\n\\n\\nMonetary\\nMonetaryField\\nThe monetary field is used to store data such as the amount of commission\\nCommission, amounts\\nThe currency of the field will match the user’s default currency setting unless specified otherwise in the request. The format of the field is determined by the user’s locale.\\n\\n\\nMultiple options\\nMultipleChoiceField\\nThe multiple options field lets you predefine a list of values to choose from. Multiple option fields can have a max of 10,000 options per field.\\nIndustry type, competitors, region\\n\\n\\n\\nSingle option\\nChoiceField\\nThe single option field lets you predefine a list of values out of which one can be selected.Single option fields can have a max of 10,000 options per field.\\nLead type, category, industry\\n\\n\\n\\nUser\\nUserField\\nThe user field can contain one user amongst users of your Fintesk account*\\nTech contacts, previous deal owners\\n\\n\\n\\nOrganization\\nOrganizationField\\nThe organization field can contain one organization out of all the organizations stored on your Fintesk account*\\nRelated parties, partner organizations\\n\\n\\n\\nPerson\\nPersonField\\nThe person field can contain one person out of all the contacts stored on your Fintesk account*\\nRelated parties, tech contacts\\n\\n\\n\\nPhone\\nPhonesField\\nA phone number field can contain a phone number (naturally) or a Skype Name with a click-to-call functionality\\nSkype names, phone numbers\\nNo auto-formatting\\n\\n\\nTime\\nTimeField\\nThe time field is used to store times, picked from a handy inline time picker\\nDelivery times, lunchtime\\n\\n\\n\\nTime range\\nTimeRangeField\\nThe time range field is used to store time ranges picked from a handy inline time picker\\nOffice hours, the best time to contact\\n\\n\\n\\nDate\\nDateField\\nDate field is used to store dates picked from a handy inline calendar\\nDelivery dates, deadlines\\nThe format of the field is determined by the user’s locale\\n\\n\\nDate range\\nDateRangeField\\nThe date range field is used to store date ranges picked from a handy inline calendar\\nEvent dates, completion estimates\\n:::info\\nComing soon\\nAddress\\nAddressField\\nAddress field is used to store addresses\\nEvent places, office locations (when separate from business address)\\nThe address field can hold all parts of address components – including City, tate, Zip Code, and Country – so there’s no need to create separate address fields for each address component. You can use Google Maps autocomplete textfield to enter addresses and visualize them on a map. You’ll also be able to filter items based on specific address criteria.\\n\\n\\nAutocomplete\\nVarcharField\\nThe text field is used to store texts up to 255 characters and can autocomplete from the text previously inserted into this field\\n\\nCustom options (e.g., tagging), email addresses\\n\\n\\n:::\\n* Doesn’t link the item with the user, person, or organization for statistics or any other form of ownership or relation, but can be used for filtering.\\n\\n","section":"Custom fields","version":"current","path":"/es/developers/core-api-concepts/core-api-concepts-custom-fields#types-of-custom-fields","category":"default"},{"title":"How to find out if a field is a custom field","content":"\\n\\nThe system_flag parameter in the response body of an entity’s fields can be used to identify if the field is a custom field:\\ntrue – a custom field\\nfalse – Fintesk default field\\n{\\n  \\"_id\\": \\"671a460f084c309cd93e58c4\\",\\n\\n  \\"active_flag\\": true,\\n  \\"add_deal_modal_visible_flag\\": false,\\n  \\"add_organization_modal_visible_flag\\": false,\\n  \\"add_person_modal_visible_flag\\": false,\\n  \\"add_product_modal_visible_flag\\": false,\\n  \\"add_time\\": \\"2024-10-24 13:05:19\\",\\n  \\"add_visible_flag\\": false,\\n  \\"alias\\": \\"next_activity_subject\\",\\n  \\"allow_bulk_edit_flag\\": false,\\n  \\"allow_filtering_flag\\": false,\\n  \\"allow_select_column_flag\\": false,\\n  \\"complex_flag\\": false,\\n  \\"created_by_user_id\\": \\"671a460f084c309cd93e5848\\",\\n  \\"delete_flag\\": false,\\n  \\"details_visible_flag\\": false,\\n  \\"edit_flag\\": false,\\n  \\"entity_id\\": \\"671a460f084c309cd93e584b\\",\\n  \\"entity_key\\": \\"Deals\\",\\n  \\"entity_referenced\\": null,\\n  \\"field_type_class\\": \\"TextField\\",\\n  \\"field_type_id\\": \\"671a460f084c309cd93e5855\\",\\n  \\"flow_flag\\": false,\\n  \\"help_text\\": \\"This field can have 255 characters at maximun\\",\\n  \\"importable_flag\\": false,\\n  \\"important_flag\\": false,\\n  \\"internal_id\\": 91,\\n  \\"key\\": \\"next_activity_subject\\",\\n  \\"last_updated_by_user_id\\": \\"671a460f084c309cd93e5848\\",\\n  \\"link\\": null,\\n  \\"mandatory_flag\\": false,\\n  \\"name\\": \\"next_activity_subject\\",\\n  \\"options\\": [],\\n  \\"order_nbr\\": 4,\\n  \\"owner_id\\": \\"671a460f084c309cd93e5848\\",\\n  \\"search_field\\": null,\\n  \\"searchable_flag\\": false,\\n  \\"sort_field\\": \\"next_activity_subject\\",\\n  \\"sortable_flag\\": true,\\n  \\"subfield_flag\\": false,\\n  \\"subfields\\": [],\\n  \\"system_flag\\": true,\\n  \\"update_time\\": \\"2024-10-24 13:05:18\\",\\n  \\"visible_in_exports_flag\\": false\\n}\\n","section":"Custom fields","version":"current","path":"/es/developers/core-api-concepts/core-api-concepts-custom-fields#how-to-find-out-if-a-field-is-a-custom-field","category":"default"},{"title":"Date format","content":"All dates and times received by the API will be in ISO 8601 format 2019-01-22 08:55:59 (would be the same as 2019-01-22T08:55:59).\\n:::warning\\nAll times received by the API will be in UTC timezone.\\n:::\\nThe times that are sent to the API should also be converted to the UTC timezone before being sent.\\n","section":"Date format","version":"current","path":"/es/developers/core-api-concepts/core-api-concepts-date-format","category":"default"},{"title":"HTTP status codes","content":"Here\'s a list of the status codes used in Fintesk:\\nStatus Code\\nName\\nDescription\\n\\n\\n\\n\\n200\\nOK\\nRequest fulfilled\\n\\n\\n201\\nCreated\\nNew resource created\\n\\n\\n400\\nBad Request\\nRequest not understood\\n\\n\\n401\\nUnauthorized\\nInvalid API token\\n\\n\\n402\\nPayment Required\\nCompany account is not open (possible reason: trial expired, payment details not entered)\\n\\n\\n403\\nForbidden\\nRequest not allowed. User account has reached a limit for an entity.\\n\\n\\n404\\nNot Found\\nResource unavailable\\n\\n\\n405\\nMethod not allowed\\nIncorrect request method\\n\\n\\n410\\nGone\\nOld resource permanently unavailable\\n\\n\\n415\\nUnsupported Media Type\\nFeature is not enabled\\n\\n\\n422\\nUnprocessable Entity\\nWebhooks limit reached\\n\\n\\n429\\nToo Many Requests\\n[Rate limit] has been exceeded\\n\\n\\n500\\nInternal Server Error\\nGeneric server error\\n\\n\\n501\\nNot Implemented\\nNon-existent functionality\\n\\n\\n503\\nService Unavailable\\nScheduled maintenance\\n","section":"HTTP status codes","version":"current","path":"/es/developers/core-api-concepts/core-api-concepts-http-status-codes","category":"default"},{"title":"Pagination","content":"Fintesk offers pagination for most of our API’s list and item collection endpoints.\\n","section":"Pagination","version":"current","path":"/es/developers/core-api-concepts/core-api-concepts-pagination","category":"default"},{"title":"Offset pagination","content":"\\n\\nWith the rest of our GET endpoints, we offer offset-based pagination. The parameters that control this type of pagination are start_page and limit_by, indicating the desired offset and the number of items to be returned per page.\\n<!-- -->\\n<!-- -->\\n\\n\\n\\n\\nstart_page (integer)\\nPagination start. If omitted, the default value is 0.\\n\\n\\nlimit_by (integer)\\nThe number of items shown per page. If not provided, 50 items will be returned.\\nExample request for the GET /v1/activities endpoint:\\nGET https://api.fintesk.com/v1/activities?start=0&limit=100\\nWithin the response’s additional_data object, a pagination object will be returned. The additional_data.pagination object will contain the given start_page and limit_by values, as well as the more_items_in_collection flag, indicating whether more items can be fetched after the current batch.\\nIf more items can be fetched, the next_start field, which can be used for specifying the next offset pointer, will also be returned.\\nThe maximum limit_by value is 500.\\nExample response:\\n{\\n  \\"success\\": true,\\n  \\"data\\": [{\\n    … // returned activities’ data\\n  }],\\n  \\"additional_data\\": {\\n    \\"pagination\\": {\\n      \\"start\\": 0,\\n      \\"limit\\": 10,\\n      \\"more_items_in_collection\\": true,\\n      \\"next_start\\": 10\\n    }\\n  }\\n}\\n","section":"Pagination","version":"current","path":"/es/developers/core-api-concepts/core-api-concepts-pagination#offset-pagination","category":"default"},{"title":"Requests","content":":::tip\\nAll requests to the Fintesk API must be made over SSL (https, not http).\\n:::\\nWe recommend using JSON body format when performing API requests. To do a proper JSON-formatted request, ensure you provide Content-Type: application/json in HTTP request headers. Our API supports UTF-8 for character encoding.\\nFor the POST method, regular form-encoded body format is also supported but you may experience quirks related to a lack of data types. Our API uses the HTTP verbs for each action:\\nMethod\\nDescription\\n\\n\\n\\n\\nGET\\nUsed for retrieving resources\\n\\n\\nPOST\\nUsed for creating resources\\n\\n\\nPUT\\nUsed for replacing resources or collections\\n\\n\\nPATCH\\nUsed for updating some parts of a resource\\n\\n\\nDELETE\\nUsed for deleting resources\\n\\n","section":"Requests","version":"current","path":"/es/developers/core-api-concepts/core-api-concepts-requests","category":"default"},{"title":"URL naming","content":"\\n\\nOur API uses a straightforward URL naming convention.\\nEach request must be made to the API endpoint https://api.fintesk.com/lc_erp/v1, followed by the type of object in a plural form, for example, https://api.fintesk.com/lc_erp/v1/deals\\nWhen one item is being asked, and such a method exists, the ID of the item must be appended to the URL, for example https://api.fintesk.com/lc_erp/v1/deals/abc\\nWhen asking for sub-objects of an object, append that to the ID of the master object, for example, https://api.fintesk.com/lc_erp/v1/deals/2/activities\\n<!-- - The API token must be provided as part of the query string for all requests using the api_token variable, for example https://api.fintesk.com/lc_erp/v1/deals/2?api_token=659c9fddb16335e48cc67114694b52074e812e03 -->\\n<!-- We advise everyone to use {COMPANYDOMAIN}.pipedrive.com for faster requests as it helps us to better determine which data center your request should go to. -->\\n\\n","section":"Requests","version":"current","path":"/es/developers/core-api-concepts/core-api-concepts-requests#url-naming","category":"default"},{"title":"Field selector","content":"\\n\\nWhen asking for a collection/list of objects, you can pass in a field selector to indicate which fields you would like to fetch per each object. Most endpoints in our API reference support this, but not all.\\n<!-- The field selector is supported in requests done with OAuth and requests done with the api_token.  -->\\nFor example, you may only want to fetch a deal\'s ID, title, value, and currency when asking the deals list – this can be done by using the following syntax:\\nRequest with OAuth 2.0:\\nGET https://api.fintesk.com/lc_erp/v1/deals:(id,title,value,currency)\\n<!--\\nRequest with api_token:\\nGET https://api.fintesk.com/lc_erp/v1/deals:(id,title,value,currency)?api_token=659c9fddb16335e48cc67114694b52074e812e03\\n``` -->\\n<!-- https://developers.pipedrive.com/tutorials/update-custom-field-pipedrive-api?step=1 -->\\n<!-- You can also see the field selector being used in our [updating custom fields\' values](/docs/updating-custom-field-value#pass-field-selectors) tutorial. -->\\n","section":"Requests","version":"current","path":"/es/developers/core-api-concepts/core-api-concepts-requests#field-selector","category":"default"},{"title":"Getting started","content":":::tip\\nCheck out our Changelog for the latest changes regarding our Developer Platform.\\n:::\\nFintesk is a sales CRM with an intuitive RESTful API. You can use our API to create public or private apps\\n<!-- using OAuth 2.0 and integrations via API token. -->\\n\\n","section":"Getting started","version":"current","path":"/es/developers/overview/getting-started","category":"default"},{"title":"Create an account","content":"\\n\\nTesting in a risk-free account. sign up for one now.\\n\\n<!-- ## Learn about the Fintesk API\\n-->\\n\\n<!--\\nLet\'s walk through the basics of the Fintesk API. Try it out here or use Fintesk\'s API in Postman or Insomnia and continue learning with our API tutorials and app tutorials. -->\\n:::tip\\nDidn\'t find what you were looking for? Let us know!\\nTell us about what you\'re looking for or inform us about the missing article\\n<!-- via the little smiling feedback button in the bottom right-hand corner. -->\\n:::\\n","section":"Getting started","version":"current","path":"/es/developers/overview/getting-started#create-an-account","category":"default"},{"title":"Fintesk API - V2","content":"<p>import ApiDocMdx from \'@theme/ApiDocMdx\';</p>\\n<p>&lt;ApiDocMdx id=&quot;fintesk-v1&quot; /&gt;</p>\\n","section":"Fintesk API - V2","version":"current","path":"/es/fintesk/api-v1","category":"default"},{"title":"Changelog","content":"<p>&lt;!-- fintesk/changelog.md --&gt;</p>\\n","section":"Changelog","version":"current","path":"/es/fintesk/changelog","category":"default"},{"title":"Donde encontrarlo","content":"Puede encontrar sus actividades haciendo clic en el icono en el menú de navegación de la parte superior izquierda:\\n\\n\\n","section":"Actividades","version":"current","path":"/es/kb/activities#donde-encontrarlo","category":"default"},{"title":"Agregar actividades","content":":::tip\\nNota: Puede configurar una actividad como un tipo de llamada, reunión, tarea, deadline, correo electrónico o almuerzo predeterminada, pero también puede crear tipos de actividad personalizados para actividades específicas para las necesidades de su empresa.\\n:::\\nHay varios lugares en Fintesk donde se pueden crear actividades.\\nEn la Vista de embudo de los negocios:\\nHaga clic en el icono de actividad de un negocio en la vista de embudo.\\nEn la Vista de detalle de cualquier negocio, persona u organización:\\nHaga clic en la pestaña Actividad para vincular una actividad directamente a ese elemento.\\n:::tip\\nNota: Si desea aprender a agregar actividades masivamente, consulte este artículo.\\n:::\\n\\n","section":"Actividades","version":"current","path":"/es/kb/activities#agregar-actividades","category":"default"},{"title":"Programando una actividad","content":"La ventana para programar una actividad presenta la agenda de todo el día a la derecha, junto a los campos necesarios para programar su próxima actividad.\\nEsto le ayuda a programar sus actividades de manera eficiente, evitar la doble reserva y reprogramar sus actividades existentes según sea necesario.\\n\\nEn la ventana de programacion de una actividad, puede completar los siguientes detalles de la actividad:\\nAsunto – Nombre de tu actividad\\nTipo – Predeterminado o Tipo de actividad personalizado\\nHora, fecha y duración – Cuándo y cuánto tiempo es la actividad\\n(Próximamente) nota – Una descripción de su actividad.esto es privado y solo visible dentro de su cuenta de Fintesk.\\n<!-- - Busy/Free – Activities are set to \\"Free\\" by default. If an activity is set to “Busy,” your customers can’t book that time slot through any Scheduler links. -->\\nAlgunos otros campos de actividad destacables:\\nÚltima fecha de actividad – shows the date of the last activity that was marked as done\\nSiguiente fecha de actividad – shows the date of the next activity you scheduled that isn’t marked as done yet\\nFecha de actualización – La fecha de la última actualización realizada en un elemento (una nueva actividad creada, un campo actualizado, movimiento entre etapas, etc.)\\n<!-- Description – Additional details about the activity that will be synced to your external calendar. Unlike the note added to your activity, the description is publicly visible to any guests added to the activity. -->\\n\\n","section":"Actividades","version":"current","path":"/es/kb/activities#programando-una-actividad","category":"default"},{"title":"Vinculación de negocios y contactos","content":"En la ventana de programacion de una actividad, puede ingresar al propietario, así como el negocio, la organización y el contacto de la persona que desea vincular a la actividad.\\nCuando una actividad está vinculada a un elemento, aparece en la página de detalles del elemento.\\n\\nNegocio vinculado – una actividad vinculada solo a un negocio se vincula automáticamente con la persona de contacto y la organización vinculada a ese negocio.\\nPersonas vinculadas (participantes) – una actividad vinculada a una persona se vincula automáticamente con la organización de esa persona.\\nOrganización vinculada – una actividad vinculada a una organización no está vinculada automáticamente a sus negocios o personas, ya que puede haber múltiples negocios y personas vinculadas a cada organización.\\n\\n","section":"Actividades","version":"current","path":"/es/kb/activities#vinculación-de-negocios-y-contactos","category":"default"},{"title":"Completando actividades","content":"Aquí hay algunas cosas que debe saber sobre completar actividades:\\n<!-- or calendar view -->\\nPuede marcarlos como completadas en la lista de actividades, así como las vista detalladas de sus elementos vinculados\\n<!-- - y la vista de línea de tiempo de contactos. -->\\nEl campo marcada como completada de la actividad, se actualiza cuando la actividad se marca como realizada.\\nEl campo fecha finalizacion siempre mostrará la hora y la fecha en que la actividad estaba originalmente programada para finalizar.\\nSi bien puedes editar manualmente la fecha finalizacion de una actividad, incluso retroactivamente, el campo marcada como completada siempre refleja el momento en que la actividad se marcó como completada.\\n\\nPuede leer más sobre la lógica de las actividades marcada como completada en este artículo.\\n<!-- :::tip\\nNota: If you’re just getting started with Fintesk, check out our “Never forget a follow-up” Fintesk Academy course.\\n::: -->\\n<!-- --- -->\\n<!-- TODO: agregar la posibilidad de borrar (SOFT en frontend) -->\\n<!--\\n","section":"Actividades","version":"current","path":"/es/kb/activities#completando-actividades","category":"default"},{"title":"Deleting activities","content":"Activities can be deleted from both your calendar and list view.\\nTo delete an activity from your list view, select one or multiple activities from the left side margin, then click the trash can icon:\\n\\nTo delete an activity from your calendar view, select the activity and click the trash can icon:\\n-->\\n","section":"Actividades","version":"current","path":"/es/kb/activities#deleting-activities","category":"default"},{"title":"Calendar view","content":"\\nThe calendar view always shows the activities by the scheduled due date, regardless of when they were marcada como completada.\\n\\nIn the above example, all three activities have been marcada como completada (shown by the green checkmarks on the right side,) but their position hasn’t changed. -->\\n\\n","section":"Lógica \\"marcada como completada\\" de Actividad","version":"current","path":"/es/kb/activities/activity-marked-as-done-logic#calendar-view","category":"default"},{"title":"Vista de lista","content":"Puedes ver y ordenar en la \\"Vista de lista\\" de actividades basandose en el campo \\"marcada como completada\\".\\nUse el ícono de engranaje en la esquina superior derecha para editar sus columnas \\"Vista de Lista\\", luego seleccione \\"marcada como completada\\" y \\"Guardar\\".\\n\\n<!-- TODO: meter el estilo gris y tachado para las actividades DONE -->\\n<!-- TODO: revisar done_time y done_by_user, parece que no estan funcionando bien -->\\n:::info\\nPróximamente: Puede ver \\"marcada como completada\\" para cualquier actividad relevante, y ordenar por el cual se completaron (ascendente o descendente) recientemente haciendo clic en la barra en la parte superior de la columna.\\n:::\\n<!--  -->\\n\\n","section":"Lógica \\"marcada como completada\\" de Actividad","version":"current","path":"/es/kb/activities/activity-marked-as-done-logic#vista-de-lista","category":"default"},{"title":"Vista de detalle","content":"En la \\"Vista de detalle\\" de un elemento, las actividades vinculadas son ordenadas por su fecha a realizar, que es visible bajo el título de cualquier actividad en su pestaña historia.\\n\\n<!-- TODO: agregar tooltip con la fecha entera por mas que diga today -->\\n:::tip\\nNota: La fecha “marcada como completada” no se encuentra visible en la \\"Vista de detalle\\" de la actividad.\\n:::\\n","section":"Lógica \\"marcada como completada\\" de Actividad","version":"current","path":"/es/kb/activities/activity-marked-as-done-logic#vista-de-detalle","category":"default"},{"title":"Creación de tipos de actividad personalizados","content":"<p>&lt;!-- ../../kb/activities/creating-custom-activity-types.md --&gt;</p>\\n<p>&lt;!-- # Creating custom activity types --&gt;</p>\\n<p>Fintesk viene con un conjunto básico de <strong>tipos de actividades</strong>, pero ¿qué pasa si necesita actividades que sean más específicas para su empresa y sus necesidades?</p>\\n<p>:::tip\\n<strong>Nota:</strong> Esta acción solo está disponible para los usuarios administrativos.\\n:::</p>\\n<p>Afortunadamente, puede crear tipos de actividades personalizadas con su propio ícono para poder hacer que Fintesk sea más específico para su negocio.</p>\\n<p>Para crear un nuevo tipo de actividad en Fintesk:</p>\\n<ul>\\n<li>Vaya a <strong>Configuración&gt; Configuración de la empresa&gt; <a href=\\"https://app.fintesk.com/settings/company-settings#activities?utm_source=fintesk-docs\\">Actividades</a></strong>. todos sus tipos de actividad se listan en esta pantalla.</li>\\n<li>Haga clic en el botón &quot;<strong>+ Tipo de actividad</strong>&quot; para agregar un nuevo tipo de actividad.</li>\\n<li>Elija un icono y nombre para su nuevo tipo de actividad y haga clic en &quot;<strong>Guardar</strong>&quot;.</li>\\n</ul>\\n<p><img src=\\"../../kb/activities/creating-custom-activity-types/01.jpg\\" alt=\\"01\\"></p>\\n","section":"Creación de tipos de actividad personalizados","version":"current","path":"/es/kb/activities/creating-custom-activity-types","category":"default"},{"title":"Agregar actividades masivamente con nuevos elementos","content":":::tip\\nNota: Echa un vistazo a nuestras hojas de cálculo de ejemplo si necesita ayuda para configurar su hoja de cálculo antes de importar.\\n:::\\nCuando importa nuevos elementos (contactos, negocios, actividades, etc.) utilizando una hoja de cálculo, esos elementos están vinculados.\\n\\nEso significa que si importa nuevos contactos y actividades, las actividades estarán vinculadas a los nuevos contactos.\\n:::tip\\nNota: Para agregar actividades masivamente sin vincularlas a otros elementos, importe una hoja de cálculo con solo datos de actividad.\\n:::\\n\\n","section":"¿Cómo puedo crear actividades masivamente?","version":"current","path":"/es/kb/activities/how-can-i-create-activities-in-bulk#agregar-actividades-masivamente-con-nuevos-elementos","category":"default"},{"title":"Agregar actividades masivamente para los elementos existentes","content":"Para agregar actividades masivamente y vincularlas a los elementos existentes, necesitará la función de IDs del sistema Fintesk para importar.\\nPara obtener los ID para sus elementos existentes, use el icono engranaje en su vista de lista para seleccionar el campo \\"ID\\", luego haga clic en \\"Guardar\\".\\n\\nUna vez que esa columna sea visible, exporte los resultados del filtro a una hoja de cálculo:\\n\\nLuego, agregue los datos de actividad necesarios a la hoja de cálculo exportada y re-importe la hoja de cálculo en su cuenta de Fintesk.\\n\\nMapee los campos de actividad adecuadamente, y una vez terminado, tendrá una nueva actividad vinculada a cada elemento que exportó.\\n","section":"¿Cómo puedo crear actividades masivamente?","version":"current","path":"/es/kb/activities/how-can-i-create-activities-in-bulk#agregar-actividades-masivamente-para-los-elementos-existentes","category":"default"},{"title":"Filtrado por tipo de actividad","content":"<!-- :::tip\\nNota: If an activity-type icon is blue, that type is being filtered for. If the icon is grey, it’s being filtered out.\\n::: -->\\nPuede filtrar los tipos de actividad predeterminados o personalizados haciendo clic en ellos en la esquina superior derecha de la vista de lista.\\n\\nPuede seleccionar \\"Todos\\" para agregar o eliminar cada filtro de tipo de actividad. Si desea filtrar para un solo tipo de actividad, haga clic en \\"Todos\\" Para filtrar cada tipo de actividad, luego seleccione el que desea filtrar.\\n:::tip\\nNota: Debe ser un usuario administrativo o un usuario regular con el permiso asignado para crear tipos de actividad personalizados.\\n:::\\n\\n","section":"¿Cómo puedo filtrar mis actividades en la vista de lista?","version":"current","path":"/es/kb/activities/how-can-i-filter-my-activities-in-the-list-view#filtrado-por-tipo-de-actividad","category":"default"},{"title":"Filtrado por la propietaria","content":":::tip\\nNota: Un filtro para \\"Todos\\" muestra las actividades propiedad de cada usuario en la cuenta.\\n:::\\n<!-- TODO: falta implementar  -->\\n<!-- excluding those blocked by visibility settings. -->\\nPara filtrar actividades por propietario, haga clic en el menu desplegable de filtros en la esquina superior derecha de la vista de su lista y seleccione \\"propietarios\\".\\n\\nDesde allí, puede seleccionar cualquier usuario enumerado y usarlo para su filtro.\\n\\n<!-- :::tip\\nNota: If you don’t have visibility of a linked deal or contact, you won’t have visibility of the linked activity.\\n::: -->\\n\\n","section":"¿Cómo puedo filtrar mis actividades en la vista de lista?","version":"current","path":"/es/kb/activities/how-can-i-filter-my-activities-in-the-list-view#filtrado-por-la-propietaria","category":"default"},{"title":"Filtrado por fecha de vencimiento","content":"En el lado derecho de la vista de su lista de actividades, puede filtrar por períodos de tiempo fijos o un rango de fechas personalizado utilizando \\"Seleccionar período\\".\\n\\n:::tip\\nNota: Puede aprender a filtrar las actividades que ya ha marcado como se hizo usando esta guía.\\n:::\\n","section":"¿Cómo puedo filtrar mis actividades en la vista de lista?","version":"current","path":"/es/kb/activities/how-can-i-filter-my-activities-in-the-list-view#filtrado-por-fecha-de-vencimiento","category":"default"},{"title":"¿Cómo puedo vincular mis actividades con múltiples personas?","content":"<p>&lt;!-- ../../kb/activities/how-can-i-link-my-activities-with-multiple-contact-persons.md --&gt;</p>\\n<p>Puede vincular varias personas a una actividad agregándolos en la sección <strong>Personas</strong> de la &quot;Vista de Detalle&quot; de actividad.</p>\\n<p>&lt;!-- # How can I link my activities with multiple contact persons? --&gt;</p>\\n<p>:::tip\\n<strong>Nota:</strong> Una actividad solo puede tener un negocio u organización vinculada. Sin embargo, no hay límite para el número de personas vinculadas que una actividad puede tener.\\n:::</p>\\n<p><img src=\\"../../kb/activities/how-can-i-link-my-activities-with-multiple-contact-persons/01.jpg\\" alt=\\"01\\"></p>\\n<p>:::tip\\n<strong>Nota:</strong> Si se agrega un contacto de Fintesk, la actividad se vinculará a ellos y aparecerá en la vista de detalle de persona.\\n:::</p>\\n<p>&lt;!-- You can also send email notifications about an activity to contacts, both in and out of Fintesk, by adding them as <strong>guests.</strong></p>\\n<p><img src=\\"https://kb-cms.pipedriveassets.com/activities%20guest.jpg\\" alt=\\"1\\"></p>\\n<p>:::tip\\n<strong>Nota:</strong> If a Fintesk contact is added as a guest, the activity won’t be linked to them or appear in their person detail view.\\n::: --&gt;</p>\\n","section":"¿Cómo puedo vincular mis actividades con múltiples personas?","version":"current","path":"/es/kb/activities/how-can-i-link-my-activities-with-multiple-contact-persons","category":"default"},{"title":"¿Cómo puedo ver las actividades completadas?","content":"<p>&lt;!-- ../../kb/activities/how-can-i-see-done-activities.md --&gt;</p>\\n<p>&lt;!-- # How can I see done activities? --&gt;</p>\\n<p>Puede ver las actividades completadas en la vista <strong>Vista de lista</strong> de la pestaña de Actividades aplicando primero un <a href=\\"../../kb/filtering\\">filtro</a>con la condición &quot;Actividad &gt; Completada &gt; es &gt; Completada&quot;.</p>\\n<p><img src=\\"../../kb/activities/how-can-i-see-done-activities/01.jpg\\" alt=\\"01\\"></p>\\n<p>&lt;!-- Then, apply a pre-set or custom time filter to see the activities <strong>done</strong> within the selected time frame. --&gt;</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202024-02-28%20at%2012.18.32.png\\" alt=\\"1\\"> --&gt;</p>\\n<p>Si desea ver todas las actividades completadas, independientemente del marco de tiempo en el que se completó, puede aplicar el filtro <code>Actividad &gt; Fecha de completada &gt; no es vacío</code>.</p>\\n<p><img src=\\"../../kb/activities/how-can-i-see-done-activities/02.jpg\\" alt=\\"02\\"></p>\\n","section":"¿Cómo puedo ver las actividades completadas?","version":"current","path":"/es/kb/activities/how-can-i-see-done-activities","category":"default"},{"title":"Creando una moneda personalizada","content":"Vaya a Configuración de la empresa > Monedas y haga clic en \\"Agregar moneda personalizada\\" para crear una nueva moneda.\\n\\nIngrese el nombre y el símbolo de su moneda, y Fintesk le asignará un código único.\\nTambién puede especificar el valor decimal (es decir, ฿ 0.30048000 o $ 125.17).\\n\\nCuando haya proporcionado toda la información relevante, haga clic en \\"Guardar\\".\\n<!-- Note: You can click “Get a different code” to generate a new code, but you can’t enter a code manually. -->\\n\\n","section":"¿Cómo puedo crear una moneda personalizada?","version":"current","path":"/es/kb/company-settings/how-can-i-create-a-custom-currency#creando-una-moneda-personalizada","category":"default"},{"title":"Ver y actualizar su moneda personalizada","content":"Puede ver su moneda personalizada en varios lugares en su cuenta de Fintesk:\\nVentanas modales de agregar Negocios y productos\\nVistas de detalle de entidades\\n<!-- - Webforms and automations -->\\nEn el modal de agregar negocio, puede elegir cualquier moneda para calcular el valor de ese negocio.\\n\\nEn la vista de detalle del negocio, haga clic en el ícono de lápiz junto al valor de su negocio, para editar su moneda.\\n\\nLuego use el menú desplegable para elegir la moneda deseada y haga clic en \\"Guardar\\".\\nO en cualquier campo personalizado de moneda de una entidad.\\n\\nTambién puede ver su moneda personalizada desde la pestaña Moneda en configuraciones. Las monedas personalizadas siempre aparecen por encima de las monedas predeterminadas en esta vista.\\n\\n\\n","section":"¿Cómo puedo crear una moneda personalizada?","version":"current","path":"/es/kb/company-settings/how-can-i-create-a-custom-currency#ver-y-actualizar-su-moneda-personalizada","category":"default"},{"title":"Desactivando y reactivando monedas personalizadas","content":"Para desactivar una moneda personalizada, vaya a su pestaña Monedas y haga clic, busque la moneda en la tabla y seleccione Desactivar.\\n\\nTambién puede reactivar una moneda haciendo clic en la pestaña \\"desactivados\\" para abrir su lista de monedas desactivadas, buscar la moneda en la tabla y luego \\"activar\\".\\n\\n\\n","section":"¿Cómo puedo crear una moneda personalizada?","version":"current","path":"/es/kb/company-settings/how-can-i-create-a-custom-currency#desactivando-y-reactivando-monedas-personalizadas","category":"default"},{"title":"Cambiar la moneda personalizada a predeterminado","content":"Vaya a Configuración> Preferencias personales> Cuenta y encuentre el menú desplegable de moneda predeterminado.\\n\\nDesde allí, seleccione su moneda personalizada y haga clic en Actualizar datos”.\\n","section":"¿Cómo puedo crear una moneda personalizada?","version":"current","path":"/es/kb/company-settings/how-can-i-create-a-custom-currency#cambiar-la-moneda-personalizada-a-predeterminado","category":"default"},{"title":"How can I enable predefined lost reasons?","content":"<p>&lt;!-- ../../kb/company-settings/how-can-i-enable-predefined-lost-reasons.md --&gt;</p>\\n<p>&lt;!-- # How can I enable predefined lost reasons? --&gt;</p>\\n<p>Como predeterminado, Fintesk opera con Razones de Perdido libre. Esto significa que cada usuario puede escribir su motivo de perdida específico de por qué el negocio en cuestión tenía que marcarse como <strong>perdido</strong>.</p>\\n<p>:::tip\\n<strong>Nota:</strong> Esta acción solo está disponible para los usuarios administrativos de negocios.\\n:::</p>\\n<p>Si prefiere establecer razones específicas y predefinidas para que sus usuarios seleccionen en su lugar, puede habilitar eso dentro de su cuenta yendo a <strong>Configuración de la empresa&gt; <a href=\\"https://app.fintesk.com/settings/company_settings#lost_reasons?utm_source=fintesk-docs\\">razones perdidas</a></strong>.</p>\\n<p>Para habilitar razones predefinidas:</p>\\n<ul>\\n<li>Haga clic en el botón &quot;<strong>Agregar razón perdida</strong>&quot;</li>\\n<li>Escriba la razón perdida predefinida que le gustaría agregar a su cuenta</li>\\n<li>Haga clic en el botón &quot;<strong>Guardar</strong>&quot;</li>\\n</ul>\\n<p><img src=\\"../../kb/company-settings/how-can-i-enable-predefined-lost-reasons/lr01.jpeg\\" alt=\\"lr01\\"></p>\\n<p>Cuando se guarda, la razón perdida predefinida aparecerá a continuación. Al hacer clic en ella, le permitirá editarla o desactivarla.</p>\\n<p><img src=\\"../../kb/company-settings/how-can-i-enable-predefined-lost-reasons/lr02.jpeg\\" alt=\\"lr02\\"></p>\\n<p>&lt;!-- You’ll also be presented with an option to allow for freeform lost reasons alongside your predefined options.</p>\\n<p><img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202024-04-16%20at%2014.39.14.png\\" alt=\\"1\\"></p>\\n<p>This way, your users could still provide freeform lost reasons in situations where the lost reason differs from the list of predefined lost reasons programmed by the admin user.</p>\\n<p><img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202024-04-16%20at%2014.43.37.png\\" alt=\\"1\\">--&gt;</p>\\n<p>Para usar sus razones perdidas predefinidas, simplemente marque un negocio en su cuenta de Fintesk como <strong>perdido</strong>.</p>\\n<p>En la seccion <strong>&quot;Marcar como perdida&quot;</strong>, verá una sección desplegable en la razón perdida en lugar del formulario de ingreso de texto. Haga clic en el indicador desplegable para desplazarse a través de una lista de sus razones perdidas predefinidas y seleccione una.</p>\\n<p>Después de seleccionar su razón perdida predefinida, e incluir cualquier comentario adicional que pueda tener, haga clic en el <strong>&quot;Marcar como perdida&quot;</strong>.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202024-04-16%20at%2014.47.57.png\\" alt=\\"1\\"> --&gt;</p>\\n<p>Una vez hecho hecho, esa razón perdida predefinida aparecerá en la <strong>vista de detalle</strong> de este, ahora negocio <strong>perdido</strong>.</p>\\n<p>Estas razones perdidas predefinidas también se pueden seguir de la misma manera que las razones perdidas de forma libre, a través de la <strong>vista de lista</strong> de los <strong>negocios</strong> de su cuenta de Fintesk.</p>\\n","section":"How can I enable predefined lost reasons?","version":"current","path":"/es/kb/company-settings/how-can-i-enable-predefined-lost-reasons","category":"default"},{"title":"Razones de pérdida libre","content":"son proporcionados por cualquier usuario que marca un negocio como perdido\\nPermitir que un usuario proporcione su idea de por qué el negocio no procedió\\n","section":"Razones de pérdida","version":"current","path":"/es/kb/company-settings/lost-reasons#razones-de-pérdida-libre","category":"default"},{"title":"Razones de pérdida predefinidas","content":"son programados por un usuario administrador como una lista para que otros usuarios elijan\\nSe puede elegir de esta lista cuando un negocio se marca como perdido, lo que permite información consistente y efectiva sobre por qué un negocio no procedió\\nAmbas opciones le permiten proporcionar comentarios adicionales sobre por qué ese negocio específico se marcó como perdido.\\nEstos comentarios se colocan en el negocio perdido como una nota para que siempre pueda consultar la información específica sobre por qué ese negocio se marcó como perdido.\\n\\n","section":"Razones de pérdida","version":"current","path":"/es/kb/company-settings/lost-reasons#razones-de-pérdida-predefinidas","category":"default"},{"title":"Usando razones perdidas","content":":::tip\\nNota: Por defecto, Fintesk está configurado para utilizar las razones de perdida libres. Aprenda a habilitar razones perdidas predefinidas en este artículo.\\n:::\\nPara usar sus razones perdidas, simplemente marque un negocio en su cuenta de Fintesk como perdido. Verá un aviso solicitando una razón para marcar ese negocio como se pierde en su cuenta.\\n\\nProporcione su visión de por qué se perdió el negocio, incluidos los comentarios adicionales que pueda tener, y haga clic en el botón \\"Marcar como perdido\\".\\nEl estado del negocio se cambiará a Perdido, y eso siempre se hará visible en la sección Detalles de la vista de detalles de ese negocio.\\n<!-- If you provided other comments in the provided section, those comments will be saved as a note, viewable in the detail view of that deal.\\n\\n-->\\nSi proporcionó otros comentarios en la sección proporcionada, esos comentarios se guardarán, visibles en la vista de lista de ese negocio.\\n\\n","section":"Razones de pérdida","version":"current","path":"/es/kb/company-settings/lost-reasons#usando-razones-perdidas","category":"default"},{"title":"Seguimiento de razones perdidas","content":"Usando esta información de razón perdida documentada, puede obtener una idea para las tendencias dentro de sus ventas, como si es probable que una cierta categoría de clientes termine una venta en una determinada época del año, o si un competidor está comenzando a expulsar a algunos de sus clientes.\\nPara tener una idea inmediata de sus razones perdidas:\\nVaya a la pestaña Negocios de su cuenta Fintesk y luego a la vista de lista.\\nUsando el botón Filtros, busque los negocios perdidos dentro de su cuenta de Fintesk.\\nAl mostrar esos negocios perdidos, haga clic en el ícono de engranajes en el lado derecho de la aplicación Fintesk.\\nSeleccione la columna razón de perdida para mostrar en su vista de lista y haga clic en \\"Guardar\\".\\nCon esa columna de razón de perdida ahora, debe ver las razones proporcionadas por qué cada negocio específico se marcó como perdido.\\n\\n","section":"Razones de pérdida","version":"current","path":"/es/kb/company-settings/lost-reasons#seguimiento-de-razones-perdidas","category":"default"},{"title":"Vista de detalles de contacto","content":"A primera vista, la vista de detalle de contacto ofrece mucha información, incluida la sección a la derecha donde puede:\\nEscribir notas\\nCrear nuevas actividades\\n<!-- Learn more about Smart Docs -->\\n\\n\\n","section":"Vista de detalles de contacto","version":"current","path":"/es/kb/contacts/contact-detail-view#vista-de-detalles-de-contacto","category":"default"},{"title":"Barra lateral","content":"<!-- Note: For a more detailed guide about detail view sidebar management, check out [this article.]\\n(../../kb/detail-view/detail-view-sidebar)\\nThe sidebar section contains a wealth of pertinent information, which can be separated into two sections. -->\\n","section":"Vista de detalles de contacto","version":"current","path":"/es/kb/contacts/contact-detail-view#barra-lateral","category":"default"},{"title":"Datos generales","content":"Su barra lateral tiene varias secciones que ofrecen una descripción general de los datos de su contacto.\\nResumen – siempre tiene las mismas piezas de información: etiquetas (próximamente), dirección de correo electrónico, número de teléfono y organización/persona vinculada\\nDetalles – puede elegir cualquier campo disponible, tanto predeterminado como personalizado, para mostrar aquí\\nDescripción general – Muestra las actividades creadas para el contacto, así como qué usuarios han interactuado con él.\\n\\n","section":"Vista de detalles de contacto","version":"current","path":"/es/kb/contacts/contact-detail-view#datos-generales","category":"default"},{"title":"Elementos vinculados","content":"<!-- You can also find any linked leads, deals, contacts and projects in your sidebar. -->\\nTambién puede encontrar negocios, contactos y organizaciones vinculadas en su barra lateral.\\n\\n\\n","section":"Vista de detalles de contacto","version":"current","path":"/es/kb/contacts/contact-detail-view#elementos-vinculados","category":"default"},{"title":"Registro de cambio","content":"Bajo el Historial de su elemento, puede seleccionar el Registro de cambio.\\n\\nEsto le brinda una lista detallada de actualizaciones realizadas en su contacto, incluso cuando se hicieron estos cambios y por qué usuario.\\n\\n","section":"Vista de detalles de contacto","version":"current","path":"/es/kb/contacts/contact-detail-view#registro-de-cambio","category":"default"},{"title":"Tarjetas flotante","content":"En la vista de detalle, puede pasar su cursor sobre ciertos elementos y ver una tarjeta con los datos de ese elemento.\\n\\n\\n","section":"Vista de detalles de contacto","version":"current","path":"/es/kb/contacts/contact-detail-view#tarjetas-flotante","category":"default"},{"title":"Historial","content":"Esta sección incluye cualquier actualización realizada en un contacto y se divide en secciones para un fácil filtrado.\\n\\n","section":"Vista de detalles de contacto","version":"current","path":"/es/kb/contacts/contact-detail-view#historial","category":"default"},{"title":"Personas","content":"Los contactos tipo Persona son los clientes individuales a los que vende usando Fintesk como CRM.\\nSon la columna vertebral del proceso de ventas, y la información relacionada, como las actividades y correos electrónicos, se registran en la vista de detalle de esa persona.\\n\\nCosas a tener en cuenta sobre la persona:\\nSon sus clientes y contienen direcciones de correo electrónico y números de teléfono.\\nSe pueden vincular a una organización.\\nSe pueden vincular a múltiples negocios al mismo tiempo.\\n:::tip\\nNota: Puede crear campos personalizados para agregar datos a sus contactos que no están cubiertos por los campos predeterminados de Fintesk.\\n:::\\n\\n","section":"Contactos-> Personas y organizaciones","version":"current","path":"/es/kb/contacts/contacts-persons-and-organizations#personas","category":"default"},{"title":"Organizaciones","content":"Organizaciones son empresas o colecciones de contactos, y al igual que la persona, puede encontrar sus detalles relevantes e información vinculada en la vista de detalle.\\n\\nCosas a tener en cuenta sobre las organizaciones:\\nSon las empresas para las que trabajan las personas y contienen información como una dirección postal o información de la industria.\\nSe pueden vincular a múltiples persona.\\nPueden tener múltiples negocios abiertos para ellos al mismo tiempo.\\nEllas pueden estar relacionadas a otras organizaciones (próximamente).\\n:::tip\\nNota: Una persona u organización puede tener múltiples negocios vinculados a ellos, pero un negocio solo puede estar vinculado a una persona u organización a la vez.\\n:::\\n\\n","section":"Contactos-> Personas y organizaciones","version":"current","path":"/es/kb/contacts/contacts-persons-and-organizations#organizaciones","category":"default"},{"title":"Cómo agregar contactos","content":"Las personas y las organizaciones se pueden agregar a su cuenta de Fintesk de varias maneras:\\nEn el cuadro de diálogo \\"Agregar negocio\\", puede crear un nuevo contacto agregando un nombre no vinculado a un contacto existente.\\n\\n\\n\\nEn la pestaña Vista de Lista de sus personas u organizaciones, puede crear nuevos contactos con los botones “+ Agregar persona” o “+ Agregar Organización”.\\n\\n\\n<!-- - In an organization’s detail view, you can add a new person using the “+” button in the persons section.\\n-->\\n:::tip\\nNota: Para obtener más información sobre cómo vincular personas y organizaciones, puede ver este artículo.\\n:::\\n<!--\\n","section":"Contactos-> Personas y organizaciones","version":"current","path":"/es/kb/contacts/contacts-persons-and-organizations#cómo-agregar-contactos","category":"default"},{"title":"Labeling contacts","content":"Your Fintesk contacts can be categorized using the contact labels feature.\\n\\nYou can add existing labels to contacts, or create new labels using the “+ Add new label” option.\\n:::tip\\nNota: Multiple labels can be added to a single person or organization. For more information about labeling, check out this article.\\n::: -->\\n","section":"Contactos-> Personas y organizaciones","version":"current","path":"/es/kb/contacts/contacts-persons-and-organizations#labeling-contacts","category":"default"},{"title":"Creación de campos personalizados de una persona u organización","content":"Para crear un campo personalizado para sus negocios, vaya a Configuración de la empresa> Campos de datos y seleccione \\"+ Agregar campo personalizado\\" En Deal.\\n<!-- Lead/deal. -->\\n\\nEscriba un nombre para su campo, seleccione \\"Persona\\" o \\"Organización\\" para su tipo de campo y haga clic en \\"Guardar.\\"\\n\\nDebería ver su nuevo campo listado en Campos personalizados.\\n\\n:::tip\\nNota: For more information about custom fields and the related settings, check out this guide.\\n:::\\n\\n","section":"¿Cómo puedo agregar personas u organizaciones relacionadas a un negocio?","version":"current","path":"/es/kb/contacts/how-can-i-add-related-persons-or-organizations-to-a-deal#creación-de-campos-personalizados-de-una-persona-u-organización","category":"default"},{"title":"Usando un campo personalizado","content":":::tip\\nNota: Un campo personalizado de tipo persona u organización permite que se agregue un contacto.\\nSi desea agregar múltiples personas u organizaciones relacionadas a sus negocios, debe crear múltiples campos personalizados.\\n:::\\nUna vez que haya creado su campo personalizado, vaya a la vista de detalle de un negocio y haga clic en el icono lápiz a la derecha del campo.\\n\\nEscriba las primeras letras del nombre de su persona u organización, y aparecerá automáticamente. Si no existe un contacto con ese nombre en su cuenta, puede crear uno usando el campo.\\n\\n","section":"¿Cómo puedo agregar personas u organizaciones relacionadas a un negocio?","version":"current","path":"/es/kb/contacts/how-can-i-add-related-persons-or-organizations-to-a-deal#usando-un-campo-personalizado","category":"default"},{"title":"Vincular una organización con una persona","content":"Para vincular una organización a una persona, vaya a la vista de detalle de un contacto de una persona y haga clic en \\"+Enlazar una organización\\" bajo la tarjeta organización.\\n\\nLuego puede buscar una organización en la cuenta Fintesk de su empresa y hacer clic en ella, lo que lo llevará a la opción \\"Enlazar esta organización\\".\\nSi no hay organización con el nombre que buscó, se le pedirá que cree una nueva organización.\\n\\n\\n<!-- ## Adding a new person to an organization\\nTo link an existing person to an organization, go to the detail view of an organization and click on the \\"+\\" icon in the persons sidebar section. You will be prompted with the Link a person modal, where you can enter the name of your person contact.\\n\\n:::tip\\nNote: If a person with the name you typed in doesn\'t exist, you can use the \\"+Add\\" option to create a new person contact.\\n:::\\n--- -->\\n","section":"Vinculación de personas y organizaciones","version":"current","path":"/es/kb/contacts/linking-persons-and-organizations#vincular-una-organización-con-una-persona","category":"default"},{"title":"Actualización de la organización vinculada","content":"Para desactivar, cambiar o actualizar los campos de la organización vinculada de una persona de contacto, vaya a la página de detalles de la persona de contacto y haga clic en el icono \\"...\\" en la tarjeta de organización.\\n\\n\\n","section":"Vinculación de personas y organizaciones","version":"current","path":"/es/kb/contacts/linking-persons-and-organizations#actualización-de-la-organización-vinculada","category":"default"},{"title":"Vincular un negocio con un contacto","content":"<!-- Both persons and organizations can be linked to a Deal through the detail view, using either the \\"+\\" option in the [sidebar section](../../ES DRAFT AUN), or the \\"Link\\" option in the person and organization sections: -->\\nTanto las personas como las organizaciones pueden vincularse a un negocio a través de la vista de detalle, utilizando la opción \\"+\\" en la sección de la barra lateral, o la opción \\"enlazar\\" en las secciones de la persona y la organización:\\n\\nCon cualquier método, se le pedirá que escriba el nombre del contacto que desea vincular. Si el contacto ya existe en su base de datos, podrá vincularlo a su negocio. Si aún no existe un contacto con ese nombre, tendrá la opción de crear un nuevo contacto.\\n\\nTambién puede vincular los contactos a sus negocios yendo a la vista de su lista, pasando su cursor sobre el espacio de una persona u organización y haciendo clic en el icono lápiz.\\n\\n","section":"Vinculación de personas y organizaciones","version":"current","path":"/es/kb/contacts/linking-persons-and-organizations#vincular-un-negocio-con-un-contacto","category":"default"},{"title":"Agregar campos personalizados","content":"<!-- :::tip\\nNote: Not sure where to add your custom field? Learn more about how your data is organized in this article.\\n::: -->\\n:::tip\\nNota: ¿No está seguro de dónde agregar su campo personalizado? Obtenga más información sobre cómo se organizan sus datos en este artículo.\\n:::\\nVaya a Configuración> Compañía> Campos de datos, y haga clic en \\"Agregar campo personalizado\\". El campo se puede agregar en Negocio, Persona, Organización o Producto.\\nEn la ventana que aparece, Nombre el campo y seleccione el tipo de campo que desea crear. Fintesk ofrece una variedad de tipos de campo personalizados que se pueden personalizar fácilmente en concordancia con la información que necesita para sus datos.\\n\\nPuede aprender sobre los tipos de campos personalizados disponibles en este artículo.\\n\\n<!--  -->\\n","section":"Campos personalizados","version":"current","path":"/es/kb/data-fields/custom-fields#agregar-campos-personalizados","category":"default"},{"title":"Field properties","content":"Al agregar un campo personalizado, puede elegir los lugares donde el campo se muestra en Fintesk.\\n<!-- - Always visible in detail view (pinned)\\nThe custom field always appears in the item’s detail view, whether or not a value is added. -->\\nAparece en la vista de agregar\\nThe custom field always appears in that item’s “Add new” dialog.\\nAparece en la vista de detalle\\nEl campo personalizado siempre aparece en ese elemento dentro de la vista de detalle. Por ejemplo, tal vez solo desee agregar un campo para trabajar solo con nuestra API.\\n<!-- - **Appears in project detail view\\n**The custom field always appears in a project\'s detail view, whether or not a value is added. -->\\n<!-- - Pipeline (for lead/deal custom fields only)\\nYou can hide some fields from specific pipelines and unclutter the deal detail view. -->\\n<!-- :::tip\\nNote: Pipeline-specific custom fields are only available for Professional and higher plans.\\n::: -->\\n<!-- ### Quality rules\\nRequired fields\\nMark fields as required to ensure your team enters crucial deal data. If a required field is empty, users won\'t be able to save the deal and will see a reminder in already existing deals.\\nImportant fields\\nMarks a field as “important” in all or specific pipelines and stages. You can read more about important fields in this article. -->\\n<!-- ### Where else can I add custom fields?\\nCustom fields can also be added in the vista de detalle of an item by going to Details > Customize fields > +Add a new field.\\n\\n--- -->\\n","section":"Campos personalizados","version":"current","path":"/es/kb/data-fields/custom-fields#field-properties","category":"default"},{"title":"Ver sus campos personalizados","content":"Puede agregar, ver o eliminar los valores de campo personalizados en los siguientes lugares dentro de Fintesk.\\nEn la vista de detalle:\\nEn la vista de detalle, cualquier campo personalizado se puede encontrar en la sección Detalles.\\nEn la vista de lista:\\nHaga clic en el icono de engranaje a la derecha de la tabla y seleccione el campo personalizado en la sección \\"Elegir columnas\\".Haga clic en \\"Guardar\\" para que esa columna de campo personalizada sea visible en la vista de la lista\\nEn la Add new dialog:\\nIf the “Show in add new dialog” option is marked as “Yes,” the custom field will appear in the “Add new” modals.\\nEn la función de Importación:\\nAl importar una hoja de cálculo en Fintesk, sus campos personalizados se pueden asignar a columnas en su hoja de cálculo. También puede agregar campos personalizados directamente desde la página Mapeo.\\nLea más sobre la importación en este artículo.\\n\\n","section":"Campos personalizados","version":"current","path":"/es/kb/data-fields/custom-fields#ver-sus-campos-personalizados","category":"default"},{"title":"Actualización de sus campos personalizados","content":"Para cambiar sus campos personalizados, vaya a Configuración> Compañía> Campos de datos y haga clic en el botón \\"...” junto a su campo personalizado.\\n\\nEditar\\nPuede cambiar el nombre de campo personalizado, propiedades de campo para su campo personalizado en cualquier momento. El tipo de campo personalizado no se puede cambiar una vez que se ha creado.\\n\\n\\nBorrar\\nEliminar su campo personalizado eliminará el campo y sus datos existentes de su cuenta Fintesk.\\n\\n\\nCopiar clave API\\nPuede copiar la clave API de su campo personalizado. Para obtener más información sobre cómo usar la API, puede ver nuestra Documentación de API.\\n<!-- **You can change the custom field name, field properties and important fields for your custom field at any time. The custom field type cannot be changed once it has been created. -->\\n<!--\\nReorder\\nYou can change the order your custom fields are displayed in. After clicking on “Reorder“, you will be prompted with a window where you can change the order of fields. The changes will be applied to the Add new view and vista de detalle.\\n\\n-->\\n<!--\\n","section":"Campos personalizados","version":"current","path":"/es/kb/data-fields/custom-fields#actualización-de-sus-campos-personalizados","category":"default"},{"title":"Custom field grouping","content":"You can organize your custom fields into groups, making it easier to find the field you need.\\nTo add a new custom field group, click ”+ Field group“ while creating or editing a custom field.\\n\\nAfter you create your group, you can see it in your data fields.\\n\\nYou can view your fields in groups or in a standard list view.\\n-->\\n","section":"Campos personalizados","version":"current","path":"/es/kb/data-fields/custom-fields#custom-field-grouping","category":"default"},{"title":"Campos personalizados","content":"Una de las características principales de Fintesk es el enfoque personalizable para administrar sus procesos y operaciones de ventas. El tipo de información que recopila de los clientes puede variar según su negocio e industria, por eso ofrecemos la opción de crear Campos personalizados.\\n\\nEstos campos se pueden ver en Vista de detalle, Vista de lista, y en el diálogo Agregar nuevo.Obtenga más información sobre cómo agregar y configurar estos campos en nuestro artículo de campos personalizados.\\n<!-- :::tip\\nNota: Formulas and pipeline-specific custom fields are only available for Professional and Enterprise users. The number of custom fields you can have depends on which plan you are on. Learn more about usage limits in this article.\\n::: -->\\n\\n","section":"Campos de datos en Fintesk","version":"current","path":"/es/kb/data-fields/data-fields-in-fintesk#campos-personalizados","category":"default"},{"title":"Campos predeterminados","content":"Los campos predeterminados ya están integrados en su cuenta de Fintesk cuando la crea. Por lo general, se usan para información relevante del cliente, como nombres, correos electrónicos o números de teléfono: cuando no existe un campo relevante, se puede crear un campo personalizado.\\n<!-- You can find the default fields section right below the custom fields section.\\n-->\\n:::tip\\nNota: Los campos predeterminados no se pueden eliminar.\\n:::\\nEstos campos se pueden ver en la vista de detalle, vista de lista. El nombre o tipo de campos predeterminados no se puede editar.\\n<!-- TODO: agregar esta clasificacion y posibilidad de modificar cuando este grouping -->\\n<!-- , but the quality rules can. -->\\n<!--  -->\\n:::tip\\nNota: Las cuentas de mensajería instantánea, las direcciones postales, las notas, el cumpleaños/fechas de nacimiento y los campos como puesto de trabajo no existen de forma predeterminada en Fintesk. Pero puede agregarlo a través de campos personalizados.\\n<!-- They are only created for contact persons when you set up your contact sync. You can learn more about contact sync in this article. -->\\n:::\\n\\n","section":"Campos de datos en Fintesk","version":"current","path":"/es/kb/data-fields/data-fields-in-fintesk#campos-predeterminados","category":"default"},{"title":"Campos del sistema","content":"Los campos del sistema también ya están integrados en su cuenta de Fintesk. Estos campos son parte de la interfaz Fintesk. La información que contienen no se llena dentro de la vista de detalle o en el diálogo de Agregar nuevo, ya que se llena manual o automáticamente a través de una característica o menú diferente (por ejemplo, la fecha en que se creó un elemento o la cantidad de correos electrónicos que intercambió con un contacto).\\nPuede encontrar la sección Campos del sistema justo a continuación.\\n<!-- the default fields section. -->\\n\\n:::tip\\nNota: Los campos del sistema no se pueden editar ni eliminar.\\n:::\\nEstos campos siempre son visibles cuando asigna sus importaciones, y son útiles para actualizar los datos en Fintesk con hojas de cálculo.\\n","section":"Campos de datos en Fintesk","version":"current","path":"/es/kb/data-fields/data-fields-in-fintesk#campos-del-sistema","category":"default"},{"title":"¿Qué campos puedo agregar?","content":"La capacidad de agregar un campo de datos via alguna ventana Agregar item dependerá del tipo de campo que esté tratando de agregar y dónde está tratando de agregarlo.\\n<table>\\n<tr>\\n<td></td>\\n<td>Ventana agregar negocio</td>\\n<td>Ventana agregar persona</td>\\n<td>Ventana agregar organización</td>\\n<td>Ventana agregar producto</td>\\n</tr>\\n<tr>\\n<td>Campo de Negocio</td>\\n<td>✔️</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>Campo de Persona</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>Campo de Organización</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td>✔️</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>Campo de Producto</td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>✔️</td>\\n</tr>\\n</table>\\n","section":"¿Cómo puedo agregar campos de datos a un negocio adicional, contacto o producto?","version":"current","path":"/es/kb/data-fields/how-can-i-add-data-fields-to-an-add-deal-contact-or-product-modal#qué-campos-puedo-agregar","category":"default"},{"title":"Tipos de campos personalizados","content":"Hay catorce (hasta este momento) diferentes tipos de campos personalizados, lo cual permite agregar diferentes tipos de información, a sus negocios, personas, organizaciones o productos.\\n<!-- There are sixteen different types of custom fields, with different kinds of information you can add to your deals, persons, organizations, or products. -->\\n<!-- information you can add to your leads, deals, contacts, projects or products. -->\\n<table>\\n<tr>\\n<td>Nombre de campo</td>\\n<td>Para que es</td>\\n<td>Usos comunes</td>\\n</tr>\\n<tr>\\n<td>Texto</td>\\n<td>Notas, URL u otro texto</td>\\n<td>Direcciones de correo electrónico secundarias, (breves) comentarios, cargos de trabajo</td>\\n</tr>\\n<tr>\\n<td>Texto largo</td>\\n<td>Notas más largas</td>\\n<td>Comentarios más largos, descripciones</td>\\n</tr>\\n<tr>\\n<td>Opción única</td>\\n<td>Lista de opciones predefinidas donde solo se puede seleccionar una opción (máximo 500 opciones)</td>\\n<td>Categoría, industria, cargo de trabajo</td>\\n</tr>\\n<tr>\\n<td>Opciones múltiples</td>\\n<td>Lista de opciones predefinidas donde se pueden seleccionar múltiples elementos (máximo 500 opciones)</td>\\n<td>Industria, región, competidores, cargo de trabajo, estado del artículo</td>\\n</tr>\\n<tr>\\n<td>Numérico</td>\\n<td>Datos numéricos</td>\\n<td>Nivel de prioridad, clasificación numerada, unidades solicitadas</td>\\n</tr>\\n<tr>\\n<td>Monetario</td>\\n<td>Datos numéricos prefijados con un símbolo de moneda.</td>\\n<td>Comisión, estimaciones, costos</td>\\n</tr>\\n<tr>\\n<td>Usuario</td>\\n<td>Etiqueta un usuario Fintesk desde tu cuenta</td>\\n<td>Propietarios de negocios o de contacto anteriores o secundarios, usuarios relacionados con el proyecto más grande</td>\\n</tr>\\n<tr>\\n<td>Organización</td>\\n<td>Etiqueta una organización desde tu base de datos de tu cuenta Fintesk.</td>\\n<td>Partes relacionadas o secundarias, organizaciones asociadas, holdings</td>\\n</tr>\\n<tr>\\n<td>Persona</td>\\n<td>Etiqueta una personadesde tu base de datos de tu cuenta Fintesk.</td>\\n<td>Contacto relacionado o secundario</td>\\n</tr>\\n<tr>\\n<td>Teléfono</td>\\n<td>Ingrese un número de teléfono</td>\\n<td>Nombres de Skype, números de teléfono secundarios, número de teléfono principal para elemento vinculado (negocio, org.)</td>\\n</tr>\\n<tr>\\n<td>Tiempo</td>\\n<td>Tiempo específico elegido de pop-up desplegable de tiempo. El formato de tiempo coincidirá con su formato de zona horaria predeterminada.</td>\\n<td>Tiempo de entrega, hora del almuerzo</td>\\n</tr>\\n<tr>\\n<td>Rango de tiempo</td>\\n<td>Rango de tiempo elegido de un pop-up desplegable de tiempo. El formato de tiempo coincidirá con su formato de zona horaria predeterminada.</td>\\n<td>Horario de oficina, mejor momento para contactar</td>\\n</tr>\\n<tr>\\n<td>Fecha</td>\\n<td>Fecha específica elegida de un calendario desplegable</td>\\n<td>Fecha de entrega, plazos</td>\\n</tr>\\n<tr>\\n<td>Rango de fechas</td>\\n<td>Rango de fechas elegidas de un calendario desplegable</td>\\n<td>Fechas del evento, estimaciones de finalización, vacaciones</td>\\n</tr>\\n</table>\\n<!-- | Address          | Stores full addresses using autocomplete from Google Maps.                                                | Event places, secondary office locations (when separate from business address)                    | -->\\n\\n","section":"¿Qué tipos de campos personalizados hay?","version":"current","path":"/es/kb/data-fields/what-types-of-custom-fields-are-there#tipos-de-campos-personalizados","category":"default"},{"title":"Cosas a tener en cuenta","content":"Los campos personalizados del tipo usuario, organización y persona permites ingresar al valor del elemento a través de un clic.\\nLas personas en Fintesk ya tienen un campo telefónico predeterminado, pero se puede agregar un campo personalizado de tipo teléfono en otros elementos (organizaciones, negocios, etc.).\\nLas organizaciones en Fintesk ya tienen un campo de dirección predeterminado, pero se puede agregar un campo personalizado de tipo dirección en otros elementos (negocios, personas, etc.)\\nAl agregar un valor en un campo personalizado tipo persona u organización, si un contacto con ese nombre no existe en su cuenta, se creará uno nuevo.\\nLa moneda de un campo monetario coincidirá con su configuración de moneda predeterminada a menos que se especifique lo contrario.\\n<!-- - Numerical and monetary fields for deals can also have formulas added to them. You can learn more about formula fields in this article. -->\\n<!-- - Text fields can be used for URLs, and clicking a URL in a text field will redirect you to that webpage -->\\n<!-- - Address custom fields behave like the default address fields under organizations, including subfields and the “Show on Map” feature. -->\\n","section":"¿Qué tipos de campos personalizados hay?","version":"current","path":"/es/kb/data-fields/what-types-of-custom-fields-are-there#cosas-a-tener-en-cuenta","category":"default"},{"title":"Agregar negocios masivamente","content":"<p>:::tip\\n<strong>Nota:</strong> El número de negocios abiertos que puede tener depende del plan en el que se encuentre. Puede obtener más información sobre los límites de uso en <a href=\\"../../kb/personal-settings/usage-limits-in-fintesk\\">este artículo</a>.\\n:::</p>\\n<p>Hay dos métodos para agregar negocios masivamente a Fintesk y ambos son a través de <a href=\\"../../kb/importing-data/importing-data-into-fintesk-with-spreadsheets\\">importación</a>.</p>\\n<hr>\\n<p><strong>Si no tiene personas u organizaciones agregadas a la cuenta de su empresa:</strong></p>\\n<p>Importarlos con una hoja de cálculo, agregando todos los detalles como sea posible, como persona de contacto u organización, valor de negocio, actividades de seguimiento, etc.</p>\\n<p>Puede encontrar nuestras hojas de cálculo de importación de ejemplo en <a href=\\"../../kb/importing-data/importing-sample-import-spreadsheets\\">esta página</a>.</p>\\n<p>:::tip\\n<strong>Nota:</strong> Los negocios deben tener una persona de contacto u organización vinculada.\\n:::</p>\\n<hr>\\n<p><strong>Si ya tiene personas de contacto u organizaciones agregadas a la cuenta de su empresa y desea agregarles negocios masivamente:</strong></p>\\n<p>Sugerimos utilizar la función de ID del sistema Fintesk al <a href=\\"../../kb/importing-data/updating-fintesk-data-with-a-spreadsheet\\">importar una hoja de cálculo</a>.</p>\\n<p>Para adquirir una hoja de cálculo que contiene la persona necesaria u ID de organización, vaya a la <a href=\\"../../kb/list-view\\">Vista de la lista</a> y use el icono de engranaje para hacer el campo <strong>ID del sistema Fintesk</strong> apropiado visible.</p>\\n<p>Una vez que ese campo sea visible, <a href=\\"../../kb/exporting-data/exporting-data-from-fintesk\\">exportar</a> los resultados del filtro a una hoja de cálculo, proporcionando la información necesaria e <a href=\\"../../kb/importing-data/importing-data-into-fintesk-with-spreadsheets\\">importar</a> esa hoja de cálculo en su cuenta de Fintesk.</p>\\n<p>:::tip\\n<strong>Nota:</strong> La exportación desde la vista de la lista solo está disponible para usuarios administrativos y usuarios regulares con permisos adecuados.\\n:::</p>\\n","section":"Agregar negocios masivamente","version":"current","path":"/es/kb/deals/adding-deals-in-bulk","category":"default"},{"title":"La vista de detalle del negocio","content":"Al hacer clic en un negocio, abre su vista de detalle, donde puede ver cualquier contacto, productos o actividades vinculados.\\n\\nAquí hay algunas cosas a tener en cuenta sobre los negocios:\\nLos negocios pueden estar vinculadas a una persona u organización. Cualquier cambio realizado en un elemento vinculado también se refleja en el negocio.\\nLas actividades y los productos pueden estar vinculados a un negocio.\\nLos negocios hacen seguimiento de todos los eventos y movimientos que tienen lugar a lo largo de su proceso de ventas (o cualquier proceso en el cual sea utilizado).\\nLos negocios se pueden importar desde un archivo CSV o XLS.\\n<!-- - Deals can be imported from a previous CRM or  -->\\n\\n","section":"Negocios-> qué son y cómo agregarlas","version":"current","path":"/es/kb/deals/deals-what-they-are-and-how-to-add-them#la-vista-de-detalle-del-negocio","category":"default"},{"title":"Agregar un negocio a la vez","content":"Hay una variedad de formas en que puede agregar un nuevo negocio a su cuenta de Fintesk.\\n","section":"Negocios-> qué son y cómo agregarlas","version":"current","path":"/es/kb/deals/deals-what-they-are-and-how-to-add-them#agregar-un-negocio-a-la-vez","category":"default"},{"title":"El botón \\"+ Agregar negocio\\"","content":"<!-- This button is found in your pipeline view, forecast view and deal list view. -->\\nEste botón se encuentra en su vista de embudos y vistas de la lista de negocios.\\n\\n<!-- You can also find it in your project detail view.\\n-->\\n","section":"Negocios-> qué son y cómo agregarlas","version":"current","path":"/es/kb/deals/deals-what-they-are-and-how-to-add-them#el-botón--agregar-negocio","category":"default"},{"title":"El botón \\"+\\"","content":"Esta opción se encuentra en la vista de detalles de su persona u organización en la sección Negocio.\\n\\n:::tip\\nNota: Para agregar un negocio de esta manera, la sección de la barra lateral del negocio debe estar visible.\\n<!-- To learn how to manage your sidebar sections, check out [this article]\\n(../../kb/detail-view/detail-view-sidebar). -->\\n:::\\n","section":"Negocios-> qué son y cómo agregarlas","version":"current","path":"/es/kb/deals/deals-what-they-are-and-how-to-add-them#el-botón-","category":"default"},{"title":"El botón \\"Agregar nuevo negocio\\"","content":"Esta opción se puede encontrar en la vista de detalles de su persona u organización.\\n\\n<!-- It can also be found in your email tab.\\n\\nIf you have an existing deal you want to link to the email, select “Link to existing.” -->\\n\\n","section":"Negocios-> qué son y cómo agregarlas","version":"current","path":"/es/kb/deals/deals-what-they-are-and-how-to-add-them#el-botón-agregar-nuevo-negocio","category":"default"},{"title":"Agregar negocios masivamente","content":":::tip\\nNota: Para aprender sobre la importación de datos en su cuenta de Fintesk, mire esta guía en profundidad.\\n:::\\nPuede agregar múltiples negocios al mismo tiempo utilizando el proceso de importación.\\nComience yendo a \\"...\\"> Importar datos.\\n<!--  -->\\n\\nAsegúrese de tener una columna para Nombre del negocio en la hoja de cálculo que está importando, y asigna al campo del mismo nombre en Fintesk.\\n<!--  -->\\n\\n:::tip\\nNota: Ofrecemos hojas de cálculo de ejemplo con datos que puede usar para practicar el proceso de importación, que puede encontrar en esta página.\\n:::\\n","section":"Negocios-> qué son y cómo agregarlas","version":"current","path":"/es/kb/deals/deals-what-they-are-and-how-to-add-them#agregar-negocios-masivamente","category":"default"},{"title":"Detail view","content":"Haga clic en el icono lápiz a la derecha de su contacto vinculado en el resumen de la vista de detalle, luego elimine el contacto existente y escriba el nombre de su nuevo contacto.\\n\\nSi ese contacto no existe en su cuenta, verá la opción de Agregar [nuevo nombre de contacto] como nuevo contacto.”\\n\\nDespués de eso, presione \\"Guardar\\" y una ventana se abrirá donde puede completar la información básica de su nuevo contacto.\\n\\nUna vez que haga clic en \\"Guardar\\" en la ventana de creador de contacto, el nuevo contacto se vinculará a su negocio.\\n","section":"Editar el contacto vinculado a un negocio","version":"current","path":"/es/kb/deals/editing-the-contact-linked-to-a-deal#detail-view","category":"default"},{"title":"Vista de lista","content":"Desde la vista de la lista de negocios, puede cambiar un contacto vinculado al pasar sobre él y hacer clic en el icono lápiz.\\n\\nLuego elimine el contacto existente y escriba el nombre del nuevo. Si no existe, puede agregarlo como un nuevo contacto.\\n\\nDespués de elegir su nuevo contacto, haga clic en \\"Guardar\\".\\n\\n","section":"Editar el contacto vinculado a un negocio","version":"current","path":"/es/kb/deals/editing-the-contact-linked-to-a-deal#vista-de-lista","category":"default"},{"title":"Vista de detalle","content":"Haga clic en el icono lápiz junto a su contacto vinculado, elimine el contacto existente y escriba el deseado.\\n\\nComenzando a partir de dos letras, verá un menú desplegable de opciones que mejor coincidan con lo que ha escrito. Cuando vea el contacto que desea, haga clic en él y \\"Guardar\\".\\n\\n","section":"Editar el contacto vinculado a un negocio","version":"current","path":"/es/kb/deals/editing-the-contact-linked-to-a-deal#vista-de-detalle","category":"default"},{"title":"Vista de lista (cambiando contacto)","content":"Desde la vista de la lista de negocios, puede cambiar un contacto vinculado al pasar sobre él y hacer clic en el icono lápiz.\\n\\nLuego escriba el nombre de su contacto preferido, y si ya existe en Fintesk, puede seleccionarlo en el menú desplegable.\\n\\nDespués de elegir su nuevo contacto, presione \\"Guardar\\".\\n\\n","section":"Editar el contacto vinculado a un negocio","version":"current","path":"/es/kb/deals/editing-the-contact-linked-to-a-deal#vista-de-lista-cambiando-contacto","category":"default"},{"title":"Renombrar un contacto","content":":::tip\\nNota: Para cambiar el nombre de un contacto, debe editar en los sectores de la barra lateral Persona u Organización, no la sección de resumen.\\n:::\\n<!-- To rename a linked contact, hover your cursor over the contact and click the pencil icon. -->\\nPara cambiar el nombre de un contacto vinculado, pase su cursor sobre el contacto y haga clic para ir a la vista de contacto de la persona.\\n\\n<!-- Then type in your desired changes, and select “Rename.” -->\\nHaga clic en el nombre, luego escriba los cambios deseados y seleccione Guardar”. Su contacto se actualizará en la vista de negocio también.\\n\\n","section":"Editar el contacto vinculado a un negocio","version":"current","path":"/es/kb/deals/editing-the-contact-linked-to-a-deal#renombrar-un-contacto","category":"default"},{"title":"Filtros predefinidos","content":"Puede seleccionar un filtro predefinido para negocios ganados, perdidos o eliminados haciendo clic en el desplegable del filtro en la esquina superior derecha y seleccionando el filtro deseado.\\n\\n<!--  -->\\nSi no puede encontrar estos filtros, puede crear otros nuevos con las mismas condiciones.\\n","section":"Filtrado para mis negocios ganados, perdidos o eliminados","version":"current","path":"/es/kb/deals/filtering-for-my-won-lost-or-deleted-deals#filtros-predefinidos","category":"default"},{"title":"Agregar un nuevo filtro","content":"Para crear un filtro, vaya al menú desplegable del filtro y seleccione \\"Agregar nuevo filtro\\".\\n<!--  -->\\n\\nUse estas condiciones para ver todos sus negocios ganados, perdidos y eliminados:\\n<!--  -->\\n\\nO puede filtrar para una de esas condiciones a la vez:\\n<!--  -->\\n\\n\\n","section":"Filtrado para mis negocios ganados, perdidos o eliminados","version":"current","path":"/es/kb/deals/filtering-for-my-won-lost-or-deleted-deals#agregar-un-nuevo-filtro","category":"default"},{"title":"Filtrado en la vista de lista","content":"Dado que los filtros se comparten entre los embudos y las vistas de lista, los mismos filtros predefinidos y personalizados desde su vista de embudos están disponibles en la vista de lista.\\n<!--  -->\\n\\nSi desea los mismos resultados en la vista de lista que vio en su vista de embudos, especifique el embudo para el que desea ver los datos.\\n<!--  -->\\n\\n:::tip\\nNota: Para obtener más información sobre lo que puede lograr con el filtrado, consulte este artículo.\\n:::\\n","section":"Filtrado para mis negocios ganados, perdidos o eliminados","version":"current","path":"/es/kb/deals/filtering-for-my-won-lost-or-deleted-deals#filtrado-en-la-vista-de-lista","category":"default"},{"title":"¿Cómo puedo trasladar un negocio a otro embudo?","content":"<p>&lt;!-- ../../kb/deals/how-can-i-move-a-deal-to-another-pipeline.md --&gt;</p>\\n<p>Hay diferentes ubicaciones en Fintesk donde se puede trasladar un negocio a otro embudo.</p>\\n<p>&lt;!-- ## How can I move a deal to another pipeline? --&gt;</p>\\n<p>:::tip\\n<strong>Nota:</strong> Puede obtener más información sobre los negocios y la mejor manera de administrarlas en <a href=\\"../../kb/deals/deals-what-they-are-and-how-to-add-them\\">este artículo</a>.\\n:::</p>\\n<ul>\\n<li>\\n<p>Vista de embudo\\n<img src=\\"../../kb/deals/how-can-i-move-a-deal-to-another-pipeline/m01.gif\\" alt=\\"m01\\">\\n&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screen%20Capture%20on%202023-05-04%20at%2011-24-39.gif\\" alt=\\"1\\"> --&gt;</p>\\n</li>\\n<li>\\n<p>Vista de lista, agregando previamente la columna <strong>Etapa</strong>, luego seleccione la etapa que pertenece al embudo deseado donde desea ponerlo.\\n&lt;!-- - List view (by selecting at least one deal, then using the <a href=\\"../../kb/list-view/bulk-editing-and-filtering\\">bulk edit</a> tool.) --&gt;\\n<img src=\\"../../kb/deals/how-can-i-move-a-deal-to-another-pipeline/m02.gif\\" alt=\\"m02\\">\\n&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/move%20deal%201.jpg\\" alt=\\"1\\"> --&gt;</p>\\n</li>\\n</ul>\\n<p>&lt;!-- - Detail view</p>\\n<p><img src=\\"https://kb-cms.pipedriveassets.com/Screen%20Capture%20on%202023-05-04%20at%2011-40-50.gif\\" alt=\\"1\\"> --&gt;</p>\\n<p>&lt;!-- :::tip\\n<strong>Note:</strong> When you move a deal to another pipeline, it no longer shows up in reports for the previous pipeline.\\n::: --&gt;</p>\\n","section":"¿Cómo puedo trasladar un negocio a otro embudo?","version":"current","path":"/es/kb/deals/how-can-i-move-a-deal-to-another-pipeline","category":"default"},{"title":"Restoring leads in bulk","content":"If you\'d like to restore more than one deleted deal, we suggest first filtering to find deleted deals in your Fintesk account.\\n\\nWhen done, use the bulk edit functionality to select all of the deals you would like to restore. In the bulk edit panel that appears, find the \\"Status\\" field, select \\"Edit current value...\\" and then select \\"Open\\".\\n\\nClick the \\"Edit deals\\" button to save these status changes. -->\\n","section":"¿Cómo puedo restaurar los negocios eliminados?","version":"current","path":"/es/kb/deals/how-can-i-restore-deleted-deals#restoring-leads-in-bulk","category":"default"},{"title":"Vista de detalle de negocio","content":"En la vista de detalle de negocio, puede encontrar información sobre ese negocio, incluido el estado del negocio y cualquier contacto vinculado.\\n<!--  -->\\n\\n","section":"Vista de detalle de Negocio","version":"current","path":"/es/kb/detail-view/deal-detail-view#vista-de-detalle-de-negocio","category":"default"},{"title":"Barra de progreso","content":"\\nEn la vista de detalle de negocio, encontrarás el barra de progreso de negocio, mostrando en qué etapa de embudo se encuentra actualmente el negocio.\\n<!-- and the number of days it took to complete each stage. -->\\n\\n<!--  -->\\nLa barra de progreso del negocio le permitirá comprender el progreso de su negocio y proporcionar una idea de cuál de sus etapas puede requerir más atención.\\n<!-- Learn more about deal management -->\\n\\n","section":"Vista de detalle de Negocio","version":"current","path":"/es/kb/detail-view/deal-detail-view#barra-de-progreso","category":"default"},{"title":"Barra lateral","content":"La barra lateral en la vista de detalle presenta la información que ha agregado a su negocio.\\n<!-- If you are using multiple Marketplace apps in your workflow, our App Panels feature allows you to add specific apps to the sidebar. -->\\n","section":"Vista de detalle de Negocio","version":"current","path":"/es/kb/detail-view/deal-detail-view#barra-lateral","category":"default"},{"title":"Resumen","content":"El resumen es la primera sección dentro de la barra lateral y contiene los detalles centrales de sus negocios, como:\\nValor y productos\\nEtiquetas (próximamente)\\nProbabilidad (próximamente)\\nFecha esperada de cierre\\nLa persona de contacto\\nLa organización vinculada al negocio\\n<!--  -->\\nEl resumen siempre se muestra en la parte superior de la barra lateral.\\n\\n","section":"Vista de detalle de Negocio","version":"current","path":"/es/kb/detail-view/deal-detail-view#resumen","category":"default"},{"title":"Registro de cambios","content":"Cuando en la vista de detalle del negocio, puedes hacer clic en el registro de cambios función para ver cualquier cambio realizado en ese elemento, ordenado por fecha.\\n<!--  -->\\nEstos cambios también incluirán cambios de etapa, valor, etiqueta y actualizaciones de contacto, así como cambios en la fecha esperada de cierre y las actualizaciones de campo predeterminadas y personalizadas.\\n\\n","section":"Vista de detalle de Negocio","version":"current","path":"/es/kb/detail-view/deal-detail-view#registro-de-cambios","category":"default"},{"title":"Tarjetas flotantes","content":"Cuando pase el cursor sobre el nombre de contacto, el nombre de la organización o el usuario de Fintesk en la vista de detalle del negocio, verá una tarjeta flotante que contiene detalles relacionados con ese elemento.\\nPropietario del negocio\\n\\n<!--  -->\\n\\n\\nPersona\\n\\n<!--  -->\\n\\n\\nOrganización\\n<!--  -->\\n\\n<!-- ## History\\nThis section includes all the items that have been added and uploaded to the deal.\\nYou can navigate through the tabs to filter specific items like notes, activities, emails exchanged, files, etc.\\n-->\\n","section":"Vista de detalle de Negocio","version":"current","path":"/es/kb/detail-view/deal-detail-view#tarjetas-flotantes","category":"default"},{"title":"Vista de detalle de negocio","content":"En la Vista de detalle de negocio, verá aquella información específica sobre ese negocio, incluido el estado del negocio y cualquier contacto vinculado.\\n\\n<!--  -->\\nEn la Vista de detalle de un negocio, verá la barra de progreso de negocios, mostrándole en qué etapa de embudo se encuentra actualmente.\\n<!-- as well as how many days it has spent in each stage. -->\\n<!--  -->\\nLa barra de progreso del negocio le permitirá comprender el progreso de su negocio y proporcionar una idea de cuáles de sus etapas pueden necesitar más atención.\\n<!-- :::tip\\nNote: The deal detail view is currently being revamped. If you don\'t see this version in your account, you might want to check the new deal detail view in this article.\\n::: -->\\n\\n","section":"Vista de detalle","version":"current","path":"/es/kb/detail-view#vista-de-detalle-de-negocio","category":"default"},{"title":"Vista de detalles de contacto","content":"La vista de detalle de una persona muestra datos sobre esa persona, como la dirección de correo electrónico o el número de teléfono de esa persona.\\n<!-- It may also contain any contact label information provided about that customer. -->\\n\\n<!--  -->\\nLa vista de detalle de una organización muestra información específica para esa organización, como una dirección de calle, o cualquier información de campo personalizada que haya agregado a ese elemento en su cuenta.\\n<!-- It will also display the assigned contact label. -->\\n\\n<!--  -->\\n\\n","section":"Vista de detalle","version":"current","path":"/es/kb/detail-view#vista-de-detalles-de-contacto","category":"default"},{"title":"Registro de cambios","content":"Cuando en la vista de detalle de un elemento en Fintesk, puede hacer clic en la función \\"Registro de Cambios\\" para ver cualquier cambio realizado en ese elemento, ordenado por fecha. Estos cambios también incluirán actualizaciones realizadas en cualquier valor predeterminado o campos personalizados de ese elemento.\\n<!--  -->\\nPersonas – La información del registro de cambios se mostrará cuando ese contacto se agregó a Fintesk, qué negocios se han hecho en su nombre y a qué organización pueden estar vinculados.\\nOrganizaciones – verá cuándo se han agregado personas a su organización o cuándo se han vinculado los negocios con esta organización.\\n\\n","section":"Vista de detalle","version":"current","path":"/es/kb/detail-view#registro-de-cambios","category":"default"},{"title":"Tarjetas flotantes","content":"Cuando se pase sobre el nombre de un negocio, o el nombre de contacto, o el nombre de la organización o el usuario de Fintesk en la vista de detalle, verá una tarjeta emergente que contiene detalles relacionados con ese elemento.\\nUsuario de Fintesk (como propietario del elemento, seguidor o participante)\\n\\n<!--  -->\\n\\n\\nOrganización\\n\\n<!--  -->\\n\\n\\nPersona\\n\\n<!--  -->\\n","section":"Vista de detalle","version":"current","path":"/es/kb/detail-view#tarjetas-flotantes","category":"default"},{"title":"Agregar una nota","content":":::tip\\nNota: Cada tamaño de la nota puede ser 100 kb máximo y puede tener hasta 3 notas por negocio (en el plan gratuito, el limite varia dependiendo del plan), persona u organización. Si una nota excede el tamaño de 100 kb, puede dividir la nota en múltiples notas.\\n:::\\nPara agregar una nota a un elemento, vaya a la vista de detalle y haga clic en ”Notas“ en la esquina superior derecha.\\n<!--  -->\\n\\nLas características básicas de texto se pueden encontrar en la parte inferior de la ventana e incluye:\\nNegrita\\nSubrayado\\nEn cursiva\\nListado\\nListado de números\\nSangría (izquierda o derecha)\\nTambién puede hacer clic en el botón enlace para incrustar un enlace en el texto en su nota.\\n<!--  -->\\n\\n:::tip\\nNota: Texto que tiene un enlace incrustado con apariencia azul, y puede hacer clic en las palabras para abrir el enlace.\\n:::\\n\\n<!-- ## Additional notes features\\n:::tip\\nNota: Additional notes features are not available for activities.\\n:::\\nOn top of the basic editing features for notes, you can also add images and @mention other users in your account.\\nTo add an image to your note, click the image icon and select the desired picture.\\n\\nYou can also use the “@“ symbol to mention another user. Users mentioned receive a notification and they can leave comments on the note.\\n\\nWhen you’ve finished editing your note, click ”Save.“\\n:::tip\\nNota: When using the mentions feature, you can either click the ”@“ symbol or use the at key on your keyboard.\\n::: -->\\n\\n","section":"¿Cómo puedo agregar notas?","version":"current","path":"/es/kb/detail-view/how-can-i-add-notes-to-a-deal-or-contact#agregar-una-nota","category":"default"},{"title":"Guardar y buscar la nota","content":"Una vez que haya guardado la nota, se agregará debajo de la sección COMPLETADO de su vista de detalle.\\n<!--  -->\\n\\nHaga clic en el \\"...\\" para editar, fijar o eliminar la nota. Cuando se fija una nota, permanece en la parte superior de la vista de detalle, pero aún se puede encontrar en COMPLETADO.\\n<!--  -->\\n\\n<!-- You can also search for keywords from your note to find the linked item.\\n-->\\n","section":"¿Cómo puedo agregar notas?","version":"current","path":"/es/kb/detail-view/how-can-i-add-notes-to-a-deal-or-contact#guardar-y-buscar-la-nota","category":"default"},{"title":"Cambiar el nombre de un elemento","content":"Cuando esté en la vista de detalles del contacto o el negocio en Fintesk, haga clic en el nombre para comenzar a editar. Una vez que haya agregado el nuevo nombre, haga clic en \\"Guardar\\" para actualizar su artículo.\\n<!--  -->\\n\\n","section":"Actualización de elementos en la vista de detalle","version":"current","path":"/es/kb/detail-view/updating-items-in-the-detail-view#cambiar-el-nombre-de-un-elemento","category":"default"},{"title":"Actualización de campos predeterminados y personalizados","content":"Cualquier valor predeterminado o campos personalizados también se puede actualizar en la vista de detalle haciendo clic en el icono del lápiz o pasando el puntero sobre el campo que desea actualizar.\\n<!--  -->\\n\\n<!-- You can manage your detail view sidebar to have more control over the information displayed. -->\\n","section":"Actualización de elementos en la vista de detalle","version":"current","path":"/es/kb/detail-view/updating-items-in-the-detail-view#actualización-de-campos-predeterminados-y-personalizados","category":"default"},{"title":"Cambiar el valor de un negocio","content":"Cuando en la Vista de detalle del negocio, haga clic en el valor para comenzar a editar. Una vez que se agrega su nuevo valor, haga clic en \\"Guardar\\" para que se actualice el valor.\\n<!--  -->\\n\\nSi el negocio tiene productos agregados, deberá ajustar la cantidad de productos y el valor se calculará automáticamente.\\n\\n","section":"Actualización de elementos en la vista de detalle","version":"current","path":"/es/kb/detail-view/updating-items-in-the-detail-view#cambiar-el-valor-de-un-negocio","category":"default"},{"title":"Eliminar y restaurar elementos","content":":::tip\\nNota: Solo los usuarios administrativos tienen la capacidad de eliminar o restaurar contactos en Fintesk.\\n:::\\nPor defecto, solo los usuarios administrativos en Fintesk pueden eliminar negocios. Si no ve la opción de eliminar un negocio, recomendamos comunicarse con el usuario administrador en su cuenta para habilitar esto.\\n<!-- permission. -->\\nSi tiene permiso para eliminar negocios en la cuenta, puede hacerlo haciendo clic en el botón \\"...\\" y seleccionando la opción \\"Eliminar\\" en el menú desplegable.\\n<!--  -->\\n\\nSi desea restaurar un negocio eliminado, simplemente haga clic en \\"reabrir\\".\\n<!--  -->\\n\\nSi desea restaurar un contacto eliminado, haga clic en el botón \\"...\\" y seleccione la opción \\"Restaurar\\".\\n<!--  -->\\n\\nSi recibe el mensaje de error \\"Este elemento no se pudo actualizar\\" Al editar datos en su cuenta, el elemento puede haberse eliminado. Deberá restaurar este elemento para actualizarlo.\\n\\n<!--\\n","section":"Actualización de elementos en la vista de detalle","version":"current","path":"/es/kb/detail-view/updating-items-in-the-detail-view#eliminar-y-restaurar-elementos","category":"default"},{"title":"Merging items in the detail view","content":"Admin users have the ability to merge deals or contacts in Fintesk by default. If you do not see the option to merge an item, we would recommend reaching out to the admin user in your account to enable this permission.\\nIf you have permission to merge items in Fintesk, you can do so by clicking the ”...” button and selecting ”Merge” option from the dropdown menu.\\n\\nYou will be prompted to search for the item you would like to merge with. After selecting the item, you will have the option to select one set of values to preserve in the case of conflict.\\nYou can then preview your merged item to complete the process.\\n\\nIf you have multiple duplicate items in your account that you would like to merge, you learn about our merge duplicates feature. -->\\n","section":"Actualización de elementos en la vista de detalle","version":"current","path":"/es/kb/detail-view/updating-items-in-the-detail-view#merging-items-in-the-detail-view","category":"default"},{"title":"Exporting from the detail view","content":"Note: Only deals can be exported from the detail view.\\nGo to a deal’s detail view and click on the “...” (more) icon > Export as XLS in the top right corner. The spreadsheet will include deal details and any linked person or organization data.\\n-->\\n\\n","section":"Exportar desde la vista de detalle","version":"current","path":"/es/kb/exporting-data/exporting-data-from-fintesk#exporting-from-the-detail-view","category":"default"},{"title":"Exportar desde la vista de lista","content":":::tip\\nNota: Solo los administradores globales y los usuarios regulares con el conjunto de permiso correcto habilitado pueden exportar desde la vista de lista o las vistas de detalles.\\n:::\\nPuede exportar informes personalizados sobre sus negocios, organizaciones u otros elementos en Fintesk desde Vista de lista. Primero, vaya a la vista de lista de un elemento y filtre para los datos específicos que desea exportar.\\nPor ejemplo, para exportar negocios perdidos, seleccione el filtro \\"Todos los negocios perdidos\\" para solo exportar negocios que se ajusten a los criterios.\\n<!--  -->\\n\\nUna vez que tenga el filtro, seleccione los campos de datos que desea exportar editando sus columnas en la vista de lista. Puede elegir entre los campos de negocios, persona y organización, mezclar y coincidir datos de los tres para obtener su combinación perfecta.\\n<!--  -->\\n\\nLuego haga clic en los tres puntos en la parte superior derecha de la pantalla y seleccione \\"Exportar resultados del filtro\\".\\n<!--  -->\\n\\n\\n<!--\\n","section":"Exportar desde la vista de detalle","version":"current","path":"/es/kb/exporting-data/exporting-data-from-fintesk#exportar-desde-la-vista-de-lista","category":"default"},{"title":"Exporting from “Export data”","content":"Note: Only full admin users (deals and global) have the ability to use the Export data option.\\nYou can also export your data by going to Tools and apps > Export data.\\n\\nSelect the type of data you want to export and click on either “**CSV“** or “**Excel**”. Your export file will appear in the “**Generated exports“** list. To download the file, click on the cloud icon in the “**Available until**“ column.\\n\\nNote: Activities, notes and files linked to deals and contacts must be exported separately.\\nNote: Files stored in Google Drive are not exported in global export, and the download URL of the file can only be used by admin users.\\n\\n","section":"Exportar desde la vista de detalle","version":"current","path":"/es/kb/exporting-data/exporting-data-from-fintesk#exporting-from-export-data","category":"default"},{"title":"Exporting from Insights","content":"There are two ways you can export data from your Insights tool.\\n","section":"Exportar desde la vista de detalle","version":"current","path":"/es/kb/exporting-data/exporting-data-from-fintesk#exporting-from-insights","category":"default"},{"title":"Exporting charts","content":"To export a report, goal, or dashboard, click the “Export” dropdown in the top right corner, and select one of the available file types:\\n\\nThis will give you a file containing the charts, title and any filters applied.\\n","section":"Exportar desde la vista de detalle","version":"current","path":"/es/kb/exporting-data/exporting-data-from-fintesk#exporting-charts","category":"default"},{"title":"Exporting to spreadsheets","content":"You can export the table view of your report as a spreadsheet by clicking the “Export” button above the table.\\n\\n\\n","section":"Exportar desde la vista de detalle","version":"current","path":"/es/kb/exporting-data/exporting-data-from-fintesk#exporting-to-spreadsheets","category":"default"},{"title":"Exporting from “Users and access”","content":"Note: Only users with \\"account settings access\\" can export the company user list from the “Users and access” tab.\\nYou can export users’ app access data by going to Manage users > Users and access.\\nThis data includes:\\nUser name\\nEmail\\nLast login time\\nPermission sets\\nVisibility groups\\n-->\\n","section":"Exportar desde la vista de detalle","version":"current","path":"/es/kb/exporting-data/exporting-data-from-fintesk#exporting-from-users-and-access","category":"default"},{"title":"Creando un filtro","content":"Puede encontrar el botón \\"+ Agregar nuevo filtro\\" haciendo clic en el menú desplegable del filtro en la esquina superior derecha de su:\\nVista de lista de negocios\\nVista de lista de contactos (persona u organización)\\nVista de la lista de actividades\\nVista de la lista de productos\\n<!--  -->\\n\\nCuando agrega un nuevo filtro, verá una ventana donde puede hacer clic en \\"Agregar condición\\" para seleccionar sus criterios de filtro:\\n<!--  -->\\n\\nTambién puede agregar un nombre de filtro o definir la visibilidad para el conjunto de filtros, luego haga clic en \\"Guardar\\" cuando haya terminado, para mostrar los resultados del filtro.\\n\\n","section":"Filtrando","version":"current","path":"/es/kb/filtering#creando-un-filtro","category":"default"},{"title":"Condiciones de filtro","content":":::tip\\nNota: Para obtener más ejemplos de cómo puede usar la herramienta de filtro, consulte este artículo.\\n:::\\nHay dos tipos de condiciones de filtro que puede agregar: TODOS y CUALQUIERA\\nCada condición TODOS debe cumplirse o no se mostrará un elemento en los resultados de su filtro\\nAl menos una condición CUALQUIERA se debe cumplir, junto con las condiciones TODOS\\nPor ejemplo, en este primer filtro, hay dos condiciones competitivas en la sección de condiciones TODOS:\\n<!--  -->\\n\\nComo una persona no puede tener dos propietarios, esto no producirá resultados de filtro.\\n<!--  -->\\n\\nPero si mueves esas mismas condiciones a la sección CUALQUIERA:\\n<!--  -->\\n\\nSus resultados consistirán en personas propiedad de cualquiera de esos usuarios.\\n<!--  -->\\n\\n:::tip\\nNota: Si bien el número máximo de condiciones del filtro es 16, recomendamos usar hasta nueve condiciones para mantener una velocidad de carga óptima.\\n:::\\n\\n","section":"Filtrando","version":"current","path":"/es/kb/filtering#condiciones-de-filtro","category":"default"},{"title":"Limpiar y eliminar filtros","content":":::tip\\nNota: \\"Todos\\" se refieren a los propietarios, lo que significa que los elementos propiedad de cada usuario serán visibles.\\n:::\\nPara borrar los filtros existentes, haga clic en el menú desplegable de filtros y cambie a Propietarios > Todos:\\n<!--  -->\\n\\nPara eliminar un filtro, haga clic en el ícono lápiz al pasar sobre el filtro, luego seleccione la opción \\"Borrar\\":\\n<!--  -->\\n\\n","section":"Filtrando","version":"current","path":"/es/kb/filtering#limpiar-y-eliminar-filtros","category":"default"},{"title":"Ver solamente negocios ganados y perdidos","content":"\\n<!--  -->\\nPara ver negocios ganados y perdidas, asegúrese de usar condiciones CUALQUIERA, en vez de condiciones TODAS. Agregar ambas condiciones a la sección TODAS producirá cero resultados, ya que un negocio no se puede ganar y perder al mismo tiempo.\\n\\n<!-- ## See deals created before this month\\n\\nThis filter will show you any deal created prior to the current month. This means the filter results will change as time passes, since \\"this month\\" is a relative time selection.\\n\\n","section":"Filtros-> Usos comunes","version":"current","path":"/es/kb/filtering/filters-common-uses#ver-solamente-negocios-ganados-y-perdidos","category":"default"},{"title":"See contacts with linked deals","content":"\\nThere are two important things to note about this filter:\\nThis filter is being run for organizations, however you can run an identical filter for persons as well\\nThis filter only applies to open deals, meaning additional conditions would be needed to see won, lost, or deleted deals\\n\\n","section":"Filtros-> Usos comunes","version":"current","path":"/es/kb/filtering/filters-common-uses#see-contacts-with-linked-deals","category":"default"},{"title":"Filter for rotten deals","content":"Knowing which deals are rotten can help you keep your pipelines productive. To filter for rotten deals, use these conditions:\\n-->\\n\\n<!-- ## Filter by a specific label\\n\\nOne vital thing to remember is that deals, and contacts all have their own dedicated labels. However, you can still filter for other labels, even if you are not in that item\'s list. For example:\\n\\nIn this case, the filter is for organizations with a deal containing the specified deal label. -->\\n\\n<!-- ## See contacts with open deals\\n\\nThis filter will show any organization in your database with at least one open deal linked to it. While the above filter doesn\'t show won and lost deals, they can be included as well:\\n\\n:::tip\\nNote: Selecting the CUALQUIERA section means only one of the conditions must be met in order for the organization to be shown as a filter result.\\n::: -->\\n\\n","section":"Filtros-> Usos comunes","version":"current","path":"/es/kb/filtering/filters-common-uses#filter-for-rotten-deals","category":"default"},{"title":"Ver personas con una dirección de correo electrónico","content":"\\n<!--  -->\\nEste filtro le mostrará cualquier persona en su cuenta con un valor agregado al campo Correo electrónico.\\n<!-- If you would like to see persons with emails sent, you can use this filter:\\n\\n -->\\n","section":"Filtros-> Usos comunes","version":"current","path":"/es/kb/filtering/filters-common-uses#ver-personas-con-una-dirección-de-correo-electrónico","category":"default"},{"title":"# {#}","content":"2FA – Un requisito de inicio de sesión adicional (aparte del nombre de usuario/contraseña) diseñado para agregar una capa adicional de seguridad de la cuenta.\\n\\n","section":"Glosario de Fintesk","version":"current","path":"/es/kb/getting-started/fintesk-glossary#undefined","category":"default"},{"title":"A","content":"Actividades – Representar cualquier acción programada de su parte hacia el cierre (ganador) de un negocio. Puede programarlos con sus personas, organizaciones o negocios (por ejemplo, reunión, tarea, etc.).\\n\\nLos campos de actividad destacables incluyen:\\n\\nÚltima fecha de actividad – Esto le mostrará la fecha de la última actividad que se marcó como realizada.\\nPróxima fecha de actividad – Esto le mostrará la fecha de la próxima actividad que programó, pero esta aún no está marcado como realizada.\\nFecha de actualización – La fecha de la última actualización realizada en el elemento, podría ser una nueva actividad creada, un campo que se actualizó, básicamente cualquier cambio.\\n<!-- However, a user can be made an admin without account settings (via user management). -->\\nAtrasada – Se utiliza para actividades que tienen su fecha de finalización establecida para cualquier momento en el pasado y que aún no se han marcado como se han completado.\\nAPI – Abreviatura de \\"Interfaz de programación de aplicaciones\\". API puede conectar otras herramientas y servicios a su cuenta de Fintesk; Sin embargo, requiere conocimiento técnico.\\nAPI token – Representa un identificador único, lo que permite el acceso a los servicios de API.\\n<!-- - Attendee – One or more contact who have received and accepted invitations to a meeting (e.g., Scheduler attendees) -->\\nAutomatización – Utiliza un disparador y una acción para realizar tareas de fondo sin que el usuario tenga que implementarlos directamente. (Ej. Crea un negocio> Agregar una etiqueta).\\nAlmacenamiento en la nube – Cuando los datos se almacenan digitalmente a través de un proveedor de almacenamiento en línea de dos partes (por ejemplo, Google Drive).\\n\\n","section":"Glosario de Fintesk","version":"current","path":"/es/kb/getting-started/fintesk-glossary#a","category":"default"},{"title":"B","content":"<!-- :::info [Cooming soon]\\nBcc – Stands for Blind Carbon Copy. When you place email addresses in the Bcc field of a message, those addresses are invisible to the recipients of the email. Can be used to forward emails to other recipients without making the original recipient aware.\\n::: -->\\nBeta – Se refiere a una fase de prueba antes del lanzamiento público, donde se lanza una característica a un número limitado de usuarios con el fin de ver cómo funciona la función y evaluar si se necesitan más ajustes.\\nBase de conocimiento – El lugar donde mantenemos todos nuestros artículos de ayuda, pertenece bajo la categoría del centro de ayuda.\\nB2B – Representa “Business-to-business” y se refiere a transacciones o negocios realizados entre empresas, en lugar de entre una empresa y un consumidor individual.\\n\\n","section":"Glosario de Fintesk","version":"current","path":"/es/kb/getting-started/fintesk-glossary#b","category":"default"},{"title":"C","content":"Campo – Consulte \\"Campo de datos\\"\\nCampo de datos – Se refiere tanto a los campos predeterminados/del sistema como a los campos personalizados en Fintesk. En la mayoría de los casos, puede consultar los campos de datos como solo \\"campos\\".\\nConsola del navegador – Registra accesos en la red, JavaScript, CSS, así como errores de seguridad, advertencias y mensajes registrados explícitamente por el código JavaScript. Nuestros agentes de soporte pueden solicitar al diagnosticar la lentitud o los mensajes de error.\\nCuenta - Empresas con al menos un negocio ganado.\\nConfiguraciones de la cuenta – Se refiere a la facturación, seguridad, configuración y gestión de usuarios de la empresa. El acceso a esta configuración viene con una cuenta de administración, sin embargo, este acceso también se puede eliminar a través de la administración de usuarios.\\nCerrada – El estado de una cuenta después del proceso de cancelación se ha completado y el tiempo restante en la factura pagada más recientemente aprobada.\\nCuenta de la empresa — la cuenta de la compañía es el conjunto de usuarios, donde se aplica la cobranza de la facturación. (e.g., Fabrizzio es un usuario en la empresa Fintesk)\\nContacto – Se refiere a una persona u organización en Fintesk.\\nCRM – representa “Gestión de la relación con el cliente”.\\nCampo personalizado – Un campo creado en Fintesk fuera de los campos predeterminados/del sistema preexistentes, que se puede utilizar para agregar y hacer seguimiento de datos. Hay una variedad de tipos de campo personalizados que se pueden usar.\\n<!-- , and if you’re on a Professional or Enterprise plan, these custom fields can be used for reporting. -->\\nCampo predeterminado – Los campos predeterminados están integrados en su cuenta de Fintesk cuando la crea y generalmente se usan para información básica del cliente como nombre, correo electrónico o número de teléfono.\\nCosto directo – Dentro del alcance de la función o característica de productos, el costo directo se refiere al precio del desarrollo o la producción del producto registrado en cuestión.\\nCompletada – Significa que se ha completado una actividad. Es uno de los dos estados posibles para una actividad, el otro es \\"a realizar\\".\\nCódigo de producto – Se refiere al código opcional especificado por el usuario, dado a cualquier producto registrado utilizando la función de productos. Se utiliza para la clasificación y propósitos de la base de datos, pero no se asigna automáticamente cuando se crea un nuevo producto (diferente a nuestro ID de sistema).\\nCuenta de usuario — Una cuenta de usuario es donde un usuario individual inicia sesión y realiza tareas (por ejemplo, Pedro es un usuario en los Pascal company)\\n\\n","section":"Glosario de Fintesk","version":"current","path":"/es/kb/getting-started/fintesk-glossary#c","category":"default"},{"title":"D","content":"\\n","section":"Glosario de Fintesk","version":"current","path":"/es/kb/getting-started/fintesk-glossary#d","category":"default"},{"title":"E","content":":::info [Próximamente]\\nEtiqueta – Etiquetas predefinidas y personalizables que se pueden conectar a varios elementos de Fintesk, ya sea manual o automáticamente. Las etiquetas permiten un reconocimiento visual y textual rápido del estado o tipo de elemento y también permiten una mejor clasificación.\\n:::\\nExportar – Copiar datos fuera de su cuenta de Fintesk (ya sea en una hoja de cálculo o en otro programa como Mailchimp).\\n\\n","section":"Glosario de Fintesk","version":"current","path":"/es/kb/getting-started/fintesk-glossary#e","category":"default"},{"title":"F","content":"Facturación – La sección de una cuenta donde puede ver la información de suscripción actual como el costo y la frecuencia de facturación, así como las facturas anteriores.También puede encontrar información sobre cómo cerrar su cuenta o comprar complementos allí.\\nFormato de archivo – Formato de archivo específico, basado en la extensión del archivo. Por ejemplo, CSV, GIF, ZIP.\\nFutura – Se utiliza para clasificar las actividades que tienen sus fechas establecidas en cualquier momento en el futuro.\\n\\n<!-- ### G -->\\n<!-- :::info [Cooming soon]\\nGroup email – An email message that is being sent to multiple email addresses at the same time. Fintesk will apply a small delay between each message in order to prevent errors and to prevent abuse scenarios.\\n::: -->\\n<!-- - Guest – see \\"Attendee\\". -->\\n\\n<!-- ### H -->\\n<!-- - HAR file – The HTTP Archive format, or HAR, is a file that tracks all interactions between a web browser and a website. -->\\n\\n","section":"Glosario de Fintesk","version":"current","path":"/es/kb/getting-started/fintesk-glossary#f","category":"default"},{"title":"I","content":"<!-- :::info [Cooming soon]\\nImportant fields – Important fields are given additional attention and brought into focus for the user. By definition, important fields are intended to be filled as a higher priority but are not required unless specified. Both default and custom fields can be marked as important.\\n::: -->\\n\\n\\nInválida – Se usa para indicar que un archivo u otro elemento está de alguna manera roto o incorrecto. Por ejemplo, una contraseña puede ser inválida, un archivo cargado puede ser inutilizable porque no es válido (corrupto), etc.\\n\\n\\nInvitar – En referencia a los usuarios, un correo electrónico enviado a la dirección de correo electrónico de un posible usuario, que les ofrece un asiento para ocupar en una cuenta de Fintesk.\\n\\n","section":"Glosario de Fintesk","version":"current","path":"/es/kb/getting-started/fintesk-glossary#i","category":"default"},{"title":"K","content":"\\n","section":"Glosario de Fintesk","version":"current","path":"/es/kb/getting-started/fintesk-glossary#k","category":"default"},{"title":"L","content":"Llamar (actividad) – Un tipo de actividad utilizado como marcador para una llamada programada.\\nLímite – Hay un número limitado de elementos (contables) que puede tener a la vez. Pero el límite solo considera el recuento actual de algo, por lo que eliminar los elementos le dará más espacio hasta alcanzar el límite (es decir, límites de uso)\\nLímites de uso — Límites en la cantidad de negocios abiertos, campos personalizados, etc. que puede crear un usuario. Los límites se basan en su plan existente, y puede encontrar más información sobre eso aquí.\\n\\n","section":"Glosario de Fintesk","version":"current","path":"/es/kb/getting-started/fintesk-glossary#l","category":"default"},{"title":"M","content":"Migración de datos – El movimiento de datos en una nueva base de datos sin una sincronización continua (por ej, importaciones de hoja de cálculo).\\n\\n","section":"Glosario de Fintesk","version":"current","path":"/es/kb/getting-started/fintesk-glossary#m","category":"default"},{"title":"N","content":"Negocio - En Fintesk, la transacción en curso que está realizando con una persona u organización se debe hacer seguimiento como un negocio, que se procesa a través de las etapas de su embudo hasta que se encuentre ganado o perdido.\\nNotas – Texto agregado a una vista de detalle, que se presenta en la parte superior para fines de visibilidad.\\n<!-- - No se pueden agregar notas a través de la automatización -->\\n<!-- , however, they can be added in bulk via import. -->\\n\\n","section":"Glosario de Fintesk","version":"current","path":"/es/kb/getting-started/fintesk-glossary#n","category":"default"},{"title":"O","content":"Organización – Un contacto que representa una organización de la vida real, negocios o de otro tipo. Se puede utilizar para unir a varias personas bajo una organización compartida (ver vinculación de personas y organizaciones).\\nOrganizaciones relacionadas - Cuando dos o más organizaciones están vinculadas entre sí\\n<!-- Deals with overdue activities will be sorted toward the top of the pipeline view (more information in this article). -->\\n\\n","section":"Glosario de Fintesk","version":"current","path":"/es/kb/getting-started/fintesk-glossary#o","category":"default"},{"title":"P","content":"Programada – Esta palabra se usa dentro del contexto de actividades para cualquier actividad que se le haya asignado una fecha y hora de finalización.\\nPor Completar – Uno de los dos estados posibles para una actividad (el otro es \\"Completada.\\") Este estado significa que la actividad aún no se ha completado.\\n<!-- - Permitted – When an email address falls within a list of approved IP addresses from which emails may be received through a provider (also called a whitelist). Email addresses can be permitted manually if emails being sent to or from you are being bounced due to security protocols. -->\\nPersona – Dentro del vocabulario de Fintesk, hace referencias a un contacto de persona, que es un conjunto registrado de datos que representa un contacto humano.\\nPlan – se refiere a su nivel de suscripción. Nuestros planes disponibles son: gratuito, esencial, avanzado y profesional.\\nPrecio unitario – Dentro del alcance de la característica de los productos, el precio unitario se refiere al precio exacto de cada unidad vendida.\\n\\n<!--\\n","section":"Glosario de Fintesk","version":"current","path":"/es/kb/getting-started/fintesk-glossary#p","category":"default"},{"title":"Q","content":"Quick help – Panel that opens in the app when the user clicks on the question mark in the upper right corner. -->\\n\\n","section":"Glosario de Fintesk","version":"current","path":"/es/kb/getting-started/fintesk-glossary#q","category":"default"},{"title":"R","content":"<!-- - Recurring payment – Refers to any payment that is intended to be repeated over the course of a schedule (usually based on a monthly or annual schedule). -->\\nReunión – Un tipo de actividad que el usuario puede programar utilizando la función de actividades. La reunión está destinada a representar una reunión física real entre el usuario y su cliente.\\n<!-- - Required field – A defined field attribute that marks either default or custom fields as required, meaning the field is not optional and must be given a value in order to store Fintesk objects. -->\\n\\n","section":"Glosario de Fintesk","version":"current","path":"/es/kb/getting-started/fintesk-glossary#r","category":"default"},{"title":"S","content":"Sincronización de ida – Una conexión de sincronización que transfiere datos de Una fuente de datos a otro.\\n\\n\\nSincronización bidireccional – Una conexión de sincronización que transfiere datos entre Dos fuentes de datos.\\n\\n\\nSaaS – abreviatura de \\"software as a service\\".\\n<!-- - May also be used for emails or campaigns. -->\\n<!-- - Single sign-on (SSO) – An account with SSO enabled means you only have to create one set of logins for your users. -->\\n\\n","section":"Glosario de Fintesk","version":"current","path":"/es/kb/getting-started/fintesk-glossary#s","category":"default"},{"title":"T","content":"Tipo de archivo – Propósito del archivo, que generalmente es un grupo de varios formatos de archivo (es decir, imágenes, audio, base de datos).\\n<!-- - Two-factor authentication – see \\"2FA\\" -->\\n\\n","section":"Glosario de Fintesk","version":"current","path":"/es/kb/getting-started/fintesk-glossary#t","category":"default"},{"title":"U","content":"Usuario administrador – Un usuario que tiene acceso completo a todas las herramientas, datos y características dentro de una cuenta de Fintesk dada.\\nUnidadad – Dentro del alcance de la función de productos, \\"Unidad\\" se refiere a la unidad predeterminada de un producto registrado. La unidad puede ser cualquier cosa, desde la cantidad de elementos, dimensiones de los artículos, etc. La unidad definida y el precio unitario en combinación forman la base del cálculo del valor al agregar productos a los negocios (es decir, 1 unidad a $ 5 cada uno, lo que significa agregar una unidad del producto a un negocio, le da al negocio un valor de $ 5).\\n\\n","section":"Glosario de Fintesk","version":"current","path":"/es/kb/getting-started/fintesk-glossary#u","category":"default"},{"title":"V","content":"Variación de precio – Cuando se cambia a \\"Activo\\", la variación de precios permite la adición de múltiples puntos de precio para un producto registrado en la base de datos. Esto es útil cuando se opera con múltiples monedas para el mismo producto o precio variable que quedan fuera de las unidades.\\n\\n","section":"Glosario de Fintesk","version":"current","path":"/es/kb/getting-started/fintesk-glossary#v","category":"default"},{"title":"Z","content":":::info [Próximamente]\\n<!-- - Zapier – One of the many services we offer integrations with, Zapier can be used to automate processes and actions between Fintesk and other services or tools. -->\\nZapier – Uno de los muchos servicios con los que ofrecemos integraciones, Zapier se puede utilizar para automatizar procesos y acciones entre Fintesk y otros servicios o herramientas.\\n:::\\n","section":"Glosario de Fintesk","version":"current","path":"/es/kb/getting-started/fintesk-glossary#z","category":"default"},{"title":"Usuario de Fintesk vs. Cuenta de la empresa","content":"<p>&lt;!-- ../../kb/getting-started/fintesk-user-vs-company-account.md --&gt;</p>\\n<p>&lt;!-- ## Fintesk user vs. company account --&gt;</p>\\n<p>Cuando se crea una cuenta de Fintesk, se crean una cuenta de usuario y una cuenta de la empresa.</p>\\n<p>La cuenta de usuario es un usuario específico, por ejemplo, Bombo Fica, que accede a Fintesk utilizando sus credenciales de inicio de sesión.</p>\\n<p>La cuenta de la compañía, por ejemplo, Cocoleruz.- Es la base de datos de información a la que los usuarios acceden dentro de Fintesk, y pueden contener muchos usuarios diferentes.</p>\\n","section":"Usuario de Fintesk vs. Cuenta de la empresa","version":"current","path":"/es/kb/getting-started/fintesk-user-vs-company-account","category":"default"},{"title":"¿Cómo puedo eliminar los elementos en Fintesk?","content":"<p>&lt;!-- ../../kb/getting-started/how-can-i-delete-items-in-fintesk.md --&gt;</p>\\n<p>&lt;!-- # Deleting items in Fintesk --&gt;</p>\\n<p>Dependiendo de la situación, es posible que deba eliminar elementos en Fintesk de muchas maneras diferentes. Hemos construido varios formas diferentes para eliminar elementos en Fintesk y ayudar a abordar cualquier situación.</p>\\n<p>Para eliminar de la <strong>Vista de Detalle</strong> de un elemento en Fintesk:</p>\\n<ul>\\n<li>Haga clic en el nombre del negocio, persona u organización para ir a la <strong>vista de detalle</strong> del elemento.</li>\\n<li>Haga clic en el&quot;<strong>...</strong>&quot; encontrado en la parte superior derecha de la aplicación Fintesk.</li>\\n<li>Seleccione el &quot;<strong>Borrar&quot;</strong> opción encontrada allí.</li>\\n<li>En el mensaje que aparece, confirme que desea eliminar este elemento.</li>\\n</ul>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202022-09-27%20at%2015.01.17.png\\" alt=\\"1\\"> --&gt;</p>\\n<p><img src=\\"../../kb/getting-started/how-can-i-delete-items-in-fintesk/hii01.jpeg\\" alt=\\"hii01\\"></p>\\n<p>Para eliminar un negocio de la pestaña <strong>Vista de embudo</strong> de sus negocios:</p>\\n<ul>\\n<li>Vaya a su pestaña de negocios y haga clic en la <strong>vista de embudo</strong>.</li>\\n<li>Haga clic en el negocio que desea eliminar y arrástrelo a la parte inferior de su pantalla en la aplicación Fintesk.</li>\\n<li>Al pasar sobre el botón <strong>Eliminar</strong>, suelte el clic del mouse.</li>\\n</ul>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/delete%20deals%20in%20pipeline.gif\\" alt=\\"1\\"> --&gt;</p>\\n<p><img src=\\"../../kb/getting-started/how-can-i-delete-items-in-fintesk/hii02.gif\\" alt=\\"hii02\\"></p>\\n<p>&lt;!--\\nTo delete a selection of items from the <strong>list view</strong>:</p>\\n<ul>\\n<li>Go to the Fintesk tab of the item(s) you wish to delete – such as deals, activities, persons, or organizations.</li>\\n<li>Using the checkboxes on the left side of the Fintesk app, select the items you wish to delete.</li>\\n<li>Click on the <strong>trash can</strong> icon that appears above the list view.</li>\\n<li>In the prompt that appears, confirm that you wish to delete those items.</li>\\n</ul>\\n<p><img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202022-09-27%20at%2015.04.11.png\\" alt=\\"1\\"></p>\\n<p>:::tip\\n<strong>Note:</strong> Deleting an item in Fintesk will delete other items linked to it (e.g., if a deal is deleted, activities linked to that deal will be deleted). Admins can restore deleted items within 30 days after deletion, the linked items will be restored as well. After 30 days the items are permanently deleted and cannot be accessed or restored.\\n::: --&gt;</p>\\n<p>&lt;!-- # Deleting items in Fintesk</p>\\n<p>:::tip\\n<strong>Note:</strong> This action is only available to users with the correct permissions enabled.\\n:::</p>\\n<p>Maintaining an effective Fintesk database can sometimes mean cleaning out data. However, we recognize that not every user should have the ability to delete potentially valuable information from your account.</p>\\n<p>To allow you to keep your data secure, the ability to delete in Fintesk is an option that can be enabled for certain user groups in <a href=\\"../../kb/users-and-permissions/permission-sets\\">permission sets</a>.</p>\\n<p>As a user with account settings, if you would like to adjust permissions regarding the deletion of deals or activities for certain users in your Fintesk account, you can do so by going to <strong>Settings &gt; Manage users &gt; <a href=\\"https://app.fintesk.com/settings/company_settings#permissions\\">Permission sets</a></strong> and adjusting those options to your preference.</p>\\n<p><img src=\\"https://kb-cms.pipedriveassets.com/Markup%20on%202022-09-27%20at%2014%3A55%3A47.png\\" alt=\\"1\\"></p>\\n<p>:::tip\\n<strong>Note:</strong> If you do not see an option to be able to delete a person or organization, you don\'t have admin settings. If you do not see the option to delete a deal or activity, then your admin user has not enabled this permission.\\n::: --&gt;</p>\\n<p>&lt;!-- --- --&gt;</p>\\n","section":"¿Cómo puedo eliminar los elementos en Fintesk?","version":"current","path":"/es/kb/getting-started/how-can-i-delete-items-in-fintesk","category":"default"},{"title":"Negocios","content":"\\n<!--  -->\\n\\nLas transacciones que se realizan diariamente con personas u organizaciones en Fintesk se hacen seguimiento como negocios, que se procesan a través de las etapas de su embudo hasta que lleguen a ganado o perdido.\\nLos negocios contienen todas las acciones tomadas para llegar a cerrar una venta. Los negocios también extraerán toda la información de la persona u organización con la que se asocian, que puede encontrar en la \\"vista de detalle\\" de ese negocio. En este artículo, puedes leer más sobre los negocios en Fintesk.\\nLos negocios se pueden vincular a una persona y organizaciones. También pueden tener productos asociados a ellos.\\nLos negocios registran todos los eventos y movimientos que tienen lugar a lo largo de su proceso de ventas.\\nDado que un negocio está conectado a un contacto, cualquier acción que realice en el negocio también se reflejará en la persona/organización vinculada a él.\\nLos negocios se pueden importar desde un archivo CSV o XLS.\\n<!-- - Deals can be imported from a previous CRM or a CSV or XLS file. -->\\n<!-- - The progress of the deals in your account is tracked as progress in your account. -->\\n\\n","section":"¿Cómo se organizan los datos de Fintesk?","version":"current","path":"/es#negocios","category":"default"},{"title":"Personas (contactos)","content":"<!--  -->\\n\\nPersonas (contactos) son los clientes específicos a los que está vendiendo, y cualquier información relacionada con cada contacto, como actividades o correos electrónicos programados, se registran en la Vista de detalles de esa persona.\\nLas personas se pueden vincular a una organización.\\nPueden tener múltiples negocios abiertos asociados a ellos al mismo tiempo.\\n<!-- - They can be synced with your contact provider or imported from a CSV or XLS file. -->\\nEllas pueden ser importadas de un archivo CSV o XLS.\\n<!-- imported from a previous CRM, -->\\n\\n","section":"¿Cómo se organizan los datos de Fintesk?","version":"current","path":"/es#personas-contactos","category":"default"},{"title":"Organizaciones (contactos)","content":"<!--  -->\\n\\nOrganizaciones son las empresas donde trabajan las personas. Todas las personas relacionadas con una organización se enumerarán en su vista de detalle, junto con cualquier Nota o actividades vinculadas a cualquier persona, negocios relacionados con la organización.\\nLas organizaciones contienen información como una dirección postal o información de la industria.\\nPuede vincular varias personas, negocios a sus organizaciones.\\n<!-- - Organizations can be synced with your contact provider, imported from a previous CRM, or imported from a CSV or XLS file. -->\\nLas organizaciones pueden ser importadas de un archivo CSV o XLS.\\n\\n","section":"¿Cómo se organizan los datos de Fintesk?","version":"current","path":"/es#organizaciones-contactos","category":"default"},{"title":"Actividades","content":"<!--  -->\\n\\nUna actividad representa cualquier acción tomada para cerrar una venta. Puede ser una llamada telefónica, una reunión de almuerzo o cualquier otro evento que programe con un contacto. Puede programar actividades en relación con una persona, organización, o negocio. Puedes leer este artículo para obtener más información sobre actividades en Fintesk.\\nLas actividades pueden estar vinculadas a una persona, organización, o negocio.\\nAsociar una actividad con un negocio también asociará la actividad con la persona y/u organización vinculada.\\n<!-- - Activities can be imported from a previous CRM or a CSV or XLS file. -->\\nLas actividades se pueden importar desde un archivo CSV o XLS.\\n","section":"¿Cómo se organizan los datos de Fintesk?","version":"current","path":"/es#actividades","category":"default"},{"title":"Productos","content":":::info\\nNota: Para obtener más información sobre las variaciones de precios, consulte este artículo.\\n:::\\n<!--  -->\\n\\nProductos son los artículos o servicios que vende o comercia, y a menudo están vinculados a negocios en curso. Los productos tienen campos específicos como Código de producto, Precio y Impuesto.\\n\\n","section":"¿Cómo se organizan los datos de Fintesk?","version":"current","path":"/es#productos","category":"default"},{"title":"Relaciones de datos","content":"Aquí hay un resumen básico de cómo se relacionan los diferentes tipos de datos.\\n<table>\\n<tr>\\n<td>Contactos</td>\\n<td>negocios/actividades</td>\\n<td>Los contactos son aquellos con quienes realiza negocios y programas actividades, así como envían correos electrónicos. Pueden representarse como contacto individual (por ej., Bombo Fica) o organizaciones colectivas (por ej., NOTco)</td>\\n</tr>\\n<tr>\\n<td>Actividades</td>\\n<td>negocios/contactos</td>\\n<td>Las actividades pueden vincularse a un negocio o contacto, pero no se requiere, ya que también se pueden crear sin estar vinculados a otros datos.</td>\\n</tr>\\n</table>\\n:::info\\nNota: Obtenga más información sobre los términos y relaciones de Fintesk en nuestro Glosario.\\n:::\\n","section":"¿Cómo se organizan los datos de Fintesk?","version":"current","path":"/es#relaciones-de-datos","category":"default"},{"title":"Navegando en Fintesk","content":"Al presionar las teclas numéricas asociadas con cada pestaña en la navegación primaria, lo traerá directamente a esa sección específica de Fintesk.\\n<!-- Hover over the tab in the primary navigation sidebar to see what number you should press to be taken straight to that page. -->\\n<!--  -->\\n\\n\\n","section":"Interfaz Fintesk","version":"current","path":"/es/kb/getting-started/interface-in-fintesk#navegando-en-fintesk","category":"default"},{"title":"Atajos de teclado","content":"You can use shortcuts to perform quick actions in Fintesk.\\n","section":"Interfaz Fintesk","version":"current","path":"/es/kb/getting-started/interface-in-fintesk#atajos-de-teclado","category":"default"},{"title":"General shortcuts","content":"<!-- | Action                                              | Shortcut |\\n| :------------------------------------------------------ | :----------- |\\n| Go to primary navigation item                           | 1 to 8   |\\n| Go to last primary menu item (“More” overflow menu) | 9          |\\n| Search Fintesk                                          | /          |\\n| Toggle secondary navigation                             | [ or ]   |\\n| Open quick add menu                                     | . or +   | -->\\nAcción\\nShortcut\\n\\n\\n\\n\\nAbra el menú de agregado rápido\\n.\\n","section":"Interfaz Fintesk","version":"current","path":"/es/kb/getting-started/interface-in-fintesk#general-shortcuts","category":"default"},{"title":"Add items shortcuts","content":"Para agregar un nuevo elemento, puede hacer clic en el signo + en la parte superior de la página, o haga clic en su botón de parada completa en su teclado (.).\\n<!-- or plus sign (+). -->\\n<!--  -->\\n\\nCada elemento en Fintesk tiene su propio atajo. Al presionar las teclas asociadas en la sección Menú rápido, abrirá inmediatamente el diálogo Agregar nuevo para el elemento previsto, que es útil para una gran cantidad de tareas, como agregar rápidamente una nota a un contacto que lo llama inesperadamente.\\nElemento\\nShortcut\\n\\n\\n\\n\\nNegocio\\nD\\n\\n\\nActividad\\nA\\n\\n\\nPersona\\nP\\n\\n\\nOrganización\\nO\\n\\n\\nProducto\\nR\\n<!-- | Note         | N          | -->\\n\\n<!--\\n","section":"Interfaz Fintesk","version":"current","path":"/es/kb/getting-started/interface-in-fintesk#add-items-shortcuts","category":"default"},{"title":"Customizing Fintesk","content":"To customize your Fintesk interface, go to Personal preferences > Interface preferences.\\n\\nHere you’ll be able to:\\nChange the appearance and select between light or dark mode for your Fintesk interface\\nEnable and disable the keyboard shortcuts\\nSet a default landing page\\nChoose up to ten icons to appear on the left navigation bar\\n\\n:::tip\\nNote: Customization settings are user-specific and not shared across the company.\\n::: -->\\n","section":"Interfaz Fintesk","version":"current","path":"/es/kb/getting-started/interface-in-fintesk#customizing-fintesk","category":"default"},{"title":"Organización vs. cuenta de la empresa","content":"<p>&lt;!-- ../../kb/getting-started/organization-vs-company-account.md --&gt;</p>\\n<p>&lt;!-- # Organization vs. company account --&gt;</p>\\n<p>Cuando se crea una cuenta de Fintesk, se crean una cuenta de usuario y la propia cuenta de la empresa.</p>\\n<p>Esa cuenta de la compañía es <strong>su</strong> empresa, y puede invitar a sus colegas de trabajo a unirse a usted como <a href=\\"../../kb/users-and-permissions/users\\">usuarios</a> para acceder a la misma base de datos.</p>\\n<p>Sin embargo, no tiene que crear una cuenta de compañía nueva para usar Fintesk. Si conoce a alguien que ya tiene una cuenta, puede invitarlo a unirse a su empresa.</p>\\n<p>&lt;!-- If you are invited, the access you have to data and account privileges will be decided by the company owner or other users with <strong><a href=\\"../../kb/users-and-permissions/global-user-management\\">User Management</a></strong> access. --&gt;</p>\\n<p>Si está invitado, el propietario de la compañía u otros usuarios decidirá el tipo de acceso al que y los privilegios de datos y de cuenta.</p>\\n<p>:::tip\\n<strong>Nota</strong>: Si no tiene acceso a <strong>Administración de usuarios</strong>, o no sabe qué tipo de usuario es, comuníquese con el administrador de su cuenta.\\n:::</p>\\n","section":"Organización vs. cuenta de la empresa","version":"current","path":"/es/kb/getting-started/organization-vs-company-account","category":"default"},{"title":"Buscando directamente por elemento","content":"Escriba una entrada en la barra de búsqueda para ver un menú desplegable de todos los elementos relevantes para su entrada de búsqueda. Puede filtrar por tipo de elemento para reducir sus resultados de búsqueda.\\n<!--  -->\\n\\nPuede buscar sus datos de Fintesk mediante los siguientes campos de datos:\\nNegocios\\nNombres, notas, campos personalizados\\nPersonas\\nNombre, número de teléfono, dirección de correo electrónico, notas y campos personalizados\\nOrganizaciones\\nNombre, dirección, notas y campos personalizados\\nActividades\\nNombre, notas, descripción\\nProductos\\nNombre, código y campos personalizados\\n<!-- - **Files and attachments\\n**Name -->\\n:::tip\\nNota: Los usuarios regulares solo pueden buscar sus propias actividades, mientras que los usuarios administrativos pueden buscar todas las actividades de los usuarios.\\n:::\\n\\n","section":"Encontrando lo que necesitas","version":"current","path":"/es/kb/getting-started/search-finding-what-you-need#buscando-directamente-por-elemento","category":"default"},{"title":"Buscando por elementos vinculados","content":"La búsqueda también traerá cualquier elemento vinculado a lo que buscó.\\nPor ejemplo, si su búsqueda coincide con un negocio, también verá a cualquier persona y organización vinculada a él.\\n<!--  -->\\n\\nSi su búsqueda coincide con una persona, verá cualquier negocio vinculado a ese elemento.\\n<!-- :::tip\\nNote: Users without a projects seat enabled can\'t search by projects or see the Projects category in the search options.\\n::: -->\\n\\n","section":"Encontrando lo que necesitas","version":"current","path":"/es/kb/getting-started/search-finding-what-you-need#buscando-por-elementos-vinculados","category":"default"},{"title":"Buscando campos personalizados","content":"Puedes buscar por valores dentro de los tipos: texto, texto largo, numérico, monetario, teléfonos y dirección de campos personalizados.\\nAl buscar el valor de campo personalizado, el elemento relevante aparecerá en los resultados de búsqueda.\\n<!--  -->\\n\\n\\n<!--\\n","section":"Encontrando lo que necesitas","version":"current","path":"/es/kb/getting-started/search-finding-what-you-need#buscando-campos-personalizados","category":"default"},{"title":"Searching by notes","content":"Keywords from your notes can be searched for if you\'ve written them under deals, contacts, leads or activities.\\nWhen searching for notes, the relevant item will appear in the search results.\\n-->\\n\\n","section":"Encontrando lo que necesitas","version":"current","path":"/es/kb/getting-started/search-finding-what-you-need#searching-by-notes","category":"default"},{"title":"Encontrando información","content":"La mayoría de los resultados de búsqueda tienen enlaces secundarios debajo de ellos.\\nPasando el ratón sobre un resultado muestra otra ventana con más información. Hacer clic en un elemento (negocio, persona u organización) lo lleva a la \\"vista de detalle\\" de ese elemento específico.\\nPor ejemplo: si hay un negocio que está conectado con una persona y organización, puede ver más información sobre los contactos vinculados al pasar el mouse sobre ellos.\\n<!--  -->\\n\\n\\n<!--\\n","section":"Encontrando lo que necesitas","version":"current","path":"/es/kb/getting-started/search-finding-what-you-need#encontrando-información","category":"default"},{"title":"Recent items in search","content":"Before you type in the search box, you can see your recently searched keywords and viewed items.\\n\\nRecent keywords are the keywords that you typed in the search bar.\\nRecently viewed items are items that you’ve just created, viewed or edited. -->\\n","section":"Encontrando lo que necesitas","version":"current","path":"/es/kb/getting-started/search-finding-what-you-need#recent-items-in-search","category":"default"},{"title":"¿Cuál es la diferencia entre un usuario y un asiento?","content":"<p>&lt;!-- ../../kb/getting-started/what-is-the-difference-between-a-user-and-a-seat.md --&gt;</p>\\n<p>&lt;!-- ## What is the difference between a user and a seat? --&gt;</p>\\n<p>En Fintesk, su suscripción se calcula por el número de <strong>asientos</strong> que tiene en su cuenta. Un <strong>usuario</strong> activo (o invitado) siempre tomará un asiento una vez que se hayan agregado a Fintesk, pero es posible tener asientos vacíos si los usuarios han sido desactivados o aún no han agregado.</p>\\n<p>Separamos usuarios y asientos en Fintesk para facilitar la desactivación y reemplazar a los usuarios sin crear cambios inmediatos en su suscripción.</p>\\n<ul>\\n<li><strong>Asiento –</strong> El número de posibles usuarios activos en su cuenta. Se le facturará por la cantidad de asientos que tiene. Se pueden quitar los asientos adicionales yendo a su <strong><a href=\\"https://app.fintesk.com/settings/company_settings#subscription\\">Pestaña de facturación</a></strong>.</li>\\n<li><strong>Usuario –</strong> Los usuarios que ha agregado a su cuenta Fintesk. Puede tener menos usuarios activos que asientos, pero aún se le cobrará por la cantidad de asientos en su cuenta. Puede administrar a sus usuarios yendo a <strong>Compañía&gt; <a href=\\"https://app.fintesk.com/settings/company/manage-users?utm_source=fintesk-docs\\">Administrar usuarios</a></strong>.</li>\\n</ul>\\n<p>Recomendamos completar los asientos gratuitos con los usuarios o eliminar los asientos no utilizados que no planea llenar para que no termine pagando por más de lo que usa.</p>\\n<p>:::tip\\n<strong>Nota:</strong> Todos los asientos agregados a su cuenta estarán en el plan que ya se está facturando.\\n:::</p>\\n<p><strong>¿Qué sucede con mi facturación cuando desactivo a un usuario?</strong></p>\\n<p>Cuando <a href=\\"../../kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user\\">desactiva</a> un usuario en la cuenta de su empresa, se le dará la opción de mantener o eliminar el asiento.</p>\\n<p>Si mantiene el asiento, puede reemplazar fácilmente al usuario desactivado con un nuevo usuario sin ninguna actualización de su facturación. Si elige eliminar el asiento, los cambios entrarán en vigencia en su suscripción al comienzo del próximo ciclo de facturación.</p>\\n<p>Obtenga más información sobre lo que le sucede a un usuario cuando está desactivado en <a href=\\"../../kb/users-and-permissions/what-happens-when-a-user-gets-deactivated\\">este artículo</a>.</p>\\n","section":"¿Cuál es la diferencia entre un usuario y un asiento?","version":"current","path":"/es/kb/getting-started/what-is-the-difference-between-a-user-and-a-seat","category":"default"},{"title":"Empezando con los cambios","content":"Antes de cualquier exportación, asegúrese de que el nuevo campo personalizado con el tipo correcto se haya creado en su cuenta, por lo que la información del campo personalizado antiguo tiene un lugar al que moverse.\\nPara crear un campo personalizado, vaya a Configuración> Campos personalizados y seleccione la categoría de campo personalizado que desea agregar a Fintesk.\\n:::tip\\nNota: Mientras se encuentra en la página de configuración de Campos personalizados, puede ser una buena idea editar el nombre del campo personalizado existente para incluir la palabra \\"antiguo\\" para evitar cualquier confusión durante el proceso de actualización.\\n:::\\n\\n","section":"Cambiar el tipo de campo de un campo personalizado","version":"current","path":"/es/kb/importing-data/changing-the-field-type-of-a-custom-field#empezando-con-los-cambios","category":"default"},{"title":"Exportar sus datos","content":"Para comenzar con su exportación, puede ir a vista de lista de los negocios, personas u organización los campos personalizado están debajo. Deberá incluir las siguientes columnas en su vista de lista:\\nNombre\\nAntiguo campo personalizado\\nNuevo campo personalizado\\nID de artículo (negocio, persona u organización)\\n:::tip\\nNota: En las capturas de pantalla a continuación, los valores en el \\"Ejemplo de Campo personalizado de texto\\" en negocios se moverán al recién creado \\"Ejemplo de Campo personalizado Opción Única\\" en negocios.\\n:::\\n<!--  -->\\n\\nUna vez que tenga estas cuatro columnas aplicadas en su \\"vista de lista\\", puede exportar la lista a una hoja de cálculo.\\nEn la hoja de cálculo exportada, tendrá que copiar y pegar todos los valores debajo del campo personalizado antiguo en las celdas debajo del campo personalizado nuevo. Esto permitirá que el nuevo campo personalizado se \\"actualice\\" con la información del campo personalizado anterior cuando vuelva a importar su hoja de cálculo.\\n<!--  -->\\n\\n\\n","section":"Cambiar el tipo de campo de un campo personalizado","version":"current","path":"/es/kb/importing-data/changing-the-field-type-of-a-custom-field#exportar-sus-datos","category":"default"},{"title":"Importando sus datos actualizados","content":"Una vez que guarde la hoja de cálculo actualizada, puede importar la hoja de cálculo de nuevo a Fintesk haciendo clic en el \\"...\\" en la parte inferior izquierda de su pantalla, luego seleccionando Importar datos > De una hoja de cálculo. Puede obtener más información sobre la importación aquí.\\nCuando llega al paso de mapeo de su importación, es importante asegurarse de que todas las columnas de su hoja de cálculo se asignen al campo correcto en su cuenta de Fintesk.\\n<!--  -->\\n\\nUna vez que todo está asignado, puede presionar el botón \\"Próximo\\" para continuar con su importación.\\n<!--  -->\\n\\nUna vez que confirma que la información se ha transferido con éxito desde el campo personalizado anterior al nuevo campo personalizado, puede eliminar la anterior.\\n","section":"Cambiar el tipo de campo de un campo personalizado","version":"current","path":"/es/kb/importing-data/changing-the-field-type-of-a-custom-field#importando-sus-datos-actualizados","category":"default"},{"title":"Mapeo en Fintesk","content":"Una vez que importe su hoja de cálculo, si Fintesk puede identificar el formato de sus fechas sin ninguna confusión, no se necesita acción. Si Fintesk no puede identificar el formato de sus fechas, le pedirá que especifique el formato de su hoja de cálculo.\\n<!--  -->\\n\\n<!--  -->\\n\\n\\n","section":"¿Cómo puedo formatear las fechas para importar a Fintesk?","version":"current","path":"/es/kb/importing-data/how-can-i-format-dates-to-import-into-fintesk#mapeo-en-fintesk","category":"default"},{"title":"Cómo formatear sus columnas en Excel","content":"Las hojas de cálculo pueden formatear sus celdas para tipos especiales de datos. A menudo, puede recibir una hoja de cálculo que ya está formateada, o es posible que tenga que formatear sus propios datos. Aquí le mostramos cómo editar el formato de sus columnas en Excel:\\nHaga clic con el botón derecho en la cabeza de su columna> Células de formato> Elija su formato deseado.\\n<!--  -->\\n\\n","section":"¿Cómo puedo formatear las fechas para importar a Fintesk?","version":"current","path":"/es/kb/importing-data/how-can-i-format-dates-to-import-into-fintesk#cómo-formatear-sus-columnas-en-excel","category":"default"},{"title":"Comenzando su importación","content":":::tip\\nNota: Si no tiene una hoja de cálculo para trabajar, proporcionamos hojas de cálculo de muestra a las que puede acceder en esta página.\\n:::\\nPara iniciar una importación de hoja de cálculo, vaya a Herramientas y aplicaciones> Importar datos > desde una hoja de cálculo.\\n<!--  -->\\n\\n\\n","section":"Import fields","version":"current","path":"/es/kb/importing-data/import-fields#comenzando-su-importación","category":"default"},{"title":"Cómo se organizan los campos","content":"En la ventana de importación, hay siete categorías de datos que representan sus tipos de campo disponibles.\\nPersona\\nOrganización\\nNegocio\\nActividad\\nNota\\nProducto\\n<!--  -->\\n\\nEn cada categoría de tipo de campo, los campos se enumeran alfabéticamente (incluidos los campos personalizados).\\n<!--  -->\\n\\n\\n","section":"Import fields","version":"current","path":"/es/kb/importing-data/import-fields#cómo-se-organizan-los-campos","category":"default"},{"title":"Campos predeterminados","content":"<!-- :::tip\\nNota: Project data can‘t be imported currently.\\n::: -->\\nPara negocios, personas, organizaciones y productos, los campos predeterminados disponibles para la importación se pueden encontrar en Campos de datos sección de su configuración en cada categoría.\\n<!--  -->\\n\\n","section":"Import fields","version":"current","path":"/es/kb/importing-data/import-fields#campos-predeterminados","category":"default"},{"title":"Actividades","content":"Las actividades no aparecen en la sección de campos de datos de su cuenta, pero puede ver los campos de importación disponibles en la pantalla de mapeo de importación.\\n<!--  -->\\n\\n<!-- Note fields can also be found in the import mapping screen.\\n-->\\n\\n","section":"Import fields","version":"current","path":"/es/kb/importing-data/import-fields#actividades","category":"default"},{"title":"Campos personalizados","content":":::tip\\nNota: Las actividades y las notas no tienen campos personalizados disponibles. Para obtener más información sobre los campos personalizados, consulte este artículo.\\n:::\\nAdemás de los campos predeterminados, los campos personalizados se pueden asignar al importar datos a su cuenta de FinTesk.\\n<!--  -->\\n\\n","section":"Import fields","version":"current","path":"/es/kb/importing-data/import-fields#campos-personalizados","category":"default"},{"title":"Mapeo de múltiples campos de opción","content":":::tip\\nNota: Para asignar un campo de opción múltiple, primero deberá asegurarse de que el campo de tipo de opción múltiple ya esté creado en su cuenta FinTesk. Puede obtener más información sobre los campos personalizados en este artículo.\\n:::\\nPara importar un campo de opciones múltiples, hay un paso adicional para que pueda mapear. Cuando haya mapeado el campo en sí (\\"número de grupo\\" En el ejemplo a continuación), haga clic en él para expandir y vea la asignación individual de cada opción de campo desde su hoja de cálculo.\\n<!--  -->\\n\\nVerifique si las opciones de su hoja de cálculo se han asignado correctamente a las opciones de campo personalizadas en Fintesk. Si no se mapearon correctamente, haga clic y arrastre las opciones correctas a sus opciones correspondientes desde la hoja de cálculo.\\n\\n<!-- ## Mapping addresses\\nThere are two possible ways to include addresses in your spreadsheet when importing an organization\'s address field or an address type custom field. -->\\n<!--\\nAddress fields in separate columns\\nWhen creating your spreadsheet, you can add your address with the different address fields separated into different columns.\\n\\nThen, when mapping your fields, you can select the individual address fields from Fintesk and match them with the fields in your spreadsheet.\\n-->\\n<!--\\nAddress in one field\\nAlternatively, you can add your address to one field, separating your items with a comma.\\n\\nIn this case, you can map the general address field to your spreadsheet column.\\n-->\\n<!-- Fintesk will attempt to geolocate your addresses using Google\'s Geolocation API. Please be aware that not all addresses will definitely be geolocated. You can learn more about how Google addresses should be formatted here. When addresses are geolocated in Fintesk, they will appear in our Show on Map feature. -->\\n\\n","section":"Importación-> Mapeo avanzado","version":"current","path":"/es/kb/importing-data/importing-advanced-mapping#mapeo-de-múltiples-campos-de-opción","category":"default"},{"title":"Mapeo de números de teléfono","content":"Al importar el número de teléfono de su contacto, tiene la opción de seleccionar la etiqueta del teléfono que desea asignar a Fintesk. Si tiene múltiples números de teléfono para un contacto, puede asignar el campo Teléfono varias veces.\\nPor ejemplo, si desea importar contactos con un número de teléfono móvil personal, así como un teléfono de trabajo, puede hacerlo agregando los números en columnas separadas.\\n<!--  -->\\n\\nAl asignar, puede hacer clic y arrastrar el campo Teléfono varias veces. Una vez que se haya asignado, haga clic en el icono Lápiz para asignar una etiqueta a ese tipo de número de teléfono.\\n<!--  -->\\n\\nPuede elegir etiquetar sus números de teléfono como trabajo, casa, móvil o otro.\\n","section":"Importación-> Mapeo avanzado","version":"current","path":"/es/kb/importing-data/importing-advanced-mapping#mapeo-de-números-de-teléfono","category":"default"},{"title":"Preparándose para una importación","content":"Antes de importar, considere los datos que está agregando a Fintesk y formatea su hoja de cálculo en consecuencia.\\n¿Está tratando de importar una lista de contactos (personas y organizaciones?)\\n¿Desea importar contactos y crear un negocio abierto para cada uno?\\n¿Desea importar contactos, negocios abiertos y crear actividades para esos negocios?\\n¿Desea importar contactos, negocios abiertos con actividades y adjuntar notas?\\n¿O abrir nuevos negocios para contactos que ya existen en Fintesk?\\nAlgunos consejos de formato de hoja de cálculo:\\nEliminar fórmulas – Use una hoja de cálculo nueva sin ninguna fórmula. Si tiene una hoja de cálculo que usa fórmulas o linkea datos para generar el contenido de una celda, copie los datos de su hoja de cálculo en una hoja nueva sin las fórmulas.\\nUna pestaña por hoja de cálculo – Su hoja de cálculo solo debe tener una pestaña que contenga datos. Si su hoja de cálculo tiene más de una pestaña, copie y pegue las pestañas en archivos individuales e importe una a la vez.\\nSin símbolos especiales – Su hoja de cálculo no puede tener símbolos para campos numéricos o monetarios. Por ejemplo, una columna para el valor del negocio solo debe incluir el número \\"100\\" y no el símbolo \\"$100\\".\\nLímite de tamaño de la hoja de cálculo – No hay un límite máximo en el número de columnas de hoja de cálculo, pero el tamaño máximo del archivo es de 50 MB, con un límite de 50,000 filas por hoja de cálculo.\\n\\n","section":"Importar datos a Fintesk con hojas de cálculo","version":"current","path":"/es/kb/importing-data/importing-data-into-fintesk-with-spreadsheets#preparándose-para-una-importación","category":"default"},{"title":"Campos obligatorios","content":"Al importar datos a Fintesk desde una hoja de cálculo, incluya los campos obligatorios para cada elemento. Cada campo obligatorio necesita una columna separada en su hoja de cálculo asignada al campo correspondiente en Fintesk.\\n:::tip\\nNota: Si no importa sus datos con los campos obligatorios, no creará elementos y un archivo omitir será generado.\\n:::\\n<table>\\n<tbody>\\n<tr>\\n<td>\\nPara importar\\n</td>\\n<td>\\nNecesitas estos campos obligatorios\\n</td>\\n</tr>\\n<tr>\\n<td>\\nNegocios\\n</td>\\n<td>\\nCualquier campo de negocio\\nNombre de la persona u nombre de la organización\\n(Nombre del negocio recomendado)\\n</td>\\n</tr>\\n<tr>\\n<td>\\nPersona\\n</td>\\n<td>\\nNombre de la persona\\n:::tip\\nNota: Se recomiendan el correo electrónico y el teléfono para evitar duplicados\\n:::\\n</td>\\n</tr>\\n<tr>\\n<td>\\nOrganización\\n</td>\\n<td>\\nNombre de la organización\\n:::tip\\nNota: Se recomienda la dirección para evitar duplicados\\n:::\\n</td>\\n</tr>\\n<tr>\\n<td>\\nProductos\\n</td>\\n<td>\\nNombre del producto\\n:::tip\\nNota: Se recomienda el código de producto para evitar duplicados\\n:::\\n</td>\\n</tr>\\n<tr>\\n<td>\\nNotas\\n</td>\\n<td>\\nContenido\\nNegocios, contactos (Información de persona u organización)\\n</td>\\n</tr>\\n<tr>\\n<td>\\nActividades\\n</td>\\n<td>\\nCualquier campo de actividad\\n</td>\\n</tr>\\n</tbody>\\n</table>\\n<!-- You can read more about mandatory fields for importing in this article. -->\\n\\n","section":"Importar datos a Fintesk con hojas de cálculo","version":"current","path":"/es/kb/importing-data/importing-data-into-fintesk-with-spreadsheets#campos-obligatorios","category":"default"},{"title":"Campos personalizados","content":"Si su hoja de cálculo tiene datos para negocios o contactos que no están cubiertos por campos predeterminados, agregue un campo personalizado antes de importar para que sus datos tengan un lugar que se mapee.\\nPor ejemplo, el \\"cargo de trabajo\\" no es un campo predeterminado en Fintesk .Para incluir esta información en su importación, cree un campo de persona personalizado, luego asigne la columna de hoja de cálculo al campo recién creado. Recomendamos un campo de texto o opción única.\\nTambién puede crear campos personalizados durante la etapa de mapeo de su importación. Obtenga más información sobre los campos personalizados en este artículo.\\n<!--  -->\\n\\n\\n","section":"Importar datos a Fintesk con hojas de cálculo","version":"current","path":"/es/kb/importing-data/importing-data-into-fintesk-with-spreadsheets#campos-personalizados","category":"default"},{"title":"Paso 1: Sube tu archivo","content":"Ir a “...” (Más)> Importar datos> desde una hoja de cálculo. Haga clic en \\"desde una hoja de cálculo\\" y seleccione el archivo que tiene la intención de importar. Fintesk admite Excel (.xls y .xlsx) y archivos .csv.\\n<!--  -->\\n\\n","section":"Importar datos a Fintesk con hojas de cálculo","version":"current","path":"/es/kb/importing-data/importing-data-into-fintesk-with-spreadsheets#paso-1-sube-tu-archivo","category":"default"},{"title":"Paso 2: mapeo","content":"Para importar sus datos a Fintesk, asigne cada columna en su hoja de cálculo al icono y campo relevantes en el paso de mapeo. Puede pasar el icono para ver a qué tipo de datos se refiere en Fintesk.\\nLa función de reconocimiento automático coincidirá automáticamente con el encabezado de la columna con los campos en Fintesk. Los campos no reconocidos deben arrastrarse desde los campos de Fintesk (derecha) a sus columnas de hoja de cálculo apropiadas (izquierda). Use la barra de búsqueda para encontrar los nombres de campo de Fintesk más fácilmente.\\n<!--  -->\\n\\n:::tip\\nNota: Puede obtener más información sobre el mapeo en este artículo o mapeo avanzado en este artículo.\\n:::\\nUna vez que haya terminado de mapeo, haga clic en \\"Siguiente\\".\\n","section":"Importar datos a Fintesk con hojas de cálculo","version":"current","path":"/es/kb/importing-data/importing-data-into-fintesk-with-spreadsheets#paso-2-mapeo","category":"default"},{"title":"Paso 3: Vista previa y acabado","content":"En la siguiente ventana, elija qué hacer si se encuentran duplicados en su hoja de cálculo. Si Fintesk detecta un registro duplicado en su hoja de cálculo o datos de Fintesk, lo consolidará en una sola entrada. Puede obtener más información sobre cómo Fintesk detecta duplicados durante la importación en este artículo.\\n<!--  -->\\n\\nEsta página también muestra una vista previa de sus datos después de la importación.\\n<!--  -->\\n\\nUna vez que haya previsualizado su importación, seleccione \\"Iniciar importación\\".\\n\\n","section":"Importar datos a Fintesk con hojas de cálculo","version":"current","path":"/es/kb/importing-data/importing-data-into-fintesk-with-spreadsheets#paso-3-vista-previa-y-acabado","category":"default"},{"title":"Después de su importación","content":"Después de su importación, verá una página de confirmación con una descripción general de los datos importados.\\n<!-- \\n -->\\n<!-- ### What is a “skip file?”\\nAny items imported incorrectly are put together in a Skip file, which includes the row where the complication occurred and the reason why.\\nFor example, if you import a list of persons and don’t include a mandatory field (e.g., person name), that row of information will be skipped. Fintesk will then take that row and organize it in a Skip file.\\nYou can download the Skip File at any time to review these errors and make the needed changes directly in the spreadsheet, then import the Skip File into Fintesk to complete your import. This ensures all of your data makes it into the system.\\n\\nYour skip file will look like this:\\n\\nYou can learn more about why data is skipped in this article. -->\\n\\n<!-- ## How do I revert an import?\\n:::tip\\nNota: Only global admin users can revert imports.\\n:::\\nA spreadsheet import can be reverted within 48 hours of its initial import with the revert button provided in your import history.\\n\\nNota: If the revert button is unavailable, let our support team know and they will assist you. -->\\n","section":"Importar datos a Fintesk con hojas de cálculo","version":"current","path":"/es/kb/importing-data/importing-data-into-fintesk-with-spreadsheets#después-de-su-importación","category":"default"},{"title":"Negocios","content":"Cada negocio en Fintesk necesita tener una persona de contacto u organización vinculada a él. Para importar un negocio, deberá agregar al menos un campo de negocio y cualquiera de los siguientes en su hoja de cálculo:\\nNombre de la persona\\nNombre de la organización\\nRecomendamos incluir el campo Nombre del negocio, pero no es obligatorio. Si no incluye un nombre de negocio, el negocio tomará automáticamente el nombre del contacto con el que se importa.\\n<!--  -->\\n\\n<!--  -->\\n\\n","section":"Importación-> campos obligatorios","version":"current","path":"/es/kb/importing-data/importing-mandatory-fields#negocios","category":"default"},{"title":"¿Qué otros campos puedo incluir con mi importación de negocios?","content":"También puede incluir los siguientes campos de negocios:\\nPropietario\\nEtapa\\nValor\\nFecha de cierre esperada\\nCualquier campo personalizado\\nSi está importando un negocio histórico o un negocio que ya se ha cerrado, puede usar los siguientes campos:\\nFecha de Ganado\\nFecha de Perdido\\nEstado\\n:::tip\\nNota: Para importar un negocio, no necesariamente necesita tener un nombre de negocio en su hoja de cálculo. Si desea crear negocios para cada persona u organización, solo necesita crear una columna vacía en su hoja de cálculo para los nombres de los negocios. Asegúrese de que esta columna vacía esté asignada al campo Nombre de negocio.\\n:::\\nCuando se importan, los nombres del negocio tomarán automáticamente el nombre de la organización. Si no hay organización, tomará el nombre de la persona de contacto.\\n\\n","section":"Importación-> campos obligatorios","version":"current","path":"/es/kb/importing-data/importing-mandatory-fields#qué-otros-campos-puedo-incluir-con-mi-importación-de-negocios","category":"default"},{"title":"Contactos: Personas y organizaciones","content":"Al importar personas u organizaciones, solo el nombre es obligatorio para la creación de contacto exitosa. Sin embargo, se recomienda agregar más campos para identificar mejor su contacto y evitar que se creen duplicados. Obtenga más información sobre cómo Fintesk detecta duplicados durante la importación en este artículo.\\nPara las personas, agregue lo siguiente para evitar que se creen duplicados:\\nDirección de correo electrónico\\nNúmero de teléfono\\nPara las organizaciones, incluya lo siguiente para evitar que se creen duplicados:\\nDirección\\nLas organizaciones y las personas se pueden crear por separado, pero recomendamos importarlos para vincularlos automáticamente.\\n<!--  -->\\n\\n<!--  -->\\n\\n:::tip\\nNota: El rojo en las imágenes de arriba representa un campo obligatorio.\\n:::\\n\\n","section":"Importación-> campos obligatorios","version":"current","path":"/es/kb/importing-data/importing-mandatory-fields#contactos-personas-y-organizaciones","category":"default"},{"title":"Productos","content":"Para importar un producto, solo necesitará el nombre del producto en su hoja de cálculo.\\n<!--  -->\\n\\n<!--  -->\\n\\n","section":"Importación-> campos obligatorios","version":"current","path":"/es/kb/importing-data/importing-mandatory-fields#productos","category":"default"},{"title":"¿Qué otros campos puedo incluir con mi importación de productos?","content":"También puede incluir otros campos de productos como precio, moneda, descripción y cualquier campo personalizado.\\n:::tip\\nNota: Actualmente no es posible vincular productos a negocios a través de una importación. Solo puede vincular un producto a un negocio cuando sus datos ya se hayan importado a Fintesk.\\n:::\\n\\n<!--\\n","section":"Importación-> campos obligatorios","version":"current","path":"/es/kb/importing-data/importing-mandatory-fields#qué-otros-campos-puedo-incluir-con-mi-importación-de-productos","category":"default"},{"title":"Notes","content":"Notes can be added under deals, persons, organizations, activities and leads, and cannot exist by themselves. When importing a note, you have to also include information of one of the following (and their mandatory fields):\\nOrganization\\nPerson\\nDeal\\nLead\\n\\nWhat are other note fields I can include?\\nYou can add the following fields for notes:\\nNote creation date\\nNote update date -->\\n\\n","section":"Importación-> campos obligatorios","version":"current","path":"/es/kb/importing-data/importing-mandatory-fields#notes","category":"default"},{"title":"Actividad","content":"Por el momento, las actividades no tienen campos obligatorios. Sin embargo, se recomienda incluir información como el Asunto, fecha finalización, tipo y Asignado al usuario, así como cualquier negocio vinculado o contactos.\\n<!--  -->\\n\\n<!--  -->\\n\\nSi su actividad ya se ha completado, puede incluir los siguientes campos históricos:\\nFecha de completado\\nMarcado como completado\\n","section":"Importación-> campos obligatorios","version":"current","path":"/es/kb/importing-data/importing-mandatory-fields#actividad","category":"default"},{"title":"Iconos de elementos","content":"Para importar sus datos a Fintesk correctamente, deberá asignar cada campo con los iconos relevantes para que sus elementos se importen. Cada tipo de elemento está representado por un icono de elemento al importar.\\nPor ejemplo, todos sus campos relacionados con la persona deben mapear a los campos bajo el ícono de elemeno \\"Persona\\" para que se muestren correctamente vinculados a sus contactos.\\n<!--  -->\\n\\nCampos de tipo de persona\\n<!--  -->\\n\\nCampos de tipo de organización\\n<!--  -->\\n\\nCampos de tipo de negocio\\n<!--  -->\\n\\nCampos de tipo de actividad\\n<!--  -->\\n\\n<!-- - Note type fields\\n\\n-->\\nCampos de tipo de producto\\n<!--  -->\\n\\n<!-- - Lead type fields\\n -->\\nHaga clic en los iconos para seleccionar el tipo correcto de campos al asignar.\\n<!--  -->\\n\\n\\n","section":"Importación-> Mapeo de sus campos","version":"current","path":"/es/kb/importing-data/importing-mapping-your-fields#iconos-de-elementos","category":"default"},{"title":"Mapeo de sus campos","content":":::tip\\nNota: No todos sus campos se asignarán automáticamente, por lo que deberá asignar algunos campos manualmente. Siempre se recomienda verificar su mapeo antes de pasar al siguiente paso para evitar cualquier mapeo incorrecto.\\n:::\\nUna vez que tenga su hoja de cálculo configurada e importada, puede comenzar a mapear sus campos. A continuación puede ver una muestra de una hoja de cálculo.\\n<!--  -->\\n\\nAl asignar, seleccione el icono del tipo de campo que desea mapear. Luego haga clic y arrastre ese campo al lado izquierdo de la página y coincida con sus columnas de hoja de cálculo. Verá los datos de la primera fila de su importación, por lo que puede verificar que Fintesk lea correctamente la hoja de cálculo.\\n<!--  -->\\n\\nPuede encontrar más información sobre la asignación avanzada, como mapeo de múltiples campos de opciones en este artículo.\\n","section":"Importación-> Mapeo de sus campos","version":"current","path":"/es/kb/importing-data/importing-mapping-your-fields#mapeo-de-sus-campos","category":"default"},{"title":"Importación-> Muestra de hojas de cálculo de importación","content":"<p>&lt;!-- ../../kb/importing-data/importing-sample-import-spreadsheets.md --&gt;</p>\\n<p>&lt;!-- # Importing: sample import spreadsheets --&gt;</p>\\n<p>Si necesita ayuda con su <a href=\\"../../kb/importing-data/importing-data-into-fintesk-with-spreadsheets\\">Importación de datos</a> hacia Fintesk, Es posible que desee comenzar con un documento de plantilla para ver la mejor manera de proceder.</p>\\n<p>:::tip\\n<strong>Nota:</strong> Para obtener información sobre cómo importar datos de hoja de cálculo en Fintesk, consulte <a href=\\"../../kb/importing-data/importing-data-into-fintesk-with-spreadsheets\\">esta guía</a>.\\n:::</p>\\n<p>La hoja de cálculo adjunta a este artículo, <strong>Datos de muestra de Fintesk</strong>, proporciona excelentes señales visuales e información de referencia importante para comenzar a usar Fintesk.</p>\\n<p>Las columnas en la hoja de cálculo de muestra están codificadas por colores y proporcionan descripciones de los diferentes campos, lo que hace que los encabezados de columnas sean fáciles de reconocer en la sección de mapeo de la función de importación de Fintesk.</p>\\n<p>Puede llenar sus propios datos en esta hoja de cálculo, o usarlos para obtener información sobre dónde mapear los diferentes campos de Fintesk en las columnas de su propia hoja de cálculo.</p>\\n<ul>\\n<li><a href=\\"../../kb/importing-data/importing-sample-import-spreadsheets/ejemplo_data_v5.xlsx\\">Descargar la muestra de datos Fintesk archivo .xlsx</a>\\n&lt;!-- - <a href=\\"https://kb-cms.pipedriveassets.com/pipedrive_sample_data.xlsx\\">Download Fintesk sample data.xlsx file</a> --&gt;\\n&lt;!-- - <a href=\\"https://kb-cms.pipedriveassets.com/pipedrive_sample_data%20-%20Sheet1.csv\\">Download Fintesk sample data.csv file</a> --&gt;</li>\\n</ul>\\n","section":"Importación-> Muestra de hojas de cálculo de importación","version":"current","path":"/es/kb/importing-data/importing-sample-import-spreadsheets","category":"default"},{"title":"Importando y exportando sus datos","content":"\\n:::tip\\nNota: Esta acción solo está disponible para usuarios administrativos o usuarios regulares con el permiso correcto habilitado.\\n:::\\nLa otra forma de trasladar sus datos a una cuenta de compañía diferente en Fintesk sería exportar los datos relevantes de su cuenta de Fintesk a una hoja de cálculo e importar en la otra cuenta de la compañía.\\nAl exportar sus datos, es importante mantener los campos obligatorios que Fintesk necesitará al mapear durante la importación futura, para crear con éxito los nuevos elementos en su otra cuenta de Fintesk. Para ver qué campos son obligatorios para importar datos en su cuenta de Fintesk, haga clic en aquí.\\nUna vez que tenga sus datos exportados a una hoja de cálculo, puede importar esta hoja de cálculo a la otra cuenta de la compañía Fintesk y comenzar a trabajar justo donde lo dejó.\\n","section":"Transferring data to a different Fintesk company account","version":"current","path":"/es/kb/importing-data/transferring-data-to-a-different-fintesk-company-account#importando-y-exportando-sus-datos","category":"default"},{"title":"Función de ID del sistema Fintesk","content":"Dentro de Fintesk, cada elemento (negocio, persona, organización, actividad, producto, notas) se le asigna una identificación única en la creación. Puede encontrar esta identificación en la URL de la vista de detalle de cada elemento, o puede agregarla como una columna en la vista de lista.\\n\\n<!-- :::tip\\nNota: If you are attempting to merge duplicates in your account, you may be interested in the Merge Duplicates feature within Fintesk. Learn more about merging duplicates in this article.\\n::: -->\\n\\n","section":"Updating Fintesk data with a spreadsheet","version":"current","path":"/es/kb/importing-data/updating-fintesk-data-with-a-spreadsheet#función-de-id-del-sistema-fintesk","category":"default"},{"title":"¿Qué IDs y campos debo usar?","content":"Para actualizar sus elementos (negocios, personas, organizaciones, productos, etc.), es necesario incluir el ID del sistema Fintesk y cualquier otro campo que desee actualizar.\\nPor ejemplo, supongamos que desea cambiar los valores, la etapa y el dueño de los negocios existentes. Necesita exportar una lista con la columna ID más la columnas Valor, Nombre de etapa y Propietario (dueño).\\n\\nTenga en cuenta que puede exportar otras columnas como referencia, como el nombre. Sin embargo, cualquier cambio que realice en esas columnas se sobrescribirán cuando importe.\\n","section":"Updating Fintesk data with a spreadsheet","version":"current","path":"/es/kb/importing-data/updating-fintesk-data-with-a-spreadsheet#qué-ids-y-campos-debo-usar","category":"default"},{"title":"¿Cómo obtengo los ID del sistema Fintesk en la vista de lista?","content":"Para hacer visible la columna ID en la vista de lista, haga clic en el ícono de engranaje para abrir la ventana de \\"Elija columnas\\", busque y seleccione el campo ID deseado y haga clic en \\"Guardar\\".\\n\\n:::tip\\nNota: Puede obtener ID de negocio, persona y organización dentro de la vista de lista de la pestaña de negocios. Sin embargo, si tiene contactos sin negocios asociados, no aparecerán en la vista de lista de la pestaña de negocios. Luego deberá usar la vista de lista de la pestaña Contactos para obtener esas ID.\\n:::\\n<!-- You can create a filter to narrow down the list  -->\\nPuede crear un filtro para reducir la lista\\na solo los elementos que desea actualizar. Cuando la vista de la lista esté configurada para mostrar sus campos de ID del sistema Fintesk, exporte la lista aquí:\\n\\n\\n","section":"Updating Fintesk data with a spreadsheet","version":"current","path":"/es/kb/importing-data/updating-fintesk-data-with-a-spreadsheet#cómo-obtengo-los-id-del-sistema-fintesk-en-la-vista-de-lista","category":"default"},{"title":"Importando sus datos","content":"Una vez exportado, realice todos los cambios necesarios en los datos dentro de la hoja de cálculo. Aquí hay un ejemplo de cómo se vería su hoja de cálculo cuando la exporta antes de los cambios:\\n\\nY aquí hay un ejemplo de la misma hoja de cálculo con cambios realizados. Tenga en cuenta que los campos de identificación no necesitan cambiarse. Solo necesita cambiar la información que debe actualizarse en Fintesk.\\n\\nEntonces, importar la hoja de cálculo a fintesk y asigna los campos de identificación correspondientes a sus columnas.\\n\\nCuando se asignen todos los campos, haga clic en \\"Siguiente\\" y finalice la importación. El ID del sistema Fintesk actualizará automáticamente su base de datos con su nueva información, ya que Fintesk sabrá qué elementos está actualizando en función de la ID del sistema Fintesk.\\n:::tip\\nNota: Si recibe un error al intentar importar una hoja de cálculo, el problema puede provenir de su hoja de cálculo: el tamaño máximo del archivo está limitado a 50 MB, con un límite máximo de 50,000 filas. Puede obtener más información sobre la importación de errores en este artículo.\\n:::\\n","section":"Updating Fintesk data with a spreadsheet","version":"current","path":"/es/kb/importing-data/updating-fintesk-data-with-a-spreadsheet#importando-sus-datos","category":"default"},{"title":"¿Por qué mis valores de moneda importados aparecen como \\"0\\"?","content":"<p>&lt;!-- ## Why do my imported currency values appear as &quot;0&quot;? --&gt;</p>\\n<p>Al importar desde hojas de cálculo, asegúrese de que todos los valores monetarios (para campos predeterminados, como el valor del negocio, y para cualquier campo personalizado donde tenga monedas) estén formateados como números <strong>sin</strong> símbolos de moneda (así que 1000000000 en lugar de $ 1000000000).</p>\\n<p>Si los números incluyen símbolos de divisas, el sistema de importación FinTesk no los detectará correctamente y, por lo tanto, todos los valores se formatearán como &quot;0&quot;.</p>\\n<p>Si ya ha importado y enfrenta este problema, el mejor curso de acción es revertir su importación, eliminar los símbolos de divisas de la hoja de cálculo que está importando e importando nuevamente.</p>\\n","section":"¿Por qué mis valores de moneda importados aparecen como \\"0\\"?","version":"current","path":"/es/kb/importing-data/why-do-my-imported-currency-values-appear-as-0","category":"default"},{"title":"Agregar columnas a la vista de lista","content":":::tip\\nNota: Los campos de negocios, personas y organizaciónes están disponibles para usar como columnas.\\n:::\\nHaga clic en el ícono de engranaje en la esquina superior derecha de la vista de la lista y seleccione qué campos desea como columnas.\\nCuando termine, haga clic en \\"Guardar\\".\\n<!--  -->\\n\\nSus nuevas columnas aparecerán en el siguiente lugar disponible a la derecha de sus columnas existentes.\\n<!--  -->\\n\\n\\n<!--\\n","section":"Personalización de las columnas en la vista de lista","version":"current","path":"/es/kb/list-view/customizing-the-columns-in-the-list-view#agregar-columnas-a-la-vista-de-lista","category":"default"},{"title":"Reordering your columns","content":"You can change where a column is located by holding your cursor down and dragging it to your preferred spot.\\n\\nYou can also change the width of your columns by holding the cursor down and moving the margins on either side. -->\\n","section":"Personalización de las columnas en la vista de lista","version":"current","path":"/es/kb/list-view/customizing-the-columns-in-the-list-view#reordering-your-columns","category":"default"},{"title":"Donde encontrarlo","content":"Puede encontrar la ID del sistema de un elemento en dos lugares.\\n","section":"IDs del sistema Fintesk","version":"current","path":"/es/kb/list-view/fintesk-system-ids#donde-encontrarlo","category":"default"},{"title":"La URL después de abrir un elemento","content":"Cuando abre la vista de detalle de un elemento, la identificación de ese elemento es el último número en la URL de su navegador.\\n<!--  -->\\n\\n","section":"IDs del sistema Fintesk","version":"current","path":"/es/kb/list-view/fintesk-system-ids#la-url-después-de-abrir-un-elemento","category":"default"},{"title":"La vista de la lista","content":"También puede encontrar las ID para sus elementos utilizando Vista de lista.\\nHaga clic en el ícono de engranaje y seleccione ID> Guardar.\\n<!--  -->\\n\\nSus IDs aparecerán como una columna y en la sección visible de la configuración de su columna.\\n<!--  -->\\n\\n\\n","section":"IDs del sistema Fintesk","version":"current","path":"/es/kb/list-view/fintesk-system-ids#la-vista-de-la-lista","category":"default"},{"title":"¿Para qué sirven?","content":":::tip\\nNota: Para obtener una guía para actualizar sus datos utilizando ID del sistema y hojas de cálculo, consulte este artículo.\\n:::\\nEl propósito principal de los ID del sistema es la organización. Tener un número que corresponde a cada pieza de datos hace que sea más fácil organizarlo y encontrarlo.\\nSin embargo, hay otras formas de usar los IDs.\\n","section":"IDs del sistema Fintesk","version":"current","path":"/es/kb/list-view/fintesk-system-ids#para-qué-sirven","category":"default"},{"title":"Actualización de datos masivamente","content":"Si desea actualizar muchos datos a la vez, puede hacerlo utilizando IDs del sistema.\\nTenemos un artículo que explica el proceso en detalle, pero básicamente:\\nIncluya el campo de ID cuando exporte una hoja de cálculo\\nHaga los cambios deseados en la hoja de cálculo\\nReimportar esa hoja de cálculo\\nSe actualizarán los datos existentes en su cuenta correspondientes a los ID de exportación.\\n","section":"IDs del sistema Fintesk","version":"current","path":"/es/kb/list-view/fintesk-system-ids#actualización-de-datos-masivamente","category":"default"},{"title":"Funciones de integración","content":"Algunas aplicaciones de terceros como Zapier tener opciones para actualizar los elementos específicos automáticamente, y el uso de IDs del sistema es una forma efectiva de identificar qué elementos desea cambiar.\\nEsto puede ser especialmente útil si, por ejemplo, tiene varios elementos con los mismos nombres o similares.\\n","section":"IDs del sistema Fintesk","version":"current","path":"/es/kb/list-view/fintesk-system-ids#funciones-de-integración","category":"default"},{"title":"¿Cómo puedo agregar o eliminar columnas en la vista de lista?","content":"<p>&lt;!-- ../../kb/list-view/how-can-i-add-or-remove-columns-in-the-list-view.md --&gt;</p>\\n<p>&lt;!-- # How can I add or remove columns in the list view? --&gt;</p>\\n<p>Para elegir qué columnas son visibles en la tabla <strong>vista de lista</strong>, haga clic en el <strong>ícono de engranaje</strong> en la esquina superior derecha de la tabla de vista de lista y, usando las casillas de verificación mostradas, seleccione qué columnas le gustaría mostrar.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screen_Shot_2020-08-28_at_3.57.23_PM.png\\" alt=\\"1\\"> --&gt;</p>\\n<p><img src=\\"../../kb/list-view/how-can-i-add-or-remove-columns-in-the-list-view/hciar01.jpeg\\" alt=\\"hciar01\\"></p>\\n<p>Cuando termine, haga clic en <strong>&quot;Guardar&quot;</strong> para actualizar su vista de lista.</p>\\n","section":"¿Cómo puedo agregar o eliminar columnas en la vista de lista?","version":"current","path":"/es/kb/list-view/how-can-i-add-or-remove-columns-in-the-list-view","category":"default"},{"title":"¿Cómo puedo editar un campo en la vista de lista?","content":"<p>&lt;!-- # How can I edit a field in the list view? --&gt;</p>\\n<p>En la vista de lista de Fintesk, puede editar un campo pasando su ratón sobre el campo en cuestión y haciendo clic en el icono del lápiz que aparece.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screen_Shot_2020-08-28_at_3.58.45_PM.png\\" alt=\\"1\\"> --&gt;</p>\\n<p><img src=\\"../../kb/list-view/how-can-i-edit-a-field-in-the-list-view/hcief01.jpeg\\" alt=\\"hcief01\\">\\n<img src=\\"../../kb/list-view/how-can-i-edit-a-field-in-the-list-view/hcief02.jpeg\\" alt=\\"hcief02\\"></p>\\n<p>Una vez que se haga clic en el icono del lápiz, podrá proporcionar nueva información para ir a ese campo.</p>\\n","section":"¿Cómo puedo editar un campo en la vista de lista?","version":"current","path":"/es/kb/list-view/how-can-i-edit-a-field-in-the-list-view","category":"default"},{"title":"Guardar las columnas de la vista de lista","content":"Para guardar la configuración de sus columnas de vista de lista, comience abriendo la ventana desplegable Filtro en su vista de lista y seleccionando un filtro.\\n<!--  -->\\n\\nDespués de haber seleccionado su filtro, marque la casilla \\"Guardar columnas seleccionadas con el filtro\\" y luego haga clic en \\"Guardar\\".\\n<!--  -->\\n\\nAhora, cuando usted u otro usuario abre ese filtro, las columnas de la vista de lista que tenía cuando se guardó también se abrirán/cargarán.\\n\\n<!--\\n","section":"¿Cómo puedo establecer columnas predeterminadas para todos mis usuarios en la vista de la lista?","version":"current","path":"/es/kb/list-view/how-can-i-set-default-columns-for-all-my-users-in-the-list-view#guardar-las-columnas-de-la-vista-de-lista","category":"default"},{"title":"Sharing your filter","content":"To share a filter with the rest of your account’s users, change the filter’s visibility to “Shared.”\\n\\nIf a filter is set to shared and “Save selected columns with the filter” is checked, other users can open your filter and the list view columns it was saved with. -->\\n","section":"¿Cómo puedo establecer columnas predeterminadas para todos mis usuarios en la vista de la lista?","version":"current","path":"/es/kb/list-view/how-can-i-set-default-columns-for-all-my-users-in-the-list-view#sharing-your-filter","category":"default"},{"title":"¿Qué puedo hacer en la vista de lista?","content":"La vista de lista admite varias acciones:\\n","section":"Vista de lista","version":"current","path":"/es/kb/list-view#qué-puedo-hacer-en-la-vista-de-lista","category":"default"},{"title":"Agregar elementos","content":"Use el botón \\"+ Agregar [elemento]\\" en la parte superior de la vista de su lista para agregar nuevos elementos.\\n<!--  -->\\n\\n:::tip\\nNota: El ejemplo anterior es desde la vista de lista de negocios y muestra el botón \\"+ Agregar negocio\\", que se utiliza para agregar nuevos negocios.\\n:::\\n","section":"Vista de lista","version":"current","path":"/es/kb/list-view#agregar-elementos","category":"default"},{"title":"Filtrar","content":"Haga clic en el menú desplegable en la esquina superior derecha para agregar o aplicar [filtros] existentes (../../kb/filtering) a su vista de lista.\\n<!--  -->\\n\\n","section":"Vista de lista","version":"current","path":"/es/kb/list-view#filtrar","category":"default"},{"title":"Cambiar columnas","content":"Haga clic en el icono de engranaje en el lado derecho de la pantalla para ajustar las columnas visibles en su vista de lista.\\n<!--  -->\\n\\n:::tip\\nNota: Para obtener más información sobre cómo cambiar las columnas de la vista de lista, consulte esta guía.\\n:::\\n","section":"Vista de lista","version":"current","path":"/es/kb/list-view#cambiar-columnas","category":"default"},{"title":"Edición de valores de campo","content":"Si se desplaza sobre un campo en un negocio, persona, organización, actividad o la vista de lista de productos, puede hacer clic en el ícono de lápiz para editar el valor de ese campo.\\n<!--  -->\\n\\n:::tip\\nNota: Algunos campos, como la actividad \\"Tiempo de creado\\", no se pueden editar a través de la vista de la lista.\\n:::\\n\\n","section":"Vista de lista","version":"current","path":"/es/kb/list-view#edición-de-valores-de-campo","category":"default"},{"title":"Tarjetas flotantes en la vista de lista","content":":::tip\\nNota: Puede hacer clic en una persona u organización dentro de en una tarjeta flotante para ver la vista de detalle del elemento.\\n:::\\nSi pasa su cursor sobre una persona, organización o negocio en la vista de lista, una tarjeta se abrirá y mostrará la información básica del elemento.\\nPersonas – La tarjeta tiene el nombre, el correo electrónico, el teléfono y la organización vinculados de la persona.\\n<!--  -->\\n\\nOrganizaciones – La tarjeta tiene el nombre, la dirección y la persona vinculada de la organización.\\n<!--  -->\\n\\n<!-- - Deals – The card has the deal title, value, linked person or organization, expected close date and current pipeline and stage. -->\\nDeals – La tarjeta tiene el nombre de negocio, el valor, la persona u organización vinculada y embudo y la etapa actuales.\\n<!-- -  -->\\n","section":"Vista de lista","version":"current","path":"/es/kb/list-view#tarjetas-flotantes-en-la-vista-de-lista","category":"default"},{"title":"Encontrar tu configuración","content":"Para encontrar tu configuración, hacer clic en la imagen en la esquina superior derecha de la ventana en Fintesk y haga clic en \\"Configuración de la empresa\\".\\n<!--  -->\\n\\n","section":"Configuración de Fintesk","version":"current","path":"/es/kb/personal-settings/fintesk-settings#encontrar-tu-configuración","category":"default"},{"title":"Configuración de la empresa","content":"La configuración de su empresa se divide en diferentes secciones:\\n<!-- - General – choose your company name and domain -->\\nActividades - Crear y administrar tipos de actividad, así como alternar la ventana emergente \\"mostrar actividad\\"\\nMonedas - Vea las monedas existentes en su cuenta y cree nuevas monedas.\\nRazones perdidas – Ver y crear razones perdidas personalizadas\\n<!--  -->\\n\\nEstas configuraciones se centran en cosas que afectan a todos los usuarios de su cuenta, por lo que necesitaConfiguraciones de la cuenta acceder para hacer cambios aquí.\\n\\n","section":"Configuración de Fintesk","version":"current","path":"/es/kb/personal-settings/fintesk-settings#configuración-de-la-empresa","category":"default"},{"title":"Preferencias personales","content":"Sus preferencias personales se dividen en tres secciones, donde solo una está funcionando en este momento:\\nCuenta – Información básica de su experiencia de usuario individual, como su correo electrónico vinculado, idioma y moneda preferida\\n<!-- - Your companies – shows any other Fintesk companies you’re added to (using the same login email) -->\\n<!-- - API – copy your unique API key or generate a new one -->\\n<!--  -->\\n\\n<!-- These settings are specific to your account, so things like your login email and API key should be kept private for security reasons. -->\\nEstas configuraciones son específicas de su cuenta, por lo que cosas como su correo electrónico de inicio de sesión deben mantenerse privados por razones de seguridad.\\n","section":"Configuración de Fintesk","version":"current","path":"/es/kb/personal-settings/fintesk-settings#preferencias-personales","category":"default"},{"title":"Para cambiar su contraseña de Fintesk","content":"Ir a Ajustes > Contraseña e inicio de sesión > Cambiar la contraseña.\\nEn el campo “Contraseña actual”, proporcione la contraseña de inicio de sesión actual para su cuenta de usuario de Fintesk.\\nEn los campos “Nueva contraseña” y ”Confirmar Contraseña”, proporcione sus credenciales de contraseña deseadas.\\nHaga clic en el “Cambiar la contraseña” botón para guardar su nueva contraseña.\\n<!--  -->\\n\\n\\n","section":"¿Cómo puedo cambiar o restablecer mi contraseña?","version":"current","path":"/es/kb/personal-settings/how-can-i-change-or-reset-my-password#para-cambiar-su-contraseña-de-fintesk","category":"default"},{"title":"Para restablecer su contraseña de Fintesk","content":"Si intenta iniciar sesión y no recuerda su contraseña de inicio de sesión, simplemente haga clic en la opción“Olvidaste tu contraseña?” listada en el cuadro de contraseña.\\nSi actualmente ha iniciado sesión en Fintesk pero aún no recuerda sus credenciales de contraseña actuales, primero deberá cerrar la sesión de su cuenta..\\n<!--  -->\\n\\nDesde allí, simplemente ingrese su dirección de correo electrónico y haga clic en “Obtenga una nueva contraseña”. Recibirá un correo electrónico de restablecimiento de contraseña en la dirección de correo electrónico proporcionada.\\nSi no recibe un correo electrónico de restablecimiento de contraseña en unos minutos, es posible que haya ingresado una dirección de correo electrónico que no está asociada con una cuenta de usuario de Fintesk.Sugerimos intentarlo nuevamente, con su dirección de correo electrónico de inicio de sesión conocida.\\n","section":"¿Cómo puedo cambiar o restablecer mi contraseña?","version":"current","path":"/es/kb/personal-settings/how-can-i-change-or-reset-my-password#para-restablecer-su-contraseña-de-fintesk","category":"default"},{"title":"Eliminar artículos","content":":::tip\\nNota: Recomendamos antes de la eliminación la exportación de tus datos si planeas eliminar, para que, puedas agregar nuevamente los datos a tu cuenta más adelante si es necesario.\\n:::\\nLa forma más efectiva de liberar espacio en su cuenta es eliminar los datos que ya no son necesarios. Puede eliminar elementos individuales en sus \\"vistas de detalle\\", o en forma masiva utilizando la \\"vista de la lista\\".\\n","section":"¿Cómo puedo limpiar mi cuenta y liberar espacio?","version":"current","path":"/es/kb/personal-settings/how-can-i-free-up-space#eliminar-artículos","category":"default"},{"title":"Eliminar con la \\"vista de detalle\\"","content":":::tip\\nNota: Las actividades no se pueden eliminar utilizando la \\"vista de detalle\\".\\n:::\\nPara eliminar un solo elemento en Fintesk (negocio, contacto, producto), vaya a la \\"vista de detalle\\" y haga clic ”...“ > Borrar.\\n<!--  -->\\n\\n<!-- Deleting with the list view\\nIf you want to delete an activity, or delete items in bulk, go to your list view and select the items you want to delete then click the trash can icon.\\n\\nYou can create and apply filters in the list view if you want to specify which items to delete, rather than selecting them individually. -->\\n\\n","section":"¿Cómo puedo limpiar mi cuenta y liberar espacio?","version":"current","path":"/es/kb/personal-settings/how-can-i-free-up-space#eliminar-con-la-vista-de-detalle","category":"default"},{"title":"Eliminar campos personalizados","content":":::tip\\nNota: Recomendamos limitar los redundancias al crear campos personalizados para optimizar el almacenamiento, como crear múltiples campos personalizados bajo el mismo nombre para diferentes elementos (por ejemplo, crear un campo \\"origen\\" para negocios y personas.)\\n:::\\nLos campos personalizados se ven afectados por los límites de uso, por lo que saber cómo eliminarlos es importante para la gestión de almacenamiento.\\n","section":"¿Cómo puedo limpiar mi cuenta y liberar espacio?","version":"current","path":"/es/kb/personal-settings/how-can-i-free-up-space#eliminar-campos-personalizados","category":"default"},{"title":"Campos personalizados","content":"Ir a Ajustes > Campos de datos, encuentre el campo deseado y haga clic ”...“ > Borrar.\\n<!--  -->\\n\\n\\n","section":"¿Cómo puedo limpiar mi cuenta y liberar espacio?","version":"current","path":"/es/kb/personal-settings/how-can-i-free-up-space#campos-personalizados","category":"default"},{"title":"Gestión de negocios","content":"Hay algunas acciones disponibles para negocios, relacionadas con la gestión de datos, que otros elementos no tienen.\\nEsto puede ser importante, especialmente porque la cantidad de negocios abiertos que puede tener se ve afectada por los límites de uso.\\n<!-- Converting deals to leads\\n:::tip\\nNote: The Rotting feature is a great way to see which deals have been stagnating in your pipeline, and potentially need to be moved to your Leads inbox. For more information about that tool, check out this article.\\n:::\\nIf you have an excess of open deals in your account and need to remove some to make room for new deals, you can move those deals into your Leads inbox.\\n\\nYou can do this in two ways:\\nfrom the deal detail view\\n\\nfrom the list view\\n\\n:::tip\\nNote: You can convert up to 100 deals at a time.\\n::: -->\\n","section":"¿Cómo puedo limpiar mi cuenta y liberar espacio?","version":"current","path":"/es/kb/personal-settings/how-can-i-free-up-space#gestión-de-negocios","category":"default"},{"title":"Reapertura de Negocios","content":":::tip\\nNota: Los Negocios eliminados se pueden recuperar durante 30 días después de la eliminación inicial.\\n:::\\nSi ha eliminado Negocios y desea agregarlos nuevamente a su cuenta, comience aplicando el filtro: todas los negocios eliminados.\\n<!--  -->\\n\\nLuego seleccione el negocio deseado y, en la vista de detalle, hacer clic \\"Reabrir\\".\\n<!--  -->\\n\\n","section":"¿Cómo puedo limpiar mi cuenta y liberar espacio?","version":"current","path":"/es/kb/personal-settings/how-can-i-free-up-space#reapertura-de-negocios","category":"default"},{"title":"Estatus del negocio","content":":::tip\\nNota: Por defecto, la vista de embudos solo se muestran Negocios abiertos. Sin embargo, puede aplicar filtros a su vista de embudos para mostrar los negocios ganados y perdidas también. Para obtener más información sobre el filtrado en Fintesk, verificar esta guía.\\n:::\\nMantener negocios ganados y perdidos abiertos afecta sus informes y estadísticas, ya que se cuentan para el almacenamiento de su negocio.\\nSi sus negocios ya estaban ganados o perdidos, recomendamos marcarlos coherentemente. Puedes hacer esto:\\n<!-- in two different ways: -->\\nVista de detalle\\n<!--  -->\\n\\n<!-- - List view\\n-->\\n\\n","section":"¿Cómo puedo limpiar mi cuenta y liberar espacio?","version":"current","path":"/es/kb/personal-settings/how-can-i-free-up-space#estatus-del-negocio","category":"default"},{"title":"Notas","content":"También puede usar notas en lugar de campos personalizados para ahorrar espacio.\\nPor ejemplo, en lugar de crear un campo personalizado de texto para la descripción del cliente, Puede agregar esa información como una nota.\\n<!--  -->\\n\\n:::tip\\nNota: Puede exportar sus notas cuando las necesite. Obtenga más información sobre la exportación de notas en este artículo.\\n:::\\n","section":"¿Cómo puedo limpiar mi cuenta y liberar espacio?","version":"current","path":"/es/kb/personal-settings/how-can-i-free-up-space#notas","category":"default"},{"title":"Límites de uso por plan","content":"<table>\\n<tr>\\n<td></td>\\n<td>Free</td>\\n<td>Essential</td>\\n<td>Advanced</td>\\n<td>Professional</td>\\n</tr>\\n<tr>\\n<td>Negocios abiertos (por empresa)</td>\\n<td>100</td>\\n<td>500</td>\\n<td>1,000</td>\\n<td>10,000</td>\\n</tr>\\n<tr>\\n<td>Campos personalizados (por empresa)</td>\\n<td>10</td>\\n<td>30</td>\\n<td>50</td>\\n<td>100</td>\\n</tr>\\n<!-- <tr>\\n<td>Custom visibility groups (per company)</td>\\n<td></td>\\n<td>N/A</td>\\n<td>N/A</td>\\n<td>3</td>\\n</tr>\\n<tr>\\n<td>Custom permission sets (per company)</td>\\n<td></td>\\n<td>N/A</td>\\n<td>N/A</td>\\n<td>2</td>\\n</tr>\\n<tr>\\n<td>Teams (per company)</td>\\n<td></td>\\n<td>N/A</td>\\n<td>N/A</td>\\n<td>3</td>\\n</tr> -->\\n</table>\\n<!-- <table>\\n<tr>\\n<td></td>\\n<td>Free</td>\\n<td>Essential</td>\\n<td>Advanced</td>\\n<td>Professional</td>\\n<td>Power</td>\\n<td>Enterprise</td>\\n</tr>\\n<tr>\\n<td>Open deals (per company)</td>\\n<td></td>\\n<td>3,000</td>\\n<td>10,000</td>\\n<td>100,000</td>\\n<td>200,000</td>\\n<td>Unlimited</td>\\n</tr>\\n<tr>\\n<td>Custom fields (per company)</td>\\n<td></td>\\n<td>30</td>\\n<td>100</td>\\n<td>300</td>\\n<td>500</td>\\n<td>Unlimited</td>\\n</tr>\\n<tr>\\n<td>Insights reports (per user)</td>\\n<td></td>\\n<td>15</td>\\n<td>30</td>\\n<td>150</td>\\n<td>250</td>\\n<td>Unlimited</td>\\n</tr>\\n<tr>\\n<td>Custom visibility groups (per company)</td>\\n<td></td>\\n<td>N/A</td>\\n<td>N/A</td>\\n<td>3</td>\\n<td>15</td>\\n<td>Unlimited</td>\\n</tr>\\n<tr>\\n<td>Custom permission sets (per company)</td>\\n<td></td>\\n<td>N/A</td>\\n<td>N/A</td>\\n<td>2</td>\\n<td>10</td>\\n<td>Unlimited</td>\\n</tr>\\n<tr>\\n<td>Teams (per company)</td>\\n<td></td>\\n<td>N/A</td>\\n<td>N/A</td>\\n<td>3</td>\\n<td>15</td>\\n<td>Unlimited</td>\\n</tr>\\n<tr>\\n<td>Automations (active per user)</td>\\n<td></td>\\n<td>N/A</td>\\n<td>30</td>\\n<td>60</td>\\n<td>90</td>\\n<td>180</td>\\n</tr>\\n<tr>\\n<td>Multiple email sync (per user)</td>\\n<td></td>\\n<td>N/A</td>\\n<td>1 email account</td>\\n<td>2 email accounts</td>\\n<td>3 email accounts</td>\\n<td>5 email accounts</td>\\n</tr>\\n</table> -->\\n:::info\\nNota: Un negocio abierto se refiere a un negocio que no ha sido ganado, perdido o eliminado.\\n<!-- Report limits are per user and. -->\\nLos límites de negocios abiertos y campos personalizados son por empresa.\\n:::\\n<!--\\n","section":"Límites de uso en Fintesk","version":"current","path":"/es/kb/personal-settings/usage-limits-in-fintesk#límites-de-uso-por-plan","category":"default"},{"title":"Automations tool","content":"Some features of the Automations tool also depend on the plan you’re on.\\n<table>\\n<tr>\\n<td>Advanced</td>\\n<td>Professional</td>\\n<td>Power</td>\\n<td>Enterprise</td>\\n</tr>\\n<tr>\\n<td>30 active automations per user</td>\\n<td>60 active automations per user</td>\\n<td>90 active automations per user</td>\\n<td>100 active automations per user</td>\\n</tr>\\n<tr>\\n<td>10 actions per automation</td>\\n<td>10 actions per automation</td>\\n<td>10 actions per automations</td>\\n<td>10 actions per automation</td>\\n</tr>\\n<tr>\\n<td>3 delays per automation</td>\\n<td>10 delays per automation</td>\\n<td>10 delays per automations</td>\\n<td>10 delays per automation</td>\\n</tr>\\n<tr>\\n<td>Total Time Limit: 90 days</td>\\n<td>Total Time Limit: 90 days</td>\\n<td>Total Time Limit: 90 days</td>\\n<td>Total Time Limit: 90 days</td>\\n</tr>\\n</table> -->\\n\\n<!--\\n","section":"Límites de uso en Fintesk","version":"current","path":"/es/kb/personal-settings/usage-limits-in-fintesk#automations-tool","category":"default"},{"title":"How can I view my usage?","content":"You can view your usage details by going to Settings > Company > Usage.\\n\\nYou’ll be notified in-app and by email when you reach 80% and 100% of a limit. -->\\n\\n","section":"Límites de uso en Fintesk","version":"current","path":"/es/kb/personal-settings/usage-limits-in-fintesk#how-can-i-view-my-usage","category":"default"},{"title":"¿Qué sucede cuando llegué a los límites de uso?","content":"<!-- Fintesk won’t delete any of your data when you’re over a limit. However, you’ll be blocked from manually adding more of the exceeded data until you free up space or upgrade to a higher plan. -->\\nFintesk no eliminará ninguno de sus datos cuando supere un límite. Sin embargo, se le bloqueará que agregue manualmente más de los datos superados por el plan, hasta que libere espacio o actualice a un plan superior.\\n<!--  -->\\n<!-- When you’re at an open deal limit, excess deals created by automations, LeadBooster (Chatbot or Web Forms), public API, or during an import will instead be sent to your deals waitlist or import skip file, respectively. Both of these can be re-imported when there is more space in your account. -->\\nCuando te encuentras en el límite de negocios abiertos, negocios creados por la API pública, o durante una importación en su lugar serán enviados al archivo de omisión de importación. Estos negocios se pueden volver a importar cuando haya más espacio en su cuenta.\\n<!-- Note: Deals that have been on the waitlist for one year will be automatically deleted. -->\\nObtenga más información sobre cómo liberar espacio en su cuenta en este artículo.\\n<!-- Note: Usage limits are also applied to the number of total workflows you can have active in your account. For more information about these limits, read this article. -->\\n","section":"Límites de uso en Fintesk","version":"current","path":"/es/kb/personal-settings/usage-limits-in-fintesk#qué-sucede-cuando-llegué-a-los-límites-de-uso","category":"default"},{"title":"¿Cómo puedo eliminar un negocio en la vista de embudos?","content":"<p>&lt;!-- ../../kb/pipeline-view/how-can-i-delete-a-deal-in-the-pipeline-view.md --&gt;</p>\\n<p>Para eliminar un negocio en la <strong>vista de embudo</strong>, haga clic y mantenga presionado el negocio que desea eliminar y arrastre al botón <strong>&quot;Eliminar&quot;</strong> en la parte inferior de la pantalla.</p>\\n<p>&lt;!-- :::tip\\n<strong>Nota:</strong> You must be a deal admin or a regular user with the correct permission to delete deals in Fintesk. Account settings admins can provide permission for other users to delete deals by going to <strong>Settings &gt; Manage users &gt;</strong> <a href=\\"https://app.fintesk.com/settings/company_settings#permissions\\">Permission sets</a> and enabling the “<strong>Delete deals</strong>” option.\\n::: --&gt;\\n&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screen%20Capture%20on%202023-04-20%20at%2007-51-16.gif\\" alt=\\"1\\"> --&gt;</p>\\n<p><img src=\\"../../kb/pipeline-view/how-can-i-delete-a-deal-in-the-pipeline-view/hcida01.gif\\" alt=\\"hcida01\\"></p>\\n<p>:::tip\\n<strong>Nota:</strong> Los elementos eliminados se pueden reabrir hasta 30 días después de la eliminación. Después de 30 días, los elementos se eliminan permanentemente y no se puede acceder o reabrir los elementos. Obtenga más información sobre cómo eliminar elementos en Fintesk en <a href=\\"../../kb/getting-started/how-can-i-delete-items-in-fintesk\\">este artículo</a>.\\n:::</p>\\n","section":"¿Cómo puedo eliminar un negocio en la vista de embudos?","version":"current","path":"/es/kb/pipeline-view/how-can-i-delete-a-deal-in-the-pipeline-view","category":"default"},{"title":"¿Cómo puedo ver negocios en un embudo diferente?","content":"<p>&lt;!-- ../../kb/pipeline-view/how-can-i-see-deals-in-a-different-pipeline.md --&gt;</p>\\n<p>&lt;!-- # How can I see deals in a different pipeline? --&gt;</p>\\n<p>Para ver otro embudo en su cuenta de Fintesk, haga clic en el menú desplegable y seleccione el embudo que desea ver.</p>\\n<p>:::tip\\n<strong>Nota:</strong> Los usuarios regulares solo pueden ver embudos a las que se les ha dado acceso via <strong><a href=\\"https://app.fintesk.com/settings/company/manage-users#visibility-groups?utm_source=fintesk-docs\\">Grupos de visibilidad</a></strong>.\\n:::</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screen%20Capture%20on%202023-04-27%20at%2015-15-49.gif\\" alt=\\"1\\"> --&gt;</p>\\n<p><img src=\\"../../kb/pipeline-view/how-can-i-see-deals-in-a-different-pipeline/hcisd01.gif\\" alt=\\"hcisd01\\"></p>\\n","section":"¿Cómo puedo ver negocios en un embudo diferente?","version":"current","path":"/es/kb/pipeline-view/how-can-i-see-deals-in-a-different-pipeline","category":"default"},{"title":"Vista de Embudo","content":"<p>&lt;!-- ../../kb/pipeline-view/the-pipeline-view.md --&gt;</p>\\n<p>&lt;!-- # Pipeline view --&gt;</p>\\n<p>Fintesk lo ayuda a realizar un seguimiento del progreso de su negocio al proporcionarle información sobre sus negocios en función de qué etapa de embudo ocupa en su <strong>Vista de embudos</strong>.</p>\\n<p>Las etapas del embudo son definidas por un usuario administrador en la cuenta de la empresa Fintesk. Puede obtener más información sobre cómo personalizar sus etapas en <a href=\\"../../kb/pipelines/how-can-i-customize-my-pipeline-stages\\">este artículo</a>.</p>\\n<p><img src=\\"../../kb/pipeline-view/the-pipeline-view/tpv02.png\\" alt=\\"tpv02\\">\\n<img src=\\"../../kb/pipeline-view/the-pipeline-view/tpv01.jpeg\\" alt=\\"tpv01\\"></p>\\n<p>La vista de embudo muestra los negocios de usuarios/propietarios específicos. Para filtrar para los negocios propiedad de un usuario específico y comprender su progreso, haga clic en el botón Filtro: &quot;Todos&quot; en la captura de pantalla anterior, y seleccione un usuario.</p>\\n<p>Para comprender mejor el estado de los negocios en su vista de embudos, sugerimos usar <strong><a href=\\"../../kb/pipeline-view/the-rotting-feature\\">función de estancamiento</a></strong>.</p>\\n<p>&lt;!-- If you are just getting started with Fintesk, you can check out our &quot;<strong>Organize your sales data</strong>&quot; <a href=\\"https://www.pipedrive.com/academy/courses/organize-your-sales-data?ref=kb_article\\">Fintesk Academy course</a>. --&gt;</p>\\n","section":"Vista de Embudo","version":"current","path":"/es/kb/pipeline-view/","category":"default"},{"title":"Configuración de la función de estancamiento","content":"<!-- Note: Check out our “Never forget a follow-up” Academy course if you’re just getting started with Fintesk. -->\\n<!--  -->\\nPara definir los períodos de estancamiento para sus etapas de embudos:\\nVaya a la Vista de embudo y presione el icono \\"lápiz\\".\\n<!--  -->\\n\\nHaga clic en el boton “Estancamiento en (días)”. Defina el número de días inactivos después de lo cual se considera un negocio Estancado en esta etapa. Haga clic en el \\"Guardar cambios\\" en la parte superior derecha.\\n<!--  -->\\n\\n\\n","section":"La función de estancamiento","version":"current","path":"/es/kb/pipeline-view/the-rotting-feature#configuración-de-la-función-de-estancamiento","category":"default"},{"title":"¡Mis negocios están estancados!¿Qué debo hacer?","content":"Sabrá que un negocio se encuentra estancado por el color rojo en el listado de negocios en su vista de embudos.\\n<!--  -->\\n\\nSi su negocio está estancado, puede restaurarlo por:\\nProgramar una nueva actividad para el negocio\\nEdición de cualquier detalle del negocio, como campos personalizados, fecha de cierre esperada, valor, etc.\\n\\n","section":"La función de estancamiento","version":"current","path":"/es/kb/pipeline-view/the-rotting-feature#mis-negocios-están-estancadosqué-debo-hacer","category":"default"},{"title":"¿Las actividades futuras harán que los negocios se estanquen?","content":"La función de estancado no considera la próxima fecha de actividad, por lo que cualquier negocio que tenga una actividad programada para un futuro aún puede estar estancada.\\nEn esta situación, reconsidere lo que significan etapas y actividades en la cuenta Fintesk de su empresa:\\nSi establece un tiempo de estancado extendido (por ejemplo, 20 días) para acomodar actividades en el futuro, puede afectar las metas y la productividad a corto plazo\\nDel mismo modo, si establece tiempos de estancado más cortos, puede ser difícil administrar y clasificar los negocios donde las actividades se deben completar en el futuro\\nUna estrategia útil puede ser crear múltiples embudos o etapas en función de que tan pronto desea que ciertas actividades completen o se cierren.\\n:::tip\\nNota: Para obtener más información sobre cómo crear múltiples embudos, puede consultar este artículo, o leer este otro artículo para obtener información sobre la creación de nuevas etapas.\\n:::\\n","section":"La función de estancamiento","version":"current","path":"/es/kb/pipeline-view/the-rotting-feature#las-actividades-futuras-harán-que-los-negocios-se-estanquen","category":"default"},{"title":"¿Cómo puedo agregar una etapa a mi embudo?","content":"<p>&lt;!-- ../../kb/pipelines/how-can-i-add-a-stage-to-my-pipeline.md --&gt;</p>\\n<p>&lt;!-- # How can I add a stage to my pipeline? --&gt;</p>\\n<p>Para agregar una nueva etapa a su embudo, haga clic en el icono <strong>lápiz</strong> junto al nombre de su embudo o pasee su cursor sobre un embudo después de abrir el menú desplegable.</p>\\n<p>:::tip\\n<strong>Nota:</strong> Esta acción solo está disponible para que los usuarios administrativos o usuarios regulares con el permiso requerido.\\n:::</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/add%20new%20stage%204.jpg\\" alt=\\"1\\"> --&gt;</p>\\n<p><img src=\\"../../kb/pipelines/how-can-i-add-a-stage-to-my-pipeline/hcias01.jpeg\\" alt=\\"hcias01\\"></p>\\n<p>Luego haga clic en el <strong>&quot;+&quot;</strong> entre dos etapas para agregar una nueva en esa ubicación.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/add%20stage%201.jpg\\" alt=\\"1\\"> --&gt;</p>\\n<p><img src=\\"../../kb/pipelines/how-can-i-add-a-stage-to-my-pipeline/hcias02.jpeg\\" alt=\\"hcias02\\"></p>\\n<p>Verá una nueva etapa en la ubicación que eligió, donde puede editar la configuración de nombre, probabilidad y estancamiento.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/add%20stage%204.jpg\\" alt=\\"1\\"> --&gt;</p>\\n<p><img src=\\"../../kb/pipelines/how-can-i-add-a-stage-to-my-pipeline/hcias03.jpeg\\" alt=\\"hcias03\\"></p>\\n","section":"¿Cómo puedo agregar una etapa a mi embudo?","version":"current","path":"/es/kb/pipelines/how-can-i-add-a-stage-to-my-pipeline","category":"default"},{"title":"Consejos sobre cómo crear etapas para su empresa","content":"Use el pretérito indefinido o pasado simple Ejemplo.\\"Reunión acordada\\" en lugar de solo \\"reunión\\".\\n\\n\\nCrear etapas que correspondan al proceso de compra de los clientes ¿Cómo sería su proceso de compra, qué tiene que suceder para que te compren?\\n\\n\\nRevisa tus etapas luego Si algunas etapas parecen confusas, puede cambiar el nombre, eliminarlas o agregar nuevas para mayor claridad.\\n\\n\\n<!-- :::tip\\nNote: Learn the nine essential sales stages for effective sales cycle management in this blog post.\\n::: -->\\n\\n","section":"¿Cómo puedo personalizar mis etapas de embudos?","version":"current","path":"/es/kb/pipelines/how-can-i-customize-my-pipeline-stages#consejos-sobre-cómo-crear-etapas-para-su-empresa","category":"default"},{"title":"Cómo editar sus etapas de embudos","content":"Ir a vista de embudo y haga clic en el icono del lápiz a la derecha del nombre del embudo.\\n<!--  -->\\n\\nDesde aquí, puede editar atributos de etapa como nombre, probabilidad y días de estancamiento.\\n<!--  -->\\n\\nTambién puede agregar una nueva etapa usando el \\"+\\" o eliminar una etapa haciendo clic en \\"Eliminar etapa\\" en la parte inferior de la pantalla.\\n<!--  -->\\n\\n","section":"¿Cómo puedo personalizar mis etapas de embudos?","version":"current","path":"/es/kb/pipelines/how-can-i-customize-my-pipeline-stages#cómo-editar-sus-etapas-de-embudos","category":"default"},{"title":"Para agregar un nuevo embudo a su cuenta de Fintesk:","content":":::tip\\nNota: Actualmente no hay límite en la cantidad de embudos que puede agregar a su cuenta. Para los planes pagos.\\n:::\\nPara crear un embudo:\\nObtenga más información sobre Software de gestión de embudos\\nVaya a la Vista de embudos y haga clic en el menú desplegable del embudo.\\nHaga clic en \\"+ nuevo embudo\\".\\n<!--  -->\\n\\nEl embudo se agrega a su cuenta y ahora puede comenzar a editar sus etapas. Una vez que las etapas sean de su gusto u especificación, presione \\"Guardar\\".\\n<!--  -->\\n\\n\\n","section":"¿Cómo puedo tener múltiples embudos?","version":"current","path":"/es/kb/pipelines/how-can-i-have-multiple-pipelines#para-agregar-un-nuevo-embudo-a-su-cuenta-de-fintesk","category":"default"},{"title":"¿Cuándo debo usar múltiples embudos?","content":"El uso de múltiples embudos puede ser bastante útil en ciertas situaciones. Por ejemplo:\\nPuede ser una empresa que ofrece diferentes tipos de productos/servicios que puede necesitar sus propias etapas propietarias durante el cierre de un negocio.\\nEs posible que tenga un producto o servicio que venda en su empresa. El servicio podría tener fácilmente un embudo más largo.\\nPuede tener campos personalizados específicos del embudo, para mantener sus procesos e información bien categorizados.\\nNo se sugiere para:\\nClasificando sus negocios por ubicación o tipo de industria (o cualquier otra cosa) si las etapas son las mismas.Sugerimos usar campos personalizados en cambio.\\nSeparar negocios de un vendedor. Fintesk ya lo hace automáticamente a través del campo propietario.\\n<!-- - To track the delivery of sold items after they’re won. Instead, you can use the Projects feature. -->\\nDe esta manera, tendrá la oportunidad de ver el embudo completa en una vista, pero también puede crear filtros para ver cualquier segmento del embudo que desee.\\n:::tip\\nNota: No es posible obtener una vista combinada de todas los embudos, incluso si los nombres de etapa son los mismos.Dentro de la base de datos Fintesk, esos embudos y etapas aún están separadas.\\n:::\\n","section":"¿Cómo puedo tener múltiples embudos?","version":"current","path":"/es/kb/pipelines/how-can-i-have-multiple-pipelines#cuándo-debo-usar-múltiples-embudos","category":"default"},{"title":"¿Puedo agregar campos adicionales al modal \\"Agregar nuevo producto\\"?","content":"<p>&lt;!-- ../../kb/products/can-i-add-extra-fields-to-the-add-new-product-modal.md --&gt;</p>\\n<p>&lt;!-- # Can I add extra fields to the &quot;Add new product&quot; modal? --&gt;</p>\\n<p>&lt;!-- <strong>Note:</strong> The <strong>Products</strong> feature is one of the many useful features of Fintesk’s Advanced, Professional and Enterprise plans. To learn how to switch plans, click <a href=\\"billing/your-fintesk-subscription-plan/how-can-i-switch-to-a-different-fintesk-plan-or-change-my-billing-frequency\\">here</a>. --&gt;</p>\\n<p>Si desea que aparezca alguno de sus campos de productos personalizados en el <strong>Agregar nuevo producto</strong> modal, vaya a <strong>Configuración de Empresa &gt; Campos de datos&gt; <a href=\\"https://app.fintesk.com/settings/company/fields#table_column/edit/products?utm_source=fintesk-docs\\">Producto</a></strong> y haga clic en el campo que le gustaría que aparezca en el <strong>diálogo de agregar nuevo</strong>. Entonces puedes marcar la opción &quot;<strong>Aparece en la vista &quot;Agregar&quot;</strong>&quot; para luego acceder al campo al agregar un nuevo producto a Fintesk.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screen_Capture_on_2020-09-01_at_15-43-31.gif\\" alt=\\"1\\"> --&gt;</p>\\n<p><img src=\\"../../kb/products/can-i-add-extra-fields-to-the-add-new-product-modal/ciaef01.gif\\" alt=\\"ciaef01\\"></p>\\n","section":"¿Puedo agregar campos adicionales al modal \\"Agregar nuevo producto\\"?","version":"current","path":"/es/kb/products/can-i-add-extra-fields-to-the-add-new-product-modal","category":"default"},{"title":"¿Puedo tener un producto con diferentes variaciones de precios?","content":"<p>&lt;!-- ../../kb/products/can-i-have-one-product-in-different-price-variations.md --&gt;</p>\\n<p>&lt;!-- # Can I have one product in different price variations? --&gt;</p>\\n<p>Puede crear diferentes variaciones de precio para el mismo producto con nuestra característica <strong>Variaciones de precios</strong>. Esta característica también se puede utilizar como una forma de crear variaciones generales para el mismo producto, ya que puede crear variaciones de productos con diferentes nombres, precios unitarios, monedas y costos por unidad.</p>\\n<p>Las variaciones se pueden configurar desde la <strong>vista de detalle</strong> del producto en cuestión.</p>\\n<p><img src=\\"../../kb/products/can-i-have-one-product-in-different-price-variations/cihopid01.jpeg\\" alt=\\"cihopid01\\"></p>\\n<p>Una vez que agregue una variación del producto, podrá seleccionar esta variación cuando <a href=\\"../../kb/products/how-can-i-link-products-to-a-deal\\">vincule este producto con un negocio</a>.</p>\\n<p><img src=\\"../../kb/products/can-i-have-one-product-in-different-price-variations/cihopid02.jpeg\\" alt=\\"cihopid02\\"></p>\\n","section":"¿Puedo tener un producto con diferentes variaciones de precios?","version":"current","path":"/es/kb/products/can-i-have-one-product-in-different-price-variations","category":"default"},{"title":"¿Puedo importar productos y vincularlos automáticamente a los negocios?","content":"<p>&lt;!-- ../../kb/products/can-i-import-products-and-automatically-link-them-to-deals.md --&gt;</p>\\n<p>&lt;!-- # Can I import products and automatically link them to deals? --&gt;</p>\\n<p>Mientras pueda <a href=\\"../../kb/importing-data/importing-data-into-fintesk-with-spreadsheets\\">importar</a> una lista de <a href=\\"../../kb/products\\">productos</a> en Fintesk, desafortunadamente, no puede adjuntar estos productos a los negocios a través del proceso de importación.</p>\\n<p>Actualmente, esto solo se puede hacer manualmente o a través de nuestro<a href=\\"../../fintesk/api/v1\\">API</a> si usted es un desarrollador calificado o tiene personal de ingeniería dedicado a su disposición.</p>\\n","section":"¿Puedo importar productos y vincularlos automáticamente a los negocios?","version":"current","path":"/es/kb/products/can-i-import-products-and-automatically-link-them-to-deals","category":"default"},{"title":"Agregar productos a los negocios","content":"<!-- You can add products directly to deals in the products list view by clicking on the checkbox next to a product and then clicking on the “Attach to deal” button.\\nYou can select more than one product if you want to bulk-add products to a deal.\\n-->\\nEn la ventana que aparece, ingrese el título del negocio al que desea vincular su producto. El precio y la moneda predeterminan el precio que ha guardado en su producto, pero puede personalizar esto a otra moneda y cambiar el precio antes de vincularlo al negocio.\\n<!--  -->\\n\\n:::tip\\nNota: Cualquier precio personalizado creado en esta ventana solo se aplicará para ese negocio y no se guardará como una entrada de precios en la vista Detalle/Lista del Producto.\\n:::\\nHaga clic en \\"Agregar producto\\" para adjuntar más de un producto al negocio elegido a la vez.\\nPuede eliminar los productos del negocio haciendo clic en el icono de basura en el lado derecho de cada entrada.\\n<!--  -->\\n\\nOtra forma de vincular productos a negocios es hacer clic en \\"+ productos\\" a la vista de detalle de cualquier negocio.\\n<!--  -->\\n\\n\\n","section":"How can I link products to a deal?","version":"current","path":"/es/kb/products/how-can-i-link-products-to-a-deal#agregar-productos-a-los-negocios","category":"default"},{"title":"Opciones de impuestos","content":"\\n:::tip\\nNota: Cualquier valor de impuesto debe agregarse manualmente, ya sea en los detalles del producto o en la ventana Agregar productos del negocio.\\n:::\\n","section":"How can I link products to a deal?","version":"current","path":"/es/kb/products/how-can-i-link-products-to-a-deal#opciones-de-impuestos","category":"default"},{"title":"Impuesto incluido","content":"Si seleccionas Impuesto incluido\\" para sus productos, el porcentaje fiscal ya se incluirá en el precio.\\n<!--  -->\\n\\n:::tip\\nNota: El precio del producto y el valor del negocio incluyen impuestos.\\n:::\\n<!-- Tax exclusive\\nNota: The tax exclusion feature is currently in beta and available to a closed group of users. It will be released to more users at a later date.\\nIf you select ”Tax exclusive” for your products, the tax will **not** be included in the subtotal. The tax percentage you enter into the tax field will be reflected in the total.\\n\\n:::tip\\nNota: The product price and the deal value exclude tax.\\n::: -->\\n","section":"How can I link products to a deal?","version":"current","path":"/es/kb/products/how-can-i-link-products-to-a-deal#impuesto-incluido","category":"default"},{"title":"Sin impuestos","content":"Si seleccionas ”Sin impuestos\\" Para sus productos, no se agregará impuestos al total de su producto.\\n<!--  -->\\n\\n:::tip\\nNota: Cada negocio solo puede tener productos en un tipo de moneda (por ejemplo, USD o CAD, no ambos). Si desea agregar una variación del producto en el mismo tipo de moneda, puede investigar la característica Variaciones de precios.\\n:::\\n","section":"How can I link products to a deal?","version":"current","path":"/es/kb/products/how-can-i-link-products-to-a-deal#sin-impuestos","category":"default"},{"title":"Encuentra la función de productos","content":"La función Productos está disponible en todos los planes.\\n<!-- and you can enable or disable it by going to Tools and apps > Products. Here, you can also select the default tax setting. -->\\n<!--  -->\\n<!-- Once you enable it, click on the Products icon on the main navigation bar. -->\\nHaga clic en el icono Productos en la barra de navegación principal.\\n<!--  -->\\n\\n\\n","section":"Productos","version":"current","path":"/es/kb/products#encuentra-la-función-de-productos","category":"default"},{"title":"Agregar nuevos productos","content":"\\nPara agregar un producto a su cuenta de Fintesk, vaya a la pestaña Productos encontrada en la barra superior de la aplicación Fintesk y haga clic en \\"+ Agregar producto\\".\\n<!--  -->\\n:::tip\\nNota: \\"Nombre\\" y \\"precio unitario\\" son campos obligatorios.\\n:::\\nUna vez que guarde el producto, podrá editar estos campos adicionales en sus productos Vista de detalles o Vista de lista.\\nActivo\\nCategoría\\nDescripción\\nNombre\\nPropietario\\nPrecio\\nCódigo de producto\\nImpuesto\\nUnidad\\nPrecios unitarios\\nVisibilidad\\nProducto campos personalizados\\n<!-- You can also add new products in the “Add deal“ window when adding new deals to your Fintesk account.\\n\\nNota: To add a new category, type the name of your category in the category search box and click on “Add as new category”. You must be a \\"global permissions\\" admin to add categories. -->\\n\\n","section":"Productos","version":"current","path":"/es/kb/products#agregar-nuevos-productos","category":"default"},{"title":"Vista de lista de productos","content":"En la vista de lista, podrá ver sus productos adicionales y editar los detalles del producto directamente.\\nPuedes filtrar para productos alfabéticamente en la esquina superior izquierda de la pantalla o cree filtros personalizados.\\n<!--  -->\\n\\nVerá campos de tipo de producto como una opción dentro de sus filtros. Esto le permite reducir sus búsquedas o exportar sus datos en base a los campos específicos del producto.\\n<!--  -->\\n\\n<!-- To bulk edit your products, you can click on the checkboxes to the left of your products and select the field you want to edit in the bulk edit panel that appears on the right side.\\n-->\\n<!-- To delete products, select your products and click on the trash can icon that appears at the top of the Products page. -->\\n<!--  -->\\n\\n\\n","section":"Productos","version":"current","path":"/es/kb/products#vista-de-lista-de-productos","category":"default"},{"title":"Vista de detalle del producto","content":"\\nSi hace clic en el nombre del producto desde la vista de lista de productos, lo llevará a la página de detalles del producto donde puede ver y editar información relacionada con su producto.\\n<!--  -->\\n\\n","section":"Productos","version":"current","path":"/es/kb/products#vista-de-detalle-del-producto","category":"default"},{"title":"Editar los detalles del producto","content":"Para editar los valores de los campos, haga clic en el icono de lápiz en la vista de detalles del producto.\\n<!--  -->\\n\\n<!-- If you want to add product custom fields in this section click on More actions > Customize fields. -->\\n<!-- \\n -->\\n","section":"Productos","version":"current","path":"/es/kb/products#editar-los-detalles-del-producto","category":"default"},{"title":"Ver y agregar precios de productos","content":"La pestaña de precios le mostrará todas las opciones de precios para ese producto. Cada producto puede tener más de un precio listado a la vez. Para editar o eliminar los precios de los productos existentes, puede pasar sobre el precio y hacer clic en el ícono lápiz o basura.\\n<!--  -->\\n\\nPrecio unitario - El precio de cada unidad se vendió\\nCosto por unidad - Costo relacionado con cada unidad vendida del producto\\nCosto directo - Costo relacionado con el desarrollo o producción del producto\\n:::tip\\nNota: Solo se mostrará el precio unitario en la vista de lista de productos y la vista de detalle. El costo por unidad y Costo directo son campos puramente de referencia.\\n:::\\nSi hace clic en el botón “+ Agregar precio”, puede agregar un nuevo precio para su producto.\\n<!--  -->\\n\\n:::tip\\nNota: Solo podrá agregar una entrada de precio para cada tipo de moneda.\\n:::\\n<!-- ### View deals linked to the product\\nThe deals tab will give a list of all of the deals that currently have that product linked. You can filter to view by deal status in the row above the list. You can learn how to link products to deals in this article.\\n\\nTo adjust the columns in your deals list, you can click on the gear icon on the right side and adjust your columns accordingly.\\nTo export the list you see to a spreadsheet, you can click on the “Export” button. -->\\n<!-- ### View and upload files\\nIn the files tab, you can see any files that have been uploaded to this product, as well as upload additional files from your device.\\n\\nIf you click on the \\"[...]\\" button you can add a description, download, or delete your file.\\n-->\\n\\n","section":"Productos","version":"current","path":"/es/kb/products#ver-y-agregar-precios-de-productos","category":"default"},{"title":"Campos específicos de productos","content":"La característica de productos incluye múltiples campos de datos específicos para productos, que pueden optimizar su experiencia.\\n<table>\\n<tr>\\n<td>Nombre de campo</td>\\n<td>Definición</td>\\n<td>Ejemplo</td>\\n</tr>\\n<tr>\\n<td>Precio</td>\\n<td>El valor monetario asignado a una unidad de un producto</td>\\n<td>Mi compañía vende pantalones, y el precio de Blue Jeans cuesta $35 por par.</td>\\n</tr>\\n<tr>\\n<td>Código de producto</td>\\n<td>Un código personalizado utilizado para identificar inequivocamente productos</td>\\n<td>El código de producto para jeans azules es 1827.</td>\\n</tr>\\n<tr>\\n<td>Impuesto %</td>\\n<td>Un porcentaje tomado del costo total de un pedido y agregado como una tarifa adicional</td>\\n<td>El precio de los jeans es de $16, con una tasa de impuestos del 10%, por lo que el costo total es de $17.6</td>\\n</tr>\\n<tr>\\n<td>Unidad</td>\\n<td>Una medición o cantidad estándar física para un producto</td>\\n<td>Un par de jeans representa una unidad, pero una caja de jeans es de cuatro unidades.</td>\\n</tr>\\n<tr>\\n<td>Precios unitarios</td>\\n<td>El precio de un producto por unidad</td>\\n<td>Una caja de jeans cuesta $120, y hay cuatro pares en una caja, por lo que el precio unitario cuesta $30 por un par, pero $40 vendido individualmente.</td>\\n</tr>\\n</table>\\n\\n<!-- ## Export products\\nNota: This action is only available to users with deals and global admin permissions enabled.\\nYou can export your product catalog and the products linked to deals by going to Tools and apps > Export data.\\nSelect “Products\\" and one of the export options:\\nEntire product catalog\\nOnly products added to deals\\n\\nThen, click on either “CSV“ or “Excel”. Your export file will appear in the “Generated exports“ list. To download the file, click on the cloud icon in the “Available until“ column. -->\\n","section":"Productos","version":"current","path":"/es/kb/products#campos-específicos-de-productos","category":"default"},{"title":"¿Dónde activo o desactivo los productos individuales?","content":"<p>&lt;!-- # Where do I activate or deactivate individual products? --&gt;</p>\\n<p>Si desea desactivar o activar <strong>Productos</strong> en su cuenta de Fintesk, puede hacerlo entrando en la <strong>Vista de Detalle</strong> del producto específico y haciendo clic en el botón &quot;<strong>Desactivar</strong>&quot; encontrado a la derecha de la pantalla.</p>\\n<p>&lt;!-- :::tip\\n<strong>Note:</strong> The <strong>Products</strong> feature is one of the many useful features of Fintesk’s Essential, Advanced, Professional and Enterprise plans. To learn how to switch plans, click <a href=\\"billing/your-fintesk-subscription-plan/how-can-i-switch-to-a-different-fintesk-plan-or-change-my-billing-frequency\\">here</a>.\\n::: --&gt;</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screen_Shot_2019-07-31_at_3.48.04_PM.png\\" alt=\\"1\\"> --&gt;</p>\\n<p><img src=\\"../../kb/products/where-do-i-activate-or-deactivate-individual-products/wdia01.jpeg\\" alt=\\"wdia01\\"></p>\\n<p>Si desea reactivar cualquier producto previamente desactivado, ingrese a la <strong>Vista de Detalle</strong> de ese producto desactivado y haga clic en el botón &quot;<strong>Activar</strong>&quot; que se encuentra allí.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screen_Shot_2019-07-31_at_3.47.50_PM.png\\" alt=\\"1\\"> --&gt;</p>\\n<p><img src=\\"../../kb/products/where-do-i-activate-or-deactivate-individual-products/wdia02.jpeg\\" alt=\\"wdia02\\"></p>\\n<p>&lt;!-- This can also be done to many products at once, by utilizing the <strong>Bulk edit</strong> functions of the list view within the <strong>Products</strong> feature. --&gt;</p>\\n","section":"¿Dónde activo o desactivo los productos individuales?","version":"current","path":"/es/kb/products/where-do-i-activate-or-deactivate-individual-products","category":"default"},{"title":"¿Se puede usar Fintesk fuera de línea?","content":"<p>&lt;!-- # Can Fintesk be used offline? --&gt;</p>\\n<p>Fintesk no tiene una aplicación de escritorio separada y solo se puede usar en línea dentro de un navegador web.</p>\\n<p>&lt;!-- However, both the Fintesk iOS and Android mobile apps allow for working offline. --&gt;</p>\\n<p>&lt;!-- Any changes made without an internet connection to the mobile apps will be updated in the Fintesk database once you have connected to the internet again. --&gt;</p>\\n<p>&lt;!-- :::tip\\n<strong>Note</strong>: Offline and online modes can\'t be toggled on mobile apps, they will default to online mode if there is an internet connection available. If your device is connected to the internet but your mobile app is still in offline mode, please contact our <a href=\\"https://fintesk.com/es/soporte/contactanos/?utm_source=fintesk-docs\\">support team</a>.\\n::: --&gt;</p>\\n","section":"¿Se puede usar Fintesk fuera de línea?","version":"current","path":"/es/kb/troubleshooting/can-fintesk-be-used-offline","category":"default"},{"title":"1. Sistema operativos de escritorio Windows","content":"Para tomar una captura de pantalla en un sistema operativo de escritorio de Windows, presione el botón \\"Imprimir pantalla\\" en su teclado.\\nLa ubicación exacta de este botón varía de un teclado a otro, y entre PC y la computadora portátil, pero generalmente es bastante fácil de encontrar y a menudo se abrevia como Print Scrn, Prnt Scrn, o Prt Scrn. con la mayoría de los teclados de PC se pueden encontrar en la fila superior de teclas en la fila después de F12.\\nUna vez que haya presionado este botón, abra el Paint que es un programa en Windows.Esto se puede hacer buscando usando la función Buscar programa o navegando a través de su lista de Programas.\\nUna vez que el programa Paint ha sido abierto, presiona CTRL+V para pegar la captura de pantalla dentro del Paint.\\n<!--  -->\\n\\nUna vez hecho esto, guarde esta captura de pantalla pegada a su computadora.\\nPara guardar, haga clic en el botón \\"Guardar\\" en el menú Archivo en la parte superior izquierda del menú del Paint.\\n<!--  -->\\n\\nUna vez guardado, puede adjuntar la imagen guardada a un correo electrónico y enviarla.\\nAlternativamente, si su captura de pantalla contiene datos que no desea compartir, puede recortar la imagen dentro del programa de pintura antes de enviarlo.\\nPara hacerlo, primero, haga clic en el cuadro \\"Selector\\" del menú en la parte superior del programa Paint.\\n<!--  -->\\n\\nUna vez hecho esto, dibuje un cuadro alrededor de lo que le gustaría que se mantenga en la imagen, luego haga clic en \\"Crop\\" desde el mismo menú:\\n<!--  -->\\n\\nEsto eliminará todo de la imagen, excepto el área que ha seleccionado.\\nTenga en cuenta que, en algunos casos, es muy útil para nosotros ver la dirección web o la URL al tratar de ayudarlo a resolver ciertos problemas. En esas situaciones, podemos pedir que la captura de pantalla incluya esa información para ayudarnos a solucionar problemas o diagnosticar problemas.\\n\\n","section":"¿Cómo puedo tomar una captura de pantalla?","version":"current","path":"/es/kb/troubleshooting/how-can-i-take-a-screenshot#1-sistema-operativos-de-escritorio-windows","category":"default"},{"title":"2. Sistema operativos de escritorio macOS","content":"Para tomar una captura de pantalla con una Mac, solo presione CMD+SHIFT+3.\\nHacerlo guardará una captura de pantalla de su pantalla completa en su escritorio. A partir de ahí, ¡puede adjuntar esa pantalla a un correo electrónico y enviarla!\\nAlternativamente, si tiene algunos datos que no desea compartir con Fintesk, puede tomar una captura de pantalla de un área específica dentro de su pantalla.\\nPara una selección específica, presione CMD+SHIFT+4 y dibuje una caja alrededor de la información que desea guardar en su captura de pantalla.\\nTenga en cuenta que, en algunos casos, es muy útil para nosotros ver la dirección web o la URL al tratar de ayudarlo a resolver ciertos problemas. En esas situaciones, podemos pedir que la captura de pantalla incluya esa información, para ayudarnos a solucionar problemas o diagnosticar problemas.\\n<!-- ---\\n","section":"¿Cómo puedo tomar una captura de pantalla?","version":"current","path":"/es/kb/troubleshooting/how-can-i-take-a-screenshot#2-sistema-operativos-de-escritorio-macos","category":"default"},{"title":"3. iOS mobile operating systems (iPad/iPhone)","content":"To take a screenshot with your iPhone, press both the Power button on the right side and the Volume Up button on the left at the same time.\\nTo take a screenshot with your iPad, press both the Power button (either at the top or on the side) and the Home button (the round button on the front) at the same time.\\nThe screenshot will then be saved into your Photos gallery and is ready to attach to an email and send to us. You can find it under the \\"All photos\\" folder.\\n\\n","section":"¿Cómo puedo tomar una captura de pantalla?","version":"current","path":"/es/kb/troubleshooting/how-can-i-take-a-screenshot#3-ios-mobile-operating-systems-ipadiphone","category":"default"},{"title":"4. Android mobile operating systems","content":"With most Android devices, pressing the Power and Volume Down buttons together will take a screenshot of the contents of the screen.\\nThe screenshot will then be saved into your Photos gallery, ready to be sent to us. The specific folder that the screenshot will be saved in will depend on the device you are using.\\nIf you cannot find the picture – or if pressing Power and Volume Down doesn\'t take a screenshot – it may be best to search the internet for specific instructions for your phone model. -->\\n","section":"¿Cómo puedo tomar una captura de pantalla?","version":"current","path":"/es/kb/troubleshooting/how-can-i-take-a-screenshot#4-android-mobile-operating-systems","category":"default"},{"title":"Google Chrome","content":"En una ventana del Chrome, haga clic \\"...\\" > Eliminar datos de navegación.\\n<!--  -->\\n\\nEn la ventana que aparece, asegúrese de que Cookies y otros datos del sitio y Imágenes y archivos en caché se seleccionan antes de hacer click en Borrar datos.\\n<!--  -->\\n\\n\\n","section":"¿Cómo limpiar el caché y las cookies de mi navegador?","version":"current","path":"/es/kb/troubleshooting/how-do-i-clear-my-browser-s-cache-and-cookies#google-chrome","category":"default"},{"title":"Firefox","content":"En una ventana de Firefox, haga clic en el icono de estantería en la esquina superior derecha > Settings:\\n<!--  -->\\n\\nLuego vaya a Privacidad y seguridad y desplácese hacia abajo a la opción Borrar datos y haga clic en ella:\\n<!--  -->\\n\\n\\n","section":"¿Cómo limpiar el caché y las cookies de mi navegador?","version":"current","path":"/es/kb/troubleshooting/how-do-i-clear-my-browser-s-cache-and-cookies#firefox","category":"default"},{"title":"Safari","content":"En una ventana de Safari, haga clic en Safari en la barra de menú y vaya a Preferencias:\\n<!--  -->\\n\\nEn la ventana que aparece, seleccione Avanzado y luego asegúrese de que el Mostrar menú de desarrollo en la parte inferior se encuentre seleccionado.\\n<!--  -->\\n\\nDespués de eso, busque la pestaña Desarrollo en su barra de menú, luego seleccione Vaciar Caches:\\n<!--  -->\\n\\n\\n","section":"¿Cómo limpiar el caché y las cookies de mi navegador?","version":"current","path":"/es/kb/troubleshooting/how-do-i-clear-my-browser-s-cache-and-cookies#safari","category":"default"},{"title":"Internet Explorer","content":":::tip\\nNota: Internet Explorer fue retirado el 15 de junio de 2022. Si bien aún puede usar versiones anteriores, Microsoft recomienda actualizar al navegador Edge. Para obtener más información, puede consultar su artículo sobre el tema.\\n:::\\nEn una ventana de Internet Explorer, haga clic en el ícono de engranaje en la esquina superior derecha y vaya a SEGURIDAD> Eliminar el historial de navegación.\\n<!--  -->\\n\\nEn la ventana que aparece, asegúrese de Preservar datos del sitio web de favoritos No está seleccionada y selecciona \\"Archivos de Internet temporales y archivos del sitio web\\" y \\"Cookies y datos del sitio web\\". entonces puedes hacer clic en \\"Delete\\" para confirmar.\\n<!--  -->\\n\\n\\n","section":"¿Cómo limpiar el caché y las cookies de mi navegador?","version":"current","path":"/es/kb/troubleshooting/how-do-i-clear-my-browser-s-cache-and-cookies#internet-explorer","category":"default"},{"title":"Si usas Microsoft Edge","content":"En una ventana de Microsoft Edge, haga clic en el ícono más (...). Después de seleccionar esto, haga clic en la pestaña Historial> Borrar datos de navegación.\\n<!--  -->\\n\\nEn la ventana que aparece, seleccione las opciones \\"Cookies y Guardado del sitio web\\" y \\"Datos y archivos almacenados en caché\\". Luego puede hacer clic en el botón \\"borrar ahora\\" para confirmar.\\n<!--  -->\\n\\n\\n","section":"¿Cómo limpiar el caché y las cookies de mi navegador?","version":"current","path":"/es/kb/troubleshooting/how-do-i-clear-my-browser-s-cache-and-cookies#si-usas-microsoft-edge","category":"default"},{"title":"Borrar caché para una página","content":"A veces debe borrar los datos de caché debido a problemas de rendimiento, pero no querrá eliminar todos esos datos de su navegador.\\nPara borrar el caché para una sola página web, comience navegando a \\"...\\" En la esquina superior derecha de su navegador, luego seleccione More Tools > Developer Tools:\\n<!--  -->\\n\\nEsto abrirá su menú Inspecionar, desde el cual puede seleccionar la pestaña Consola. Una vez seleccionado, mantenga la pestaña de la consola abierta y haga clic con el botón derecho en el icono de actualización en la parte superior izquierda de su página web.\\nEsto revelará la opción de vaciar caché y recargar:\\n<!--  -->\\n\\n:::tip\\nNota: Este método para restablecer el caché es específico para Google Chrome.\\n:::\\n","section":"¿Cómo limpiar el caché y las cookies de mi navegador?","version":"current","path":"/es/kb/troubleshooting/how-do-i-clear-my-browser-s-cache-and-cookies#borrar-caché-para-una-página","category":"default"},{"title":"Información de la consola del navegador","content":"La consola del navegador proporciona información sobre los errores de la página web que pueden no haberse visto en el equipo de desarrollo de Fintesk.\\nPara abrir la consola del navegador en la mayoría de los navegadores, puede:\\nHaga clic con el botón derecho en su mouse\\nClic “Inspeccionar/inspeccionar elemento”\\nClic “Consola”\\nSi hay errores de página, aparecerán en rojo y deben incluirse en cualquier captura de pantalla que proporcione para el equipo de soporte. Fintesk no proporciona mapas de origen (advertencias de consola en amarillo), así que escúchalos.\\nPara obtener información adicional sobre cómo abrir la consola de su navegador, consulte este enlace.\\n<!--  -->\\n\\n:::tip\\nNota: Asegúrese de que la pestaña de la consola se seleccione al tomar la captura de pantalla.\\n:::\\n\\n","section":"¿Cómo abro la consola de mi navegador?","version":"current","path":"/es/kb/troubleshooting/how-do-i-open-my-browser-console#información-de-la-consola-del-navegador","category":"default"},{"title":"Información de la red del navegador","content":"La Información de la red del navegador destaca los problemas de conexión a Internet que causan errores.\\nPara abrir su pestaña de red en la mayoría de los navegadores, puede:\\nHaga clic con el botón derecho en su mouse\\nClic “Inspeccionar/inspeccionar elemento”\\nClic “Red”\\nDespués de cambiar a la pestaña Red, recargar la página para registrar la actividad en el registro de red Antes de tomar la captura de pantalla.\\n<!--  -->\\n\\nAl tomar una captura de pantalla de la pestaña de red del navegador, capture cualquier error que aparezca.\\n","section":"¿Cómo abro la consola de mi navegador?","version":"current","path":"/es/kb/troubleshooting/how-do-i-open-my-browser-console#información-de-la-red-del-navegador","category":"default"},{"title":"Para una resolución general de problemas","content":"\\nBorre el caché y las cookies de tu navegador.\\nPruebe para ver si el problema persiste en una ventana de incógnito y otros navegadores.\\nComuníquese con el equipo de soporte aquí.\\n\\n","section":"Solución de problemas-> Aplicación web de Fintesk","version":"current","path":"/es/kb/troubleshooting/troubleshooting-fintesk-web-app#para-una-resolución-general-de-problemas","category":"default"},{"title":"Si Fintesk está siendo lenta","content":"Actualice la página de su navegador.\\nSalga de su sesión e inicie sesión nuevamente en su cuenta de Fintesk.\\nAsegúrese de que su navegador esté actualizado a la última versión. Puede ver si está en la última versión de su navegador aquí.\\nBorre el caché y las cookies de tu navegador.\\nInicie sesión en Fintesk con otro navegador. Puede leer sobre qué los navegadores funcionan mejor con Fintesk en este artículo.\\nConecte su computadora a otra red. Esto descartará cualquier problema de red que pueda estar causando la lentitud.\\nInicie sesión en Fintesk en otra computadora. Esto descartará cualquier problema del dispositivo que pueda estar causando la lentitud.\\n\\n","section":"Solución de problemas-> Aplicación web de Fintesk","version":"current","path":"/es/kb/troubleshooting/troubleshooting-fintesk-web-app#si-fintesk-está-siendo-lenta","category":"default"},{"title":"Si sus datos parecen faltar","content":"Verifique si tiene algún filtro aplicado a su cuenta de Fintesk.\\n<!-- \\n -->\\n\\n<!-- - Clear out Pipeline View filters and select the correct pipeline:\\n -->\\n\\n\\nBorre el caché y las cookies de tu navegador.\\n\\n\\nVerifique si alguna extensiones del navegador interactúa con Fintesk. Al iniciar sesión en Fintesk con una ventana de incógnito, podrá ver si una de sus extensiones está causando algún problema.\\nSi todavía tiene problemas con su cuenta de Fintesk, comuníquese con nuestro equipo de soporte aquí.\\n","section":"Solución de problemas-> Aplicación web de Fintesk","version":"current","path":"/es/kb/troubleshooting/troubleshooting-fintesk-web-app#si-sus-datos-parecen-faltar","category":"default"},{"title":"¿Qué navegador es mejor para Fintesk?","content":"<p>&lt;!-- ../../kb/troubleshooting/which-browser-is-best-for-fintesk.md --&gt;</p>\\n<p>&lt;!-- # Which browser is best for Fintesk? --&gt;</p>\\n<p><a href=\\"https://www.google.com/chrome/\\">Google Chrome</a> y <a href=\\"https://www.microsoft.com/en-us/edge\\">Edge</a> proporcionarán las mejores experiencias al usar Fintesk. Recomendamos mantenerse alejados de los navegadores predeterminados comunes, como Internet Explorer y Safari, ya que pueden causar problemas de rendimiento.</p>\\n<p>Es importante asegurarse de que su navegador esté en la última versión para un funcionamiento óptimo. Puede ver la siguiente documentación para aprender cómo actualizar los navegadores recomendados:</p>\\n<ul>\\n<li><a href=\\"https://support.google.com/chrome/answer/95414?co=GENIE.Platform%3DDesktop&amp;hl=en\\">Google Chrome</a></li>\\n<li><a href=\\"https://support.microsoft.com/en-us/topic/microsoft-edge-update-settings-af8aaca2-1b69-4870-94fe-18822dbb7ef1\\">Edge</a></li>\\n</ul>\\n","section":"¿Qué navegador es mejor para Fintesk?","version":"current","path":"/es/kb/troubleshooting/which-browser-is-best-for-fintesk","category":"default"},{"title":"Derechos de acceso","content":"La vista de \\"Derechos de acceso\\" de usuarios en su cuenta, vaya a Configuración de empresa> Administrar usuarios\\n<!-- and, to the right of each user\'s name, you will see five subheaders representing each category. -->\\nLos \\"Derechos de acceso\\" para cada categoría son los siguientes:\\n<!-- -  – Admin access\\n– Regular user access\\n\\n\\n – No access -->\\n\\n\\nAcceso de administrador\\n\\n\\nAcceso regular al usuario\\n\\n\\nSin acceso\\nPara cambiar el acceso para un usuario, haga clic en \\"...\\" a la derecha del usuario, luego seleccione Editar \\"Derechos de acceso\\".\\n<!--  -->\\nEsto abrirá el panel \\"Derechos de acceso\\", donde verá las opciones que tiene para asignar acceso o permisos de edición.\\nPuede hacer clic en las casillas de verificación Azul para dar acceso, o usar el menú desplegable disponible para editar los permisos existentes.\\n<!--  -->\\nUna vez que haya realizado los cambios deseados, haga clic en el botón editar en la parte inferior del panel y confirmar los cambios.\\n\\n","section":"Gestión global de usuarios","version":"current","path":"/es/kb/users-and-permissions/global-user-management#derechos-de-acceso","category":"default"},{"title":"Función de Negocios","content":"\\"Acceso a función de negocios\\" le permite usar la funcionalidad de ventas básicas de Fintesk.\\nAl tener acceso a negocios, tendrá acceso a su embudo, negocios, contactos y todas las características relacionadas.Dentro de los negocios, los usuarios se les asigna grupos de visibilidad y conjuntos de permisos para controlar lo que pueden ver y hacer en la cuenta.\\n\\"Acceso a función de negocios\\" requiere un asiento pagado en su cuenta. Cualquier usuario agregado con \\"acceso a función de negocios\\" se le asignará un conjunto de permisos.\\n<!-- and visibility group. -->\\n<!--  -->\\nUsuarios con \\"Acceso a función de negocios\\" tendrá acceso a nuestra sección Negocios vía el embudo.\\n<!-- , as well as our Leads Inbox. -->\\n<!-- --- -->\\n<!-- ## Projects app\\nThis category grants access to project management features and their data. This category requires \\"Deals app access\\" enabled.\\n\\nNote: Project management is currently free to test in beta to a closed group of users and will be released to more users at a later date. After the beta period ends it will require an additional subscription. -->\\n<!-- --- -->\\n<!-- ## Campaigns app\\nAllow your users to send stunning email campaigns by enabling access to this feature. This category requires \\"Deals app access\\" enabled.\\n-->\\n<!--\\nNote: Campaigns by Fintesk is available as a paid add-on. -->\\n\\n","section":"Gestión global de usuarios","version":"current","path":"/es/kb/users-and-permissions/global-user-management#función-de-negocios","category":"default"},{"title":"Permisos globales","content":"<!-- This category grants permission to the rest of the shared functionalities (such as contacts, Insights, activities, workflow automations, importing, etc.) to enhance the cross-product experience. -->\\nEsta categoría otorga permiso al resto de las funcionalidades compartidas (como contactos, actividades, importaciones, etc.) para mejorar la experiencia de funcionalidades cruzadas.\\nLos permisos globales se aplican automáticamente si el usuario seleccionado tiene acceso a al menos una aplicación.\\n<!--  -->\\n\\n","section":"Gestión global de usuarios","version":"current","path":"/es/kb/users-and-permissions/global-user-management#permisos-globales","category":"default"},{"title":"Configuraciones de la cuenta","content":"Los derechos de acceso a \\"Configuraciones de la cuenta\\" Le brinde la capacidad de ver y editar los detalles de facturación de su empresa, la configuración de seguridad, la configuración de la empresa, la gestión de usuarios y las configuraciones personales.\\n<!--  -->\\n<!-- Note: Users with \\"Configuraciones de la cuenta\\" only will not have access to deals, so they will not see deals, leads, pipelines and other core features of Fintesk in the web app and won’t be able to login to the mobile app. -->\\n:::tip\\nNota: Usuarios con \\"Configuraciones de la cuenta\\" solo no tendrá acceso a negocios, por lo que no verán negocios, embudos y otras características centrales de Fintesk en la aplicación web.\\n:::\\nSi el \\"Acceso a función de negocios\\" no está habilitado, el usuario \\"Configuraciones de la Cuenta\\" tendrá un asiento gratuito en la cuenta de Fintesk.\\nSi desea asignar \\"Acceso a función de negocios\\" a un usuario con acceso de \\"Configuraciones de la cuenta\\", puede hacerlo habilitando ambos tipos de acceso para ese usuario. Tenga en cuenta que, mientras está agregando \\"Acceso a función de negocios\\", agregarás un asiento a tu suscripción de Fintesk.\\n","section":"Gestión global de usuarios","version":"current","path":"/es/kb/users-and-permissions/global-user-management#configuraciones-de-la-cuenta","category":"default"},{"title":"Invitar a nuevos usuarios","content":"Vaya a Configuración> Administrar usuarios> Usuarios. Desde aquí, puede agregar al equipo de su cuenta otro miembro haciendo clic en el botón \\"+ Agregar usuarios\\", que se encuentra en el lado derecho de la pantalla.\\n<!--  -->\\n\\nEl cuadro “Agregar usuarios” se abrirá, donde puede ingresar la dirección de correo electrónico de la persona que desea agregar y hacer clic en “Previsualizar.” Para agregar múltiples usuarios, agregue sus direcciones de correo electrónico separadas por comas.\\n<!--  -->\\n\\n<!-- Si selecciona un usuario en la vista previa, verá el panel Editar acceso, donde puede elegir los permisos para su posible usuario. -->\\n\\n","section":"¿Cómo puedo agregar un usuario?","version":"current","path":"/es/kb/users-and-permissions/how-can-i-add-a-user#invitar-a-nuevos-usuarios","category":"default"},{"title":"Después de invitar a nuevos usuarios","content":"Si su usuario invitado no ha aceptado su invitación, puede cancelarse o reenviar.\\nHaga clic en la pestaña invitado, seleccione cualquier invitación pendientes, luego seleccione las opciones de cancelar o reenviar.\\n<!-- You can also edit permissions for prospective users from this screen. -->\\n<!--  -->\\n\\nSi su usuarios invitados:\\nNo se han inscrito en Fintesk antes, recibirán un correo electrónico de invitación de Fintesk. Este enlace de correo electrónico les permitirá establecer su contraseña e iniciar sesión en la cuenta de la empresa Fintesk que les ha invitado a unirse.\\n<!-- - Have signed up for Fintesk before and are still members of another Fintesk account, they’ll receive an email notification that they’ve been added to your account. They’ll use the same login credentials they’ve already set and can switch between the companies using the “Switch company” option in the upper-right corner of the app. -->\\n<!--  -->\\n:::tip\\nNota: Fintesk se factura por el número de asientos activos en la cuenta de la compañía Fintesk. Agregar un usuario aumentará el costo de su suscripción de Fintesk, si es que al hacerlo aumenta el número de asientos en la cuenta.\\n:::\\n","section":"¿Cómo puedo agregar un usuario?","version":"current","path":"/es/kb/users-and-permissions/how-can-i-add-a-user#después-de-invitar-a-nuevos-usuarios","category":"default"},{"title":"Desactivar un usuario","content":"Para desactivar a un usuario de Fintesk, vaya a Configuración> Administrar usuarios> Usuarios y acceso. A la derecha de cada usuario, verá una “...“. Haga clic en el \\"Desactivar\\" opción para desactivar el usuario que desea eliminar de su cuenta Fintesk.\\nCuando desactiva a un usuario, también verá los elementos que actualmente son propiedad de ese usuario para que pueda reasignar los elementos si es necesario. También verá un recordatorio para eliminar los asientos no utilizados.\\n<!--  -->\\n\\n\\n","section":"¿Cómo puedo desactivar, reactivar o eliminar un usuario?","version":"current","path":"/es/kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user#desactivar-un-usuario","category":"default"},{"title":"Eliminando asientos no utilizados","content":"Si opta por eliminar los asientos no utilizados durante la desactivación del usuario, deberá confirmar el cambio en el pago de facturación.\\nPuede aprender sobre la diferencia entre un asiento facturado y un usuario de Fintesk en este artículo.\\n<!-- \\n -->\\nSi elimina este asiento no utilizado, ya no tendrá un asiento activo para agregar un usuario. Se le facturará por la disminución del monto del asiento de su próxima fecha de facturación. Puede aprender sobre la diferencia entre un asiento facturado y un usuario de Fintesk en este artículo.\\nSi no quita este asiento no utilizado, entonces ese asiento todavía existe en su cuenta y la facturación permanece sin cambios. Esto le permite agregar otro usuario para reemplazar al usuario desactivado fácilmente sin tener que procesar múltiples transacciones de facturación.\\n:::tip\\nNota: La facturación de Fintesk se basa en asientos activos. Desactivar los usuarios solo reduce los costos de su suscripción de Fintesk si los números de asiento disminuyen. Puede leer más sobre el proceso de facturación en este artículo.\\n:::\\n\\n","section":"¿Cómo puedo desactivar, reactivar o eliminar un usuario?","version":"current","path":"/es/kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user#eliminando-asientos-no-utilizados","category":"default"},{"title":"Reactivación de un usuario","content":"Cualquier usuario desactivado puede reactivarse yendo a la pestaña Desactivados y hacer clic en “Reactivar” al lado del usuario objetivo.\\n<!--  -->\\n\\n","section":"¿Cómo puedo desactivar, reactivar o eliminar un usuario?","version":"current","path":"/es/kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user#reactivación-de-un-usuario","category":"default"},{"title":"Cambios en el recuento de asientos activos","content":"Si existe un asiento abierto, los usuarios reactivados lo llenan sin afectar la facturación\\nSi la reactivación de un usuario agrega un nuevo asiento a su cuenta, su recuento de asientos facturados aumentará, lo que lo facturará de inmediato por ese nuevo asiento\\nPuede leer más sobre este proceso de facturación en este artículo.\\n\\n<!--\\n","section":"¿Cómo puedo desactivar, reactivar o eliminar un usuario?","version":"current","path":"/es/kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user#cambios-en-el-recuento-de-asientos-activos","category":"default"},{"title":"Deleting a user","content":"If you need to remove the name and email address of a deactivated user, you can permanently delete it.\\n:::tip\\nNota: Once a user is deleted, it can’t be reactivated.\\n:::\\nTo delete a user, go to the Deactivated tab and click “Delete user” next to the target user. -->\\n<!--  -->\\n<!--  -->\\n<!--\\nUpon user deletion:\\nThe user’s name, email are completely removed from your company account. Instead, you’ll see the name (deleted user) or (deleted user, IDxxxxxxxx).\\nAll leads, deals and contacts the deleted user owns remain in your company account and are still assigned to the deleted user, unless the ownership is transferred during deletion.\\n:::tip\\nNota: We highly recommend transferring item ownership before the user is deleted, as you’ll no longer be able to select the deactivated user in filters. As an alternative, you can create a filter with conditions where the owner is not any of the other users.\\n::: -->\\n<!-- Learn about the other items the deleted user could be part of in this article. -->\\n","section":"¿Cómo puedo desactivar, reactivar o eliminar un usuario?","version":"current","path":"/es/kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user#deleting-a-user","category":"default"},{"title":"¿Cómo puedo reemplazar a los usuarios en mi cuenta de Fintesk?","content":"<p>&lt;!-- ../../kb/users-and-permissions/how-can-i-replace-users-in-my-pipedrive-company-account.md --&gt;</p>\\n<p>&lt;!-- # How can I replace users in my Fintesk company account? --&gt;</p>\\n<p>:::tip\\n<strong>Nota</strong>: Esta acción solo está disponible para usuarios con acceso de <strong>Configuración de la cuenta</strong> .\\n:::</p>\\n<p>&lt;!-- When an existing Fintesk user switches to another team or leaves the company, you may want to replace them with a new user. --&gt;</p>\\n<p>Cuando un usuario de Fintesk existente deja la empresa, es posible que desee reemplazarlos con un nuevo usuario.</p>\\n<p>Para fines de seguridad, la mejor manera de hacerlo sería <a href=\\"../../kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user\\">desactivar al antiguo usuario</a> por lo tanto, ya no tienen acceso y luego <a href=\\"../../kb/users-and-permissions/how-can-i-add-a-user\\">agregar un nuevo usuario</a> a tu cuenta de Fintesk.</p>\\n<p>Puede hacer ambas cosas yendo a <strong><a href=\\"https://app.fintesk.com/settings/company/manage-users?utm_source=fintesk-docs\\">Administrar usuarios</a></strong> y luego, después de hacer clic en <strong>“...”</strong> junto al usuario que desea desactivar, seleccione <strong>&quot;Desactivar&quot;</strong>.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202023-10-10%20at%2011.15.46.png\\" alt=\\"1\\"> --&gt;</p>\\n<p><img src=\\"../../kb/users-and-permissions/how-can-i-replace-users-in-my-fintesk-company-account/hciru01.jpeg\\" alt=\\"hciru01\\"></p>\\n<p>Para agregar un nuevo usuario, haga clic en <strong>&quot;+&quot;</strong> en el lado derecho para agregar un nuevo usuario a su cuenta.</p>\\n<p>&lt;!-- ## What if I want to transfer data from the deactivated user to the new user?</p>\\n<p>Once you deactivate a user, you may find that this user had owned deals or contacts that now need to be reassigned to the new user or another active user. You can easily reassign the items by following <a href=\\"../../kb/filtering/viewing-and-reassigning-the-data-of-a-deactivated-user\\">this article</a>. Transferring data in this way will allow you to choose exactly what needs to be reassigned and prevent any confidential information from being shared. --&gt;</p>\\n","section":"¿Cómo puedo reemplazar a los usuarios en mi cuenta de Fintesk?","version":"current","path":"/es/kb/users-and-permissions/how-can-i-replace-users-in-my-fintesk-company-account","category":"default"},{"title":"Actualización de su propia información de usuario","content":"\\n:::tip\\nNota: Los usuarios pueden solo actualizar su propia información de usuario independientemente de los permisos.\\n:::\\nPara actualizar su información de usuario, vaya a preferencias personales> cuenta.\\nAquí, puede actualizar la siguiente información:\\nNombre de pila\\nApellido\\nmoneda predeterminada\\n<!-- - Picture -->\\n<!-- - Login email -->\\n<!-- - Timezone (this is updated automatically to match your computer timezone) -->\\n<!-- - Date/number format -->\\n<!-- - Language -->\\n<!--  -->\\n\\nTambién puede cambiar su contraseña yendo a contraseña> contraseña e inicio de sesión.\\n\\n","section":"Actualizar la información del usuario","version":"current","path":"/es/kb/users-and-permissions/updating-user-information#actualización-de-su-propia-información-de-usuario","category":"default"},{"title":"Actualizar otra la información de usuario","content":"<!-- :::tip\\nNota: If you want to give a user \\"account settings access\\", please read this article.\\n::: -->\\nLos usuarios con acceso de Configuración de la cuenta pueden realizar las siguientes acciones para usuarios regulares y otros administradores.\\n<!-- - Edit permission sets -->\\nagregar y desactivar usuarios\\nPuede realizar estos cambios yendo a Configuración de la empresa> Administrar usuarios > “...” > Editar derechos de acceso.\\n<!--  -->\\n\\n","section":"Actualizar la información del usuario","version":"current","path":"/es/kb/users-and-permissions/updating-user-information#actualizar-otra-la-información-de-usuario","category":"default"},{"title":"¿Puede un usuario administrador actualizar la información de inicio de sesión de otros usuarios?","content":"Por razones de seguridad y privacidad, un usuario administrador no puede actualizar el nombre, el correo electrónico de inicio de sesión o la contraseña de cualquier otro usuario, administrador o regular.\\nEn Fintesk, un usuario puede pertenecer a múltiples compañías (próximamente) con un conjunto de credenciales de inicio de sesión, por lo que queremos asegurarnos de que otros usuarios no puedan acceder o cambiar esa información.\\n","section":"Actualizar la información del usuario","version":"current","path":"/es/kb/users-and-permissions/updating-user-information#puede-un-usuario-administrador-actualizar-la-información-de-inicio-de-sesión-de-otros-usuarios","category":"default"},{"title":"¿Qué pasa si quiero reemplazar un usuario?","content":"La mejor manera de reemplazar a un usuario en Fintesk es desactivar el usuario existente y agregar uno nuevo para el nuevo miembro del equipo.\\n<!-- :::tip\\nNota: For a guide on transferring previously owned items to a new user, check out this article.\\n::: -->\\n","section":"Actualizar la información del usuario","version":"current","path":"/es/kb/users-and-permissions/updating-user-information#qué-pasa-si-quiero-reemplazar-un-usuario","category":"default"},{"title":"Activos","content":"El usuario está actualmente inscrito con la cuenta Fintesk y tiene acceso\\n","section":"Usuarios","version":"current","path":"/es/kb/users-and-permissions/users#activos","category":"default"},{"title":"Invitados","content":"Se ha enviado una invitación a la dirección de correo electrónico, pero el nuevo usuario aún no se ha inscrito.\\n","section":"Usuarios","version":"current","path":"/es/kb/users-and-permissions/users#invitados","category":"default"},{"title":"Desactivados","content":"El usuario ha sido deshabilitado y el usuario ya no tiene acceso a la cuenta Fintesk de la empresa.\\nSi un usuario ha sido invitado a unirse a la cuenta pero no ha aceptado, puede cancelar su enlace de invitación de Fintesk en la pestaña de invitados.\\nPuede obtener más información sobre cómo agregar nuevos usuarios en este artículo.\\n","section":"Usuarios","version":"current","path":"/es/kb/users-and-permissions/users#desactivados","category":"default"},{"title":"¿Qué es un \\"usuario regular\\"?","content":"<p>&lt;!-- ../../kb/users-and-permissions/what-is-a-regular-user.md --&gt;</p>\\n<p>&lt;!-- # What is a &quot;regular/agent user&quot;? --&gt;</p>\\n<p>Al navegar por la página <strong>Administrar usuarios</strong>, puede notar que sus permisos están configurados como regulares.</p>\\n<p>Los usuarios con <strong>Acceso regular</strong> en negocios y &quot;permisos globales&quot; tienen los permisos que se les dieron cuando fueron invitados a su cuenta de Fintesk.</p>\\n<p>Según las opciones elegidas en ese conjunto de permisos, el usuario puede tener acceso limitado a ver y cambiar ciertos elementos en la cuenta de Fintesk.</p>\\n<p>&lt;!-- <img src=\\"https://kb-cms.pipedriveassets.com/Screenshot%202023-02-27%20at%2018.11.45.png\\" alt=\\"1\\"> --&gt;</p>\\n","section":"¿Qué es un \\"usuario regular\\"?","version":"current","path":"/es/kb/users-and-permissions/what-is-a-regular-user","category":"default"},{"title":"¿Quién es el usuario administrador de mi cuenta?","content":"<p>&lt;!-- ...kb/users-and-permissions/who-is-the-admin-user-of-my-account --&gt;\\n&lt;!-- # Who is the admin user of my account? --&gt;</p>\\n<p>El usuario administrador con acceso &quot;Configuración de la cuenta&quot; es el primer usuario que configuró la cuenta y los usuarios que asignaron con el rol de administrador desde entonces.</p>\\n<p>Si no está seguro de quién es el usuario administrador en su cuenta, por razones de seguridad y para mantener la privacidad del usuario, nuestros agentes de soporte no pueden responder esta pregunta por usted. Desafortunadamente, no hay posibilidad de que nuestro equipo de soporte comparta esta información con usted.</p>\\n<p>En este caso, una posibilidad sería que revise desde que usuario fue que llegó el correo electrónico de invitación a Fintesk. En muchos casos, este usuario seguirá siendo el usuario administrador.</p>\\n<p>De lo contrario, deberá comunicarse con su gerente, supervisor, administrador de TI o colegas para averiguar quién es el usuario administrador en la cuenta.</p>\\n<p>:::tip\\n<strong>Nota</strong>: El creador original de la cuenta se le dará al acceso a la cuenta en forma de administrador, sin embargo, este estado se puede eliminar u otorgarse a otros usuarios.</p>\\n<p>&lt;!-- You can check out <a href=\\"../../kb/users-and-permissions/global-user-management\\">this article</a> for more information about user management. --&gt;</p>\\n<p>:::</p>\\n","section":"¿Quién es el usuario administrador de mi cuenta?","version":"current","path":"/es/kb/users-and-permissions/who-is-the-admin-user-of-my-account","category":"default"},{"title":"Anexo de Procesamiento de Datos (“DPA”)","content":"Última actualización: 27 de noviembre de 2025\\nEste DPA se celebra entre:\\nLa entidad o persona definida como “Cliente” en los Términos (“Cliente”) y,\\nFintesk (entendida como la entidad legal con la cual el Cliente tiene una relación contractual según los Términos, “Fintesk”).\\nEl Cliente y Fintesk también se denominan “Parte” y colectivamente como las “Partes”.\\nEste DPA forma parte de y está sujeto a los Términos de Servicio de Fintesk, disponibles en (“Términos”). Este DPA entrará en vigor tras la aceptación por parte del Cliente, u otra ejecución, de los Términos y continuará de acuerdo con las disposiciones aquí establecidas.\\n","section":"Anexo de Procesamiento de Datos (“DPA”)","version":"current","path":"/es/privacy/dpa","category":"default"},{"title":"1. Antecedentes","content":"1.1 El Cliente ha aceptado los Términos, según los cuales Fintesk ha acordado prestar ciertos servicios al Cliente (“Servicios”).\\n1.2 Al prestar los Servicios, Fintesk puede recopilar, obtener acceso o procesar de otro modo Datos Personales de individuos (Interesados) en nombre del Cliente. A menos que las Partes acuerden lo contrario, el Cliente será el Responsable del Tratamiento (Data Controller) y Fintesk será el Encargado del Tratamiento (Data Processor) de dichos Datos Personales.\\n1.3 Este DPA especifica las obligaciones de protección de datos de las Partes bajo los Términos. Se aplica a todas las actividades realizadas por Fintesk en relación con los Términos en las que Fintesk, su personal o un tercero que actúe en nombre de Fintesk entre en contacto con Datos Personales como Encargado del Tratamiento en nombre del Cliente.\\n1.4 El DPA se basa en las disposiciones de la Ley N° 21.719, sobre protección de los datos personales, y las definiciones contenidas en ella.\\n1.5 Si existe un conflicto entre los términos de los Términos y los de este DPA, prevalecerán las disposiciones de este DPA.\\n","section":"Anexo de Procesamiento de Datos (“DPA”)","version":"current","path":"/es/privacy/dpa#1-antecedentes","category":"default"},{"title":"2. Definiciones","content":"2.1 Todos los términos en mayúscula utilizados en el presente documento y no definidos de otro modo aquí, tendrán el significado atribuido a dicho término en los Términos.\\n2.2 “Responsable del Tratamiento” (Data Controller) significa la persona física o jurídica, autoridad pública, agencia u otro organismo que, solo o conjuntamente con otros, determina los fines y medios del Procesamiento de Datos Personales.\\n2.3 “Encargado del Tratamiento” (Data Processor) significa una persona física o jurídica, autoridad pública, agencia u otro organismo que Procesa Datos Personales en nombre del Responsable del Tratamiento.\\n2.4 “Leyes de Protección de Datos” significa toda la legislación mundial aplicable relacionada con la protección de datos y la privacidad que se aplica a la Parte respectiva en el rol de Procesamiento de Datos Personales en cuestión bajo los Términos, en cada caso según sea enmendada.\\n2.5 “Interesado” (Data Subject) significa el individuo con el que se relacionan los Datos Personales.\\n2.6 “Instrucciones” significa las instrucciones escritas y documentadas emitidas por el Cliente a Fintesk, incluyendo mediante el uso de los Servicios, y dirigiendo a este a realizar una acción específica o general con respecto a los Datos Personales (incluyendo, entre otros, eliminar o poner a disposición).\\n2.7 “Datos Personales” significa cualquier información relacionada con un individuo identificado o identificable (Interesado) donde dicha información esté contenida dentro de los Datos del Cliente y sea reconocida como datos personales bajo las Leyes de Protección de Datos.\\n2.8 “Violación de Seguridad de Datos Personales” significa una violación de seguridad que conduce a la destrucción accidental o ilegal, pérdida, alteración, divulgación no autorizada de, o acceso a, Datos Personales transmitidos, almacenados o procesados de otro modo por Fintesk y/o sus Subencargados. No incluirá intentos o actividades fallidas que no comprometan la seguridad de los Datos Personales (pings, escaneos de puertos, ataques fallidos, etc.).\\n2.9 “Procesamiento” significa cualquier operación o conjunto de operaciones que se realiza sobre Datos Personales, abarcando la recopilación, registro, organización, almacenamiento, adaptación, recuperación, uso, divulgación, restricción o eliminación.\\n2.10 “Subencargado” (Sub-Processor) significa cualquier Encargado del Tratamiento contratado por Fintesk para ayudar a cumplir sus obligaciones con respecto a la prestación de los Servicios.\\n2.11 “Tercer País” significa cualquier país fuera de Chile que no proporcione protección adecuada reconocida.\\n","section":"Anexo de Procesamiento de Datos (“DPA”)","version":"current","path":"/es/privacy/dpa#2-definiciones","category":"default"},{"title":"3. Detalles del Procesamiento","content":"3.1 Propósito del Procesamiento. Sujeto a la Sección 5.1, Fintesk Procesará Datos Personales solo para proporcionar y mantener los Servicios. Fintesk seguirá las Instrucciones razonables del Cliente que no entren en conflicto con el DPA o las leyes.\\n3.2 Naturaleza del Procesamiento. Fintesk es una herramienta CRM SaaS basada en la nube. Los Datos Personales estarán sujetos a almacenamiento y otro procesamiento necesario para mantener los Servicios y divulgación según los Términos o la ley.\\n3.3 Instrucciones del Responsable. Los Términos junto con el uso de los Servicios constituyen las Instrucciones completas y finales del Cliente. Instrucciones adicionales requieren acuerdo escrito previo.\\n3.4 Categorías de Interesados. Fintesk no tiene control sobre las categorías, pero usualmente incluyen: directores, empleados, pasantes, contratistas, solicitantes de empleo, clientes, proveedores y contactos comerciales del Cliente.\\n3.5 Categorías y Naturaleza de los Datos Personales. Generalmente incluirán: Nombre, dirección, email, teléfono, historial del cliente, direcciones IP, notas de texto libre y otros datos ingresados por el Cliente. Las Partes no anticipan el Procesamiento de Información Sensible.\\n","section":"Anexo de Procesamiento de Datos (“DPA”)","version":"current","path":"/es/privacy/dpa#3-detalles-del-procesamiento","category":"default"},{"title":"4. Obligaciones del Cliente","content":"4.1 Cumplimiento de las Leyes. El Cliente será responsable de cumplir con todos los requisitos bajo las Leyes de Protección de Datos en su uso de los Servicios y en sus Instrucciones a Fintesk. Fintesk no tiene obligación de evaluar los Datos del Cliente para identificar requisitos legales específicos.\\n4.2 Responsabilidades Específicas. El Cliente acepta que será el único responsable de:\\n4.2.1 La exactitud, calidad y legalidad de los Datos Personales.\\n4.2.2 Cumplir con los requisitos de transparencia y legalidad (notificaciones y consentimientos, incluido marketing).\\n4.2.3 Asegurar que tiene el derecho de transferir o proporcionar acceso a los Datos Personales a Fintesk.\\n4.2.4 Asegurar que las Instrucciones cumplen con las leyes aplicables.\\n4.2.5 Cumplir con las leyes aplicables a los correos electrónicos o contenido gestionado a través de los Servicios.\\n4.3 El Cliente informará a Fintesk sin demora indebida si no puede cumplir con sus responsabilidades.\\n","section":"Anexo de Procesamiento de Datos (“DPA”)","version":"current","path":"/es/privacy/dpa#4-obligaciones-del-cliente","category":"default"},{"title":"5. Obligaciones de Fintesk","content":"5.1 Alcance del Procesamiento. Fintesk se compromete a Procesar Datos Personales solo basándose en las Instrucciones documentadas.\\n5.2 Confidencialidad. Fintesk asegurará que las personas autorizadas se hayan comprometido a la confidencialidad.\\n5.3 Personal Calificado. Fintesk utilizará personal calificado con formación en protección de datos.\\n5.4 Instrucciones al Personal. Fintesk obligará a su personal a Procesar datos solo según los Términos e Instrucciones.\\n5.5 Notificación de Violación (Instrucciones). Fintesk notificará al Cliente si opina que una Instrucción viola las Leyes de Protección de Datos.\\n5.6 Notificación de Violación de Seguridad y Cooperación. Fintesk notificará al Cliente sin demora indebida (con un tiempo objetivo no mayor a 72 horas hábiles) tras tener conocimiento de una Violación de Seguridad de Datos Personales y asistirá al Cliente en sus obligaciones legales.\\n5.7 Terceros. Fintesk mantendrá la confidencialidad y no pondrá Datos Personales a disposición de terceros excepto según los Términos o la ley.\\n5.8 Solicitudes de los Interesados. Fintesk apoyará al Cliente implementando medidas técnicas y organizativas para cumplir con los derechos del Interesado. Si un Interesado contacta a Fintesk directamente, Fintesk le indicará que contacte al Responsable del Tratamiento.\\n5.9 Seguridad. Fintesk asistirá al Cliente en el cumplimiento de sus obligaciones.\\n5.10 Cooperación con Autoridades. Fintesk cooperará con las autoridades de control pertinentes.\\n5.11 Eliminación y Devolución. Al terminar los Servicios, Fintesk eliminará o devolverá los Datos Personales según las Instrucciones. Si el Cliente no da Instrucciones, Fintesk eliminará los datos así:\\nContenidos de Cuentas cerradas: ~180 días.\\nContenidos de Cuentas de Prueba Gratuita: ~60 días.\\nCopias de seguridad: ~90 días.\\n5.12 Evaluación de Impacto. Fintesk proporcionará asistencia razonable con evaluaciones de impacto de protección de datos.\\n","section":"Anexo de Procesamiento de Datos (“DPA”)","version":"current","path":"/es/privacy/dpa#5-obligaciones-de-fintesk","category":"default"},{"title":"6. Subencargados","content":"6.1 Autorización General. El Cliente otorga a Fintesk una autorización general para contratar Subencargados.\\n6.2 Subencargados Autorizados. Listados en www.pipedrive.com/subprocessors.\\n6.3 Notificación de Cambios. Fintesk notificará al Cliente antes del nombramiento de cualquier nuevo Subencargado vía correo electrónico. El Cliente puede objetar dentro de los diez (10) días naturales enviando un correo a privacidad@fintesk.com.\\n6.4 Objeción. Si el Cliente objeta, Fintesk recomendará cambios. Si no se puede resolver en 30 días, el Cliente puede terminar los Servicios afectados y recibir un reembolso prorrateado.\\n6.5 Condiciones para Contratar. Fintesk asegurará acuerdos con Subencargados que impongan obligaciones similares y no menos protectoras que este DPA, y asegurará un nivel adecuado de protección para transferencias a Terceros Países.\\n6.6 Responsabilidad. Fintesk será plenamente responsable ante el Cliente por las violaciones de este DPA por parte de los Subencargados.\\n","section":"Anexo de Procesamiento de Datos (“DPA”)","version":"current","path":"/es/privacy/dpa#6-subencargados","category":"default"},{"title":"7. Lugar de Procesamiento y Transferencias de Datos","content":"7.1 Lugares de Procesamiento. El Cliente acepta que Fintesk puede procesar datos globalmente, incluyendo transferencias a filiales y Subencargados en sus jurisdicciones.\\n7.2 Cumplimiento. Cada Parte asegurará que las transferencias cumplan con las Leyes de Protección de Datos de Chile.\\n","section":"Anexo de Procesamiento de Datos (“DPA”)","version":"current","path":"/es/privacy/dpa#7-lugar-de-procesamiento-y-transferencias-de-datos","category":"default"},{"title":"8. Medidas Técnicas y Organizativas","content":"Fintesk implementará medidas de seguridad técnicas y organizativas apropiadas para garantizar un nivel de seguridad adecuado al riesgo (de conformidad con la Ley N° 21.719), descritas en el Anexo B1.\\n","section":"Anexo de Procesamiento de Datos (“DPA”)","version":"current","path":"/es/privacy/dpa#8-medidas-técnicas-y-organizativas","category":"default"},{"title":"9. Auditorías","content":"Fintesk otorgará al Cliente derechos de acceso e información para verificar el cumplimiento, previa solicitud por escrito. El Cliente puede determinar el cumplimiento mediante auditoría en las instalaciones una vez al año, sujeto a confidencialidad y reembolso de costos a las tarifas de servicios profesionales de Fintesk (ver Anexo B1 de este DPA).\\n","section":"Anexo de Procesamiento de Datos (“DPA”)","version":"current","path":"/es/privacy/dpa#9-auditorías","category":"default"},{"title":"10. Responsabilidad","content":"Las obligaciones o incumplimientos bajo este DPA estarán sujetos a las limitaciones de responsabilidad establecidas en los Términos.\\n","section":"Anexo de Procesamiento de Datos (“DPA”)","version":"current","path":"/es/privacy/dpa#10-responsabilidad","category":"default"},{"title":"11. Misceláneos","content":"11.1 Ley Aplicable. La indicada en los Términos.\\n11.2 Cambios. Fintesk puede modificar este DPA para cumplir con leyes, órdenes regulatorias o nuevas prácticas. El uso continuo de los Servicios constituye la aceptación del Cliente.\\n","section":"Anexo de Procesamiento de Datos (“DPA”)","version":"current","path":"/es/privacy/dpa#11-misceláneos","category":"default"},{"title":"Anexo B1 – Medidas Técnicas y Organizativas","content":"Descripción de las medidas de seguridad implementadas por Fintesk:\\n","section":"Anexo de Procesamiento de Datos (“DPA”)","version":"current","path":"/es/privacy/dpa#anexo-b1--medidas-técnicas-y-organizativas","category":"default"},{"title":"1. Cifrado y Seudonimización","content":"Datos en reposo: Cifrado con AES-256.\\nDatos en tránsito: Uso de HSTS vía TLS (HTTPS).\\n","section":"Anexo de Procesamiento de Datos (“DPA”)","version":"current","path":"/es/privacy/dpa#1-cifrado-y-seudonimización","category":"default"},{"title":"2. Confidencialidad, Integridad y Disponibilidad","content":"Gestión de Incidentes:\\n\\nFunción 24x7 para respuesta inmediata.\\nProcedimiento formal para eventos de seguridad y análisis post-mortem.\\n\\n\\nResiliencia:\\n\\nPlan de continuidad del negocio y recuperación ante desastres.\\nCopias de seguridad (backups) almacenadas fuera del sitio y probadas.\\n\\n\\nRedundancia:\\n\\nInfraestructura escalable y redundante globalmente (IaaS).\\nAlta disponibilidad en todos los componentes.\\n","section":"Anexo de Procesamiento de Datos (“DPA”)","version":"current","path":"/es/privacy/dpa#2-confidencialidad-integridad-y-disponibilidad","category":"default"},{"title":"3. Testing y Evaluación Regular","content":"Escaneos de vulnerabilidades anuales.\\nPruebas de penetración anuales realizadas internamente.\\n","section":"Anexo de Procesamiento de Datos (“DPA”)","version":"current","path":"/es/privacy/dpa#3-testing-y-evaluación-regular","category":"default"},{"title":"4. Identificación y Autorización","content":"Control de acceso (Just-in-Time, mínimo privilegio).\\nPolítica de contraseñas fuertes.\\nGestión del ciclo de vida de identidad y expiración automática de sesiones.\\n","section":"Anexo de Procesamiento de Datos (“DPA”)","version":"current","path":"/es/privacy/dpa#4-identificación-y-autorización","category":"default"},{"title":"5. Protección durante Transmisión","content":"Cifrado en tránsito, firewalls (WAF, cloud-native), IPS.\\nMonitoreo de intentos de compromiso.\\n","section":"Anexo de Procesamiento de Datos (“DPA”)","version":"current","path":"/es/privacy/dpa#5-protección-durante-transmisión","category":"default"},{"title":"6. Protección durante Almacenamiento","content":"Detección de intrusiones en endpoints.\\nGestión de secretos (claves).\\nFormación en seguridad para empleados.\\nActualizaciones de software y parches.\\nSeparación lógica de instancias de clientes.\\n","section":"Anexo de Procesamiento de Datos (“DPA”)","version":"current","path":"/es/privacy/dpa#6-protección-durante-almacenamiento","category":"default"},{"title":"7. Seguridad Física","content":"Instalaciones de AWS protegidas según sus protocolos de seguridad (ver aws.amazon.com/compliance).\\n","section":"Anexo de Procesamiento de Datos (“DPA”)","version":"current","path":"/es/privacy/dpa#7-seguridad-física","category":"default"},{"title":"8. Gestión de Configuración","content":"Automatización continua para despliegue.\\nPruebas de integración.\\nProceso para correcciones de emergencia críticas.\\n","section":"Anexo de Procesamiento de Datos (“DPA”)","version":"current","path":"/es/privacy/dpa#8-gestión-de-configuración","category":"default"},{"title":"9. Gobernanza de TI y Seguridad","content":"Programa de gestión de riesgos de seguridad de la información y proveedores.\\nRevisiones de seguridad desde el diseño.\\nFiltros de email y ejercicios de phishing.\\nAcciones disciplinarias internas.\\n","section":"Anexo de Procesamiento de Datos (“DPA”)","version":"current","path":"/es/privacy/dpa#9-gobernanza-de-ti-y-seguridad","category":"default"},{"title":"10. Minimización y Retención","content":"Recopilación limitada a los fines del procesamiento.\\nEliminación/devolución de datos al finalizar servicios.\\nRetención según política de privacidad.\\n","section":"Anexo de Procesamiento de Datos (“DPA”)","version":"current","path":"/es/privacy/dpa#10-minimización-y-retención","category":"default"},{"title":"11. Portabilidad y Borrado","content":"Funciones de autoservicio para exportar o eliminar Datos del Cliente.\\n","section":"Anexo de Procesamiento de Datos (“DPA”)","version":"current","path":"/es/privacy/dpa#11-portabilidad-y-borrado","category":"default"},{"title":"12. Separación de Datos","content":"Separación de acceso por aplicación y usuario.\\nTablas normalizadas separadas por módulo.\\nInterfaces diseñadas para propósitos específicos.\\n","section":"Anexo de Procesamiento de Datos (“DPA”)","version":"current","path":"/es/privacy/dpa#12-separación-de-datos","category":"default"},{"title":"13. Inteligencia Artificial (IA/ML)","content":"Formación a equipos en uso seguro de IA.\\nRevisión legal, de privacidad y seguridad de casos de uso de IA/ML.\\n","section":"Anexo de Procesamiento de Datos (“DPA”)","version":"current","path":"/es/privacy/dpa#13-inteligencia-artificial-iaml","category":"default"},{"title":"Introducción","content":"Fintesk puede utilizar subencargados (sub-processors) para dar soporte en la prestación de los servicios solicitados por un Cliente. Este documento detalla la identidad, ubicación y función de cada subencargado, así como el tipo de datos que procesan.\\n","section":"Subencargados del Tratamiento de Datos de Fintesk","version":"current","path":"/es/privacy/fintesk-data-sub-processors#introducción","category":"default"},{"title":"Infraestructura y Alojamiento","content":"Estos proveedores son fundamentales para la operatividad básica y la seguridad de la plataforma.\\nSubencargado\\nPaís de la Entidad\\nMecanismo de Transferencia\\nServicio Aplicable\\nTipo de Datos Personales\\n\\n\\n\\n\\nDigitalOcean LLC\\nEE. UU.\\nDPA\\nServicios de alojamiento y CDN en Europa y EE. UU. (según ubicación del cliente).\\nTodos los Datos del Cliente almacenados, según se define en los Términos de Servicio.\\n\\n\\nCloudflare, Inc.\\nEE. UU.\\nDPA\\nDistribución de contenido, seguridad, prevención de abusos y servicios DNS.\\nDirección IP del Usuario Final o Agente.\\n","section":"Subencargados del Tratamiento de Datos de Fintesk","version":"current","path":"/es/privacy/fintesk-data-sub-processors#infraestructura-y-alojamiento","category":"default"},{"title":"Proveedores de Funciones Específicas","content":"Estos proveedores habilitan características opcionales o específicas dentro de Fintesk.\\nSubencargado\\nPaís de la Entidad\\nServicio Aplicable\\nTipo de Datos Personales\\n\\n\\n\\n\\nMessagebird UK Ltd.\\nReino Unido\\nDPA\\nProveedor para la función Live Chat en LeadBooster.\\n\\n\\nGoogle LLC\\nEE. UU.\\nDPA\\nProveedor para funciones de IA (resumen de emails, generación, análisis de datos).\\n\\n\\nMailgun Technologies, Inc\\nEE. UU.\\nDPA\\nProveedor para la función Simple Email\\n","section":"Subencargados del Tratamiento de Datos de Fintesk","version":"current","path":"/es/privacy/fintesk-data-sub-processors#proveedores-de-funciones-específicas","category":"default"},{"title":"Servicios de Atención al Cliente","content":"Subencargados que intervienen cuando solicitas soporte técnico.\\nSubencargado\\nPaís de la Entidad\\nServicio Aplicable\\nTipo de Datos Personales\\n\\n\\n\\n\\nSplashtop Inc.\\nEE. UU.\\nUso compartido de pantalla y co-navegación para resolver problemas.\\nDatos que el Cliente elija compartir durante sesiones de pantalla compartida.\\n","section":"Subencargados del Tratamiento de Datos de Fintesk","version":"current","path":"/es/privacy/fintesk-data-sub-processors#servicios-de-atención-al-cliente","category":"default"},{"title":"2. Subencargados Afiliados de Fintesk","content":"El grupo Fintesk no tiene subencargados afiliados.\\n","section":"Subencargados del Tratamiento de Datos de Fintesk","version":"current","path":"/es/privacy/fintesk-data-sub-processors#2-subencargados-afiliados-de-fintesk","category":"default"},{"title":"3. Ubicaciones de Alojamiento de Datos","content":"Fintesk aloja sus datos actualmente en las siguientes regiones de AWS:\\nEE. UU. Este\\nEE. UU. Oeste\\n","section":"Subencargados del Tratamiento de Datos de Fintesk","version":"current","path":"/es/privacy/fintesk-data-sub-processors#3-ubicaciones-de-alojamiento-de-datos","category":"default"},{"title":"Asignación de Centro de Datos","content":"Para optimizar el rendimiento y cumplimiento, las nuevas cuentas se alojan principalmente en:\\nEE. UU.\\nNota: Debido a condiciones externas (como mapeos de IP), las cuentas de empresa pueden alojarse en centros de datos diferentes a los predeterminados. Para confirmar la ubicación exacta de los datos de su empresa, contacte al equipo de Soporte.\\n","section":"Subencargados del Tratamiento de Datos de Fintesk","version":"current","path":"/es/privacy/fintesk-data-sub-processors#asignación-de-centro-de-datos","category":"default"},{"title":"1. Definiciones","content":"“Cliente” significa un cliente de Fintesk.\\n“Datos del cliente” significa datos personales, informes, direcciones y otros archivos, carpetas o documentos en formato electrónico que un Usuario del Servicio almacena dentro del Servicio.\\n“Datos Personales” significa cualquier información relativa a una persona física identificada o identificable.\\n“Área Pública” significa el área del Sitio a la que pueden acceder tanto los Usuarios como los Visitantes, sin necesidad de iniciar sesión.\\n“Área Restringida” significa el área del Sitio a la que solo pueden acceder los Usuarios, y donde el acceso requiere iniciar sesión.\\n“Usuario” significa un empleado, agente o representante de un Cliente, que utiliza principalmente las áreas restringidas del Sitio con el fin de acceder al Servicio en tal capacidad.\\n“Visitante” significa un individuo que es un Usuario, que utiliza el área pública, pero no tiene acceso a las áreas restringidas del Sitio o Servicio.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#1-definiciones","category":"default"},{"title":"2. Roles y responsabilidades","content":"Fintesk es el controlador de tus Datos personales, tal como se describe en este Aviso de privacidad, a menos que se indique lo contrario.\\nTenga en cuenta que este Aviso de privacidad no aplica en la medida en que procesemos Datos personales en el rol de un procesador (o en un rol similar, como un “proveedor de servicios” en ciertas jurisdicciones) a nombre de nuestros Clientes, incluido cuando ofrecemos a nuestros Clientes diferentes productos y/o servicios en la nube, a través de los cuales nuestros Clientes (y/o sus afiliados) conectan sus propios sitios web y aplicaciones a nuestra plataforma alojada, venden u ofrecen sus propios productos y/o servicios, envían comunicaciones electrónicas a otras personas o recopilan, usan, comparten o procesan Datos personales a través de nuestros productos y/o servicios en la nube. En tales casos, Fintesk no posee, controla ni dirige el uso de ninguno de los Datos del Cliente almacenados o procesados ​​por un Cliente o Usuario a través del Servicio. Solo el Cliente o los Usuarios tienen derecho a acceder, recuperar y dirigir el uso de dichos Datos del Cliente. El Cliente o el Usuario es el único responsable del tratamiento en virtud de las regulaciones de cualquier Dato del Cliente que contenga Datos Personales.\\nPara obtener la información de privacidad detallada aplicable a situaciones en las que un Cliente de Fintesk (y/o un afiliado del Cliente) es el controlador que usa los productos y servicios en la nube de Fintesk, comuníquese directamente con el Cliente respectivo. No somos responsables de las prácticas de privacidad o seguridad de datos de nuestros Clientes, que pueden diferir de las establecidas en este Aviso de privacidad. Si no se indica lo contrario en este Aviso de privacidad o en un documento adicional, procesamos los Datos Personales en el rol de un procesador o proveedor de servicios a nombre de un Cliente (y/o sus afiliados), donde somos el controlador responsable de los Datos Personales.\\nSi tus Datos Personales nos han sido enviados por o en nombre de un Cliente de Fintesk y desea ejercer cualquier derecho que pueda tener en virtud de las leyes de protección de datos aplicables, consulte directamente con el Cliente correspondiente.\\nFintesk desconoce qué Datos del Cliente están realmente almacenados o puestos a disposición por un Cliente o un Usuario para el Servicio y no accede directamente a dichos Datos del Cliente, excepto según lo autorizado por el Cliente, o según sea necesario para proporcionar Servicios al Cliente y sus Usuarios.\\nA excepción de lo dispuesto en este Aviso de privacidad, Fintesk no causa que los Datos del cliente que contienen Datos Personales almacenados en relación con los Servicios se transfieran o pongan a disposición de terceros de otro modo, excepto a los Sub-procesadores de terceros que pueden procesar dichos datos en nombre de Fintesk en conexión con la prestación de Servicios a los Clientes por parte de Fintesk.\\nFintesk no es responsable del contenido de los Datos personales incluidos en los Datos del cliente u otra información almacenada en sus servidores (o los servidores de sus subprocesadores) a discreción del Cliente o Usuario, ni Fintesk es responsable de la forma en que el Cliente o El usuario recopila, maneja la divulgación, distribuye o procesa dicha información.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#2-roles-y-responsabilidades","category":"default"},{"title":"3. La información que recopilamos","content":"Recopilamos diferentes tipos de información de o a través del Servicio.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#3-la-información-que-recopilamos","category":"default"},{"title":"3.1 Información que proporcionas directamente a Fintesk","content":"Registro de cuenta: cuando se registra para obtener una cuenta para acceder a uno o más de nuestros servicios, le solicitamos información como su nombre, número de contacto, dirección de correo electrónico, nombre de la empresa y país para completar el proceso de registro de cuenta. También puede proporcionarnos más información, como su foto, zona horaria e idioma, pero no requerimos esa información para registrarse en una cuenta.\\nRegistros de eventos y otros envíos de formularios: registramos la información que envía cuando (i) se registra para cualquier evento, incluidos seminarios web o seminarios, (ii) se suscribe a nuestro boletín informativo o cualquier otra lista de correo, (iii) envía un formulario para descargar cualquier producto, documento técnico u otros materiales, (iv) participar en concursos o responder encuestas, o (v) enviar un formulario para solicitar atención al cliente o ponerse en contacto con Fintesk por cualquier otro propósito.\\nProcesamiento de pagos: cuando nos compra algo, le pedimos que proporcione su nombre, información de contacto e información de la tarjeta de crédito u otra información de la cuenta de pago. Cuando envía la información de su tarjeta, almacenamos el nombre y la dirección del titular de la tarjeta, la fecha de vencimiento y los últimos cuatro dígitos del número de la tarjeta de crédito. No almacenamos el número real de la tarjeta de crédito. Para un procesamiento rápido de pagos futuros, si nos ha dado su aprobación, podemos almacenar la información de su tarjeta de crédito u otra información de pago en un formato cifrado en los servidores seguros de nuestros proveedores de servicios de pasarela de pago.\\nTestimonios: cuando nos autoriza a publicar testimonios sobre nuestros productos y servicios en sitios web, podemos incluir su nombre y otra información personal en el testimonio. Se le dará la oportunidad de revisar y aprobar el testimonio antes de que lo publiquemos. Si desea actualizar o eliminar su testimonio, puede contactarnos en privacidad@fintesk.com.\\nInteracciones con Fintesk: podemos registrar, analizar y utilizar sus interacciones con nosotros, incluidas las conversaciones por correo electrónico, teléfono y chat con nuestros profesionales de ventas y atención al cliente, para mejorar nuestras interacciones con usted y otros clientes.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#31-información-que-proporcionas-directamente-a-fintesk","category":"default"},{"title":"3.2 Información recopilada por los Clientes","content":"Un Cliente o Usuario puede almacenar o cargar Datos del Cliente en el Servicio. Fintesk no tiene una relación directa con las personas cuyos Datos personales aloja como parte de los Datos del cliente. Cada Cliente es responsable de notificar a sus clientes y terceros sobre el propósito por el cual el Cliente recopila sus Datos personales y cómo se procesan estos Datos personales en o a través del Servicio como parte de los Datos del cliente.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#32-información-recopilada-por-los-clientes","category":"default"},{"title":"3.3 Información recopilada automáticamente","content":"Información de navegadores, dispositivos y servidores: cuando visita nuestros sitios web, recopilamos información que los navegadores web, dispositivos móviles y servidores ponen a disposición, como la dirección del protocolo de Internet, el tipo de navegador, la preferencia de idioma, la zona horaria, la URL de referencia, la fecha y la hora de acceso, sistema operativo, fabricante del dispositivo móvil e información de la red móvil. Los incluimos en nuestros archivos de registro para comprender más acerca de los visitantes de nuestros sitios web.\\nInformación de cookies y tecnologías de seguimiento: Utilizamos cookies temporales y permanentes para identificar a los usuarios de nuestros servicios y mejorar la experiencia del usuario. Incorporamos identificadores únicos en nuestros productos para rastrear el uso de los mismos. También utilizamos cookies, etiquetas, scripts y otras tecnologías similares para identificar a los visitantes, realizar un seguimiento de la navegación en el sitio web, recopilar información demográfica sobre los visitantes y usuarios, comprender la eficacia de las campañas de correo electrónico y para el “engagement” específico de visitantes y usuarios mediante el seguimiento de sus actividades en nuestros sitios web.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#33-información-recopilada-automáticamente","category":"default"},{"title":"3.4 Información que recopilamos de terceros","content":"Registros de usuarios mediante proveedores de servicios de autenticación federados: puedes iniciar sesión en Fintesk vía proveedores de servicios de autenticación compatibles, como LinkedIn, Microsoft y Google. Estos servicios autenticarán su identidad y le darán la opción de compartir cierta información personal con nosotros, como su nombre y dirección de correo electrónico. Debe verificar su configuración de privacidad en cada Servicio Integrado para comprender qué información ese Servicio Integrado pone a nuestra disposición y realizar los cambios necesarios. Revise cuidadosamente los términos de uso y las políticas de privacidad de cada Servicio Integrado antes de usar sus servicios y conectarse a nuestro Servicio.\\nReferidos: si alguien le ha referido cualquiera de nuestros productos o servicios a través de cualquiera de nuestros programas de referencia, esa persona puede habernos proporcionado su nombre, dirección de correo electrónico y otra información personal. Puede ponerse en contacto con nosotros en privacidad@fintesk.com para solicitar que eliminemos su información de nuestra base de datos. Si nos brinda información sobre otra persona, o si otra persona nos brinda su información, solo utilizaremos esa información por el motivo específico por el cual nos la proporcionó.\\nInformación de nuestros socios revendedores y proveedores de servicios: si se comunica con cualquiera de nuestros socios revendedores o les expresa interés en cualquiera de nuestros productos o servicios, el socio revendedor puede pasar su nombre, dirección de correo electrónico, nombre de la empresa y otra información a Fintesk. Si te registras o asistes a un evento patrocinado por Fintesk, el organizador del evento puede compartir tu información con nosotros. Fintesk también puede recibir información sobre usted de sitios de reseñas, si comenta alguna reseña de nuestros productos y servicios, y de otros proveedores de servicios externos que contratamos para comercializar nuestros productos y servicios.\\nInformación que recopilamos y procesamos cuando integra el Servicio con terceros: puede conectar integraciones de terceros a su cuenta de Fintesk, lo que puede solicitar ciertos permisos para acceder a datos o enviar información hacia o desde su cuenta de Fintesk. Es su responsabilidad revisar cualquier integración de terceros que autorice. Podemos recopilar información sobre qué tipos de integraciones usas en tu cuenta de Fintesk. Cualquier permiso(s) otorgado(s) por usted, otorga a estos terceros el acceso a sus datos, lo que puede incluir (pero no se limita a) otorgar acceso a aplicaciones de terceros para ver, almacenar y modificar los datos de su cuenta de Fintesk. No somos responsables de las prácticas de integraciones de terceros, así que revise cuidadosamente los permisos que otorga a las aplicaciones de terceros.\\nInformación de sitios de redes sociales y otras fuentes disponibles públicamente: cuando proporciona comentarios o reseñas sobre nuestros productos, interactúa con nosotros en mercados, sitios de reseñas o sitios de redes sociales como Facebook, Twitter, LinkedIn e Instagram a través de publicaciones, comentarios, preguntas y otras interacciones, podemos recopilar dicha información disponible públicamente, incluida la información del perfil, para permitirnos conectarnos con usted, mejorar nuestros productos, comprender mejor las reacciones y los problemas de los usuarios, o reproducir y publicar sus comentarios en nuestros sitios web. Debemos decirle que una vez recopilada, esta información puede permanecer con nosotros incluso si la elimina de estos sitios. Fintesk también puede agregar y actualizar información sobre usted, de otras fuentes disponibles públicamente.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#34-información-que-recopilamos-de-terceros","category":"default"},{"title":"4. Cómo usamos la información que recopilamos","content":"Usamos la información que recopilamos de varias maneras para proporcionar el Servicio y operar nuestro negocio, incluidas las siguientes:\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#4-cómo-usamos-la-información-que-recopilamos","category":"default"},{"title":"4.1 Operaciones","content":"Usamos la información, aparte de los Datos del Cliente, para operar, mantener, mejorar y proporcionar todas las funciones del Servicio.\\nPara configurar y mantener su cuenta, y para hacer todas las demás cosas necesarias para proporcionar nuestros servicios, como habilitar la colaboración, proporcionar alojamiento de sitios web y correo electrónico, y realizar copias de seguridad y restaurar sus datos;\\nPara brindar atención al cliente y analizar y mejorar nuestras interacciones con los clientes;\\nPara detectar y prevenir transacciones fraudulentas y otras actividades ilegales, denunciar spam y proteger los derechos e intereses de Fintesk, los usuarios de Fintesk, terceros y el público.\\nProcesamos los Datos del Cliente únicamente de acuerdo con las instrucciones proporcionadas por el Cliente o Usuario correspondiente.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#41-operaciones","category":"default"},{"title":"4.2 Mejoras","content":"Usamos la información:\\nPara comprender cómo los usuarios usan nuestros productos y servicios, para monitorear y prevenir problemas, y para mejorar nuestros productos y servicios;\\nPara analizar tendencias, administrar nuestros sitios web y rastrear las navegaciones de los visitantes en nuestros sitios web para comprender qué buscan los visitantes y ayudarlos mejor;\\nSi para este propósito se requiere que Fintesk procese Datos del Cliente, entonces los datos solo se utilizarán de forma anónima o agregada.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#42-mejoras","category":"default"},{"title":"4.3 Comunicaciones","content":"Además de los fines mencionados anteriormente, podemos utilizar su información para los siguientes fines:\\nPara comunicarnos con usted (por ejemplo, por correo electrónico) sobre productos y materiales que ha descargado y servicios a los que se ha suscrito, cambios en este Aviso de privacidad, cambios en los Términos de servicio o avisos importantes;\\nPara mantenerlo informado sobre nuevos productos y servicios, próximos eventos, ofertas, promociones y otra información que creemos que será de su interés;\\nPara pedirle que participe en encuestas o para solicitar comentarios sobre nuestros productos y servicios;\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#43-comunicaciones","category":"default"},{"title":"4.4 Analítica","content":"Para actualizar, ampliar y analizar nuestros registros, identificar nuevos clientes y proporcionar productos y servicios que puedan ser de su interés;\\nPara monitorear y mejorar las campañas de marketing y hacer sugerencias relevantes para el usuario.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#44-analítica","category":"default"},{"title":"4.5 Bases legales para el procesamiento de datos personales","content":"Recopilamos y procesamos información sobre usted solo cuando tenemos una base legal o bases para hacerlo según las leyes aplicables. Las bases legales dependen de los productos y servicios que tu organización haya comprado de Fintesk, cómo se usan dichos productos y servicios, y cómo eliges interactuar y comunicarte con los sitios web y sistemas de Fintesk, y si asistes a eventos de Fintesk.\\nEsto significa que recopilamos y usamos sus Datos personales solo cuando:\\nLo necesitamos para operar y brindarle nuestros productos y servicios, brindar atención al cliente y funciones personalizadas, y para proteger la seguridad de nuestros productos y servicios;\\nSatisface un interés legítimo de Fintesk (que no se anula con sus intereses y derechos de protección de datos), como investigación y desarrollo, para brindarle información sobre nuestros productos y servicios que creemos que usted y su organización pueden encontrar útiles, y para proteger nuestros derechos e intereses legales;\\nUsted nos da su consentimiento para hacerlo con un propósito específico; o\\nTenemos que cumplir con una obligación legal.\\nCuando dependamos de intereses legítimos para procesar sus Datos personales, puede oponerse a ese procesamiento como se describe a continuación en la sección de “Tus opciones”. En respuesta a su objeción, dejaremos de procesar su información para los fines correspondientes a menos que tengamos motivos convincentes en las circunstancias o el procesamiento sea necesario en el contexto de reclamaciones legales. Fintesk también puede procesar otra información que constituye sus Datos personales con fines de marketing directo y usted tiene derecho a oponerse al uso de Fintesk de sus Datos personales para este fin en cualquier momento.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#45-bases-legales-para-el-procesamiento-de-datos-personales","category":"default"},{"title":"4.6 Límites adicionales en el uso de sus datos de usuario de Google","content":"Sin perjuicio de lo indicado en este Aviso de privacidad, si proporciona a Fintesk acceso a sus datos de Google (por ejemplo, cuando habilita la función de sincronización de correo electrónico con su cuenta de Google), el uso de esos datos por parte de Fintesk estará sujeto a estas restricciones adicionales:\\nFintesk solo usará el acceso para leer, escribir, modificar o controlar los cuerpos de los mensajes de Gmail (incluidos los archivos adjuntos), metadatos, encabezados y configuraciones para proporcionar un cliente de correo electrónico web que permita a los usuarios redactar, enviar, leer y procesar correos electrónicos y no transferirá estos datos de Gmail a otros a menos que hacerlo sea necesario para proporcionar y mejorar estas funciones, cumplir con la ley aplicable o como parte de una fusión, adquisición o venta de activos.\\nFintesk no utilizará estos datos de Gmail para publicar anuncios.\\nFintesk no permitirá que otras personas lean estos datos a menos que tengamos su acuerdo afirmativo para mensajes específicos, hacerlo es necesario por motivos de seguridad, como investigar abusos, cumplir con la ley aplicable o para las operaciones internas de Fintesk e incluso entonces solo cuando los datos tienen agregado y anonimizado.\\nEl uso de Fintesk de la información recibida y la transferencia de información de Fintesk a cualquier otra aplicación desde las API de Google cumplirán con la Política de datos de usuario de los servicios de API de Google, incluidos los requisitos de uso limitado.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#46-límites-adicionales-en-el-uso-de-sus-datos-de-usuario-de-google","category":"default"},{"title":"5. A quién divulgamos información","content":"Excepto como se describe en este Aviso de Privacidad, no divulgaremos intencionalmente los Datos personales o los Datos del cliente que recopilamos o almacenamos en el Servicio a terceros sin el consentimiento del Visitante, Usuario o Cliente correspondiente. Podemos divulgar información a terceros si nos da su consentimiento para hacerlo, así como en las siguientes circunstancias:\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#5-a-quién-divulgamos-información","category":"default"},{"title":"5.1 Información no restringida","content":"Cualquier información que voluntariamente elija incluir en un Área pública del Servicio, como una página de perfil público, estará disponible para cualquier Visitante o Usuario que tenga acceso a ese contenido.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#51-información-no-restringida","category":"default"},{"title":"5.2 Otros usuarios en su cuenta de empresa","content":"Cierta información sobre su uso de los Servicios de Fintesk está disponible para los administradores de su Cuenta de Fintesk y, según la configuración elegida por los Usuarios de la Cuenta, también para otros Usuarios con el fin de proporcionar los Servicios de Fintesk.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#52-otros-usuarios-en-su-cuenta-de-empresa","category":"default"},{"title":"5.3 Proveedores de servicios","content":"Trabajamos con proveedores de servicios externos que nos brindan sitios web, desarrollo de aplicaciones, hospedaje, mantenimiento, seguridad y detección de fraude, entre otros servicios. Estos terceros pueden tener acceso o procesar Datos personales o Datos del cliente como parte de la prestación de esos servicios para nosotros. Limitamos la información proporcionada a estos proveedores de servicios a la que sea razonablemente necesaria para que puedan realizar sus funciones, y nuestros contratos con ellos les exigen que mantengan la confidencialidad de dicha información.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#53-proveedores-de-servicios","category":"default"},{"title":"5.4 Comunidades de Fintesk y otro contenido generado por el usuario","content":"Ponemos a su disposición varios foros comunitarios y materiales de apoyo de autoayuda, así como blogs y otros medios para que usted publique información en nuestros sitios web. Esta información que publica es información disponible públicamente que usted elige divulgar y puede ser leída, recopilada y procesada por otras personas que visitan estos sitios web. A excepción del nombre de usuario (que puede ser su nombre real) y los detalles que elija incluir en su perfil, las categorías de datos divulgados en estas circunstancias dependerán de la información que elija proporcionar. Tus publicaciones y cierta información de perfil pueden permanecer incluso después de cancelar tu cuenta de Fintesk. Le instamos a que considere la sensibilidad de cualquier información que pueda divulgar de esta manera. Corregiremos o eliminaremos cualquier información que haya publicado en los sitios web si así lo solicita, como se describe a continuación en la Sección 10 “Tus opciones”. En algunos casos, es posible que no podamos eliminar su información, en cuyo caso le informaremos si no podemos y por qué.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#54-comunidades-de-fintesk-y-otro-contenido-generado-por-el-usuario","category":"default"},{"title":"5.5 Redes sociales","content":"Los sitios web de Fintesk pueden utilizar funciones de redes sociales, como el botón “Me gusta” de Facebook, las funciones para compartir de LinkedIn y Twitter, y otros widgets similares (“Funciones de redes sociales”). Es posible que dichas funciones de redes sociales le den la opción de publicar información sobre sus actividades en un sitio web en una página de perfil suya proporcionada por una red social de terceros para compartir contenido con otros dentro de su red. Las funciones de redes sociales están alojadas en la red social respectiva o directamente en nuestros sitios web. En la medida en que las funciones de las redes sociales estén alojadas en las respectivas redes sociales y haga clic en ellas desde nuestro sitio web, este último puede recibir información que demuestre que ha visitado nuestro sitio web. Si ha iniciado sesión en su cuenta de redes sociales, es posible que la red social respectiva pueda vincular su visita a nuestros sitios web con su perfil de redes sociales. Sus interacciones con las Funciones de redes sociales se rigen por las políticas de privacidad (y cualquier otro término aplicable) de las respectivas empresas que brindan las Funciones de redes sociales relevantes.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#55-redes-sociales","category":"default"},{"title":"5.6 Publicidad y Marketing","content":"Nos asociamos con redes publicitarias de terceros para mostrar publicidad en nuestro sitio web o para administrar nuestra publicidad en otros sitios. Nuestro socio de la red publicitaria utiliza cookies para recopilar información sobre sus actividades en este y otros sitios web para brindarle publicidad dirigida en función de sus intereses. Si no desea que esta información se utilice con el fin de mostrarle anuncios dirigidos, puede optar por no utilizar estos servicios: networkadvertising o aboutads (o si se encuentra en la Unión Europea, haciendo clic aquí: youronlinechoices). Tenga en cuenta que esto no le impide recibir publicidad, seguirá recibiendo anuncios genéricos.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#56-publicidad-y-marketing","category":"default"},{"title":"5.7 Socios de Negocios (Partners)","content":"Podemos compartir datos con socios confiables de Fintesk para contactarlo en función de su solicitud para recibir dichas comunicaciones, ayudarnos a realizar análisis estadísticos, brindar soporte de ventas o brindar soporte al cliente. Los socios tienen prohibido usar sus Datos personales, excepto para estos fines, y están obligados a mantener la confidencialidad de sus datos. Nos asociamos con terceros de confianza para proporcionar contenido que creemos que puede ser relevante para usted. Cuando interactúe con estos socios, le diremos con quién compartimos datos y le proporcionaremos un enlace a la política de privacidad del socio para que pueda saber cómo optar por no recibir las comunicaciones del socio. Estos socios deben cumplir con nuestras políticas de privacidad y protección de datos. Para obtener más información sobre nuestro programa de socios, consulte esta página. Si no desea que compartamos sus datos personales con estas empresas, comuníquese con el equipo de nuestro socio en partners@fintesk.com\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#57-socios-de-negocios-partners","category":"default"},{"title":"5.8 Información de identificación no personal","content":"Podemos poner a disposición de terceros cierta información recopilada automáticamente, agregada o no identificable personalmente para diversos fines, incluido (i) el cumplimiento de diversas obligaciones de información; (ii) con fines comerciales o de marketing; o (iii) para ayudar a dichas partes a comprender los intereses, hábitos y patrones de uso de nuestros Clientes, Usuarios y Visitantes para ciertos programas, contenido, servicios y/o funcionalidades disponibles a través del Servicio, todo lo anterior está sujeto a límites adicionales en el uso de sus datos como se establece en este Aviso de Privacidad.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#58-información-de-identificación-no-personal","category":"default"},{"title":"5.9 Aplicación de la ley, proceso legal y cumplimiento","content":"Podemos divulgar Datos personales u otra información si así lo requiere la ley o si creemos de buena fe que dicha acción es necesaria para cumplir con las leyes aplicables, en respuesta a una orden judicial válida a primera vista, una citación judicial o de otro tipo del gobierno, o para cooperar de otro modo con las fuerzas del orden u otras agencias gubernamentales. También nos reservamos el derecho de divulgar Datos personales u otra información que consideremos, de buena fe, apropiada o necesaria para (i) tomar precauciones contra posibles riesgos, (ii) protegernos a nosotros mismos o a otros de usos o actividades fraudulentos, abusivos o ilegales. , (iii) investigar y defendernos contra reclamos o acusaciones de terceros, (iv) proteger la seguridad o integridad del Servicio y cualquier instalación o equipo utilizado para hacer que el Servicio esté disponible, o (v) proteger nuestra propiedad y derechos u otros derechos legales, hacer cumplir nuestros contratos, la propiedad o la seguridad de otros.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#59-aplicación-de-la-ley-proceso-legal-y-cumplimiento","category":"default"},{"title":"5.10 Cambio de titularidad","content":"La información sobre Usuarios y Visitantes, incluidos los Datos personales, puede divulgarse y transferirse de otro modo a un adquirente, sucesor o cesionario como parte de cualquier fusión, adquisición, financiación de deuda, venta de activos o transacción similar, así como en el caso de una insolvencia, quiebra o administración judicial en la que la información se transfiere a uno o más terceros como uno de nuestros activos comerciales y solo si el destinatario de los Datos del usuario o del visitante se compromete con una Política de privacidad que tiene términos sustancialmente consistentes con este Aviso de privacidad.\\nLos Datos del Cliente pueden transferirse física o electrónicamente a un adquirente, sucesor o cesionario como parte de cualquier fusión, adquisición, financiamiento de deuda, venta de activos o transacción similar, así como en caso de insolvencia, quiebra o administración judicial en cuya información se transfiere a uno o más terceros como uno de nuestros activos comerciales, con el único propósito de continuar la operación del Servicio, y solo si el destinatario de los Datos del Cliente se compromete con una Política de privacidad que tiene términos sustancialmente consistentes con este Aviso de Privacidad.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#510-cambio-de-titularidad","category":"default"},{"title":"6. Seguridad de los datos","content":"En Fintesk, nos tomamos muy en serio la seguridad de los datos. Hemos tomado medidas para implementar medidas de seguridad administrativas, técnicas y físicas apropiadas para evitar el acceso, uso, modificación, divulgación o destrucción no autorizados de la información que nos confía. Sin embargo, ningún sistema de seguridad es perfecto y, debido a la naturaleza inherente de Internet, no podemos garantizar que los datos, incluidos los Datos personales, estén absolutamente a salvo de intrusiones u otros accesos no autorizados por parte de terceros. Usted es responsable de proteger su(s) contraseña(s) y otros factores de autenticación, así como de mantener la seguridad de sus dispositivos. Si cree que sus datos personales se han visto comprometidos, contáctenos como se establece en la sección “Cómo contactarnos”. Si nos enteramos de una violación de los sistemas de seguridad, le informaremos a usted y a las autoridades sobre la ocurrencia de la violación de acuerdo con la ley aplicable.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#6-seguridad-de-los-datos","category":"default"},{"title":"7. Transferencias internacionales de datos","content":"Fintesk puede transferir sus Datos personales a países distintos de aquel en el que vive, incluido transferencias a los Estados Unidos. En la medida en que los Datos personales se transfieran al exterior, Fintesk garantizará el cumplimiento de los requisitos de las leyes aplicables en la jurisdicción respectiva de acuerdo con las obligaciones de Fintesk.\\nEn particular, ofrecemos las siguientes garantías si Fintesk transfiere Datos personales desde jurisdicciones con diferentes leyes de protección de datos:\\nCláusulas contractuales estándar de la Comisión Europea. Fintesk utiliza cláusulas contractuales estándar aprobadas por la Comisión Europea (y las cláusulas contractuales estándar equivalentes para el Reino Unido cuando corresponda) para las transferencias a países que no están sujetos a una decisión de adecuación de la Comisión Europea o su legislatura o regulador local.\\nPrivacy Shield; Fintesk participa y cumple con la EU-U.S. Privacy Shield Framework es establecido por el Departamento de Comercio de EE. UU. con respecto a la recopilación, el uso y la retención de información personal de personas en la Unión Europea. De conformidad con los Principios del Privacy Shield Framework , Fintesk se compromete a resolver las quejas sobre nuestra recopilación o uso de su información personal. Las personas de la Unión Europea que tengan consultas o quejas sobre nuestra política de protección de la privacidad deben comunicarse primero con el responsable de protección de datos de Fintesk en privacidad@fintesk.com. Fintesk se ha comprometido además a cooperar con el panel establecido por las autoridades de protección de datos (DPA) de la Unión Europea en relación con las quejas no resueltas del Privacy Shield Framework relacionadas con datos de recursos humanos y datos que no son de recursos humanos transferidos desde la Unión Europea. En cualquier asunto relacionado con la Unión Europea-EE.UU Privacy Shield Framework, Fintesk está sujeto a los poderes de investigación y ejecución de la Comisión Federal de Comercio (FTC). Bajo ciertas condiciones, descritas más detalladamente en el sitio web de Privacy Shield en How-to-Submit-a-Complaint, puede invocar el arbitraje vinculante cuando se hayan agotado otros procedimientos de resolución de disputas.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#7-transferencias-internacionales-de-datos","category":"default"},{"title":"8. Privacidad de Menores y Niños","content":"Proteger la privacidad de los niños pequeños es extremadamente importante. Nuestro Servicio no está dirigido ni destinado a niños menores de 18 años, y no recopilamos a sabiendas Datos personales de niños menores de 18 años. Si es menor de 18 años, no use ni acceda al Servicio en en cualquier momento o de cualquier manera. Si nos enteramos de que se han recopilado Datos personales en el Servicio de personas menores de 18 años y sin el consentimiento verificable de los padres, tomaremos las medidas adecuadas para eliminar esta información. Si es padre o tutor y descubre que su hijo menor de 18 años ha obtenido una Cuenta en el Servicio, puede alertarnos a privacidad@fintesk.com y solicitar que eliminemos los Datos personales de ese niño/menor de nuestros sistemas.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#8-privacidad-de-menores-y-niños","category":"default"},{"title":"9. Retención de datos","content":"Conservaremos sus Datos personales durante un período de tiempo que sea consistente con el propósito original de la recopilación de datos, o según sea necesario para cumplir con nuestras obligaciones legales, resolver disputas y hacer cumplir nuestros acuerdos. Cuando ya no tengamos una necesidad legítima de procesar su información, eliminaremos o convertiremos en anónima su información de nuestras bases de datos activas. También almacenaremos la información de forma segura y la aislaremos para que no se procese más en discos de respaldo hasta que sea posible eliminarla.\\nPara el servicio CRM de Fintesk:\\nel contenido de las cuentas cerradas se elimina dentro de los 6 meses posteriores a la fecha de cierre;\\nel contenido de las Cuentas de prueba gratuitas cerradas se elimina dentro de los 30 días posteriores a la fecha de cierre;\\nLas copias de seguridad del archivo del servidor se conservan durante 3 meses.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#9-retención-de-datos","category":"default"},{"title":"10.1 Sus derechos con respecto a la información que tenemos sobre usted como controlador","content":"Derecho de acceso: tiene derecho a saber qué datos tenemos sobre usted (si los hay).\\nDerecho a la rectificación de datos: tiene derecho a solicitar la corrección de sus Datos personales en caso de que sean inexactos o incompletos.\\nDerecho a la eliminación de datos: tiene derecho, bajo ciertas condiciones, a solicitar la eliminación de sus Datos personales, incluso en situaciones en las que el procesamiento de sus Datos personales ya no sea necesario para los fines para los que fueron recopilados, o si el procesamiento de sus Datos personales se basaron en su consentimiento y desea retirar su consentimiento, y no hay otros motivos para procesar sus Datos personales.\\nDerecho a la restricción del procesamiento: también puede tener derecho a solicitar que se restrinja el uso de su información en ciertas circunstancias, como cuando se ha opuesto a que usemos sus datos, pero necesitamos verificar si tenemos motivos legítimos para el uso de ellos.\\nDerecho a la portabilidad de datos: tiene derecho a transferir su información a un tercero en un formato estructurado, de uso común y legible por máquina, en circunstancias en las que la información se procesa con su consentimiento o por medios automatizados.\\nDerecho a oponerse: tiene derecho a oponerse al uso de su información en determinadas circunstancias, como el uso de su información personal para marketing.\\nDerecho a quejarse: tiene derecho a presentar una queja ante la autoridad supervisora correspondiente si tiene alguna queja sobre la forma en que recopilamos, usamos o compartimos su información. Es posible que este derecho no esté disponible para usted si no existe una autoridad supervisora que se ocupe de la protección de datos en su país.\\nRespetamos sus derechos de privacidad y le brindamos un acceso razonable a los Datos personales que pueda haber proporcionado a través del uso de los Servicios. Si desea acceder o modificar cualquier otro dato personal que tengamos sobre usted, o solicitar que eliminemos o transfiramos cualquier información sobre usted que hayamos obtenido de un Servicio Integrado, puede comunicarse con nosotros como se establece en la sección “Cómo contactarnos”. Si lo solicita, eliminaremos o bloquearemos cualquier referencia a usted en nuestra base de datos.\\nAdemás:\\nPuede actualizar, corregir o eliminar la información y las preferencias de su Cuenta en cualquier momento accediendo a la página de configuración de su Cuenta en el Servicio. Tenga en cuenta que si bien cualquier cambio que realice se reflejará en las bases de datos de usuarios activas al instante o dentro de un período de tiempo razonable, podemos conservar toda la información que envíe para realizar copias de seguridad, archivar, prevenir fraudes y abusos, análisis, cumplimiento de obligaciones legales o cuando creamos razonablemente que tenemos una razón legítima para hacerlo.\\nPuede negarse a compartir ciertos Datos personales con nosotros, en cuyo caso es posible que no podamos proporcionarle algunas de las características y funciones del Servicio.\\nInformación opcional: puede optar por no proporcionar información de perfil opcional, como su foto. También puede eliminar o cambiar su información de perfil opcional. Siempre puede optar por no completar los campos no obligatorios cuando envía cualquier formulario vinculado a nuestros sitios web.\\nEn cualquier momento, puede objetar el procesamiento de sus Datos personales, por motivos legítimos, excepto si la ley aplicable permite lo contrario. Si cree que se ha infringido su derecho a la privacidad otorgado por las leyes de protección de datos aplicables, comuníquese con el responsable de protección de datos de Fintesk en privacidad@fintesk.com.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#101-sus-derechos-con-respecto-a-la-información-que-tenemos-sobre-usted-como-controlador","category":"default"},{"title":"10.2 Información de navegación","content":"Puede optar por no participar en la recopilación de información de navegación sobre su visita al Sitio por parte de Google Analytics utilizando la función de exclusión voluntaria de Google Analytics. Puede deshabilitar las cookies del navegador antes de visitar nuestros sitios web. Sin embargo, si lo hace, es posible que no pueda usar ciertas funciones de los sitios web correctamente.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#102-información-de-navegación","category":"default"},{"title":"10.3 Optar por no recibir comunicaciones comerciales","content":"Puede optar por no recibir boletines y otros mensajes no esenciales utilizando la función “cancelar suscripción” incluida en todos esos mensajes o enviando un correo electrónico a la dirección proporcionada en la sección “Cómo contactarnos”. Tenga en cuenta que continuará recibiendo avisos y correos electrónicos esenciales, como correos electrónicos de notificación de cuenta (cambio de contraseña, recordatorios de renovación, etc.), alertas de incidentes de seguridad, notificaciones de actualizaciones de seguridad y privacidad, y correos electrónicos esenciales relacionados con transacciones y pagos. Los usuarios pueden ver y modificar la configuración relacionada con la naturaleza y la frecuencia de las comunicaciones promocionales que reciben de nosotros accediendo a la pestaña “Funcionalidad de la cuenta” en el Servicio.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#103-optar-por-no-recibir-comunicaciones-comerciales","category":"default"},{"title":"10.4 Información procesada en nombre del Cliente de Fintesk","content":"Fintesk no tiene una relación directa con los clientes del Cliente o un tercero cuyos Datos personales pueda procesar en nombre de un Cliente. Una persona que busca acceso, o que busca corregir, modificar, eliminar datos inexactos o retirar el consentimiento para un contacto posterior debe dirigir su consulta al Cliente o Usuario con el que trata directamente.\\nLos Clientes de Fintesk pueden eliminar, modificar o bloquear el acceso a cualquier Dato personal dentro de la aplicación de Fintesk o poniéndose en contacto con el Soporte de Fintesk.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#104-información-procesada-en-nombre-del-cliente-de-fintesk","category":"default"},{"title":"11. Solicitudes de No rastrear (DNT, Do Not Track)","content":"Algunos navegadores de Internet han habilitado funciones de “No rastrear” (DNT), que envían una señal (llamada señal DNT) a los sitios web que visita indicando que no desea que lo rastreen. Actualmente, no existe un estándar que rija lo que los sitios web pueden o deben hacer cuando reciben estas señales. Por ahora, no tomamos medidas en respuesta a estas señales.\\nMientras tanto, puede optar por no recibir publicidad basada en intereses de redes publicitarias visitando los siguientes sitios web: http://www.aboutads.info/consumers y http://www.networkadvertising.org. Esto lo excluirá de muchas, pero no todas, de las actividades publicitarias basadas en intereses en las que participamos nosotros o terceros. Las elecciones que haga pueden ser específicas del navegador y del dispositivo. Si elimina sus cookies o utiliza un navegador diferente o una computadora o dispositivo diferente, es posible que deba actualizar sus opciones de exclusión.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#11-solicitudes-de-no-rastrear-dnt-do-not-track","category":"default"},{"title":"12. Cambios y actualizaciones a este Aviso de Privacidad","content":"Vuelva a visitar esta página periódicamente para estar al tanto de cualquier cambio en este Aviso de Privacidad, que podemos actualizar de vez en cuando. Si modificamos el Aviso de Privacidad, lo pondremos a disposición a través del Servicio, indicaremos la fecha de la última revisión y cumpliremos con la ley aplicable. Su uso continuado del Servicio después de que el Aviso de Privacidad revisado haya entrado en vigencia indica que ha leído, entendido y aceptado la versión actual del Aviso.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#12-cambios-y-actualizaciones-a-este-aviso-de-privacidad","category":"default"},{"title":"13. Cómo contactarnos","content":"Comuníquese con nosotros si tiene preguntas o comentarios sobre este Aviso, sus Datos personales, nuestras prácticas de uso y divulgación o sus opciones de consentimiento por correo electrónico a privacidad@fintesk.com. Si tiene alguna inquietud o queja sobre este Aviso o sus Datos personales, puede comunicarse con el Oficial de Protección de Datos (dpo) de Fintesk por correo electrónico a privacidad@fintesk.com.\\n","section":"Aviso de Privacidad – Fintesk","version":"current","path":"/es/privacy#13-cómo-contactarnos","category":"default"},{"title":"Condiciones de servicio de Fintesk","content":"Los Servicios de Fintesk se ofrecen al Cliente sujeto a su aceptación, sin modificaciones, de estos Términos de servicio y cualquier modificación futura de los mismos, y los procedimientos que pueden publicarse periódicamente o ponerse a disposición del Cliente en o a través de los Servicios de Fintesk. Cuando un Cliente utiliza los Servicios de Fintesk, estos Términos forman un contrato legalmente vinculante entre el Cliente y Fintesk. Si está celebrando estos Términos en nombre de una entidad, como su empleador o la empresa para la que trabaja, declara y garantiza que tiene la autoridad legal para representar y vincular a dicho Cliente, en cuyo caso los términos “usted, ” “su”, “cliente” o un término en mayúscula relacionado en el presente se referirá a dicho Cliente.\\nSI ESTÁ UTILIZANDO LA DIRECCIÓN DE CORREO ELECTRÓNICO DE SU EMPLEADOR O DE UNA ENTIDAD PARA REGISTRARSE EN LOS SERVICIOS DE FINTESK, TENGA EN CUENTA QUE SE LE CONSIDERA UN REPRESENTANTE O AGENTE AUTORIZADO DE SU EMPLEADOR O UNA ENTIDAD (SEGÚN CORRESPONDA).\\nEstos Términos son un contrato que rige el uso de los Servicios de Fintesk por parte de los Clientes y consisten en lo siguiente:\\nTérminos maestros\\nTérminos complementarios\\nAviso de Privacidad\\nSi se registra para una Prueba gratuita de la Plataforma, las disposiciones aplicables de los Términos regirán esa Prueba gratuita.\\nPOR FAVOR LEA ESTOS TÉRMINOS CUIDADOSAMENTE. AL REGISTRARSE, ACCEDER, NAVEGAR Y UTILIZAR DE OTRO MODO LOS SERVICIOS DE FINTESK, USTED RECONOCE QUE HA LEÍDO, ENTENDIDO Y ACEPTA ESTAR OBLIGADO POR ESTOS TÉRMINOS. SI NO ACEPTA ESTAR OBLIGADO POR ESTOS TÉRMINOS, NO ACCEDA, NAVEGUE NI UTILICE DE OTRO MODO LOS SERVICIOS DE FINTESK.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#condiciones-de-servicio-de-fintesk","category":"default"},{"title":"1.1 Definiciones","content":"“Cuenta” hace referencia al medio principal para acceder y utilizar los Servicios de Fintesk, sujeto al pago de una Tarifa designada en el Plan seleccionado.\\n“Administrador” significa un Usuario(s) de una Cuenta a la que el Cliente ha otorgado una autorización especial para administrar la Cuenta del Cliente.\\n“Afiliados/as” se refiere a cualquier entidad legal que controle o posea más del 50% de las acciones o valores en circulación de dicha entidad, que esté controlada o bajo el control común de una parte.\\n“Servicio Beta” hace referencia a cualquier funcionalidad de los Servicios de Fintesk que esté en desarrollo o que no se haya lanzado comercialmente como producto final y que Fintesk haya puesto a disposición del Cliente para su prueba y evaluación.\\n“Cliente” hace referencia a una persona física o jurídica o entidad que ha aceptado estos Términos con Fintesk mediante el uso de los Servicios de Fintesk.\\n“Datos del Cliente” se refiere a datos y documentos de cualquier tipo (imágenes, hojas de cálculo, archivos de texto, etc.) y cualquier otro dato e información digital, que esté sujeto a la Plataforma, o que el Cliente haya insertado de otro modo en la Plataforma y para el cual Fintesk es un “procesador” (como se define en el Aviso de Privacidad). Los Datos del Cliente no contendrán Información Sensible.\\n“Contenido” hace referencia a cualquier dato e información disponible a través de los Servicios de Fintesk o contenido dentro de la estructura de los Servicios de Fintesk, incluidos, entre otros, artículos, documentos, folletos, presentaciones, fotografías, imágenes, trabajos audiovisuales, otros materiales informativos y cualquier comentario.\\n“Credenciales” se refiere a todos los nombres de usuario, contraseñas y otras credenciales de acceso creadas o asignadas al Cliente y cada uno de sus Usuarios designados para el uso de los Servicios de Fintesk.\\n“Característica” hace referencia a una función o conjunto de funciones que brindan una capacidad particular dentro de los Servicios de Fintesk según lo determinado por Fintesk y según lo rigen los Términos Complementarios aplicables.\\n“Tarifa” se refiere al pago regular por usar los Servicios de Fintesk a través de una Cuenta activa.\\n“Comentarios o Feedback” hace referencia a cualquier comentario, informe de error, comentario, sugerencia o modificación de los Servicios de Fintesk que el Cliente o un Usuario proporciona a Fintesk.\\n“Prueba gratuita” hace referencia al acceso temporal con el fin de probar cualquier parte de los Servicios o Funciones de Fintesk de acuerdo con cualquier Plan seleccionado sin pagar una Tarifa.\\n“Términos Maestros” hace referencia a estos términos legales y comerciales básicos que se aplican al uso de los Servicios de Fintesk por parte del Cliente.\\n“Aplicación que no es de Fintesk” hace referencia a una funcionalidad de aplicación de software basada en web, móvil, fuera de línea u otra que interactúa con los Servicios de Fintesk, que es proporcionada por el Cliente o un tercero. Las Aplicaciones que no sean de Fintesk, distintas de las obtenidas o proporcionadas por el Cliente, serán identificables como tal.\\n“Fintesk” significa, según lo requiera el contexto, Fintesk SpA., LibroContable SpA o cualquier otra de sus Afiliadas.\\n“Materiales de Fintesk” se refiere a las interfaces visuales, gráficos, diseño, sistemas, métodos, información, código de computadora, software, servicios, “apariencia”, organización, compilación del Contenido, código, datos y todos los demás elementos de Fintesk. Servicios.\\n“Servicios de Fintesk” hace referencia al Sitio web, el Contenido, los Materiales de Fintesk, la Plataforma y todos los demás contenidos, servicios y/o productos, y Funciones/Características, disponibles en la Plataforma o a través de ella.\\n“Plan” se refiere a varios criterios relacionados con el uso, la funcionalidad y el costo de un Servicio de Fintesk en particular y en el que se basa la Tarifa.\\n“Plazo del Plan” hace referencia al período de uso de los Servicios de Fintesk por parte del Cliente que comienza en la fecha de pago de la Tarifa correspondiente al Plan asociado y finaliza en la fecha de vencimiento del Plan.\\n“Plataforma” hace referencia a la aplicación de Fintesk para la Gestión de relaciones con los Clientes, incluidas las Funciones o Características asociadas.\\n“Aviso de privacidad” hace referencia al aviso, tal como se establece en Aviso de privacidad, que describe cómo Fintesk recopila, recibe, usa, almacena, comparte, transfiere y procesa los “Datos del Cliente” en relación a como el Cliente usa los Servicios de Fintesk. También describe las opciones del Cliente con respecto al uso, así como los derechos del Cliente de acceso y corrección de sus “Datos del Cliente”.\\n“Fecha de renovación” significa la fecha en que el Plan del Cliente se renovará automáticamente de forma anual o mensual, según el Plan del Cliente.\\n“Revendedor” hace referencia a una entidad de terceros que (i) compra Servicios de Fintesk a Fintesk y revende dichos Servicios de Fintesk a los Clientes, (ii) factura a dichos Clientes directamente y (iii) proporciona a dichos Clientes un servicio de atención al cliente relacionado con los Servicios de Fintesk.\\n“Información confidencial” significa números de tarjetas de crédito o débito; números de cuenta financieras o instrucciones de transferencia; números de identificación emitidos por el gobierno (como números de Seguro Social, números de pasaporte), información biométrica, información de salud personal (u otra información protegida bajo cualquier ley de protección de datos de salud aplicable), información personal de niños protegidos bajo cualquier ley de protección de datos de niños y cualquier otra información o combinaciones de información que se encuentran dentro de la definición de “categorías especiales de datos” según cualquier ley aplicable relacionada con la privacidad y la protección de datos.\\n“Sub-procesador” hace referencia a cualquier tercero, como se establece aquí, que Fintesk utiliza en la prestación de los Servicios de Fintesk.\\n“Términos Complementarios” significa los términos, tal como se establecen aquí, aplicables al uso por parte del Cliente de una Característica en particular o cualquier servicio de terceros y que forman parte de los Términos.\\n“Términos” significa estos Términos de servicio y consiste en los Términos maestros, los Términos complementarios aplicables y el Aviso de privacidad.\\n“Usuario” se refiere a una entidad o persona a la que se otorgan los derechos y privilegios autorizados para utilizar la Cuenta en nombre de un Cliente.\\n“Sitio web” hace referencia a la compilación de todos los documentos web (incluidas imágenes, archivos php y html) disponibles a través de Fintesk.com, sus subdominios o dominios con nombres idénticos bajo otros dominios principales y propiedad de Fintesk.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#11-definiciones","category":"default"},{"title":"2. MODIFICACIONES A LAS CONDICIONES","content":"Fintesk se reserva el derecho, a su exclusivo criterio, de cambiar, modificar, agregar o eliminar cualquier parte de los Términos de vez en cuando. La notificación de dichas modificaciones puede publicarse en o a través de la Plataforma o los Servicios de Fintesk. El uso continuo por parte del Cliente de los Servicios de Fintesk constituye su aceptación de estos Términos y cualquier modificación que surja.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#2-modificaciones-a-las-condiciones","category":"default"},{"title":"3.1 Uso de los servicios de Fintesk","content":"Sujeto a estos Términos y a los Términos complementarios aplicables, y al pago de la Tarifa aplicable, Fintesk otorga al Cliente y a sus Usuarios una licencia no exclusiva, no transferible y no sublicenciable para usar los Servicios de Fintesk para:\\nrecopilar, almacenar y organizar los Datos del Cliente;\\nmodificar y eliminar los Datos del Cliente; y\\npersonalizar las Funciones estándar o la funcionalidad de los Servicios de Fintesk.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#31-uso-de-los-servicios-de-fintesk","category":"default"},{"title":"3.2 Modificaciones a los servicios de Fintesk","content":"Fintesk se reserva el derecho de modificar los Servicios de Fintesk o cualquier parte o elemento de los mismos de vez en cuando sin previo aviso, lo que incluye, entre otros:\\nCambiar la marca, reempaquetar o cambiar el precio (incluidos los ajustes a las Tarifas actuales que se aplicarán en la próxima fecha de renovación del Plan) de los Servicios de Fintesk a su exclusivo criterio;\\nDejar de proporcionar o discontinuar el desarrollo de cualquier Servicio, Función o parte o elemento de la Plataforma de Fintesk en particular, de forma temporal o permanente;\\ntomar las medidas necesarias para preservar los derechos de Fintesk sobre cualquier uso de los Servicios de Fintesk que pueda interpretarse razonablemente como una violación de los derechos de propiedad intelectual de Fintesk, distribución de virus de Internet, gusanos, caballos de Troya, malware y otras actividades destructivas o actividades ilegales.\\nSegún corresponda, el Cliente puede ser notificado de dichas modificaciones al iniciar sesión en la Cuenta.\\nSi el Cliente no acepta una modificación, el Cliente deberá notificar a Fintesk o al Revendedor (si el Cliente compró el acceso a los Servicios de Fintesk a un Revendedor) antes de la fecha de vigencia de la modificación, y la Cuenta del Cliente finalizará en la fecha de vigencia de la modificación. Sin embargo, el uso continuado por parte del Cliente de los Servicios de Fintesk, o cualquier parte o elemento de los mismos, después de la fecha de vigencia de una modificación indicará su consentimiento a las modificaciones. Fintesk no será responsable ante el Cliente o cualquier tercero por cualquier modificación, suspensión o interrupción de los Servicios de Fintesk, o cualquier parte o elemento de los mismos.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#32-modificaciones-a-los-servicios-de-fintesk","category":"default"},{"title":"3.3 Credenciales","content":"El Cliente es responsable de mantener la confidencialidad de todas las Credenciales y es el único responsable de todas las actividades que ocurran con dichas Credenciales. Estas Credenciales no deben ser compartidas ni utilizadas por varias personas, pero pueden reasignarse a un nuevo Usuario que reemplace a un Usuario anterior que haya dejado de trabajar (o haya cambiado de función laboral) y que ya no utilice los Servicios de Fintesk. Fintesk se reserva el derecho de rescindir cualquier Credencial de usuario que Fintesk determine razonablemente que puede haber sido utilizada por un tercero no autorizado o de manera no autorizada, según lo determine únicamente Fintesk, y notificará de inmediato dicha rescisión al Cliente.\\nEl cliente debe notificar de inmediato a Fintesk:\\nde cualquier revelación, pérdida o uso no autorizado real o sospechoso de cualquier Credencial;\\nde la salida de un Usuario de la organización del Cliente;\\nde un cambio en el rol de un Usuario en la organización del Cliente; o\\nde cualquier terminación del derecho de un Usuario por cualquier razón.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#33-credenciales","category":"default"},{"title":"3.4 Cambio de planes","content":"El Cliente puede actualizar o degradar un Plan actual en cualquier momento seleccionando un nuevo Plan entre la colección de Planes definidos por Fintesk. En tal caso, la tarjeta de crédito del Cliente registrada en Fintesk se cargará automáticamente con una Tarifa para el próximo intervalo de pago con la tasa estipulada en el nuevo Plan. Si el Cliente elige actualizar su Plan, la parte no utilizada de cualquier Tarifa prepaga se aplicará a la Tarifa del Plan actualizado. Si, después del comienzo de un Plazo del Plan, el Cliente elige degradar su Plan, esto puede causar la pérdida de Funciones, funcionalidad, capacidad de la Cuenta, así como la pérdida de Datos del Cliente. No se reembolsará al Cliente ninguna Tarifa prepaga o pendiente por la diferencia de precio entre los Planes en caso de que el Cliente decida bajar de categoría después del comienzo del Plazo del Plan.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#34-cambio-de-planes","category":"default"},{"title":"3.5 Gestión de la Cuenta del Cliente","content":"El Cliente reconoce que retiene el control administrativo sobre a quién otorga acceso a los Datos del Cliente alojados en los Servicios de Fintesk. El Cliente puede especificar un Usuario para que sea el propietario de la facturación y, según el Plan, uno o más Usuarios para que sean Administradores para administrar su cuenta, y Fintesk tiene derecho a depender de las comunicaciones de un Administrador al atender la Cuenta del Cliente. Los Administradores del Cliente pueden tener la capacidad de acceder, monitorear, usar y/o exportar Datos del Cliente.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#35-gestión-de-la-cuenta-del-cliente","category":"default"},{"title":"3.6 Soporte técnico","content":"Fintesk proporcionará soporte técnico razonable al Cliente y sus Usuarios a través de las siguientes opciones, como se describe a continuación, tan pronto como sea razonablemente posible.\\nChat: disponible para todos los usuarios, a través de su cuenta de Fintesk\\nTeléfono: los usuarios de ciertos planes pueden solicitar una devolución de llamada del soporte a través de su cuenta de Fintesk\\nSi tiene problemas para iniciar sesión o no tiene una cuenta de Fintesk, puede comunicarse con nosotros en contacto@fintesk.com.\\nSin perjuicio de lo anterior, para cualquier Servicio de Fintesk comprado a un Revendedor, el soporte técnico de primera línea será proporcionado por el Revendedor y no por Fintesk.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#36-soporte-técnico","category":"default"},{"title":"3.7 Verificación de usuario","content":"El cliente comprende y acepta que podemos solicitarle que proporcione información que puede usarse para confirmar su identidad y ayudar a garantizar la seguridad de su Cuenta y/o Usuario. En caso de que el Cliente pierda el acceso a una Cuenta o solicite información sobre una Cuenta, nos reservamos el derecho de solicitar al Cliente cualquier verificación que consideremos necesaria antes de restablecer el acceso o proporcionar información sobre dicha Cuenta.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#37-verificación-de-usuario","category":"default"},{"title":"3.8 Características","content":"Fintesk puede, de vez en cuando, hacer que las Funciones estén disponibles a través de los Servicios de Fintesk, y que pueden estar sujetas a Términos Complementarios. El uso por parte del Cliente de cualquiera de dichas Funciones está sujeto a los Términos Complementarios aplicables.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#38-características","category":"default"},{"title":"3.9 Prueba gratuita","content":"Un nuevo Cliente puede tener derecho a una Prueba gratuita y no está obligado a proporcionar ninguna información de tarjeta de crédito o pago durante el período de Prueba gratuita. Al vencimiento del período de prueba gratuito, la cuenta se desactivará automáticamente. Para evitar la desactivación o reactivar la Cuenta, el Cliente debe seleccionar un Plan y pagar la Tarifa del primer intervalo de pago del Plan. Si el Cliente no paga la Tarifa del primer intervalo de pago dentro de las 2 semanas posteriores al vencimiento del período de Prueba gratuita, Fintesk tiene derecho a eliminar de forma permanente la Cuenta, incluidos todos los Datos del Cliente. Además de la colección actual de Planes, Fintesk puede ofrecer descuentos y promociones especiales, de vez en cuando, a discreción exclusiva de Fintesk, que pueden estar sujetos a términos y condiciones adicionales.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#39-prueba-gratuita","category":"default"},{"title":"3.10 Servicios Beta","content":"Fintesk puede ofrecer a los Clientes ciertas Funciones con fines de prueba y evaluación denominadas Servicios Beta. Fintesk se reserva el derecho de descontinuar total o parcialmente, en cualquier momento y de vez en cuando, temporal o permanentemente, cualquiera de los Servicios Beta, con o sin previo aviso al Cliente. El Cliente acepta que Fintesk no será responsable ante el Cliente o cualquier tercero por cualquier daño relacionado con, que surja del uso del Cliente de los Servicios Beta, o causado por la modificación, suspensión o interrupción de cualquiera de los Servicios Beta, por cualquier razón.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#310-servicios-beta","category":"default"},{"title":"3.11 Aplicaciones que no son de Fintesk","content":"Fintesk o terceros pueden poner a disposición aplicaciones de terceros que no sean de Fintesk. Si el Cliente elige adquirir una aplicación que no sea de Fintesk, los términos y condiciones con respecto a su uso o recepción de la aplicación que no sea de Fintesk son entre el Cliente y el proveedor de esas aplicaciones que no sean de Fintesk y cualquier intercambio de datos entre el Cliente y dicho proveedor externo es únicamente entre el Cliente y el proveedor correspondiente. Cualquier pregunta, inquietud o disputa que surja en función del uso por parte del Cliente de aplicaciones que no sean de Fintesk debe abordarse con el proveedor de dicha aplicación que no sea de Fintesk y no con Fintesk. Fintesk no garantiza ni soporta o mantiene aplicaciones que no sean de Fintesk, ya sea que Fintesk las designe como “certificadas” o no. Fintesk no es responsable de ninguna divulgación, modificación o eliminación de los Datos del cliente que resulten del acceso por parte de dicha aplicación que no sea de Fintesk o su proveedor.\\nIntegración con aplicaciones que no son de Fintesk. Los Servicios de Fintesk pueden contener Funciones y funciones diseñadas para interoperar con aplicaciones que no son de Fintesk. Sin embargo, Fintesk no puede garantizar la disponibilidad continua de dichas Funciones o funcionalidades, y puede dejar de proporcionarlas sin previo aviso y sin dar derecho al Cliente a ningún reembolso, crédito u otra compensación, si, por ejemplo y sin limitación, el proveedor de un servicio que no sea de Fintesk deja de hacer que la aplicación que no es de Fintesk esté disponible para interoperar con las Funciones o funcionalidades correspondientes de una manera aceptable para Fintesk.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#311-aplicaciones-que-no-son-de-fintesk","category":"default"},{"title":"4.1 Actividades Prohibidas","content":"El Cliente y sus Usuarios pueden usar los Servicios de Fintesk, y cualquier parte o elemento de los mismos, solo en el alcance, con los medios y para los fines identificados en estos Términos y la ley aplicable. A título enunciativo, ni el Cliente ni ningún Usuario podrá:\\nusar los Servicios de Fintesk o cualquier parte o elemento de los mismos para cometer un delito, infringir cualquier ley aplicable o atraer o invitar a otros a llevar a cabo dichas acciones ilegales;\\ncopiar, duplicar, distribuir, modificar, adaptar, hackear, crear trabajos derivados, aplicar ingeniería inversa o descompilar los Servicios de Fintesk o cualquier parte o elemento de los mismos, o intentar extraer el código fuente de los mismos, a menos que (i) esté expresamente permitido por la ley aplicable y (ii) en la medida en que Fintesk no esté autorizado por la ley aplicable para excluir o limitar los derechos anteriores;\\nproporcionar información falsa, inexacta o engañosa;\\nactuar de manera difamatoria, calumniosa, amenazante o acosadora para Fintesk; o\\nusar los Servicios de Fintesk o cualquier parte o elemento de los mismos a menos que haya aceptado estar sujeto a estos Términos.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#41-actividades-prohibidas","category":"default"},{"title":"4.2 Usos que requieren el consentimiento de Fintesk","content":"El Cliente o cualquier Usuario no podrá, sin el previo consentimiento expreso por escrito de Fintesk:\\nvender, revender, arrendar, otorgar licencias, sublicenciar, distribuir, proporcionar, revelar, divulgar, explotar o de otro modo conceder acceso o poner los Servicios de Fintesk a disposición de terceros, en su totalidad o en parte, a menos que dichos terceros sean Usuarios del mismo Cliente; o\\nutilizar los Servicios de Fintesk, o cualquier parte o elemento de los mismos, en un ámbito, con medios o para fines distintos de aquellos para los que se diseñó su funcionalidad.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#42-usos-que-requieren-el-consentimiento-de-fintesk","category":"default"},{"title":"4.3 Cumplimiento del control comercial","content":"El Cliente, cualquier Usuario, Revendedor o agente (“Tercero”) declara, garantiza, acuerda y acepta que, con respecto a los Servicios de Fintesk:\\nEl Tercero ha cumplido y cumplirá, y hará que sus directores, funcionarios, empleados y agentes cumplan con las leyes y reglamentaciones sobre sanciones económicas, comerciales y financieras de los Estados Unidos, la Unión Europea y cualquier otro sanciones comerciales administradas por la Oficina de Control de Activos Extranjeros (“OFAC”) del Departamento del Tesoro de los EE. UU. y el Departamento de Estado de los EE. UU. (colectivamente, “Sanciones”), y las leyes y regulaciones de los EE. UU., la UE y otros países aplicables relacionadas con los controles de exportación, incluidos aquellos administrados por los Departamentos de Comercio y Estado de los EE. UU. (colectivamente, “Controles Comerciales”).\\nEl Tercero no tomará ninguna medida, directa o indirectamente, que pudiera causar que Fintesk o cualquiera de sus Filiales, o cualquiera de sus respectivos funcionarios, directores, empleados o representantes, infrinja cualquier Sanción o Control Comercial.\\nTampoco el Tercero ni ninguno de sus funcionarios o directores, empleados y cualquier agente u otro representante que actúe en su nombre (i) ha sido o está designado en alguna lista de personas restringidas o bloqueadas relacionadas con sanciones o exportaciones, incluida la designación en La Lista de Nacionales Especialmente Designados y Personas Bloqueadas de la OFAC o la Lista de Identificaciones de Sanciones Sectoriales de la OFAC, (ii) se encuentra en, está organizada bajo las leyes de, o reside en cualquier país o territorio que sea sujeto de sanciones o embargos por parte de cualquier autoridad gubernamental , incluidos, entre otros, Cuba, Irán, Siria, Corea del Norte, Venezuela y la Región de Crimea de Ucrania, (iii) es o ha sido dueño o está controlado por más del 50 % por cualquier persona o personas descritas en la cláusula (i) o (ii) (colectivamente con (i) y (ii), una “Persona restringida”), o (iv) ha proporcionado o proporcionará los Servicios de Fintesk a cualquier persona descrita en las cláusulas (i)-(iii).\\nEl Tercero notificará de inmediato a Fintesk si el Tercero o cualquier miembro del personal empleado o afiliado a un Tercero: (i) comete un incumplimiento real o potencial de Sanciones o Controles comerciales en relación con los Servicios de Fintesk, o (ii) se convierte en una Persona restringida.\\nFintesk, a su exclusivo criterio, tendrá derecho a cancelar de inmediato el acceso o el uso de los Servicios de Fintesk sin previo aviso ni responsabilidad ante el Tercero, si el Tercero, o cualquier persona empleada o afiliada a un Tercero, toma alguna medida en violación de las disposiciones descritas en esta Sección 4 o si Fintesk determina, a su exclusivo criterio, que el uso continuado de los Servicios de Fintesk por parte del Tercero podría violar Sanciones o Controles comerciales.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#43-cumplimiento-del-control-comercial","category":"default"},{"title":"5.1. Prestación de servicios de Fintesk","content":"Fintesk (a) pondrá los Servicios de Fintesk, el Contenido y los Datos del cliente a disposición del Cliente de conformidad con estos Términos, (b) brindará soporte como se describe en la Sección 3.6 para los Servicios de Fintesk al Cliente sin cargo adicional, (c) hará esfuerzos comercialmente razonables para hacer que los Servicios de Fintesk estén disponibles las 24 horas del día, los 7 días de la semana, excepto por: (i) el tiempo de inactividad planificado (sobre el cual Fintesk notificará electrónicamente con anticipación), y (ii) cualquier falta de disponibilidad causada por circunstancias fuera del control razonable de Fintesk, que incluye , por ejemplo, un acto de Fuerza Mayor, acto de gobierno, inundación, incendio, terremoto, disturbios civiles, acto de terror, pandemia, huelga u otro problema laboral, falla o retraso del proveedor de servicios de Internet o ataque de denegación de servicio. Fintesk puede usar Sub-procesadores para prestar los Servicios de Fintesk. Fintesk hará todos los esfuerzos comercialmente razonables para garantizar que las transferencias de datos a los Subprocesadores cumplan con los requisitos aplicables al procesamiento de los Datos del Cliente por parte de los Clientes y proporcionará información sobre dichas transferencias de datos en estos Términos para la consideración del Cliente. Para obtener información adicional sobre dichas transferencias con Sub-procesadores, consulte el Aviso de privacidad de Fintesk y la lista actual de Sub-procesadores.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#51-prestación-de-servicios-de-fintesk","category":"default"},{"title":"5.2. Protección de Datos del Cliente","content":"Fintesk mantendrá salvaguardas administrativas, físicas y técnicas para proteger la seguridad, confidencialidad e integridad de los Datos del Cliente. Esas salvaguardas incluirán, entre otras, medidas para evitar el acceso, uso, modificación o divulgación no autorizados de los Datos del Cliente. Además, Fintesk solo accederá, usará, modificará o divulgará de otro modo los Datos del Cliente: (a) para proporcionar los Servicios de Fintesk y prevenir o abordar problemas técnicos o de servicio, (b) según lo exija la ley de acuerdo con la Sección 7.6 (Divulgación obligatoria) a continuación, (c) según lo permita expresamente el Cliente o Usuario por escrito.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#52-protección-de-datos-del-cliente","category":"default"},{"title":"6. TARIFAS/PAGO","content":"Las disposiciones de esta Sección 6 son aplicables solo si el Cliente accede a los Servicios de Fintesk directamente desde Fintesk. Si el Cliente compra el acceso a los Servicios de Fintesk a través de un Revendedor, las condiciones de pago se establecerán en el acuerdo del Cliente con dicho Revendedor.\\nEl uso de los Servicios de Fintesk, que no sea a través de una Prueba gratuita, está sujeto a una Tarifa. Al registrarse en una Cuenta, el Cliente debe seleccionar un Plan. Se aplican diferentes tarifas a diferentes Planes. La Tarifa aplicable se cobra por adelantado en forma mensual o anual. Fintesk se reserva el derecho de modificar las Tarifas de cualquier Plan, a su discreción razonable, en cualquier momento después del comienzo del Plazo del Plan, con al menos un mes de aviso previo al Cliente, dicha modificación no surtirá efecto hasta el comienzo de cualquier Plan inmediatamente después del Plazo del Plan en el que Fintesk notificó al Cliente sobre la modificación.\\nEl Cliente autoriza a Fintesk a cobrar automáticamente al Cliente las Tarifas correspondientes a partir de la Fecha de renovación, a menos que el Plan haya sido rescindido o cancelado de acuerdo con estos Términos. Si un Cliente desea reducir el número de Usuarios, deberá hacerlo antes de la Fecha de Renovación. Los clientes pueden cancelar su Plan en cualquier momento como se describe a continuación, sin embargo, deben hacerlo antes de la Fecha de renovación para evitar la facturación de las Tarifas del próximo Plazo del Plan. Si el Cliente elige cancelar su Plan durante el Plazo del Plan, el Cliente puede usar el Servicio hasta el final del Plazo del Plan vigente en ese momento del Cliente, pero no se le reembolsarán las Tarifas cobradas más recientemente (o las anteriores).\\nTodas las tarifas no son reembolsables. Para mayor claridad, no hay reembolsos ni créditos por períodos en los que el Cliente no usó una Cuenta activada, la usó solo parcialmente, desactivó la Cuenta o canceló estos Términos durante un intervalo de pago en curso, o cuando una Cuenta es cancelada o suspendida por Fintesk de acuerdo con la Sección 13.\\nTodas las Tarifas excluyen todos los impuestos, gravámenes o aranceles aplicables en virtud de cualquier ley aplicable, a menos que se indique lo contrario en el presente. El cliente es el único responsable del pago de dichos impuestos, gravámenes o derechos.\\nEn caso de que el Cliente no pague todas las Tarifas adeudadas dentro de los 29 días posteriores a la fecha de la factura, Fintesk suspenderá todo acceso a la Cuenta del Cliente. El Cliente tendrá 180 días para proporcionar un método de pago autorizado para reactivar una suscripción y su Cuenta; de lo contrario, Fintesk tiene derecho a eliminar permanentemente la Cuenta, incluidos todos los Datos del Cliente que contenga.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#6-tarifaspago","category":"default"},{"title":"6.1 Autorización de tarjeta de pago","content":"Fintesk (LibroContable SpA) y sus Filiales pueden solicitar la pre-autorización de la cuenta de la tarjeta de pago del Cliente antes de la compra de los Servicios de Fintesk para verificar que la tarjeta de pago sea válida y tenga los fondos necesarios o el crédito disponible para cubrir cualquier compra. El Cliente acepta aprobar dicha pre-autorización de la tarjeta y pagar los montos de un Plan descrito en el Sitio web, y autoriza a Fintesk a cargar todas las Tarifas a dicha cuenta de tarjeta. El cliente acepta proporcionar a Fintesk información actualizada sobre su cuenta de tarjeta de pago a pedido de Fintesk y en cualquier momento en que la información proporcionada anteriormente ya no sea válida.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#61-autorización-de-tarjeta-de-pago","category":"default"},{"title":"6.2 Pagos por Débito Directo","content":"Si el Cliente está de acuerdo, Fintesk puede elegir que el Cliente complete un mandato de débito bancario para habilitar los pagos de débito bancario. En tales casos, Fintesk cumplirá con todas las normas y reglamentos nacionales aplicables relacionados con los pagos domiciliados.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#62-pagos-por-débito-directo","category":"default"},{"title":"6.3 Proveedores de servicios de pago","content":"Fintesk usa Flow para procesar los pagos de débito bancario del Cliente. Más información sobre cómo Flow procesa los datos personales del Cliente y los derechos de protección de datos del Cliente, incluido el derecho del Cliente a oponerse, está disponible en Flow.cl\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#63-proveedores-de-servicios-de-pago","category":"default"},{"title":"6.4 Factura Electrónica","content":"Si Fintesk no ha solicitado la pre-autorización de la tarjeta de pago del Cliente, entonces, antes del final de cada intervalo de pago, se emitirá al Cliente una factura electrónica por el pago de la Tarifa del siguiente intervalo de pago. El cliente debe pagar la factura antes de la fecha de vencimiento indicada en la factura.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#64-factura-electrónica","category":"default"},{"title":"6.5 Cargos por pagos atrasados","content":"En caso de retraso en cualquier pago, Fintesk puede exigir al Cliente que pague intereses sobre el retraso (multa por pago atrasado) por el período en que dicho pago esté vencido. La tasa de interés por pago atrasado será del 1% mensual o el máximo permitido por la ley local, el que sea mayor.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#65-cargos-por-pagos-atrasados","category":"default"},{"title":"6.6 Derecho a compensación","content":"Además de otros derechos y recursos que Fintesk pueda tener, si está legalmente permitido, Fintesk puede compensar cualquier obligación de pago con el Cliente en la que Fintesk pueda incurrir en virtud de los Términos con cualquier tarifa adeudada a Fintesk y que el Cliente aún no haya pagado en virtud de los Términos, o cualquier otro acuerdo entre el Cliente y Fintesk.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#66-derecho-a-compensación","category":"default"},{"title":"7.1 Derechos a los Datos del Cliente","content":"En relación con los Datos del Cliente, el Cliente afirma, declara y garantiza que:\\n(i) el Cliente es propietario de sus Datos del Cliente o tiene las licencias, los derechos, los consentimientos y los permisos necesarios para usar y autorizar a Fintesk a mostrar o usar los Datos del Cliente bajo todas las patentes, marcas registradas, derechos de autor, secretos comerciales u otros derechos de propiedad sobre sus Datos de Cliente de manera consistente con las Funciones previstas de los Servicios de Fintesk y estos Términos, y para otorgar los derechos y la licencia establecidos en estos Términos, y\\n(ii) los Datos del Cliente, o el uso de Fintesk o cualquier licenciatario de Fintesk de dichos Datos del Cliente de conformidad con estos Términos, no:\\n(a) infringen, violan o se apropian indebidamente de ningún derecho de terceros, incluidos derechos de autor, marcas registradas, patentes , secreto comercial, derecho moral, derecho de privacidad, derecho de publicidad o cualquier otra propiedad intelectual o derecho de propiedad;\\n(b) violan cualquier ley o regulación aplicable en cualquier parte del mundo; o\\n(c) exigen la obtención de una licencia o el pago de tarifas y/o regalías por parte de Fintesk a un tercero para la prestación de cualquier Servicio de Fintesk que el Cliente haya elegido que Fintesk realice o para el ejercicio de cualquier derecho otorgado en estos Términos, a menos que el Cliente y Fintesk acuerden lo contrario.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#71-derechos-a-los-datos-del-cliente","category":"default"},{"title":"7.2 Cargar datos del cliente en los servicios de Fintesk","content":"El Cliente es el único responsable de sus propios Datos de Cliente y de las consecuencias de publicarlos en el Servicio de Fintesk o a través de este.\\nSi el Cliente carga Datos del Cliente en los Servicios de Fintesk, dichos Datos del Cliente y cualquier procesamiento de dichos Datos del Cliente deben cumplir con estos Términos y la ley aplicable.\\nTodos los derechos, títulos e intereses sobre los Datos del Cliente pertenecen al Cliente o a sus respectivos propietarios (incluidos los Usuarios, las personas y las organizaciones), ya sea que el Cliente los publique y/o los cargue o que estén disponibles en o a través de los Servicios de Fintesk.\\nAl cargar los Datos del Cliente en los Servicios de Fintesk, el Cliente autoriza a Fintesk a procesar los Datos del Cliente.\\nEl cliente es responsable de garantizar que:\\nEl Cliente y cualquiera de los Usuarios asociados con la Cuenta no crean, transmiten, muestran ni ponen a disposición de otro modo Datos del Cliente que infrinjan estos Términos, los derechos de Fintesk, otros clientes o usuarios de los Servicios de Fintesk o personas u organizaciones;\\nlos Datos del Cliente no son dañinos (por ejemplo, virus, gusanos, malware y otros códigos destructivos), ofensivos, amenazantes, abusivos, acosadores, tortuosos, difamatorios, vulgares, obscenos, invasivos de la privacidad de otra persona, odiosos o ilegales; y\\nEl Cliente y todos los Usuarios asociados con la Cuenta tienen los derechos necesarios para usar los Datos del Cliente, incluso para insertarlos en los Servicios de Fintesk y procesarlos a través de la Cuenta.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#72-cargar-datos-del-cliente-en-los-servicios-de-fintesk","category":"default"},{"title":"7.3 Sin responsabilidad de los datos del cliente","content":"Fintesk no garantiza ninguna precisión con respecto a la información contenida en los Datos del Cliente y recomienda que el Cliente considere detenidamente lo que transmite, envía o publica a través de los Servicios de Fintesk. El Cliente entiende que toda la información contenida en los Datos del Cliente es responsabilidad exclusiva de la persona de quien se originaron dichos Datos del Cliente. Esto significa que el Cliente, y no Fintesk, es completamente responsable de todos los Datos del Cliente que se cargan, publican, transmiten o ponen a disposición de otro modo a través de los Servicios de Fintesk, por parte del Cliente o sus Usuarios, así como de cualquier acción correctiva tomada por Fintesk o otros Clientes o Usuarios como resultado de dichos Datos del Cliente.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#73-sin-responsabilidad-de-los-datos-del-cliente","category":"default"},{"title":"7.4 Información Sensible y Datos de Clientes Ilícitos","content":"El Cliente no utilizará el Servicio de Fintesk de ninguna manera para procesar:\\n(a) Información confidencial o\\n(b) Datos del cliente que, de alguna manera, esté prohibido por la ley o infrinja estos Términos.\\nFintesk no está obligado a preseleccionar, monitorear o filtrar los Datos del Cliente, o su procesamiento por parte del Cliente, para determinar si es Información confidencial o de naturaleza ilegal.\\nSin embargo, si Fintesk, a su exclusivo criterio, tiene motivos para creer que el Cliente está procesando cualquier Dato del Cliente o Información confidencial ilegal, o si la acción de su procesamiento es de naturaleza ilegal, Fintesk tiene derecho a:\\n(a) notificar al Cliente sobre dichos Datos del Cliente o Información Sensible ilegales;\\n(b) denegar su uso en los Servicios de Fintesk;\\n(c) exigir que el Cliente haga que su uso de los Servicios de Fintesk cumpla con estos Términos y ley aplicable;\\n(d) eliminar temporal o permanentemente los Datos del Cliente ilegales o la Información Sensible desde los Servicios de Fintesk, restringir el acceso a él o eliminarlo.\\nSi a Fintesk se le presentan pruebas convincentes de que los Datos del cliente no son información confidencial o ilegal, Fintesk puede, a su exclusivo criterio, restaurar dichos Datos del cliente o Información confidencial, que se eliminó previamente de los Servicios o la Cuenta de Fintesk o cuyo acceso estaba restringido.\\nLos servicios de Fintesk no están diseñados para cumplir con las regulaciones específicas de la industria, como la Ley de Portabilidad y Responsabilidad de Seguros Médicos (HIPAA) o la Ley Federal de Gestión de Seguridad de la Información (FISMA). Como tal, el Cliente no puede usar los Servicios de Fintesk donde sus comunicaciones estarían sujetas a dichas leyes. Además, el Cliente no puede usar los Servicios de Fintesk de una manera que viole la Ley Gramm-Leach-Bliley (GLBA).\\nEL CLIENTE RECONOCE QUE LOS SERVICIOS DE FINTESK NO HAN SIDO DISEÑADOS PARA PROCESAR O GESTIONAR INFORMACIÓN SENSIBLE Y, POR CONSIGUIENTE, EL CLIENTE ACEPTA NO UTILIZAR LOS SERVICIOS DE FINTESK PARA RECOPILAR, GESTIONAR O PROCESAR INFORMACIÓN SENSIBLE. FINTESK NO TENDRÁ, Y FINTESK RENUNCIA ESPECÍFICAMENTE, CUALQUIER RESPONSABILIDAD QUE PUEDA RESULTAR DEL USO DE LOS SERVICIOS DE FINTESK POR PARTE DEL CLIENTE PARA RECOPILAR, PROCESAR O GESTIONAR INFORMACIÓN SENSIBLE.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#74-información-sensible-y-datos-de-clientes-ilícitos","category":"default"},{"title":"7.5 Derechos de Fintesk sobre los datos del cliente","content":"Fintesk puede utilizar los Datos del cliente en un formato agregado o anónimo para fines de investigación, educativos y otros fines similares. Fintesk no puede usar ni mostrar públicamente los Datos del Cliente sin el consentimiento por escrito del Cliente y respeta el derecho del Cliente a la propiedad exclusiva de los Datos del Cliente.\\nA menos que el Cliente lo permita específicamente y se establezca de otro modo en el presente, el uso de los Servicios de Fintesk por parte del Cliente no otorga a Fintesk la licencia para usar, reproducir, adaptar, modificar, publicar o distribuir los Datos del Cliente creados por el Cliente o almacenados en la Cuenta del Cliente con fines comerciales, mercadeo o cualquier propósito similar.\\nEl Cliente otorga expresamente a Fintesk el derecho a usar y analizar los datos agregados de la actividad del sistema asociados con el uso de los Servicios de Fintesk por parte del Cliente y sus Usuarios con el fin de optimizar, mejorar o mejorar la forma en que operan los Servicios de Fintesk, y para crear nuevas Características y funciones en conexión con los Servicios de Fintesk a la sola discreción de Fintesk.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#75-derechos-de-fintesk-sobre-los-datos-del-cliente","category":"default"},{"title":"7.6 Divulgaciones obligatorias","content":"Fintesk se esfuerza por cumplir con todas las leyes, y se reserva el derecho de eliminar cualquier Dato del cliente de la Plataforma al recibir un aviso de eliminación conforme, incluidas las órdenes o avisos judiciales.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#76-divulgaciones-obligatorias","category":"default"},{"title":"8. PRIVACIDAD","content":"El Aviso de privacidad de Fintesk está disponible en Seguridad y privacidad\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#8-privacidad","category":"default"},{"title":"9.1 Derechos de propiedad intelectual de Fintesk","content":"Los Servicios de Fintesk, la Plataforma, los Materiales de Fintesk, los nombres comerciales y las marcas registradas de Fintesk, y cualquier propiedad intelectual asociada a los mismos son, única y exclusivamente, propiedad y están operados por Fintesk, sus Afiliados o sus respectivos proveedores externos y socios de alojamiento.\\nLos materiales de Fintesk están protegidos por derechos de autor, imagen comercial, patentes, secretos comerciales y leyes de marcas registradas, convenciones y tratados internacionales, y todas las demás leyes de propiedad intelectual y derechos de propiedad.\\nA excepción de lo establecido en estos Términos, el uso por parte del Cliente de los Servicios de Fintesk y los Materiales de Fintesk, y cualquier parte o elemento, no otorga al Cliente ningún derecho de propiedad o derechos de propiedad intelectual sobre los mismos.\\nCualquier distribución, publicación o explotación comercial o promocional de los Materiales de Fintesk está estrictamente prohibida a menos que el Cliente haya recibido el permiso expreso previo por escrito de Fintesk o del titular de los derechos correspondiente.\\nEl Cliente no puede usar los nombres comerciales y las marcas registradas de Fintesk de ninguna manera que menosprecie a Fintesk o sus productos o servicios, o retrate a Fintesk de manera falsa, adversa a la competencia o deficiente.\\nFintesk se reserva todos los derechos sobre los Servicios de Fintesk, la Plataforma, los Materiales de Fintesk y los nombres comerciales y las marcas registradas de Fintesk que no se otorgan expresamente en los Términos.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#91-derechos-de-propiedad-intelectual-de-fintesk","category":"default"},{"title":"9.2 Contenido","content":"Sujeto a estos Términos y al pago de la Tarifa aplicable, Fintesk otorga al Cliente y a sus Usuarios una licencia no exclusiva, no transferible y no sublicenciable para descargar una sola copia de cualquier parte del Contenido únicamente para su uso personal, no -uso comercial.\\nEl Cliente no eliminará los avisos de derechos de autor y de propiedad que se incluyen en cualquier parte del Contenido.\\nEl Cliente reconoce expresamente que no adquiere ningún derecho de propiedad al descargar cualquier material protegido por derechos de autor desde o a través de la Plataforma o los Servicios de Fintesk.\\nEl Cliente no copiará, distribuirá ni publicará ningún Contenido ni ninguna información obtenida o derivada del mismo, salvo que Fintesk lo permita expresamente.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#92-contenido","category":"default"},{"title":"9.3 Comentarios","content":"Si un Cliente o un Usuario proporciona Comentarios a Fintesk, Fintesk tendrá derecho a utilizar dichos Comentarios a su discreción, lo que incluye, entre otros, la incorporación de dichos cambios sugeridos en los Servicios de Fintesk.\\nPor el presente, el Cliente o Usuario otorga a Fintesk una licencia perpetua, irrevocable, no exclusiva y libre de regalías bajo todos los derechos necesarios para incorporar, publicar, reproducir, distribuir, modificar, adaptar, preparar trabajos derivados, exhibir públicamente, ejecutar públicamente, explotar y usar Comentarios para cualquier objetivo.\\nFintesk tendrá derecho a modificar o eliminar cualquier Comentario proporcionado en las áreas públicas del Sitio web que Fintesk considere, a su exclusivo criterio, dañino, ofensivo, amenazante, abusivo, acosador, tortuoso, difamatorio, vulgar, obsceno, invasivo de la privacidad de otra persona, detestable o ilegal.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#93-comentarios","category":"default"},{"title":"10. EXENCIONES DE RESPONSABILIDAD; SIN GARANTÍA","content":"A MENOS QUE FINTESK ESTABLEZCA EXPRESAMENTE LO CONTRARIO, LOS SERVICIOS DE FINTESK, EL MATERIAL DE FINTESK, LA PLATAFORMA Y CUALQUIER CONTENIDO O CARACTERÍSTICAS DISPONIBLES JUNTO CON O A TRAVÉS DE LOS SERVICIOS DE FINTESK SE PROPORCIONAN “TAL CUAL” Y “SEGÚN DISPONIBILIDAD” SIN GARANTÍAS DE NINGÚN TIPO, NI EXPLÍCITAS O IMPLÍCITO. EN LA MEDIDA MÁXIMA PERMITIDA DE CONFORMIDAD CON LA LEY APLICABLE, FINTESK Y SUS AFILIADOS RENUNCIA A TODAS LAS GARANTÍAS LEGALES, EXPLÍCITAS O IMPLÍCITAS, INCLUIDAS, ENTRE OTRAS, GARANTÍAS IMPLÍCITAS DE COMERCIABILIDAD, IDONEIDAD PARA UN FIN DETERMINADO, NO VIOLACIÓN DE DERECHOS DE PROPIEDAD, EXACTITUD , PRECISIÓN Y FIABILIDAD.\\nA MENOS QUE FINTESK ESTABLEZCA EXPRESAMENTE LO CONTRARIO, FINTESK Y SUS FILIALES NO GARANTIZAN QUE LOS SERVICIOS DE FINTESK Y CUALQUIER CONTENIDO O CARACTERÍSTICAS DISPONIBLES JUNTO CON O A TRAVÉS DE LOS SERVICIOS DE FINTESK NO TENDRÁN INTERRUPCIONES O ERRORES, QUE LOS DEFECTOS SERÁN CORREGIDOS O QUE EL LOS SERVICIOS DE FINTESK Y CUALQUIER CONTENIDO O CARACTERÍSTICAS DISPONIBLES JUNTO CON LOS SERVICIOS DE FINTESK O MEDIANTE LOS SERVICIOS DE FINTESK O LA PLATAFORMA QUE LOS HACE DISPONIBLES ESTÁN LIBRES DE VIRUS U OTROS COMPONENTES DAÑINOS.\\nA MENOS QUE FINTESK ESTABLEZCA EXPRESAMENTE LO CONTRARIO, FINTESK Y SUS FILIALES NO GARANTIZAN NI REALIZAN NINGUNA REPRESENTACIÓN CON RESPECTO AL USO O LOS RESULTADOS DEL USO DE LA PLATAFORMA, LOS SERVICIOS DE FINTESK, LOS MATERIALES DE FINTESK O CUALQUIER SITIO WEB, EN TÉRMINOS DE CORRECCIÓN, PRECISIÓN O CONFIABILIDAD , O DE OTRO MODO.\\nSI LAS LEYES DE CIERTOS PAÍSES Y ESTADOS NO PERMITEN LIMITACIONES EN LAS GARANTÍAS IMPLÍCITAS O LA EXCLUSIÓN O LIMITACIÓN DE CIERTOS DAÑOS, ALGUNAS O TODAS LAS RENUNCIAS, EXCLUSIONES O LIMITACIONES ANTERIORES, ESTABLECIDAS EN ESTA SECCIÓN 10, PUEDEN NO APLICAR A FINTESK, Y EL CLIENTE PUEDE TENER DERECHOS ADICIONALES SEGÚN LO ESTABLECE LA LEY.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#10-exenciones-de-responsabilidad-sin-garantía","category":"default"},{"title":"11. INDEMNIZACIÓN","content":"El Cliente acepta defender, indemnizar y eximir de responsabilidad a FINTESK y sus Afiliados, y a sus respectivos directores, funcionarios, empleados y agentes, de cualquier reclamo, pérdida, daño, responsabilidad, incluidos los honorarios de abogados, que surja del uso o mal uso de FINTESK. Servicios, Materiales de FINTESK, representaciones hechas a FINTESK, sus Afiliados y/o terceros, violación de estos Términos, violación de los derechos de cualquier otra persona o entidad, o cualquier incumplimiento de las representaciones, garantías y convenios anteriores. FINTESK se reserva el derecho, a sus expensas, de asumir la defensa y el control exclusivos de cualquier asunto por el cual el Cliente deba indemnizar a FINTESK, y el Cliente acepta cooperar con dicha defensa de estos reclamos.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#11-indemnización","category":"default"},{"title":"12.1 No responsabilidad","content":"Fintesk no será responsable ante el Cliente o Usuario de las consecuencias derivadas de:\\ncualquier modificación de estos Términos, modificación de los Servicios de Fintesk, Material de Fintesk, uso de la Cuenta por parte del Cliente o cualquier parte o elemento de los mismos, incluidos, entre otros, cualquier error, interrupción permanente o temporal, interrupción, suspensión u otro tipo de falta de disponibilidad de los Servicios de Fintesk o los Materiales de Fintesk;\\neliminación, corrupción o falta de almacenamiento de los Datos del Cliente;\\nuso de los Datos del Cliente por parte del Cliente o cualquiera de los Usuarios asociados con la Cuenta;\\nactualización o degradación de un Plan actual por parte del Cliente;\\ncualquier divulgación, pérdida o uso no autorizado de las credenciales de inicio de sesión del Cliente o cualquier Usuario debido a que el Cliente no las mantuvo confidenciales;\\nel uso por parte del Cliente de la Cuenta o los Servicios de Fintesk por medio de navegadores web distintos a los aceptados o admitidos por Fintesk;\\nla aplicación de cualquier recurso contra el Cliente o los Usuarios por parte de Fintesk; por ejemplo, si el Cliente o Usuario ha cometido un delito o infringido la ley aplicable al usar los Servicios de Fintesk o cualquier parte o elemento de los mismos;\\nlas diferencias entre tecnologías y plataformas utilizadas para el acceso; por ejemplo, si determinadas Características, funciones, partes o elementos de los Servicios de Fintesk están diseñados para su uso en una computadora personal o portátil y no funcionan en una plataforma móvil o tableta;\\nLa aplicación por parte de Fintesk de los recursos descritos en estos Términos, incluso si los motivos razonables o la base legal para la aplicación de estos recursos resultaran infundados o inválidos posteriormente.\\nAdemás, Fintesk y sus Afiliados no serán responsables ante el Cliente por ningún reclamo de cualquier usuario, persona, organización o terceros contra el Cliente que surja del hecho de que el Cliente falla en:\\nproporcionar a Fintesk información precisa sobre el Cliente, los Usuarios o la Cuenta;\\nnotificar a Fintesk sobre cualquier motivo por el cual un Usuario no tiene derecho a usar la Cuenta en nombre del Cliente;\\nproporcionar cualquier Servicio o Función de Fintesk que haya acordado proporcionar a cualquier persona u organización (ya sea que dicha falla surja como resultado de la negligencia de Fintesk, el incumplimiento de estos Términos o de otra manera);\\ngarantizar la legalidad de los Datos del Cliente;\\nobtener los derechos necesarios para utilizar los Datos del Cliente; o\\ncumplir con cualquiera de las restricciones descritas en estos Términos.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#121-no-responsabilidad","category":"default"},{"title":"12.2 Limitación de responsabilidad","content":"EN NINGÚN CASO LA RESPONSABILIDAD TOTAL DE FINTESK Y SUS AFILIADOS QUE SURJA O ESTÉ RELACIONADA CON ESTOS TÉRMINOS, YA SEA CON RESPECTO A UN ÚNICO OCURRIMIENTO O UNA SERIE DE OCURRENCIAS, EXCEDERÁ EL MONTO TOTAL PAGADO POR EL CLIENTE A CONTINUACIÓN POR LOS SERVICIOS ESPECÍFICOS DE FINTESK QUE DIERON LUGAR A LA RESPONSABILIDAD EN LOS SEIS MESES ANTERIORES AL PRIMER INCIDENTE DEL QUE SURGIÓ LA RESPONSABILIDAD. LA LIMITACIÓN ANTERIOR SE APLICARÁ SI UNA ACCIÓN ES POR NEGLIGENCIA, POR CONTRATO O AGRAVIO, DECLARACIÓN FALSA O DE CUALQUIER OTRO TIPO, E INDEPENDIENTEMENTE DE LA TEORÍA DE LA RESPONSABILIDAD, PERO NO LIMITARÁ LAS OBLIGACIONES DE PAGO DEL CLIENTE ESTABLECIDAS EN LA SECCIÓN 5 “HONORARIOS/PAGO”.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#122-limitación-de-responsabilidad","category":"default"},{"title":"12.3 Exclusión de Daños Consecuentes y Relacionados","content":"A EXCEPCIÓN DE LAS OBLIGACIONES DE INDEMNIZACIÓN DEL CLIENTE ESTABLECIDAS EN LA SECCIÓN 11 “INDEMNIFICACIÓN”, EN NINGÚN CASO NINGUNA DE LAS PARTES O SUS AFILIADOS TENDRÁ NINGUNA RESPONSABILIDAD DERIVADA O RELACIONADA CON ESTOS TÉRMINOS POR LA PÉRDIDA DE BENEFICIOS, INGRESOS, FONDO DE COMERCIO O INDIRECTO, ESPECIAL, INCIDENTAL, CONSECUENCIA, COBERTURA, INTERRUPCIÓN DEL NEGOCIO O DAÑOS PUNITIVOS, YA SEA UNA ACCIÓN POR CONTRATO O AGRAVIO E INDEPENDIENTEMENTE DE LA TEORÍA DE LA RESPONSABILIDAD, INCLUSO SI UNA PARTE O SUS AFILIADOS HAYAN SIDO ADVERTIDO DE LA POSIBILIDAD DE DICHOS DAÑOS O SI UNA PARTE O SUS AFILIADOS HAYAN SIDO EL RECURSO DE LO CONTRARIO FALLA EN SU PROPÓSITO ESENCIAL. LA EXENCIÓN DE RESPONSABILIDAD ANTERIOR NO SE APLICARÁ EN LA MEDIDA EN QUE LO PROHÍBA LA LEY.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#123-exclusión-de-daños-consecuentes-y-relacionados","category":"default"},{"title":"13.1 Por conveniencia","content":"Estos Términos y/o el acceso del Cliente a los Servicios de Fintesk pueden rescindirse por conveniencia en las siguientes situaciones;\\npor el Cliente en cualquier momento:\\n\\n(i) haciendo clic en el enlace de cancelación en el Sitio web,\\n(ii) revocando el acuerdo de facturación en su perfil de PayPal, si el Cliente está pagando el Servicio de Fintesk con una cuenta de PayPal; o\\n(iii) por medios acordados entre el Cliente y el Revendedor, si el Cliente paga el Servicio de Fintesk a través de un Revendedor;\\n\\n\\npor Fintesk tras la decisión de finalizar la provisión de cualquier parte de los Servicios de Fintesk, cualquier Característica y/o cerrar cualquier parte de la Plataforma;\\npor Fintesk en cualquier etapa y por cualquier motivo, siempre que Fintesk proporcione un reembolso prorrateado de cualquier Tarifa no utilizada por el resto del Plazo; o\\ninmediatamente por cualquiera de las partes, si se inicia un procedimiento de liquidación o insolvencia de la otra parte o se concluye un arreglo negociado con los acreedores de la otra parte o se realiza una cesión en nombre de la otra parte en beneficio de los acreedores.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#131-por-conveniencia","category":"default"},{"title":"13.2 Por defecto","content":"Estos Términos y/o el acceso del Cliente a los Servicios de Fintesk pueden rescindirse por incumplimiento mediante notificación por escrito a la otra parte como se indica en la Sección 15.6 “Aviso”:\\npor cualquiera de las partes en caso de incumplimiento de estos Términos por la otra parte, si el incumplimiento no se ha subsanado dentro de los 30 días posteriores a la recepción de un aviso de la parte que no incumple;\\ninmediatamente por cualquiera de las partes si la otra parte incumple sus obligaciones, según corresponda en virtud de las Secciones 4 “Restricciones”, 7 “Datos del cliente/Información confidencial”, 9 “Derechos de propiedad intelectual” o 11 “Indemnización”; o\\npor Fintesk con efecto inmediato si:\\n\\n(i) se sospecha que el uso de los Servicios de Fintesk por parte del Cliente, a exclusivo criterio de Fintesk, es una actividad ilegal,\\n(ii) las solicitudes realizadas por las fuerzas del orden público, una orden judicial u otras agencias gubernamentales para dicha terminación, o\\n(iii) si el uso que hace el Cliente de los Servicios de Fintesk pone en peligro la propiedad de otros, el Sitio web o la Plataforma.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#132-por-defecto","category":"default"},{"title":"13.3 Efecto de la rescisión","content":"Tras la rescisión de estos Términos y/o el acceso del Cliente a los Servicios de Fintesk por cualquier motivo:\\nFintesk desactivará y eliminará de forma permanente la Cuenta y todos los Datos del Cliente en los Servicios de Fintesk dentro de los 6 meses posteriores a la fecha de vigencia de la rescisión de estos Términos y/o el acceso del Cliente a los Servicios de Fintesk. Si el Cliente ha solicitado específicamente una eliminación anterior de la Cuenta y todos los Datos del Cliente, Fintesk cumplirá con dicha solicitud en el plazo de 1 mes a partir de la recepción de dicha solicitud.\\nEl cliente debe:\\n\\ndejar de usar y evitar el uso posterior de los Servicios de Fintesk, incluida, entre otras, la Plataforma;\\npagar los montos adeudados a Fintesk en virtud de estos Términos; y\\nliberar cualquier responsabilidad incurrida por el Cliente bajo estos Términos antes de la terminación.\\n\\n\\nSalvo que se establezca lo contrario en el presente, en ningún caso el Cliente recibirá un reembolso de las Tarifas pagadas por adelantado en virtud del presente.\\nLas siguientes disposiciones sobrevivirán a la terminación de estos Términos: Secciones 1, 2, 4, 6, 7-9, 11, 12, 14 y 15.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#133-efecto-de-la-rescisión","category":"default"},{"title":"13.4 Suspensión","content":"Fintesk tiene derecho a suspender el acceso a la totalidad o parte del Servicio de Fintesk o una Cuenta, incluida la eliminación de Contenido, en cualquier momento y durante cualquier período de tiempo, por:\\n(i) incumplimiento o sospecha de incumplimiento de estos Términos,\\n(ii) obligaciones legales\\n(iii) el uso de ancho de banda por parte del Cliente o sus Usuarios del Servicio de Fintesk, cualquier Característica o funcionalidad sea significativamente excesivo en relación con otros usuarios del Servicio de Fintesk, o para proteger la integridad, operatividad y seguridad del Servicio de Fintesk, efectivo inmediatamente, con o sin previo aviso.\\nA menos que lo prohíba la ley o un proceso legal, o para evitar daños inminentes al Servicio de Fintesk o a cualquier tercero, Fintesk generalmente proporciona un aviso en forma de banner o correo electrónico antes de dicha suspensión.\\nFintesk, a su discreción y de buena fe, adaptará cualquier suspensión según sea necesario para preservar la integridad, la operatividad y la seguridad del Servicio de Fintesk.\\nPara cualquier suspensión de este tipo, Fintesk tomará la determinación exclusiva en cuanto a cualquier crédito o reembolso de Tarifas prepagas por parte del Cliente.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#134-suspensión","category":"default"},{"title":"14.1 Entidad contratante de Fintesk","content":"La entidad de Fintesk con la que el Cliente contrata en virtud de estos Términos depende del domicilio del Cliente. Fintesk determina el domicilio del Cliente en función del país indicado en la dirección de facturación del Cliente. Para las Pruebas gratuitas, Fintesk determina el domicilio del Cliente en función de la ubicación indicada en la dirección IP del Cliente.\\nAl aceptar estos Términos o usar los Servicios de Fintesk, el Cliente está contratando con la entidad de Fintesk que se indica:\\nLibroContable SpA (Fintesk)\\nCorreo electrónico: contacto@fintesk.com\\nDirección: Dr. Manuel Barros Borgoño 71, oficina 1105.\\nProvidencia, Santiago, Chile.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#141-entidad-contratante-de-fintesk","category":"default"},{"title":"14.2 Arbitraje/ley aplicable y jurisdicción","content":"En caso de disputa, controversia o reclamo que surja de o en relación con estos Términos, incluidos, entre otros, la formación, validez, incumplimiento o terminación de los mismos, las partes intentarán resolver el asunto de manera amistosa en negociaciones mutuas. En el caso de que no se pueda llegar a una resolución mutuamente aceptable dentro de un tiempo razonable, cualquiera de las partes tendrá derecho a buscar todos los recursos disponibles, incluidos los recursos legales sujetos a los términos y condiciones establecidos a continuación.\\nSin perjuicio de lo anterior y sujeto a los términos y condiciones establecidos a continuación, cualquiera de las partes puede solicitar medidas cautelares con respecto a cualquier asunto en disputa en la medida de lo posible según la ley aplicable.\\nEn caso de que no sea posible un arreglo amistoso entre las partes, la disputa se resolverá definitivamente mediante arbitraje como se designa en el presente, sujeto a los términos y condiciones que se establecen a continuación.\\nLa Convención de las Naciones Unidas sobre Contratos para la Venta Internacional de Mercaderías (Convención de Viena de 1980) no se aplicará a estos Términos.\\nCualquier cuestión relacionada con estos Términos que no esté expresa o implícitamente resuelta por las disposiciones contenidas en estos Términos se regirá e interpretará de conformidad con lo siguiente:\\nPara Clientes a los que no se hace referencia específica en estos Términos, todas las disputas o controversias que surjan de o en relación con los Términos, incluida cualquier pregunta sobre su existencia, validez o rescisión, será resuelta bajo el domicilio común la Ciudad de Santiago y donde tanto el Cliente como Fintesk concuerdan en someterse a las autoridades judiciales que la ley determine como competentes para resolver la controversia que se presente entre las partes, de la forma y bajo los parámetros establecidos en la legislación correspondiente.\\nEl arbitraje se iniciará mediante una solicitud de arbitraje de cualquiera de las partes, entregada a la otra parte.\\nLa solicitud de arbitraje deberá establecer la naturaleza de la(s) reclamación(es) y la reparación solicitada.\\nSalvo que se limite específicamente lo contrario en estos Términos, el tribunal arbitral tendrá la facultad de otorgar cualquier recurso o reparación que considere apropiado, ya sea provisional o definitivo, incluidos, entre otros, medidas cautelares y cualquier medida ordenada por el tribunal arbitral, en la medida en que lo permita la ley aplicable, se considerará un laudo definitivo sobre el objeto de las medidas y será ejecutable como tal.\\nCada parte conserva el derecho de solicitar a cualquier tribunal de jurisdicción competente medidas cautelares y/o provisionales, incluidos embargos o mandatos judiciales previos al arbitraje, y dicha solicitud no se considerará incompatible con el acuerdo de arbitraje o una renuncia al derecho a arbitrar.\\nLas partes y los miembros del tribunal arbitral mantendrán la confidencialidad de la existencia y el contenido de las actuaciones arbitrales y de cualquier fallo o laudo, excepto\\n(i) en la medida en que se requiera la divulgación de una parte para cumplir con un deber legal, proteger o perseguir un derecho legal, o hacer cumplir o impugnar un laudo en procedimientos legales de buena fe ante un tribunal estatal u otra autoridad judicial,\\n(ii) con el consentimiento de todas las partes,\\n(iii) cuando sea necesario para la preparación o presentación de un reclamo o defensa en este arbitraje,\\n(iv) cuando dicha información ya sea de dominio público salvo como resultado de un incumplimiento de esta cláusula, o\\n(v) por orden del tribunal arbitral a solicitud de una de las partes.\\nEl tribunal arbitral podrá incluir en su laudo una asignación a cualquiera de las partes de los costos y gastos, incluidos los honorarios de los abogados, que el tribunal arbitral considere razonables.\\nTodo laudo del tribunal arbitral será definitivo y vinculante para las partes. La ejecución de cualquier laudo puede solicitarse en cualquier tribunal de jurisdicción competente.\\nA todos los efectos de estos Términos, las partes aceptan\\n(a) la jurisdicción y el lugar exclusivos en el condado de Santiago, Chile y\\n(b) las leyes de Chile como ley aplicable, sin dar efecto a ningún principio de conflicto de leyes.\\nEl uso de los Servicios de Fintesk no está autorizado en ninguna jurisdicción que no haga efectivas todas las disposiciones de estos Términos, incluida, entre otras, esta sección.\\nSin perjuicio de lo anterior, el Cliente y Fintesk acuerdan que nada de lo contenido en el presente se interpretará como renuncia, exclusión o limitación del derecho de cualquiera de las partes a (i) emprender acciones de ejecución a través de las agencias federales, estatales o locales correspondientes donde tales acciones estén disponibles, (ii) buscar medidas cautelares en un tribunal de justicia, o (iii) presentar una demanda en un tribunal de justicia para abordar reclamos de infracción de propiedad intelectual.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#142-arbitrajeley-aplicable-y-jurisdicción","category":"default"},{"title":"15.1 Relación de las Partes","content":"Las partes actuarán únicamente como contratistas independientes. Estos Términos no se interpretarán como la creación de una agencia, sociedad, empresa conjunta, deber fiduciario o cualquier otra forma de asociación legal entre el Cliente y Fintesk, y el Cliente no declarará lo contrario, ya sea de forma expresa, implícita, aparente o de otro modo. Estos Términos no son para el beneficio de terceros.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#151-relación-de-las-partes","category":"default"},{"title":"15.2 Divisibilidad","content":"Si algún término, condición o disposición de estos Términos se considera inválido, inaplicable o ilegal en su totalidad o en parte por cualquier motivo, esa disposición se aplicará en la medida máxima permitida para lograr la intención de las partes. La validez y exigibilidad de los restantes términos, condiciones o disposiciones, o partes de ellos, no se verán afectadas.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#152-divisibilidad","category":"default"},{"title":"15.3 Acuerdo completo","content":"Estos Términos constituyen el acuerdo completo entre el Cliente y Fintesk con respecto al uso por parte del Cliente de los Servicios de Fintesk, los Materiales de Fintesk y la Plataforma y reemplaza todos los acuerdos, propuestas o representaciones anteriores y contemporáneos, escritos u orales, con respecto a su objeto.\\nSalvo que se disponga lo contrario en el presente, ninguna modificación, enmienda o renuncia a ninguna disposición de estos Términos será efectiva a menos que se haga por escrito y esté firmada por la parte contra la cual se hace valer la modificación, enmienda o renuncia.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#153-acuerdo-completo","category":"default"},{"title":"15.4 Cesión","content":"El cliente no puede, directa o indirectamente, en su totalidad o en parte, por ministerio de la ley o de otro modo, ceder o transferir estos Términos o delegar cualquiera de sus derechos y/u obligaciones bajo estos Términos sin el consentimiento previo por escrito de Fintesk.\\nCualquier intento de cesión, transferencia o delegación sin dicho consentimiento previo por escrito será nulo e inaplicable.\\nNo obstante lo anterior, el Cliente, o sus cesionarios o cesionarios sucesivos permitidos, pueden ceder o transferir estos Términos o delegar cualquier derecho u obligación en virtud del presente sin consentimiento:\\n(1) a cualquier entidad controlada por, o bajo el control común con el Cliente, o su cesionarios o cesionarios sucesivos permitidos; o\\n(2) en relación con una fusión, reorganización, transferencia, venta de activos o líneas de productos, o cambio de control o propiedad del Cliente, o sus cesionarios o cesionarios sucesivos permitidos.\\nFintesk puede asignar o transferir libremente estos Términos o delegar cualquiera de sus derechos y/u obligaciones en virtud de estos Términos sin restricciones.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#154-cesión","category":"default"},{"title":"15.5 No renuncia","content":"El hecho de que cualquiera de las partes no ejerza o haga cumplir cualquier disposición o cualquiera de sus derechos en virtud de estos Términos no se considerará una renuncia a la aplicación futura de esa o cualquier otra disposición o derecho.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#155-no-renuncia","category":"default"},{"title":"15.6 Avisos","content":"Salvo que se especifique lo contrario en los Términos, todos los avisos relacionados con los Términos se harán por escrito y entrarán en vigencia a partir de\\n(a) entrega personal,\\n(b) el segundo día hábil después del envío por correo, o\\n(c), a excepción de los avisos de rescisión o una reclamación indemnizable, que será claramente identificable como “Avisos Legales”, el día de su envío por correo electrónico.\\nLos avisos relacionados con la facturación al Cliente se enviarán al contacto de facturación correspondiente designado por el Cliente por correo electrónico.\\nTodos los demás avisos al Cliente se dirigirán al administrador del sistema del Cliente correspondiente designado por el Cliente.\\n","section":"Condiciones de servicio de Fintesk","version":"current","path":"/es/tos/terms-of-service#156-avisos","category":"default"},{"title":"El Desafío Generalizado de los Leads de Baja Calidad en el Marketing Digital","content":"La preocupación inicial del usuario pone de manifiesto un problema común en el ámbito del marketing digital: la atracción de un gran volumen de prospectos que, en última instancia, no se traducen en ventas concretas.\\n<!-- truncate -->\\nGenerar una buena cantidad de leads no es lo más importante, sino, de manera crítica, en su calidad y su grado de alineación con la oferta y el público objetivo de la empresa.\\nRevisaremos estrategias para no solo aumentar el número de consultas, sino, lo que es más importante, asegurar que dichas consultas provengan de prospectos genuinamente interesados y calificados.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/es/blog/estrategias-para-atraer-leads-de-alta-calidad#el-desafío-generalizado-de-los-leads-de-baja-calidad-en-el-marketing-digital","category":"blogs"},{"title":"Entendiendo la Calidad de los Leads: Definiendo Prospectos Valiosos para su Negocio","content":"Lo que constituye un \\"lead de alta calidad\\" varía en función del negocio específico, su público objetivo y sus ofertas particulares.\\nUn \\"lead basura\\" es aquel que no cumple ni siquiera con los requisitos mínimos (por ejemplo, una consulta minorista para un negocio mayorista).\\nEs importante destacar que un lead que finalmente no realiza una compra no es necesariamente un \\"lead basura\\", sino más bien un prospecto no convertido.\\nLa definición clara de un Perfil de Cliente Ideal(ICP) resulta crucial para distinguir entre leads de alta y baja calidad. Los \\"leads basura\\" se relacionan directamente con desviaciones de este perfil ideal (tipo de compra incorrecto, ubicación incorrecta, cantidad incorrecta, falta de presupuesto). Por lo tanto, un ICP bien definido actúa como el punto de referencia para la calidad de los leads.\\nAdemás, la percepción de \\"lead basura\\" puede ser subjetiva y verse influenciada por el porcentaje de leads de baja calidad en relación con el volumen total (consulta inicial). Incluso un pequeño número de leads no deseados puede generar una sensación de saturación y frustración. Por ello, las empresas necesitan realizar un seguimiento y analizar la proporción de los diferentes tipos de leads para obtener una comprensión realista de su calidad general.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/es/blog/estrategias-para-atraer-leads-de-alta-calidad#entendiendo-la-calidad-de-los-leads-definiendo-prospectos-valiosos-para-su-negocio","category":"blogs"},{"title":"El Impacto Perjudicial de los \\"Leads Basura\\": Costos, Eficiencia y Moral del Equipo","content":"El procesamiento de leads de baja calidad consume tiempo y recursos valiosos de los equipos de ventas y marketing.\\nEsto puede acarrear una disminución de la productividad, un desperdicio de esfuerzo y tasas de conversión más bajas.\\nTambién puede afectar negativamente la moral del equipo, ya que los representantes de ventas pueden sentirse frustrados por la falta de prospectos calificados.\\nCentrarse en la calidad de los leads por encima de la cantidad puede mejorar significativamente el retorno de la inversión (ROI) de los esfuerzos de marketing, al reducir los recursos desperdiciados en prospectos no calificados.\\nEl Costo por Lead (CPL) es una métrica clave para evaluar la eficiencia de las campañas de Marketing.\\nSi un gran porcentaje de los leads son \\"basura\\", el CPL efectivo para los leads calificados aumenta, lo que disminuye el ROI.\\nUn porcentaje significativo de los leads nunca se convierte en ventas, lo que implica una inversión desperdiciada si esos leads fueron de baja calidad desde el principio.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/es/blog/estrategias-para-atraer-leads-de-alta-calidad#el-impacto-perjudicial-de-los-leads-basura-costos-eficiencia-y-moral-del-equipo","category":"blogs"},{"title":"Refinando la Segmentación y el Targeting de Audiencia en Plataformas Digitales","content":"Diferentes canales de publicidad atraen a distintos tipos de audiencias con diferentes niveles de calificación.\\nPor ejemplo, Google Ads podría generar menos leads, pero estos podrían estar más calificados, en comparación con Meta (Facebook/Instagram), que podría generar un mayor volumen, pero requerir un mayor filtrado.\\nMeta permite la optimización para leads de \\"Mayor Intención\\", lo que sugiere un enfoque en usuarios con mayor probabilidad de conversión.\\nSe debería considerar el uso de canales menos obvios que podrían generar una mejor calidad si Google Ads resulta demasiado competitivo o costoso puede ser una estrategia acertada.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/es/blog/estrategias-para-atraer-leads-de-alta-calidad#refinando-la-segmentación-y-el-targeting-de-audiencia-en-plataformas-digitales","category":"blogs"},{"title":"Creando Textos de Anuncios Atractivos y Calificados","content":"El mensaje transmitido en los anuncios puede actuar como un filtro.\\nLos elementos creativos de los anuncios deben ser llamativos y utilizar mensajes claros y potentes llamados a la acción (CTA) para atraer el tipo de atención adecuado.\\nEl texto del anuncio debe articular claramente la propuesta de valor y el cliente ideal para la oferta.\\nTambién debería incluir sutilmente criterios de calificación (por ejemplo, \\"Para empresas con más de 50 empleados\\").\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/es/blog/estrategias-para-atraer-leads-de-alta-calidad#creando-textos-de-anuncios-atractivos-y-calificados","category":"blogs"},{"title":"Optimizando las Páginas de Destino (landing pages) para aumentar la Conversión","content":"Las páginas de destino deben optimizarse para la captura de leads y diseñarse para las conversiones.\\nLos formularios en las páginas de destino deben ser sencillos y fáciles de completar para evitar el abandono.\\nLa información solicitada en el formulario desempeña un papel crucial en la calificación inicial de los leads.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/es/blog/estrategias-para-atraer-leads-de-alta-calidad#optimizando-las-páginas-de-destino-landing-pages-para-aumentar-la-conversión","category":"blogs"},{"title":"Aprovechando Estrategias Específicas de Canal (Google Ads, Meta, etc.)","content":"Como se mencionó anteriormente, los diferentes canales tienen diferentes fortalezas y debilidades en términos de calidad y volumen de leads.\\nGoogle Ads, cuando se realiza correctamente, genera leads de mayor calidad debido a la intención de búsqueda de los usuarios.\\nMeta (Facebook, Instagram) puede proporcionar un mayor volumen de leads, pero puede requerir un filtrado más riguroso.\\nTambién se deben considerar otros canales relevantes, como por ejemplo LinkedIn para leads B2B.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/es/blog/estrategias-para-atraer-leads-de-alta-calidad#aprovechando-estrategias-específicas-de-canal-google-ads-meta-etc","category":"blogs"},{"title":"Implementando Preguntas de Calificación Efectivas en los Formularios de Captura de Leads","content":"Idealmente lograr un filtrado en tres etapas, siendo la primera dentro de la propia campaña.\\nLas preguntas de calificación en los formularios son una táctica clave en esta etapa.\\nFormular preguntas de calificación en los formularios de captura de leads es una forma directa de filtrar a los usuarios no interesados o no calificados.\\nEsto permite a las empresas recopilar información crucial desde el principio.\\nEjemplos de preguntas de calificación:\\n\\"¿Cuál es su sector?\\" (para filtrar por sectores relevantes).\\n\\"¿Cuál es su cargo en la empresa?\\" (para identificar a los responsables de la toma de decisiones).\\n\\"¿Cuántos empleados tiene su empresa?\\" (para filtrar por tamaño de la empresa).\\n\\"¿Es usted el responsable de la toma de decisiones?\\".\\n\\"¿Es usted responsable del presupuesto de compra?\\".\\nLos formularios pueden incluir campos de \\"filtro\\" para calificar directamente a los leads en función de criterios como el sector, el cargo o los ingresos.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/es/blog/estrategias-para-atraer-leads-de-alta-calidad#implementando-preguntas-de-calificación-efectivas-en-los-formularios-de-captura-de-leads","category":"blogs"},{"title":"Utilizando Chatbots para la Selección Inicial de Leads","content":"Filtrado después de que el lead ha llegado.\\nLos chatbots pueden desempeñar un papel importante en este proceso.\\nLos chatbots pueden ser una tecnología eficaz para capturar leads y calificarlos simultáneamente a través del marketing conversacional.\\nLos chatbots utilizan el marketing conversacional para extraer datos de los visitantes y determinar la calidad del lead antes de pasarlo a ventas.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/es/blog/estrategias-para-atraer-leads-de-alta-calidad#utilizando-chatbots-para-la-selección-inicial-de-leads","category":"blogs"},{"title":"Desarrollando Procesos Manuales de Revisión de Leads","content":"También es bastante usado, siguiendo el filtrado después de que el lead haya llegado, el realizar una calificación manual basada en la lectura de la información proporcionada por el lead (por ejemplo, tamaño de la empresa, necesidades).\\nEsto implica que un agente (humano) revise la información del lead y realice una evaluación inicial de su calidad. Esto puede resultar especialmente útil para los leads generados a través de canales donde el filtrado automatizado es menos efectivo.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/es/blog/estrategias-para-atraer-leads-de-alta-calidad#desarrollando-procesos-manuales-de-revisión-de-leads","category":"blogs"},{"title":"Aprovechando Sistemas Automatizados de Puntuación de Leads","content":"Existe la posibilidad de utilizar la automatización para filtrar leads.\\nLa implementación de un sistema de puntuación de leads permite el etiquetado y la priorización automáticos de los leads en función de criterios predefinidos.\\nLa puntuación de leads es una metodología complementaria al Lead Nurturing, que se aplica a campañas de Email Marketing en una estrategia de Inbound Marketing y permite clasificar el grado de interés de un lead y su nivel de preparación para la compra.\\nLa puntuación de leads puede considerar datos explícitos (información proporcionada en los formularios) y datos implícitos (comportamiento del lead, como visitas al sitio web o aperturas de correos electrónicos).\\nEl software CRM a menudo incluye funciones para la puntuación automática de leads.\\nLos leads que alcanzan un cierto umbral de puntuación pueden pasarse automáticamente al equipo de ventas, mientras que los leads con puntuaciones más bajas pueden ser objeto de un mayor seguimiento.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/es/blog/estrategias-para-atraer-leads-de-alta-calidad#aprovechando-sistemas-automatizados-de-puntuación-de-leads","category":"blogs"},{"title":"El Papel Estratégico del Software CRM en la Gestión y Calificación de Leads","content":"Es recomendable el uso de un CRM para trabajar en ventas y categorizar manualmente los leads por los siguientes motivos:\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/es/blog/estrategias-para-atraer-leads-de-alta-calidad#el-papel-estratégico-del-software-crm-en-la-gestión-y-calificación-de-leads","category":"blogs"},{"title":"Centralización de Datos de Leads y Seguimiento de Interacciones","content":"Los sistemas CRM sirven como un repositorio central para todos los datos de los leads, lo que permite una visión integral de cada prospecto y sus interacciones con la empresa. Esto ayuda a evitar silos de datos y garantiza que tanto los equipos de marketing como los de ventas tengan acceso a la misma información.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/es/blog/estrategias-para-atraer-leads-de-alta-calidad#centralización-de-datos-de-leads-y-seguimiento-de-interacciones","category":"blogs"},{"title":"Implementación de Puntuación y Etiquetado Automatizados de Leads","content":"Muchos sistemas CRM ofrecen funciones automatizadas de puntuación de leads. También pueden etiquetar automáticamente los leads en función de diversos criterios (por ejemplo, fuente, datos demográficos, nivel de participación).\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/es/blog/estrategias-para-atraer-leads-de-alta-calidad#implementación-de-puntuación-y-etiquetado-automatizados-de-leads","category":"blogs"},{"title":"Facilitando la Alineación entre Ventas y Marketing","content":"Las plataformas CRM pueden mejorar la alineación entre los equipos de ventas y marketing al proporcionar una visión compartida del embudo de leads y facilitar la retroalimentación sobre la calidad de los leads. Esto garantiza que los esfuerzos de marketing se centren en generar los tipos de leads que el equipo de ventas puede convertir eficazmente.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/es/blog/estrategias-para-atraer-leads-de-alta-calidad#facilitando-la-alineación-entre-ventas-y-marketing","category":"blogs"},{"title":"Nutrición de Leads para Mejorar la Calidad y la Conversión","content":"Es importante realizar el procesamiento correcto de los leads, incluso si inicialmente se consideran \\"basura\\" (por ejemplo, manteniéndolos en la base de datos de contactos).\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/es/blog/estrategias-para-atraer-leads-de-alta-calidad#nutrición-de-leads-para-mejorar-la-calidad-y-la-conversión","category":"blogs"},{"title":"Desarrollo de Estrategias de Contenido Dirigido para Diferentes Etapas del Lead","content":"La nutrición de leads implica proporcionar contenido relevante y valioso a los prospectos en diferentes etapas del recorrido del comprador para construir relaciones y guiarlos hacia una compra. El contenido puede incluir publicaciones de blog, libros electrónicos, seminarios web, estudios de casos y más. La creación de contenido alineado con cada etapa del embudo de marketing (conciencia, consideración, acción) resulta crucial para una nutrición de leads eficaz.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/es/blog/estrategias-para-atraer-leads-de-alta-calidad#desarrollo-de-estrategias-de-contenido-dirigido-para-diferentes-etapas-del-lead","category":"blogs"},{"title":"Personalización de la Comunicación para Aumentar la Participación","content":"La personalización del email marketing y otras comunicaciones basadas en los datos y el comportamiento de los leads puede aumentar significativamente las tasas de participación y conversión. Esto puede implicar el uso de contenido dinámico en los correos electrónicos y la segmentación de las listas en función de diversos criterios.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/es/blog/estrategias-para-atraer-leads-de-alta-calidad#personalización-de-la-comunicación-para-aumentar-la-participación","category":"blogs"},{"title":"Implementación de la Puntuación de Leads para Identificar Prospectos Listos para la Venta","content":"Los esfuerzos de nutrición de leads deben realizar un seguimiento continuo de la participación de los leads y actualizar sus puntuaciones en consecuencia.\\nLos leads con altas puntuaciones de participación tienen más probabilidades de estar listos para la venta.\\nLa puntuación de leads ayuda a identificar qué leads nutridos están mostrando fuertes señales de compra y deben ser priorizados por el equipo de ventas. Incluso los \\"leads basura\\" podrían volverse valiosos en el futuro si sus circunstancias cambian, por lo que mantenerlos en una base de datos y nutrirlos adecuadamente puede resultar beneficioso (consulta inicial).\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/es/blog/estrategias-para-atraer-leads-de-alta-calidad#implementación-de-la-puntuación-de-leads-para-identificar-prospectos-listos-para-la-venta","category":"blogs"},{"title":"Midiendo el Éxito de los Esfuerzos para Mejorar la Calidad de los Leads","content":"En otro artículo estaremos ahondando en las siguientes métricas, pero por el momento las mencionaremos.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/es/blog/estrategias-para-atraer-leads-de-alta-calidad#midiendo-el-éxito-de-los-esfuerzos-para-mejorar-la-calidad-de-los-leads","category":"blogs"},{"title":"Indicadores Clave de Rendimiento (KPIs)","content":"Tasas de Conversión: Seguimiento del porcentaje de leads que se convierten en oportunidades calificadas y, en última instancia, en clientes.\\nCosto por Lead (CPL): Monitoreo del costo promedio de adquisición de un lead, con un enfoque en el CPL para los leads calificados.\\nDuración del Ciclo de Ventas: Medición del tiempo que tarda un lead en avanzar a través del embudo de ventas y convertirse en cliente. Una mejor calidad de los leads debería idealmente acortar el ciclo de ventas.\\nMétricas de Participación de los Leads: Seguimiento de las tasas de apertura de correos electrónicos, las tasas de clics, las visitas al sitio web y las descargas de contenido para evaluar el interés y la calidad de los leads.\\nRetroalimentación del Equipo de Ventas: Solicitud periódica de retroalimentación del equipo de ventas sobre la calidad de los leads que están recibiendo.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/es/blog/estrategias-para-atraer-leads-de-alta-calidad#indicadores-clave-de-rendimiento-kpis","category":"blogs"},{"title":"Utilización de Herramientas de Análisis para el Seguimiento y la Elaboración de Informes","content":"Plataformas como Google Analytics y los paneles de análisis de las plataformas de publicidad (por ejemplo, Meta Ads Manager) proporcionan datos valiosos para el seguimiento del rendimiento de la generación de leads.\\nLos sistemas CRM también ofrecen funciones de informes para analizar la calidad de los leads y las métricas de conversión.\\nUn porcentaje significativo de los profesionales del marketing evalúan la calidad de sus leads, lo que destaca su importancia como métrica.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/es/blog/estrategias-para-atraer-leads-de-alta-calidad#utilización-de-herramientas-de-análisis-para-el-seguimiento-y-la-elaboración-de-informes","category":"blogs"},{"title":"Implementando un Enfoque Holístico para Atraer y Gestionar Leads de Alta Calidad en sus Campañas de Marketing Digital","content":"Atraer leads de alta calidad y gestionar eficazmente los de baja calidad requiere un enfoque multifacético que integre estrategia, tácticas y tecnología. Las empresas de la Región Metropolitana de Santiago deberían centrarse en:\\nDefinir claramente su perfil de cliente ideal.\\nOptimizar su segmentación de audiencia y los mensajes de sus anuncios en las plataformas digitales relevantes.\\nImplementar preguntas de calificación y chatbots para la selección inicial de leads.\\nAprovechar el software CRM para la gestión centralizada de leads y la puntuación automatizada.\\nDesarrollar estrategias de nutrición de leads para involucrar y calificar a los prospectos a lo largo del tiempo.\\nMonitorear y analizar continuamente los indicadores clave de rendimiento para perfeccionar sus esfuerzos de generación de leads.\\nAl adoptar estas mejores prácticas, las empresas pueden reducir significativamente el volúmen de los \\"leads basura\\" y centrar sus recursos en interactuar con los prospectos que tienen más probabilidades de convertirse en clientes valiosos, impulsando en última instancia el crecimiento de las ventas.\\n","section":"Estrategias para Atraer Leads de Alta Calidad","version":"current","path":"/es/blog/estrategias-para-atraer-leads-de-alta-calidad#implementando-un-enfoque-holístico-para-atraer-y-gestionar-leads-de-alta-calidad-en-sus-campañas-de-marketing-digital","category":"blogs"},{"title":"2. La Ventaja Estratégica: Por qué un CRM supera la Gestión de Ventas Tradicional","content":"La adopción de un sistema CRM ofrece una serie de ventajas estratégicas significativas en comparación con los métodos tradicionales de gestión de ventas, como el uso de hojas de cálculo o software de gestión básico.\\nEficiencia y Productividad: Los sistemas CRM mejoran la eficiencia y la productividad al automatizar tareas repetitivas como la entrada de datos, lo que permite a los equipos de ventas concentrarse en la actividad principal de vender. Funciones como los seguimientos y recordatorios automatizados aseguran una interacción oportuna con clientes potenciales y existentes. El acceso centralizado a los datos también ahorra tiempo al eliminar la necesidad de buscar información en múltiples plataformas.\\nGestión de Datos Mejorada: Un CRM proporciona una plataforma centralizada para almacenar y organizar todos los datos relacionados con los clientes, creando una \\"única fuente de verdad\\". Esto ofrece una visión integral de las interacciones con los clientes, el historial de compras y las preferencias en un solo lugar. Esto contrasta con los desafíos de administrar datos en hojas de cálculo dispersas, lo que puede generar imprecisiones y pérdida de información.\\nRelaciones con los Clientes Más Sólidas: El CRM facilita la comunicación personalizada al proporcionar información sobre las necesidades y el historial de los clientes. Permite rastrear las interacciones con los clientes a través de múltiples canales, lo que garantiza una experiencia coherente y adaptada. Además, el CRM ayuda a identificar y nutrir clientes potenciales, lo que lleva a mejores tasas de conversión y una mayor lealtad del cliente.\\nPotencial de Escalabilidad y Crecimiento: Los sistemas CRM están diseñados para crecer con la empresa, permitiendo la adición de más usuarios y funciones según sea necesario. Esto contrasta con las limitaciones de métodos tradicionales como Excel, que se vuelven cada vez más difíciles de manejar a medida que la empresa se expande. El CRM puede ayudar a las empresas a adaptar sus procesos para dar cabida al crecimiento y administrar bases de datos de clientes más grandes.\\nInformes y Análisis Robustos: El software CRM ofrece herramientas para analizar los datos de los clientes, identificar tendencias y generar informes sobre el rendimiento de las ventas y el comportamiento del cliente. Estos conocimientos pueden ayudar a las empresas a tomar decisiones basadas en datos para optimizar sus estrategias de ventas y marketing. También permite rastrear los indicadores clave de rendimiento (KPI) y monitorear el desempeño del equipo en relación con los objetivos de ventas.\\nLa adopción de un CRM representa un cambio fundamental en la forma en que las empresas abordan la interacción con el cliente, facilitando una estrategia centrada en el cliente que prioriza la construcción de relaciones a largo plazo.\\nLos métodos tradicionales a menudo carecen de la sofisticación para capturar y analizar los matices de las interacciones con los clientes.\\nEl CRM proporciona el marco y las herramientas para comprender profundamente el comportamiento del cliente, lo que permite a las empresas anticipar las necesidades y personalizar las experiencias, cruciales para fomentar la lealtad en el mercado actual.\\nLas capacidades de automatización del CRM van más allá de la simple gestión de tareas; capacitan a los equipos de ventas para que se concentren en actividades estratégicas que impactan directamente en la generación de ingresos.\\nAl reducir las cargas administrativas, el CRM permite a los profesionales de ventas dedicar más tiempo a construir una buena relación con los clientes, comprender sus puntos débiles y adaptar las soluciones. Este cambio de enfoque puede conducir a mayores tasas de cierre y una mejor satisfacción del cliente.\\n","section":"Cómo elegir el CRM o Software de Gestión de Ventas Adecuado para su Empresa","version":"current","path":"/es/blog/como-elegir-el-crm-o-software-de-gestion-de-ventas-adecuado-para-su-empresa#2-la-ventaja-estratégica-por-qué-un-crm-supera-la-gestión-de-ventas-tradicional","category":"blogs"},{"title":"4. Sentando las Bases: La Criticidad de la Implementación del CRM","content":"Una implementación de CRM exitosa es fundamental para la adopción por parte de los usuarios y para obtener los beneficios previstos del software. Una implementación deficiente puede llevar a una subutilización del sistema y a un retorno de la inversión negativo.\\nEs esencial una estrategia bien definida y objetivos comerciales claros para guiar el proceso de implementación.\\nAuto-Implementación: La auto-implementación se refiere al proceso en el que la empresa se encarga internamente de la configuración y puesta en marcha del CRM. Entre las posibles ventajas se encuentran un mayor control sobre el sistema y posibles ahorros iniciales en los costos. Sin embargo, también existen posibles desventajas, como la necesidad de experiencia técnica interna, la naturaleza laboriosa del proceso en tiempo y recursos, y el riesgo de errores o retrasos. La auto-implementación puede ser adecuada para empresas con equipos de TI dedicados y requisitos de CRM más sencillos.\\nImplementación Incluida en el Costo del Software: Algunos proveedores de CRM, especialmente aquellos dirigidos a las pequeñas y medianas empresas (PYMES), ofrecen asistencia para la implementación como parte de su paquete de software. Las posibles ventajas incluyen el acceso a la orientación de expertos y un proceso de configuración más fluido. Las posibles desventajas pueden incluir limitaciones en la personalización o el nivel de soporte proporcionado. Esta opción puede ser particularmente beneficiosa para las empresas más pequeñas con recursos técnicos limitados.\\nContratación de Consultores Externos: Las empresas también pueden optar por contratar consultores de CRM externos para gestionar el proceso de implementación. Entre las posibles ventajas se encuentran el acceso a experiencia especializada, mejores prácticas y tiempos de implementación más rápidos. Las posibles desventajas incluyen el costo adicional y la necesidad de seleccionar cuidadosamente a un consultor que comprenda las necesidades específicas de la empresa. Esta opción puede ser adecuada para organizaciones más grandes con requisitos de CRM complejos o aquellas que carecen de experiencia interna.\\nLa decisión de cómo implementar un sistema CRM es estratégica y tiene implicaciones significativas para el éxito del proyecto y el costo general.\\nLas PYMES, en particular, deben sopesar cuidadosamente las ventajas y desventajas entre control, costo y experiencia al elegir un enfoque de implementación. La auto-implementación puede parecer rentable inicialmente, pero la falta de experiencia puede llevar a errores y retrasos costosos.\\nPor el contrario, si bien la contratación de consultores ofrece orientación experta, el gasto puede ser prohibitivo para las empresas más pequeñas.\\nLos proveedores de CRM que incluyen la implementación pueden lograr un equilibrio, pero el nivel de soporte puede variar. Muchos de los sistemas que incluyen la implementación u ofrecen guías de auto-implementación sencillas suelen ser las opciones más viables. Esto resalta la importancia de la facilidad de uso y el soporte fácilmente disponible para las PYMES, las cuales suelen tener recursos limitados y es posible que no cuenten con personal de TI dedicado para implementaciones complejas.\\nPor lo tanto, los sistemas CRM que son intuitivos de configurar y ofrecen soporte u orientación integrados tienen más probabilidades de ser adoptados con éxito y proporcionar valor rápidamente.\\n","section":"Cómo elegir el CRM o Software de Gestión de Ventas Adecuado para su Empresa","version":"current","path":"/es/blog/como-elegir-el-crm-o-software-de-gestion-de-ventas-adecuado-para-su-empresa#4-sentando-las-bases-la-criticidad-de-la-implementación-del-crm","category":"blogs"},{"title":"5. Construyendo un Ecosistema Conectado: La Importancia de la Integración del CRM","content":"La integración de un sistema CRM con otras aplicaciones empresariales cruciales es vital para garantizar la precisión de los datos, optimizar los flujos de trabajo y mejorar las operaciones comerciales generales.\\nIntegración con Sistemas ERP: La integración del CRM con los sistemas de planificación de recursos empresariales (ERP) permite un flujo de datos continuo entre las funciones de front-office (ventas, marketing) y back-office (operaciones, finanzas). Esto ofrece beneficios como una mayor precisión de los datos, una mejor visibilidad en toda la empresa, un procesamiento de pedidos optimizado y una mejor gestión del inventario. Los puntos de datos comunes que se integran entre los sistemas CRM y ERP incluyen la información de contacto del cliente, el historial de pedidos y los detalles de precios.\\nIntegración con Plataformas de Automatización de Marketing: La integración del CRM con plataformas de automatización de marketing permite a las empresas optimizar la generación de leads, nutrir a los prospectos y personalizar las campañas de marketing. Esto conduce a una mejor gestión de leads, mensajes dirigidos, una mejor segmentación de clientes y un mejor seguimiento del ROI de marketing.\\nIntegración con Herramientas de Comunicación por Correo Electrónico: La integración del CRM con plataformas de correo electrónico como Gmail u Outlook permite un seguimiento continuo de la correspondencia por correo electrónico con contactos y clientes potenciales. Esto ofrece beneficios como una mejor gestión de la comunicación, un fácil acceso al historial de correo electrónico y la capacidad de enviar correos electrónicos personalizados directamente desde el CRM. Algunos sistemas CRM también ofrecen plantillas de correo electrónico y funciones de marketing por correo electrónico.\\nOtras Integraciones: Los sistemas CRM también pueden integrarse con plataformas de redes sociales, software de servicio al cliente, software de contabilidad y herramientas de colaboración. El objetivo general de estas integraciones es crear una visión unificada del cliente y optimizar los procesos comerciales.\\nLa integración del CRM es crucial para romper los silos de datos dentro de una organización y garantizar que los diferentes departamentos tengan una visión coherente y actualizada de la información del cliente.\\nEsta perspectiva unificada es esencial para brindar una experiencia de cliente perfecta en todos los puntos de contacto. Cuando el CRM se integra con otros sistemas empresariales, los datos fluyen automáticamente entre las plataformas, eliminando la necesidad de ingresar datos manualmente y reduciendo el riesgo de errores.\\nEsta sincronización en tiempo real garantiza que los equipos de ventas, marketing y servicio al cliente trabajen con la misma información, lo que lleva a interacciones con los clientes más coordinadas y efectivas.\\nLas integraciones específicas que una empresa debe priorizar dependen de sus necesidades únicas y de las otras herramientas de software que utiliza actualmente.\\nLas PYMES deben centrarse en las integraciones que abordan sus desafíos más apremiantes, como la optimización de la gestión de leads o la mejora de la comunicación con los clientes.\\nSi bien existe una amplia gama de integraciones disponibles, no todas son relevantes para todas las empresas.\\nLas PYMES deben identificar los procesos clave que desean optimizar y elegir sistemas CRM que ofrezcan una integración perfecta con las herramientas que utilizan para esos procesos.\\nPor ejemplo, una empresa de comercio electrónico probablemente priorizaría la integración con su plataforma de tienda en línea.\\n","section":"Cómo elegir el CRM o Software de Gestión de Ventas Adecuado para su Empresa","version":"current","path":"/es/blog/como-elegir-el-crm-o-software-de-gestion-de-ventas-adecuado-para-su-empresa#5-construyendo-un-ecosistema-conectado-la-importancia-de-la-integración-del-crm","category":"blogs"},{"title":"7. Funcionalidades Centrales: Funciones Esenciales de CRM para una Gestión de Ventas Eficaz","content":"Un sistema CRM eficaz debe ofrecer una variedad de funcionalidades básicas para facilitar la gestión de ventas y mejorar las relaciones con los clientes.\\nGestión de Contactos y Cuentas: Esta es una función fundamental para almacenar y organizar información detallada sobre contactos individuales y las empresas a las que pertenecen. Permite rastrear el historial de comunicación, las preferencias y las interacciones clave para cada contacto y cuenta. Las capacidades de segmentación para categorizar contactos y cuentas en función de diversos criterios también son esenciales.\\nSeguimiento de Clientes Potenciales y Oportunidades: Las funciones para capturar, calificar y rastrear clientes potenciales a lo largo del proceso de ventas son cruciales. El CRM ayuda a gestionar las oportunidades, incluido el seguimiento de las etapas del acuerdo, los ingresos potenciales y la probabilidad de cierre. Algunos sistemas CRM también ofrecen funcionalidades de puntuación y asignación de clientes potenciales.\\nVisualización del Embudo de Ventas: Una representación visual del embudo de ventas permite a los equipos de ventas ver el estado de los acuerdos en cada etapa. Las funciones de gestión del embudo ayudan a identificar cuellos de botella, pronosticar ventas y gestionar las actividades de ventas de manera eficaz. El embudo de ventas también debe poder personalizarse para que coincida con el proceso de ventas específico de la empresa.\\nAutomatización del Flujo de Trabajo: El CRM permite la automatización de tareas y procesos repetitivos, lo que mejora la eficiencia y libera tiempo para los equipos de ventas. Los ejemplos de flujos de trabajo automatizados incluyen el envío de correos electrónicos de seguimiento, la programación de tareas y la actualización de las etapas de los acuerdos. Los usuarios también deben poder configurar reglas y activadores personalizados para acciones automatizadas.\\nInformes y Análisis: Las herramientas de informes y análisis son esenciales para obtener información sobre el rendimiento de las ventas, el comportamiento del cliente y las tendencias comerciales generales. Esto incluye la disponibilidad de informes predefinidos y personalizables, paneles de control y funciones de previsión de ventas. La capacidad de rastrear métricas clave e indicadores clave de rendimiento (KPI) para monitorear el progreso hacia los objetivos de ventas también es importante.\\nIntegración de Correo Electrónico: La integración del correo electrónico permite a los equipos de ventas conectar sus cuentas de correo electrónico con el CRM, lo que les permite rastrear la correspondencia por correo electrónico y enviar correos electrónicos directamente desde el sistema. Las funciones como las plantillas de correo electrónico, el seguimiento de correo electrónico (tasas de apertura y clics) y la capacidad de vincular correos electrónicos a contactos y acuerdos específicos mejoran la productividad. La integración con aplicaciones de calendario para programar reuniones y citas también es beneficiosa.\\nSi bien los diferentes sistemas CRM ofrecen una amplia gama de funciones, estas funcionalidades básicas son esenciales para cualquier empresa que busque gestionar eficazmente sus procesos de ventas y relaciones con los clientes.\\nLas PYMES deben priorizar las plataformas CRM que ofrezcan versiones sólidas y fáciles de usar de estas funciones clave.\\nSin una sólida gestión de contactos y clientes potenciales, las empresas tendrán dificultades para organizar sus datos de clientes.\\nUna visión clara del embudo de ventas es crucial para rastrear el progreso e identificar áreas de mejora.\\nLas capacidades de automatización ahorran tiempo y garantizan la coherencia, mientras que los informes y el análisis proporcionan información valiosa para la toma de decisiones.\\nLa integración perfecta del correo electrónico mejora la comunicación y la productividad.\\nLas necesidades específicas de una PYME dictarán la importancia relativa de cada una de estas funcionalidades básicas. Por ejemplo, una empresa con un gran volumen de clientes potenciales podría priorizar las funciones sólidas de gestión de clientes potenciales, mientras que una empresa centrada en las relaciones a largo plazo con los clientes podría enfatizar la gestión de contactos y el seguimiento de la comunicación.\\nLas PYMES deben identificar sus principales objetivos de ventas y elegir un CRM que sobresalga en las funcionalidades que son más críticas para lograr esos objetivos. Una evaluación exhaustiva de su proceso de ventas actual y sus puntos débiles ayudará a determinar sus necesidades específicas.\\n","section":"Cómo elegir el CRM o Software de Gestión de Ventas Adecuado para su Empresa","version":"current","path":"/es/blog/como-elegir-el-crm-o-software-de-gestion-de-ventas-adecuado-para-su-empresa#7-funcionalidades-centrales-funciones-esenciales-de-crm-para-una-gestión-de-ventas-eficaz","category":"blogs"},{"title":"9. Tomando la Decisión Correcta: Una Guía Paso a Paso para Seleccionar su CRM Ideal","content":"Elegir el sistema CRM adecuado requiere un enfoque sistemático que tenga en cuenta las necesidades y objetivos específicos de su empresa.\\nDefina sus Objetivos y Necesidades Comerciales: Articule claramente lo que su empresa espera lograr con un sistema CRM. ¿Su objetivo es mejorar la generación de leads, aumentar las ventas, mejorar el servicio al cliente u optimizar los procesos internos?. Evalúe su proceso de ventas actual e identifique los puntos débiles que un CRM podría abordar.\\nEvalúe sus Requisitos Funcionales: Enumere las funciones y funcionalidades específicas que necesita en un CRM en función de sus objetivos y procesos. Considere las funciones esenciales como la gestión de contactos, el seguimiento de leads, la gestión de embudos, la automatización, los informes y las necesidades de integración. Priorice las funciones imprescindibles frente a las funciones deseables para reducir las opciones.\\nEvalúe las Opciones de Precios e Implementación: Revise cuidadosamente los modelos de precios de los diferentes proveedores de CRM, considerando los costos base, las tarifas por usuario, los límites de contacto y los niveles de funciones. Evalúe el costo total de propiedad, incluida la implementación, la capacitación y el soporte continuo. Considere su enfoque de implementación preferido (auto-implementación, incluida o de terceros) y sus costos y beneficios asociados.\\nComprenda sus Necesidades de Integración: Asegúrese de que el CRM elegido se integre perfectamente con otros sistemas comerciales que ya utiliza su empresa. Identifique las integraciones críticas, como ERP, automatización de marketing, correo electrónico o software de contabilidad. Consulte el sitio web del proveedor de CRM o el mercado de aplicaciones para conocer las integraciones disponibles.\\nAproveche los Períodos de Prueba Gratuitos: Aproveche los períodos de prueba gratuitos que ofrecen los proveedores de CRM para probar la facilidad de uso y la idoneidad de la plataforma para su empresa. Involucre al equipo de ventas y a otros usuarios potenciales en el proceso de prueba para recopilar comentarios. Utilice el período de prueba para explorar las funciones y funcionalidades clave relevantes para las necesidades de su empresa.\\nSeleccionar el CRM adecuado es un proceso que requiere una comprensión profunda de las necesidades y objetivos específicos de la empresa. Apresurarse a tomar una decisión sin una comprensión clara de los requisitos puede llevar a elegir un sistema que sea insuficiente o demasiado complejo y costoso.\\nUn enfoque sistemático, que comience con la definición de objetivos y la asignación de requisitos funcionales, garantizará que el CRM elegido se alinee con las prioridades estratégicas de la empresa y proporcione las herramientas necesarias para mejorar la gestión de ventas y las relaciones con los clientes.\\nLos períodos de prueba gratuitos son oportunidades invaluables para que las empresas experimenten una plataforma CRM de primera mano y evalúen su usabilidad y su ajuste dentro de sus flujos de trabajo existentes.\\nInvolucrar activamente a los usuarios potenciales en el proceso de prueba es crucial para garantizar la aceptación y maximizar las posibilidades de una adopción exitosa del CRM.\\nLos comentarios de los usuarios durante los períodos de prueba pueden revelar información práctica sobre la facilidad de uso, la relevancia de las funciones y cualquier desafío potencial que pueda surgir durante la implementación real. Esta información es esencial para tomar una decisión informada y seleccionar un CRM que satisfaga las necesidades de todo el equipo.\\n","section":"Cómo elegir el CRM o Software de Gestión de Ventas Adecuado para su Empresa","version":"current","path":"/es/blog/como-elegir-el-crm-o-software-de-gestion-de-ventas-adecuado-para-su-empresa#9-tomando-la-decisión-correcta-una-guía-paso-a-paso-para-seleccionar-su-crm-ideal","category":"blogs"},{"title":"10. Empoderando su Empresa con la Solución CRM Adecuada","content":"Elegir el software CRM adecuado es una decisión fundamental que puede afectar significativamente el crecimiento y el éxito de su empresa. Al considerar cuidadosamente los factores descritos en esta guía, puede seleccionar una solución que no solo satisfaga sus necesidades actuales sino que también respalde su crecimiento futuro.\\nLos sistemas CRM ofrecen una ventaja estratégica sobre los métodos tradicionales al mejorar la eficiencia, mejorar la gestión de datos, fortalecer las relaciones con los clientes, permitir la escalabilidad y proporcionar información valiosa a través de informes y análisis sólidos.\\nUna implementación bien planificada y una integración perfecta con otros sistemas comerciales son esenciales para maximizar los beneficios de su inversión en CRM y empoderará a su empresa, mejorará la satisfacción del cliente e impulsará el éxito a largo plazo en el dinámico mercado actual.\\nTe recomendamos leer:\\nCómo elegir el CRM o Software de Gestión de Ventas Adecuado para su Empresa\\nUn Análisis Más Detallado, Software CRM Popular en el Mercado Estadounidense\\n","section":"Cómo elegir el CRM o Software de Gestión de Ventas Adecuado para su Empresa","version":"current","path":"/es/blog/como-elegir-el-crm-o-software-de-gestion-de-ventas-adecuado-para-su-empresa#10-empoderando-su-empresa-con-la-solución-crm-adecuada","category":"blogs"},{"title":"3. Decodificando el Costo: Entendiendo los Modelos de Precios de CRM en la Nube","content":"Los modelos de precios para el software CRM moderno basado en la nube varían, pero la mayoría siguen ciertas estructuras comunes.\\nComprender estos modelos es esencial para que las empresas puedan evaluar con precisión el costo de un CRM y elegir un plan que se ajuste a su presupuesto y necesidades.\\nPrecios Basados en Suscripción: La mayoría de los CRM modernos basados en la nube operan con un modelo de suscripción, donde las empresas pagan una tarifa mensual o anual para usar el software. Este modelo ofrece flexibilidad y escalabilidad, lo que lo hace adecuado para empresas de diversos tamaños. El costo a menudo está determinado por la cantidad de usuarios que requieren acceso al sistema.\\nCostos de Plan Base: Otros proveedores ofrecen un plan base con una tarifa mensual o anual fija que incluye un conjunto de funciones principales. Estos planes base pueden incluir un cierto número de usuarios, y los usuarios adicionales incurren en cargos adicionales.\\nTarifas por Usuario: Además del costo del plan base, estos proveedores de CRM suelen cobrar una tarifa adicional por cada usuario que necesita acceder al sistema. Este precio por usuario permite a las empresas escalar el uso de su CRM en línea con el tamaño de su equipo.\\nCargos Basados en la Cantidad de Contactos: Algunos proveedores de CRM también pueden cobrar en función de la cantidad de contactos o clientes potenciales almacenados en el sistema. Este modelo de precios puede afectar a las empresas con grandes bases de datos de clientes potenciales.\\nCargos Basados en Funciones y Niveles: Otros proveedores de CRM ofrecen diferentes niveles de precios con distintos niveles de funciones y funcionalidades. Los planes básicos ofrecen funciones esenciales, mientras que los planes de nivel superior incluyen capacidades más avanzadas, como automatización de marketing o análisis avanzado. El panorama de precios para los CRM basados en la nube es diverso y requiere una cuidadosa consideración de varios factores más allá del costo base.\\nLas empresas deben anticipar su crecimiento en términos de usuarios y contactos, así como sus requisitos de funciones en evolución, para elegir un modelo de precios que siga siendo rentable a largo plazo.\\nSi bien el modelo de suscripción ofrece flexibilidad, el costo acumulado con el tiempo puede ser significativo. Comprender los matices de las tarifas por usuario, los límites de contacto y los niveles basados en funciones es crucial para evitar gastos inesperados a medida que la empresa escala.\\nLa tendencia hacia los precios escalonados refleja un esfuerzo de los proveedores de CRM para atender a una gama más amplia de empresas con diferentes necesidades y presupuestos.\\nSin embargo, también requiere una evaluación exhaustiva de las funciones incluidas en cada nivel para garantizar que el plan elegido proporcione las funcionalidades necesarias sin pagar en exceso por capacidades no utilizadas.\\nLas empresas deben mapear sus requisitos específicos con las funciones que se ofrecen en cada nivel de precios. Una comparación detallada de las ofertas de diferentes proveedores a precios similares puede revelar diferencias significativas en funcionalidad y valor.\\n","section":"Un Análisis Más Detallado, Software CRM Popular en el Mercado Estadounidense","version":"current","path":"/es/blog/software-crm-popular-en-el-mercado-estadounidense#3-decodificando-el-costo-entendiendo-los-modelos-de-precios-de-crm-en-la-nube","category":"blogs"},{"title":"6. Navegando por el Panorama: Complejidad y Curva de Aprendizaje de los Sistemas CRM","content":"La complejidad y la curva de aprendizaje de los sistemas CRM pueden variar significativamente entre las diferentes plataformas, lo que afecta su idoneidad para las PYMES.\\nVarios factores contribuyen a la complejidad de un CRM, incluida la cantidad de funciones que ofrece, el diseño de la interfaz de usuario, las opciones de personalización y la disponibilidad de recursos de capacitación.\\n<!-- truncate -->\\nSalesforce: Salesforce es una plataforma CRM potente y altamente personalizable que atiende a empresas de todos los tamaños. Sin embargo, puede presentar una curva de aprendizaje más pronunciada, especialmente para las PYMES, debido a su amplia gama de funciones y opciones de personalización.\\nZoho CRM: Zoho CRM es una plataforma versátil y rentable que ofrece una amplia gama de funciones para ventas, marketing y atención al cliente. Si bien es fácil de usar, puede tener una curva de aprendizaje ligeramente más pronunciada en comparación con otras CRM, especialmente para los usuarios que no están familiarizados con los sistemas CRM. Zoho CRM es altamente personalizable, lo que puede ser una ventaja, pero también puede contribuir a su complejidad.\\nFreshworks CRM (Freshsales): Freshworks CRM es un CRM de ventas impulsado por IA diseñado para ser fácil de usar, con un enfoque en la automatización de ventas y un proceso de ventas optimizado. Ofrece una interfaz intuitiva y un proceso de configuración rápido, lo que lo hace accesible para los usuarios de CRM por primera vez. Si bien generalmente es fácil de usar, algunos usuarios pueden encontrar que ciertas funciones avanzadas tienen una curva de aprendizaje.\\nEl \\"mejor\\" CRM para una PYME no es necesariamente el que tiene más funciones, sino el que logra el equilibrio adecuado entre funcionalidad y facilidad de uso.\\nUn CRM complejo con una curva de aprendizaje pronunciada puede generar frustración y subutilización, lo que anula sus beneficios potenciales.\\nLas PYMES suelen tener tiempo y recursos limitados para una capacitación extensa. Un CRM con una interfaz intuitiva y materiales de soporte fácilmente disponibles probablemente verá tasas de adopción más altas y ofrecerá un retorno de la inversión más rápido.\\nLos diferentes niveles de complejidad y curvas de aprendizaje entre los diferentes sistemas CRM sugieren que las empresas deben evaluar cuidadosamente su experiencia técnica interna y el tiempo que están dispuestas a invertir en capacitación al tomar una decisión.\\nUn CRM más simple podría ser preferible para las empresas con personal técnico limitado o aquellas que son nuevas en CRM.\\nLas empresas deben considerar realizar pruebas de diferentes plataformas CRM para evaluar su facilidad de uso desde la perspectiva de sus usuarios reales.\\nLos comentarios del equipo de ventas y otras partes interesadas relevantes pueden ser invaluables para elegir un CRM que se alinee con su nivel de comodidad y conjunto de habilidades.\\n","section":"Un Análisis Más Detallado, Software CRM Popular en el Mercado Estadounidense","version":"current","path":"/es/blog/software-crm-popular-en-el-mercado-estadounidense#6-navegando-por-el-panorama-complejidad-y-curva-de-aprendizaje-de-los-sistemas-crm","category":"blogs"},{"title":"8. Un Análisis Más Detallado: Software CRM Popular en el Mercado Estadounidense","content":"A continuación, se presenta una descripción general de las plataformas CRM populares en el mercado estadounidense, con un enfoque en su descripción, facilidad de uso para las PYMES, estructura de precios e información clave de las reseñas de los usuarios.\\nSalesforce\\n\\nDescripción: Salesforce es una plataforma CRM líder basada en la nube, conocida por sus amplias capacidades de personalización y una amplia gama de funciones para empresas de todos los tamaños. Ofrece soluciones para equipos de ventas, servicio, marketing, comercio y TI.\\nFacilidad de Uso y Curva de Aprendizaje para las PYMES: Si bien es potente, Salesforce puede tener una curva de aprendizaje más pronunciada, especialmente para las pequeñas y medianas empresas, debido a su gran cantidad de funciones y opciones de personalización. Estructura de Precios: Salesforce ofrece varios planes de precios, con Starter Suite para pequeñas empresas a partir de $25 por usuario al mes (facturado anualmente). Otros planes como Professional, Enterprise y Unlimited ofrecen niveles crecientes de funciones y personalización a precios más altos. Los complementos para funcionalidades específicas pueden aumentar aún más el costo.\\nInformación Clave de las Reseñas de los Usuarios (G2, Capterra): Los usuarios aprecian su capacidad para integrarse con varias otras aplicaciones comerciales y su escalabilidad. Sin embargo, también se señala con frecuencia como más caro que muchas alternativas y con una curva de aprendizaje más pronunciada, particularmente para principiantes. La atención al cliente generalmente es bien considerada, especialmente para los planes de nivel superior.\\n\\n\\nHubSpot\\n\\nDescripción: HubSpot CRM es conocido por su interfaz fácil de usar y su facilidad de uso, lo que lo hace particularmente adecuado para integraciones de ventas y marketing. Está diseñado teniendo en cuenta la experiencia del usuario, lo que facilita su adopción y escalabilidad por parte de las PYMES sin necesidad de equipos técnicos dedicados. Facilidad de Uso y Curva de Aprendizaje para las PYMES: HubSpot CRM está diseñado pensando en la facilidad de uso para las pequeñas y medianas empresas. Su interfaz se describe como intuitiva y fácil de usar, lo que facilita su adopción y escalabilidad por parte de las PYMES sin necesidad de equipos técnicos dedicados. La plataforma ofrece herramientas de arrastrar y soltar, paneles limpios y requiere una configuración mínima, lo que la hace accesible incluso para usuarios sin conocimientos técnicos.\\nEstructura de Precios: HubSpot CRM ofrece un plan gratuito con funciones esenciales, lo que lo convierte en una excelente opción para las pequeñas empresas que están comenzando. Sus planes de pago comienzan en $15 por usuario al mes para el plan Starter. Los planes Professional y Enterprise ofrecen funciones más avanzadas a precios más altos. HubSpot es conocido por su modelo de precios transparente, pero los costos pueden aumentar a medida que las empresas escalan y requieren funciones más avanzadas o más contactos de marketing.\\nInformación Clave de las Reseñas de los Usuarios (G2, Capterra): Si bien el plan gratuito es muy generoso, algunas funciones avanzadas y límites más altos requieren planes de pago, que pueden resultar costosos para las empresas en crecimiento.\\n\\n\\nZoho CRM\\n\\nDescripción: Zoho CRM es una plataforma versátil y rentable que ofrece una amplia gama de funciones para ventas, marketing y atención al cliente. Está diseñado para ayudar a las empresas a convertir más clientes potenciales, construir relaciones duraderas con los clientes y lograr un crecimiento resistente a través de IA contextual y una interfaz de usuario intuitiva. Zoho CRM atiende a empresas de todos los tamaños e industrias, desde pequeñas empresas hasta grandes empresas.\\nFacilidad de Uso y Curva de Aprendizaje para las PYMES: Zoho CRM está diseñado para ser fácil de usar, con una interfaz limpia e intuitiva. Ofrece una configuración sencilla y proporciona guías útiles para ayudar a los usuarios a comenzar. Si bien la plataforma ofrece una gran cantidad de funciones, lo que puede requerir algo de tiempo para dominar todo, su diseño organizado y limpio simplifica la experiencia del usuario. Zoho también ofrece Bigin by Zoho CRM, que está diseñado específicamente para pequeñas empresas, lo que sugiere un enfoque en la facilidad de uso para las PYMES.\\nEstructura de Precios: Zoho CRM ofrece una variedad de planes de precios para adaptarse a diferentes necesidades y presupuestos. Su plan gratuito admite hasta 3 usuarios, lo que lo convierte en una excelente opción para pequeñas empresas o nuevas empresas. Los planes de pago comienzan en $14 por usuario al mes (facturado anualmente) para el plan Estándar y ofrecen funciones y capacidades cada vez más avanzadas a precios más altos. Zoho también ofrece contratos mensuales flexibles sin períodos de bloqueo y sin costos ocultos, lo que lo hace atractivo para las PYMES que buscan soluciones rentables y adaptables.\\nInformación Clave de las Reseñas de los Usuarios (G2, Capterra): Si bien la plataforma generalmente se considera fácil de usar, algunos usuarios han notado que dominar todas sus funciones puede llevar tiempo. La atención al cliente ha recibido críticas mixtas, y algunos usuarios informan problemas de coherencia y tiempos de respuesta lentos.\\n\\n\\nFreshworks CRM (Freshsales)\\n\\nDescripción: Freshsales, de Freshworks, es un CRM de ventas impulsado por IA diseñado para ayudar a las empresas a vender de forma más inteligente y cerrar acuerdos más rápido. Su objetivo es agilizar el proceso de ventas y mejorar la productividad. Freshsales forma parte de Freshworks Suite, que ofrece soluciones para ventas, marketing y atención al cliente. Facilidad de Uso y Curva de Aprendizaje para las PYMES: Freshsales es conocido por su interfaz fácil de usar, especialmente teniendo en cuenta su amplia funcionalidad. La configuración se describe como rápida y sencilla, lo que sugiere una curva de aprendizaje poco profunda para la mayoría de los propietarios de negocios y sus equipos. Estructura de Precios: Freshsales ofrece una variedad de planes de precios, que incluyen un plan gratuito para hasta 3 usuarios con funciones esenciales. Los planes de pago comienzan en $15 por usuario al mes para el plan Growth (facturado anualmente) y ofrecen funciones y capacidades cada vez más avanzadas a precios más altos. Freshsales también ofrece una prueba gratuita de 21 días para que las empresas prueben la plataforma.\\nInformación Clave de las Reseñas de los Usuarios (G2, Capterra): Algunos usuarios han notado que la plataforma puede tener una curva de aprendizaje ligeramente más pronunciada que otras..\\nTabla 1: Comparación de Modelos de Precios para Software CRM Popular Basado en la Nube\\nPlataforma CRM\\nPrecio Inicial (por usuario/mes, facturado anualmente)\\nFunciones Clave en el Plan Básico\\nModelo de Precios\\nPosibles Costos Adicionales\\n\\n\\n\\n\\nSalesforce\\n$25\\nGestión de leads, gestión de cuentas y oportunidades\\nPor usuario\\nUsuarios adicionales, funciones avanzadas, complementos\\n\\n\\nHubSpot\\n$15\\nGestión de contactos, seguimiento de acuerdos, email marketing\\nPor usuario, niveles\\nContactos de marketing adicionales, funciones profesionales\\n\\n\\nZoho CRM\\n$12\\nGestión de leads, gestión de contactos, gestión de acuerdos\\nPor usuario, niveles\\nUsuarios adicionales, almacenamiento, funciones avanzadas\\n\\n\\nFreshworks CRM\\n$15\\nGestión de contactos y cuentas, gestión de acuerdos\\nPor usuario, niveles\\nUsuarios adicionales, funciones profesionales y empresariales\\nTabla 2: Evaluación de la Facilidad de Uso y la Curva de Aprendizaje para Plataformas CRM Populares (para PYMES)\\nPlataforma CRM\\nInterfaz de Usuario (Valoración)\\nCurva de Aprendizaje (Valoración)\\nDisponibilidad de Recursos de Capacitación\\nIdoneidad General para PYMES (Valoración)\\nConclusiones Clave de las Reseñas de los Usuarios (Facilidad de Uso)\\n\\n\\n\\n\\nSalesforce\\nCompleja\\nPronunciada\\nTrailhead, guías, soporte\\nMenos Adecuado\\nInterfaz potente pero puede ser abrumadora para principiantes.\\n\\n\\nHubSpot\\nMuy Intuitiva\\nMínima\\nHubSpot Academy, base de conocimientos, soporte\\nMuy Adecuado\\nInterfaz limpia y fácil de navegar, intuitiva incluso para no técnicos.\\n\\n\\nZoho CRM\\nIntuitiva\\nModerada\\nGuías, tutoriales, base de conocimientos, foros\\nAdecuado\\nDiseño organizado y limpio, pero dominar todas las funciones lleva tiempo.\\n\\n\\nFreshworks CRM\\nIntuitiva\\nModerada\\nBase de conocimientos, tutoriales, soporte\\nAdecuado\\nInterfaz intuitiva, pero la profundidad de las funciones puede ser abrumadora inicialmente.\\nTabla 3: Comparación de Funciones Esenciales de CRM Entre Plataformas Populares\\nPlataforma CRM\\nGestión de Contactos y Cuentas\\nSeguimiento de Clientes Potenciales y Oportunidades\\nVisualización del Embudo de Ventas\\nAutomatización del Flujo de Trabajo\\nInformes y Análisis\\nIntegración de Correo Electrónico\\n\\n\\n\\n\\nSalesforce\\nSí (Profundo)\\nSí (Sofisticado)\\nSí (Personalizable)\\nSí (Potente)\\nSí (Avanzado)\\nSí (Completo)\\n\\n\\nHubSpot\\nSí (Completo)\\nSí (Completo)\\nSí (Visual)\\nSí (Sencillo)\\nSí (Completo)\\nSí (Completo)\\n\\n\\nZoho CRM\\nSí (Completo)\\nSí (Completo)\\nSí (Personalizable)\\nSí (Personalizable)\\nSí (Completo)\\nSí (Completo)\\n\\n\\nFreshworks CRM\\nSí (Completo)\\nSí (Completo)\\nSí (Visual)\\nSí (Completo)\\nSí (Completo)\\nSí (Completo)\\nTe recomendamos leer:\\nCómo elegir el CRM o Software de Gestión de Ventas Adecuado para su Empresa\\nUn Análisis Más Detallado, Software CRM Popular en el Mercado Estadounidense\\n","section":"Un Análisis Más Detallado, Software CRM Popular en el Mercado Estadounidense","version":"current","path":"/es/blog/software-crm-popular-en-el-mercado-estadounidense#8-un-análisis-más-detallado-software-crm-popular-en-el-mercado-estadounidense","category":"blogs"},{"title":"6.1. Eficacia","content":"Los sistemas CRM ofrecen inherentemente un mayor grado de eficacia en la gestión de la nutrición y el seguimiento de leads en comparación con Excel.\\n<!-- truncate -->\\nEl repositorio de datos centralizado dentro de un CRM permite una comprensión integral de cada lead, facilitando una comunicación altamente personalizada que aborda sus necesidades específicas y su etapa en el recorrido del comprador.\\nFunciones como la puntuación de leads mejoran aún más la eficacia al permitir que los equipos de ventas prioricen sus esfuerzos en los prospectos más prometedores.\\nAdemás, las capacidades de automatización del CRM garantizan un seguimiento constante y oportuno, nutriendo a los leads a través de secuencias y recordatorios predefinidos, lo que aumenta significativamente la probabilidad de conversión.\\nEn contraste, las limitaciones de Excel en personalización, automatización y seguimiento oportuno a menudo resultan en un enfoque menos específico y más manual para la gestión de leads, lo que podría llevar a la pérdida de oportunidades y a una nutrición menos eficaz.\\nLas funcionalidades diseñadas de los sistemas CRM abordan directamente los requisitos básicos para una nutrición y un seguimiento de leads exitosos, lo que lleva a tasas de participación y conversión más altas en comparación con los métodos manuales y menos específicos que se emplean típicamente con Excel.\\n","section":"Comparación de la Eficacia y la Eficiencia de CRM Versus Excel en la Gestión de Procesos de Nutrición y Seguimiento de Leads","version":"current","path":"/es/blog/comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel#61-eficacia","category":"blogs"},{"title":"6.2. Eficiencia","content":"En términos de eficiencia, los sistemas CRM proporcionan una clara ventaja sobre Excel en la gestión de los procesos de nutrición y seguimiento de leads.\\nLa automatización de tareas repetitivas pero cruciales, como la entrada de datos, el envío de correos electrónicos de seguimiento y la programación de recordatorios, reduce significativamente la carga administrativa de los equipos de ventas y marketing, liberando su tiempo para que se centren en actividades más estratégicas.\\nEl acceso centralizado a los datos de los leads dentro de un CRM también agiliza los flujos de trabajo al reducir el tiempo dedicado a buscar información y proporcionar una visión general rápida y completa de todas las interacciones con los leads.\\nPor el contrario, la gestión de la nutrición y el seguimiento de leads en Excel a menudo se caracteriza por la entrada manual de datos que consume mucho tiempo, la falta de recordatorios automatizados para las acciones críticas de seguimiento y las dificultades en la colaboración del equipo, todo lo cual contribuye a ineficiencias significativas.\\nLas capacidades de automatización y la gestión centralizada de datos de los sistemas CRM permiten a los equipos manejar mayores volúmenes de leads con menos esfuerzo manual y un menor riesgo de errores, lo que resulta en un enfoque mucho más eficiente para la gestión de leads.\\n","section":"Comparación de la Eficacia y la Eficiencia de CRM Versus Excel en la Gestión de Procesos de Nutrición y Seguimiento de Leads","version":"current","path":"/es/blog/comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel#62-eficiencia","category":"blogs"},{"title":"6.3. Tabla: Comparación de Eficacia y Eficiencia","content":"Característica\\nSistema CRM\\nExcel\\n\\n\\n\\n\\nEficacia\\nAlta: Nutrición y seguimiento personalizados, oportunos y dirigidos.\\nBaja a Media: Capacidades limitadas de personalización y segmentación.\\n\\n\\nAutomatización\\nAlta: Automatiza seguimientos, recordatorios, entrada de datos, puntuación de leads.\\nBaja: Procesos principalmente manuales.\\n\\n\\nGestión de Datos\\nCentralizada, única fuente de verdad, fácil acceso y actualizaciones.\\nDescentralizada, potencial de inconsistencias, difícil de gestionar grandes datos.\\n\\n\\nColaboración\\nFluida, colaboración en tiempo real entre equipos.\\nLimitada, propensa a problemas de control de versiones.\\n\\n\\nInformes y Análisis\\nInformes y paneles de control avanzados y personalizables para obtener información sobre el rendimiento.\\nAnálisis básico basado en gráficos y fórmulas, requiere mucho tiempo.\\n\\n\\nEscalabilidad\\nAlta: Diseñado para crecer con la empresa.\\nBaja: Se vuelve engorroso e ineficiente con el crecimiento.\\n\\n\\nEficiencia\\nAlta: Ahorra tiempo, reduce errores manuales, agiliza los flujos de trabajo.\\nBaja: Tareas manuales que consumen tiempo, propensas a errores.\\n7. Funciones y Funcionalidades Específicas Dentro de las Plataformas CRM Beneficiosas para la Nutrición y el Seguimiento de Leads en Comparación con Excel\\n","section":"Comparación de la Eficacia y la Eficiencia de CRM Versus Excel en la Gestión de Procesos de Nutrición y Seguimiento de Leads","version":"current","path":"/es/blog/comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel#63-tabla-comparación-de-eficacia-y-eficiencia","category":"blogs"},{"title":"7.1. Puntuación y Calificación de Leads","content":"Los sistemas CRM a menudo incorporan sofisticadas funcionalidades de puntuación de leads que asignan automáticamente puntos a los leads en función de su información demográfica, su interacción con los materiales de marketing y su comportamiento en el sitio web de una empresa u otras plataformas digitales.\\nEste proceso de puntuación automatizado ayuda a los equipos de ventas a identificar rápidamente qué leads son los más prometedores y están listos para la venta, lo que les permite priorizar sus esfuerzos de contacto en consecuencia.\\nEn contraste, la calificación de leads en Excel suele ser un proceso manual y subjetivo, que depende de que los representantes de ventas individuales evalúen el potencial de un lead en función de información limitada y su propio juicio.\\nLa naturaleza objetiva y la automatización de la puntuación de leads dentro de un CRM proporcionan una forma más consistente y eficiente de identificar leads de alto potencial.\\n","section":"Comparación de la Eficacia y la Eficiencia de CRM Versus Excel en la Gestión de Procesos de Nutrición y Seguimiento de Leads","version":"current","path":"/es/blog/comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel#71-puntuación-y-calificación-de-leads","category":"blogs"},{"title":"7.2. Flujos de Trabajo y Secuencias Automatizadas","content":"Las plataformas CRM permiten a los usuarios diseñar e implementar flujos de trabajo y secuencias de seguimiento automatizadas que se activan por acciones o hitos específicos de los leads.\\nPor ejemplo, un lead que descarga un recurso (ppt, guía, etc) específico podría recibir automáticamente una serie de correos electrónicos dirigidos durante los siguientes días o semanas.\\nEstas secuencias automatizadas garantizan que los leads reciban una comunicación oportuna y relevante sin requerir la intervención manual del equipo de ventas o marketing.\\nExcel carece de la capacidad de crear tales procesos de seguimiento automatizados y basados en el comportamiento, lo que requiere la programación y ejecución manual de cada comunicación, lo que puede llevar mucho tiempo y ser propenso a omisiones.\\n","section":"Comparación de la Eficacia y la Eficiencia de CRM Versus Excel en la Gestión de Procesos de Nutrición y Seguimiento de Leads","version":"current","path":"/es/blog/comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel#72-flujos-de-trabajo-y-secuencias-automatizadas","category":"blogs"},{"title":"7.3. Integración y Seguimiento del Correo Electrónico","content":"Muchos sistemas CRM ofrecen una integración perfecta con las plataformas de correo electrónico populares, lo que permite a los usuarios enviar y rastrear correos electrónicos directamente desde la interfaz del CRM.\\nEsta integración a menudo incluye funciones como plantillas de correo electrónico prediseñadas que se pueden personalizar con información específica del lead, la capacidad de programar el envío de correos electrónicos en los momentos óptimos y el seguimiento de las aperturas y los clics de los correos electrónicos para evaluar la participación del lead.\\nEste nivel de gestión e información del correo electrónico no está disponible cuando se utiliza Excel, donde la comunicación por correo electrónico se maneja típicamente por separado, lo que dificulta el seguimiento de qué correos electrónicos se han enviado, su contenido y la interacción del destinatario con ellos.\\n","section":"Comparación de la Eficacia y la Eficiencia de CRM Versus Excel en la Gestión de Procesos de Nutrición y Seguimiento de Leads","version":"current","path":"/es/blog/comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel#73-integración-y-seguimiento-del-correo-electrónico","category":"blogs"},{"title":"7.4. Gestión de Campañas","content":"Las plataformas CRM a menudo proporcionan herramientas robustas de gestión de campañas que permiten a las empresas crear, ejecutar y rastrear campañas de nutrición de leads a través de múltiples canales, incluyendo correo electrónico, redes sociales y marketing de contenidos.\\nEstas funciones permiten a las empresas segmentar sus leads en grupos específicos para mensajes dirigidos, automatizar la entrega de contenido relevante y supervisar el rendimiento de sus campañas en términos de participación y tasas de conversión.La gestión de campañas multicanal y el seguimiento preciso de su eficacia son significativamente más desafiantes y menos eficientes cuando se depende únicamente de Excel, que carece de las herramientas integradas para la creación, automatización y análisis del rendimiento de las campañas.\\n","section":"Comparación de la Eficacia y la Eficiencia de CRM Versus Excel en la Gestión de Procesos de Nutrición y Seguimiento de Leads","version":"current","path":"/es/blog/comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel#74-gestión-de-campañas","category":"blogs"},{"title":"7.5. Paneles de Control e Informes y Análisis","content":"Los sistemas CRM suelen incluir paneles de control de informes intuitivos y herramientas de análisis personalizables que proporcionan una visión clara y visual de las métricas clave de nutrición y seguimiento de leads.\\nLos usuarios pueden rastrear fácilmente los KPI críticos, como las tasas de conversión de leads en diferentes etapas del embudo, los niveles generales de participación con los esfuerzos de nutrición, la duración promedio del ciclo de ventas y el rendimiento de los representantes de ventas individuales.\\nEstos paneles de control e informes proporcionan información práctica que permite a las empresas comprender qué está funcionando bien e identificar áreas de mejora en sus estrategias de gestión de leads.\\nLa generación de informes similares, completos y dinámicos en Excel requiere una manipulación manual significativa de los datos y habilidades avanzadas en hojas de cálculo.\\n","section":"Comparación de la Eficacia y la Eficiencia de CRM Versus Excel en la Gestión de Procesos de Nutrición y Seguimiento de Leads","version":"current","path":"/es/blog/comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel#75-paneles-de-control-e-informes-y-análisis","category":"blogs"},{"title":"7.6. Gestión de Contactos y Actividades","content":"Los sistemas CRM están diseñados para proporcionar una visión de 360 grados de cada lead, centralizando toda la información de contacto relevante, un historial cronológico de cada interacción (incluyendo correos electrónicos, llamadas, reuniones y visitas al sitio web) y detalles de cualquier actividad de seguimiento programada.\\nLos representantes de ventas pueden registrar fácilmente todas sus interacciones con un lead, asegurando que se mantenga un registro completo y accesible para todo el equipo.\\nEsta gestión integral de contactos y actividades ayuda a construir contexto para futuras interacciones y garantiza un enfoque más personalizado e informado para la nutrición y el seguimiento de leads.\\nEn contraste, la gestión de la información de contacto y el seguimiento de las actividades en Excel a menudo resulta en registros fragmentados e incompletos, lo que dificulta el mantenimiento de una comprensión holística del recorrido y la participación de cada lead.\\nTe recomendamos leer:\\nCRM vs Excel, Un Análisis Comparativo para la Nutrición y el Seguimiento de Leads en Ventas\\nLas Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads\\nComparación de la Eficacia y la Eficiencia de CRM Versus Excel\\nLas Desventajas de Usar Excel para la Nutrición y el Seguimiento de Leads\\nIndicadores Clave de Rendimiento (KPI) para Medir el Éxito\\n","section":"Comparación de la Eficacia y la Eficiencia de CRM Versus Excel en la Gestión de Procesos de Nutrición y Seguimiento de Leads","version":"current","path":"/es/blog/comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel#76-gestión-de-contactos-y-actividades","category":"blogs"},{"title":"2. Introducción","content":"La capacidad de nutrir eficazmente a los leads y realizar un seguimiento constante de los clientes potenciales es primordial para convertir a los prospectos en clientes leales y lograr un crecimiento de ingresos sostenible para cualquier negocio.\\nDos herramientas comunes utilizadas por las organizaciones para gestionar estos procesos críticos son los sistemas de Gestión de Relaciones con los Clientes (CRM) y Microsoft Excel.\\nLos sistemas CRM son soluciones de software diseñadas específicamente para gestionar y analizar las interacciones y los datos de los clientes a lo largo de su ciclo de vida, con el objetivo de mejorar las relaciones comerciales.\\nExcel, por otro lado, es un programa de hojas de cálculo ampliamente utilizado, destinado principalmente a la organización y el análisis de datos.\\nBuscaremos proporcionar una comparación detallada de los sistemas CRM y Excel en el contexto de la nutrición y el seguimiento de leads dentro de las ventas. Examinar las ventajas y desventajas de cada herramienta, destacar funcionalidades específicas, identificar indicadores clave de rendimiento relevantes y analizar escenarios de uso adecuados, proporcionando así la información necesaria para tomar decisiones informadas sobre qué herramienta se alinea mejor con sus necesidades y objetivos específicos para optimizar sus estrategias de gestión de leads.\\n","section":"CRM vs Excel, Un Análisis Comparativo para la Nutrición y el Seguimiento de Leads en Ventas","version":"current","path":"/es/blog/crm-vs-excel-un-analisis-comparativo#2-introducción","category":"blogs"},{"title":"3.1. Definición de la Nutrición de Leads en Ventas","content":"La nutrición de leads, dentro del ámbito de las ventas, se entiende como el proceso estratégico de cultivar relaciones con clientes potenciales que han expresado algún nivel de interés en los productos o servicios de una empresa, pero que aún no están listos para realizar una compra.\\nEsto implica una comprensión profunda de las necesidades y los desafíos del cliente potencial, junto con la provisión constante de información y recursos valiosos adaptados a su etapa específica en el proceso de compra.\\nEl objetivo fundamental de la nutrición de leads es construir confianza y credibilidad, mejorar el conocimiento de la marca y mantener una conexión significativa con los prospectos hasta que estén suficientemente informados y motivados para convertirse en clientes de pago.\\nEsto no es un evento singular, sino más bien un viaje cuidadosamente orquestado y de múltiples etapas que abarca tanto el embudo de marketing como el de ventas.\\nLa nutrición eficaz de leads enfatiza el desarrollo de una relación a largo plazo al abordar de manera proactiva los puntos débiles del cliente potencial y ofrecer soluciones, en lugar de centrarse únicamente en ganancias transaccionales inmediatas.\\nEste compromiso sostenido y personalizado es crucial para fomentar la lealtad del cliente y, en última instancia, impulsar el crecimiento de los ingresos.\\n","section":"CRM vs Excel, Un Análisis Comparativo para la Nutrición y el Seguimiento de Leads en Ventas","version":"current","path":"/es/blog/crm-vs-excel-un-analisis-comparativo#31-definición-de-la-nutrición-de-leads-en-ventas","category":"blogs"},{"title":"3.2. Definición del Seguimiento de Leads en Ventas","content":"El seguimiento de leads en ventas se refiere al proceso sistemático de contactar a individuos o entidades que han mostrado un interés inicial en las ofertas de una empresa o que han participado en alguna forma de interacción, como enviar una consulta o descargar una guía o algún recurso.\\nEl objetivo principal del seguimiento de leads es mantener el compromiso del prospecto con el proceso de ventas y continuar nutriendo la relación hasta que esté preparado para tomar una decisión de compra.\\nUn seguimiento de leads exitoso se caracteriza por varios elementos clave, incluyendo una respuesta oportuna a las consultas iniciales, un enfoque personalizado que reconoce las necesidades específicas del prospecto y la provisión de valor continuo en cada interacción.\\nRequiere un delicado equilibrio entre el contacto constante y el respeto por el tiempo y las preferencias de comunicación del prospecto, asegurando la persistencia sin volverse intrusivo.\\nUn seguimiento de leads eficaz es una secuencia estratégica de acciones diseñadas para guiar a los clientes potenciales a través del proceso de toma de decisiones, proporcionando información relevante, abordando sus inquietudes y generando confianza en la capacidad de la empresa para satisfacer sus necesidades.\\n","section":"CRM vs Excel, Un Análisis Comparativo para la Nutrición y el Seguimiento de Leads en Ventas","version":"current","path":"/es/blog/crm-vs-excel-un-analisis-comparativo#32-definición-del-seguimiento-de-leads-en-ventas","category":"blogs"},{"title":"3.3. Relación Entre la Nutrición y el Seguimiento de Leads","content":"El seguimiento de leads funciona como un componente táctico crítico dentro del marco estratégico general de la nutrición de leads. Mientras que la nutrición de leads abarca el esfuerzo más amplio de construir y mantener relaciones con clientes potenciales a lo largo de todo su recorrido, el seguimiento de leads se centra en las interacciones y comunicaciones específicas e individuales diseñadas para hacer avanzar al lead a través del ciclo de ventas.El seguimiento de leads luego ejecuta las acciones necesarias en cada una de estas etapas, asegurando que la comunicación sea oportuna, relevante y contribuya a los objetivos generales de nutrición.\\nEstos dos conceptos están intrínsecamente ligados y se refuerzan mutuamente; una nutrición eficaz proporciona el contexto y la estrategia para las actividades de seguimiento, mientras que un seguimiento constante y valioso es esencial para una nutrición de leads exitosa y, en última instancia, para la conversión de ventas.\\nTe recomendamos leer:\\nCRM vs Excel, Un Análisis Comparativo para la Nutrición y el Seguimiento de Leads en Ventas\\nLas Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads\\nComparación de la Eficacia y la Eficiencia de CRM Versus Excel\\nLas Desventajas de Usar Excel para la Nutrición y el Seguimiento de Leads\\nIndicadores Clave de Rendimiento (KPI) para Medir el Éxito\\n","section":"CRM vs Excel, Un Análisis Comparativo para la Nutrición y el Seguimiento de Leads en Ventas","version":"current","path":"/es/blog/crm-vs-excel-un-analisis-comparativo#33-relación-entre-la-nutrición-y-el-seguimiento-de-leads","category":"blogs"},{"title":"8.1. KPIs Medibles con CRM","content":"Los sistemas CRM ofrecen la capacidad de rastrear y medir con precisión varios indicadores clave de rendimiento (KPI) que son cruciales para evaluar el éxito de los esfuerzos de nutrición y seguimiento de leads.\\n<!-- truncate -->\\nLa Tasa de Conversión, que representa el porcentaje de leads que finalmente se convierten en clientes de pago, es un KPI fundamental que se puede rastrear fácilmente dentro de un CRM a medida que los leads avanzan por el embudo de ventas.\\nUna Puntuación de Compromiso del Lead, a menudo calculada automáticamente por el CRM en función de las interacciones de un lead con las actividades de marketing y ventas, proporciona una indicación numérica de su nivel de interés.\\nPara las campañas de nutrición basadas en correo electrónico, la Tasa de Clics (CTR) y la Tasa de Apertura revelan la eficacia del contenido del correo electrónico para captar la atención e interés de los leads.\\nLa Duración del Ciclo de Ventas, que es el tiempo que tarda un lead en pasar del punto de contacto inicial a un acuerdo cerrado, también se puede medir con precisión dentro de un CRM mediante el seguimiento de las diversas etapas del proceso de ventas.\\nAdemás, los datos del CRM permiten calcular el Costo por Adquisición (CPA), que representa el costo de adquirir un nuevo cliente a través de iniciativas de nutrición y seguimiento de leads, y el Retorno de la Inversión (ROI) de las Campañas de Nutrición de Leads, que compara los ingresos generados por los leads nutridos con los gastos incurridos en la ejecución de esas campañas.\\nLos sistemas CRM pueden rastrear la Eficacia de la Fuente del Lead, identificando qué canales o fuentes están generando los leads de mayor calidad y más convertibles.\\n","section":"Indicadores Clave de Rendimiento (KPI) para Medir el Éxito de la Nutrición y el Seguimiento de Leads","version":"current","path":"/es/blog/indicadores-clave-de-rendimiento-kpi-para-medir-el-exito#81-kpis-medibles-con-crm","category":"blogs"},{"title":"8.2. KPIs Difíciles o Imposibles de Medir con Precisión con Excel","content":"Si bien el seguimiento básico del estado del lead y la conversión final se pueden registrar manualmente en Excel, la obtención de mediciones precisas y escalables para varios indicadores clave de rendimiento es significativamente desafiante o incluso imposible. Por ejemplo, una Puntuación de Compromiso del Lead que refleje una visión holística de las interacciones de un lead a través de varios puntos de contacto requiere capacidades de seguimiento automatizadas de las que carece Excel.\\nDe manera similar, métricas como la Tasa de Clics y la Tasa de Apertura para los correos electrónicos enviados como parte de las campañas de nutrición no son medibles dentro de Excel, ya que no tiene funciones integradas de integración o seguimiento de correo electrónico.\\nEl seguimiento preciso de la Duración del Ciclo de Ventas para un gran número de leads en Excel, con marcas de tiempo detalladas para cada etapa, es propenso a errores e ineficiencias debido a la naturaleza manual de la entrada y las actualizaciones de datos.\\nEl cálculo del Costo por Adquisición (CPA) y el Retorno de la Inversión (ROI) de las Campañas de Nutrición de Leads en Excel también es problemático, ya que requiere vincular los gastos de marketing a conversiones de leads específicas, un proceso que necesita capacidades de integración no disponibles en el software de hojas de cálculo estándar.\\nSi bien la fuente del lead se puede anotar manualmente en una hoja de Excel, realizar un análisis detallado de la Eficacia de la Fuente del Lead en un conjunto de datos sustancial y correlacionarlo con las métricas de conversión es una tarea engorrosa y propensa a errores sin las funciones automatizadas de seguimiento e informes de un CRM.\\n","section":"Indicadores Clave de Rendimiento (KPI) para Medir el Éxito de la Nutrición y el Seguimiento de Leads","version":"current","path":"/es/blog/indicadores-clave-de-rendimiento-kpi-para-medir-el-exito#82-kpis-difíciles-o-imposibles-de-medir-con-precisión-con-excel","category":"blogs"},{"title":"8.3. Tabla: Capacidades de Medición de KPIs","content":"KPI\\nMedible con CRM\\nMedible con Excel (con precisión/escalabilidad)\\n\\n\\n\\n\\nTasa de Conversión\\nSí\\nSí (con un esfuerzo manual significativo)\\n\\n\\nPuntuación de Compromiso del Lead\\nSí\\nNo\\n\\n\\nCTR y Tasa de Apertura de Correo Electrónico\\nSí\\nNo\\n\\n\\nDuración del Ciclo de Ventas\\nSí\\nDifícil\\n\\n\\nCosto por Adquisición (CPA)\\nSí\\nNo\\n\\n\\nROI de Campañas\\nSí\\nNo\\n\\n\\nEficacia de la Fuente del Lead\\nSí\\nDifícil\\n","section":"Indicadores Clave de Rendimiento (KPI) para Medir el Éxito de la Nutrición y el Seguimiento de Leads","version":"current","path":"/es/blog/indicadores-clave-de-rendimiento-kpi-para-medir-el-exito#83-tabla-capacidades-de-medición-de-kpis","category":"blogs"},{"title":"9. Mejores Prácticas para la Nutrición y el Seguimiento de Leads Utilizando un Sistema CRM","content":"Para maximizar la eficacia de los esfuerzos de nutrición y seguimiento de leads utilizando un sistema CRM, se deben implementar varias mejores prácticas.\\nEn primer lugar, es crucial Definir su Perfil de Cliente Ideal (ICP) para obtener una comprensión clara de las características de su público objetivo, lo que le permitirá adaptar sus estrategias de nutrición y seguimiento de manera eficaz.\\nEn segundo lugar, Segmentar los Leads en función de diversos criterios, como la demografía, el comportamiento, los intereses y su posición en el recorrido del comprador, para asegurarse de que está entregando contenido y mensajes personalizados que resuenan con cada grupo.\\nComprender y Mapear el Recorrido del Comprador también es esencial; esto implica identificar las diferentes etapas por las que pasa un lead antes de realizar una compra y crear contenido y puntos de contacto relevantes para cada etapa.\\nCrear Contenido Dirigido y Valioso que aborde las necesidades y los puntos débiles específicos de sus leads en cada etapa de su recorrido es primordial para generar confianza y guiarlos hacia la conversión.\\nPersonalizar su Comunicación aprovechando los datos disponibles en su CRM para adaptar los correos electrónicos, los mensajes y las ofertas a los leads individuales hará que se sientan más valorados y comprendidos, lo que aumentará el compromiso con la marca.\\nLa implementación de Flujos de Trabajo Automatizados para tareas repetitivas como el envío de correos electrónicos de seguimiento y la programación de recordatorios garantiza un compromiso oportuno y coherente sin esfuerzo manual.\\nLa utilización de un sistema de Puntuación de Leads ayuda a identificar y priorizar los leads más prometedores para el contacto de ventas, maximizando la eficiencia y el potencial de conversión.\\nTambién es fundamental Realizar un Seguimiento Oportuno después de la consulta o interacción inicial de un lead para demostrar capacidad de respuesta y valorar su interés.\\nInteractuar con los leads a través de Múltiples Canales como correo electrónico, redes sociales y llamadas telefónicas, en función de sus preferencias y comportamiento, también puede mejorar el compromiso.\\nRastrear y Analizar Continuamente sus Resultados mediante la supervisión de los KPI clave de nutrición y seguimiento de leads dentro de su CRM le ayudará a identificar qué estrategias son eficaces y dónde se necesitan mejoras.\\nGarantizar la Alineación Entre los Esfuerzos de Ventas y Marketing en las definiciones, los procesos y los objetivos de los leads es crucial para una estrategia de gestión de leads fluida y eficaz. Y en función de los datos de rendimiento que recopile, es importante Optimizar Continuamente sus Estrategias para mejorar tanto la eficacia como la eficiencia de sus procesos de nutrición y seguimiento de leads.\\n","section":"Indicadores Clave de Rendimiento (KPI) para Medir el Éxito de la Nutrición y el Seguimiento de Leads","version":"current","path":"/es/blog/indicadores-clave-de-rendimiento-kpi-para-medir-el-exito#9-mejores-prácticas-para-la-nutrición-y-el-seguimiento-de-leads-utilizando-un-sistema-crm","category":"blogs"},{"title":"10. Análisis de Escenarios Donde el Uso de un CRM es Más Adecuado que Excel para la Nutrición y el Seguimiento de Leads","content":"En varios escenarios, las capacidades de un sistema CRM lo convierten en una opción significativamente más adecuada que Excel para gestionar los procesos de nutrición y seguimiento de leads. Cuando las empresas experimentan Equipos de Ventas en Crecimiento y Aumento de los Volúmenes de Leads, la gestión centralizada de datos, las funciones de automatización y las herramientas de colaboración que ofrece un CRM se vuelven esenciales para mantener la organización y garantizar que no se pasen por alto leads.\\nExcel a menudo se vuelve engorroso y difícil de gestionar en tales condiciones. Para las empresas con Ciclos de Ventas Complejos con Múltiples Puntos de Contacto, la automatización del flujo de trabajo, la integración del correo electrónico y el seguimiento detallado de las interacciones de un CRM son cruciales para mantener a los leads comprometidos y guiarlos a través de las diversas etapas del proceso de compra. Excel carece de la sofisticación para manejar eficientemente este nivel de complejidad.\\nCuando existe una Necesidad de Informes y Análisis Detallados para obtener información sobre el rendimiento de la nutrición y el seguimiento de leads, optimizar las estrategias y medir el ROI, las capacidades avanzadas de informes y análisis de un CRM proporcionan una clara ventaja sobre las funcionalidades básicas de Excel.\\nSi una empresa tiene un Requisito de Integración Perfecta con Otros Sistemas Empresariales, como plataformas de automatización de marketing, servicios de marketing por correo electrónico y sistemas de atención al cliente, las capacidades de integración de un CRM ofrecen un flujo de trabajo optimizado y eficiente que Excel no puede replicar.\\nEn industrias donde existe un Énfasis en la Seguridad y el Cumplimiento de los Datos, los sistemas CRM ofrecen funciones de seguridad robustas y pistas de auditoría que faltan en Excel, lo que convierte al CRM en la opción más segura y compatible para proteger la información confidencial de los clientes.\\nPara los equipos de ventas que requieren Accesibilidad Móvil a la información de los leads mientras están en movimiento, los sistemas CRM con aplicaciones móviles dedicadas proporcionan una ventaja significativa sobre Excel, que típicamente requiere acceso de escritorio.\\n","section":"Indicadores Clave de Rendimiento (KPI) para Medir el Éxito de la Nutrición y el Seguimiento de Leads","version":"current","path":"/es/blog/indicadores-clave-de-rendimiento-kpi-para-medir-el-exito#10-análisis-de-escenarios-donde-el-uso-de-un-crm-es-más-adecuado-que-excel-para-la-nutrición-y-el-seguimiento-de-leads","category":"blogs"},{"title":"11. Conclusión","content":"Si bien Microsoft Excel puede servir como una herramienta inicial y básica para gestionar los datos de los clientes y algunos aspectos de la nutrición y el seguimiento de leads, particularmente para empresas muy pequeñas con procesos sencillos, presenta limitaciones significativas que dificultan la eficacia y la eficiencia a medida que las empresas crecen y sus necesidades se vuelven más complejas.\\nLos sistemas CRM, por otro lado, están diseñados específicamente para abordar los requisitos multifacéticos de la gestión moderna de leads. Las fortalezas de las plataformas CRM en áreas como la automatización de tareas, la gestión centralizada de datos, las capacidades de personalización mejoradas, los informes y análisis robustos, la integración perfecta con otras herramientas empresariales y la escalabilidad los convierten en una solución mucho más eficaz y eficiente para nutrir leads y realizar un seguimiento de los clientes potenciales.\\nLas limitaciones inherentes de Excel, incluyendo su susceptibilidad a errores humanos, la falta de datos en tiempo real, la colaboración ineficiente y las características de seguridad inadecuadas, lo hacen menos adecuado para las empresas que buscan optimizar sus procesos de ventas y construir relaciones sólidas y duraderas con los clientes.\\nPor lo tanto, si bien Excel podría ofrecer un punto de entrada de bajo costo, las empresas que se toman en serio la maximización de sus tasas de conversión de leads, la mejora del compromiso del cliente y el logro de un crecimiento sostenible encontrarán que invertir en un sistema CRM es la decisión más estratégica y, en última instancia, más gratificante para gestionar sus esfuerzos de nutrición y seguimiento de leads.\\nElegir las herramientas adecuadas para optimizar los procesos de ventas es crucial para alcanzar los objetivos empresariales en el panorama competitivo actual.\\nTe recomendamos leer:\\nCRM vs Excel, Un Análisis Comparativo para la Nutrición y el Seguimiento de Leads en Ventas\\nLas Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads\\nComparación de la Eficacia y la Eficiencia de CRM Versus Excel\\nLas Desventajas de Usar Excel para la Nutrición y el Seguimiento de Leads\\nIndicadores Clave de Rendimiento (KPI) para Medir el Éxito\\n","section":"Indicadores Clave de Rendimiento (KPI) para Medir el Éxito de la Nutrición y el Seguimiento de Leads","version":"current","path":"/es/blog/indicadores-clave-de-rendimiento-kpi-para-medir-el-exito#11-conclusión","category":"blogs"},{"title":"5.1. Propenso a Errores Humanos","content":"Uno de los inconvenientes fundamentales de depender de Microsoft Excel para la nutrición y el seguimiento de leads es su inherente susceptibilidad a errores humanos.La naturaleza manual de la entrada de datos en las hojas de cálculo significa que los errores como las erratas, las fórmulas incorrectas o las eliminaciones accidentales se cometen fácilmente, lo que puede llevar a imprecisiones en el seguimiento y el análisis de las ventas.\\n<!-- truncate -->\\nA diferencia de los sistemas CRM que a menudo incorporan funciones automatizadas de validación de datos y detección de errores, Excel carece de estas salvaguardias.\\nEstas imprecisiones pueden tener consecuencias significativas, lo que lleva a decisiones comerciales erróneas, oportunidades de seguimiento perdidas y, en última instancia, un proceso de nutrición de leads menos eficaz.\\nLa dependencia de los procesos manuales aumenta el riesgo de inconsistencias y errores, lo que dificulta el mantenimiento de una visión fiable y precisa de los datos de los leads.\\n","section":"Las Desventajas de Usar Excel para la Nutrición y el Seguimiento de Leads","version":"current","path":"/es/blog/las-desventajas-de-usar-excel-para-la-nutricion-y-el-seguimiento-de-leads#51-propenso-a-errores-humanos","category":"blogs"},{"title":"5.2. Falta de Datos en Tiempo Real","content":"Las hojas de cálculo de Excel normalmente no ofrecen actualizaciones de datos en tiempo real, lo que puede ser una limitación significativa en el entorno dinámico de las ventas.\\nLa información contenida en una hoja de Excel es estática y solo refleja los datos en el momento del último guardado. En ciclos de ventas rápidos donde el estado y la participación de los leads pueden cambiar rápidamente, esta falta de visibilidad en tiempo real puede llevar a que se utilice información desactualizada para las decisiones críticas de seguimiento.\\nLos equipos de ventas podrían no estar al tanto de la actividad reciente de los leads o de los cambios en sus necesidades, lo que resultaría en comunicaciones inoportunas o irrelevantes.\\nEste retraso en los datos puede dificultar la capacidad de proporcionar una nutrición oportuna y eficaz, lo que podría llevar a la pérdida de oportunidades a medida que los competidores con información más actualizada obtienen una ventaja.\\n","section":"Las Desventajas de Usar Excel para la Nutrición y el Seguimiento de Leads","version":"current","path":"/es/blog/las-desventajas-de-usar-excel-para-la-nutricion-y-el-seguimiento-de-leads#52-falta-de-datos-en-tiempo-real","category":"blogs"},{"title":"5.3. Colaboración Ineficiente","content":"Excel NO está diseñado para ser una herramienta de colaboración de la misma manera que los sistemas CRM modernos.\\nCuando varios miembros del equipo necesitan acceder y actualizar la misma información de leads simultáneamente, Excel puede volverse ineficiente y propenso a conflictos.\\nPueden surgir problemas como problemas de control de versiones, sobrescrituras accidentales de datos y dificultades para rastrear quién realizó qué cambios, lo que lleva a confusión y posible pérdida de datos.\\nEsta falta de colaboración fluida en tiempo real puede obstaculizar la productividad de los equipos de ventas y marketing, lo que dificulta el mantenimiento de un enfoque unificado y coherente para los esfuerzos de nutrición y seguimiento de leads.\\n","section":"Las Desventajas de Usar Excel para la Nutrición y el Seguimiento de Leads","version":"current","path":"/es/blog/las-desventajas-de-usar-excel-para-la-nutricion-y-el-seguimiento-de-leads#53-colaboración-ineficiente","category":"blogs"},{"title":"5.4. Funciones Limitadas de Gestión de Leads","content":"Excel carece de las funciones y funcionalidades especializadas que son esenciales para una gestión eficaz de leads, especialmente a gran escala.\\nA diferencia de los sistemas CRM que están diseñados específicamente para gestionar todo el ciclo de vida de los leads, el marco básico de Excel no admite inherentemente procesos cruciales como los seguimientos automatizados basados en el comportamiento de los leads, la puntuación sistemática de leads para priorizar los prospectos o la integración perfecta con las plataformas de automatización de marketing.\\nEstas limitaciones pueden resultar en la pérdida de oportunidades a medida que los equipos de ventas luchan por nutrir los leads de manera eficiente e identificar a aquellos que están más listos para convertirse.\\nLa ausencia de herramientas dedicadas a la gestión de leads dificulta la implementación de estrategias de nutrición sofisticadas y el seguimiento de su eficacia.\\n","section":"Las Desventajas de Usar Excel para la Nutrición y el Seguimiento de Leads","version":"current","path":"/es/blog/las-desventajas-de-usar-excel-para-la-nutricion-y-el-seguimiento-de-leads#54-funciones-limitadas-de-gestión-de-leads","category":"blogs"},{"title":"5.5. Informes y Análisis Inadecuados","content":"Si bien Excel ofrece algunas capacidades básicas para el análisis de datos y la creación de gráficos, sus funcionalidades de informes y análisis son considerablemente menos robustas y fáciles de usar en comparación con las que se encuentran en los sistemas CRM dedicados.\\nGenerar informes significativos y reveladores sobre el rendimiento de la nutrición y el seguimiento de leads en Excel a menudo requiere un esfuerzo manual significativo, incluyendo la creación de fórmulas complejas y la manipulación de grandes conjuntos de datos.\\nEsto puede llevar mucho tiempo y puede no proporcionar el mismo nivel de detalle o automatización que los informes predefinidos y personalizables disponibles en las plataformas CRM.\\nLa falta de análisis avanzado dificulta que las empresas que utilizan Excel obtengan una comprensión profunda de la eficacia de su gestión de leads, identifiquen tendencias y tomen decisiones basadas en datos para optimizar sus estrategias.\\n","section":"Las Desventajas de Usar Excel para la Nutrición y el Seguimiento de Leads","version":"current","path":"/es/blog/las-desventajas-de-usar-excel-para-la-nutricion-y-el-seguimiento-de-leads#55-informes-y-análisis-inadecuados","category":"blogs"},{"title":"5.6. Problemas de Seguridad","content":"El uso de Excel para almacenar y gestionar datos confidenciales de clientes y leads puede plantear importantes problemas de seguridad.\\nLos archivos de Excel suelen carecer del cifrado de datos robusto y de los mecanismos sofisticados de control de acceso que se encuentran en los sistemas CRM.\\nEsto los hace más vulnerables a las violaciones de seguridad, al acceso no autorizado y a la exposición accidental de datos, especialmente si los archivos se comparten por correo electrónico o soluciones de almacenamiento en la nube menos seguras.\\nPara las empresas que manejan información confidencial de los clientes, depender únicamente de Excel para la nutrición y el seguimiento de leads puede representar un riesgo considerable para la privacidad y la seguridad de los datos, lo que podría generar problemas de cumplimiento y daños a la reputación.\\n","section":"Las Desventajas de Usar Excel para la Nutrición y el Seguimiento de Leads","version":"current","path":"/es/blog/las-desventajas-de-usar-excel-para-la-nutricion-y-el-seguimiento-de-leads#56-problemas-de-seguridad","category":"blogs"},{"title":"5.7. Falta de Automatización","content":"Una limitación importante de Excel en el contexto de la nutrición y el seguimiento de leads es la ausencia general de funciones de automatización integradas.\\nTareas como el envío de correos electrónicos de seguimiento automatizados, la programación de recordatorios para las actividades de ventas y la actualización de los estados de los leads suelen requerir la intervención manual en Excel.\\nEsta falta de automatización puede llevar mucho tiempo y ser ineficiente, especialmente cuando se trata de un gran volumen de leads. Sin flujos de trabajo automatizados, los equipos de ventas y marketing deben gestionar manualmente cada paso del proceso de nutrición y seguimiento, lo que aumenta el riesgo de que se pasen por alto o se retrasen las tareas. Esto puede obstaculizar significativamente la productividad y reducir la eficacia general de los esfuerzos de gestión de leads.\\n","section":"Las Desventajas de Usar Excel para la Nutrición y el Seguimiento de Leads","version":"current","path":"/es/blog/las-desventajas-de-usar-excel-para-la-nutricion-y-el-seguimiento-de-leads#57-falta-de-automatización","category":"blogs"},{"title":"5.8. Limitaciones de Escalabilidad","content":"A medida que las empresas crecen y aumenta el número de leads que necesitan gestionar, Excel a menudo demuestra ser una solución con una escalabilidad limitada.\\nEl manejo de grandes conjuntos de datos en Excel puede generar problemas de rendimiento, como tiempos de carga lentos y un mayor riesgo de bloqueos o corrupción de datos.\\nLa gestión de extensas listas de leads, el seguimiento de sus interacciones y la generación de informes pueden volverse cada vez más engorrosos e ineficientes a medida que crece el volumen de datos.\\nEsta falta de escalabilidad hace que Excel sea una solución a largo plazo menos viable para las empresas que anticipan un crecimiento en su base de clientes y en sus esfuerzos de generación de leads.\\nLos sistemas CRM, por otro lado, están diseñados específicamente para manejar grandes volúmenes de datos y escalar con las necesidades cambiantes de la empresa.\\nTe recomendamos leer:\\nCRM vs Excel, Un Análisis Comparativo para la Nutrición y el Seguimiento de Leads en Ventas\\nLas Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads\\nComparación de la Eficacia y la Eficiencia de CRM Versus Excel\\nLas Desventajas de Usar Excel para la Nutrición y el Seguimiento de Leads\\nIndicadores Clave de Rendimiento (KPI) para Medir el Éxito\\n","section":"Las Desventajas de Usar Excel para la Nutrición y el Seguimiento de Leads","version":"current","path":"/es/blog/las-desventajas-de-usar-excel-para-la-nutricion-y-el-seguimiento-de-leads#58-limitaciones-de-escalabilidad","category":"blogs"},{"title":"4.1. Gestión Centralizada de Datos","content":"Uno de los beneficios más significativos de emplear un sistema CRM para la nutrición y el seguimiento de leads es su capacidad para consolidar toda la información pertinente de leads y clientes en una única base de datos de fácil acceso.\\n<!-- truncate -->\\nEste repositorio centralizado actúa como una única fuente de verdad, proporcionando una visión integral de cada interacción, preferencia e historial de compras asociado con cada lead.\\nAl eliminar los silos de datos fragmentados que a menudo existen en diferentes departamentos u hojas de cálculo, un sistema CRM garantiza que tanto los equipos de ventas como los de marketing tengan acceso inmediato a la información más actualizada.\\nEsta perspectiva holística permite a los equipos interactuar con los leads de una manera más informada y personalizada, fomentando relaciones más sólidas y mejorando la eficacia de los esfuerzos de nutrición y seguimiento.\\nLa capacidad de recuperar rápidamente el historial y las preferencias de un lead permite una comunicación adaptada que resuena con sus necesidades específicas y su etapa en el proceso de compra.\\n","section":"Las Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads","version":"current","path":"/es/blog/las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads#41-gestión-centralizada-de-datos","category":"blogs"},{"title":"4.2. Automatización de Tareas","content":"Los sistemas CRM ofrecen sólidas capacidades de automatización que agilizan significativamente los procesos de nutrición y seguimiento de leads.\\nEstas plataformas pueden automatizar una amplia gama de tareas, incluyendo el envío de correos electrónicos de seguimiento personalizados basados en activadores o programaciones predefinidas, el establecimiento de recordatorios para que los representantes de ventas realicen un contacto oportuno y la actualización automática de los estados de los leads a medida que avanzan por el embudo de ventas.\\nEsta automatización no solo ahorra tiempo valioso a los equipos de ventas y marketing, sino que también minimiza el riesgo de error humano y garantiza un compromiso constante con los leads en los puntos de contacto cruciales.\\nAdemás, muchos sistemas CRM pueden automatizar la captura inicial de leads de diversas fuentes, como formularios de sitios web, consultas por correo electrónico e interacciones en redes sociales, asegurando que no se pase por alto ninguna oportunidad potencial.\\nAl automatizar estas tareas administrativas rutinarias, los sistemas CRM permiten a los profesionales de ventas y marketing dedicar más tiempo y recursos a actividades estratégicas como la construcción de relaciones y el cierre de acuerdos.\\n","section":"Las Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads","version":"current","path":"/es/blog/las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads#42-automatización-de-tareas","category":"blogs"},{"title":"4.3. Mejora de la Calificación y Puntuación de Leads","content":"Muchos sistemas CRM incorporan sofisticadas funciones de puntuación de leads que permiten a las empresas identificar y priorizar los leads más prometedores en función de una variedad de criterios predefinidos.\\nEstos criterios pueden incluir la interacción de un lead con materiales de marketing (como visitas al sitio web, descargas de contenido y clics en correos electrónicos), información demográfica y necesidades o intereses expresados.\\nEl sistema CRM asigna automáticamente una puntuación a cada lead en función de estos factores, proporcionando a los equipos de ventas una indicación clara de qué prospectos tienen más probabilidades de convertirse.\\nEste enfoque basado en datos permite a los representantes de ventas centrar sus esfuerzos en los leads con una mayor probabilidad de éxito, optimizando así su tiempo y recursos.\\nAdemás, los sistemas CRM pueden rastrear el comportamiento y las interacciones de un lead a lo largo del tiempo, ofreciendo información valiosa sobre su nivel de interés y su disposición a tomar una decisión de compra.\\n","section":"Las Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads","version":"current","path":"/es/blog/las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads#43-mejora-de-la-calificación-y-puntuación-de-leads","category":"blogs"},{"title":"4.4. Personalización y Comunicación Mejoradas","content":"Las plataformas CRM permiten a las empresas personalizar su comunicación con los leads a un nivel granular.\\nAl permitir la segmentación de leads en función de diversos atributos, como la demografía, la industria, los intereses específicos o la etapa en el recorrido del comprador, los sistemas CRM permiten a los equipos de ventas y marketing adaptar sus mensajes y contenido para que resuenen con las necesidades únicas de diferentes segmentos de leads.\\nEste enfoque personalizado, que puede incluir dirigirse a los leads por su nombre y hacer referencia a sus intereses específicos o interacciones pasadas, mejora significativamente el compromiso y ayuda a construir una relación más sólida.\\nAdemás, los sistemas CRM mantienen un registro completo de todo el historial de comunicación con cada lead, proporcionando un contexto valioso para cada interacción y asegurando que los representantes de ventas tengan una comprensión completa de la progresión de la relación.\\n","section":"Las Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads","version":"current","path":"/es/blog/las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads#44-personalización-y-comunicación-mejoradas","category":"blogs"},{"title":"4.5. Mejora de la Colaboración Entre los Equipos de Ventas y Marketing","content":"Los sistemas CRM sirven como una herramienta central que facilita la comunicación y la colaboración fluidas entre los equipos de ventas y marketing.\\nAl proporcionar a ambos equipos una visión compartida de todos los datos, actividades y progreso de los leads, las plataformas CRM garantizan la alineación en los procesos de gestión de leads y facilitan una transición más fluida de los leads calificados del marketing a las ventas.Esta visibilidad compartida elimina posibles malentendidos y garantiza que ambos equipos trabajen hacia objetivos comunes en la nutrición y conversión de leads.\\nLos equipos de marketing pueden aprovechar los datos del CRM para comprender mejor qué campañas están generando los leads más calificados, mientras que los equipos de ventas pueden proporcionar comentarios sobre la calidad de los leads recibidos, lo que permite una optimización continua de la estrategia general de gestión de leads. Esta colaboración mejorada fomenta un enfoque más unificado y eficaz para interactuar con los clientes potenciales.\\n","section":"Las Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads","version":"current","path":"/es/blog/las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads#45-mejora-de-la-colaboración-entre-los-equipos-de-ventas-y-marketing","category":"blogs"},{"title":"4.6. Escalabilidad","content":"Los sistemas CRM están intrínsecamente diseñados para escalar junto con el crecimiento de una empresa, capaces de adaptarse a volúmenes crecientes de leads, datos de clientes y actividad de usuarios.\\nA medida que una empresa se expande y sus procesos de ventas se vuelven más intrincados, las plataformas CRM pueden adaptarse para manejar una mayor complejidad y dar soporte a equipos más grandes.\\nEsta escalabilidad garantiza que los procesos de nutrición y seguimiento de leads sigan siendo eficientes y eficaces incluso a medida que la empresa evoluciona.\\nA diferencia de las soluciones basadas en hojas de cálculo, que pueden volverse engorrosas y propensas a errores al tratar con grandes conjuntos de datos, los sistemas CRM están construidos con arquitecturas robustas que pueden gestionar un crecimiento significativo en el volumen y la complejidad de los leads sin comprometer el rendimiento.\\nEsto convierte al CRM en una solución sostenible y preparada para el futuro para las empresas con aspiraciones de expansión.\\n","section":"Las Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads","version":"current","path":"/es/blog/las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads#46-escalabilidad","category":"blogs"},{"title":"4.7. Informes y Análisis","content":"Los sistemas CRM ofrecen potentes funcionalidades de informes y análisis que proporcionan información invaluable sobre la eficacia de las estrategias de nutrición y seguimiento de leads.\\nLas empresas pueden aprovechar estas capacidades para rastrear indicadores clave de rendimiento (KPI) como las tasas de conversión de leads, los niveles de participación con las campañas de nutrición, la duración promedio del ciclo de ventas y la eficacia de diferentes fuentes de leads.\\nMuchas plataformas CRM ofrecen paneles de control personalizables que proporcionan una representación visual de estas métricas, lo que permite a las partes interesadas obtener una visión general rápida y completa del rendimiento.\\nEstas funciones de informes y análisis permiten la toma de decisiones basada en datos, lo que permite a las empresas identificar qué estrategias están funcionando eficazmente y dónde se pueden realizar mejoras para optimizar sus procesos de nutrición y seguimiento de leads.\\n","section":"Las Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads","version":"current","path":"/es/blog/las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads#47-informes-y-análisis","category":"blogs"},{"title":"4.8. Integración con Otras Herramientas","content":"Una ventaja significativa de los sistemas CRM es su capacidad para integrarse sin problemas con una amplia gama de otras herramientas y plataformas empresariales.\\nEsto puede incluir la integración con plataformas de marketing por correo electrónico para ejecutar y rastrear campañas de nutrición, software de automatización de marketing para flujos de trabajo de gestión de leads más sofisticados, plataformas de participación de ventas para mejorar las actividades de seguimiento e incluso sistemas de atención al cliente para garantizar una experiencia de cliente unificada.\\nEstas integraciones crean un ecosistema más conectado y eficiente, lo que permite un flujo fluido de datos y acciones entre diferentes funciones empresariales. Por ejemplo, los leads capturados a través de los esfuerzos de marketing pueden ingresarse automáticamente en el CRM, y sus interacciones posteriores pueden activar secuencias de seguimiento automatizadas gestionadas dentro de la plataforma de participación de ventas.\\nEsta interconexión mejora la eficacia general de los esfuerzos de nutrición y seguimiento de leads al proporcionar una visión holística del recorrido del cliente y agilizar los flujos de trabajo.\\n","section":"Las Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads","version":"current","path":"/es/blog/las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads#48-integración-con-otras-herramientas","category":"blogs"},{"title":"4.9. Mejora de la Experiencia del Cliente","content":"Al facilitar la comunicación personalizada y oportuna, y al proporcionar una comprensión integral del recorrido de cada lead, los sistemas CRM contribuyen en última instancia a una experiencia del cliente mejorada.\\nCuando las empresas pueden rastrear y gestionar eficazmente sus interacciones con clientes potenciales, están mejor equipadas para anticipar sus necesidades, proporcionar información relevante y ofrecer soluciones personalizadas.\\nEste nivel de atención y personalización hace que los leads se sientan valorados y comprendidos, fomentando relaciones más sólidas y aumentando la probabilidad de conversión.\\nUna experiencia positiva y atractiva a lo largo del proceso de nutrición y seguimiento de leads puede mejorar significativamente la satisfacción del cliente y generar lealtad a largo plazo, lo que en última instancia beneficia a la empresa a través de mayores ventas y referencias positivas de boca en boca.\\nTe recomendamos leer:\\nCRM vs Excel, Un Análisis Comparativo para la Nutrición y el Seguimiento de Leads en Ventas\\nLas Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads\\nComparación de la Eficacia y la Eficiencia de CRM Versus Excel\\nLas Desventajas de Usar Excel para la Nutrición y el Seguimiento de Leads\\nIndicadores Clave de Rendimiento (KPI) para Medir el Éxito\\n","section":"Las Ventajas de Usar un Sistema CRM para la Nutrición y el Seguimiento de Leads","version":"current","path":"/es/blog/las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads#49-mejora-de-la-experiencia-del-cliente","category":"blogs"},{"title":"VIII. Estudios de Caso del Mundo Real: Historias de Éxito en la Optimización de la Tasa de Conversión.","content":"Numerosas empresas han implementado con éxito estrategias para mejorar las tasas de conversión en sus embudos de marketing y ventas, proporcionando valiosas lecciones para otros.\\nEn la etapa de Conciencia, Tom\'s Planner, una empresa de software de gestión de proyectos en línea, aumentó las inscripciones en un 44% simplemente agregando un formulario de inscripción directamente en su página de inicio junto a la imagen del producto, minimizando los pasos requeridos para que los usuarios creen una cuenta.\\nGoing, una empresa de ofertas de viajes, mejoró su tasa de inicio de prueba en un 104% mes a mes al optimizar su página de destino mediante pruebas A/B y centrarse en propuestas de valor claras.\\nPara la etapa de Consideración, Archive Social aumentó su tasa de clics en un 68% al probar y mejorar la visibilidad de la llamada a la acción principal en su página de inicio.\\nBear Mattress aprovechó estratégicamente las oportunidades de venta cruzada en las páginas de detalles de sus productos de colchones al incorporar imágenes en miniatura, texto centrado en el visitante y ofertas rediseñadas, lo que resultó en un aumento del 16% en los ingresos.\\nEn las etapas de Decisión/Conversión, Walmart Canadá logró un aumento del 20% en las conversiones generales en todos los dispositivos y un aumento del 98% en los pedidos móviles al simplificar la experiencia del usuario de su sitio web y eliminar elementos innecesarios.\\nFlos USA abordó las bajas tasas de conversión de pago realizando análisis de comportamiento exhaustivos e implementando cambios específicos en sus páginas de productos, como actualizar la opción \\"Elegir acabado\\" con muestras de color, lo que llevó a un notable aumento del 125% en las tasas de pago.\\nEn términos de Defensa, PUMA desarrolló una estrategia de defensa del cliente que resultó en un ROI de 6 veces al promover programas de referencia en puntos de contacto clave y adaptar los mensajes a diferentes audiencias a través de pruebas A/B.\\nEstos estudios de caso subrayan la importancia de comprender el comportamiento del usuario, probar diferentes enfoques y centrarse en proporcionar valor y una experiencia fluida en cada etapa del embudo.\\nDemuestran que incluso los cambios aparentemente pequeños, cuando se basan en datos y conocimientos del cliente, pueden conducir a mejoras significativas en las tasas de conversión y el éxito empresarial general.\\n","section":"Alineando Marketing y Ventas para una Conversión Óptima","version":"current","path":"/es/blog/alineando-marketing-y-ventas-para-una-conversion-optima#viii-estudios-de-caso-del-mundo-real-historias-de-éxito-en-la-optimización-de-la-tasa-de-conversión","category":"blogs"},{"title":"IX. Tendencias Futuras en la Conversión del Embudo de Marketing y Ventas (2024-2025).","content":"El panorama de la conversión del embudo de marketing y ventas está en constante evolución, impulsado por los avances tecnológicos y los cambios en los comportamientos del consumidor. Varias tendencias clave están preparadas para dar forma a las estrategias de optimización en 2024 y 2025.\\nLa inteligencia artificial (IA) y el análisis predictivo están impulsando cada vez más los esfuerzos de personalización, permitiendo a las empresas crear experiencias hiper-personalizadas basadas en el comportamiento y la intención del usuario.\\nCon la evolución de las regulaciones de privacidad de datos, se está poniendo un mayor énfasis en las estrategias, donde las empresas recopilan datos directamente de los consumidores para impulsar sus esfuerzos de marketing. El contenido interactivo y “comprable” está ganando terreno en cada etapa del embudo, ofreciendo experiencias inmersivas y permitiendo compras directas.\\nLa automatización de correo electrónico y SMS impulsada por IA se está volviendo más sofisticada, permitiendo mensajes altamente dirigidos y personalizados basados en el comportamiento del usuario en tiempo real.\\nEl auge de la búsqueda por voz y el SEO impulsado por IA está remodelando la forma en que los consumidores descubren la información, lo que requiere la optimización para estos nuevos canales.\\nReconociendo que la retención es la nueva adquisición, las marcas se están centrando cada vez más en estrategias de marketing de fidelización y retención para aumentar el valor de vida del cliente.\\nLas tecnologías de IA generativa se están adoptando para diversos aspectos de la CRO, incluyendo la síntesis de registros de pruebas, el resaltado de hallazgos clave e incluso la sugerencia de pasos futuros.\\nAprovechar la prueba social a través de contenido generado por el usuario, reseñas y testimonios sigue siendo una tendencia poderosa para generar confianza e impulsar las conversiones.\\nGarantizar la limpieza e integridad de los datos se está volviendo cada vez más importante para un análisis preciso y una optimización efectiva.\\nLas empresas están profundizando en la investigación del comportamiento de los visitantes para obtener una comprensión más profunda de las motivaciones y los puntos débiles del usuario.\\nLa optimización para experiencias multicanal será crucial a medida que los consumidores interactúen con las marcas a través de diversos puntos de contacto.\\nLas empresas están explorando los beneficios de diversificar los canales de medios pagados y centrarse en la optimización del proceso de clientes potenciales a ventas mediante el seguimiento de métricas del embudo más profundas.\\nPara aprovechar estas tendencias emergentes, las empresas deben invertir en herramientas de automatización de marketing impulsadas por IA para personalizar los puntos de contacto en todo el embudo y priorizar la recopilación de datos de primera parte a través de experiencias interactivas.\\nLa optimización del contenido para motores de búsqueda impulsados por IA y la incorporación de contenido de video y comprable mejorarán la participación y la conversión.\\nCentrarse en tácticas de marketing de retención y monitorear y adaptarse continuamente al panorama digital en evolución será crucial para el éxito sostenido.\\n","section":"Alineando Marketing y Ventas para una Conversión Óptima","version":"current","path":"/es/blog/alineando-marketing-y-ventas-para-una-conversion-optima#ix-tendencias-futuras-en-la-conversión-del-embudo-de-marketing-y-ventas-2024-2025","category":"blogs"},{"title":"X. Conclusión: Perspectivas Clave y una Hoja de Ruta para la Mejora Continua de la Conversión.","content":"Mejorar las tasas de conversión en todo el embudo de marketing y ventas es un proceso continuo que requiere un enfoque holístico, basado en datos y centrado en el cliente.\\nAl comprender los matices de cada etapa del embudo, realizar un seguimiento diligente de los indicadores clave de rendimiento e implementar estrategias dirigidas para la optimización, las empresas pueden mejorar significativamente su capacidad para convertir prospectos en clientes leales y defensores de la marca.\\nLa identificación y eliminación de cuellos de botella, junto con una priorización estratégica de los esfuerzos de optimización, garantiza que los recursos se centren en las áreas que producirán el mayor impacto.\\nEl poder de un enfoque integrado, que alinea los equipos de marketing y ventas, fomenta un recorrido del cliente fluido y consistente que genera confianza e impulsa las conversiones. Los estudios de caso del mundo real destacados en este informe demuestran resultados tangibles que se pueden lograr a través de una optimización efectiva de la tasa de conversión.\\nDe cara al futuro, mantenerse informado y adaptarse a las tendencias futuras en tecnología y comportamiento del consumidor será esencial para mantener una ventaja competitiva. La hoja de ruta para la mejora continua de la conversión implica un compromiso con el monitoreo continuo, las pruebas rigurosas y la voluntad de refinar las estrategias basadas en datos y comentarios de los clientes.\\nEn última instancia, al colocar al cliente en el centro de todos los esfuerzos y esforzarse por satisfacer sus necesidades en cada etapa del embudo, las empresas pueden desbloquear un crecimiento sostenible y construir relaciones duraderas.\\nTe recomendamos leer:\\nMejora de las Tasas de Conversión a Través del Embudo de Marketing y Ventas\\nEstrategias Accionables para Mejorar las Tasas de Conversión en Cada Etapa del Embudo\\nAlineando Marketing y Ventas para una Conversión Óptima\\n","section":"Alineando Marketing y Ventas para una Conversión Óptima","version":"current","path":"/es/blog/alineando-marketing-y-ventas-para-una-conversion-optima#x-conclusión-perspectivas-clave-y-una-hoja-de-ruta-para-la-mejora-continua-de-la-conversión","category":"blogs"},{"title":"V. Identificación y Eliminación de Cuellos de Botella y Puntos Débiles en su Embudo de Conversión.","content":"La identificación y el tratamiento de los cuellos de botella y los puntos débiles dentro del embudo de conversión es crucial para maximizar la eficacia de las ventas y lograr un crecimiento óptimo.\\nUn cuello de botella se produce cuando los clientes potenciales se \\"atascan\\" en una etapa particular y no avanzan más, lo que indica un problema que debe resolverse. Se pueden emplear varios métodos para identificar estas áreas de fricción.\\nUno de los enfoques más eficaces es analizar las tasas de conversión en cada etapa del embudo. Al monitorear el porcentaje de leads que pasan con éxito de una etapa a la siguiente, puede identificar dónde se producen las caídas significativas. Por ejemplo, un gran número de leads que entran en la etapa de conciencia pero una baja tasa de conversión a la etapa de interés podría sugerir problemas con el mensaje inicial o la segmentación. Del mismo modo, una gran caída entre las etapas de consideración y decisión podría indicar que los prospectos no están encontrando la información o la tranquilidad que necesitan para finalizar una compra.\\nRevisar la calidad de los leads en cada nivel es otro paso importante. Los leads de baja calidad tienen menos probabilidades de convertirse y pueden obstruir el embudo, creando un cuello de botella. Al evaluar las características y el compromiso de los leads en diferentes etapas, puede identificar si existen problemas con sus procesos de generación, segmentación o calificación de leads. Las herramientas de análisis de ventas, como Fintesk, pueden proporcionar datos e información valiosos sobre el rendimiento del embudo, incluidas las tasas de conversión, la velocidad de los acuerdos o negocios y la atribución de ingresos, lo que ayuda a identificar dónde se atascan los leads.\\nInteractuar directamente con los clientes a través de encuestas y análisis de comentarios también puede revelar cuellos de botella. Los comentarios de los clientes pueden resaltar los puntos débiles, los obstáculos y las razones por las que los prospectos podrían no estar avanzando más en el embudo. Abordar estos problemas puede mejorar significativamente la satisfacción del cliente y eliminar los cuellos de botella.\\nAdemás, evaluar la eficacia de sus procesos de nutrición y seguimiento de leads es esencial. Si los leads se estancan en una determinada etapa, podría indicar la necesidad de mejorar la frecuencia, la calidad y la personalización de su comunicación. Asegurar un seguimiento rápido y relevante es crucial para mantener a los leads comprometidos.\\nAgilizar la alineación de ventas y marketing es vital para un flujo fluido de leads a través del embudo. La falta de alineación entre estos equipos puede generar una comunicación deficiente, prioridades contradictorias y, en última instancia, cuellos de botella.\\nUna mejor cooperación, objetivos compartidos y un circuito de retroalimentación constante entre ventas y marketing pueden optimizar todo el proceso de ventas. Las herramientas de análisis de sitios web (como el gratuito google analytics) se pueden utilizar para rastrear el comportamiento del usuario e identificar puntos específicos donde los usuarios abandonan el embudo.\\nEl análisis de métricas como la tasa de rebote, el tiempo en la página y las páginas de salida puede proporcionar pistas sobre posibles problemas de usabilidad o lagunas de contenido.\\nLos mapas de calor y las repeticiones de sesión (como hotjar) ofrecen información cualitativa sobre cómo los usuarios interactúan con su sitio web, revelando áreas de frustración, confusión o distracción que podrían estar obstaculizando la conversión.\\nEl monitoreo del tiempo dedicado por los clientes en cada etapa también puede indicar posibles cuellos de botella. Un tiempo inusualmente largo dedicado a una etapa en particular podría sugerir que los usuarios tienen dificultades para encontrar la información que necesitan o que enfrentan dificultades para continuar.\\nOtros signos de puntos débiles en el embudo de ventas incluyen ciclos de ventas largos sin progreso visible, bajas tasas de conversión de lead a cliente y un alto volumen de leads de baja calidad.\\nEl análisis de los informes del embudo de ventas puede proporcionar una visión general completa de estas métricas, destacando las etapas con bajas tasas de conversión o un alto estancamiento de leads.\\nLa implementación de un sistema de puntuación de leads CRM puede ayudar a priorizar los leads prometedores y garantizar que los esfuerzos de ventas se centren en las conversiones más probables.\\nLa revisión periódica del embudo de ventas para una posible optimización y la garantía de que los clientes comprendan completamente la propuesta de valor de su oferta también son pasos cruciales para identificar y eliminar los cuellos de botella.\\nFinalmente, es esencial validar sus fuentes de datos y realizar investigaciones exhaustivas de la causa raíz cuando se observan cambios o caídas significativas en el rendimiento del embudo.\\n","section":"Estrategias Accionables para Mejorar las Tasas de Conversión en Cada Etapa del Embudo","version":"current","path":"/es/blog/estrategias-para-mejorar-las-tasas-de-conversion-en-cada-etapa-del-embudo#v-identificación-y-eliminación-de-cuellos-de-botella-y-puntos-débiles-en-su-embudo-de-conversión","category":"blogs"},{"title":"VI. Priorización de los Esfuerzos de Optimización de la Conversión para un Máximo Impacto.","content":"Con tiempo y recursos limitados, es esencial priorizar los esfuerzos de optimización de la conversión para garantizar el mayor retorno. Varios marcos de priorización pueden ayudar a las empresas a tomar decisiones informadas sobre dónde enfocar sus esfuerzos de optimización.\\nEl marco ICE (Impacto, Confianza, Facilidad) implica calificar cada idea de optimización en función de su impacto estimado, su confianza en lograr ese impacto y la facilidad de implementación. La multiplicación de estas puntuaciones proporciona una puntuación ICE general, lo que permite la comparación y la priorización.\\nDel mismo modo, el marco PIE (Potencial, Importancia, Facilidad) clasifica las pruebas en función del potencial de mejora, la importancia de la página o el tráfico y la facilidad de implementación.\\nEl marco RICE (Alcance, Impacto, Confianza, Esfuerzo) amplía esto al considerar también el alcance de la mejora potencial, proporcionando una evaluación más completa.\\nLa Matriz de Impacto vs. Esfuerzo ofrece un enfoque visual para la priorización, trazando las tareas en función de su impacto potencial y el esfuerzo requerido para su finalización.\\nEste marco ayuda a identificar \\"victorias rápidas\\" (alto impacto, bajo esfuerzo), \\"grandes apuestas\\" (alto impacto, alto esfuerzo), \\"rellenos\\" (bajo impacto, bajo esfuerzo) y \\"sumideros de dinero\\" (bajo impacto, alto esfuerzo).\\nIndependientemente del marco elegido (existen varios para clasificar las oportunidades de mejora), es crucial priorizar los esfuerzos en función del impacto potencial en las tasas de conversión, la facilidad de implementación de los cambios y la alineación con los objetivos comerciales generales.\\nA menudo se recomienda comenzar con las \\"oportunidades fáciles\\" que pueden generar resultados rápidos con un mínimo esfuerzo para generar impulso y demostrar el valor de la optimización de la tasa de conversión.\\nLa selección del marco más apropiado dependerá del contexto específico, los datos disponibles y los objetivos del programa de optimización. Una combinación de análisis de datos cuantitativos e información cualitativa del cliente debe guiar este proceso de priorización.\\nTe recomendamos leer:\\nMejora de las Tasas de Conversión a Través del Embudo de Marketing y Ventas\\nEstrategias Accionables para Mejorar las Tasas de Conversión en Cada Etapa del Embudo\\nAlineando Marketing y Ventas para una Conversión Óptima\\n","section":"Estrategias Accionables para Mejorar las Tasas de Conversión en Cada Etapa del Embudo","version":"current","path":"/es/blog/estrategias-para-mejorar-las-tasas-de-conversion-en-cada-etapa-del-embudo#vi-priorización-de-los-esfuerzos-de-optimización-de-la-conversión-para-un-máximo-impacto","category":"blogs"},{"title":"Entendiendo el Viaje del Cliente.","content":"El embudo de marketing y ventas, ilustra el camino teórico que sigue un cliente desde su primera interacción con una marca hasta la etapa final de lealtad y defensa.\\nComprender este viaje es fundamental para optimizar las tasas de conversión en cada punto de contacto.\\nEl embudo típicamente comienza con la etapa de Conciencia. Aquí, el objetivo principal es hacer que los clientes potenciales conozcan una marca, sus productos o sus servicios. Esta exposición inicial puede ocurrir a través de varios canales, como redes sociales, marketing de contenidos o publicidad.\\nA medida que los prospectos se vuelven conscientes de una marca, ingresan a las etapas de Interés y Consideración. Durante esta fase, los consumidores buscan activamente información sobre la marca y sus ofertas, evaluando si estas podrían satisfacer sus necesidades o resolver sus problemas.\\nComparan diferentes opciones y comienzan a formarse una opinión sobre el valor potencial de una solución en particular.\\nMuy relacionada está la etapa de Deseo o Evaluación, donde el cliente ha identificado una necesidad y está considerando soluciones específicas, potencialmente con un presupuesto en mente. Están yendo más allá del interés general y comenzando a imaginarse a sí mismos usando el producto o servicio.\\nLa etapa de Intención, a veces considerada una fase separada o un puente entre la consideración y la acción, significa que el prospecto está mostrando un claro deseo de adquirir la oferta.\\nEl punto crucial de la transacción ocurre en la etapa de Conversión, Decisión o Acción. Aquí es donde el prospecto toma la decisión final de comprar el producto o servicio, convirtiéndose en cliente. Sin embargo, el viaje no termina aquí.\\nLa experiencia posterior a la compra es fundamental para fomentar la Lealtad y la Retención. El enfoque cambia a la construcción de relaciones a largo plazo, asegurando la satisfacción del cliente y fomentando las compras repetidas.\\nLa etapa final, Defensa, se alcanza cuando los clientes satisfechos y leales se convierten en promotores del negocio, recomendándolo a otros.\\nEs importante reconocer que si bien este modelo proporciona un marco general, el número específico y la definición de las etapas pueden variar según el negocio en particular y su proceso de ventas.\\nComprender la mentalidad y las necesidades de los clientes en cada una de estas etapas es esencial para desarrollar estrategias específicas para mejorar las tasas de conversión.\\nLa visión lineal tradicional del embudo se complementa cada vez más con una comprensión más dinámica del viaje del cliente, donde las personas pueden interactuar a través de múltiples canales y potencialmente revisar o incluso omitir ciertas etapas.\\n","section":"Mejora de las Tasas de Conversión a Través del Embudo de Marketing y Ventas","version":"current","path":"/es/blog/mejora-de-las-tasas-de-conversion-a-traves-del-embudo-de-marketing-y-ventas#entendiendo-el-viaje-del-cliente","category":"blogs"},{"title":"Indicadores Clave de Rendimiento (KPIs) para Medir la Conversión en las Etapas del Embudo.","content":"Para optimizar eficazmente el embudo de marketing y ventas, es crucial realizar un seguimiento de los indicadores clave de rendimiento (KPI) en cada etapa.\\nEstas métricas proporcionan información valiosa sobre el rendimiento del embudo, lo que permite a las empresas identificar áreas de fortaleza y debilidad y medir el impacto de los esfuerzos de optimización.\\nEn la etapa de Conciencia, las métricas clave incluyen el tráfico del sitio web, que indica el número de clientes potenciales que visitan sus plataformas en línea, y la participación en redes sociales, que refleja cómo los usuarios interactúan con su marca en los canales de redes sociales. Las menciones de marca rastrean con qué frecuencia se discute su marca en línea, mientras que el alcance y las impresiones miden el alcance de la visibilidad de su marca. Los visitantes únicos proporcionan un recuento de los visitantes por primera vez, y el crecimiento de fans y seguidores indica la expansión de su audiencia en redes sociales. El seguimiento de la clasificación de palabras clave de búsqueda de marca ayuda a evaluar su visibilidad en los resultados de los motores de búsqueda. Para el contenido de video, el porcentaje de visualizaciones de video y la tasa de finalización de video son importantes. El rendimiento de la publicidad se puede medir mediante el costo por mil impresiones (CPM) y el costo por clic (CPC). Finalmente, la tasa de rebote en las páginas de destino puede indicar la relevancia y el compromiso de su contenido inicial.\\nPasando a las etapas de Interés y Consideración, los KPI relevantes incluyen el tiempo dedicado al sitio/página y las páginas vistas, que reflejan el nivel de compromiso con su contenido. Las descargas de contenido indican interés en recursos más profundos, y la tasa de generación de leads mide la eficacia con la que está capturando información de clientes potenciales. La tasa de participación en las redes sociales (compartidos, comentarios, me gusta, menciones) muestra el nivel de interacción con su contenido. Los registros de correo electrónico construyen su canal de comunicación directa, y las reseñas de clientes proporcionan prueba social. Para las empresas de comercio electrónico, la tasa de adición al carrito señala la intención de compra. La calidad del lead evalúa la probabilidad de que los leads se conviertan. Los visitantes recurrentes, la tasa de carrito a detalle y el uso de la búsqueda del sitio ofrecen más información sobre el comportamiento y la intención del usuario. Métricas adicionales como la tasa de enfoque, el comportamiento de múltiples clics, la rotación de dispositivos y los patrones de lectura pueden proporcionar una comprensión granular del compromiso del usuario.\\nLas etapas de Conversión, Decisión o Acción son críticas para medir el éxito de su embudo. La tasa de conversión (CVR) es la medida más directa de cuántos prospectos se están convirtiendo en clientes. El costo por adquisición (CPA) y el costo por lead (CPL) ayudan a evaluar la eficiencia de su gasto en marketing. Las ventas y los ingresos son los indicadores definitivos del rendimiento financiero, mientras que el retorno de la inversión publicitaria (ROAS) mide los ingresos generados por cada dólar gastado en publicidad. El valor promedio del pedido (AOV) y el valor promedio del contrato reflejan el valor de cada transacción. El análisis de los pedidos de clientes nuevos versus recurrentes y los ingresos por producto proporciona información sobre la adquisición de clientes y el rendimiento del producto. Los ingresos por visitante (RPV) vinculan el tráfico del sitio web con la generación de ingresos. Para los equipos de ventas, métricas como la tasa de conversión de leads calificados para ventas (SQL) a oportunidad, la tasa de conversión de lead a cliente, la tasa de conversión de lead a reunión, la tasa de abandono del embudo, la relación de oportunidad a ganancia, el tamaño promedio del acuerdo, la velocidad del pipeline de ventas son esenciales.\\nDespués de la compra, en las etapas de Lealtad y Retención, los KPI clave incluyen la satisfacción del cliente (CSAT), las tasas de retención y el sentimiento del cliente. La tasa de recompra (RPR) y el valor de vida del cliente (CLV) indican el valor a largo plazo de sus clientes. La tasa de abandono mide la pérdida de clientes, mientras que el promedio de días entre transacciones y la tasa de retención de clientes general reflejan la lealtad del cliente.\\nFinalmente, en la etapa de Defensa, el Net Promoter Score (NPS) mide la lealtad del cliente y la probabilidad de recomendación, junto con el número de referencias, menciones en redes sociales y calificaciones de reseñas.\\nAl monitorear consistentemente estos KPI, las empresas pueden obtener una comprensión integral del rendimiento de su embudo de marketing y ventas, realizar un seguimiento del progreso hacia sus objetivos e identificar áreas específicas que requieren optimización.\\nEl análisis combinado de estas métricas puede revelar información más profunda sobre el comportamiento del cliente y la eficacia de diversas estrategias.\\nPor ejemplo, un alto volumen de tráfico en el sitio web en la etapa de conciencia, junto con una baja tasa de generación de leads, podría sugerir que el contenido no está resonando con el público objetivo o que el llamado a la acción no es convincente.\\nPor el contrario, una sólida tasa de conversión de lead a cliente pero una alta tasa de abandono podrían indicar problemas con la experiencia del cliente posterior a la compra.\\nDada la cantidad de métricas existentes no recomendamos implementar todas en un solo paso, sino seleccionar, en primera instancia una (1) por cada etapa y luego a medida que se tiene un mayor entendimiento de las métricas implementadas ir avanzando en implementar otras.\\n","section":"Mejora de las Tasas de Conversión a Través del Embudo de Marketing y Ventas","version":"current","path":"/es/blog/mejora-de-las-tasas-de-conversion-a-traves-del-embudo-de-marketing-y-ventas#indicadores-clave-de-rendimiento-kpis-para-medir-la-conversión-en-las-etapas-del-embudo","category":"blogs"},{"title":"Indicadores Clave de Rendimiento (KPIs) para Medir la Conversión en las Etapas del Embudo","content":"Etapa del Embudo\\nIndicadores Clave de Rendimiento (KPIs)\\n\\n\\n\\n\\nConciencia\\nTráfico del sitio web, participación en redes sociales, menciones de marca, alcance, impresiones, crecimiento de fans y seguidores, clasificación de palabras clave de búsqueda de marca, porcentaje de visualizaciones de video, tasa de finalización de video, costo por mil impresiones (CPM), costo por clic (CPC), tasa de rebote, visitantes únicos\\n\\n\\nInterés y Consideración\\nTiempo dedicado al sitio/página, páginas vistas, descargas de contenido, tasa de generación de leads, tasa de participación en redes sociales (compartidos, comentarios, me gusta, menciones), registros de correo electrónico, reseñas de clientes, tasa de adición al carrito, calidad del lead, visitantes recurrentes, tasa de carrito a detalle, uso de la búsqueda del sitio, tasa de enfoque, comportamiento de múltiples clics, rotación de dispositivos, patrones de lectura\\n\\n\\nConversión, Decisión o Acción\\nTasa de conversión (CVR), costo por adquisición (CPA), costo por lead (CPL), ventas, ingresos, retorno de la inversión publicitaria (ROAS), valor promedio del pedido (AOV), valor promedio del contrato, pedidos de clientes nuevos versus recurrentes, ingresos por producto, ingresos por visitante (RPV), tasa de conversión de leads calificados para ventas (SQL) a oportunidad, tasa de conversión de lead a cliente, tasa de conversión de lead a reunión, tasa de abandono del embudo, relación de oportunidad a ganancia, tamaño promedio del acuerdo, velocidad del pipeline de ventas, tasa de calificación de leads\\n\\n\\nLealtad y Retención\\nSatisfacción del cliente (CSAT), tasas de retención, sentimiento del cliente, tasa de recompra (RPR), valor de vida del cliente (CLV), tasa de abandono, promedio de días entre transacciones, tasa de retención de clientes\\n\\n\\nDefensa\\nNet Promoter Score (NPS), referencias, menciones en redes sociales, calificaciones de reseñas\\nTe recomendamos leer:\\nMejora de las Tasas de Conversión a Través del Embudo de Marketing y Ventas\\nEstrategias Accionables para Mejorar las Tasas de Conversión en Cada Etapa del Embudo\\nAlineando Marketing y Ventas para una Conversión Óptima\\n","section":"Mejora de las Tasas de Conversión a Través del Embudo de Marketing y Ventas","version":"current","path":"/es/blog/mejora-de-las-tasas-de-conversion-a-traves-del-embudo-de-marketing-y-ventas#indicadores-clave-de-rendimiento-kpis-para-medir-la-conversión-en-las-etapas-del-embudo-1","category":"blogs"},{"title":"Markdown page example","content":"You don\'t need React to write simple standalone pages.\\n","section":"Markdown page example","version":"current","path":"/es/markdown-page","category":"pages"}],"availableVersions":["current"],"docsInstances":["default"],"plugins":{"analytics":{"enabled":true}},"id":"default"}}}')
;// CONCATENATED MODULE: ./.docusaurus/i18n.json
var i18n_namespaceObject = JSON.parse('{"defaultLocale":"en","locales":["en","es"],"path":"i18n","currentLocale":"es","localeConfigs":{"en":{"label":"English","direction":"ltr","htmlLang":"en","calendar":"gregory","path":"en","translate":true,"url":"https://docs.fintesk.com","baseUrl":"/"},"es":{"label":"Español","direction":"ltr","htmlLang":"es","calendar":"gregory","path":"es","translate":true,"url":"https://docs.fintesk.com","baseUrl":"/es/"}}}')
// EXTERNAL MODULE: ./.docusaurus/codeTranslations.json
var codeTranslations = __webpack_require__(22654);
;// CONCATENATED MODULE: ./.docusaurus/site-metadata.json
var site_metadata_namespaceObject = JSON.parse('{"docusaurusVersion":"3.9.2","siteVersion":"0.0.0","pluginVersions":{"docusaurus-plugin-css-cascade-layers":{"type":"package","name":"@docusaurus/plugin-css-cascade-layers","version":"3.9.2"},"docusaurus-plugin-content-docs":{"type":"package","name":"@docusaurus/plugin-content-docs","version":"3.9.2"},"docusaurus-plugin-content-blog":{"type":"package","name":"@docusaurus/plugin-content-blog","version":"3.9.2"},"docusaurus-plugin-content-pages":{"type":"package","name":"@docusaurus/plugin-content-pages","version":"3.9.2"},"docusaurus-plugin-sitemap":{"type":"package","name":"@docusaurus/plugin-sitemap","version":"3.9.2"},"docusaurus-plugin-svgr":{"type":"package","name":"@docusaurus/plugin-svgr","version":"3.9.2"},"docusaurus-plugin-redoc":{"type":"package","name":"docusaurus-plugin-redoc","version":"2.2.2"},"docusaurus-theme-classic":{"type":"package","name":"@docusaurus/theme-classic","version":"3.9.2"},"docusaurus-theme-redoc":{"type":"package","name":"docusaurus-theme-redoc","version":"2.2.2"},"docusaurus-plugin-google-tag-manager":{"type":"package","name":"@docusaurus/plugin-google-tag-manager","version":"3.9.2"},"@orama/plugin-docusaurus-v3":{"type":"package","name":"@orama/plugin-docusaurus-v3","version":"3.1.16"}}}')
;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/docusaurusContext.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 






// Static value on purpose: don't make it dynamic!
// Using context is still useful for testability reasons.
const contextValue = {
    siteConfig: docusaurus_config/* ["default"] */.A,
    siteMetadata: site_metadata_namespaceObject,
    globalData: globalData_namespaceObject,
    i18n: i18n_namespaceObject,
    codeTranslations: codeTranslations
};
const Context = /*#__PURE__*/ react.createContext(contextValue);
function DocusaurusContextProvider({ children }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(Context.Provider, {
        value: contextValue,
        children: children
    });
}


}),
9526: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (BrowserOnly)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _docusaurus_useIsBrowser__rspack_import_2 = __webpack_require__(19863);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


// Similar comp to the one described here:
// https://www.joshwcomeau.com/react/the-perils-of-rehydration/#abstractions
function BrowserOnly({ children, fallback }) {
    const isBrowser = (0,_docusaurus_useIsBrowser__rspack_import_2/* ["default"] */.A)();
    if (isBrowser) {
        if (typeof children !== 'function' && "production" === 'development') {}
        return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(react_jsx_runtime__rspack_import_0.Fragment, {
            children: children?.()
        });
    }
    return fallback ?? null;
}


}),
11701: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ ErrorBoundary)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(74848);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/ExecutionEnvironment.js
var ExecutionEnvironment = __webpack_require__(91289);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/Head.js
var Head = __webpack_require__(53572);
// EXTERNAL MODULE: ./node_modules/@docusaurus/utils-common/lib/index.js
var lib = __webpack_require__(5248);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Layout/index.js + 170 modules
var Layout = __webpack_require__(16099);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/routeContext.js
var routeContext = __webpack_require__(97574);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/theme-fallback/Error/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ // Should we translate theme-fallback?
/* eslint-disable @docusaurus/no-untranslated-text */ 






function ErrorDisplay({ error, tryAgain }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
        style: {
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'center',
            alignItems: 'flex-start',
            minHeight: '100vh',
            width: '100%',
            maxWidth: '80ch',
            fontSize: '20px',
            margin: '0 auto',
            padding: '1rem'
        },
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsx)("h1", {
                style: {
                    fontSize: '3rem'
                },
                children: "This page crashed"
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)("button", {
                type: "button",
                onClick: tryAgain,
                style: {
                    margin: '1rem 0',
                    fontSize: '2rem',
                    cursor: 'pointer',
                    borderRadius: 20,
                    padding: '1rem'
                },
                children: "Try again"
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(ErrorBoundaryError, {
                error: error
            })
        ]
    });
}
function ErrorBoundaryError({ error }) {
    const causalChain = (0,lib.getErrorCausalChain)(error);
    const fullMessage = causalChain.map((e)=>e.message).join('\n\nCause:\n');
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("p", {
        style: {
            whiteSpace: 'pre-wrap'
        },
        children: fullMessage
    });
}
// A bit hacky: we need to add an artificial RouteContextProvider here
// The goal is to be able to render the error inside the theme layout
// Without this, our theme classic would crash due to lack of route context
// See also https://github.com/facebook/docusaurus/pull/9852
function ErrorRouteContextProvider({ children }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(routeContext/* .RouteContextProvider */.W, {
        value: {
            plugin: {
                name: 'docusaurus-core-error-boundary',
                id: 'default'
            }
        },
        children: children
    });
}
function Error({ error, tryAgain }) {
    // We wrap the error in its own error boundary because the layout can actually
    // throw too... Only the ErrorDisplay component is simple enough to be
    // considered safe to never throw
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(ErrorRouteContextProvider, {
        children: /*#__PURE__*/ (0,jsx_runtime.jsxs)(ErrorBoundary, {
            // Note: we display the original error here, not the error that we
            // captured in this extra error boundary
            fallback: ()=>/*#__PURE__*/ (0,jsx_runtime.jsx)(ErrorDisplay, {
                    error: error,
                    tryAgain: tryAgain
                }),
            children: [
                /*#__PURE__*/ (0,jsx_runtime.jsx)(Head/* ["default"] */.A, {
                    children: /*#__PURE__*/ (0,jsx_runtime.jsx)("title", {
                        children: "Page Error"
                    })
                }),
                /*#__PURE__*/ (0,jsx_runtime.jsx)(Layout/* ["default"] */.A, {
                    children: /*#__PURE__*/ (0,jsx_runtime.jsx)(ErrorDisplay, {
                        error: error,
                        tryAgain: tryAgain
                    })
                })
            ]
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/exports/ErrorBoundary.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



// eslint-disable-next-line react/function-component-definition
const DefaultFallback = (params)=>/*#__PURE__*/ (0,jsx_runtime.jsx)(Error, {
        ...params
    });
class ErrorBoundary extends react.Component {
    constructor(props){
        super(props);
        this.state = {
            error: null
        };
    }
    componentDidCatch(error) {
        // Catch errors in any components below and re-render with error message
        if (ExecutionEnvironment["default"].canUseDOM) {
            this.setState({
                error
            });
        }
    }
    render() {
        const { children } = this.props;
        const { error } = this.state;
        if (error) {
            const fallbackParams = {
                error,
                tryAgain: ()=>this.setState({
                        error: null
                    })
            };
            const fallback = this.props.fallback ?? DefaultFallback;
            return fallback(fallbackParams);
        }
        // See https://github.com/facebook/docusaurus/issues/6337#issuecomment-1012913647
        return children ?? null;
    }
}


}),
91289: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  "default": () => (__rspack_default_export)
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ const canUseDOM = typeof window !== 'undefined' && 'document' in window && 'createElement' in window.document;
const ExecutionEnvironment = {
    canUseDOM,
    // window.attachEvent is IE-specific; it's very likely Docusaurus won't work
    // on IE anyway.
    canUseEventListeners: canUseDOM && ('addEventListener' in window || 'attachEvent' in window),
    canUseIntersectionObserver: canUseDOM && 'IntersectionObserver' in window,
    canUseViewport: canUseDOM && 'screen' in window
};
/* export default */ const __rspack_default_export = (ExecutionEnvironment);


}),
53572: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (Head)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var react_helmet_async__rspack_import_2 = __webpack_require__(80545);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


function Head(props) {
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(react_helmet_async__rspack_import_2/* .Helmet */.mg, {
        ...props
    });
}


}),
95310: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (__rspack_default_export)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var react_router_dom__rspack_import_8 = __webpack_require__(54625);
/* import */ var _docusaurus_utils_common__rspack_import_7 = __webpack_require__(5248);
/* import */ var _useDocusaurusContext__rspack_import_2 = __webpack_require__(10898);
/* import */ var _isInternalUrl__rspack_import_6 = __webpack_require__(58310);
/* import */ var _ExecutionEnvironment__rspack_import_3 = __webpack_require__(91289);
/* import */ var _useBrokenLinks__rspack_import_4 = __webpack_require__(55916);
/* import */ var _useBaseUrl__rspack_import_5 = __webpack_require__(66497);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 








// TODO all this wouldn't be necessary if we used ReactRouter basename feature
// We don't automatically add base urls to all links,
// only the "safe" ones, starting with / (like /docs/introduction)
// this is because useBaseUrl() actually transforms relative links
// like "introduction" to "/baseUrl/introduction" => bad behavior to fix
const shouldAddBaseUrlAutomatically = (to)=>to.startsWith('/');
function Link({ isNavLink, to, href, activeClassName, isActive, 'data-noBrokenLinkCheck': noBrokenLinkCheck, autoAddBaseUrl = true, ...props }, forwardedRef) {
    const { siteConfig } = (0,_useDocusaurusContext__rspack_import_2/* ["default"] */.A)();
    const { trailingSlash, baseUrl } = siteConfig;
    const router = siteConfig.future.experimental_router;
    const { withBaseUrl } = (0,_useBaseUrl__rspack_import_5/* .useBaseUrlUtils */.hH)();
    const brokenLinks = (0,_useBrokenLinks__rspack_import_4/* ["default"] */.A)();
    const innerRef = (0,react__rspack_import_1.useRef)(null);
    (0,react__rspack_import_1.useImperativeHandle)(forwardedRef, ()=>innerRef.current);
    // IMPORTANT: using to or href should not change anything
    // For example, MDX links will ALWAYS give us the href props
    // Using one prop or the other should not be used to distinguish
    // internal links (/docs/myDoc) from external links (https://github.com)
    const targetLinkUnprefixed = to || href;
    function maybeAddBaseUrl(str) {
        return autoAddBaseUrl && shouldAddBaseUrlAutomatically(str) ? withBaseUrl(str) : str;
    }
    const isInternal = (0,_isInternalUrl__rspack_import_6/* ["default"] */.A)(targetLinkUnprefixed);
    // pathname:// is a special "protocol" we use to tell Docusaurus link
    // that a link is not "internal" and that we shouldn't use history.push()
    // this is not ideal but a good enough escape hatch for now
    // see https://github.com/facebook/docusaurus/issues/3309
    // note: we want baseUrl to be appended (see issue for details)
    // TODO read routes and automatically detect internal/external links?
    const targetLinkWithoutPathnameProtocol = targetLinkUnprefixed?.replace('pathname://', '');
    // TODO we should use ReactRouter basename feature instead!
    // Automatically apply base url in links that start with /
    let targetLink = typeof targetLinkWithoutPathnameProtocol !== 'undefined' ? maybeAddBaseUrl(targetLinkWithoutPathnameProtocol) : undefined;
    // TODO find a way to solve this problem properly
    // Fix edge case when useBaseUrl is used on a link
    // "./" is useful for images and other resources
    // But we don't need it for <Link>
    // unfortunately we can't really make the difference :/
    if (router === 'hash' && targetLink?.startsWith('./')) {
        targetLink = targetLink?.slice(1);
    }
    if (targetLink && isInternal) {
        targetLink = (0,_docusaurus_utils_common__rspack_import_7.applyTrailingSlash)(targetLink, {
            trailingSlash,
            baseUrl
        });
    }
    const preloaded = (0,react__rspack_import_1.useRef)(false);
    const LinkComponent = isNavLink ? react_router_dom__rspack_import_8/* .NavLink */.k2 : react_router_dom__rspack_import_8/* .Link */.N_;
    const IOSupported = _ExecutionEnvironment__rspack_import_3["default"].canUseIntersectionObserver;
    const ioRef = (0,react__rspack_import_1.useRef)();
    const handleRef = (el)=>{
        innerRef.current = el;
        if (IOSupported && el && isInternal) {
            // If IO supported and element reference found, set up Observer.
            ioRef.current = new window.IntersectionObserver((entries)=>{
                entries.forEach((entry)=>{
                    if (el === entry.target) {
                        // If element is in viewport, stop observing and run callback.
                        // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
                        if (entry.isIntersecting || entry.intersectionRatio > 0) {
                            ioRef.current.unobserve(el);
                            ioRef.current.disconnect();
                            if (targetLink != null) {
                                window.docusaurus.prefetch(targetLink);
                            }
                        }
                    }
                });
            });
            // Add element to the observer.
            ioRef.current.observe(el);
        }
    };
    const onInteractionEnter = ()=>{
        if (!preloaded.current && targetLink != null) {
            window.docusaurus.preload(targetLink);
            preloaded.current = true;
        }
    };
    (0,react__rspack_import_1.useEffect)(()=>{
        // If IO is not supported. We prefetch by default (only once).
        if (!IOSupported && isInternal && _ExecutionEnvironment__rspack_import_3["default"].canUseDOM) {
            if (targetLink != null) {
                window.docusaurus.prefetch(targetLink);
            }
        }
        // When unmounting, stop intersection observer from watching.
        return ()=>{
            if (IOSupported && ioRef.current) {
                ioRef.current.disconnect();
            }
        };
    }, [
        ioRef,
        targetLink,
        IOSupported,
        isInternal
    ]);
    // It is simple local anchor link targeting current page?
    const isAnchorLink = targetLink?.startsWith('#') ?? false;
    // See also RR logic:
    // https://github.com/remix-run/react-router/blob/v5/packages/react-router-dom/modules/Link.js#L47
    const hasInternalTarget = !props.target || props.target === '_self';
    // Should we use a regular <a> tag instead of React-Router Link component?
    const isRegularHtmlLink = !targetLink || !isInternal || !hasInternalTarget || // When using the hash router, we can't use the regular <a> link for anchors
    // We need to use React Router to navigate to /#/pathname/#anchor
    // And not /#anchor
    // See also https://github.com/facebook/docusaurus/pull/10311
    isAnchorLink && router !== 'hash';
    if (!noBrokenLinkCheck && (isAnchorLink || !isRegularHtmlLink)) {
        brokenLinks.collectLink(targetLink);
    }
    if (props.id) {
        brokenLinks.collectAnchor(props.id);
    }
    // These props are only added in unit tests to assert/capture the type of link
    const testOnlyProps =  false ? 0 : {};
    return isRegularHtmlLink ? // eslint-disable-next-line jsx-a11y/anchor-has-content, @docusaurus/no-html-links
    /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("a", {
        ref: innerRef,
        href: targetLink,
        ...targetLinkUnprefixed && !isInternal && {
            target: '_blank',
            rel: 'noopener noreferrer'
        },
        ...props,
        ...testOnlyProps
    }) : /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(LinkComponent, {
        ...props,
        onMouseEnter: onInteractionEnter,
        onTouchStart: onInteractionEnter,
        innerRef: handleRef,
        to: targetLink,
        ...isNavLink && {
            isActive,
            activeClassName
        },
        ...testOnlyProps
    });
}
/* export default */ const __rspack_default_export = (/*#__PURE__*/react__rspack_import_1.forwardRef(Link));


}),
30568: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ Translate),
  T: () => (/* binding */ translate)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(74848);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/exports/Interpolate.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

function interpolate(text, values) {
    // eslint-disable-next-line prefer-named-capture-group
    const segments = text.split(/(\{\w+\})/).map((seg, index)=>{
        // Odd indices (1, 3, 5...) of the segments are (potentially) interpolatable
        if (index % 2 === 1) {
            const value = values?.[seg.slice(1, -1)];
            if (value !== undefined) {
                return value;
            }
        // No match: add warning? There's no way to "escape" interpolation though
        }
        return seg;
    });
    if (segments.some((seg)=>/*#__PURE__*/ (0,react.isValidElement)(seg))) {
        return segments.map((seg, index)=>/*#__PURE__*/ (0,react.isValidElement)(seg) ? /*#__PURE__*/ react.cloneElement(seg, {
                key: index
            }) : seg).filter((seg)=>seg !== '');
    }
    return segments.join('');
}
function Interpolate({ children, values }) {
    if (typeof children !== 'string') {
        throw new Error(`The Docusaurus <Interpolate> component only accept simple string values. Received: ${/*#__PURE__*/ isValidElement(children) ? 'React element' : typeof children}`);
    }
    return /*#__PURE__*/ _jsx(_Fragment, {
        children: interpolate(children, values)
    });
}

// EXTERNAL MODULE: ./.docusaurus/codeTranslations.json
var codeTranslations = __webpack_require__(22654);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/exports/Translate.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


// Can't read it from context, due to exposing imperative API

function getLocalizedMessage({ id, message }) {
    if (typeof id === 'undefined' && typeof message === 'undefined') {
        throw new Error('Docusaurus translation declarations must have at least a translation id or a default translation message');
    }
    return codeTranslations[id ?? message] ?? message ?? id;
}
// Imperative translation API is useful for some edge-cases:
// - translating page titles (meta)
// - translating string props (input placeholders, image alt, aria labels...)
function translate({ message, id }, values) {
    const localizedMessage = getLocalizedMessage({
        message,
        id
    });
    return interpolate(localizedMessage, values);
}
// Maybe we'll want to improve this component with additional features
// Like toggling a translation mode that adds a little translation button near
// the text?
function Translate({ children, id, values }) {
    if (children && typeof children !== 'string') {
        console.warn('Illegal <Translate> children', children);
        throw new Error('The Docusaurus <Translate> component only accept simple string values');
    }
    const localizedMessage = getLocalizedMessage({
        message: children,
        id
    });
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
        children: interpolate(localizedMessage, values)
    });
}


}),
68977: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  W: () => (DEFAULT_PLUGIN_ID)
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ // Constants used on the client-side: duplicated from server-side code
const DEFAULT_PLUGIN_ID = 'default';


}),
58310: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (isInternalUrl),
  z: () => (hasProtocol)
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ function hasProtocol(url) {
    return /^(?:\w*:|\/\/)/.test(url);
}
function isInternalUrl(url) {
    return typeof url !== 'undefined' && !hasProtocol(url);
}


}),
66497: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  Ay: () => (useBaseUrl),
  hH: () => (useBaseUrlUtils)
});
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var _useDocusaurusContext__rspack_import_1 = __webpack_require__(10898);
/* import */ var _isInternalUrl__rspack_import_2 = __webpack_require__(58310);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


function addBaseUrl({ siteUrl, baseUrl, url, options: { forcePrependBaseUrl = false, absolute = false } = {}, router }) {
    // It never makes sense to add base url to a local anchor url, or one with a
    // protocol
    if (!url || url.startsWith('#') || (0,_isInternalUrl__rspack_import_2/* .hasProtocol */.z)(url)) {
        return url;
    }
    // TODO hash router + /baseUrl/ is unlikely to work well in all situations
    // This will support most cases, but not all
    // See https://github.com/facebook/docusaurus/pull/9859
    if (router === 'hash') {
        return url.startsWith('/') ? `.${url}` : `./${url}`;
    }
    if (forcePrependBaseUrl) {
        return baseUrl + url.replace(/^\//, '');
    }
    // /baseUrl -> /baseUrl/
    // https://github.com/facebook/docusaurus/issues/6315
    if (url === baseUrl.replace(/\/$/, '')) {
        return baseUrl;
    }
    // We should avoid adding the baseurl twice if it's already there
    const shouldAddBaseUrl = !url.startsWith(baseUrl);
    const basePath = shouldAddBaseUrl ? baseUrl + url.replace(/^\//, '') : url;
    return absolute ? siteUrl + basePath : basePath;
}
function useBaseUrlUtils() {
    const { siteConfig } = (0,_useDocusaurusContext__rspack_import_1/* ["default"] */.A)();
    const { baseUrl, url: siteUrl } = siteConfig;
    const router = siteConfig.future.experimental_router;
    const withBaseUrl = (0,react__rspack_import_0.useCallback)((url, options)=>addBaseUrl({
            siteUrl,
            baseUrl,
            url,
            options,
            router
        }), [
        siteUrl,
        baseUrl,
        router
    ]);
    return {
        withBaseUrl
    };
}
function useBaseUrl(url, options = {}) {
    const { withBaseUrl } = useBaseUrlUtils();
    return withBaseUrl(url, options);
}


}),
55916: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ useBrokenLinks)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(74848);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/BrokenLinksContext.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

const createStatefulBrokenLinks = ()=>{
    // Set to dedup, as it's not useful to collect multiple times the same value
    const allAnchors = new Set();
    const allLinks = new Set();
    return {
        collectAnchor: (anchor)=>{
            typeof anchor !== 'undefined' && allAnchors.add(anchor);
        },
        collectLink: (link)=>{
            typeof link !== 'undefined' && allLinks.add(link);
        },
        getCollectedAnchors: ()=>[
                ...allAnchors
            ],
        getCollectedLinks: ()=>[
                ...allLinks
            ]
    };
};
const Context = /*#__PURE__*/ react.createContext({
    collectAnchor: ()=>{
    // No-op for client
    },
    collectLink: ()=>{
    // No-op for client
    }
});
const useBrokenLinksContext = ()=>(0,react.useContext)(Context);
function BrokenLinksProvider({ children, brokenLinks }) {
    return /*#__PURE__*/ _jsx(Context.Provider, {
        value: brokenLinks,
        children: children
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/core/lib/client/exports/useBrokenLinks.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 
function useBrokenLinks() {
    return useBrokenLinksContext();
}


}),
10898: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (useDocusaurusContext)
});
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var _docusaurusContext__rspack_import_1 = __webpack_require__(93587);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

function useDocusaurusContext() {
    return (0,react__rspack_import_0.useContext)(_docusaurusContext__rspack_import_1/* .Context */.o);
}


}),
99044: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  P_: () => (usePluginData),
  kh: () => (useAllPluginInstancesData)
});
/* import */ var _useDocusaurusContext__rspack_import_0 = __webpack_require__(10898);
/* import */ var _constants__rspack_import_1 = __webpack_require__(68977);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

function useGlobalData() {
    const { globalData } = (0,_useDocusaurusContext__rspack_import_0/* ["default"] */.A)();
    return globalData;
}
function useAllPluginInstancesData(pluginName, options = {}) {
    const globalData = useGlobalData();
    const pluginGlobalData = globalData[pluginName];
    if (!pluginGlobalData && options.failfast) {
        throw new Error(`Docusaurus plugin global data not found for "${pluginName}" plugin.`);
    }
    return pluginGlobalData;
}
function usePluginData(pluginName, pluginId = _constants__rspack_import_1/* .DEFAULT_PLUGIN_ID */.W, options = {}) {
    const pluginGlobalData = useAllPluginInstancesData(pluginName);
    const pluginInstanceGlobalData = pluginGlobalData?.[pluginId];
    if (!pluginInstanceGlobalData && options.failfast) {
        throw new Error(`Docusaurus plugin global data not found for "${pluginName}" plugin with id "${pluginId}".`);
    }
    return pluginInstanceGlobalData;
}


}),
19863: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (useIsBrowser)
});
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var _browserContext__rspack_import_1 = __webpack_require__(91173);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

function useIsBrowser() {
    return (0,react__rspack_import_0.useContext)(_browserContext__rspack_import_1/* .Context */.o);
}


}),
99989: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (__rspack_default_export)
});
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var _ExecutionEnvironment__rspack_import_1 = __webpack_require__(91289);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

/**
 * This hook is like `useLayoutEffect`, but without the SSR warning.
 * It seems hacky but it's used in many React libs (Redux, Formik...).
 * Also mentioned here: https://github.com/facebook/react/issues/16956
 *
 * It is useful when you need to update a ref as soon as possible after a React
 * render (before `useEffect`).
 *
 * TODO should become unnecessary in React v19?
 * https://github.com/facebook/react/pull/26395
 * This was added in core with Docusaurus v3 but kept undocumented on purpose
 */ const useIsomorphicLayoutEffect = _ExecutionEnvironment__rspack_import_1["default"].canUseDOM ? react__rspack_import_0.useLayoutEffect : react__rspack_import_0.useEffect;
/* export default */ const __rspack_default_export = (useIsomorphicLayoutEffect);


}),
78491: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (useRouteContext)
});
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var _routeContext__rspack_import_1 = __webpack_require__(97574);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

function useRouteContext() {
    const context = react__rspack_import_0.useContext(_routeContext__rspack_import_1/* .Context */.o);
    if (!context) {
        throw new Error('Unexpected: no Docusaurus route context found');
    }
    return context;
}


}),
27665: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (flat)
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ const isTree = (x)=>typeof x === 'object' && !!x && Object.keys(x).length > 0;
/**
 * Takes a tree, and flattens it into a map of keyPath -> value.
 *
 * ```js
 * flat({ a: { b: 1 } }) === { "a.b": 1 };
 * flat({ a: [1, 2] }) === { "a.0": 1, "a.1": 2 };
 * ```
 */ function flat(target) {
    const delimiter = '.';
    const output = {};
    function dfs(object, prefix) {
        Object.entries(object).forEach(([key, value])=>{
            const newKey = prefix ? `${prefix}${delimiter}${key}` : key;
            if (isTree(value)) {
                dfs(value, newKey);
            } else {
                output[newKey] = value;
            }
        });
    }
    dfs(target);
    return output;
}


}),
97574: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  W: () => (RouteContextProvider),
  o: () => (Context)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

const Context = /*#__PURE__*/ react__rspack_import_1.createContext(null);
function mergeContexts({ parent, value }) {
    if (!parent) {
        if (!value) {
            throw new Error('Unexpected: no Docusaurus route context found');
        } else if (!('plugin' in value)) {
            throw new Error('Unexpected: Docusaurus topmost route context has no `plugin` attribute');
        }
        return value;
    }
    // TODO deep merge this
    const data = {
        ...parent.data,
        ...value?.data
    };
    return {
        // Nested routes are not supposed to override plugin attribute
        plugin: parent.plugin,
        data
    };
}
function RouteContextProvider({ children, value }) {
    const parent = react__rspack_import_1.useContext(Context);
    const mergedValue = (0,react__rspack_import_1.useMemo)(()=>mergeContexts({
            parent,
            value
        }), [
        parent,
        value
    ]);
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(Context.Provider, {
        value: mergedValue,
        children: children
    });
}


}),
42086: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  VQ: () => (DocsPreferredVersionContextProvider),
  XK: () => (useDocsPreferredVersionByPluginId),
  g1: () => (useDocsPreferredVersion)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _docusaurus_plugin_content_docs_client__rspack_import_4 = __webpack_require__(88209);
/* import */ var _docusaurus_constants__rspack_import_6 = __webpack_require__(68977);
/* import */ var _docusaurus_theme_common__rspack_import_3 = __webpack_require__(61022);
/* import */ var _docusaurus_theme_common_internal__rspack_import_2 = __webpack_require__(41367);
/* import */ var _docusaurus_theme_common_internal__rspack_import_5 = __webpack_require__(52260);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 





const storageKey = (pluginId)=>`docs-preferred-version-${pluginId}`;
const DocsPreferredVersionStorage = {
    save: (pluginId, persistence, versionName)=>{
        (0,_docusaurus_theme_common_internal__rspack_import_2/* .createStorageSlot */.Wf)(storageKey(pluginId), {
            persistence
        }).set(versionName);
    },
    read: (pluginId, persistence)=>(0,_docusaurus_theme_common_internal__rspack_import_2/* .createStorageSlot */.Wf)(storageKey(pluginId), {
            persistence
        }).get(),
    clear: (pluginId, persistence)=>{
        (0,_docusaurus_theme_common_internal__rspack_import_2/* .createStorageSlot */.Wf)(storageKey(pluginId), {
            persistence
        }).del();
    }
};
/**
 * Initial state is always null as we can't read local storage from node SSR
 */ const getInitialState = (pluginIds)=>Object.fromEntries(pluginIds.map((id)=>[
            id,
            {
                preferredVersionName: null
            }
        ]));
/**
 * Read storage for all docs plugins, assigning each doc plugin a preferred
 * version (if found)
 */ function readStorageState({ pluginIds, versionPersistence, allDocsData }) {
    /**
     * The storage value we read might be stale, and belong to a version that does
     * not exist in the site anymore. In such case, we remove the storage value to
     * avoid downstream errors.
     */ function restorePluginState(pluginId) {
        const preferredVersionNameUnsafe = DocsPreferredVersionStorage.read(pluginId, versionPersistence);
        const pluginData = allDocsData[pluginId];
        const versionExists = pluginData.versions.some((version)=>version.name === preferredVersionNameUnsafe);
        if (versionExists) {
            return {
                preferredVersionName: preferredVersionNameUnsafe
            };
        }
        DocsPreferredVersionStorage.clear(pluginId, versionPersistence);
        return {
            preferredVersionName: null
        };
    }
    return Object.fromEntries(pluginIds.map((id)=>[
            id,
            restorePluginState(id)
        ]));
}
function useVersionPersistence() {
    return (0,_docusaurus_theme_common__rspack_import_3/* .useThemeConfig */.p)().docs.versionPersistence;
}
const Context = /*#__PURE__*/ react__rspack_import_1.createContext(null);
function useContextValue() {
    const allDocsData = (0,_docusaurus_plugin_content_docs_client__rspack_import_4/* .useAllDocsData */.Gy)();
    const versionPersistence = useVersionPersistence();
    const pluginIds = (0,react__rspack_import_1.useMemo)(()=>Object.keys(allDocsData), [
        allDocsData
    ]);
    // Initial state is empty, as we can't read browser storage in node/SSR
    const [state, setState] = (0,react__rspack_import_1.useState)(()=>getInitialState(pluginIds));
    // On mount, we set the state read from browser storage
    (0,react__rspack_import_1.useEffect)(()=>{
        setState(readStorageState({
            allDocsData,
            versionPersistence,
            pluginIds
        }));
    }, [
        allDocsData,
        versionPersistence,
        pluginIds
    ]);
    // The API that we expose to consumer hooks (memo for constant object)
    const api = (0,react__rspack_import_1.useMemo)(()=>{
        function savePreferredVersion(pluginId, versionName) {
            DocsPreferredVersionStorage.save(pluginId, versionPersistence, versionName);
            setState((s)=>({
                    ...s,
                    [pluginId]: {
                        preferredVersionName: versionName
                    }
                }));
        }
        return {
            savePreferredVersion
        };
    }, [
        versionPersistence
    ]);
    return [
        state,
        api
    ];
}
function DocsPreferredVersionContextProviderUnsafe({ children }) {
    const value = useContextValue();
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(Context.Provider, {
        value: value,
        children: children
    });
}
/**
 * This is a maybe-layer. If the docs plugin is not enabled, this provider is a
 * simple pass-through.
 */ function DocsPreferredVersionContextProvider({ children }) {
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(DocsPreferredVersionContextProviderUnsafe, {
        children: children
    });
}
function useDocsPreferredVersionContext() {
    const value = (0,react__rspack_import_1.useContext)(Context);
    if (!value) {
        throw new _docusaurus_theme_common_internal__rspack_import_5/* .ReactContextError */.dV('DocsPreferredVersionContextProvider');
    }
    return value;
}
/**
 * Returns a read-write interface to a plugin's preferred version. The
 * "preferred version" is defined as the last version that the user visited.
 * For example, if a user is using v3, even when v4 is later published, the user
 * would still be browsing v3 docs when she opens the website next time. Note,
 * the `preferredVersion` attribute will always be `null` before mount.
 */ function useDocsPreferredVersion(pluginId = _docusaurus_constants__rspack_import_6/* .DEFAULT_PLUGIN_ID */.W) {
    const docsData = (0,_docusaurus_plugin_content_docs_client__rspack_import_4/* .useDocsData */.ht)(pluginId);
    const [state, api] = useDocsPreferredVersionContext();
    const { preferredVersionName } = state[pluginId];
    const preferredVersion = docsData.versions.find((version)=>version.name === preferredVersionName) ?? null;
    const savePreferredVersionName = (0,react__rspack_import_1.useCallback)((versionName)=>{
        api.savePreferredVersion(pluginId, versionName);
    }, [
        api,
        pluginId
    ]);
    return {
        preferredVersion,
        savePreferredVersionName
    };
}
function useDocsPreferredVersionByPluginId() {
    const allDocsData = (0,_docusaurus_plugin_content_docs_client__rspack_import_4/* .useAllDocsData */.Gy)();
    const [state] = useDocsPreferredVersionContext();
    function getPluginIdPreferredVersion(pluginId) {
        const docsData = allDocsData[pluginId];
        const { preferredVersionName } = state[pluginId];
        return docsData.versions.find((version)=>version.name === preferredVersionName) ?? null;
    }
    const pluginIds = Object.keys(allDocsData);
    return Object.fromEntries(pluginIds.map((id)=>[
            id,
            getPluginIdPreferredVersion(id)
        ]));
}


}),
7021: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  k: () => (getDocsVersionSearchTag),
  v: () => (useDocsContextualSearchTags)
});
/* import */ var _docusaurus_plugin_content_docs_client__rspack_import_0 = __webpack_require__(88209);
/* import */ var _docsPreferredVersion__rspack_import_1 = __webpack_require__(42086);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

/** The search tag to append as each doc's metadata. */ function getDocsVersionSearchTag(pluginId, versionName) {
    return `docs-${pluginId}-${versionName}`;
}
/**
 * Gets the relevant docs tags to search.
 * This is the logic that powers the contextual search feature.
 *
 * If user is browsing Android 1.4 docs, he'll get presented with:
 * - Android '1.4' docs
 * - iOS 'preferred | latest' docs
 *
 * The result is generic and not coupled to Algolia/DocSearch on purpose.
 */ function useDocsContextualSearchTags() {
    const allDocsData = (0,_docusaurus_plugin_content_docs_client__rspack_import_0/* .useAllDocsData */.Gy)();
    const activePluginAndVersion = (0,_docusaurus_plugin_content_docs_client__rspack_import_0/* .useActivePluginAndVersion */.gk)();
    const docsPreferredVersionByPluginId = (0,_docsPreferredVersion__rspack_import_1/* .useDocsPreferredVersionByPluginId */.XK)();
    // This can't use more specialized hooks because we are mapping over all
    // plugin instances.
    function getDocPluginTags(pluginId) {
        const activeVersion = activePluginAndVersion?.activePlugin.pluginId === pluginId ? activePluginAndVersion.activeVersion : undefined;
        const preferredVersion = docsPreferredVersionByPluginId[pluginId];
        const latestVersion = allDocsData[pluginId].versions.find((v)=>v.isLast);
        const version = activeVersion ?? preferredVersion ?? latestVersion;
        return getDocsVersionSearchTag(pluginId, version.name);
    }
    return [
        ...Object.keys(allDocsData).map(getDocPluginTags)
    ];
}


}),
52473: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  V: () => (DocsSidebarProvider),
  t: () => (useDocsSidebar)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _docusaurus_theme_common_internal__rspack_import_2 = __webpack_require__(52260);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


// Using a Symbol because null is a valid context value (a doc with no sidebar)
// Inspired by https://github.com/jamiebuilds/unstated-next/blob/master/src/unstated-next.tsx
const EmptyContext = Symbol('EmptyContext');
const Context = /*#__PURE__*/ react__rspack_import_1.createContext(EmptyContext);
/**
 * Provide the current sidebar to your children.
 */ function DocsSidebarProvider({ children, name, items }) {
    const stableValue = (0,react__rspack_import_1.useMemo)(()=>name && items ? {
            name,
            items
        } : null, [
        name,
        items
    ]);
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(Context.Provider, {
        value: stableValue,
        children: children
    });
}
/**
 * Gets the sidebar that's currently displayed, or `null` if there isn't one
 */ function useDocsSidebar() {
    const value = (0,react__rspack_import_1.useContext)(Context);
    if (value === EmptyContext) {
        throw new _docusaurus_theme_common_internal__rspack_import_2/* .ReactContextError */.dV('DocsSidebarProvider');
    }
    return value;
}


}),
88260: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  $S: () => (useCurrentSidebarCategory),
  B5: () => (useDocRootMetadata),
  Nr: () => (findFirstSidebarItemLink),
  OF: () => (useSidebarBreadcrumbs),
  QB: () => (useLayoutDoc),
  Vd: () => (useDocsVersionCandidates),
  Y: () => (useVisibleSidebarItems),
  a4: () => (useCurrentSidebarSiblings),
  cC: () => (useDocById),
  d1: () => (filterDocCardListItems),
  fW: () => (useLayoutDocsSidebar),
  w8: () => (isActiveSidebarItem)
});
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var _docusaurus_router__rspack_import_2 = __webpack_require__(56347);
/* import */ var _docusaurus_renderRoutes__rspack_import_8 = __webpack_require__(22831);
/* import */ var _docusaurus_plugin_content_docs_client__rspack_import_5 = __webpack_require__(88209);
/* import */ var _docusaurus_theme_common_internal__rspack_import_4 = __webpack_require__(19209);
/* import */ var _docusaurus_theme_common__rspack_import_7 = __webpack_require__(80618);
/* import */ var _docsPreferredVersion__rspack_import_6 = __webpack_require__(42086);
/* import */ var _docsVersion__rspack_import_1 = __webpack_require__(70921);
/* import */ var _docsSidebar__rspack_import_3 = __webpack_require__(52473);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 








function useDocById(id) {
    const version = (0,_docsVersion__rspack_import_1/* .useDocsVersion */.r)();
    if (!id) {
        return undefined;
    }
    const doc = version.docs[id];
    if (!doc) {
        throw new Error(`no version doc found by id=${id}`);
    }
    return doc;
}
/**
 * Pure function, similar to `Array#find`, but works on the sidebar tree.
 */ function findSidebarCategory(sidebar, predicate) {
    for (const item of sidebar){
        if (item.type === 'category') {
            if (predicate(item)) {
                return item;
            }
            const subItem = findSidebarCategory(item.items, predicate);
            if (subItem) {
                return subItem;
            }
        }
    }
    return undefined;
}
/**
 * Best effort to assign a link to a sidebar category. If the category doesn't
 * have a link itself, we link to the first sub item with a link.
 */ function findFirstSidebarItemCategoryLink(item) {
    if (item.href && !item.linkUnlisted) {
        return item.href;
    }
    for (const subItem of item.items){
        const link = findFirstSidebarItemLink(subItem);
        if (link) {
            return link;
        }
    }
    return undefined;
}
/**
 * Best effort to assign a link to a sidebar item.
 */ function findFirstSidebarItemLink(item) {
    if (item.type === 'link' && !item.unlisted) {
        return item.href;
    }
    if (item.type === 'category') {
        return findFirstSidebarItemCategoryLink(item);
    }
    // Other items types, like "html"
    return undefined;
}
/**
 * Gets the category associated with the current location. Should only be used
 * on category index pages.
 */ function useCurrentSidebarCategory() {
    const { pathname } = (0,_docusaurus_router__rspack_import_2/* .useLocation */.zy)();
    const sidebar = (0,_docsSidebar__rspack_import_3/* .useDocsSidebar */.t)();
    if (!sidebar) {
        throw new Error('Unexpected: cant find current sidebar in context');
    }
    const categoryBreadcrumbs = getSidebarBreadcrumbs({
        sidebarItems: sidebar.items,
        pathname,
        onlyCategories: true
    });
    const deepestCategory = categoryBreadcrumbs.slice(-1)[0];
    if (!deepestCategory) {
        throw new Error(`${pathname} is not associated with a category. useCurrentSidebarCategory() should only be used on category index pages.`);
    }
    return deepestCategory;
}
/**
 * Gets the category associated with the current location. Should only be used
 * on category index pages.
 */ function useCurrentSidebarSiblings() {
    const { pathname } = (0,_docusaurus_router__rspack_import_2/* .useLocation */.zy)();
    const sidebar = (0,_docsSidebar__rspack_import_3/* .useDocsSidebar */.t)();
    if (!sidebar) {
        throw new Error('Unexpected: cant find current sidebar in context');
    }
    const categoryBreadcrumbs = getSidebarBreadcrumbs({
        sidebarItems: sidebar.items,
        pathname,
        onlyCategories: true
    });
    const deepestCategory = categoryBreadcrumbs.slice(-1)[0];
    return deepestCategory?.items ?? sidebar.items;
}
const isActive = (testedPath, activePath)=>typeof testedPath !== 'undefined' && (0,_docusaurus_theme_common_internal__rspack_import_4/* .isSamePath */.ys)(testedPath, activePath);
const containsActiveSidebarItem = (items, activePath)=>items.some((subItem)=>isActiveSidebarItem(subItem, activePath));
/**
 * Checks if a sidebar item should be active, based on the active path.
 */ function isActiveSidebarItem(item, activePath) {
    if (item.type === 'link') {
        return isActive(item.href, activePath);
    }
    if (item.type === 'category') {
        return isActive(item.href, activePath) || containsActiveSidebarItem(item.items, activePath);
    }
    return false;
}
function isVisibleSidebarItem(item, activePath) {
    switch(item.type){
        case 'category':
            return isActiveSidebarItem(item, activePath) || typeof item.href !== 'undefined' && !item.linkUnlisted || item.items.some((subItem)=>isVisibleSidebarItem(subItem, activePath));
        case 'link':
            // An unlisted item remains visible if it is active
            return !item.unlisted || isActiveSidebarItem(item, activePath);
        default:
            return true;
    }
}
function useVisibleSidebarItems(items, activePath) {
    return (0,react__rspack_import_0.useMemo)(()=>items.filter((item)=>isVisibleSidebarItem(item, activePath)), [
        items,
        activePath
    ]);
}
/**
 * Get the sidebar the breadcrumbs for a given pathname
 * Ordered from top to bottom
 */ function getSidebarBreadcrumbs({ sidebarItems, pathname, onlyCategories = false }) {
    const breadcrumbs = [];
    function extract(items) {
        for (const item of items){
            if (item.type === 'category' && ((0,_docusaurus_theme_common_internal__rspack_import_4/* .isSamePath */.ys)(item.href, pathname) || extract(item.items)) || item.type === 'link' && (0,_docusaurus_theme_common_internal__rspack_import_4/* .isSamePath */.ys)(item.href, pathname)) {
                const filtered = onlyCategories && item.type !== 'category';
                if (!filtered) {
                    breadcrumbs.unshift(item);
                }
                return true;
            }
        }
        return false;
    }
    extract(sidebarItems);
    return breadcrumbs;
}
/**
 * Gets the breadcrumbs of the current doc page, based on its sidebar location.
 * Returns `null` if there's no sidebar or breadcrumbs are disabled.
 */ function useSidebarBreadcrumbs() {
    const sidebar = (0,_docsSidebar__rspack_import_3/* .useDocsSidebar */.t)();
    const { pathname } = (0,_docusaurus_router__rspack_import_2/* .useLocation */.zy)();
    const breadcrumbsOption = (0,_docusaurus_plugin_content_docs_client__rspack_import_5/* .useActivePlugin */.vT)()?.pluginData.breadcrumbs;
    if (breadcrumbsOption === false || !sidebar) {
        return null;
    }
    return getSidebarBreadcrumbs({
        sidebarItems: sidebar.items,
        pathname
    });
}
/**
 * "Version candidates" are mostly useful for the layout components, which must
 * be able to work on all pages. For example, if a user has `{ type: "doc",
 * docId: "intro" }` as a navbar item, which version does that refer to? We
 * believe that it could refer to at most three version candidates:
 *
 * 1. The **active version**, the one that the user is currently browsing. See
 * {@link useActiveDocContext}.
 * 2. The **preferred version**, the one that the user last visited. See
 * {@link useDocsPreferredVersion}.
 * 3. The **latest version**, the "default". See {@link useLatestVersion}.
 *
 * @param docsPluginId The plugin ID to get versions from.
 * @returns An array of 1~3 versions with priorities defined above, guaranteed
 * to be unique and non-sparse. Will be memoized, hence stable for deps array.
 */ function useDocsVersionCandidates(docsPluginId) {
    const { activeVersion } = (0,_docusaurus_plugin_content_docs_client__rspack_import_5/* .useActiveDocContext */.zK)(docsPluginId);
    const { preferredVersion } = (0,_docsPreferredVersion__rspack_import_6/* .useDocsPreferredVersion */.g1)(docsPluginId);
    const latestVersion = (0,_docusaurus_plugin_content_docs_client__rspack_import_5/* .useLatestVersion */.r7)(docsPluginId);
    return (0,react__rspack_import_0.useMemo)(()=>(0,_docusaurus_theme_common__rspack_import_7/* .uniq */.sb)([
            activeVersion,
            preferredVersion,
            latestVersion
        ].filter(Boolean)), [
        activeVersion,
        preferredVersion,
        latestVersion
    ]);
}
/**
 * The layout components, like navbar items, must be able to work on all pages,
 * even on non-doc ones where there's no version context, so a sidebar ID could
 * be ambiguous. This hook would always return a sidebar to be linked to. See
 * also {@link useDocsVersionCandidates} for how this selection is done.
 *
 * @throws This hook throws if a sidebar with said ID is not found.
 */ function useLayoutDocsSidebar(sidebarId, docsPluginId) {
    const versions = useDocsVersionCandidates(docsPluginId);
    return (0,react__rspack_import_0.useMemo)(()=>{
        const allSidebars = versions.flatMap((version)=>version.sidebars ? Object.entries(version.sidebars) : []);
        const sidebarEntry = allSidebars.find((sidebar)=>sidebar[0] === sidebarId);
        if (!sidebarEntry) {
            throw new Error(`Can't find any sidebar with id "${sidebarId}" in version${versions.length > 1 ? 's' : ''} ${versions.map((version)=>version.name).join(', ')}".
Available sidebar ids are:
- ${allSidebars.map((entry)=>entry[0]).join('\n- ')}`);
        }
        return sidebarEntry[1];
    }, [
        sidebarId,
        versions
    ]);
}
/**
 * The layout components, like navbar items, must be able to work on all pages,
 * even on non-doc ones where there's no version context, so a doc ID could be
 * ambiguous. This hook would always return a doc to be linked to. See also
 * {@link useDocsVersionCandidates} for how this selection is done.
 *
 * @throws This hook throws if a doc with said ID is not found.
 */ function useLayoutDoc(docId, docsPluginId) {
    const versions = useDocsVersionCandidates(docsPluginId);
    return (0,react__rspack_import_0.useMemo)(()=>{
        const allDocs = versions.flatMap((version)=>version.docs);
        const doc = allDocs.find((versionDoc)=>versionDoc.id === docId);
        if (!doc) {
            const isDraft = versions.flatMap((version)=>version.draftIds).includes(docId);
            // Drafts should be silently filtered instead of throwing
            if (isDraft) {
                return null;
            }
            throw new Error(`Couldn't find any doc with id "${docId}" in version${versions.length > 1 ? 's' : ''} "${versions.map((version)=>version.name).join(', ')}".
Available doc ids are:
- ${(0,_docusaurus_theme_common__rspack_import_7/* .uniq */.sb)(allDocs.map((versionDoc)=>versionDoc.id)).join('\n- ')}`);
        }
        return doc;
    }, [
        docId,
        versions
    ]);
}
// TODO later read version/route directly from context
/**
 * The docs plugin creates nested routes, with the top-level route providing the
 * version metadata, and the subroutes creating individual doc pages. This hook
 * will match the current location against all known sub-routes.
 *
 * @param props The props received by `@theme/DocRoot`
 * @returns The data of the relevant document at the current location, or `null`
 * if no document associated with the current location can be found.
 */ function useDocRootMetadata({ route }) {
    const location = (0,_docusaurus_router__rspack_import_2/* .useLocation */.zy)();
    const versionMetadata = (0,_docsVersion__rspack_import_1/* .useDocsVersion */.r)();
    const docRoutes = route.routes;
    const currentDocRoute = docRoutes.find((docRoute)=>(0,_docusaurus_router__rspack_import_2/* .matchPath */.B6)(location.pathname, docRoute));
    if (!currentDocRoute) {
        return null;
    }
    // For now, the sidebarName is added as route config: not ideal!
    const sidebarName = currentDocRoute.sidebar;
    const sidebarItems = sidebarName ? versionMetadata.docsSidebars[sidebarName] : undefined;
    const docElement = (0,_docusaurus_renderRoutes__rspack_import_8/* .renderRoutes */.v)(docRoutes);
    return {
        docElement,
        sidebarName,
        sidebarItems
    };
}
/**
 * Filter items we don't want to display on the doc card list view
 * @param items
 */ function filterDocCardListItems(items) {
    return items.filter((item)=>{
        const canHaveLink = item.type === 'category' || item.type === 'link';
        if (canHaveLink) {
            return !!findFirstSidebarItemLink(item);
        }
        return true;
    });
}


}),
70921: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  n: () => (DocsVersionProvider),
  r: () => (useDocsVersion)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _docusaurus_theme_common_internal__rspack_import_2 = __webpack_require__(52260);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


const Context = /*#__PURE__*/ react__rspack_import_1.createContext(null);
/**
 * Provide the current version's metadata to your children.
 */ function DocsVersionProvider({ children, version }) {
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(Context.Provider, {
        value: version,
        children: children
    });
}
/**
 * Gets the version metadata of the current doc page.
 */ function useDocsVersion() {
    const version = (0,react__rspack_import_1.useContext)(Context);
    if (version === null) {
        throw new _docusaurus_theme_common_internal__rspack_import_2/* .ReactContextError */.dV('DocsVersionProvider');
    }
    return version;
}


}),
88209: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  gk: () => (/* binding */ useActivePluginAndVersion),
  r7: () => (/* binding */ useLatestVersion),
  $S: () => (/* reexport */ docsUtils/* .useCurrentSidebarCategory */.$S),
  HW: () => (/* binding */ useDocVersionSuggestions),
  zK: () => (/* binding */ useActiveDocContext),
  ir: () => (/* binding */ useActiveVersion),
  vF: () => (/* reexport */ docsSearch/* .useDocsContextualSearchTags */.v),
  vT: () => (/* binding */ useActivePlugin),
  g1: () => (/* reexport */ docsPreferredVersion/* .useDocsPreferredVersion */.g1),
  d1: () => (/* reexport */ docsUtils/* .filterDocCardListItems */.d1),
  jh: () => (/* binding */ useVersions),
  Gy: () => (/* binding */ useAllDocsData),
  ht: () => (/* binding */ useDocsData)
});

// UNUSED EXPORTS: isActiveSidebarItem, useDoc, useDocById, useDocSidebarItemsExpandedState, useDocsSidebar, useDocsVersion, useLayoutDocsSidebar, isVisibleSidebarItem, getDocsVersionSearchTag, useSidebarBreadcrumbs, DocsPreferredVersionContextProvider, DocSidebarItemsExpandedStateProvider, DocsSidebarProvider, useDocsVersionCandidates, useLayoutDoc, useDocsPreferredVersionByPluginId, useVisibleSidebarItems, useDocRootMetadata, useBreadcrumbsStructuredData, findFirstSidebarItemLink, DocsVersionProvider, DocProvider, useCurrentSidebarSiblings, findSidebarCategory

// EXTERNAL MODULE: ./node_modules/react-router/esm/react-router.js
var react_router = __webpack_require__(56347);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/useGlobalData.js
var useGlobalData = __webpack_require__(99044);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/plugin-content-docs/lib/client/docsClientUtils.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 
// This code is not part of the api surface, not in ./theme on purpose
// get the data of the plugin that is currently "active"
// ie the docs of that plugin are currently browsed
// it is useful to support multiple docs plugin instances
function getActivePlugin(allPluginData, pathname, options = {}) {
    const activeEntry = Object.entries(allPluginData)// Route sorting: '/android/foo' should match '/android' instead of '/'
    .sort((a, b)=>b[1].path.localeCompare(a[1].path)).find(([, pluginData])=>!!(0,react_router/* .matchPath */.B6)(pathname, {
            path: pluginData.path,
            exact: false,
            strict: false
        }));
    const activePlugin = activeEntry ? {
        pluginId: activeEntry[0],
        pluginData: activeEntry[1]
    } : undefined;
    if (!activePlugin && options.failfast) {
        throw new Error(`Can't find active docs plugin for "${pathname}" pathname, while it was expected to be found. Maybe you tried to use a docs feature that can only be used on a docs-related page? Existing docs plugin paths are: ${Object.values(allPluginData).map((plugin)=>plugin.path).join(', ')}`);
    }
    return activePlugin;
}
const getLatestVersion = (data)=>data.versions.find((version)=>version.isLast);
function getActiveVersion(data, pathname) {
    // Sort paths so that a match-all version like /docs/* is matched last
    // Otherwise /docs/* would match /docs/1.0.0/* routes
    // This is simplified but similar to the core sortRoutes() logic
    const sortedVersions = [
        ...data.versions
    ].sort((a, b)=>{
        if (a.path === b.path) {
            return 0;
        }
        if (a.path.includes(b.path)) {
            return -1;
        }
        if (b.path.includes(a.path)) {
            return 1;
        }
        return 0;
    });
    return sortedVersions.find((version)=>!!(0,react_router/* .matchPath */.B6)(pathname, {
            path: version.path,
            exact: false,
            strict: false
        }));
}
function getActiveDocContext(data, pathname) {
    const activeVersion = getActiveVersion(data, pathname);
    const activeDoc = activeVersion?.docs.find((doc)=>!!(0,react_router/* .matchPath */.B6)(pathname, {
            path: doc.path,
            exact: true,
            strict: false
        }));
    function getAlternateVersionDocs(docId) {
        const result = {};
        data.versions.forEach((version)=>{
            version.docs.forEach((doc)=>{
                if (doc.id === docId) {
                    result[version.name] = doc;
                }
            });
        });
        return result;
    }
    const alternateVersionDocs = activeDoc ? getAlternateVersionDocs(activeDoc.id) : {};
    return {
        activeVersion,
        activeDoc,
        alternateDocVersions: alternateVersionDocs
    };
}
function getDocVersionSuggestions(data, pathname) {
    const latestVersion = getLatestVersion(data);
    const activeDocContext = getActiveDocContext(data, pathname);
    const latestDocSuggestion = activeDocContext.alternateDocVersions[latestVersion.name];
    return {
        latestDocSuggestion,
        latestVersionSuggestion: latestVersion
    };
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/plugin-content-docs/lib/client/docsUtils.js
var docsUtils = __webpack_require__(88260);
// EXTERNAL MODULE: ./node_modules/@docusaurus/plugin-content-docs/lib/client/docsPreferredVersion.js
var docsPreferredVersion = __webpack_require__(42086);
// EXTERNAL MODULE: ./node_modules/@docusaurus/plugin-content-docs/lib/client/docsSearch.js
var docsSearch = __webpack_require__(7021);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/plugin-content-docs/lib/client/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 











// Important to use a constant object to avoid React useEffect executions etc.
// see https://github.com/facebook/docusaurus/issues/5089
const StableEmptyObject = {};
// In blog-only mode, docs hooks are still used by the theme. We need a fail-
// safe fallback when the docs plugin is not in use
const useAllDocsData = ()=>(0,useGlobalData/* .useAllPluginInstancesData */.kh)('docusaurus-plugin-content-docs') ?? StableEmptyObject;
const useDocsData = (pluginId)=>{
    try {
        return (0,useGlobalData/* .usePluginData */.P_)('docusaurus-plugin-content-docs', pluginId, {
            failfast: true
        });
    } catch (error) {
        throw new Error(`You are using a feature of the Docusaurus docs plugin, but this plugin does not seem to be enabled${pluginId === 'Default' ? '' : ` (pluginId=${pluginId}`}`, {
            cause: error
        });
    }
};
// TODO this feature should be provided by docusaurus core
function useActivePlugin(options = {}) {
    const data = useAllDocsData();
    const { pathname } = (0,react_router/* .useLocation */.zy)();
    return getActivePlugin(data, pathname, options);
}
function useActivePluginAndVersion(options = {}) {
    const activePlugin = useActivePlugin(options);
    const { pathname } = (0,react_router/* .useLocation */.zy)();
    if (!activePlugin) {
        return undefined;
    }
    const activeVersion = getActiveVersion(activePlugin.pluginData, pathname);
    return {
        activePlugin,
        activeVersion
    };
}
/** Versions are returned ordered (most recent first). */ function useVersions(pluginId) {
    const data = useDocsData(pluginId);
    return data.versions;
}
function useLatestVersion(pluginId) {
    const data = useDocsData(pluginId);
    return getLatestVersion(data);
}
/**
 * Returns `undefined` on doc-unrelated pages, because there's no version
 * currently considered as active.
 */ function useActiveVersion(pluginId) {
    const data = useDocsData(pluginId);
    const { pathname } = (0,react_router/* .useLocation */.zy)();
    return getActiveVersion(data, pathname);
}
function useActiveDocContext(pluginId) {
    const data = useDocsData(pluginId);
    const { pathname } = (0,react_router/* .useLocation */.zy)();
    return getActiveDocContext(data, pathname);
}
/**
 * Useful to say "hey, you are not on the latest docs version, please switch"
 */ function useDocVersionSuggestions(pluginId) {
    const data = useDocsData(pluginId);
    const { pathname } = (0,react_router/* .useLocation */.zy)();
    return getDocVersionSuggestions(data, pathname);
}


}),
33678: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  "default": () => (__rspack_default_export)
});
/* import */ var nprogress__rspack_import_0 = __webpack_require__(5947);
/* import */ var nprogress__rspack_import_0_default = /*#__PURE__*/__webpack_require__.n(nprogress__rspack_import_0);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

nprogress__rspack_import_0_default().configure({
    showSpinner: false
});
const delay = 200;
const clientModule = {
    onRouteUpdate ({ location, previousLocation }) {
        if (previousLocation && location.pathname !== previousLocation.pathname) {
            const progressBarTimeout = window.setTimeout(()=>{
                nprogress__rspack_import_0_default().start();
            }, delay);
            return ()=>window.clearTimeout(progressBarTimeout);
        }
        return undefined;
    },
    onRouteDidUpdate () {
        nprogress__rspack_import_0_default().done();
    }
};
/* export default */ const __rspack_default_export = (clientModule);


}),
32489: (function (__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) {
"use strict";

// EXTERNAL MODULE: ./node_modules/prism-react-renderer/dist/index.mjs
var dist = __webpack_require__(71765);
// EXTERNAL MODULE: ./.docusaurus/docusaurus.config.mjs
var docusaurus_config = __webpack_require__(4784);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/prism-include-languages.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 
function prismIncludeLanguages(PrismObject) {
    const { themeConfig: { prism } } = docusaurus_config/* ["default"] */.A;
    const { additionalLanguages } = prism;
    // Prism components work on the Prism instance on the window, while prism-
    // react-renderer uses its own Prism instance. We temporarily mount the
    // instance onto window, import components to enhance it, then remove it to
    // avoid polluting global namespace.
    // You can mutate PrismObject: registering plugins, deleting languages... As
    // long as you don't re-assign it
    const PrismBefore = globalThis.Prism;
    globalThis.Prism = PrismObject;
    additionalLanguages.forEach((lang)=>{
        if (lang === 'php') {
            // eslint-disable-next-line global-require
            __webpack_require__(19700);
        }
        // eslint-disable-next-line global-require, import/no-dynamic-require
        __webpack_require__(75166)(`./prism-${lang}`);
    });
    // Clean up and eventually restore former globalThis.Prism object (if any)
    delete globalThis.Prism;
    if (typeof PrismBefore !== 'undefined') {
        globalThis.Prism = PrismObject;
    }
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/prism-include-languages.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

prismIncludeLanguages(dist/* .Prism */.My);


}),
72072: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (Heading)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var clsx__rspack_import_6 = __webpack_require__(34164);
/* import */ var _docusaurus_Translate__rspack_import_2 = __webpack_require__(30568);
/* import */ var _docusaurus_theme_common__rspack_import_5 = __webpack_require__(34727);
/* import */ var _docusaurus_Link__rspack_import_3 = __webpack_require__(95310);
/* import */ var _docusaurus_useBrokenLinks__rspack_import_4 = __webpack_require__(55916);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 







function Heading({ as: As, id, ...props }) {
    const brokenLinks = (0,_docusaurus_useBrokenLinks__rspack_import_4/* ["default"] */.A)();
    const anchorTargetClassName = (0,_docusaurus_theme_common__rspack_import_5/* .useAnchorTargetClassName */.v)(id);
    // H1 headings do not need an id because they don't appear in the TOC.
    if (As === 'h1' || !id) {
        return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(As, {
            ...props,
            id: undefined
        });
    }
    brokenLinks.collectAnchor(id);
    const anchorTitle = (0,_docusaurus_Translate__rspack_import_2/* .translate */.T)({
        id: 'theme.common.headingLinkTitle',
        message: 'Direct link to {heading}',
        description: 'Title for link to heading'
    }, {
        heading: typeof props.children === 'string' ? props.children : id
    });
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsxs)(As, {
        ...props,
        className: (0,clsx__rspack_import_6/* ["default"] */.A)('anchor', anchorTargetClassName, props.className),
        id: id,
        children: [
            props.children,
            /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(_docusaurus_Link__rspack_import_3/* ["default"] */.A, {
                className: "hash-link",
                to: `#${id}`,
                "aria-label": anchorTitle,
                title: anchorTitle,
                translate: "no",
                children: "​"
            })
        ]
    });
}


}),
37715: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ IconExternalLink)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(74848);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/Translate.js + 1 modules
var Translate = __webpack_require__(30568);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Icon/ExternalLink/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const styles_module = ({"iconExternalLink":"iconExternalLink_nPIU"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Icon/ExternalLink/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



// References symbol in docusaurus-theme-classic/src/inlineSvgSprites.ts
// See why: https://github.com/facebook/docusaurus/issues/5865
const svgSprite = '#theme-svg-external-link';
function IconExternalLink({ width = 13.5, height = 13.5 }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("svg", {
        width: width,
        height: height,
        "aria-label": (0,Translate/* .translate */.T)({
            id: 'theme.IconExternalLink.ariaLabel',
            message: '(opens in new tab)',
            description: 'The ARIA label for the external link icon'
        }),
        className: styles_module.iconExternalLink,
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)("use", {
            href: svgSprite
        })
    });
}


}),
16099: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ Layout)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(74848);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/clsx/dist/clsx.mjs
var clsx = __webpack_require__(34164);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/ErrorBoundary.js + 1 modules
var ErrorBoundary = __webpack_require__(11701);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/metadataUtils.js
var metadataUtils = __webpack_require__(34308);
// EXTERNAL MODULE: ./node_modules/react-router/esm/react-router.js
var react_router = __webpack_require__(56347);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/Translate.js + 1 modules
var Translate = __webpack_require__(30568);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/useLocationChange.js
var useLocationChange = __webpack_require__(98398);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/skipToContentUtils.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




/**
 * The id of the element that should become focused on a page
 * that does not have a <main> html tag.
 * Focusing the Docusaurus Layout children is a reasonable fallback.
 *
 * __ prefix allows search crawlers (Algolia/DocSearch) to ignore anchors
 * https://github.com/facebook/docusaurus/issues/8883#issuecomment-1516328368
 */ const SkipToContentFallbackId = '__docusaurus_skipToContent_fallback';
/**
 * Returns the skip to content element to focus when the link is clicked.
 */ function getSkipToContentTarget() {
    return(// Try to focus the <main> in priority
    // Note: this will only work if JS is enabled
    // See https://github.com/facebook/docusaurus/issues/6411#issuecomment-1284136069
    document.querySelector('main:first-of-type') ?? // Then try to focus the fallback element (usually the Layout children)
    document.getElementById(SkipToContentFallbackId));
}
function programmaticFocus(el) {
    el.setAttribute('tabindex', '-1');
    el.focus();
    el.removeAttribute('tabindex');
}
/** This hook wires the logic for a skip-to-content link. */ function useSkipToContent() {
    const containerRef = (0,react.useRef)(null);
    const { action } = (0,react_router/* .useHistory */.W6)();
    const onClick = (0,react.useCallback)((e)=>{
        e.preventDefault();
        const targetElement = getSkipToContentTarget();
        if (targetElement) {
            programmaticFocus(targetElement);
        }
    }, []);
    // "Reset" focus when navigating.
    // See https://github.com/facebook/docusaurus/pull/8204#issuecomment-1276547558
    (0,useLocationChange/* .useLocationChange */.$)(({ location })=>{
        if (containerRef.current && !location.hash && action === 'PUSH') {
            programmaticFocus(containerRef.current);
        }
    });
    return {
        containerRef,
        onClick
    };
}
const DefaultSkipToContentLabel = (0,Translate/* .translate */.T)({
    id: 'theme.common.skipToMainContent',
    description: 'The skip to content label used for accessibility, allowing to rapidly navigate to main content with keyboard tab/enter navigation',
    message: 'Skip to main content'
});
function SkipToContentLink(props) {
    const linkLabel = props.children ?? DefaultSkipToContentLabel;
    const { containerRef, onClick } = useSkipToContent();
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
        ref: containerRef,
        role: "region",
        "aria-label": DefaultSkipToContentLabel,
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)("a", {
            ...props,
            // Note this is a fallback href in case JS is disabled
            // It has limitations, see https://github.com/facebook/docusaurus/issues/6411#issuecomment-1284136069
            href: `#${SkipToContentFallbackId}`,
            onClick: onClick,
            children: linkLabel
        })
    });
} //# sourceMappingURL=skipToContentUtils.js.map

// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/ThemeClassNames.js
var ThemeClassNames = __webpack_require__(88287);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/hooks/useKeyboardNavigation.js + 1 modules
var useKeyboardNavigation = __webpack_require__(23433);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/SkipToContent/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const styles_module = ({"skipToContent":"skipToContent_fXgn"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/SkipToContent/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



function SkipToContent() {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(SkipToContentLink, {
        className: styles_module.skipToContent
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/useThemeConfig.js
var useThemeConfig = __webpack_require__(61022);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/contexts/announcementBar.js
var contexts_announcementBar = __webpack_require__(63337);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Icon/Close/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

function IconClose({ width = 21, height = 21, color = 'currentColor', strokeWidth = 1.2, className, ...restProps }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("svg", {
        viewBox: "0 0 15 15",
        width: width,
        height: height,
        ...restProps,
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)("g", {
            stroke: color,
            strokeWidth: strokeWidth,
            children: /*#__PURE__*/ (0,jsx_runtime.jsx)("path", {
                d: "M.75.75l13.5 13.5M14.25.75L.75 14.25"
            })
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/AnnouncementBar/CloseButton/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const CloseButton_styles_module = ({"closeButton":"closeButton_CVFx"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/AnnouncementBar/CloseButton/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 





function AnnouncementBarCloseButton(props) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("button", {
        type: "button",
        "aria-label": (0,Translate/* .translate */.T)({
            id: 'theme.AnnouncementBar.closeButtonAriaLabel',
            message: 'Close',
            description: 'The ARIA label for close button of announcement bar'
        }),
        ...props,
        className: (0,clsx/* ["default"] */.A)('clean-btn close', CloseButton_styles_module.closeButton, props.className),
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(IconClose, {
            width: 14,
            height: 14,
            strokeWidth: 3.1
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/AnnouncementBar/Content/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const Content_styles_module = ({"content":"content_knG7"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/AnnouncementBar/Content/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




function AnnouncementBarContent(props) {
    const { announcementBar } = (0,useThemeConfig/* .useThemeConfig */.p)();
    const { content } = announcementBar;
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
        ...props,
        className: (0,clsx/* ["default"] */.A)(Content_styles_module.content, props.className),
        // Developer provided the HTML, so assume it's safe.
        // eslint-disable-next-line react/no-danger
        dangerouslySetInnerHTML: {
            __html: content
        }
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/AnnouncementBar/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const AnnouncementBar_styles_module = ({"announcementBar":"announcementBar_mb4j","announcementBarPlaceholder":"announcementBarPlaceholder_vyr4","announcementBarClose":"announcementBarClose_gvF7","announcementBarContent":"announcementBarContent_xLdY"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/AnnouncementBar/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 







function AnnouncementBar() {
    const { announcementBar } = (0,useThemeConfig/* .useThemeConfig */.p)();
    const { isActive, close } = (0,contexts_announcementBar/* .useAnnouncementBar */.M)();
    if (!isActive) {
        return null;
    }
    const { backgroundColor, textColor, isCloseable } = announcementBar;
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
        className: (0,clsx/* ["default"] */.A)(ThemeClassNames/* .ThemeClassNames.announcementBar.container */.G.announcementBar.container, AnnouncementBar_styles_module.announcementBar),
        style: {
            backgroundColor,
            color: textColor
        },
        role: "banner",
        children: [
            isCloseable && /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
                className: AnnouncementBar_styles_module.announcementBarPlaceholder
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(AnnouncementBarContent, {
                className: AnnouncementBar_styles_module.announcementBarContent
            }),
            isCloseable && /*#__PURE__*/ (0,jsx_runtime.jsx)(AnnouncementBarCloseButton, {
                onClick: close,
                className: AnnouncementBar_styles_module.announcementBarClose
            })
        ]
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/contexts/navbarMobileSidebar.js
var navbarMobileSidebar = __webpack_require__(29965);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/scrollUtils.js
var scrollUtils = __webpack_require__(28584);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/hooks/useHideableNavbar.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


/**
 * Wires the imperative logic of a hideable navbar.
 * @param hideOnScroll If `false`, this hook is basically a no-op.
 */ function useHideableNavbar(hideOnScroll) {
    const [isNavbarVisible, setIsNavbarVisible] = (0,react.useState)(hideOnScroll);
    const isFocusedAnchor = (0,react.useRef)(false);
    const navbarHeight = (0,react.useRef)(0);
    const navbarRef = (0,react.useCallback)((node)=>{
        if (node !== null) {
            navbarHeight.current = node.getBoundingClientRect().height;
        }
    }, []);
    (0,scrollUtils/* .useScrollPosition */.Mq)(({ scrollY: scrollTop }, lastPosition)=>{
        if (!hideOnScroll) {
            return;
        }
        // Needed mostly for handling rubber band scrolling.
        // See https://github.com/facebook/docusaurus/pull/5721
        if (scrollTop < navbarHeight.current) {
            setIsNavbarVisible(true);
            return;
        }
        if (isFocusedAnchor.current) {
            isFocusedAnchor.current = false;
            return;
        }
        const lastScrollTop = lastPosition?.scrollY;
        const documentHeight = document.documentElement.scrollHeight - navbarHeight.current;
        const windowHeight = window.innerHeight;
        if (lastScrollTop && scrollTop >= lastScrollTop) {
            setIsNavbarVisible(false);
        } else if (scrollTop + windowHeight < documentHeight) {
            setIsNavbarVisible(true);
        }
    });
    (0,useLocationChange/* .useLocationChange */.$)((locationChangeEvent)=>{
        if (!hideOnScroll) {
            return;
        }
        // See https://github.com/facebook/docusaurus/pull/8059#issuecomment-1239639480
        const currentHash = locationChangeEvent.location.hash;
        const currentHashAnchor = currentHash ? document.getElementById(currentHash.substring(1)) : undefined;
        if (currentHashAnchor) {
            isFocusedAnchor.current = true;
            setIsNavbarVisible(false);
            return;
        }
        setIsNavbarVisible(true);
    });
    return {
        navbarRef,
        isNavbarVisible
    };
} //# sourceMappingURL=useHideableNavbar.js.map

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/hooks/useLockBodyScroll.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 
/**
 * Side-effect that locks the document body's scroll throughout the lifetime of
 * the containing component. e.g. when the mobile sidebar is expanded.
 */ function useLockBodyScroll(lock = true) {
    (0,react.useEffect)(()=>{
        document.body.style.overflow = lock ? 'hidden' : 'visible';
        return ()=>{
            document.body.style.overflow = 'visible';
        };
    }, [
        lock
    ]);
} //# sourceMappingURL=useLockBodyScroll.js.map

// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/reactUtils.js
var reactUtils = __webpack_require__(52260);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/contexts/navbarSecondaryMenu/content.js
var navbarSecondaryMenu_content = __webpack_require__(17000);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/contexts/navbarSecondaryMenu/display.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




const Context = /*#__PURE__*/ react.createContext(null);
function useContextValue() {
    const mobileSidebar = (0,navbarMobileSidebar/* .useNavbarMobileSidebar */.M)();
    const content = (0,navbarSecondaryMenu_content/* .useNavbarSecondaryMenuContent */.YL)();
    const [shown, setShown] = (0,react.useState)(false);
    const hasContent = content.component !== null;
    const previousHasContent = (0,reactUtils/* .usePrevious */.ZC)(hasContent);
    // When content is become available for the first time (set in useEffect)
    // we set this content to be shown!
    (0,react.useEffect)(()=>{
        const contentBecameAvailable = hasContent && !previousHasContent;
        if (contentBecameAvailable) {
            setShown(true);
        }
    }, [
        hasContent,
        previousHasContent
    ]);
    // On sidebar close, secondary menu is set to be shown on next re-opening
    // (if any secondary menu content available)
    (0,react.useEffect)(()=>{
        if (!hasContent) {
            setShown(false);
            return;
        }
        if (!mobileSidebar.shown) {
            setShown(true);
        }
    }, [
        mobileSidebar.shown,
        hasContent
    ]);
    return (0,react.useMemo)(()=>[
            shown,
            setShown
        ], [
        shown
    ]);
}
/** @internal */ function NavbarSecondaryMenuDisplayProvider({ children }) {
    const value = useContextValue();
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(Context.Provider, {
        value: value,
        children: children
    });
}
function renderElement(content) {
    if (content.component) {
        const Comp = content.component;
        return /*#__PURE__*/ (0,jsx_runtime.jsx)(Comp, {
            ...content.props
        });
    }
    return undefined;
}
/** Wires the logic for rendering the mobile navbar secondary menu. */ function useNavbarSecondaryMenu() {
    const value = (0,react.useContext)(Context);
    if (!value) {
        throw new reactUtils/* .ReactContextError */.dV('NavbarSecondaryMenuDisplayProvider');
    }
    const [shown, setShown] = value;
    const hide = (0,react.useCallback)(()=>setShown(false), [
        setShown
    ]);
    const content = (0,navbarSecondaryMenu_content/* .useNavbarSecondaryMenuContent */.YL)();
    return (0,react.useMemo)(()=>({
            shown,
            hide,
            content: renderElement(content)
        }), [
        hide,
        content,
        shown
    ]);
} //# sourceMappingURL=display.js.map

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/MobileSidebar/Layout/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




// TODO Docusaurus v4: remove temporary inert workaround
//  See https://github.com/facebook/react/issues/17157
//  See https://github.com/radix-ui/themes/pull/509
function inertProps(inert) {
    const isBeforeReact19 = parseInt(react.version.split('.')[0], 10) < 19;
    if (isBeforeReact19) {
        return {
            inert: inert ? '' : undefined
        };
    }
    return {
        inert
    };
}
function NavbarMobileSidebarPanel({ children, inert }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
        className: (0,clsx/* ["default"] */.A)(ThemeClassNames/* .ThemeClassNames.layout.navbar.mobileSidebar.panel */.G.layout.navbar.mobileSidebar.panel, 'navbar-sidebar__item menu'),
        ...inertProps(inert),
        children: children
    });
}
function NavbarMobileSidebarLayout({ header, primaryMenu, secondaryMenu }) {
    const { shown: secondaryMenuShown } = useNavbarSecondaryMenu();
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
        className: (0,clsx/* ["default"] */.A)(ThemeClassNames/* .ThemeClassNames.layout.navbar.mobileSidebar.container */.G.layout.navbar.mobileSidebar.container, 'navbar-sidebar'),
        children: [
            header,
            /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
                className: (0,clsx/* ["default"] */.A)('navbar-sidebar__items', {
                    'navbar-sidebar__items--show-secondary': secondaryMenuShown
                }),
                children: [
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarMobileSidebarPanel, {
                        inert: secondaryMenuShown,
                        children: primaryMenu
                    }),
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarMobileSidebarPanel, {
                        inert: !secondaryMenuShown,
                        children: secondaryMenu
                    })
                ]
            })
        ]
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/contexts/colorMode.js
var contexts_colorMode = __webpack_require__(83941);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/useIsBrowser.js
var useIsBrowser = __webpack_require__(19863);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Icon/LightMode/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

function IconLightMode(props) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("svg", {
        viewBox: "0 0 24 24",
        width: 24,
        height: 24,
        ...props,
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)("path", {
            fill: "currentColor",
            d: "M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Icon/DarkMode/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

function IconDarkMode(props) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("svg", {
        viewBox: "0 0 24 24",
        width: 24,
        height: 24,
        ...props,
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)("path", {
            fill: "currentColor",
            d: "M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Icon/SystemColorMode/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 
function IconSystemColorMode(props) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("svg", {
        viewBox: "0 0 24 24",
        width: 24,
        height: 24,
        ...props,
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)("path", {
            fill: "currentColor",
            d: "m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/ColorModeToggle/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const ColorModeToggle_styles_module = ({"toggle":"toggle_vylO","toggleButton":"toggleButton_gllP","toggleIcon":"toggleIcon_g3eP","systemToggleIcon":"systemToggleIcon_QzmC","lightToggleIcon":"lightToggleIcon_pyhR","darkToggleIcon":"darkToggleIcon_wfgR","toggleButtonDisabled":"toggleButtonDisabled_aARS"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/ColorModeToggle/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 








// The order of color modes is defined here, and can be customized with swizzle
function getNextColorMode(colorMode, respectPrefersColorScheme) {
    // 2-value transition
    if (!respectPrefersColorScheme) {
        return colorMode === 'dark' ? 'light' : 'dark';
    }
    // 3-value transition
    switch(colorMode){
        case null:
            return 'light';
        case 'light':
            return 'dark';
        case 'dark':
            return null;
        default:
            throw new Error(`unexpected color mode ${colorMode}`);
    }
}
function getColorModeLabel(colorMode) {
    switch(colorMode){
        case null:
            return (0,Translate/* .translate */.T)({
                message: 'system mode',
                id: 'theme.colorToggle.ariaLabel.mode.system',
                description: 'The name for the system color mode'
            });
        case 'light':
            return (0,Translate/* .translate */.T)({
                message: 'light mode',
                id: 'theme.colorToggle.ariaLabel.mode.light',
                description: 'The name for the light color mode'
            });
        case 'dark':
            return (0,Translate/* .translate */.T)({
                message: 'dark mode',
                id: 'theme.colorToggle.ariaLabel.mode.dark',
                description: 'The name for the dark color mode'
            });
        default:
            throw new Error(`unexpected color mode ${colorMode}`);
    }
}
function getColorModeAriaLabel(colorMode) {
    return (0,Translate/* .translate */.T)({
        message: 'Switch between dark and light mode (currently {mode})',
        id: 'theme.colorToggle.ariaLabel',
        description: 'The ARIA label for the color mode toggle'
    }, {
        mode: getColorModeLabel(colorMode)
    });
}
function CurrentColorModeIcon() {
    // 3 icons are always rendered for technical reasons
    // We use "data-theme-choice" to render the correct one
    // This must work even before React hydrates
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsx)(IconLightMode, {
                // a18y is handled at the button level,
                // not relying on button content (svg icons)
                "aria-hidden": true,
                className: (0,clsx/* ["default"] */.A)(ColorModeToggle_styles_module.toggleIcon, ColorModeToggle_styles_module.lightToggleIcon)
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(IconDarkMode, {
                "aria-hidden": true,
                className: (0,clsx/* ["default"] */.A)(ColorModeToggle_styles_module.toggleIcon, ColorModeToggle_styles_module.darkToggleIcon)
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(IconSystemColorMode, {
                "aria-hidden": true,
                className: (0,clsx/* ["default"] */.A)(ColorModeToggle_styles_module.toggleIcon, ColorModeToggle_styles_module.systemToggleIcon)
            })
        ]
    });
}
function ColorModeToggle({ className, buttonClassName, respectPrefersColorScheme, value, onChange }) {
    const isBrowser = (0,useIsBrowser/* ["default"] */.A)();
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
        className: (0,clsx/* ["default"] */.A)(ColorModeToggle_styles_module.toggle, className),
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)("button", {
            className: (0,clsx/* ["default"] */.A)('clean-btn', ColorModeToggle_styles_module.toggleButton, !isBrowser && ColorModeToggle_styles_module.toggleButtonDisabled, buttonClassName),
            type: "button",
            onClick: ()=>onChange(getNextColorMode(value, respectPrefersColorScheme)),
            disabled: !isBrowser,
            title: getColorModeLabel(value),
            "aria-label": getColorModeAriaLabel(value),
            children: /*#__PURE__*/ (0,jsx_runtime.jsx)(CurrentColorModeIcon, {})
        })
    });
}
/* export default */ const theme_ColorModeToggle = (/*#__PURE__*/react.memo(ColorModeToggle));

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/ColorModeToggle/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const Navbar_ColorModeToggle_styles_module = ({"darkNavbarColorModeToggle":"darkNavbarColorModeToggle_X3D1"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/ColorModeToggle/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




function NavbarColorModeToggle({ className }) {
    const navbarStyle = (0,useThemeConfig/* .useThemeConfig */.p)().navbar.style;
    const { disableSwitch, respectPrefersColorScheme } = (0,useThemeConfig/* .useThemeConfig */.p)().colorMode;
    const { colorModeChoice, setColorMode } = (0,contexts_colorMode/* .useColorMode */.G)();
    if (disableSwitch) {
        return null;
    }
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(theme_ColorModeToggle, {
        className: className,
        buttonClassName: navbarStyle === 'dark' ? Navbar_ColorModeToggle_styles_module.darkNavbarColorModeToggle : undefined,
        respectPrefersColorScheme: respectPrefersColorScheme,
        value: colorModeChoice,
        onChange: setColorMode
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Logo/index.js
var Logo = __webpack_require__(85153);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/Logo/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


function NavbarLogo() {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(Logo/* ["default"] */.A, {
        className: "navbar__brand",
        imageClassName: "navbar__logo",
        titleClassName: "navbar__title text--truncate"
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/MobileSidebar/Header/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 






function CloseButton() {
    const mobileSidebar = (0,navbarMobileSidebar/* .useNavbarMobileSidebar */.M)();
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("button", {
        type: "button",
        "aria-label": (0,Translate/* .translate */.T)({
            id: 'theme.docs.sidebar.closeSidebarButtonAriaLabel',
            message: 'Close navigation bar',
            description: 'The ARIA label for close button of mobile sidebar'
        }),
        className: "clean-btn navbar-sidebar__close",
        onClick: ()=>mobileSidebar.toggle(),
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(IconClose, {
            color: "var(--ifm-color-emphasis-600)"
        })
    });
}
function NavbarMobileSidebarHeader() {
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
        className: "navbar-sidebar__brand",
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarLogo, {}),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarColorModeToggle, {
                className: "margin-right--md"
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(CloseButton, {})
        ]
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/Link.js
var Link = __webpack_require__(95310);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/useBaseUrl.js
var useBaseUrl = __webpack_require__(66497);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/isInternalUrl.js
var isInternalUrl = __webpack_require__(58310);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/regexpUtils.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ /**
 * Matches a string regex (as provided from the config) against a target in a
 * null-safe fashion, case insensitive and global.
 */ function isRegexpStringMatch(regexAsString, valueToTest) {
    if (typeof regexAsString === 'undefined' || typeof valueToTest === 'undefined') {
        return false;
    }
    return new RegExp(regexAsString, 'gi').test(valueToTest);
} //# sourceMappingURL=regexpUtils.js.map

// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Icon/ExternalLink/index.js + 1 modules
var ExternalLink = __webpack_require__(37715);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/NavbarNavLink.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 






function NavbarNavLink({ activeBasePath, activeBaseRegex, to, href, label, html, isDropdownLink, prependBaseUrlToHref, ...props }) {
    // TODO all this seems hacky
    // {to: 'version'} should probably be forbidden, in favor of {to: '/version'}
    const toUrl = (0,useBaseUrl/* ["default"] */.Ay)(to);
    const activeBaseUrl = (0,useBaseUrl/* ["default"] */.Ay)(activeBasePath);
    const normalizedHref = (0,useBaseUrl/* ["default"] */.Ay)(href, {
        forcePrependBaseUrl: true
    });
    const isExternalLink = label && href && !(0,isInternalUrl/* ["default"] */.A)(href);
    // Link content is set through html XOR label
    const linkContentProps = html ? {
        dangerouslySetInnerHTML: {
            __html: html
        }
    } : {
        children: /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
            children: [
                label,
                isExternalLink && /*#__PURE__*/ (0,jsx_runtime.jsx)(ExternalLink/* ["default"] */.A, {
                    ...isDropdownLink && {
                        width: 12,
                        height: 12
                    }
                })
            ]
        })
    };
    if (href) {
        return /*#__PURE__*/ (0,jsx_runtime.jsx)(Link/* ["default"] */.A, {
            href: prependBaseUrlToHref ? normalizedHref : href,
            ...props,
            ...linkContentProps
        });
    }
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(Link/* ["default"] */.A, {
        to: toUrl,
        isNavLink: true,
        ...(activeBasePath || activeBaseRegex) && {
            isActive: (_match, location)=>activeBaseRegex ? isRegexpStringMatch(activeBaseRegex, location.pathname) : location.pathname.startsWith(activeBaseUrl)
        },
        ...props,
        ...linkContentProps
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/DefaultNavbarItem/Mobile/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



function DefaultNavbarItemMobile({ className, isDropdownItem, ...props }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("li", {
        className: "menu__list-item",
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarNavLink, {
            className: (0,clsx/* ["default"] */.A)('menu__link', className),
            ...props
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/DefaultNavbarItem/Desktop/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



function DefaultNavbarItemDesktop({ className, isDropdownItem = false, ...props }) {
    const element = /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarNavLink, {
        className: (0,clsx/* ["default"] */.A)(isDropdownItem ? 'dropdown__link' : 'navbar__item navbar__link', className),
        isDropdownLink: isDropdownItem,
        ...props
    });
    if (isDropdownItem) {
        return /*#__PURE__*/ (0,jsx_runtime.jsx)("li", {
            children: element
        });
    }
    return element;
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/DefaultNavbarItem/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



function DefaultNavbarItem({ mobile = false, position, ...props }) {
    const Comp = mobile ? DefaultNavbarItemMobile : DefaultNavbarItemDesktop;
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(Comp, {
        ...props,
        activeClassName: props.activeClassName ?? (mobile ? 'menu__link--active' : 'navbar__link--active')
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/components/Collapsible/index.js
var Collapsible = __webpack_require__(39510);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/routesUtils.js
var routesUtils = __webpack_require__(19209);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/useDocusaurusContext.js
var exports_useDocusaurusContext = __webpack_require__(10898);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/useLocalPathname.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

/**
 * Get the pathname of current route, without the optional site baseUrl.
 * - `/docs/myDoc` => `/docs/myDoc`
 * - `/baseUrl/docs/myDoc` => `/docs/myDoc`
 */ function useLocalPathname() {
    const { siteConfig: { baseUrl } } = (0,exports_useDocusaurusContext/* ["default"] */.A)();
    const { pathname } = (0,react_router/* .useLocation */.zy)();
    return pathname.replace(baseUrl, '/');
} //# sourceMappingURL=useLocalPathname.js.map

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/DropdownNavbarItem/Mobile/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const Mobile_styles_module = ({"dropdownNavbarItemMobile":"dropdownNavbarItemMobile_J0Sd"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/DropdownNavbarItem/Mobile/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 









function isItemActive(item, localPathname) {
    if ((0,routesUtils/* .isSamePath */.ys)(item.to, localPathname)) {
        return true;
    }
    if (isRegexpStringMatch(item.activeBaseRegex, localPathname)) {
        return true;
    }
    if (item.activeBasePath && localPathname.startsWith(item.activeBasePath)) {
        return true;
    }
    return false;
}
function containsActiveItems(items, localPathname) {
    return items.some((item)=>isItemActive(item, localPathname));
}
function CollapseButton({ collapsed, onClick }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("button", {
        "aria-label": collapsed ? (0,Translate/* .translate */.T)({
            id: 'theme.navbar.mobileDropdown.collapseButton.expandAriaLabel',
            message: 'Expand the dropdown',
            description: 'The ARIA label of the button to expand the mobile dropdown navbar item'
        }) : (0,Translate/* .translate */.T)({
            id: 'theme.navbar.mobileDropdown.collapseButton.collapseAriaLabel',
            message: 'Collapse the dropdown',
            description: 'The ARIA label of the button to collapse the mobile dropdown navbar item'
        }),
        "aria-expanded": !collapsed,
        type: "button",
        className: "clean-btn menu__caret",
        onClick: onClick
    });
}
function useItemCollapsible({ active }) {
    const { collapsed, toggleCollapsed, setCollapsed } = (0,Collapsible/* .useCollapsible */.u)({
        initialState: ()=>!active
    });
    // Expand if any item active after a navigation
    (0,react.useEffect)(()=>{
        if (active) {
            setCollapsed(false);
        }
    }, [
        active,
        setCollapsed
    ]);
    return {
        collapsed,
        toggleCollapsed
    };
}
function DropdownNavbarItemMobile({ items, className, position, onClick, ...props }) {
    const localPathname = useLocalPathname();
    const isActive = (0,routesUtils/* .isSamePath */.ys)(props.to, localPathname);
    const containsActive = containsActiveItems(items, localPathname);
    const { collapsed, toggleCollapsed } = useItemCollapsible({
        active: isActive || containsActive
    });
    // # hash permits to make the <a> tag focusable in case no link target
    // See https://github.com/facebook/docusaurus/pull/6003
    // There's probably a better solution though...
    const href = props.to ? undefined : '#';
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)("li", {
        className: (0,clsx/* ["default"] */.A)('menu__list-item', {
            'menu__list-item--collapsed': collapsed
        }),
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
                className: (0,clsx/* ["default"] */.A)('menu__list-item-collapsible', {
                    'menu__list-item-collapsible--active': isActive
                }),
                children: [
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarNavLink, {
                        role: "button",
                        className: (0,clsx/* ["default"] */.A)(Mobile_styles_module.dropdownNavbarItemMobile, 'menu__link menu__link--sublist', className),
                        href: href,
                        ...props,
                        onClick: (e)=>{
                            // Prevent navigation when link is "#"
                            if (href === '#') {
                                e.preventDefault();
                            }
                            // Otherwise we let navigation eventually happen, and/or collapse
                            toggleCollapsed();
                        },
                        children: props.children ?? props.label
                    }),
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(CollapseButton, {
                        collapsed: collapsed,
                        onClick: (e)=>{
                            e.preventDefault();
                            toggleCollapsed();
                        }
                    })
                ]
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(Collapsible/* .Collapsible */.N, {
                lazy: true,
                as: "ul",
                className: "menu__list",
                collapsed: collapsed,
                children: items.map((childItemProps, i)=>/*#__PURE__*/ (0,react.createElement)(NavbarItem, {
                        mobile: true,
                        isDropdownItem: true,
                        onClick: onClick,
                        activeClassName: "menu__link--active",
                        ...childItemProps,
                        key: i
                    }))
            })
        ]
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/DropdownNavbarItem/Desktop/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 





function DropdownNavbarItemDesktop({ items, position, className, onClick, ...props }) {
    const dropdownRef = (0,react.useRef)(null);
    const [showDropdown, setShowDropdown] = (0,react.useState)(false);
    (0,react.useEffect)(()=>{
        const handleClickOutside = (event)=>{
            if (!dropdownRef.current || dropdownRef.current.contains(event.target)) {
                return;
            }
            setShowDropdown(false);
        };
        document.addEventListener('mousedown', handleClickOutside);
        document.addEventListener('touchstart', handleClickOutside);
        document.addEventListener('focusin', handleClickOutside);
        return ()=>{
            document.removeEventListener('mousedown', handleClickOutside);
            document.removeEventListener('touchstart', handleClickOutside);
            document.removeEventListener('focusin', handleClickOutside);
        };
    }, [
        dropdownRef
    ]);
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
        ref: dropdownRef,
        className: (0,clsx/* ["default"] */.A)('navbar__item', 'dropdown', 'dropdown--hoverable', {
            'dropdown--right': position === 'right',
            'dropdown--show': showDropdown
        }),
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarNavLink, {
                "aria-haspopup": "true",
                "aria-expanded": showDropdown,
                role: "button",
                // # hash permits to make the <a> tag focusable in case no link target
                // See https://github.com/facebook/docusaurus/pull/6003
                // There's probably a better solution though...
                href: props.to ? undefined : '#',
                className: (0,clsx/* ["default"] */.A)('navbar__link', className),
                ...props,
                onClick: props.to ? undefined : (e)=>e.preventDefault(),
                onKeyDown: (e)=>{
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        setShowDropdown(!showDropdown);
                    }
                },
                children: props.children ?? props.label
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)("ul", {
                className: "dropdown__menu",
                children: items.map((childItemProps, i)=>/*#__PURE__*/ (0,react.createElement)(NavbarItem, {
                        isDropdownItem: true,
                        activeClassName: "dropdown__link--active",
                        ...childItemProps,
                        key: i
                    }))
            })
        ]
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/DropdownNavbarItem/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



function DropdownNavbarItem({ mobile = false, ...props }) {
    const Comp = mobile ? DropdownNavbarItemMobile : DropdownNavbarItemDesktop;
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(Comp, {
        ...props
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/useAlternatePageUtils.js
var useAlternatePageUtils = __webpack_require__(5243);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/historyUtils.js
var historyUtils = __webpack_require__(96629);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Icon/Language/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

function IconLanguage({ width = 20, height = 20, ...props }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("svg", {
        viewBox: "0 0 24 24",
        width: width,
        height: height,
        "aria-hidden": true,
        ...props,
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)("path", {
            fill: "currentColor",
            d: "M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/LocaleDropdownNavbarItem/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const LocaleDropdownNavbarItem_styles_module = ({"iconLanguage":"iconLanguage_nlXk"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/LocaleDropdownNavbarItem/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 








function useLocaleDropdownUtils() {
    const { siteConfig, i18n: { localeConfigs } } = (0,exports_useDocusaurusContext/* ["default"] */.A)();
    const alternatePageUtils = (0,useAlternatePageUtils/* .useAlternatePageUtils */.o)();
    const search = (0,historyUtils/* .useHistorySelector */.Hl)((history)=>history.location.search);
    const hash = (0,historyUtils/* .useHistorySelector */.Hl)((history)=>history.location.hash);
    const getLocaleConfig = (locale)=>{
        const localeConfig = localeConfigs[locale];
        if (!localeConfig) {
            throw new Error(`Docusaurus bug, no locale config found for locale=${locale}`);
        }
        return localeConfig;
    };
    const getBaseURLForLocale = (locale)=>{
        const localeConfig = getLocaleConfig(locale);
        const isSameDomain = localeConfig.url === siteConfig.url;
        if (isSameDomain) {
            // Shorter paths if localized sites are hosted on the same domain
            // This reduces HTML size a bit
            return `pathname://${alternatePageUtils.createUrl({
                locale,
                fullyQualified: false
            })}`;
        }
        return alternatePageUtils.createUrl({
            locale,
            fullyQualified: true
        });
    };
    return {
        getURL: (locale, options)=>{
            // We have 2 query strings because
            // - there's the current one
            // - there's one user can provide through navbar config
            // see https://github.com/facebook/docusaurus/pull/8915
            const finalSearch = (0,historyUtils/* .mergeSearchStrings */.jy)([
                search,
                options.queryString
            ], 'append');
            return `${getBaseURLForLocale(locale)}${finalSearch}${hash}`;
        },
        getLabel: (locale)=>{
            return getLocaleConfig(locale).label;
        },
        getLang: (locale)=>{
            return getLocaleConfig(locale).htmlLang;
        }
    };
}
function LocaleDropdownNavbarItem({ mobile, dropdownItemsBefore, dropdownItemsAfter, queryString, ...props }) {
    const utils = useLocaleDropdownUtils();
    const { i18n: { currentLocale, locales } } = (0,exports_useDocusaurusContext/* ["default"] */.A)();
    const localeItems = locales.map((locale)=>{
        return {
            label: utils.getLabel(locale),
            lang: utils.getLang(locale),
            to: utils.getURL(locale, {
                queryString
            }),
            target: '_self',
            autoAddBaseUrl: false,
            className: // eslint-disable-next-line no-nested-ternary
            locale === currentLocale ? // class name. This cannot be substituted with isActive, because the
            // target URLs contain `pathname://` and therefore are not NavLinks!
            mobile ? 'menu__link--active' : 'dropdown__link--active' : ''
        };
    });
    const items = [
        ...dropdownItemsBefore,
        ...localeItems,
        ...dropdownItemsAfter
    ];
    // Mobile is handled a bit differently
    const dropdownLabel = mobile ? (0,Translate/* .translate */.T)({
        message: 'Languages',
        id: 'theme.navbar.mobileLanguageDropdown.label',
        description: 'The label for the mobile language switcher dropdown'
    }) : utils.getLabel(currentLocale);
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(DropdownNavbarItem, {
        ...props,
        mobile: mobile,
        label: /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
            children: [
                /*#__PURE__*/ (0,jsx_runtime.jsx)(IconLanguage, {
                    className: LocaleDropdownNavbarItem_styles_module.iconLanguage
                }),
                dropdownLabel
            ]
        }),
        items: items
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/BrowserOnly.js
var BrowserOnly = __webpack_require__(9526);
// EXTERNAL MODULE: ./node_modules/@docusaurus/plugin-content-docs/lib/client/index.js + 1 modules
var lib_client = __webpack_require__(88209);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/useGlobalData.js
var useGlobalData = __webpack_require__(99044);
;// CONCATENATED MODULE: ./node_modules/pako/dist/pako.esm.mjs

/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

/* Public constants ==========================================================*/
/* ===========================================================================*/


//const Z_FILTERED          = 1;
//const Z_HUFFMAN_ONLY      = 2;
//const Z_RLE               = 3;
const Z_FIXED$1               = 4;
//const Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
const Z_BINARY              = 0;
const Z_TEXT                = 1;
//const Z_ASCII             = 1; // = Z_TEXT
const Z_UNKNOWN$1             = 2;

/*============================================================================*/


function zero$1(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES    = 2;
/* The three kinds of block type */

const MIN_MATCH$1    = 3;
const MAX_MATCH$1    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

const LENGTH_CODES$1  = 29;
/* number of length codes, not counting the special END_BLOCK code */

const LITERALS$1      = 256;
/* number of literal bytes 0..255 */

const L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;
/* number of Literal or Length codes, including the END_BLOCK code */

const D_CODES$1       = 30;
/* number of distance codes */

const BL_CODES$1      = 19;
/* number of codes used to transfer the bit lengths */

const HEAP_SIZE$1     = 2 * L_CODES$1 + 1;
/* maximum heap size */

const MAX_BITS$1      = 15;
/* All codes must not exceed MAX_BITS bits */

const Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

const MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

const END_BLOCK   = 256;
/* end of block literal code */

const REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

const REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

const REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
const extra_lbits =   /* extra bits for each length code */
  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);

const extra_dbits =   /* extra bits for each distance code */
  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);

const extra_blbits =  /* extra bits for each bit length code */
  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);

const bl_order =
  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

const DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
const static_ltree  = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

const static_dtree  = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

const _dist_code    = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

const _length_code  = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

const base_length   = new Array(LENGTH_CODES$1);
zero$1(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

const base_dist     = new Array(D_CODES$1);
zero$1(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


let static_l_desc;
let static_d_desc;
let static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



const d_code = (dist) => {

  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
const put_short = (s, w) => {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
};


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
const send_bits = (s, value, length) => {

  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
};


const send_code = (s, c, tree) => {

  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
};


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
const bi_reverse = (code, len) => {

  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
const bi_flush = (s) => {

  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
const gen_bitlen = (s, desc) => {
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */

  const tree            = desc.dyn_tree;
  const max_code        = desc.max_code;
  const stree           = desc.stat_desc.static_tree;
  const has_stree       = desc.stat_desc.has_stree;
  const extra           = desc.stat_desc.extra_bits;
  const base            = desc.stat_desc.extra_base;
  const max_length      = desc.stat_desc.max_length;
  let h;              /* heap index */
  let n, m;           /* iterate over the tree elements */
  let bits;           /* bit length */
  let xbits;          /* extra bits */
  let f;              /* frequency */
  let overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Tracev((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Tracev((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
};


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
const gen_codes = (tree, max_code, bl_count) => {
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */

  const next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */
  let code = 0;              /* running code value */
  let bits;                  /* bit index */
  let n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code = (code + bl_count[bits - 1]) << 1;
    next_code[bits] = code;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    let len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
};


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
const tr_static_init = () => {

  let n;        /* iterates over tree elements */
  let bits;     /* bit counter */
  let length;   /* length value */
  let code;     /* code value */
  let dist;     /* distance index */
  const bl_count = new Array(MAX_BITS$1 + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES$1, MAX_BL_BITS);

  //static_init_done = true;
};


/* ===========================================================================
 * Initialize a new block.
 */
const init_block = (s) => {

  let n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES$1;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES$1;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES$1; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
const bi_windup = (s) =>
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
const smaller = (tree, n, m, depth) => {

  const _n2 = n * 2;
  const _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
};

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
const pqdownheap = (s, tree, k) => {
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */

  const v = s.heap[k];
  let j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
};


// inlined manually
// const SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
const compress_block = (s, ltree, dtree) => {
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */

  let dist;           /* distance of matched string */
  let lc;             /* match length or unmatched char (if dist == 0) */
  let sx = 0;         /* running index in sym_buf */
  let code;           /* the code to send */
  let extra;          /* number of extra bits to send */

  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 0xff;
      dist += (s.pending_buf[s.sym_buf + sx++] & 0xff) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and sym_buf is ok: */
      //Assert(s->pending < s->lit_bufsize + sx, "pendingBuf overflow");

    } while (sx < s.sym_next);
  }

  send_code(s, END_BLOCK, ltree);
};


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
const build_tree = (s, desc) => {
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */

  const tree     = desc.dyn_tree;
  const stree    = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems    = desc.stat_desc.elems;
  let n, m;          /* iterate over heap elements */
  let max_code = -1; /* largest code with non zero frequency */
  let node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
};


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
const scan_tree = (s, tree, max_code) => {
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */

  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
const send_tree = (s, tree, max_code) => {
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */

  let n;                     /* iterates over all tree elements */
  let prevlen = -1;          /* last emitted length */
  let curlen;                /* length of current code */

  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  let count = 0;             /* repeat count of the current code */
  let max_count = 7;         /* max repeat count */
  let min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
const build_bl_tree = (s) => {

  let max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
};


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
const send_all_trees = (s, lcodes, dcodes, blcodes) => {
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */

  let rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
};


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "block list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "allow list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
const detect_data_type = (s) => {
  /* block_mask is the bit mask of block-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  let block_mask = 0xf3ffc07f;
  let n;

  /* Check for non-textual ("block-listed") bytes. */
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if ((block_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("allow-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "block-listed" or "allow-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
};


let static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
const _tr_init$1 = (s) =>
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
};


/* ===========================================================================
 * Send a stored block
 */
const _tr_stored_block$1 = (s, buf, stored_len, last) => {
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */

  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  bi_windup(s);        /* align on byte boundary */
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
const _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and write out the encoded block.
 */
const _tr_flush_block$1 = (s, buf, stored_len, last) => {
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */

  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  let max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->sym_next / 3));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block$1(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
};

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
const _tr_tally$1 = (s, dist, lc) => {
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */

  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

  return (s.sym_next === s.sym_end);
};

var _tr_init_1  = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1  = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;

var trees = {
	_tr_init: _tr_init_1,
	_tr_stored_block: _tr_stored_block_1,
	_tr_flush_block: _tr_flush_block_1,
	_tr_tally: _tr_tally_1,
	_tr_align: _tr_align_1
};

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const adler32 = (adler, buf, len, pos) => {
  let s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
};


var adler32_1 = adler32;

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
const makeTable = () => {
  let c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
};

// Create table on load. Just 255 signed longs. Not a problem.
const crcTable = new Uint32Array(makeTable());


const crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;

  crc ^= -1;

  for (let i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
};


var crc32_1 = crc32;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var messages = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var constants$2 = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  Z_MEM_ERROR:       -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;




/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;

/*============================================================================*/


const MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
const MAX_WBITS$1 = 15;
/* 32K LZ77 window */
const DEF_MEM_LEVEL = 8;


const LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
const LITERALS      = 256;
/* number of literal bytes 0..255 */
const L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
const D_CODES       = 30;
/* number of distance codes */
const BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
const HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
const MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

const PRESET_DICT = 0x20;

const INIT_STATE    =  42;    /* zlib header -> BUSY_STATE */
//#ifdef GZIP
const GZIP_STATE    =  57;    /* gzip header -> BUSY_STATE | EXTRA_STATE */
//#endif
const EXTRA_STATE   =  69;    /* gzip extra block -> NAME_STATE */
const NAME_STATE    =  73;    /* gzip file name -> COMMENT_STATE */
const COMMENT_STATE =  91;    /* gzip comment -> HCRC_STATE */
const HCRC_STATE    = 103;    /* gzip header CRC -> BUSY_STATE */
const BUSY_STATE    = 113;    /* deflate -> FINISH_STATE */
const FINISH_STATE  = 666;    /* stream complete */

const BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
const BS_BLOCK_DONE     = 2; /* block flush performed */
const BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
const BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

const OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

const pako_esm_err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};

const pako_esm_rank = (f) => {
  return ((f) * 2) - ((f) > 4 ? 9 : 0);
};

const zero = (buf) => {
  let len = buf.length; while (--len >= 0) { buf[len] = 0; }
};

/* ===========================================================================
 * Slide the hash table when sliding the window down (could be avoided with 32
 * bit values at the expense of memory usage). We slide even when level == 0 to
 * keep the hash table consistent if we switch back to level > 0 later.
 */
const slide_hash = (s) => {
  let n, m;
  let p;
  let wsize = s.w_size;

  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = (m >= wsize ? m - wsize : 0);
  } while (--n);
  n = wsize;
//#ifndef FASTEST
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = (m >= wsize ? m - wsize : 0);
    /* If n is not on any hash chain, prev[n] is garbage but
     * its value will never be used.
     */
  } while (--n);
//#endif
};

/* eslint-disable new-cap */
let HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;
// This hash causes less collisions, https://github.com/nodeca/pako/issues/135
// But breaks binary compatibility
//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;
let HASH = HASH_ZLIB;


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output, except for
 * some deflate_stored() output, goes through this function so some
 * applications may wish to modify it to avoid allocating a large
 * strm->next_out buffer and copying into it. (See also read_buf()).
 */
const flush_pending = (strm) => {
  const s = strm.state;

  //_tr_flush_bits(s);
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out  += len;
  s.pending_out  += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending      -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};


const flush_block_only = (s, last) => {
  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};


const put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
const putShortMSB = (s, b) => {

  //  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
};


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
const read_buf = (strm, buf, start, size) => {

  let len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
};


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
const longest_match = (s, cur_match) => {

  let chain_length = s.max_chain_length;      /* max hash chain length */
  let scan = s.strstart; /* current string */
  let match;                       /* matched string */
  let len;                           /* length of current match */
  let best_len = s.prev_length;              /* best match length so far */
  let nice_match = s.nice_match;             /* stop if match long enough */
  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  const _win = s.window; // shortcut

  const wmask = s.w_mask;
  const prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  const strend = s.strstart + MAX_MATCH;
  let scan_end1  = _win[scan + best_len - 1];
  let scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
const fill_window = (s) => {

  const _w_size = s.w_size;
  let n, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    const curr = s.strstart + s.lookahead;
//    let init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
};

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 *
 * In case deflateParams() is used to later switch to a non-zero compression
 * level, s->matches (otherwise unused when storing) keeps track of the number
 * of hash table slides to perform. If s->matches is 1, then one hash table
 * slide will be done when switching. If s->matches is 2, the maximum value
 * allowed here, then the hash table will be cleared, since two or more slides
 * is the same as a clear.
 *
 * deflate_stored() is written to minimize the number of times an input byte is
 * copied. It is most efficient with large input and output buffers, which
 * maximizes the opportunites to have a single copy from next_in to next_out.
 */
const deflate_stored = (s, flush) => {

  /* Smallest worthy block size when not flushing or finishing. By default
   * this is 32K. This can be as small as 507 bytes for memLevel == 1. For
   * large input and output buffers, the stored block size will be larger.
   */
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;

  /* Copy as many min_block or larger stored blocks directly to next_out as
   * possible. If flushing, copy the remaining available input to next_out as
   * stored blocks, if there is enough space.
   */
  let len, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    /* Set len to the maximum size block that we can copy directly with the
     * available input data and output space. Set left to how much of that
     * would be copied from what's left in the window.
     */
    len = 65535/* MAX_STORED */;     /* maximum deflate stored block length */
    have = (s.bi_valid + 42) >> 3;     /* number of header bytes */
    if (s.strm.avail_out < have) {         /* need room for header */
      break;
    }
      /* maximum stored block length that will fit in avail_out: */
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;  /* bytes left in window */
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;   /* limit len to the input */
    }
    if (len > have) {
      len = have;             /* limit len to the output */
    }

    /* If the stored block would be less than min_block in length, or if
     * unable to copy all of the available input when flushing, then try
     * copying to the window and the pending buffer instead. Also don't
     * write an empty block when flushing -- deflate() does that.
     */
    if (len < min_block && ((len === 0 && flush !== Z_FINISH$3) ||
                        flush === Z_NO_FLUSH$2 ||
                        len !== left + s.strm.avail_in)) {
      break;
    }

    /* Make a dummy stored block in pending to get the header bytes,
     * including any pending bits. This also updates the debugging counts.
     */
    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);

    /* Replace the lengths in the dummy stored block with len. */
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;

    /* Write the stored block header bytes. */
    flush_pending(s.strm);

//#ifdef ZLIB_DEBUG
//    /* Update debugging counts for the data about to be copied. */
//    s->compressed_len += len << 3;
//    s->bits_sent += len << 3;
//#endif

    /* Copy uncompressed bytes from the window to next_out. */
    if (left) {
      if (left > len) {
        left = len;
      }
      //zmemcpy(s->strm->next_out, s->window + s->block_start, left);
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }

    /* Copy uncompressed bytes directly from next_in to next_out, updating
     * the check value.
     */
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);

  /* Update the sliding window with the last s->w_size bytes of the copied
   * data, or append all of the copied data to the existing window if less
   * than s->w_size bytes were copied. Also update the number of bytes to
   * insert in the hash tables, in the event that deflateParams() switches to
   * a non-zero compression level.
   */
  used -= s.strm.avail_in;    /* number of input bytes directly copied */
  if (used) {
    /* If any input was used, then no unused input remains in the window,
     * therefore s->block_start == s->strstart.
     */
    if (used >= s.w_size) {  /* supplant the previous history */
      s.matches = 2;     /* clear hash */
      //zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    }
    else {
      if (s.window_size - s.strstart <= used) {
        /* Slide the window down. */
        s.strstart -= s.w_size;
        //zmemcpy(s->window, s->window + s->w_size, s->strstart);
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;   /* add a pending slide_hash() */
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      //zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }

  /* If the last block was written to next_out, then done. */
  if (last) {
    return BS_FINISH_DONE;
  }

  /* If flushing and all input has been consumed, then done. */
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 &&
    s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }

  /* Fill the window with any remaining input. */
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    /* Slide the window down. */
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    //zmemcpy(s->window, s->window + s->w_size, s->strstart);
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;       /* add a pending slide_hash() */
    }
    have += s.w_size;      /* more space now */
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }

  /* There was not enough avail_out to write a complete worthy or flushed
   * stored block to next_out. Write a stored block to pending instead, if we
   * have enough input for a worthy block, or if flushing and there is enough
   * room for the remaining input as a stored block in the pending buffer.
   */
  have = (s.bi_valid + 42) >> 3;     /* number of header bytes */
    /* maximum stored block length that will fit in pending: */
  have = s.pending_buf_size - have > 65535/* MAX_STORED */ ? 65535/* MAX_STORED */ : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block ||
     ((left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 &&
     s.strm.avail_in === 0 && left <= have)) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 &&
         len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }

  /* We've done all we can with the available input and output. */
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};


/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
const deflate_fast = (s, flush) => {

  let hash_head;        /* head of the hash chain */
  let bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
const deflate_slow = (s, flush) => {

  let hash_head;          /* head of hash chain */
  let bflush;              /* set if current block must be flushed */

  let max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
};


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
const deflate_rle = (s, flush) => {

  let bflush;            /* set if current block must be flushed */
  let prev;              /* byte at distance one to match */
  let scan, strend;      /* scan goes up to strend for length of run */

  const _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
const deflate_huff = (s, flush) => {

  let bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
};

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {

  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
const lm_init = (s) => {

  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED$2; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.sym_buf = 0;        /* buffer for distances and literals/lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.sym_next = 0;      /* running index in sym_buf */
  this.sym_end = 0;       /* symbol table full when sym_next reaches this */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


/* =========================================================================
 * Check for a valid deflate stream state. Return 0 if ok, 1 if not.
 */
const deflateStateCheck = (strm) => {

  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || (s.status !== INIT_STATE &&
//#ifdef GZIP
                                s.status !== GZIP_STATE &&
//#endif
                                s.status !== EXTRA_STATE &&
                                s.status !== NAME_STATE &&
                                s.status !== COMMENT_STATE &&
                                s.status !== HCRC_STATE &&
                                s.status !== BUSY_STATE &&
                                s.status !== FINISH_STATE)) {
    return 1;
  }
  return 0;
};


const deflateResetKeep = (strm) => {

  if (deflateStateCheck(strm)) {
    return pako_esm_err(strm, Z_STREAM_ERROR$2);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status =
//#ifdef GZIP
    s.wrap === 2 ? GZIP_STATE :
//#endif
    s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};


const deflateReset = (strm) => {

  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};


const deflateSetHeader = (strm, head) => {

  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};


const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {

  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED || (windowBits === 8 && wrap !== 1)) {
    return pako_esm_err(strm, Z_STREAM_ERROR$2);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  const s = new DeflateState();

  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;     /* to pass state test in deflateReset() */

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  /* We overlay pending_buf and sym_buf. This works since the average size
   * for length/distance pairs over any compressed block is assured to be 31
   * bits or less.
   *
   * Analysis: The longest fixed codes are a length code of 8 bits plus 5
   * extra bits, for lengths 131 to 257. The longest fixed distance codes are
   * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest
   * possible fixed-codes length/distance pair is then 31 bits total.
   *
   * sym_buf starts one-fourth of the way into pending_buf. So there are
   * three bytes in sym_buf for every four bytes in pending_buf. Each symbol
   * in sym_buf is three bytes -- two for the distance and one for the
   * literal/length. As each symbol is consumed, the pointer to the next
   * sym_buf value to read moves forward three bytes. From that symbol, up to
   * 31 bits are written to pending_buf. The closest the written pending_buf
   * bits gets to the next sym_buf symbol to read is just before the last
   * code is written. At that time, 31*(n-2) bits have been written, just
   * after 24*(n-2) bits have been consumed from sym_buf. sym_buf starts at
   * 8*n bits into pending_buf. (Note that the symbol buffer fills when n-1
   * symbols are written.) The closest the writing gets to what is unread is
   * then n+14 bits. Here n is lit_bufsize, which is 16384 by default, and
   * can range from 128 to 32768.
   *
   * Therefore, at a minimum, there are 142 bits of space between what is
   * written and what is read in the overlain buffers, so the symbols cannot
   * be overwritten by the compressed data. That space is actually 139 bits,
   * due to the three-bit fixed-code block header.
   *
   * That covers the case where either Z_FIXED is specified, forcing fixed
   * codes, or when the use of fixed codes is chosen, because that choice
   * results in a smaller compressed block than dynamic codes. That latter
   * condition then assures that the above analysis also covers all dynamic
   * blocks. A dynamic-code block will only be chosen to be emitted if it has
   * fewer bits than a fixed-code block would for the same set of symbols.
   * Therefore its average symbol length is assured to be less than 31. So
   * the compressed data for a dynamic block also cannot overwrite the
   * symbols from which it is being constructed.
   */

  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->sym_buf = s->pending_buf + s->lit_bufsize;
  s.sym_buf = s.lit_bufsize;

  //s->sym_end = (s->lit_bufsize - 1) * 3;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  /* We avoid equality with lit_bufsize*3 because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
};

const deflateInit = (strm, level) => {

  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};


/* ========================================================================= */
const deflate$2 = (strm, flush) => {

  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? pako_esm_err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }

  const s = strm.state;

  if (!strm.output ||
      (strm.avail_in !== 0 && !strm.input) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH$3)) {
    return pako_esm_err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }

  const old_flush = s.last_flush;
  s.last_flush = flush;

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK$3;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && pako_esm_rank(flush) <= pako_esm_rank(old_flush) &&
    flush !== Z_FINISH$3) {
    return pako_esm_err(strm, Z_BUF_ERROR$1);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return pako_esm_err(strm, Z_BUF_ERROR$1);
  }

  /* Write the header */
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    /* zlib header */
    let header = (Z_DEFLATED$2 + ((s.w_bits - 8) << 4)) << 8;
    let level_flags = -1;

    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= (level_flags << 6);
    if (s.strstart !== 0) { header |= PRESET_DICT; }
    header += 31 - (header % 31);

    putShortMSB(s, header);

    /* Save the adler32 of the preset dictionary: */
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 0xffff);
    }
    strm.adler = 1; // adler32(0L, Z_NULL, 0);
    s.status = BUSY_STATE;

    /* Compression must start with an empty pending buffer */
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
//#ifdef GZIP
  if (s.status === GZIP_STATE) {
    /* gzip header */
    strm.adler = 0;  //crc32(0L, Z_NULL, 0);
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) { // s->gzhead == Z_NULL
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 :
                  (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                   4 : 0));
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;

      /* Compression must start with an empty pending buffer */
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
    else {
      put_byte(s, (s.gzhead.text ? 1 : 0) +
                  (s.gzhead.hcrc ? 2 : 0) +
                  (!s.gzhead.extra ? 0 : 4) +
                  (!s.gzhead.name ? 0 : 8) +
                  (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 0xff);
      put_byte(s, (s.gzhead.time >> 8) & 0xff);
      put_byte(s, (s.gzhead.time >> 16) & 0xff);
      put_byte(s, (s.gzhead.time >> 24) & 0xff);
      put_byte(s, s.level === 9 ? 2 :
                  (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                   4 : 0));
      put_byte(s, s.gzhead.os & 0xff);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 0xff);
        put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      let beg = s.pending;   /* start of bytes to update crc */
      let left = (s.gzhead.extra.length & 0xffff) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy = s.pending_buf_size - s.pending;
        // zmemcpy(s.pending_buf + s.pending,
        //    s.gzhead.extra + s.gzindex, copy);
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
        s.pending = s.pending_buf_size;
        //--- HCRC_UPDATE(beg) ---//
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        //---//
        s.gzindex += copy;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      // JS specific: s.gzhead.extra may be TypedArray or Array for backward compatibility
      //              TypedArray.slice and TypedArray.from don't exist in IE10-IE11
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      // zmemcpy(s->pending_buf + s->pending,
      //     s->gzhead->extra + s->gzindex, left);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      let beg = s.pending;   /* start of bytes to update crc */
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          //--- HCRC_UPDATE(beg) ---//
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          //---//
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      let beg = s.pending;   /* start of bytes to update crc */
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          //--- HCRC_UPDATE(beg) ---//
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          //---//
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      //--- HCRC_UPDATE(beg) ---//
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      //---//
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 0xff);
      put_byte(s, (strm.adler >> 8) & 0xff);
      strm.adler = 0; //crc32(0L, Z_NULL, 0);
    }
    s.status = BUSY_STATE;

    /* Compression must start with an empty pending buffer */
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
//#endif

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE)) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) :
                 s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
                 s.strategy === Z_RLE ? deflate_rle(s, flush) :
                 configuration_table[s.level].func(s, flush);

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK$3;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      }
      else if (flush !== Z_BLOCK$1) { /* FULL_FLUSH or SYNC_FLUSH */

        _tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH$1) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK$3;
      }
    }
  }

  if (flush !== Z_FINISH$3) { return Z_OK$3; }
  if (s.wrap <= 0) { return Z_STREAM_END$3; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};


const deflateEnd = (strm) => {

  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }

  const status = strm.state.status;

  strm.state = null;

  return status === BUSY_STATE ? pako_esm_err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
const deflateSetDictionary = (strm, dictionary) => {

  let dictLength = dictionary.length;

  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }

  const s = strm.state;
  const wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};


var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
module.exports.deflateBound = deflateBound;
module.exports.deflateCopy = deflateCopy;
module.exports.deflateGetDictionary = deflateGetDictionary;
module.exports.deflateParams = deflateParams;
module.exports.deflatePending = deflatePending;
module.exports.deflatePrime = deflatePrime;
module.exports.deflateTune = deflateTune;
*/

var deflate_1$2 = {
	deflateInit: deflateInit_1,
	deflateInit2: deflateInit2_1,
	deflateReset: deflateReset_1,
	deflateResetKeep: deflateResetKeep_1,
	deflateSetHeader: deflateSetHeader_1,
	deflate: deflate_2$1,
	deflateEnd: deflateEnd_1,
	deflateSetDictionary: deflateSetDictionary_1,
	deflateInfo: deflateInfo
};

const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};

var pako_esm_assign = function (obj /*from1, from2, from3, ...*/) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// Join array of chunks to single array.
var flattenChunks = (chunks) => {
  // calculate data length
  let len = 0;

  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }

  // join chunks
  const result = new Uint8Array(len);

  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }

  return result;
};

var common = {
	assign: pako_esm_assign,
	flattenChunks: flattenChunks
};

// String encode/decode helpers


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
let STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
const _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
var string2buf = (str) => {
  if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }

  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new Uint8Array(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper
const buf2binstring = (buf, len) => {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }

  let result = '';
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};


// convert array to string
var buf2string = (buf, max) => {
  const len = max || buf.length;

  if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }

  let i, out;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  const utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    let c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    let c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = (buf, max) => {

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

var strings = {
	string2buf: string2buf,
	buf2string: buf2string,
	utf8border: utf8border
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

var zstream = ZStream;

const toString$1 = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});

  let opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new zstream();
  this.strm.avail_out = 0;

  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }

  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    let dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = deflate_1$2.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must
 * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
 * buffers and call [[Deflate#onEnd]].
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate$1.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;

  if (this.ended) { return false; }

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    // Make sure avail_out > 6 to avoid repeating markers
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    status = deflate_1$2.deflate(strm, _flush_mode);

    // Ended => flush and finish
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }

    // Flush if out buffer full
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }

    // Flush if requested and has data
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array): output data.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate$1.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate$1.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array
 * - data (Uint8Array|ArrayBuffer|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || messages[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array
 * - data (Uint8Array|ArrayBuffer|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array
 * - data (Uint8Array|ArrayBuffer|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}


var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;

var deflate_1$1 = {
	Deflate: Deflate_1$1,
	deflate: deflate_2,
	deflateRaw: deflateRaw_1$1,
	gzip: gzip_1$1,
	constants: constants$1
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
const BAD$1 = 16209;       /* got a data error -- remain here until reset */
const TYPE$1 = 16191;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
var inffast = function inflate_fast(strm, start) {
  let _in;                    /* local strm.input */
  let last;                   /* have enough input while in < last */
  let _out;                   /* local strm.output */
  let beg;                    /* inflate()'s initial strm.output */
  let end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  let dmax;                   /* maximum distance from zlib header */
//#endif
  let wsize;                  /* window size or zero if not using window */
  let whave;                  /* valid bytes in the window */
  let wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  let s_window;               /* allocated sliding window, if wsize != 0 */
  let hold;                   /* local strm.hold */
  let bits;                   /* local strm.bits */
  let lcode;                  /* local strm.lencode */
  let dcode;                  /* local strm.distcode */
  let lmask;                  /* mask for first level of length codes */
  let dmask;                  /* mask for first level of distance codes */
  let here;                   /* retrieved table entry */
  let op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  let len;                    /* match length, unused bytes */
  let dist;                   /* match distance */
  let from;                   /* where to copy match from */
  let from_source;


  let input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  const state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD$1;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD$1;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD$1;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE$1;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD$1;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

const MAXBITS = 15;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;

const lbase = new Uint16Array([ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
]);

const lext = new Uint8Array([ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
]);

const dbase = new Uint16Array([ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
]);

const dext = new Uint8Array([ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
]);

const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>
{
  const bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  let len = 0;               /* a code's length in bits */
  let sym = 0;               /* index of code symbols */
  let min = 0, max = 0;          /* minimum and maximum code lengths */
  let root = 0;              /* number of index bits for root table */
  let curr = 0;              /* number of index bits for current table */
  let drop = 0;              /* code bits to drop for sub-table */
  let left = 0;                   /* number of prefix codes available */
  let used = 0;              /* code entries in table used */
  let huff = 0;              /* Huffman code */
  let incr;              /* for incrementing code, index */
  let fill;              /* index for replicating entries */
  let low;               /* low bits for current root entry */
  let mask;              /* mask for low root bits */
  let next;             /* next available space in table */
  let base = null;     /* base value table to use */
//  let shoextra;    /* extra bits table to use */
  let match;                  /* use base and extra for symbol >= match */
  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  let extra = null;

  let here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES$1) {
    base = extra = work;    /* dummy value--not used */
    match = 20;

  } else if (type === LENS$1) {
    base = lbase;
    extra = lext;
    match = 257;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    match = 0;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
    (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
        (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};


var inftrees = inflate_table;

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.






const CODES = 0;
const LENS = 1;
const DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES,
  Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;


/* STATES ====================================================================*/
/* ===========================================================================*/


const    HEAD = 16180;       /* i: waiting for magic header */
const    FLAGS = 16181;      /* i: waiting for method and flags (gzip) */
const    TIME = 16182;       /* i: waiting for modification time (gzip) */
const    OS = 16183;         /* i: waiting for extra flags and operating system (gzip) */
const    EXLEN = 16184;      /* i: waiting for extra length (gzip) */
const    EXTRA = 16185;      /* i: waiting for extra bytes (gzip) */
const    NAME = 16186;       /* i: waiting for end of file name (gzip) */
const    COMMENT = 16187;    /* i: waiting for end of comment (gzip) */
const    HCRC = 16188;       /* i: waiting for header crc (gzip) */
const    DICTID = 16189;    /* i: waiting for dictionary check value */
const    DICT = 16190;      /* waiting for inflateSetDictionary() call */
const        TYPE = 16191;      /* i: waiting for type bits, including last-flag bit */
const        TYPEDO = 16192;    /* i: same, but skip check to exit inflate on new block */
const        STORED = 16193;    /* i: waiting for stored size (length and complement) */
const        COPY_ = 16194;     /* i/o: same as COPY below, but only first time in */
const        COPY = 16195;      /* i/o: waiting for input or output to copy stored block */
const        TABLE = 16196;     /* i: waiting for dynamic block table lengths */
const        LENLENS = 16197;   /* i: waiting for code length code lengths */
const        CODELENS = 16198;  /* i: waiting for length/lit and distance code lengths */
const            LEN_ = 16199;      /* i: same as LEN below, but only first time in */
const            LEN = 16200;       /* i: waiting for length/lit/eob code */
const            LENEXT = 16201;    /* i: waiting for length extra bits */
const            DIST = 16202;      /* i: waiting for distance code */
const            DISTEXT = 16203;   /* i: waiting for distance extra bits */
const            MATCH = 16204;     /* o: waiting for output space to copy string */
const            LIT = 16205;       /* o: waiting for output space to write literal */
const    CHECK = 16206;     /* i: waiting for 32-bit check value */
const    LENGTH = 16207;    /* i: waiting for 32-bit length (gzip) */
const    DONE = 16208;      /* finished check, done -- remain here until reset */
const    BAD = 16209;       /* got a data error -- remain here until reset */
const    MEM = 16210;       /* got an inflate() memory error -- remain here until reset */
const    SYNC = 16211;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

const MAX_WBITS = 15;
/* 32K LZ77 window */
const DEF_WBITS = MAX_WBITS;


const zswap32 = (q) => {

  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
};


function InflateState() {
  this.strm = null;           /* pointer back to this zlib stream */
  this.mode = 0;              /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip,
                                 bit 2 true to validate check value */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib), or
                                 -1 if raw or no header yet */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new Uint16Array(320); /* temporary storage for code lengths */
  this.work = new Uint16Array(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}


const inflateStateCheck = (strm) => {

  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm ||
    state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};


const inflateResetKeep = (strm) => {

  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK$1;
};


const inflateReset = (strm) => {

  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

};


const inflateReset2 = (strm, windowBits) => {
  let wrap;

  /* get the state */
  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
  const state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};


const inflateInit2 = (strm, windowBits) => {

  if (!strm) { return Z_STREAM_ERROR$1; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  const state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.strm = strm;
  state.window = null/*Z_NULL*/;
  state.mode = HEAD;     /* to pass state test in inflateReset2() */
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
};


const inflateInit = (strm) => {

  return inflateInit2(strm, DEF_WBITS);
};


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
let virgin = true;

let lenfix, distfix; // We have no pointers in JS, so keep tables separate


const fixedtables = (state) => {

  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);

    /* literal/length table */
    let sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inftrees(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inftrees(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
const updatewindow = (strm, src, end, copy) => {

  let dist;
  const state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new Uint8Array(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
};


const inflate$2 = (strm, flush) => {

  let state;
  let input, output;          // input/output buffers
  let next;                   /* next input INDEX */
  let put;                    /* next output INDEX */
  let have, left;             /* available input and output */
  let hold;                   /* bit buffer */
  let bits;                   /* bits in bit buffer */
  let _in, _out;              /* save starting available input and output */
  let copy;                   /* number of stored or match bytes to copy */
  let from;                   /* where to copy match bytes from */
  let from_source;
  let here = 0;               /* current decoding table entry */
  let here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //let last;                   /* parent table entry */
  let last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  let len;                    /* length to copy for repeats, bits to drop */
  let ret;                    /* return code */
  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */
  let opts;

  let n; // temporary variable for NEED_BITS

  const order = /* permutation of code lengths */
    new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);


  if (inflateStateCheck(strm) || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR$1;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK$1;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          if (state.wbits === 0) {
            state.wbits = 15;
          }
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        if (len > 15 || len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }

        // !!! pako patch. Force use `options.windowBits` if passed.
        // Required to always use max window size by default.
        state.dmax = 1 << state.wbits;
        //state.dmax = 1 << len;

        state.flags = 0;               /* indicate zlib header */
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if ((state.flags & 0x0200) && (state.wrap & 4)) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if ((state.flags & 0x0200) && (state.wrap & 4)) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32_1(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if ((state.flags & 0x0200) && (state.wrap & 4)) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32_1(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Uint8Array(state.head.extra_len);
              }
              state.head.extra.set(
                input.subarray(
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  next + copy
                ),
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if ((state.flags & 0x0200) && (state.wrap & 4)) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            state.check = crc32_1(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if ((state.wrap & 4) && hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT$1;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          output.set(input.subarray(next, next + copy), put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inffast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if ((state.wrap & 4) && _out) {
            strm.adler = state.check =
                /*UPDATE_CHECK(state.check, put - _out, _out);*/
                (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.wrap & 4) && (state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if ((state.wrap & 4) && hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END$1;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR$1;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR$1;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR$1;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH$1))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if ((state.wrap & 4) && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};


const inflateEnd = (strm) => {

  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }

  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};


const inflateGetHeader = (strm, head) => {

  /* check state */
  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
  const state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK$1;
};


const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;

  let state;
  let dictid;
  let ret;

  /* check state */
  if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK$1;
};


var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
module.exports.inflateCodesUsed = inflateCodesUsed;
module.exports.inflateCopy = inflateCopy;
module.exports.inflateGetDictionary = inflateGetDictionary;
module.exports.inflateMark = inflateMark;
module.exports.inflatePrime = inflatePrime;
module.exports.inflateSync = inflateSync;
module.exports.inflateSyncPoint = inflateSyncPoint;
module.exports.inflateUndermine = inflateUndermine;
module.exports.inflateValidate = inflateValidate;
*/

var inflate_1$2 = {
	inflateReset: inflateReset_1,
	inflateReset2: inflateReset2_1,
	inflateResetKeep: inflateResetKeep_1,
	inflateInit: inflateInit_1,
	inflateInit2: inflateInit2_1,
	inflate: inflate_2$1,
	inflateEnd: inflateEnd_1,
	inflateGetHeader: inflateGetHeader_1,
	inflateSetDictionary: inflateSetDictionary_1,
	inflateInfo: inflateInfo
};

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

var gzheader = GZheader;

const pako_esm_toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

const {
  Z_NO_FLUSH, Z_FINISH,
  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR
} = constants$2;

/* ===========================================================================*/


/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako')
 * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
 * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * const inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ''
  }, options || {});

  const opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new zstream();
  this.strm.avail_out = 0;

  let status  = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }

  this.header = new gzheader();

  inflate_1$2.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (pako_esm_toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, flush_mode]) -> Boolean
 * - data (Uint8Array|ArrayBuffer): input data
 * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
 *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
 *   `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. If end of stream detected,
 * [[Inflate#onEnd]] will be called.
 *
 * `flush_mode` is not needed for normal operation, because end of stream
 * detected automatically. You may try to use it for advanced things, but
 * this functionality was not tested.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate$1.prototype.push = function (data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;

  if (this.ended) return false;

  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

  // Convert data if needed
  if (pako_esm_toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  for (;;) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = inflate_1$2.inflate(strm, _flush_mode);

    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);

      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        // Replace code with more verbose
        status = Z_NEED_DICT;
      }
    }

    // Skip snyc markers if more data follows and not raw mode
    while (strm.avail_in > 0 &&
           status === Z_STREAM_END &&
           strm.state.wrap > 0 &&
           data[strm.next_in] !== 0)
    {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }

    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }

    // Remember real `avail_out` value, because we may patch out buffer content
    // to align utf8 strings boundaries.
    last_avail_out = strm.avail_out;

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {

        if (this.options.to === 'string') {

          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail & realign counters
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);

          this.onData(utf8str);

        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }

    // Must repeat iteration if out buffer is full
    if (status === Z_OK && last_avail_out === 0) continue;

    // Finalize if end of stream reached.
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }

    if (strm.avail_in === 0) break;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|String): output data. When string output requested,
 *   each chunk will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate$1.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH). By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate$1.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * const pako = require('pako');
 * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
 * let output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err) {
 *   console.log(err);
 * }
 * ```
 **/
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);

  inflator.push(input);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) throw inflator.msg || messages[inflator.err];

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|String
 * - data (Uint8Array|ArrayBuffer): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;

var inflate_1$1 = {
	Inflate: Inflate_1$1,
	inflate: inflate_2,
	inflateRaw: inflateRaw_1$1,
	ungzip: ungzip$1,
	constants: constants
};

const { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;

const { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;



var Deflate_1 = (/* unused pure expression or super */ null && (Deflate));
var deflate_1 = (/* unused pure expression or super */ null && (deflate));
var deflateRaw_1 = (/* unused pure expression or super */ null && (deflateRaw));
var gzip_1 = (/* unused pure expression or super */ null && (gzip));
var Inflate_1 = (/* unused pure expression or super */ null && (Inflate));
var inflate_1 = (/* unused pure expression or super */ null && (inflate));
var inflateRaw_1 = (/* unused pure expression or super */ null && (inflateRaw));
var ungzip_1 = ungzip;
var constants_1 = (/* unused pure expression or super */ null && (constants$2));

var pako = (/* unused pure expression or super */ null && ({
	Deflate: Deflate_1,
	deflate: deflate_1,
	deflateRaw: deflateRaw_1,
	gzip: gzip_1,
	Inflate: Inflate_1,
	inflate: inflate_1,
	inflateRaw: inflateRaw_1,
	ungzip: ungzip_1,
	constants: constants_1
}));



;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/tokenizer/languages.js
const STEMMERS = {
    arabic: 'ar',
    armenian: 'am',
    bulgarian: 'bg',
    czech: 'cz',
    danish: 'dk',
    dutch: 'nl',
    english: 'en',
    finnish: 'fi',
    french: 'fr',
    german: 'de',
    greek: 'gr',
    hungarian: 'hu',
    indian: 'in',
    indonesian: 'id',
    irish: 'ie',
    italian: 'it',
    lithuanian: 'lt',
    nepali: 'np',
    norwegian: 'no',
    portuguese: 'pt',
    romanian: 'ro',
    russian: 'ru',
    serbian: 'rs',
    slovenian: 'ru',
    spanish: 'es',
    swedish: 'se',
    tamil: 'ta',
    turkish: 'tr',
    ukrainian: 'uk',
    sanskrit: 'sk'
};
const SPLITTERS = {
    dutch: /[^A-Za-zàèéìòóù0-9_'-]+/gim,
    english: /[^A-Za-zàèéìòóù0-9_'-]+/gim,
    french: /[^a-z0-9äâàéèëêïîöôùüûœç-]+/gim,
    italian: /[^A-Za-zàèéìòóù0-9_'-]+/gim,
    norwegian: /[^a-z0-9_æøåÆØÅäÄöÖüÜ]+/gim,
    portuguese: /[^a-z0-9à-úÀ-Ú]/gim,
    russian: /[^a-z0-9а-яА-ЯёЁ]+/gim,
    spanish: /[^a-z0-9A-Zá-úÁ-ÚñÑüÜ]+/gim,
    swedish: /[^a-z0-9_åÅäÄöÖüÜ-]+/gim,
    german: /[^a-z0-9A-ZäöüÄÖÜß]+/gim,
    finnish: /[^a-z0-9äöÄÖ]+/gim,
    danish: /[^a-z0-9æøåÆØÅ]+/gim,
    hungarian: /[^a-z0-9áéíóöőúüűÁÉÍÓÖŐÚÜŰ]+/gim,
    romanian: /[^a-z0-9ăâîșțĂÂÎȘȚ]+/gim,
    serbian: /[^a-z0-9čćžšđČĆŽŠĐ]+/gim,
    turkish: /[^a-z0-9çÇğĞıİöÖşŞüÜ]+/gim,
    lithuanian: /[^a-z0-9ąčęėįšųūžĄČĘĖĮŠŲŪŽ]+/gim,
    arabic: /[^a-z0-9أ-ي]+/gim,
    nepali: /[^a-z0-9अ-ह]+/gim,
    irish: /[^a-z0-9áéíóúÁÉÍÓÚ]+/gim,
    indian: /[^a-z0-9अ-ह]+/gim,
    armenian: /[^a-z0-9ա-ֆ]+/gim,
    greek: /[^a-z0-9α-ωά-ώ]+/gim,
    indonesian: /[^a-z0-9]+/gim,
    ukrainian: /[^a-z0-9а-яА-ЯіїєІЇЄ]+/gim,
    slovenian: /[^a-z0-9čžšČŽŠ]+/gim,
    bulgarian: /[^a-z0-9а-яА-Я]+/gim,
    tamil: /[^a-z0-9அ-ஹ]+/gim,
    sanskrit: /[^a-z0-9A-Zāīūṛḷṃṁḥśṣṭḍṇṅñḻḹṝ]+/gim,
    czech: /[^A-Z0-9a-zěščřžýáíéúůóťďĚŠČŘŽÝÁÍÉÓÚŮŤĎ-]+/gim
};
const SUPPORTED_LANGUAGES = Object.keys(STEMMERS);
function getLocale(language) {
    return language !== undefined && SUPPORTED_LANGUAGES.includes(language) ? STEMMERS[language] : undefined;
}
//# sourceMappingURL=languages.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/utils.js

const baseId = Date.now().toString().slice(5);
let lastId = 0;
const utils_k = 1024;
const nano = BigInt(1e3);
const milli = BigInt(1e6);
const utils_second = BigInt(1e9);
const isServer = (/* unused pure expression or super */ null && (typeof window === 'undefined'));
/**
 * This value can be increased up to 100_000
 * But i don't know if this value change from nodejs to nodejs
 * So I will keep a safer value here.
 */
const MAX_ARGUMENT_FOR_STACK = 65535;
/**
 * This method is needed to used because of issues like: https://github.com/oramasearch/orama/issues/301
 * that issue is caused because the array that is pushed is huge (>100k)
 *
 * @example
 * ```ts
 * safeArrayPush(myArray, [1, 2])
 * ```
 */
function utils_safeArrayPush(arr, newArr) {
    if (newArr.length < MAX_ARGUMENT_FOR_STACK) {
        Array.prototype.push.apply(arr, newArr);
    }
    else {
        const newArrLength = newArr.length;
        for (let i = 0; i < newArrLength; i += MAX_ARGUMENT_FOR_STACK) {
            Array.prototype.push.apply(arr, newArr.slice(i, i + MAX_ARGUMENT_FOR_STACK));
        }
    }
}
function sprintf(template, ...args) {
    return template.replace(/%(?:(?<position>\d+)\$)?(?<width>-?\d*\.?\d*)(?<type>[dfs])/g, function (...replaceArgs) {
        const groups = replaceArgs[replaceArgs.length - 1];
        const { width: rawWidth, type, position } = groups;
        const replacement = position ? args[Number.parseInt(position) - 1] : args.shift();
        const width = rawWidth === '' ? 0 : Number.parseInt(rawWidth);
        switch (type) {
            case 'd':
                return replacement.toString().padStart(width, '0');
            case 'f': {
                let value = replacement;
                const [padding, precision] = rawWidth.split('.').map((w) => Number.parseFloat(w));
                if (typeof precision === 'number' && precision >= 0) {
                    value = value.toFixed(precision);
                }
                return typeof padding === 'number' && padding >= 0 ? value.toString().padStart(width, '0') : value.toString();
            }
            case 's':
                return width < 0
                    ? replacement.toString().padEnd(-width, ' ')
                    : replacement.toString().padStart(width, ' ');
            default:
                return replacement;
        }
    });
}
function formatBytes(bytes, decimals = 2) {
    if (bytes === 0) {
        return '0 Bytes';
    }
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    const i = Math.floor(Math.log(bytes) / Math.log(utils_k));
    return `${parseFloat((bytes / Math.pow(utils_k, i)).toFixed(dm))} ${sizes[i]}`;
}
function isInsideWebWorker() {
    // @ts-expect-error - WebWorker global scope
    return typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
}
function isInsideNode() {
    return typeof process !== 'undefined' && process.release && process.release.name === 'node';
}
function getNanosecondTimeViaPerformance() {
    return BigInt(Math.floor(performance.now() * 1e6));
}
function utils_formatNanoseconds(value) {
    if (typeof value === 'number') {
        value = BigInt(value);
    }
    if (value < nano) {
        return `${value}ns`;
    }
    else if (value < milli) {
        return `${value / nano}μs`;
    }
    else if (value < utils_second) {
        return `${value / milli}ms`;
    }
    return `${value / utils_second}s`;
}
function utils_getNanosecondsTime() {
    if (isInsideWebWorker()) {
        return getNanosecondTimeViaPerformance();
    }
    if (isInsideNode()) {
        return process.hrtime.bigint();
    }
    if (typeof process !== 'undefined' && typeof process?.hrtime?.bigint === 'function') {
        return process.hrtime.bigint();
    }
    if (typeof performance !== 'undefined') {
        return getNanosecondTimeViaPerformance();
    }
    // @todo: fallback to V8 native method to get microtime
    return BigInt(0);
}
function uniqueId() {
    return `${baseId}-${lastId++}`;
}
function getOwnProperty(object, property) {
    // Checks if `hasOwn` method is defined avoiding errors with older Node.js versions
    if (Object.hasOwn === undefined) {
        return Object.prototype.hasOwnProperty.call(object, property) ? object[property] : undefined;
    }
    return Object.hasOwn(object, property) ? object[property] : undefined;
}
function getTokenFrequency(token, tokens) {
    let count = 0;
    for (const t of tokens) {
        if (t === token) {
            count++;
        }
    }
    return count;
}
function insertSortedValue(arr, el, compareFn = utils_sortTokenScorePredicate) {
    let low = 0;
    let high = arr.length;
    let mid;
    while (low < high) {
        mid = (low + high) >>> 1;
        if (compareFn(el, arr[mid]) < 0) {
            high = mid;
        }
        else {
            low = mid + 1;
        }
    }
    arr.splice(low, 0, el);
    return arr;
}
function utils_sortTokenScorePredicate(a, b) {
    if (b[1] === a[1]) {
        return a[0] - b[0];
    }
    return b[1] - a[1];
}
// Intersection function taken from https://github.com/lovasoa/fast_array_intersect.
// MIT Licensed at the time of writing.
function utils_intersect(arrays) {
    if (arrays.length === 0) {
        return [];
    }
    else if (arrays.length === 1) {
        return arrays[0];
    }
    for (let i = 1; i < arrays.length; i++) {
        if (arrays[i].length < arrays[0].length) {
            const tmp = arrays[0];
            arrays[0] = arrays[i];
            arrays[i] = tmp;
        }
    }
    const set = new Map();
    for (const elem of arrays[0]) {
        set.set(elem, 1);
    }
    for (let i = 1; i < arrays.length; i++) {
        let found = 0;
        for (const elem of arrays[i]) {
            const count = set.get(elem);
            if (count === i) {
                set.set(elem, count + 1);
                found++;
            }
        }
        if (found === 0)
            return [];
    }
    return arrays[0].filter((e) => {
        const count = set.get(e);
        if (count !== undefined)
            set.set(e, 0);
        return count === arrays.length;
    });
}
function utils_getDocumentProperties(doc, paths) {
    const properties = {};
    const pathsLength = paths.length;
    for (let i = 0; i < pathsLength; i++) {
        const path = paths[i];
        const pathTokens = path.split('.');
        let current = doc;
        const pathTokensLength = pathTokens.length;
        for (let j = 0; j < pathTokensLength; j++) {
            current = current[pathTokens[j]];
            // We found an object but we were supposed to be done
            if (typeof current === 'object') {
                if (current !== null &&
                    'lat' in current &&
                    'lon' in current &&
                    typeof current.lat === 'number' &&
                    typeof current.lon === 'number') {
                    current = properties[path] = current;
                    break;
                }
                else if (!Array.isArray(current) && current !== null && j === pathTokensLength - 1) {
                    current = undefined;
                    break;
                }
            }
            else if ((current === null || typeof current !== 'object') && j < pathTokensLength - 1) {
                // We can't recurse anymore but we were supposed to
                current = undefined;
                break;
            }
        }
        if (typeof current !== 'undefined') {
            properties[path] = current;
        }
    }
    return properties;
}
function utils_getNested(obj, path) {
    const props = utils_getDocumentProperties(obj, [path]);
    return props[path];
}
function flattenObject(obj, prefix = '') {
    const result = {};
    for (const key in obj) {
        const prop = `${prefix}${key}`;
        const objKey = obj[key];
        if (typeof objKey === 'object' && objKey !== null) {
            Object.assign(result, flattenObject(objKey, `${prop}.`));
        }
        else {
            result[prop] = objKey;
        }
    }
    return result;
}
const mapDistanceToMeters = {
    cm: 0.01,
    m: 1,
    km: 1000,
    ft: 0.3048,
    yd: 0.9144,
    mi: 1609.344
};
function utils_convertDistanceToMeters(distance, unit) {
    const ratio = mapDistanceToMeters[unit];
    if (ratio === undefined) {
        throw new Error(errors_createError('INVALID_DISTANCE_SUFFIX', distance).message);
    }
    return distance * ratio;
}
function utils_removeVectorsFromHits(searchResult, vectorProperties) {
    searchResult.hits = searchResult.hits.map((result) => ({
        ...result,
        document: {
            ...result.document,
            // Remove embeddings from the result
            ...vectorProperties.reduce((acc, prop) => {
                const path = prop.split('.');
                const lastKey = path.pop();
                let obj = acc;
                for (const key of path) {
                    obj[key] = obj[key] ?? {};
                    obj = obj[key];
                }
                obj[lastKey] = null;
                return acc;
            }, result.document)
        }
    }));
}
function isPromise(obj) {
    return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
}
/**
 * Checks if the provided input is an async function or if the input is an array
 * containing at least one async function.
 *
 * @param func - A single function or an array of functions to check.
 *               Non-function values are ignored.
 * @returns `true` if the input is an async function or an array containing at least
 *          one async function, otherwise `false`.
 */
function utils_isAsyncFunction(func) {
    if (Array.isArray(func)) {
        return func.some((item) => utils_isAsyncFunction(item));
    }
    return func?.constructor?.name === 'AsyncFunction';
}
const withIntersection = 'intersection' in new Set();
function setIntersection(...sets) {
    // Fast path 1
    if (sets.length === 0) {
        return new Set();
    }
    // Fast path 2
    if (sets.length === 1) {
        return sets[0];
    }
    // Fast path 3
    if (sets.length === 2) {
        const set1 = sets[0];
        const set2 = sets[1];
        if (withIntersection) {
            return set1.intersection(set2);
        }
        const result = new Set();
        const base = set1.size < set2.size ? set1 : set2;
        const other = base === set1 ? set2 : set1;
        for (const value of base) {
            if (other.has(value)) {
                result.add(value);
            }
        }
        return result;
    }
    // Slow path
    // Find the smallest set
    const min = {
        index: 0,
        size: sets[0].size
    };
    for (let i = 1; i < sets.length; i++) {
        if (sets[i].size < min.size) {
            min.index = i;
            min.size = sets[i].size;
        }
    }
    if (withIntersection) {
        let base = sets[min.index];
        for (let i = 0; i < sets.length; i++) {
            if (i === min.index) {
                continue;
            }
            base = base.intersection(sets[i]);
        }
        return base;
    }
    // manual implementation:
    // intersect all sets with the smallest set
    const base = sets[min.index];
    for (let i = 0; i < sets.length; i++) {
        if (i === min.index) {
            continue;
        }
        const other = sets[i];
        for (const value of base) {
            if (!other.has(value)) {
                base.delete(value);
            }
        }
    }
    return base;
}
const withUnion = 'union' in new Set();
function setUnion(set1, set2) {
    if (withUnion) {
        if (set1) {
            return set1.union(set2);
        }
        return set2;
    }
    if (!set1) {
        return new Set(set2);
    }
    return new Set([...set1, ...set2]);
}
function setDifference(set1, set2) {
    const result = new Set();
    for (const value of set1) {
        if (!set2.has(value)) {
            result.add(value);
        }
    }
    return result;
}
// This code is taken from https://github.com/davidmarkclements/atomic-sleep, MIT licensed at the time of commit b8149d3ca276c84a54fa8fa1478f9cc79aabc15a.
// All credits go to the original author (David Mark Clements, https://github.com/davidmarkclements).
function sleep(ms) {
    if (typeof SharedArrayBuffer !== 'undefined' && typeof Atomics !== 'undefined') {
        const nil = new Int32Array(new SharedArrayBuffer(4));
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
            if (typeof ms !== 'number' && typeof ms !== 'bigint') {
                throw TypeError('sleep: ms must be a number');
            }
            throw RangeError('sleep: ms must be a number that is greater than 0 but less than Infinity');
        }
        Atomics.wait(nil, 0, 0, Number(ms));
    }
    else {
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
            if (typeof ms !== 'number' && typeof ms !== 'bigint') {
                throw TypeError('sleep: ms must be a number');
            }
            throw RangeError('sleep: ms must be a number that is greater than 0 but less than Infinity');
        }
        const target = Date.now() + Number(ms);
        while (target > Date.now()) {
            /* empty */
        }
    }
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/errors.js


const allLanguages = SUPPORTED_LANGUAGES.join('\n - ');
const errors = {
    NO_LANGUAGE_WITH_CUSTOM_TOKENIZER: 'Do not pass the language option to create when using a custom tokenizer.',
    LANGUAGE_NOT_SUPPORTED: `Language "%s" is not supported.\nSupported languages are:\n - ${allLanguages}`,
    INVALID_STEMMER_FUNCTION_TYPE: `config.stemmer property must be a function.`,
    MISSING_STEMMER: `As of version 1.0.0 @orama/orama does not ship non English stemmers by default. To solve this, please explicitly import and specify the "%s" stemmer from the package @orama/stemmers. See https://docs.orama.com/docs/orama-js/text-analysis/stemming for more information.`,
    CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY: 'Custom stop words array must only contain strings.',
    UNSUPPORTED_COMPONENT: `Unsupported component "%s".`,
    COMPONENT_MUST_BE_FUNCTION: `The component "%s" must be a function.`,
    COMPONENT_MUST_BE_FUNCTION_OR_ARRAY_FUNCTIONS: `The component "%s" must be a function or an array of functions.`,
    INVALID_SCHEMA_TYPE: `Unsupported schema type "%s" at "%s". Expected "string", "boolean" or "number" or array of them.`,
    DOCUMENT_ID_MUST_BE_STRING: `Document id must be of type "string". Got "%s" instead.`,
    DOCUMENT_ALREADY_EXISTS: `A document with id "%s" already exists.`,
    DOCUMENT_DOES_NOT_EXIST: `A document with id "%s" does not exists.`,
    MISSING_DOCUMENT_PROPERTY: `Missing searchable property "%s".`,
    INVALID_DOCUMENT_PROPERTY: `Invalid document property "%s": expected "%s", got "%s"`,
    UNKNOWN_INDEX: `Invalid property name "%s". Expected a wildcard string ("*") or array containing one of the following properties: %s`,
    INVALID_BOOST_VALUE: `Boost value must be a number greater than, or less than 0.`,
    INVALID_FILTER_OPERATION: `You can only use one operation per filter, you requested %d.`,
    SCHEMA_VALIDATION_FAILURE: `Cannot insert document due schema validation failure on "%s" property.`,
    INVALID_SORT_SCHEMA_TYPE: `Unsupported sort schema type "%s" at "%s". Expected "string" or "number".`,
    CANNOT_SORT_BY_ARRAY: `Cannot configure sort for "%s" because it is an array (%s).`,
    UNABLE_TO_SORT_ON_UNKNOWN_FIELD: `Unable to sort on unknown field "%s". Allowed fields: %s`,
    SORT_DISABLED: `Sort is disabled. Please read the documentation at https://docs.orama.com/docs/orama-js for more information.`,
    UNKNOWN_GROUP_BY_PROPERTY: `Unknown groupBy property "%s".`,
    INVALID_GROUP_BY_PROPERTY: `Invalid groupBy property "%s". Allowed types: "%s", but given "%s".`,
    UNKNOWN_FILTER_PROPERTY: `Unknown filter property "%s".`,
    UNKNOWN_VECTOR_PROPERTY: `Unknown vector property "%s". Make sure the property exists in the schema and is configured as a vector.`,
    INVALID_VECTOR_SIZE: `Vector size must be a number greater than 0. Got "%s" instead.`,
    INVALID_VECTOR_VALUE: `Vector value must be a number greater than 0. Got "%s" instead.`,
    INVALID_INPUT_VECTOR: `Property "%s" was declared as a %s-dimensional vector, but got a %s-dimensional vector instead.\nInput vectors must be of the size declared in the schema, as calculating similarity between vectors of different sizes can lead to unexpected results.`,
    WRONG_SEARCH_PROPERTY_TYPE: `Property "%s" is not searchable. Only "string" properties are searchable.`,
    FACET_NOT_SUPPORTED: `Facet doens't support the type "%s".`,
    INVALID_DISTANCE_SUFFIX: `Invalid distance suffix "%s". Valid suffixes are: cm, m, km, mi, yd, ft.`,
    INVALID_SEARCH_MODE: `Invalid search mode "%s". Valid modes are: "fulltext", "vector", "hybrid".`,
    MISSING_VECTOR_AND_SECURE_PROXY: `No vector was provided and no secure proxy was configured. Please provide a vector or configure an Orama Secure Proxy to perform hybrid search.`,
    MISSING_TERM: `"term" is a required parameter when performing hybrid search. Please provide a search term.`,
    INVALID_VECTOR_INPUT: `Invalid "vector" property. Expected an object with "value" and "property" properties, but got "%s" instead.`,
    PLUGIN_CRASHED: `A plugin crashed during initialization. Please check the error message for more information:`,
    PLUGIN_SECURE_PROXY_NOT_FOUND: `Could not find '@orama/secure-proxy-plugin' installed in your Orama instance.\nPlease install it before proceeding with creating an answer session.\nRead more at https://docs.orama.com/docs/orama-js/plugins/plugin-secure-proxy#plugin-secure-proxy\n`,
    PLUGIN_SECURE_PROXY_MISSING_CHAT_MODEL: `Could not find a chat model defined in the secure proxy plugin configuration.\nPlease provide a chat model before proceeding with creating an answer session.\nRead more at https://docs.orama.com/docs/orama-js/plugins/plugin-secure-proxy#plugin-secure-proxy\n`,
    ANSWER_SESSION_LAST_MESSAGE_IS_NOT_ASSISTANT: `The last message in the session is not an assistant message. Cannot regenerate non-assistant messages.`,
    PLUGIN_COMPONENT_CONFLICT: `The component "%s" is already defined. The plugin "%s" is trying to redefine it.`
};
function errors_createError(code, ...args) {
    const error = new Error(sprintf(errors[code] ?? `Unsupported Orama Error code: ${code}`, ...args));
    error.code = code;
    if ('captureStackTrace' in Error.prototype) {
        Error.captureStackTrace(error);
    }
    return error;
}
//# sourceMappingURL=errors.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/defaults.js



function defaults_formatElapsedTime(n) {
    return {
        raw: Number(n),
        formatted: utils_formatNanoseconds(n)
    };
}
function defaults_getDocumentIndexId(doc) {
    if (doc.id) {
        if (typeof doc.id !== 'string') {
            throw errors_createError('DOCUMENT_ID_MUST_BE_STRING', typeof doc.id);
        }
        return doc.id;
    }
    return uniqueId();
}
function defaults_validateSchema(doc, schema) {
    for (const [prop, type] of Object.entries(schema)) {
        const value = doc[prop];
        if (typeof value === 'undefined') {
            continue;
        }
        if (type === 'geopoint' &&
            typeof value === 'object' &&
            typeof value.lon === 'number' &&
            typeof value.lat === 'number') {
            continue;
        }
        if (type === 'enum' && (typeof value === 'string' || typeof value === 'number')) {
            continue;
        }
        if (type === 'enum[]' && Array.isArray(value)) {
            const valueLength = value.length;
            for (let i = 0; i < valueLength; i++) {
                if (typeof value[i] !== 'string' && typeof value[i] !== 'number') {
                    return prop + '.' + i;
                }
            }
            continue;
        }
        if (isVectorType(type)) {
            const vectorSize = getVectorSize(type);
            if (!Array.isArray(value) || value.length !== vectorSize) {
                throw errors_createError('INVALID_INPUT_VECTOR', prop, vectorSize, value.length);
            }
            continue;
        }
        if (isArrayType(type)) {
            if (!Array.isArray(value)) {
                return prop;
            }
            const expectedType = getInnerType(type);
            const valueLength = value.length;
            for (let i = 0; i < valueLength; i++) {
                if (typeof value[i] !== expectedType) {
                    return prop + '.' + i;
                }
            }
            continue;
        }
        if (typeof type === 'object') {
            if (!value || typeof value !== 'object') {
                return prop;
            }
            // using as ResultDocument is not exactly right but trying to be type-safe here is not useful
            const subProp = defaults_validateSchema(value, type);
            if (subProp) {
                return prop + '.' + subProp;
            }
            continue;
        }
        if (typeof value !== type) {
            return prop;
        }
    }
    return undefined;
}
const IS_ARRAY_TYPE = {
    string: false,
    number: false,
    boolean: false,
    enum: false,
    geopoint: false,
    'string[]': true,
    'number[]': true,
    'boolean[]': true,
    'enum[]': true
};
const INNER_TYPE = {
    'string[]': 'string',
    'number[]': 'number',
    'boolean[]': 'boolean',
    'enum[]': 'enum'
};
function isGeoPointType(type) {
    return type === 'geopoint';
}
function isVectorType(type) {
    return typeof type === 'string' && /^vector\[\d+\]$/.test(type);
}
function isArrayType(type) {
    return typeof type === 'string' && IS_ARRAY_TYPE[type];
}
function getInnerType(type) {
    return INNER_TYPE[type];
}
function getVectorSize(type) {
    const size = Number(type.slice(7, -1));
    switch (true) {
        case isNaN(size):
            throw errors_createError('INVALID_VECTOR_VALUE', type);
        case size <= 0:
            throw errors_createError('INVALID_VECTOR_SIZE', type);
        default:
            return size;
    }
}
//# sourceMappingURL=defaults.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/internal-document-id-store.js
function createInternalDocumentIDStore() {
    return {
        idToInternalId: new Map(),
        internalIdToId: [],
        save,
        load
    };
}
function save(store) {
    return {
        internalIdToId: store.internalIdToId
    };
}
function load(orama, raw) {
    const { internalIdToId } = raw;
    orama.internalDocumentIDStore.idToInternalId.clear();
    orama.internalDocumentIDStore.internalIdToId = [];
    const internalIdToIdLength = internalIdToId.length;
    for (let i = 0; i < internalIdToIdLength; i++) {
        const internalIdItem = internalIdToId[i];
        orama.internalDocumentIDStore.idToInternalId.set(internalIdItem, i + 1);
        orama.internalDocumentIDStore.internalIdToId.push(internalIdItem);
    }
}
function internal_document_id_store_getInternalDocumentId(store, id) {
    if (typeof id === 'string') {
        const internalId = store.idToInternalId.get(id);
        if (internalId) {
            return internalId;
        }
        const currentId = store.idToInternalId.size + 1;
        store.idToInternalId.set(id, currentId);
        store.internalIdToId.push(id);
        return currentId;
    }
    if (id > store.internalIdToId.length) {
        return internal_document_id_store_getInternalDocumentId(store, id.toString());
    }
    return id;
}
function internal_document_id_store_getDocumentIdFromInternalId(store, internalId) {
    if (store.internalIdToId.length < internalId) {
        throw new Error(`Invalid internalId ${internalId}`);
    }
    return store.internalIdToId[internalId - 1];
}
//# sourceMappingURL=internal-document-id-store.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/documents-store.js

function create(_, sharedInternalDocumentStore) {
    return {
        sharedInternalDocumentStore,
        docs: {},
        count: 0
    };
}
function get(store, id) {
    const internalId = internal_document_id_store_getInternalDocumentId(store.sharedInternalDocumentStore, id);
    return store.docs[internalId];
}
function getMultiple(store, ids) {
    const idsLength = ids.length;
    const found = Array.from({ length: idsLength });
    for (let i = 0; i < idsLength; i++) {
        const internalId = internal_document_id_store_getInternalDocumentId(store.sharedInternalDocumentStore, ids[i]);
        found[i] = store.docs[internalId];
    }
    return found;
}
function getAll(store) {
    return store.docs;
}
function documents_store_store(store, id, internalId, doc) {
    if (typeof store.docs[internalId] !== 'undefined') {
        return false;
    }
    store.docs[internalId] = doc;
    store.count++;
    return true;
}
function documents_store_remove(store, id) {
    const internalId = internal_document_id_store_getInternalDocumentId(store.sharedInternalDocumentStore, id);
    if (typeof store.docs[internalId] === 'undefined') {
        return false;
    }
    delete store.docs[internalId];
    store.count--;
    return true;
}
function documents_store_count(store) {
    return store.count;
}
function documents_store_load(sharedInternalDocumentStore, raw) {
    const rawDocument = raw;
    return {
        docs: rawDocument.docs,
        count: rawDocument.count,
        sharedInternalDocumentStore
    };
}
function documents_store_save(store) {
    return {
        docs: store.docs,
        count: store.count
    };
}
function createDocumentsStore() {
    return {
        create,
        get,
        getMultiple,
        getAll,
        store: documents_store_store,
        remove: documents_store_remove,
        count: documents_store_count,
        load: documents_store_load,
        save: documents_store_save
    };
}
//# sourceMappingURL=documents-store.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/plugins.js

const AVAILABLE_PLUGIN_HOOKS = [
    'beforeInsert',
    'afterInsert',
    'beforeRemove',
    'afterRemove',
    'beforeUpdate',
    'afterUpdate',
    'beforeUpsert',
    'afterUpsert',
    'beforeSearch',
    'afterSearch',
    'beforeInsertMultiple',
    'afterInsertMultiple',
    'beforeRemoveMultiple',
    'afterRemoveMultiple',
    'beforeUpdateMultiple',
    'afterUpdateMultiple',
    'beforeUpsertMultiple',
    'afterUpsertMultiple',
    'beforeLoad',
    'afterLoad',
    'afterCreate'
];
function getAllPluginsByHook(orama, hook) {
    const pluginsToRun = [];
    const pluginsLength = orama.plugins?.length;
    if (!pluginsLength) {
        return pluginsToRun;
    }
    for (let i = 0; i < pluginsLength; i++) {
        try {
            const plugin = orama.plugins[i];
            if (typeof plugin[hook] === 'function') {
                pluginsToRun.push(plugin[hook]);
            }
        }
        catch (error) {
            console.error('Caught error in getAllPluginsByHook:', error);
            throw errors_createError('PLUGIN_CRASHED');
        }
    }
    return pluginsToRun;
}
//# sourceMappingURL=plugins.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/hooks.js

const OBJECT_COMPONENTS = ['tokenizer', 'index', 'documentsStore', 'sorter', 'pinning'];
const FUNCTION_COMPONENTS = [
    'validateSchema',
    'getDocumentIndexId',
    'getDocumentProperties',
    'formatElapsedTime'
];
const SINGLE_OR_ARRAY_COMPONENTS = (/* unused pure expression or super */ null && ([
/* deprecated with v2.0.0-beta.5 */
]));
function hooks_runSingleHook(hooks, orama, id, doc) {
    const needAsync = hooks.some(utils_isAsyncFunction);
    if (needAsync) {
        return (async () => {
            for (const hook of hooks) {
                await hook(orama, id, doc);
            }
        })();
    }
    else {
        for (const hook of hooks) {
            hook(orama, id, doc);
        }
    }
}
function hooks_runMultipleHook(hooks, orama, docsOrIds) {
    const needAsync = hooks.some(utils_isAsyncFunction);
    if (needAsync) {
        return (async () => {
            for (const hook of hooks) {
                await hook(orama, docsOrIds);
            }
        })();
    }
    else {
        for (const hook of hooks) {
            hook(orama, docsOrIds);
        }
    }
}
function hooks_runAfterSearch(hooks, db, params, language, results) {
    const needAsync = hooks.some(isAsyncFunction);
    if (needAsync) {
        return (async () => {
            for (const hook of hooks) {
                await hook(db, params, language, results);
            }
        })();
    }
    else {
        for (const hook of hooks) {
            hook(db, params, language, results);
        }
    }
}
function hooks_runBeforeSearch(hooks, db, params, language) {
    const needAsync = hooks.some(isAsyncFunction);
    if (needAsync) {
        return (async () => {
            for (const hook of hooks) {
                await hook(db, params, language);
            }
        })();
    }
    else {
        for (const hook of hooks) {
            hook(db, params, language);
        }
    }
}
function runAfterCreate(hooks, db) {
    const needAsync = hooks.some(utils_isAsyncFunction);
    if (needAsync) {
        return (async () => {
            for (const hook of hooks) {
                await hook(db);
            }
        })();
    }
    else {
        for (const hook of hooks) {
            hook(db);
        }
    }
}
//# sourceMappingURL=hooks.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/trees/avl.js
class AVLNode {
    k;
    v;
    l = null;
    r = null;
    h = 1;
    constructor(key, value) {
        this.k = key;
        this.v = new Set(value);
    }
    updateHeight() {
        this.h = Math.max(AVLNode.getHeight(this.l), AVLNode.getHeight(this.r)) + 1;
    }
    static getHeight(node) {
        return node ? node.h : 0;
    }
    getBalanceFactor() {
        return AVLNode.getHeight(this.l) - AVLNode.getHeight(this.r);
    }
    rotateLeft() {
        const newRoot = this.r;
        this.r = newRoot.l;
        newRoot.l = this;
        this.updateHeight();
        newRoot.updateHeight();
        return newRoot;
    }
    rotateRight() {
        const newRoot = this.l;
        this.l = newRoot.r;
        newRoot.r = this;
        this.updateHeight();
        newRoot.updateHeight();
        return newRoot;
    }
    toJSON() {
        return {
            k: this.k,
            v: Array.from(this.v),
            l: this.l ? this.l.toJSON() : null,
            r: this.r ? this.r.toJSON() : null,
            h: this.h
        };
    }
    static fromJSON(json) {
        const node = new AVLNode(json.k, json.v);
        node.l = json.l ? AVLNode.fromJSON(json.l) : null;
        node.r = json.r ? AVLNode.fromJSON(json.r) : null;
        node.h = json.h;
        return node;
    }
}
class AVLTree {
    root = null;
    insertCount = 0;
    constructor(key, value) {
        if (key !== undefined && value !== undefined) {
            this.root = new AVLNode(key, value);
        }
    }
    insert(key, value, rebalanceThreshold = 1000) {
        this.root = this.insertNode(this.root, key, value, rebalanceThreshold);
    }
    insertMultiple(key, value, rebalanceThreshold = 1000) {
        for (const v of value) {
            this.insert(key, v, rebalanceThreshold);
        }
    }
    // Rebalance the tree if the insert count reaches the threshold.
    // This will improve insertion performance since we won't be rebalancing the tree on every insert.
    // When inserting docs using `insertMultiple`, the threshold will be set to the number of docs being inserted.
    // We can force rebalancing the tree by setting the threshold to 1 (default).
    rebalance() {
        if (this.root) {
            this.root = this.rebalanceNode(this.root);
        }
    }
    toJSON() {
        return {
            root: this.root ? this.root.toJSON() : null,
            insertCount: this.insertCount
        };
    }
    static fromJSON(json) {
        const tree = new AVLTree();
        tree.root = json.root ? AVLNode.fromJSON(json.root) : null;
        tree.insertCount = json.insertCount || 0;
        return tree;
    }
    insertNode(node, key, value, rebalanceThreshold) {
        if (node === null) {
            return new AVLNode(key, [value]);
        }
        const path = [];
        let current = node;
        let parent = null;
        while (current !== null) {
            path.push({ parent, node: current });
            if (key < current.k) {
                if (current.l === null) {
                    current.l = new AVLNode(key, [value]);
                    path.push({ parent: current, node: current.l });
                    break;
                }
                else {
                    parent = current;
                    current = current.l;
                }
            }
            else if (key > current.k) {
                if (current.r === null) {
                    current.r = new AVLNode(key, [value]);
                    path.push({ parent: current, node: current.r });
                    break;
                }
                else {
                    parent = current;
                    current = current.r;
                }
            }
            else {
                // Key already exists
                current.v.add(value);
                /*
                if (Array.isArray(current.v)) {
                  if (Array.isArray(value)) {
                    ;(current.v as any[]).push(...(value as V[]))
                  } else {
                    ;(current.v as any[]).push(value)
                  }
                } else {
                  current.v = new Set([value])
                }
                */
                return node;
            }
        }
        // Update heights and rebalance if necessary
        let needRebalance = false;
        if (this.insertCount++ % rebalanceThreshold === 0) {
            needRebalance = true;
        }
        for (let i = path.length - 1; i >= 0; i--) {
            const { parent, node: currentNode } = path[i];
            currentNode.updateHeight();
            if (needRebalance) {
                const rebalancedNode = this.rebalanceNode(currentNode);
                if (parent) {
                    if (parent.l === currentNode) {
                        parent.l = rebalancedNode;
                    }
                    else if (parent.r === currentNode) {
                        parent.r = rebalancedNode;
                    }
                }
                else {
                    // This is the root node
                    node = rebalancedNode;
                }
            }
        }
        return node;
    }
    rebalanceNode(node) {
        const balanceFactor = node.getBalanceFactor();
        if (balanceFactor > 1) {
            // Left heavy
            if (node.l && node.l.getBalanceFactor() >= 0) {
                // Left Left Case
                return node.rotateRight();
            }
            else if (node.l) {
                // Left Right Case
                node.l = node.l.rotateLeft();
                return node.rotateRight();
            }
        }
        if (balanceFactor < -1) {
            // Right heavy
            if (node.r && node.r.getBalanceFactor() <= 0) {
                // Right Right Case
                return node.rotateLeft();
            }
            else if (node.r) {
                // Right Left Case
                node.r = node.r.rotateRight();
                return node.rotateLeft();
            }
        }
        return node;
    }
    find(key) {
        const node = this.findNodeByKey(key);
        return node ? node.v : null;
    }
    contains(key) {
        return this.find(key) !== null;
    }
    getSize() {
        let count = 0;
        const stack = [];
        let current = this.root;
        while (current || stack.length > 0) {
            while (current) {
                stack.push(current);
                current = current.l;
            }
            current = stack.pop();
            count++;
            current = current.r;
        }
        return count;
    }
    isBalanced() {
        if (!this.root)
            return true;
        const stack = [this.root];
        while (stack.length > 0) {
            const node = stack.pop();
            const balanceFactor = node.getBalanceFactor();
            if (Math.abs(balanceFactor) > 1) {
                return false;
            }
            if (node.l)
                stack.push(node.l);
            if (node.r)
                stack.push(node.r);
        }
        return true;
    }
    remove(key) {
        this.root = this.removeNode(this.root, key);
    }
    removeDocument(key, id) {
        const node = this.findNodeByKey(key);
        if (!node) {
            return;
        }
        if (node.v.size === 1) {
            this.root = this.removeNode(this.root, key);
        }
        else {
            node.v = new Set([...node.v.values()].filter((v) => v !== id));
        }
    }
    findNodeByKey(key) {
        let node = this.root;
        while (node) {
            if (key < node.k) {
                node = node.l;
            }
            else if (key > node.k) {
                node = node.r;
            }
            else {
                return node;
            }
        }
        return null;
    }
    removeNode(node, key) {
        if (node === null)
            return null;
        const path = [];
        let current = node;
        while (current !== null && current.k !== key) {
            path.push(current);
            if (key < current.k) {
                current = current.l;
            }
            else {
                current = current.r;
            }
        }
        if (current === null) {
            // Key not found
            return node;
        }
        // Node with only one child or no child
        if (current.l === null || current.r === null) {
            const child = current.l ? current.l : current.r;
            if (path.length === 0) {
                // Node to be deleted is root
                node = child;
            }
            else {
                const parent = path[path.length - 1];
                if (parent.l === current) {
                    parent.l = child;
                }
                else {
                    parent.r = child;
                }
            }
        }
        else {
            // Node with two children: Get the inorder successor
            let successorParent = current;
            let successor = current.r;
            while (successor.l !== null) {
                successorParent = successor;
                successor = successor.l;
            }
            // Copy the successor's content to current node
            current.k = successor.k;
            current.v = successor.v;
            // Delete the successor
            if (successorParent.l === successor) {
                successorParent.l = successor.r;
            }
            else {
                successorParent.r = successor.r;
            }
            current = successorParent;
        }
        // Update heights and rebalance
        path.push(current);
        for (let i = path.length - 1; i >= 0; i--) {
            const currentNode = path[i];
            currentNode.updateHeight();
            const rebalancedNode = this.rebalanceNode(currentNode);
            if (i > 0) {
                const parent = path[i - 1];
                if (parent.l === currentNode) {
                    parent.l = rebalancedNode;
                }
                else if (parent.r === currentNode) {
                    parent.r = rebalancedNode;
                }
            }
            else {
                // Root node
                node = rebalancedNode;
            }
        }
        return node;
    }
    rangeSearch(min, max) {
        const result = new Set();
        const stack = [];
        let current = this.root;
        while (current || stack.length > 0) {
            while (current) {
                stack.push(current);
                current = current.l;
            }
            current = stack.pop();
            if (current.k >= min && current.k <= max) {
                for (const value of current.v) {
                    result.add(value);
                }
            }
            if (current.k > max) {
                break;
            }
            current = current.r;
        }
        return result;
    }
    greaterThan(key, inclusive = false) {
        const result = new Set();
        const stack = [];
        let current = this.root;
        while (current || stack.length > 0) {
            while (current) {
                stack.push(current);
                current = current.r; // Traverse right subtree first
            }
            current = stack.pop();
            if ((inclusive && current.k >= key) || (!inclusive && current.k > key)) {
                for (const value of current.v) {
                    result.add(value);
                }
            }
            else if (current.k <= key) {
                break; // Since we're traversing in descending order, we can break early
            }
            current = current.l;
        }
        return result;
    }
    lessThan(key, inclusive = false) {
        const result = new Set();
        const stack = [];
        let current = this.root;
        while (current || stack.length > 0) {
            while (current) {
                stack.push(current);
                current = current.l;
            }
            current = stack.pop();
            if ((inclusive && current.k <= key) || (!inclusive && current.k < key)) {
                for (const value of current.v) {
                    result.add(value);
                }
            }
            else if (current.k > key) {
                break; // Since we're traversing in ascending order, we can break early
            }
            current = current.r;
        }
        return result;
    }
}
//# sourceMappingURL=avl.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/trees/flat.js
class FlatTree {
    numberToDocumentId;
    constructor() {
        this.numberToDocumentId = new Map();
    }
    insert(key, value) {
        if (this.numberToDocumentId.has(key)) {
            this.numberToDocumentId.get(key).add(value);
        }
        else {
            this.numberToDocumentId.set(key, new Set([value]));
        }
    }
    find(key) {
        const idSet = this.numberToDocumentId.get(key);
        return idSet ? Array.from(idSet) : null;
    }
    remove(key) {
        this.numberToDocumentId.delete(key);
    }
    removeDocument(id, key) {
        const idSet = this.numberToDocumentId.get(key);
        if (idSet) {
            idSet.delete(id);
            if (idSet.size === 0) {
                this.numberToDocumentId.delete(key);
            }
        }
    }
    contains(key) {
        return this.numberToDocumentId.has(key);
    }
    getSize() {
        let size = 0;
        for (const idSet of this.numberToDocumentId.values()) {
            size += idSet.size;
        }
        return size;
    }
    filter(operation) {
        const operationKeys = Object.keys(operation);
        if (operationKeys.length !== 1) {
            throw new Error('Invalid operation');
        }
        const operationType = operationKeys[0];
        switch (operationType) {
            case 'eq': {
                const value = operation[operationType];
                const idSet = this.numberToDocumentId.get(value);
                return idSet ? Array.from(idSet) : [];
            }
            case 'in': {
                const values = operation[operationType];
                const resultSet = new Set();
                for (const value of values) {
                    const idSet = this.numberToDocumentId.get(value);
                    if (idSet) {
                        for (const id of idSet) {
                            resultSet.add(id);
                        }
                    }
                }
                return Array.from(resultSet);
            }
            case 'nin': {
                const excludeValues = new Set(operation[operationType]);
                const resultSet = new Set();
                for (const [key, idSet] of this.numberToDocumentId.entries()) {
                    if (!excludeValues.has(key)) {
                        for (const id of idSet) {
                            resultSet.add(id);
                        }
                    }
                }
                return Array.from(resultSet);
            }
            default:
                throw new Error('Invalid operation');
        }
    }
    filterArr(operation) {
        const operationKeys = Object.keys(operation);
        if (operationKeys.length !== 1) {
            throw new Error('Invalid operation');
        }
        const operationType = operationKeys[0];
        switch (operationType) {
            case 'containsAll': {
                const values = operation[operationType];
                const idSets = values.map((value) => this.numberToDocumentId.get(value) ?? new Set());
                if (idSets.length === 0)
                    return [];
                const intersection = idSets.reduce((prev, curr) => {
                    return new Set([...prev].filter((id) => curr.has(id)));
                });
                return Array.from(intersection);
            }
            case 'containsAny': {
                const values = operation[operationType];
                const idSets = values.map((value) => this.numberToDocumentId.get(value) ?? new Set());
                if (idSets.length === 0)
                    return [];
                const union = idSets.reduce((prev, curr) => {
                    return new Set([...prev, ...curr]);
                });
                return Array.from(union);
            }
            default:
                throw new Error('Invalid operation');
        }
    }
    static fromJSON(json) {
        if (!json.numberToDocumentId) {
            throw new Error('Invalid Flat Tree JSON');
        }
        const tree = new FlatTree();
        for (const [key, ids] of json.numberToDocumentId) {
            tree.numberToDocumentId.set(key, new Set(ids));
        }
        return tree;
    }
    toJSON() {
        return {
            numberToDocumentId: Array.from(this.numberToDocumentId.entries()).map(([key, idSet]) => [key, Array.from(idSet)])
        };
    }
}
//# sourceMappingURL=flat.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/levenshtein.js
/**
 * Inspired by:
 * https://github.com/Yomguithereal/talisman/blob/86ae55cbd040ff021d05e282e0e6c71f2dde21f8/src/metrics/levenshtein.js#L218-L340
 */
function _boundedLevenshtein(term, word, tolerance) {
    // Handle base cases
    if (tolerance < 0)
        return -1;
    if (term === word)
        return 0;
    const m = term.length;
    const n = word.length;
    // Special case for empty strings
    if (m === 0)
        return n <= tolerance ? n : -1;
    if (n === 0)
        return m <= tolerance ? m : -1;
    // term = term.toLowerCase()
    // word = word.toLowerCase()
    const diff = Math.abs(m - n);
    // Special case for prefixes
    // If the searching word starts with the indexed word, return early.
    if (term.startsWith(word)) {
        // We just check if the remaining characters are within the tolerance
        return diff <= tolerance ? diff : -1;
    }
    // If the indexed word starts with the searching word, return early.
    if (word.startsWith(term)) {
        // any prefixed word is within the tolerance
        return 0;
    }
    // If the length difference is greater than the tolerance, return early
    if (diff > tolerance)
        return -1;
    // Initialize the matrix
    const matrix = [];
    for (let i = 0; i <= m; i++) {
        matrix[i] = [i];
        for (let j = 1; j <= n; j++) {
            matrix[i][j] = i === 0 ? j : 0;
        }
    }
    // Fill the matrix
    for (let i = 1; i <= m; i++) {
        let rowMin = Infinity;
        for (let j = 1; j <= n; j++) {
            if (term[i - 1] === word[j - 1]) {
                matrix[i][j] = matrix[i - 1][j - 1];
            }
            else {
                matrix[i][j] = Math.min(matrix[i - 1][j] + 1, // deletion
                matrix[i][j - 1] + 1, // insertion
                matrix[i - 1][j - 1] + 1 // substitution
                );
            }
            rowMin = Math.min(rowMin, matrix[i][j]);
        }
        // Early termination if all values in this row exceed tolerance
        if (rowMin > tolerance) {
            return -1;
        }
    }
    return matrix[m][n] <= tolerance ? matrix[m][n] : -1;
}
/**
 * Computes the Levenshtein distance between two strings (a, b), returning early with -1 if the distance
 * is greater than the given tolerance.
 * It assumes that:
 * - tolerance >= ||a| - |b|| >= 0
 */
function boundedLevenshtein(term, w, tolerance) {
    const distance = _boundedLevenshtein(term, w, tolerance);
    return {
        distance,
        isBounded: distance >= 0
    };
}
// This is only used internally, keep in sync with the previous one
function syncBoundedLevenshtein(term, w, tolerance) {
    const distance = _boundedLevenshtein(term, w, tolerance);
    return {
        distance,
        isBounded: distance >= 0
    };
}
function levenshtein(a, b) {
    /* c8 ignore next 3 */
    if (!a.length) {
        return b.length;
    }
    /* c8 ignore next 3 */
    if (!b.length) {
        return a.length;
    }
    const swap = a;
    if (a.length > b.length) {
        a = b;
        b = swap;
    }
    const row = Array.from({ length: a.length + 1 }, (_, i) => i);
    let val = 0;
    for (let i = 1; i <= b.length; i++) {
        let prev = i;
        for (let j = 1; j <= a.length; j++) {
            if (b[i - 1] === a[j - 1]) {
                val = row[j - 1];
            }
            else {
                val = Math.min(row[j - 1] + 1, Math.min(prev + 1, row[j] + 1));
            }
            row[j - 1] = prev;
            prev = val;
        }
        row[a.length] = prev;
    }
    return row[a.length];
}
//# sourceMappingURL=levenshtein.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/trees/radix.js
/* eslint-disable @typescript-eslint/no-this-alias */


class RadixNode {
    // Node key
    k;
    // Node subword
    s;
    // Node children
    c = new Map();
    // Node documents
    d = new Set();
    // Node end
    e;
    // Node word
    w = '';
    constructor(key, subWord, end) {
        this.k = key;
        this.s = subWord;
        this.e = end;
    }
    updateParent(parent) {
        this.w = parent.w + this.s;
    }
    addDocument(docID) {
        this.d.add(docID);
    }
    removeDocument(docID) {
        return this.d.delete(docID);
    }
    findAllWords(output, term, exact, tolerance) {
        const stack = [this];
        while (stack.length > 0) {
            const node = stack.pop();
            if (node.e) {
                const { w, d: docIDs } = node;
                if (exact && w !== term) {
                    continue;
                }
                // check if _output[w] exists and then add the doc to it
                // always check in own property to prevent access to inherited properties
                // fix https://github.com/oramasearch/orama/issues/137
                if (getOwnProperty(output, w) !== null) {
                    if (tolerance) {
                        const difference = Math.abs(term.length - w.length);
                        if (difference <= tolerance && syncBoundedLevenshtein(term, w, tolerance).isBounded) {
                            output[w] = [];
                        }
                        else {
                            continue;
                        }
                    }
                    else {
                        output[w] = [];
                    }
                }
                // check if _output[w] exists and then add the doc to it
                // always check in own property to prevent access to inherited properties
                // fix https://github.com/oramasearch/orama/issues/137
                if (getOwnProperty(output, w) != null && docIDs.size > 0) {
                    const docs = output[w];
                    for (const docID of docIDs) {
                        if (!docs.includes(docID)) {
                            docs.push(docID);
                        }
                    }
                }
            }
            if (node.c.size > 0) {
                stack.push(...node.c.values());
            }
        }
        return output;
    }
    insert(word, docId) {
        let node = this;
        let i = 0;
        const wordLength = word.length;
        while (i < wordLength) {
            const currentCharacter = word[i];
            const childNode = node.c.get(currentCharacter);
            if (childNode) {
                const edgeLabel = childNode.s;
                const edgeLabelLength = edgeLabel.length;
                let j = 0;
                // Find the common prefix length between edgeLabel and the remaining word
                while (j < edgeLabelLength && i + j < wordLength && edgeLabel[j] === word[i + j]) {
                    j++;
                }
                if (j === edgeLabelLength) {
                    // Edge label fully matches; proceed to the child node
                    node = childNode;
                    i += j;
                    if (i === wordLength) {
                        // The word is a prefix of an existing word
                        if (!childNode.e) {
                            childNode.e = true;
                        }
                        childNode.addDocument(docId);
                        return;
                    }
                    continue;
                }
                // Split the edgeLabel at the common prefix
                const commonPrefix = edgeLabel.slice(0, j);
                const newEdgeLabel = edgeLabel.slice(j);
                const newWordLabel = word.slice(i + j);
                // Create an intermediate node for the common prefix
                const inbetweenNode = new RadixNode(commonPrefix[0], commonPrefix, false);
                node.c.set(commonPrefix[0], inbetweenNode);
                inbetweenNode.updateParent(node);
                // Update the existing childNode
                childNode.s = newEdgeLabel;
                childNode.k = newEdgeLabel[0];
                inbetweenNode.c.set(newEdgeLabel[0], childNode);
                childNode.updateParent(inbetweenNode);
                if (newWordLabel) {
                    // Create a new node for the remaining part of the word
                    const newNode = new RadixNode(newWordLabel[0], newWordLabel, true);
                    newNode.addDocument(docId);
                    inbetweenNode.c.set(newWordLabel[0], newNode);
                    newNode.updateParent(inbetweenNode);
                }
                else {
                    // The word ends at the inbetweenNode
                    inbetweenNode.e = true;
                    inbetweenNode.addDocument(docId);
                }
                return;
            }
            else {
                // No matching child; create a new node
                const newNode = new RadixNode(currentCharacter, word.slice(i), true);
                newNode.addDocument(docId);
                node.c.set(currentCharacter, newNode);
                newNode.updateParent(node);
                return;
            }
        }
        // If we reach here, the word already exists in the tree
        if (!node.e) {
            node.e = true;
        }
        node.addDocument(docId);
    }
    _findLevenshtein(term, index, tolerance, originalTolerance, output) {
        const stack = [{ node: this, index, tolerance }];
        while (stack.length > 0) {
            const { node, index, tolerance } = stack.pop();
            if (node.w.startsWith(term)) {
                node.findAllWords(output, term, false, 0);
                continue;
            }
            if (tolerance < 0) {
                continue;
            }
            if (node.e) {
                const { w, d: docIDs } = node;
                if (w) {
                    if (syncBoundedLevenshtein(term, w, originalTolerance).isBounded) {
                        output[w] = [];
                    }
                    if (getOwnProperty(output, w) !== undefined && docIDs.size > 0) {
                        const docs = new Set(output[w]);
                        for (const docID of docIDs) {
                            docs.add(docID);
                        }
                        output[w] = Array.from(docs);
                    }
                }
            }
            if (index >= term.length) {
                continue;
            }
            const currentChar = term[index];
            // 1. If node has child matching term[index], push { node: childNode, index +1, tolerance }
            if (node.c.has(currentChar)) {
                const childNode = node.c.get(currentChar);
                stack.push({ node: childNode, index: index + 1, tolerance });
            }
            // 2. Push { node, index +1, tolerance -1 } (Delete operation)
            stack.push({ node: node, index: index + 1, tolerance: tolerance - 1 });
            // 3. For each child:
            for (const [character, childNode] of node.c) {
                // a) Insert operation
                stack.push({ node: childNode, index: index, tolerance: tolerance - 1 });
                // b) Substitute operation
                if (character !== currentChar) {
                    stack.push({ node: childNode, index: index + 1, tolerance: tolerance - 1 });
                }
            }
        }
    }
    find(params) {
        const { term, exact, tolerance } = params;
        if (tolerance && !exact) {
            const output = {};
            this._findLevenshtein(term, 0, tolerance, tolerance, output);
            return output;
        }
        else {
            let node = this;
            let i = 0;
            const termLength = term.length;
            while (i < termLength) {
                const character = term[i];
                const childNode = node.c.get(character);
                if (childNode) {
                    const edgeLabel = childNode.s;
                    const edgeLabelLength = edgeLabel.length;
                    let j = 0;
                    // Compare edge label with the term starting from position i
                    while (j < edgeLabelLength && i + j < termLength && edgeLabel[j] === term[i + j]) {
                        j++;
                    }
                    if (j === edgeLabelLength) {
                        // Full match of edge label; proceed to the child node
                        node = childNode;
                        i += j;
                    }
                    else if (i + j === termLength) {
                        // The term ends in the middle of the edge label - FIX: this handles prefix matches like 'p' matching 'phone'
                        // Check if the term matches from the beginning of the edge label
                        if (j === termLength - i) {
                            // Term is a prefix of the edge label
                            if (exact) {
                                // Exact match required but term doesn't end at a node
                                return {};
                            }
                            else {
                                // Partial match; collect words starting from this node
                                const output = {};
                                // Just call findAllWords on the child node to collect all words in this subtree
                                childNode.findAllWords(output, term, exact, tolerance);
                                return output;
                            }
                        }
                        else {
                            // Mismatch found
                            return {};
                        }
                    }
                    else {
                        // Mismatch found
                        return {};
                    }
                }
                else {
                    // No matching child node
                    return {};
                }
            }
            // Term fully matched; collect words starting from this node
            const output = {};
            node.findAllWords(output, term, exact, tolerance);
            return output;
        }
    }
    contains(term) {
        let node = this;
        let i = 0;
        const termLength = term.length;
        while (i < termLength) {
            const character = term[i];
            const childNode = node.c.get(character);
            if (childNode) {
                const edgeLabel = childNode.s;
                const edgeLabelLength = edgeLabel.length;
                let j = 0;
                while (j < edgeLabelLength && i + j < termLength && edgeLabel[j] === term[i + j]) {
                    j++;
                }
                if (j < edgeLabelLength) {
                    return false;
                }
                i += edgeLabelLength;
                node = childNode;
            }
            else {
                return false;
            }
        }
        return true;
    }
    removeWord(term) {
        if (!term) {
            return false;
        }
        let node = this;
        const termLength = term.length;
        const stack = [];
        for (let i = 0; i < termLength; i++) {
            const character = term[i];
            if (node.c.has(character)) {
                const childNode = node.c.get(character);
                stack.push({ parent: node, character });
                i += childNode.s.length - 1;
                node = childNode;
            }
            else {
                return false;
            }
        }
        // Remove documents from the node
        node.d.clear();
        node.e = false;
        // Clean up any nodes that no longer lead to a word
        while (stack.length > 0 && node.c.size === 0 && !node.e && node.d.size === 0) {
            const { parent, character } = stack.pop();
            parent.c.delete(character);
            node = parent;
        }
        return true;
    }
    removeDocumentByWord(term, docID, exact = true) {
        if (!term) {
            return true;
        }
        let node = this;
        const termLength = term.length;
        for (let i = 0; i < termLength; i++) {
            const character = term[i];
            if (node.c.has(character)) {
                const childNode = node.c.get(character);
                i += childNode.s.length - 1;
                node = childNode;
                if (exact && node.w !== term) {
                    // Do nothing if the exact condition is not met.
                }
                else {
                    node.removeDocument(docID);
                }
            }
            else {
                return false;
            }
        }
        return true;
    }
    static getCommonPrefix(a, b) {
        const len = Math.min(a.length, b.length);
        let i = 0;
        while (i < len && a.charCodeAt(i) === b.charCodeAt(i)) {
            i++;
        }
        return a.slice(0, i);
    }
    toJSON() {
        return {
            w: this.w,
            s: this.s,
            e: this.e,
            k: this.k,
            d: Array.from(this.d),
            c: Array.from(this.c?.entries())?.map(([key, node]) => [key, node.toJSON()])
        };
    }
    static fromJSON(json) {
        const node = new RadixNode(json.k, json.s, json.e);
        node.w = json.w;
        node.d = new Set(json.d);
        node.c = new Map(json?.c?.map(([key, nodeJson]) => [key, RadixNode.fromJSON(nodeJson)]) || []);
        return node;
    }
}
class RadixTree extends RadixNode {
    constructor() {
        super('', '', false);
    }
    static fromJSON(json) {
        const tree = new RadixTree();
        tree.w = json.w;
        tree.s = json.s;
        tree.e = json.e;
        tree.k = json.k;
        tree.d = new Set(json.d);
        tree.c = new Map(json?.c?.map(([key, nodeJson]) => [key, RadixNode.fromJSON(nodeJson)]) || []);
        return tree;
    }
    toJSON() {
        return super.toJSON();
    }
}
//# sourceMappingURL=radix.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/trees/bkd.js
const K = 2; // 2D points
const EARTH_RADIUS = 6371e3; // Earth radius in meters
class BKDNode {
    point;
    docIDs;
    left;
    right;
    parent;
    constructor(point, docIDs) {
        this.point = point;
        this.docIDs = new Set(docIDs);
        this.left = null;
        this.right = null;
        this.parent = null;
    }
    toJSON() {
        return {
            point: this.point,
            docIDs: Array.from(this.docIDs),
            left: this.left ? this.left.toJSON() : null,
            right: this.right ? this.right.toJSON() : null
        };
    }
    static fromJSON(json, parent = null) {
        const node = new BKDNode(json.point, json.docIDs);
        node.parent = parent;
        if (json.left) {
            node.left = BKDNode.fromJSON(json.left, node);
        }
        if (json.right) {
            node.right = BKDNode.fromJSON(json.right, node);
        }
        return node;
    }
}
class bkd_BKDTree {
    root;
    nodeMap;
    constructor() {
        this.root = null;
        this.nodeMap = new Map();
    }
    getPointKey(point) {
        return `${point.lon},${point.lat}`;
    }
    insert(point, docIDs) {
        const pointKey = this.getPointKey(point);
        const existingNode = this.nodeMap.get(pointKey);
        if (existingNode) {
            docIDs.forEach((id) => existingNode.docIDs.add(id));
            return;
        }
        const newNode = new BKDNode(point, docIDs);
        this.nodeMap.set(pointKey, newNode);
        if (this.root == null) {
            this.root = newNode;
            return;
        }
        let node = this.root;
        let depth = 0;
        // eslint-disable-next-line no-constant-condition
        while (true) {
            const axis = depth % K;
            if (axis === 0) {
                if (point.lon < node.point.lon) {
                    if (node.left == null) {
                        node.left = newNode;
                        newNode.parent = node;
                        return;
                    }
                    node = node.left;
                }
                else {
                    if (node.right == null) {
                        node.right = newNode;
                        newNode.parent = node;
                        return;
                    }
                    node = node.right;
                }
            }
            else {
                if (point.lat < node.point.lat) {
                    if (node.left == null) {
                        node.left = newNode;
                        newNode.parent = node;
                        return;
                    }
                    node = node.left;
                }
                else {
                    if (node.right == null) {
                        node.right = newNode;
                        newNode.parent = node;
                        return;
                    }
                    node = node.right;
                }
            }
            depth++;
        }
    }
    contains(point) {
        const pointKey = this.getPointKey(point);
        return this.nodeMap.has(pointKey);
    }
    getDocIDsByCoordinates(point) {
        const pointKey = this.getPointKey(point);
        const node = this.nodeMap.get(pointKey);
        if (node) {
            return Array.from(node.docIDs);
        }
        return null;
    }
    removeDocByID(point, docID) {
        const pointKey = this.getPointKey(point);
        const node = this.nodeMap.get(pointKey);
        if (node) {
            node.docIDs.delete(docID);
            if (node.docIDs.size === 0) {
                this.nodeMap.delete(pointKey);
                this.deleteNode(node);
            }
        }
    }
    deleteNode(node) {
        const parent = node.parent;
        const child = node.left ? node.left : node.right;
        if (child) {
            child.parent = parent;
        }
        if (parent) {
            if (parent.left === node) {
                parent.left = child;
            }
            else if (parent.right === node) {
                parent.right = child;
            }
        }
        else {
            this.root = child;
            if (this.root) {
                this.root.parent = null;
            }
        }
    }
    searchByRadius(center, radius, inclusive = true, sort = 'asc', highPrecision = false) {
        const distanceFn = highPrecision ? bkd_BKDTree.vincentyDistance : bkd_BKDTree.haversineDistance;
        const stack = [{ node: this.root, depth: 0 }];
        const result = [];
        while (stack.length > 0) {
            const { node, depth } = stack.pop();
            if (node == null)
                continue;
            const dist = distanceFn(center, node.point);
            if (inclusive ? dist <= radius : dist > radius) {
                result.push({ point: node.point, docIDs: Array.from(node.docIDs) });
            }
            if (node.left != null) {
                stack.push({ node: node.left, depth: depth + 1 });
            }
            if (node.right != null) {
                stack.push({ node: node.right, depth: depth + 1 });
            }
        }
        if (sort) {
            result.sort((a, b) => {
                const distA = distanceFn(center, a.point);
                const distB = distanceFn(center, b.point);
                return sort.toLowerCase() === 'asc' ? distA - distB : distB - distA;
            });
        }
        return result;
    }
    searchByPolygon(polygon, inclusive = true, sort = null, highPrecision = false) {
        const stack = [{ node: this.root, depth: 0 }];
        const result = [];
        while (stack.length > 0) {
            const { node, depth } = stack.pop();
            if (node == null)
                continue;
            if (node.left != null) {
                stack.push({ node: node.left, depth: depth + 1 });
            }
            if (node.right != null) {
                stack.push({ node: node.right, depth: depth + 1 });
            }
            const isInsidePolygon = bkd_BKDTree.isPointInPolygon(polygon, node.point);
            if ((isInsidePolygon && inclusive) || (!isInsidePolygon && !inclusive)) {
                result.push({ point: node.point, docIDs: Array.from(node.docIDs) });
            }
        }
        const centroid = bkd_BKDTree.calculatePolygonCentroid(polygon);
        if (sort) {
            const distanceFn = highPrecision ? bkd_BKDTree.vincentyDistance : bkd_BKDTree.haversineDistance;
            result.sort((a, b) => {
                const distA = distanceFn(centroid, a.point);
                const distB = distanceFn(centroid, b.point);
                return sort.toLowerCase() === 'asc' ? distA - distB : distB - distA;
            });
        }
        return result;
    }
    toJSON() {
        return {
            root: this.root ? this.root.toJSON() : null
        };
    }
    static fromJSON(json) {
        const tree = new bkd_BKDTree();
        if (json.root) {
            tree.root = BKDNode.fromJSON(json.root);
            tree.buildNodeMap(tree.root);
        }
        return tree;
    }
    buildNodeMap(node) {
        if (node == null)
            return;
        const pointKey = this.getPointKey(node.point);
        this.nodeMap.set(pointKey, node);
        if (node.left) {
            this.buildNodeMap(node.left);
        }
        if (node.right) {
            this.buildNodeMap(node.right);
        }
    }
    static calculatePolygonCentroid(polygon) {
        let totalArea = 0;
        let centroidX = 0;
        let centroidY = 0;
        const polygonLength = polygon.length;
        for (let i = 0, j = polygonLength - 1; i < polygonLength; j = i++) {
            const xi = polygon[i].lon;
            const yi = polygon[i].lat;
            const xj = polygon[j].lon;
            const yj = polygon[j].lat;
            const areaSegment = xi * yj - xj * yi;
            totalArea += areaSegment;
            centroidX += (xi + xj) * areaSegment;
            centroidY += (yi + yj) * areaSegment;
        }
        totalArea /= 2;
        const centroidCoordinate = 6 * totalArea;
        centroidX /= centroidCoordinate;
        centroidY /= centroidCoordinate;
        return { lon: centroidX, lat: centroidY };
    }
    static isPointInPolygon(polygon, point) {
        let isInside = false;
        const x = point.lon;
        const y = point.lat;
        const polygonLength = polygon.length;
        for (let i = 0, j = polygonLength - 1; i < polygonLength; j = i++) {
            const xi = polygon[i].lon;
            const yi = polygon[i].lat;
            const xj = polygon[j].lon;
            const yj = polygon[j].lat;
            const intersect = yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;
            if (intersect)
                isInside = !isInside;
        }
        return isInside;
    }
    static haversineDistance(coord1, coord2) {
        const P = Math.PI / 180;
        const lat1 = coord1.lat * P;
        const lat2 = coord2.lat * P;
        const deltaLat = (coord2.lat - coord1.lat) * P;
        const deltaLon = (coord2.lon - coord1.lon) * P;
        const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
            Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return EARTH_RADIUS * c;
    }
    static vincentyDistance(coord1, coord2) {
        const a = 6378137;
        const f = 1 / 298.257223563;
        const b = (1 - f) * a;
        const P = Math.PI / 180;
        const lat1 = coord1.lat * P;
        const lat2 = coord2.lat * P;
        const deltaLon = (coord2.lon - coord1.lon) * P;
        const U1 = Math.atan((1 - f) * Math.tan(lat1));
        const U2 = Math.atan((1 - f) * Math.tan(lat2));
        const sinU1 = Math.sin(U1);
        const cosU1 = Math.cos(U1);
        const sinU2 = Math.sin(U2);
        const cosU2 = Math.cos(U2);
        let lambda = deltaLon;
        let prevLambda;
        let iterationLimit = 1000;
        let sinSigma;
        let cosSigma;
        let sigma;
        let sinAlpha;
        let cos2Alpha;
        let cos2SigmaM;
        do {
            const sinLambda = Math.sin(lambda);
            const cosLambda = Math.cos(lambda);
            sinSigma = Math.sqrt(cosU2 * sinLambda * (cosU2 * sinLambda) +
                (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));
            if (sinSigma === 0)
                return 0; // co-incident points
            cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
            sigma = Math.atan2(sinSigma, cosSigma);
            sinAlpha = (cosU1 * cosU2 * sinLambda) / sinSigma;
            cos2Alpha = 1 - sinAlpha * sinAlpha;
            cos2SigmaM = cosSigma - (2 * sinU1 * sinU2) / cos2Alpha;
            if (isNaN(cos2SigmaM))
                cos2SigmaM = 0;
            const C = (f / 16) * cos2Alpha * (4 + f * (4 - 3 * cos2Alpha));
            prevLambda = lambda;
            lambda =
                deltaLon +
                    (1 - C) *
                        f *
                        sinAlpha *
                        (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
        } while (Math.abs(lambda - prevLambda) > 1e-12 && --iterationLimit > 0);
        if (iterationLimit === 0) {
            return NaN;
        }
        const uSquared = (cos2Alpha * (a * a - b * b)) / (b * b);
        const A = 1 + (uSquared / 16384) * (4096 + uSquared * (-768 + uSquared * (320 - 175 * uSquared)));
        const B = (uSquared / 1024) * (256 + uSquared * (-128 + uSquared * (74 - 47 * uSquared)));
        const deltaSigma = B *
            sinSigma *
            (cos2SigmaM +
                (B / 4) *
                    (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) -
                        (B / 6) * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
        const s = b * A * (sigma - deltaSigma);
        return s;
    }
}
//# sourceMappingURL=bkd.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/trees/bool.js
class BoolNode {
    true;
    false;
    constructor() {
        this.true = new Set();
        this.false = new Set();
    }
    insert(value, bool) {
        if (bool) {
            this.true.add(value);
        }
        else {
            this.false.add(value);
        }
    }
    delete(value, bool) {
        if (bool) {
            this.true.delete(value);
        }
        else {
            this.false.delete(value);
        }
    }
    getSize() {
        return this.true.size + this.false.size;
    }
    toJSON() {
        return {
            true: Array.from(this.true),
            false: Array.from(this.false)
        };
    }
    static fromJSON(json) {
        const node = new BoolNode();
        node.true = new Set(json.true);
        node.false = new Set(json.false);
        return node;
    }
}
//# sourceMappingURL=bool.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/algorithms.js

function prioritizeTokenScores(arrays, boost, threshold = 0, keywordsCount) {
    if (boost === 0) {
        throw createError('INVALID_BOOST_VALUE');
    }
    const tokenScoresMap = new Map();
    const mapsLength = arrays.length;
    for (let i = 0; i < mapsLength; i++) {
        const arr = arrays[i];
        const entriesLength = arr.length;
        for (let j = 0; j < entriesLength; j++) {
            const [token, score] = arr[j];
            const boostScore = score * boost;
            const oldScore = tokenScoresMap.get(token)?.[0];
            if (oldScore !== undefined) {
                tokenScoresMap.set(token, [oldScore * 1.5 + boostScore, (tokenScoresMap?.get(token)?.[1] || 0) + 1]);
            }
            else {
                tokenScoresMap.set(token, [boostScore, 1]);
            }
        }
    }
    const tokenScores = [];
    for (const tokenScoreEntry of tokenScoresMap.entries()) {
        tokenScores.push([tokenScoreEntry[0], tokenScoreEntry[1][0]]);
    }
    const results = tokenScores.sort((a, b) => b[1] - a[1]);
    // If threshold is 1, it means we will return all the results with at least one search term,
    // prioritizing the ones that contains more search terms (fuzzy match)
    if (threshold === 1) {
        return results;
    }
    // For threshold = 0 when keywordsCount is 1 (single term search),
    // we return all matches since they automatically contain 100% of keywords
    if (threshold === 0 && keywordsCount === 1) {
        return results;
    }
    // Prepare keywords count tracking for threshold handling
    const allResults = results.length;
    const tokenScoreWithKeywordsCount = [];
    for (const tokenScoreEntry of tokenScoresMap.entries()) {
        tokenScoreWithKeywordsCount.push([tokenScoreEntry[0], tokenScoreEntry[1][0], tokenScoreEntry[1][1]]);
    }
    // Find the index of the last result with all keywords.
    // Order the documents by the number of keywords they contain, and then by the score.
    const keywordsPerToken = tokenScoreWithKeywordsCount.sort((a, b) => {
        // Compare by the third element, higher numbers first
        if (a[2] > b[2])
            return -1;
        if (a[2] < b[2])
            return 1;
        // If the third elements are equal, compare by the second element, higher numbers first
        if (a[1] > b[1])
            return -1;
        if (a[1] < b[1])
            return 1;
        // If both the second and third elements are equal, consider the elements equal
        return 0;
    });
    let lastTokenWithAllKeywords = undefined;
    for (let i = 0; i < allResults; i++) {
        if (keywordsPerToken[i][2] === keywordsCount) {
            lastTokenWithAllKeywords = i;
        }
        else {
            break;
        }
    }
    // If no results had all the keywords, either bail out earlier or normalize
    if (typeof lastTokenWithAllKeywords === 'undefined') {
        if (threshold === 0) {
            return [];
        }
        lastTokenWithAllKeywords = 0;
    }
    const keywordsPerTokenLength = keywordsPerToken.length;
    const resultsWithIdAndScore = new Array(keywordsPerTokenLength);
    for (let i = 0; i < keywordsPerTokenLength; i++) {
        resultsWithIdAndScore[i] = [keywordsPerToken[i][0], keywordsPerToken[i][1]];
    }
    // If threshold is 0, it means we will only return all the results that contains ALL the search terms (exact match)
    if (threshold === 0) {
        return resultsWithIdAndScore.slice(0, lastTokenWithAllKeywords + 1);
    }
    // If the threshold is between 0 and 1, we will return all the results that contains at least the threshold of search terms
    // For example, if threshold is 0.5, we will return all the results that contains at least 50% of the search terms
    // (fuzzy match with a minimum threshold)
    const thresholdLength = lastTokenWithAllKeywords + Math.ceil((threshold * 100 * (allResults - lastTokenWithAllKeywords)) / 100);
    return resultsWithIdAndScore.slice(0, Math.min(allResults, thresholdLength));
}
function BM25(tf, matchingCount, docsCount, fieldLength, averageFieldLength, { k, b, d }) {
    const idf = Math.log(1 + (docsCount - matchingCount + 0.5) / (matchingCount + 0.5));
    return (idf * (d + tf * (k + 1))) / (tf + k * (1 - b + (b * fieldLength) / averageFieldLength));
}
//# sourceMappingURL=algorithms.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/trees/vector.js
const vector_DEFAULT_SIMILARITY = 0.8;
class VectorIndex {
    size;
    vectors = new Map();
    constructor(size) {
        this.size = size;
    }
    add(internalDocumentId, value) {
        if (!(value instanceof Float32Array)) {
            value = new Float32Array(value);
        }
        const magnitude = getMagnitude(value, this.size);
        this.vectors.set(internalDocumentId, [magnitude, value]);
    }
    remove(internalDocumentId) {
        this.vectors.delete(internalDocumentId);
    }
    find(vector, similarity, whereFiltersIDs) {
        if (!(vector instanceof Float32Array)) {
            vector = new Float32Array(vector);
        }
        const results = findSimilarVectors(vector, whereFiltersIDs, this.vectors, this.size, similarity);
        return results;
    }
    toJSON() {
        const vectors = [];
        for (const [id, [magnitude, vector]] of this.vectors) {
            vectors.push([id, [magnitude, Array.from(vector)]]);
        }
        return {
            size: this.size,
            vectors,
        };
    }
    static fromJSON(json) {
        const raw = json;
        const index = new VectorIndex(raw.size);
        for (const [id, [magnitude, vector]] of raw.vectors) {
            index.vectors.set(id, [magnitude, new Float32Array(vector)]);
        }
        return index;
    }
}
function getMagnitude(vector, vectorLength) {
    let magnitude = 0;
    for (let i = 0; i < vectorLength; i++) {
        magnitude += vector[i] * vector[i];
    }
    return Math.sqrt(magnitude);
}
// @todo: Write plugins for Node and Browsers to use parallel computation for this function
function findSimilarVectors(targetVector, keys, vectors, length, threshold) {
    const targetMagnitude = getMagnitude(targetVector, length);
    const similarVectors = [];
    const base = keys ? keys : vectors.keys();
    for (const vectorId of base) {
        const entry = vectors.get(vectorId);
        if (!entry) {
            continue;
        }
        const magnitude = entry[0];
        const vector = entry[1];
        let dotProduct = 0;
        for (let i = 0; i < length; i++) {
            dotProduct += targetVector[i] * vector[i];
        }
        const similarity = dotProduct / (targetMagnitude * magnitude);
        if (similarity >= threshold) {
            similarVectors.push([vectorId, similarity]);
        }
    }
    return similarVectors;
}
//# sourceMappingURL=vector.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/index.js











function insertDocumentScoreParameters(index, prop, id, tokens, docsCount) {
    const internalId = internal_document_id_store_getInternalDocumentId(index.sharedInternalDocumentStore, id);
    index.avgFieldLength[prop] = ((index.avgFieldLength[prop] ?? 0) * (docsCount - 1) + tokens.length) / docsCount;
    index.fieldLengths[prop][internalId] = tokens.length;
    index.frequencies[prop][internalId] = {};
}
function insertTokenScoreParameters(index, prop, id, tokens, token) {
    let tokenFrequency = 0;
    for (const t of tokens) {
        if (t === token) {
            tokenFrequency++;
        }
    }
    const internalId = internal_document_id_store_getInternalDocumentId(index.sharedInternalDocumentStore, id);
    const tf = tokenFrequency / tokens.length;
    index.frequencies[prop][internalId][token] = tf;
    if (!(token in index.tokenOccurrences[prop])) {
        index.tokenOccurrences[prop][token] = 0;
    }
    // increase a token counter that may not yet exist
    index.tokenOccurrences[prop][token] = (index.tokenOccurrences[prop][token] ?? 0) + 1;
}
function removeDocumentScoreParameters(index, prop, id, docsCount) {
    const internalId = internal_document_id_store_getInternalDocumentId(index.sharedInternalDocumentStore, id);
    if (docsCount > 1) {
        index.avgFieldLength[prop] =
            (index.avgFieldLength[prop] * docsCount - index.fieldLengths[prop][internalId]) / (docsCount - 1);
    }
    else {
        index.avgFieldLength[prop] = undefined;
    }
    index.fieldLengths[prop][internalId] = undefined;
    index.frequencies[prop][internalId] = undefined;
}
function removeTokenScoreParameters(index, prop, token) {
    index.tokenOccurrences[prop][token]--;
}
function components_create(orama, sharedInternalDocumentStore, schema, index, prefix = '') {
    if (!index) {
        index = {
            sharedInternalDocumentStore,
            indexes: {},
            vectorIndexes: {},
            searchableProperties: [],
            searchablePropertiesWithTypes: {},
            frequencies: {},
            tokenOccurrences: {},
            avgFieldLength: {},
            fieldLengths: {}
        };
    }
    for (const [prop, type] of Object.entries(schema)) {
        const path = `${prefix}${prefix ? '.' : ''}${prop}`;
        if (typeof type === 'object' && !Array.isArray(type)) {
            // Nested
            components_create(orama, sharedInternalDocumentStore, type, index, path);
            continue;
        }
        if (isVectorType(type)) {
            index.searchableProperties.push(path);
            index.searchablePropertiesWithTypes[path] = type;
            index.vectorIndexes[path] = {
                type: 'Vector',
                node: new VectorIndex(getVectorSize(type)),
                isArray: false
            };
        }
        else {
            const isArray = /\[/.test(type);
            switch (type) {
                case 'boolean':
                case 'boolean[]':
                    index.indexes[path] = { type: 'Bool', node: new BoolNode(), isArray };
                    break;
                case 'number':
                case 'number[]':
                    index.indexes[path] = { type: 'AVL', node: new AVLTree(0, []), isArray };
                    break;
                case 'string':
                case 'string[]':
                    index.indexes[path] = { type: 'Radix', node: new RadixTree(), isArray };
                    index.avgFieldLength[path] = 0;
                    index.frequencies[path] = {};
                    index.tokenOccurrences[path] = {};
                    index.fieldLengths[path] = {};
                    break;
                case 'enum':
                case 'enum[]':
                    index.indexes[path] = { type: 'Flat', node: new FlatTree(), isArray };
                    break;
                case 'geopoint':
                    index.indexes[path] = { type: 'BKD', node: new bkd_BKDTree(), isArray };
                    break;
                default:
                    throw errors_createError('INVALID_SCHEMA_TYPE', Array.isArray(type) ? 'array' : type, path);
            }
            index.searchableProperties.push(path);
            index.searchablePropertiesWithTypes[path] = type;
        }
    }
    return index;
}
function insertScalarBuilder(implementation, index, prop, internalId, language, tokenizer, docsCount, options) {
    return (value) => {
        const { type, node } = index.indexes[prop];
        switch (type) {
            case 'Bool': {
                node[value ? 'true' : 'false'].add(internalId);
                break;
            }
            case 'AVL': {
                const avlRebalanceThreshold = options?.avlRebalanceThreshold ?? 1;
                node.insert(value, internalId, avlRebalanceThreshold);
                break;
            }
            case 'Radix': {
                const tokens = tokenizer.tokenize(value, language, prop, false);
                implementation.insertDocumentScoreParameters(index, prop, internalId, tokens, docsCount);
                for (const token of tokens) {
                    implementation.insertTokenScoreParameters(index, prop, internalId, tokens, token);
                    node.insert(token, internalId);
                }
                break;
            }
            case 'Flat': {
                node.insert(value, internalId);
                break;
            }
            case 'BKD': {
                node.insert(value, [internalId]);
                break;
            }
        }
    };
}
function components_insert(implementation, index, prop, id, internalId, value, schemaType, language, tokenizer, docsCount, options) {
    if (isVectorType(schemaType)) {
        return insertVector(index, prop, value, id, internalId);
    }
    const insertScalar = insertScalarBuilder(implementation, index, prop, internalId, language, tokenizer, docsCount, options);
    if (!isArrayType(schemaType)) {
        return insertScalar(value);
    }
    const elements = value;
    const elementsLength = elements.length;
    for (let i = 0; i < elementsLength; i++) {
        insertScalar(elements[i]);
    }
}
function insertVector(index, prop, value, id, internalDocumentId) {
    index.vectorIndexes[prop].node.add(internalDocumentId, value);
}
function removeScalar(implementation, index, prop, id, internalId, value, schemaType, language, tokenizer, docsCount) {
    if (isVectorType(schemaType)) {
        index.vectorIndexes[prop].node.remove(internalId);
        return true;
    }
    const { type, node } = index.indexes[prop];
    switch (type) {
        case 'AVL': {
            node.removeDocument(value, internalId);
            return true;
        }
        case 'Bool': {
            node[value ? 'true' : 'false'].delete(internalId);
            return true;
        }
        case 'Radix': {
            const tokens = tokenizer.tokenize(value, language, prop);
            implementation.removeDocumentScoreParameters(index, prop, id, docsCount);
            for (const token of tokens) {
                implementation.removeTokenScoreParameters(index, prop, token);
                node.removeDocumentByWord(token, internalId);
            }
            return true;
        }
        case 'Flat': {
            node.removeDocument(internalId, value);
            return true;
        }
        case 'BKD': {
            node.removeDocByID(value, internalId);
            return false;
        }
    }
}
function components_remove(implementation, index, prop, id, internalId, value, schemaType, language, tokenizer, docsCount) {
    if (!isArrayType(schemaType)) {
        return removeScalar(implementation, index, prop, id, internalId, value, schemaType, language, tokenizer, docsCount);
    }
    const innerSchemaType = getInnerType(schemaType);
    const elements = value;
    const elementsLength = elements.length;
    for (let i = 0; i < elementsLength; i++) {
        removeScalar(implementation, index, prop, id, internalId, elements[i], innerSchemaType, language, tokenizer, docsCount);
    }
    return true;
}
function calculateResultScores(index, prop, term, ids, docsCount, bm25Relevance, resultsMap, boostPerProperty, whereFiltersIDs, keywordMatchesMap) {
    const documentIDs = Array.from(ids);
    const avgFieldLength = index.avgFieldLength[prop];
    const fieldLengths = index.fieldLengths[prop];
    const oramaOccurrences = index.tokenOccurrences[prop];
    const oramaFrequencies = index.frequencies[prop];
    // oramaOccurrences[term] can be undefined, 0, string, or { [k: string]: number }
    const termOccurrences = typeof oramaOccurrences[term] === 'number' ? (oramaOccurrences[term] ?? 0) : 0;
    // Calculate TF-IDF value for each term, in each document, for each index.
    const documentIDsLength = documentIDs.length;
    for (let k = 0; k < documentIDsLength; k++) {
        const internalId = documentIDs[k];
        if (whereFiltersIDs && !whereFiltersIDs.has(internalId)) {
            continue;
        }
        // Track keyword matches per property
        if (!keywordMatchesMap.has(internalId)) {
            keywordMatchesMap.set(internalId, new Map());
        }
        const propertyMatches = keywordMatchesMap.get(internalId);
        propertyMatches.set(prop, (propertyMatches.get(prop) || 0) + 1);
        const tf = oramaFrequencies?.[internalId]?.[term] ?? 0;
        const bm25 = BM25(tf, termOccurrences, docsCount, fieldLengths[internalId], avgFieldLength, bm25Relevance);
        if (resultsMap.has(internalId)) {
            resultsMap.set(internalId, resultsMap.get(internalId) + bm25 * boostPerProperty);
        }
        else {
            resultsMap.set(internalId, bm25 * boostPerProperty);
        }
    }
}
function components_search(index, term, tokenizer, language, propertiesToSearch, exact, tolerance, boost, relevance, docsCount, whereFiltersIDs, threshold = 0) {
    const tokens = tokenizer.tokenize(term, language);
    const keywordsCount = tokens.length || 1;
    // Track keyword matches per document and property
    const keywordMatchesMap = new Map();
    // Track which tokens were found in the search
    const tokenFoundMap = new Map();
    const resultsMap = new Map();
    for (const prop of propertiesToSearch) {
        if (!(prop in index.indexes)) {
            continue;
        }
        const tree = index.indexes[prop];
        const { type } = tree;
        if (type !== 'Radix') {
            throw errors_createError('WRONG_SEARCH_PROPERTY_TYPE', prop);
        }
        const boostPerProperty = boost[prop] ?? 1;
        if (boostPerProperty <= 0) {
            throw errors_createError('INVALID_BOOST_VALUE', boostPerProperty);
        }
        // if the tokenizer returns an empty array, we returns all the documents
        if (tokens.length === 0 && !term) {
            tokens.push('');
        }
        // Process each token in the search term
        const tokenLength = tokens.length;
        for (let i = 0; i < tokenLength; i++) {
            const token = tokens[i];
            const searchResult = tree.node.find({ term: token, exact, tolerance });
            // See if this token was found (for threshold=0 filtering)
            const termsFound = Object.keys(searchResult);
            if (termsFound.length > 0) {
                tokenFoundMap.set(token, true);
            }
            // Process each matching term
            const termsFoundLength = termsFound.length;
            for (let j = 0; j < termsFoundLength; j++) {
                const word = termsFound[j];
                const ids = searchResult[word];
                calculateResultScores(index, prop, word, ids, docsCount, relevance, resultsMap, boostPerProperty, whereFiltersIDs, keywordMatchesMap);
            }
        }
    }
    // Convert to array and sort by score
    const results = Array.from(resultsMap.entries())
        .map(([id, score]) => [id, score])
        .sort((a, b) => b[1] - a[1]);
    if (results.length === 0) {
        return [];
    }
    // If threshold is 1, return all results
    if (threshold === 1) {
        return results;
    }
    // For threshold=0, check if all tokens were found
    if (threshold === 0) {
        // Quick return for single tokens - already validated
        if (keywordsCount === 1) {
            return results;
        }
        // For multiple tokens, verify that ALL tokens were found
        // If any token wasn't found, return an empty result
        for (const token of tokens) {
            if (!tokenFoundMap.get(token)) {
                return [];
            }
        }
        // Find documents that have all keywords in at least one property
        const fullMatches = results.filter(([id]) => {
            const propertyMatches = keywordMatchesMap.get(id);
            if (!propertyMatches)
                return false;
            // Check if any property has all keywords
            return Array.from(propertyMatches.values()).some((matches) => matches === keywordsCount);
        });
        return fullMatches;
    }
    // Find documents that have all keywords in at least one property
    const fullMatches = results.filter(([id]) => {
        const propertyMatches = keywordMatchesMap.get(id);
        if (!propertyMatches)
            return false;
        // Check if any property has all keywords
        return Array.from(propertyMatches.values()).some((matches) => matches === keywordsCount);
    });
    // If we have full matches and threshold < 1, return full matches plus a percentage of partial matches
    if (fullMatches.length > 0) {
        const remainingResults = results.filter(([id]) => !fullMatches.some(([fid]) => fid === id));
        const additionalResults = Math.ceil(remainingResults.length * threshold);
        return [...fullMatches, ...remainingResults.slice(0, additionalResults)];
    }
    // If no full matches, return all results
    return results;
}
function searchByWhereClause(index, tokenizer, filters, language) {
    // Handle logical operators
    if ('and' in filters && filters.and && Array.isArray(filters.and)) {
        const andFilters = filters.and;
        if (andFilters.length === 0) {
            return new Set();
        }
        const results = andFilters.map((filter) => searchByWhereClause(index, tokenizer, filter, language));
        return setIntersection(...results);
    }
    if ('or' in filters && filters.or && Array.isArray(filters.or)) {
        const orFilters = filters.or;
        if (orFilters.length === 0) {
            return new Set();
        }
        const results = orFilters.map((filter) => searchByWhereClause(index, tokenizer, filter, language));
        // Use reduce to union all sets
        return results.reduce((acc, set) => setUnion(acc, set), new Set());
    }
    if ('not' in filters && filters.not) {
        const notFilter = filters.not;
        // Get all document IDs from the internal document store
        const allDocs = new Set();
        // Get all document IDs from the internal document store
        const docsStore = index.sharedInternalDocumentStore;
        for (let i = 1; i <= docsStore.internalIdToId.length; i++) {
            allDocs.add(i);
        }
        const notResult = searchByWhereClause(index, tokenizer, notFilter, language);
        return setDifference(allDocs, notResult);
    }
    // Handle regular property filters (existing logic)
    const filterKeys = Object.keys(filters);
    const filtersMap = filterKeys.reduce((acc, key) => ({
        [key]: new Set(),
        ...acc
    }), {});
    for (const param of filterKeys) {
        const operation = filters[param];
        if (typeof index.indexes[param] === 'undefined') {
            throw errors_createError('UNKNOWN_FILTER_PROPERTY', param);
        }
        const { node, type, isArray } = index.indexes[param];
        if (type === 'Bool') {
            const idx = node;
            const filteredIDs = operation ? idx.true : idx.false;
            filtersMap[param] = setUnion(filtersMap[param], filteredIDs);
            continue;
        }
        if (type === 'BKD') {
            let reqOperation;
            if ('radius' in operation) {
                reqOperation = 'radius';
            }
            else if ('polygon' in operation) {
                reqOperation = 'polygon';
            }
            else {
                throw new Error(`Invalid operation ${operation}`);
            }
            if (reqOperation === 'radius') {
                const { value, coordinates, unit = 'm', inside = true, highPrecision = false } = operation[reqOperation];
                const distanceInMeters = utils_convertDistanceToMeters(value, unit);
                const ids = node.searchByRadius(coordinates, distanceInMeters, inside, undefined, highPrecision);
                filtersMap[param] = addGeoResult(filtersMap[param], ids);
            }
            else {
                const { coordinates, inside = true, highPrecision = false } = operation[reqOperation];
                const ids = node.searchByPolygon(coordinates, inside, undefined, highPrecision);
                filtersMap[param] = addGeoResult(filtersMap[param], ids);
            }
            continue;
        }
        if (type === 'Radix' && (typeof operation === 'string' || Array.isArray(operation))) {
            for (const raw of [operation].flat()) {
                const term = tokenizer.tokenize(raw, language, param);
                for (const t of term) {
                    const filteredIDsResults = node.find({ term: t, exact: true });
                    filtersMap[param] = addFindResult(filtersMap[param], filteredIDsResults);
                }
            }
            continue;
        }
        const operationKeys = Object.keys(operation);
        if (operationKeys.length > 1) {
            throw errors_createError('INVALID_FILTER_OPERATION', operationKeys.length);
        }
        if (type === 'Flat') {
            const results = new Set(isArray
                ? node.filterArr(operation)
                : node.filter(operation));
            filtersMap[param] = setUnion(filtersMap[param], results);
            continue;
        }
        if (type === 'AVL') {
            const operationOpt = operationKeys[0];
            const operationValue = operation[operationOpt];
            let filteredIDs;
            switch (operationOpt) {
                case 'gt': {
                    filteredIDs = node.greaterThan(operationValue, false);
                    break;
                }
                case 'gte': {
                    filteredIDs = node.greaterThan(operationValue, true);
                    break;
                }
                case 'lt': {
                    filteredIDs = node.lessThan(operationValue, false);
                    break;
                }
                case 'lte': {
                    filteredIDs = node.lessThan(operationValue, true);
                    break;
                }
                case 'eq': {
                    const ret = node.find(operationValue);
                    filteredIDs = ret ?? new Set();
                    break;
                }
                case 'between': {
                    const [min, max] = operationValue;
                    filteredIDs = node.rangeSearch(min, max);
                    break;
                }
                default:
                    throw errors_createError('INVALID_FILTER_OPERATION', operationOpt);
            }
            filtersMap[param] = setUnion(filtersMap[param], filteredIDs);
        }
    }
    // AND operation: calculate the intersection between all the IDs in filterMap
    return setIntersection(...Object.values(filtersMap));
}
function getSearchableProperties(index) {
    return index.searchableProperties;
}
function getSearchablePropertiesWithTypes(index) {
    return index.searchablePropertiesWithTypes;
}
function components_load(sharedInternalDocumentStore, raw) {
    const { indexes: rawIndexes, vectorIndexes: rawVectorIndexes, searchableProperties, searchablePropertiesWithTypes, frequencies, tokenOccurrences, avgFieldLength, fieldLengths } = raw;
    const indexes = {};
    const vectorIndexes = {};
    for (const prop of Object.keys(rawIndexes)) {
        const { node, type, isArray } = rawIndexes[prop];
        switch (type) {
            case 'Radix':
                indexes[prop] = {
                    type: 'Radix',
                    node: RadixTree.fromJSON(node),
                    isArray
                };
                break;
            case 'Flat':
                indexes[prop] = {
                    type: 'Flat',
                    node: FlatTree.fromJSON(node),
                    isArray
                };
                break;
            case 'AVL':
                indexes[prop] = {
                    type: 'AVL',
                    node: AVLTree.fromJSON(node),
                    isArray
                };
                break;
            case 'BKD':
                indexes[prop] = {
                    type: 'BKD',
                    node: bkd_BKDTree.fromJSON(node),
                    isArray
                };
                break;
            case 'Bool':
                indexes[prop] = {
                    type: 'Bool',
                    node: BoolNode.fromJSON(node),
                    isArray
                };
                break;
            default:
                indexes[prop] = rawIndexes[prop];
        }
    }
    for (const idx of Object.keys(rawVectorIndexes)) {
        vectorIndexes[idx] = {
            type: 'Vector',
            isArray: false,
            node: VectorIndex.fromJSON(rawVectorIndexes[idx])
        };
    }
    return {
        sharedInternalDocumentStore,
        indexes,
        vectorIndexes,
        searchableProperties,
        searchablePropertiesWithTypes,
        frequencies,
        tokenOccurrences,
        avgFieldLength,
        fieldLengths
    };
}
function components_save(index) {
    const { indexes, vectorIndexes, searchableProperties, searchablePropertiesWithTypes, frequencies, tokenOccurrences, avgFieldLength, fieldLengths } = index;
    const dumpVectorIndexes = {};
    for (const idx of Object.keys(vectorIndexes)) {
        dumpVectorIndexes[idx] = vectorIndexes[idx].node.toJSON();
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const savedIndexes = {};
    for (const name of Object.keys(indexes)) {
        const { type, node, isArray } = indexes[name];
        if (type === 'Flat' || type === 'Radix' || type === 'AVL' || type === 'BKD' || type === 'Bool') {
            savedIndexes[name] = {
                type,
                node: node.toJSON(),
                isArray
            };
        }
        else {
            savedIndexes[name] = indexes[name];
            savedIndexes[name].node = savedIndexes[name].node.toJSON();
        }
    }
    return {
        indexes: savedIndexes,
        vectorIndexes: dumpVectorIndexes,
        searchableProperties,
        searchablePropertiesWithTypes,
        frequencies,
        tokenOccurrences,
        avgFieldLength,
        fieldLengths
    };
}
function createIndex() {
    return {
        create: components_create,
        insert: components_insert,
        remove: components_remove,
        insertDocumentScoreParameters,
        insertTokenScoreParameters,
        removeDocumentScoreParameters,
        removeTokenScoreParameters,
        calculateResultScores,
        search: components_search,
        searchByWhereClause,
        getSearchableProperties,
        getSearchablePropertiesWithTypes,
        load: components_load,
        save: components_save
    };
}
function addGeoResult(set, ids) {
    if (!set) {
        set = new Set();
    }
    const idsLength = ids.length;
    for (let i = 0; i < idsLength; i++) {
        const entry = ids[i].docIDs;
        const idsLength = entry.length;
        for (let j = 0; j < idsLength; j++) {
            set.add(entry[j]);
        }
    }
    return set;
}
function createGeoTokenScores(ids, centerPoint, highPrecision = false) {
    const distanceFn = highPrecision ? BKDTree.vincentyDistance : BKDTree.haversineDistance;
    const results = [];
    // Calculate distances for all results to find the maximum
    const distances = [];
    for (const { point } of ids) {
        distances.push(distanceFn(centerPoint, point));
    }
    const maxDistance = Math.max(...distances);
    // Create results with inverse distance scores (higher score = closer)
    let index = 0;
    for (const { docIDs } of ids) {
        const distance = distances[index];
        // Use inverse score: closer points get higher scores
        // Add 1 to avoid division by zero for points at exact center
        const score = maxDistance - distance + 1;
        for (const docID of docIDs) {
            results.push([docID, score]);
        }
        index++;
    }
    // Sort by score (higher first - closer points)
    results.sort((a, b) => b[1] - a[1]);
    return results;
}
function isGeosearchOnlyQuery(filters, index) {
    const filterKeys = Object.keys(filters);
    if (filterKeys.length !== 1) {
        return { isGeoOnly: false };
    }
    const param = filterKeys[0];
    const operation = filters[param];
    if (typeof index.indexes[param] === 'undefined') {
        return { isGeoOnly: false };
    }
    const { type } = index.indexes[param];
    if (type === 'BKD' && operation && ('radius' in operation || 'polygon' in operation)) {
        return { isGeoOnly: true, geoProperty: param, geoOperation: operation };
    }
    return { isGeoOnly: false };
}
function components_searchByGeoWhereClause(index, filters) {
    const indexTyped = index;
    const geoInfo = isGeosearchOnlyQuery(filters, indexTyped);
    if (!geoInfo.isGeoOnly || !geoInfo.geoProperty || !geoInfo.geoOperation) {
        return null;
    }
    const { node } = indexTyped.indexes[geoInfo.geoProperty];
    const operation = geoInfo.geoOperation;
    // Cast node to BKDTree since we already verified it's type 'BKD'
    const bkdNode = node;
    let results;
    if ('radius' in operation) {
        const { value, coordinates, unit = 'm', inside = true, highPrecision = false } = operation.radius;
        const centerPoint = coordinates;
        const distanceInMeters = convertDistanceToMeters(value, unit);
        results = bkdNode.searchByRadius(centerPoint, distanceInMeters, inside, 'asc', highPrecision);
        return createGeoTokenScores(results, centerPoint, highPrecision);
    }
    else if ('polygon' in operation) {
        const { coordinates, inside = true, highPrecision = false } = operation.polygon;
        results = bkdNode.searchByPolygon(coordinates, inside, 'asc', highPrecision);
        const centroid = BKDTree.calculatePolygonCentroid(coordinates);
        return createGeoTokenScores(results, centroid, highPrecision);
    }
    return null;
}
function addFindResult(set, filteredIDsResults) {
    if (!set) {
        set = new Set();
    }
    const keys = Object.keys(filteredIDsResults);
    const keysLength = keys.length;
    for (let i = 0; i < keysLength; i++) {
        const ids = filteredIDsResults[keys[i]];
        const idsLength = ids.length;
        for (let j = 0; j < idsLength; j++) {
            set.add(ids[j]);
        }
    }
    return set;
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/sorter.js





function innerCreate(orama, sharedInternalDocumentStore, schema, sortableDeniedProperties, prefix) {
    const sorter = {
        language: orama.tokenizer.language,
        sharedInternalDocumentStore,
        enabled: true,
        isSorted: true,
        sortableProperties: [],
        sortablePropertiesWithTypes: {},
        sorts: {}
    };
    for (const [prop, type] of Object.entries(schema)) {
        const path = `${prefix}${prefix ? '.' : ''}${prop}`;
        if (sortableDeniedProperties.includes(path)) {
            continue;
        }
        if (typeof type === 'object' && !Array.isArray(type)) {
            // Nested
            const ret = innerCreate(orama, sharedInternalDocumentStore, type, sortableDeniedProperties, path);
            utils_safeArrayPush(sorter.sortableProperties, ret.sortableProperties);
            sorter.sorts = {
                ...sorter.sorts,
                ...ret.sorts
            };
            sorter.sortablePropertiesWithTypes = {
                ...sorter.sortablePropertiesWithTypes,
                ...ret.sortablePropertiesWithTypes
            };
            continue;
        }
        if (!isVectorType(type)) {
            switch (type) {
                case 'boolean':
                case 'number':
                case 'string':
                    sorter.sortableProperties.push(path);
                    sorter.sortablePropertiesWithTypes[path] = type;
                    sorter.sorts[path] = {
                        docs: new Map(),
                        orderedDocsToRemove: new Map(),
                        orderedDocs: [],
                        type: type
                    };
                    break;
                case 'geopoint':
                case 'enum':
                    // We don't allow to sort by enums or geopoints
                    continue;
                case 'enum[]':
                case 'boolean[]':
                case 'number[]':
                case 'string[]':
                    // We don't allow to sort by arrays
                    continue;
                default:
                    throw errors_createError('INVALID_SORT_SCHEMA_TYPE', Array.isArray(type) ? 'array' : type, path);
            }
        }
    }
    return sorter;
}
function sorter_create(orama, sharedInternalDocumentStore, schema, config) {
    const isSortEnabled = config?.enabled !== false;
    if (!isSortEnabled) {
        return {
            disabled: true
        };
    }
    return innerCreate(orama, sharedInternalDocumentStore, schema, (config || {}).unsortableProperties || [], '');
}
function sorter_insert(sorter, prop, id, value) {
    if (!sorter.enabled) {
        return;
    }
    sorter.isSorted = false;
    const internalId = internal_document_id_store_getInternalDocumentId(sorter.sharedInternalDocumentStore, id);
    const s = sorter.sorts[prop];
    // This happen during a document updating
    // Because we re-use the same internalId
    // We need to clean-up the data structure before re-inserting
    // to avoid duplicates in the orderedDocs array
    // See: https://github.com/oramasearch/orama/issues/629
    if (s.orderedDocsToRemove.has(internalId)) {
        ensureOrderedDocsAreDeletedByProperty(sorter, prop);
    }
    s.docs.set(internalId, s.orderedDocs.length);
    s.orderedDocs.push([internalId, value]);
}
function ensureIsSorted(sorter) {
    if (sorter.isSorted || !sorter.enabled) {
        return;
    }
    const properties = Object.keys(sorter.sorts);
    for (const prop of properties) {
        ensurePropertyIsSorted(sorter, prop);
    }
    sorter.isSorted = true;
}
function stringSort(language, value, d) {
    return value[1].localeCompare(d[1], getLocale(language));
}
function numberSort(value, d) {
    return value[1] - d[1];
}
function booleanSort(value, d) {
    return d[1] ? -1 : 1;
}
function ensurePropertyIsSorted(sorter, prop) {
    const s = sorter.sorts[prop];
    let predicate;
    switch (s.type) {
        case 'string':
            predicate = stringSort.bind(null, sorter.language);
            break;
        case 'number':
            predicate = numberSort.bind(null);
            break;
        case 'boolean':
            predicate = booleanSort.bind(null);
            break;
    }
    s.orderedDocs.sort(predicate);
    // Increment position for the greather documents
    const orderedDocsLength = s.orderedDocs.length;
    for (let i = 0; i < orderedDocsLength; i++) {
        const docId = s.orderedDocs[i][0];
        s.docs.set(docId, i);
    }
}
function ensureOrderedDocsAreDeleted(sorter) {
    const properties = Object.keys(sorter.sorts);
    for (const prop of properties) {
        ensureOrderedDocsAreDeletedByProperty(sorter, prop);
    }
}
function ensureOrderedDocsAreDeletedByProperty(sorter, prop) {
    const s = sorter.sorts[prop];
    if (!s.orderedDocsToRemove.size)
        return;
    s.orderedDocs = s.orderedDocs.filter((doc) => !s.orderedDocsToRemove.has(doc[0]));
    s.orderedDocsToRemove.clear();
}
function sorter_remove(sorter, prop, id) {
    if (!sorter.enabled) {
        return;
    }
    const s = sorter.sorts[prop];
    const internalId = internal_document_id_store_getInternalDocumentId(sorter.sharedInternalDocumentStore, id);
    const index = s.docs.get(internalId);
    if (!index)
        return;
    s.docs.delete(internalId);
    s.orderedDocsToRemove.set(internalId, true);
}
function sortBy(sorter, docIds, by) {
    if (!sorter.enabled) {
        throw errors_createError('SORT_DISABLED');
    }
    const property = by.property;
    const isDesc = by.order === 'DESC';
    const s = sorter.sorts[property];
    if (!s) {
        throw errors_createError('UNABLE_TO_SORT_ON_UNKNOWN_FIELD', property, sorter.sortableProperties.join(', '));
    }
    ensureOrderedDocsAreDeletedByProperty(sorter, property);
    ensureIsSorted(sorter);
    docIds.sort((a, b) => {
        // This sort algorithm works leveraging on
        // that s.docs is a map of docId -> position
        // If a document is not indexed, it will be not present in the map
        const indexOfA = s.docs.get(internal_document_id_store_getInternalDocumentId(sorter.sharedInternalDocumentStore, a[0]));
        const indexOfB = s.docs.get(internal_document_id_store_getInternalDocumentId(sorter.sharedInternalDocumentStore, b[0]));
        const isAIndexed = typeof indexOfA !== 'undefined';
        const isBIndexed = typeof indexOfB !== 'undefined';
        if (!isAIndexed && !isBIndexed) {
            return 0;
        }
        // unindexed documents are always at the end
        if (!isAIndexed) {
            return 1;
        }
        if (!isBIndexed) {
            return -1;
        }
        return isDesc ? indexOfB - indexOfA : indexOfA - indexOfB;
    });
    return docIds;
}
function getSortableProperties(sorter) {
    if (!sorter.enabled) {
        return [];
    }
    return sorter.sortableProperties;
}
function getSortablePropertiesWithTypes(sorter) {
    if (!sorter.enabled) {
        return {};
    }
    return sorter.sortablePropertiesWithTypes;
}
function sorter_load(sharedInternalDocumentStore, raw) {
    const rawDocument = raw;
    if (!rawDocument.enabled) {
        return {
            enabled: false
        };
    }
    const sorts = Object.keys(rawDocument.sorts).reduce((acc, prop) => {
        const { docs, orderedDocs, type } = rawDocument.sorts[prop];
        acc[prop] = {
            docs: new Map(Object.entries(docs).map(([k, v]) => [+k, v])),
            orderedDocsToRemove: new Map(),
            orderedDocs,
            type
        };
        return acc;
    }, {});
    return {
        sharedInternalDocumentStore,
        language: rawDocument.language,
        sortableProperties: rawDocument.sortableProperties,
        sortablePropertiesWithTypes: rawDocument.sortablePropertiesWithTypes,
        sorts,
        enabled: true,
        isSorted: rawDocument.isSorted
    };
}
function sorter_save(sorter) {
    if (!sorter.enabled) {
        return {
            enabled: false
        };
    }
    ensureOrderedDocsAreDeleted(sorter);
    ensureIsSorted(sorter);
    const sorts = Object.keys(sorter.sorts).reduce((acc, prop) => {
        const { docs, orderedDocs, type } = sorter.sorts[prop];
        acc[prop] = {
            docs: Object.fromEntries(docs.entries()),
            orderedDocs,
            type
        };
        return acc;
    }, {});
    return {
        language: sorter.language,
        sortableProperties: sorter.sortableProperties,
        sortablePropertiesWithTypes: sorter.sortablePropertiesWithTypes,
        sorts,
        enabled: sorter.enabled,
        isSorted: sorter.isSorted
    };
}
function createSorter() {
    return {
        create: sorter_create,
        insert: sorter_insert,
        remove: sorter_remove,
        save: sorter_save,
        load: sorter_load,
        sortBy,
        getSortableProperties,
        getSortablePropertiesWithTypes
    };
}
//# sourceMappingURL=sorter.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/tokenizer/diacritics.js
const DIACRITICS_CHARCODE_START = 192;
const DIACRITICS_CHARCODE_END = 383;
const CHARCODE_REPLACE_MAPPING = [
    65,
    65,
    65,
    65,
    65,
    65,
    65,
    67,
    69,
    69,
    69,
    69,
    73,
    73,
    73,
    73,
    69,
    78,
    79,
    79,
    79,
    79,
    79,
    null,
    79,
    85,
    85,
    85,
    85,
    89,
    80,
    115,
    97,
    97,
    97,
    97,
    97,
    97,
    97,
    99,
    101,
    101,
    101,
    101,
    105,
    105,
    105,
    105,
    101,
    110,
    111,
    111,
    111,
    111,
    111,
    null,
    111,
    117,
    117,
    117,
    117,
    121,
    112,
    121,
    65,
    97,
    65,
    97,
    65,
    97,
    67,
    99,
    67,
    99,
    67,
    99,
    67,
    99,
    68,
    100,
    68,
    100,
    69,
    101,
    69,
    101,
    69,
    101,
    69,
    101,
    69,
    101,
    71,
    103,
    71,
    103,
    71,
    103,
    71,
    103,
    72,
    104,
    72,
    104,
    73,
    105,
    73,
    105,
    73,
    105,
    73,
    105,
    73,
    105,
    73,
    105,
    74,
    106,
    75,
    107,
    107,
    76,
    108,
    76,
    108,
    76,
    108,
    76,
    108,
    76,
    108,
    78,
    110,
    78,
    110,
    78,
    110,
    110,
    78,
    110,
    79,
    111,
    79,
    111,
    79,
    111,
    79,
    111,
    82,
    114,
    82,
    114,
    82,
    114,
    83,
    115,
    83,
    115,
    83,
    115,
    83,
    115,
    84,
    116,
    84,
    116,
    84,
    116,
    85,
    117,
    85,
    117,
    85,
    117,
    85,
    117,
    85,
    117,
    85,
    117,
    87,
    119,
    89,
    121,
    89,
    90,
    122,
    90,
    122,
    90,
    122,
    115
];
function replaceChar(charCode) {
    if (charCode < DIACRITICS_CHARCODE_START || charCode > DIACRITICS_CHARCODE_END)
        return charCode;
    /* c8 ignore next  */
    return CHARCODE_REPLACE_MAPPING[charCode - DIACRITICS_CHARCODE_START] || charCode;
}
function replaceDiacritics(str) {
    const stringCharCode = [];
    for (let idx = 0; idx < str.length; idx++) {
        stringCharCode[idx] = replaceChar(str.charCodeAt(idx));
    }
    return String.fromCharCode(...stringCharCode);
}
//# sourceMappingURL=diacritics.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/tokenizer/english-stemmer.js
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck
const step2List = {
    ational: 'ate',
    tional: 'tion',
    enci: 'ence',
    anci: 'ance',
    izer: 'ize',
    bli: 'ble',
    alli: 'al',
    entli: 'ent',
    eli: 'e',
    ousli: 'ous',
    ization: 'ize',
    ation: 'ate',
    ator: 'ate',
    alism: 'al',
    iveness: 'ive',
    fulness: 'ful',
    ousness: 'ous',
    aliti: 'al',
    iviti: 'ive',
    biliti: 'ble',
    logi: 'log'
};
const step3List = {
    icate: 'ic',
    ative: '',
    alize: 'al',
    iciti: 'ic',
    ical: 'ic',
    ful: '',
    ness: ''
};
// Consonant
const english_stemmer_c = '[^aeiou]';
// Vowel
const english_stemmer_v = '[aeiouy]';
// Consonant sequence
const english_stemmer_C = english_stemmer_c + '[^aeiouy]*';
// Vowel sequence
const V = english_stemmer_v + '[aeiou]*';
// [C]VC... is m>0
const mgr0 = '^(' + english_stemmer_C + ')?' + V + english_stemmer_C;
// [C]VC[V] is m=1
const meq1 = '^(' + english_stemmer_C + ')?' + V + english_stemmer_C + '(' + V + ')?$';
// [C]VCVC... is m>1
const mgr1 = '^(' + english_stemmer_C + ')?' + V + english_stemmer_C + V + english_stemmer_C;
// vowel in stem
const s_v = '^(' + english_stemmer_C + ')?' + english_stemmer_v;
function english_stemmer_stemmer(w) {
    let stem;
    let suffix;
    let re;
    let re2;
    let re3;
    let re4;
    if (w.length < 3) {
        return w;
    }
    const firstch = w.substring(0, 1);
    if (firstch == 'y') {
        w = firstch.toUpperCase() + w.substring(1);
    }
    re = /^(.+?)(ss|i)es$/;
    re2 = /^(.+?)([^s])s$/;
    if (re.test(w)) {
        w = w.replace(re, '$1$2');
    }
    else if (re2.test(w)) {
        w = w.replace(re2, '$1$2');
    }
    re = /^(.+?)eed$/;
    re2 = /^(.+?)(ed|ing)$/;
    if (re.test(w)) {
        const fp = re.exec(w);
        re = new RegExp(mgr0);
        if (re.test(fp[1])) {
            re = /.$/;
            w = w.replace(re, '');
        }
    }
    else if (re2.test(w)) {
        const fp = re2.exec(w);
        stem = fp[1];
        re2 = new RegExp(s_v);
        if (re2.test(stem)) {
            w = stem;
            re2 = /(at|bl|iz)$/;
            re3 = new RegExp('([^aeiouylsz])\\1$');
            re4 = new RegExp('^' + english_stemmer_C + english_stemmer_v + '[^aeiouwxy]$');
            if (re2.test(w)) {
                w = w + 'e';
            }
            else if (re3.test(w)) {
                re = /.$/;
                w = w.replace(re, '');
            }
            else if (re4.test(w)) {
                w = w + 'e';
            }
        }
    }
    re = /^(.+?)y$/;
    if (re.test(w)) {
        const fp = re.exec(w);
        stem = fp?.[1];
        re = new RegExp(s_v);
        if (stem && re.test(stem)) {
            w = stem + 'i';
        }
    }
    re =
        /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;
    if (re.test(w)) {
        const fp = re.exec(w);
        stem = fp?.[1];
        suffix = fp?.[2];
        re = new RegExp(mgr0);
        if (stem && re.test(stem)) {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            w = stem + step2List[suffix];
        }
    }
    re = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;
    if (re.test(w)) {
        const fp = re.exec(w);
        stem = fp?.[1];
        suffix = fp?.[2];
        re = new RegExp(mgr0);
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        if (stem && re.test(stem)) {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            w = stem + step3List[suffix];
        }
    }
    re = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;
    re2 = /^(.+?)(s|t)(ion)$/;
    if (re.test(w)) {
        const fp = re.exec(w);
        stem = fp?.[1];
        re = new RegExp(mgr1);
        if (stem && re.test(stem)) {
            w = stem;
        }
    }
    else if (re2.test(w)) {
        const fp = re2.exec(w);
        stem = fp?.[1] ?? '' + fp?.[2] ?? '';
        re2 = new RegExp(mgr1);
        if (re2.test(stem)) {
            w = stem;
        }
    }
    re = /^(.+?)e$/;
    if (re.test(w)) {
        const fp = re.exec(w);
        stem = fp?.[1];
        re = new RegExp(mgr1);
        re2 = new RegExp(meq1);
        re3 = new RegExp('^' + english_stemmer_C + english_stemmer_v + '[^aeiouwxy]$');
        if (stem && (re.test(stem) || (re2.test(stem) && !re3.test(stem)))) {
            w = stem;
        }
    }
    re = /ll$/;
    re2 = new RegExp(mgr1);
    if (re.test(w) && re2.test(w)) {
        re = /.$/;
        w = w.replace(re, '');
    }
    if (firstch == 'y') {
        w = firstch.toLowerCase() + w.substring(1);
    }
    return w;
}
//# sourceMappingURL=english-stemmer.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/tokenizer/index.js




function tokenizer_normalizeToken(prop, token, withCache = true) {
    const key = `${this.language}:${prop}:${token}`;
    if (withCache && this.normalizationCache.has(key)) {
        return this.normalizationCache.get(key);
    }
    // Remove stopwords if enabled
    if (this.stopWords?.includes(token)) {
        if (withCache) {
            this.normalizationCache.set(key, '');
        }
        return '';
    }
    // Apply stemming if enabled
    if (this.stemmer && !this.stemmerSkipProperties.has(prop)) {
        token = this.stemmer(token);
    }
    token = replaceDiacritics(token);
    if (withCache) {
        this.normalizationCache.set(key, token);
    }
    return token;
}
/* c8 ignore next 10 */
function trim(text) {
    while (text[text.length - 1] === '') {
        text.pop();
    }
    while (text[0] === '') {
        text.shift();
    }
    return text;
}
function tokenize(input, language, prop, withCache = true) {
    if (language && language !== this.language) {
        throw errors_createError('LANGUAGE_NOT_SUPPORTED', language);
    }
    /* c8 ignore next 3 */
    if (typeof input !== 'string') {
        return [input];
    }
    const normalizeToken = this.normalizeToken.bind(this, prop ?? '');
    let tokens;
    if (prop && this.tokenizeSkipProperties.has(prop)) {
        tokens = [normalizeToken(input, withCache)];
    }
    else {
        const splitRule = SPLITTERS[this.language];
        tokens = input
            .toLowerCase()
            .split(splitRule)
            .map(t => normalizeToken(t, withCache))
            .filter(Boolean);
    }
    const trimTokens = trim(tokens);
    if (!this.allowDuplicates) {
        return Array.from(new Set(trimTokens));
    }
    return trimTokens;
}
function createTokenizer(config = {}) {
    if (!config.language) {
        config.language = 'english';
    }
    else if (!SUPPORTED_LANGUAGES.includes(config.language)) {
        throw errors_createError('LANGUAGE_NOT_SUPPORTED', config.language);
    }
    // Handle stemming - It is disabled by default
    let stemmer;
    if (config.stemming || (config.stemmer && !('stemming' in config))) {
        if (config.stemmer) {
            if (typeof config.stemmer !== 'function') {
                throw errors_createError('INVALID_STEMMER_FUNCTION_TYPE');
            }
            stemmer = config.stemmer;
        }
        else {
            if (config.language === 'english') {
                stemmer = english_stemmer_stemmer;
            }
            else {
                throw errors_createError('MISSING_STEMMER', config.language);
            }
        }
    }
    // Handle stopwords
    let stopWords;
    if (config.stopWords !== false) {
        stopWords = [];
        if (Array.isArray(config.stopWords)) {
            stopWords = config.stopWords;
        }
        else if (typeof config.stopWords === 'function') {
            stopWords = config.stopWords(stopWords);
        }
        else if (config.stopWords) {
            throw errors_createError('CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY');
        }
        // Make sure stopWords is just an array of strings
        if (!Array.isArray(stopWords)) {
            throw errors_createError('CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY');
        }
        for (const s of stopWords) {
            if (typeof s !== 'string') {
                throw errors_createError('CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY');
            }
        }
    }
    // Create the tokenizer
    const tokenizer = {
        tokenize,
        language: config.language,
        stemmer,
        stemmerSkipProperties: new Set(config.stemmerSkipProperties ? [config.stemmerSkipProperties].flat() : []),
        tokenizeSkipProperties: new Set(config.tokenizeSkipProperties ? [config.tokenizeSkipProperties].flat() : []),
        stopWords,
        allowDuplicates: Boolean(config.allowDuplicates),
        normalizeToken: tokenizer_normalizeToken,
        normalizationCache: new Map()
    };
    tokenizer.tokenize = tokenize.bind(tokenizer);
    tokenizer.normalizeToken = tokenizer_normalizeToken;
    return tokenizer;
}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/pinning.js
function pinning_create(sharedInternalDocumentStore) {
    return {
        sharedInternalDocumentStore,
        rules: new Map()
    };
}
function addRule(store, rule) {
    if (store.rules.has(rule.id)) {
        throw new Error(`PINNING_RULE_ALREADY_EXISTS: A pinning rule with id "${rule.id}" already exists. Use updateRule to modify it.`);
    }
    store.rules.set(rule.id, rule);
}
function updateRule(store, rule) {
    if (!store.rules.has(rule.id)) {
        throw new Error(`PINNING_RULE_NOT_FOUND: Cannot update pinning rule with id "${rule.id}" because it does not exist. Use addRule to create it.`);
    }
    store.rules.set(rule.id, rule);
}
function removeRule(store, ruleId) {
    return store.rules.delete(ruleId);
}
function getRule(store, ruleId) {
    return store.rules.get(ruleId);
}
function getAllRules(store) {
    return Array.from(store.rules.values());
}
function matchesCondition(term, condition) {
    const normalizedTerm = term.toLowerCase().trim();
    const normalizedPattern = condition.pattern.toLowerCase().trim();
    switch (condition.anchoring) {
        case 'is':
            return normalizedTerm === normalizedPattern;
        case 'starts_with':
            return normalizedTerm.startsWith(normalizedPattern);
        case 'contains':
            return normalizedTerm.includes(normalizedPattern);
        default:
            return false;
    }
}
function matchesRule(term, rule) {
    if (!term) {
        return false;
    }
    // All conditions must match (AND logic)
    return rule.conditions.every((condition) => matchesCondition(term, condition));
}
function getMatchingRules(store, term) {
    if (!term) {
        return [];
    }
    const matchingRules = [];
    for (const rule of store.rules.values()) {
        if (matchesRule(term, rule)) {
            matchingRules.push(rule);
        }
    }
    return matchingRules;
}
function pinning_load(sharedInternalDocumentStore, raw) {
    const rawStore = raw;
    return {
        sharedInternalDocumentStore,
        rules: new Map(rawStore?.rules ?? [])
    };
}
function pinning_save(store) {
    return {
        rules: Array.from(store.rules.entries())
    };
}
function createPinning() {
    return {
        create: pinning_create,
        addRule,
        updateRule,
        removeRule,
        getRule,
        getAllRules,
        getMatchingRules,
        load: pinning_load,
        save: pinning_save
    };
}
//# sourceMappingURL=pinning.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/methods/create.js











function validateComponents(components) {
    const defaultComponents = {
        formatElapsedTime: defaults_formatElapsedTime,
        getDocumentIndexId: defaults_getDocumentIndexId,
        getDocumentProperties: utils_getDocumentProperties,
        validateSchema: defaults_validateSchema
    };
    for (const rawKey of FUNCTION_COMPONENTS) {
        const key = rawKey;
        if (components[key]) {
            if (typeof components[key] !== 'function') {
                throw errors_createError('COMPONENT_MUST_BE_FUNCTION', key);
            }
        }
        else {
            components[key] = defaultComponents[key];
        }
    }
    for (const rawKey of Object.keys(components)) {
        if (!OBJECT_COMPONENTS.includes(rawKey) && !FUNCTION_COMPONENTS.includes(rawKey)) {
            throw errors_createError('UNSUPPORTED_COMPONENT', rawKey);
        }
    }
}
function create_create({ schema, sort, language, components, id, plugins }) {
    if (!components) {
        components = {};
    }
    for (const plugin of plugins ?? []) {
        if (!('getComponents' in plugin)) {
            continue;
        }
        if (typeof plugin.getComponents !== 'function') {
            continue;
        }
        const pluginComponents = plugin.getComponents(schema);
        const keys = Object.keys(pluginComponents);
        for (const key of keys) {
            if (components[key]) {
                throw errors_createError('PLUGIN_COMPONENT_CONFLICT', key, plugin.name);
            }
        }
        components = {
            ...components,
            ...pluginComponents
        };
    }
    if (!id) {
        id = uniqueId();
    }
    let tokenizer = components.tokenizer;
    let index = components.index;
    let documentsStore = components.documentsStore;
    let sorter = components.sorter;
    let pinning = components.pinning;
    if (!tokenizer) {
        // Use the default tokenizer
        tokenizer = createTokenizer({ language: language ?? 'english' });
    }
    else if (!tokenizer.tokenize) {
        // If there is no tokenizer function, we assume this is a TokenizerConfig
        tokenizer = createTokenizer(tokenizer);
    }
    else {
        const customTokenizer = tokenizer;
        tokenizer = customTokenizer;
    }
    if (components.tokenizer && language) {
        // Accept language only if a tokenizer is not provided
        throw errors_createError('NO_LANGUAGE_WITH_CUSTOM_TOKENIZER');
    }
    const internalDocumentStore = createInternalDocumentIDStore();
    index ||= createIndex();
    sorter ||= createSorter();
    documentsStore ||= createDocumentsStore();
    pinning ||= createPinning();
    // Validate all other components
    validateComponents(components);
    // Assign only recognized components and hooks
    const { getDocumentProperties, getDocumentIndexId, validateSchema, formatElapsedTime } = components;
    const orama = {
        data: {},
        caches: {},
        schema,
        tokenizer,
        index,
        sorter,
        documentsStore,
        pinning,
        internalDocumentIDStore: internalDocumentStore,
        getDocumentProperties,
        getDocumentIndexId,
        validateSchema,
        beforeInsert: [],
        afterInsert: [],
        beforeRemove: [],
        afterRemove: [],
        beforeUpdate: [],
        afterUpdate: [],
        beforeUpsert: [],
        afterUpsert: [],
        beforeSearch: [],
        afterSearch: [],
        beforeInsertMultiple: [],
        afterInsertMultiple: [],
        beforeRemoveMultiple: [],
        afterRemoveMultiple: [],
        beforeUpdateMultiple: [],
        afterUpdateMultiple: [],
        beforeUpsertMultiple: [],
        afterUpsertMultiple: [],
        afterCreate: [],
        formatElapsedTime,
        id,
        plugins,
        version: getVersion()
    };
    orama.data = {
        index: orama.index.create(orama, internalDocumentStore, schema),
        docs: orama.documentsStore.create(orama, internalDocumentStore),
        sorting: orama.sorter.create(orama, internalDocumentStore, schema, sort),
        pinning: orama.pinning.create(internalDocumentStore)
    };
    for (const hook of AVAILABLE_PLUGIN_HOOKS) {
        orama[hook] = (orama[hook] ?? []).concat(getAllPluginsByHook(orama, hook));
    }
    const afterCreate = orama['afterCreate'];
    if (afterCreate) {
        runAfterCreate(afterCreate, orama);
    }
    return orama;
}
function getVersion() {
    return '{{VERSION}}';
}
//# sourceMappingURL=create.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components.js






//# sourceMappingURL=components.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/methods/insert.js





function insert_insert(orama, doc, language, skipHooks, options) {
    const errorProperty = orama.validateSchema(doc, orama.schema);
    if (errorProperty) {
        throw errors_createError('SCHEMA_VALIDATION_FAILURE', errorProperty);
    }
    const asyncNeeded = utils_isAsyncFunction(orama.beforeInsert) ||
        utils_isAsyncFunction(orama.afterInsert) ||
        utils_isAsyncFunction(orama.index.beforeInsert) ||
        utils_isAsyncFunction(orama.index.insert) ||
        utils_isAsyncFunction(orama.index.afterInsert);
    if (asyncNeeded) {
        return innerInsertAsync(orama, doc, language, skipHooks, options);
    }
    return innerInsertSync(orama, doc, language, skipHooks, options);
}
const ENUM_TYPE = new Set(['enum', 'enum[]']);
const STRING_NUMBER_TYPE = new Set(['string', 'number']);
async function innerInsertAsync(orama, doc, language, skipHooks, options) {
    const { index, docs } = orama.data;
    const id = orama.getDocumentIndexId(doc);
    if (typeof id !== 'string') {
        throw errors_createError('DOCUMENT_ID_MUST_BE_STRING', typeof id);
    }
    const internalId = internal_document_id_store_getInternalDocumentId(orama.internalDocumentIDStore, id);
    if (!skipHooks) {
        await hooks_runSingleHook(orama.beforeInsert, orama, id, doc);
    }
    if (!orama.documentsStore.store(docs, id, internalId, doc)) {
        throw errors_createError('DOCUMENT_ALREADY_EXISTS', id);
    }
    const docsCount = orama.documentsStore.count(docs);
    const indexableProperties = orama.index.getSearchableProperties(index);
    const indexablePropertiesWithTypes = orama.index.getSearchablePropertiesWithTypes(index);
    const indexableValues = orama.getDocumentProperties(doc, indexableProperties);
    for (const [key, value] of Object.entries(indexableValues)) {
        if (typeof value === 'undefined')
            continue;
        const actualType = typeof value;
        const expectedType = indexablePropertiesWithTypes[key];
        validateDocumentProperty(actualType, expectedType, key, value);
    }
    await indexAndSortDocument(orama, id, indexableProperties, indexableValues, docsCount, language, doc, options);
    if (!skipHooks) {
        await hooks_runSingleHook(orama.afterInsert, orama, id, doc);
    }
    return id;
}
function innerInsertSync(orama, doc, language, skipHooks, options) {
    const { index, docs } = orama.data;
    const id = orama.getDocumentIndexId(doc);
    if (typeof id !== 'string') {
        throw errors_createError('DOCUMENT_ID_MUST_BE_STRING', typeof id);
    }
    const internalId = internal_document_id_store_getInternalDocumentId(orama.internalDocumentIDStore, id);
    if (!skipHooks) {
        hooks_runSingleHook(orama.beforeInsert, orama, id, doc);
    }
    if (!orama.documentsStore.store(docs, id, internalId, doc)) {
        throw errors_createError('DOCUMENT_ALREADY_EXISTS', id);
    }
    const docsCount = orama.documentsStore.count(docs);
    const indexableProperties = orama.index.getSearchableProperties(index);
    const indexablePropertiesWithTypes = orama.index.getSearchablePropertiesWithTypes(index);
    const indexableValues = orama.getDocumentProperties(doc, indexableProperties);
    for (const [key, value] of Object.entries(indexableValues)) {
        if (typeof value === 'undefined')
            continue;
        const actualType = typeof value;
        const expectedType = indexablePropertiesWithTypes[key];
        validateDocumentProperty(actualType, expectedType, key, value);
    }
    indexAndSortDocumentSync(orama, id, indexableProperties, indexableValues, docsCount, language, doc, options);
    if (!skipHooks) {
        hooks_runSingleHook(orama.afterInsert, orama, id, doc);
    }
    return id;
}
function validateDocumentProperty(actualType, expectedType, key, value) {
    if (isGeoPointType(expectedType) &&
        typeof value === 'object' &&
        typeof value.lon === 'number' &&
        typeof value.lat === 'number') {
        return;
    }
    if (isVectorType(expectedType) && Array.isArray(value))
        return;
    if (isArrayType(expectedType) && Array.isArray(value))
        return;
    if (ENUM_TYPE.has(expectedType) && STRING_NUMBER_TYPE.has(actualType))
        return;
    if (actualType !== expectedType) {
        throw errors_createError('INVALID_DOCUMENT_PROPERTY', key, expectedType, actualType);
    }
}
async function indexAndSortDocument(orama, id, indexableProperties, indexableValues, docsCount, language, doc, options) {
    for (const prop of indexableProperties) {
        const value = indexableValues[prop];
        if (typeof value === 'undefined')
            continue;
        const expectedType = orama.index.getSearchablePropertiesWithTypes(orama.data.index)[prop];
        await orama.index.beforeInsert?.(orama.data.index, prop, id, value, expectedType, language, orama.tokenizer, docsCount);
        const internalId = orama.internalDocumentIDStore.idToInternalId.get(id);
        await orama.index.insert(orama.index, orama.data.index, prop, id, internalId, value, expectedType, language, orama.tokenizer, docsCount, options);
        await orama.index.afterInsert?.(orama.data.index, prop, id, value, expectedType, language, orama.tokenizer, docsCount);
    }
    const sortableProperties = orama.sorter.getSortableProperties(orama.data.sorting);
    const sortableValues = orama.getDocumentProperties(doc, sortableProperties);
    for (const prop of sortableProperties) {
        const value = sortableValues[prop];
        if (typeof value === 'undefined')
            continue;
        const expectedType = orama.sorter.getSortablePropertiesWithTypes(orama.data.sorting)[prop];
        orama.sorter.insert(orama.data.sorting, prop, id, value, expectedType, language);
    }
}
function indexAndSortDocumentSync(orama, id, indexableProperties, indexableValues, docsCount, language, doc, options) {
    for (const prop of indexableProperties) {
        const value = indexableValues[prop];
        if (typeof value === 'undefined')
            continue;
        const expectedType = orama.index.getSearchablePropertiesWithTypes(orama.data.index)[prop];
        const internalDocumentId = internal_document_id_store_getInternalDocumentId(orama.internalDocumentIDStore, id);
        orama.index.beforeInsert?.(orama.data.index, prop, id, value, expectedType, language, orama.tokenizer, docsCount);
        orama.index.insert(orama.index, orama.data.index, prop, id, internalDocumentId, value, expectedType, language, orama.tokenizer, docsCount, options);
        orama.index.afterInsert?.(orama.data.index, prop, id, value, expectedType, language, orama.tokenizer, docsCount);
    }
    const sortableProperties = orama.sorter.getSortableProperties(orama.data.sorting);
    const sortableValues = orama.getDocumentProperties(doc, sortableProperties);
    for (const prop of sortableProperties) {
        const value = sortableValues[prop];
        if (typeof value === 'undefined')
            continue;
        const expectedType = orama.sorter.getSortablePropertiesWithTypes(orama.data.sorting)[prop];
        orama.sorter.insert(orama.data.sorting, prop, id, value, expectedType, language);
    }
}
function insertMultiple(orama, docs, batchSize, language, skipHooks, timeout) {
    const asyncNeeded = utils_isAsyncFunction(orama.afterInsertMultiple) ||
        utils_isAsyncFunction(orama.beforeInsertMultiple) ||
        utils_isAsyncFunction(orama.index.beforeInsert) ||
        utils_isAsyncFunction(orama.index.insert) ||
        utils_isAsyncFunction(orama.index.afterInsert);
    if (asyncNeeded) {
        return innerInsertMultipleAsync(orama, docs, batchSize, language, skipHooks, timeout);
    }
    return innerInsertMultipleSync(orama, docs, batchSize, language, skipHooks, timeout);
}
async function innerInsertMultipleAsync(orama, docs, batchSize = 1000, language, skipHooks, timeout = 0) {
    const ids = [];
    const processNextBatch = async (startIndex) => {
        const endIndex = Math.min(startIndex + batchSize, docs.length);
        const batch = docs.slice(startIndex, endIndex);
        for (const doc of batch) {
            const options = { avlRebalanceThreshold: batch.length };
            const id = await insert_insert(orama, doc, language, skipHooks, options);
            ids.push(id);
        }
        return endIndex;
    };
    const processAllBatches = async () => {
        let currentIndex = 0;
        while (currentIndex < docs.length) {
            const startTime = Date.now();
            currentIndex = await processNextBatch(currentIndex);
            if (timeout > 0) {
                const elapsedTime = Date.now() - startTime;
                const waitTime = timeout - elapsedTime;
                if (waitTime > 0) {
                    sleep(waitTime);
                }
            }
        }
    };
    await processAllBatches();
    if (!skipHooks) {
        await hooks_runMultipleHook(orama.afterInsertMultiple, orama, docs);
    }
    return ids;
}
function innerInsertMultipleSync(orama, docs, batchSize = 1000, language, skipHooks, timeout = 0) {
    const ids = [];
    let i = 0;
    function processNextBatch() {
        const batch = docs.slice(i * batchSize, (i + 1) * batchSize);
        if (batch.length === 0)
            return false;
        for (const doc of batch) {
            const options = { avlRebalanceThreshold: batch.length };
            const id = insert_insert(orama, doc, language, skipHooks, options);
            ids.push(id);
        }
        i++;
        return true;
    }
    function processAllBatches() {
        const startTime = Date.now();
        // eslint-disable-next-line no-constant-condition
        while (true) {
            const hasMoreBatches = processNextBatch();
            if (!hasMoreBatches)
                break;
            if (timeout > 0) {
                const elapsedTime = Date.now() - startTime;
                if (elapsedTime >= timeout) {
                    const remainingTime = timeout - (elapsedTime % timeout);
                    if (remainingTime > 0) {
                        sleep(remainingTime);
                    }
                }
            }
        }
    }
    processAllBatches();
    if (!skipHooks) {
        hooks_runMultipleHook(orama.afterInsertMultiple, orama, docs);
    }
    return ids;
}
function insert_innerInsertMultiple(orama, docs, batchSize, language, skipHooks, timeout) {
    const asyncNeeded = isAsyncFunction(orama.beforeInsert) ||
        isAsyncFunction(orama.afterInsert) ||
        isAsyncFunction(orama.index.beforeInsert) ||
        isAsyncFunction(orama.index.insert) ||
        isAsyncFunction(orama.index.afterInsert);
    if (asyncNeeded) {
        return innerInsertMultipleAsync(orama, docs, batchSize, language, skipHooks, timeout);
    }
    return innerInsertMultipleSync(orama, docs, batchSize, language, skipHooks, timeout);
}
//# sourceMappingURL=insert.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/methods/remove.js



function remove_remove(orama, id, language, skipHooks) {
    const asyncNeeded = isAsyncFunction(orama.index.beforeRemove) ||
        isAsyncFunction(orama.index.remove) ||
        isAsyncFunction(orama.index.afterRemove);
    if (asyncNeeded) {
        return removeAsync(orama, id, language, skipHooks);
    }
    return removeSync(orama, id, language, skipHooks);
}
async function removeAsync(orama, id, language, skipHooks) {
    let result = true;
    const { index, docs } = orama.data;
    const doc = orama.documentsStore.get(docs, id);
    if (!doc) {
        return false;
    }
    const internalId = getInternalDocumentId(orama.internalDocumentIDStore, id);
    const docId = getDocumentIdFromInternalId(orama.internalDocumentIDStore, internalId);
    const docsCount = orama.documentsStore.count(docs);
    if (!skipHooks) {
        await runSingleHook(orama.beforeRemove, orama, docId);
    }
    const indexableProperties = orama.index.getSearchableProperties(index);
    const indexablePropertiesWithTypes = orama.index.getSearchablePropertiesWithTypes(index);
    const values = orama.getDocumentProperties(doc, indexableProperties);
    for (const prop of indexableProperties) {
        const value = values[prop];
        if (typeof value === 'undefined') {
            continue;
        }
        const schemaType = indexablePropertiesWithTypes[prop];
        await orama.index.beforeRemove?.(orama.data.index, prop, docId, value, schemaType, language, orama.tokenizer, docsCount);
        if (!(await orama.index.remove(orama.index, orama.data.index, prop, id, internalId, value, schemaType, language, orama.tokenizer, docsCount))) {
            result = false;
        }
        await orama.index.afterRemove?.(orama.data.index, prop, docId, value, schemaType, language, orama.tokenizer, docsCount);
    }
    const sortableProperties = await orama.sorter.getSortableProperties(orama.data.sorting);
    const sortableValues = await orama.getDocumentProperties(doc, sortableProperties);
    for (const prop of sortableProperties) {
        if (typeof sortableValues[prop] === 'undefined') {
            continue;
        }
        orama.sorter.remove(orama.data.sorting, prop, id);
    }
    if (!skipHooks) {
        await runSingleHook(orama.afterRemove, orama, docId);
    }
    orama.documentsStore.remove(orama.data.docs, id, internalId);
    return result;
}
function removeSync(orama, id, language, skipHooks) {
    let result = true;
    const { index, docs } = orama.data;
    const doc = orama.documentsStore.get(docs, id);
    if (!doc) {
        return false;
    }
    const internalId = getInternalDocumentId(orama.internalDocumentIDStore, id);
    const docId = getDocumentIdFromInternalId(orama.internalDocumentIDStore, internalId);
    const docsCount = orama.documentsStore.count(docs);
    if (!skipHooks) {
        runSingleHook(orama.beforeRemove, orama, docId);
    }
    const indexableProperties = orama.index.getSearchableProperties(index);
    const indexablePropertiesWithTypes = orama.index.getSearchablePropertiesWithTypes(index);
    const values = orama.getDocumentProperties(doc, indexableProperties);
    for (const prop of indexableProperties) {
        const value = values[prop];
        if (typeof value === 'undefined') {
            continue;
        }
        const schemaType = indexablePropertiesWithTypes[prop];
        orama.index.beforeRemove?.(orama.data.index, prop, docId, value, schemaType, language, orama.tokenizer, docsCount);
        if (!orama.index.remove(orama.index, orama.data.index, prop, id, internalId, value, schemaType, language, orama.tokenizer, docsCount)) {
            result = false;
        }
        orama.index.afterRemove?.(orama.data.index, prop, docId, value, schemaType, language, orama.tokenizer, docsCount);
    }
    const sortableProperties = orama.sorter.getSortableProperties(orama.data.sorting);
    const sortableValues = orama.getDocumentProperties(doc, sortableProperties);
    for (const prop of sortableProperties) {
        if (typeof sortableValues[prop] === 'undefined') {
            continue;
        }
        orama.sorter.remove(orama.data.sorting, prop, id);
    }
    if (!skipHooks) {
        runSingleHook(orama.afterRemove, orama, docId);
    }
    orama.documentsStore.remove(orama.data.docs, id, internalId);
    return result;
}
function remove_removeMultiple(orama, ids, batchSize, language, skipHooks) {
    const asyncNeeded = isAsyncFunction(orama.index.beforeRemove) ||
        isAsyncFunction(orama.index.remove) ||
        isAsyncFunction(orama.index.afterRemove) ||
        isAsyncFunction(orama.beforeRemoveMultiple) ||
        isAsyncFunction(orama.afterRemoveMultiple);
    if (asyncNeeded) {
        return removeMultipleAsync(orama, ids, batchSize, language, skipHooks);
    }
    return removeMultipleSync(orama, ids, batchSize, language, skipHooks);
}
async function removeMultipleAsync(orama, ids, batchSize, language, skipHooks) {
    let result = 0;
    if (!batchSize) {
        batchSize = 1000;
    }
    const docIdsForHooks = skipHooks
        ? []
        : ids.map((id) => getDocumentIdFromInternalId(orama.internalDocumentIDStore, getInternalDocumentId(orama.internalDocumentIDStore, id)));
    if (!skipHooks) {
        await runMultipleHook(orama.beforeRemoveMultiple, orama, docIdsForHooks);
    }
    await new Promise((resolve, reject) => {
        let i = 0;
        async function _removeMultiple() {
            const batch = ids.slice(i * batchSize, ++i * batchSize);
            if (!batch.length) {
                return resolve();
            }
            for (const doc of batch) {
                try {
                    if (await remove_remove(orama, doc, language, skipHooks)) {
                        result++;
                    }
                }
                catch (err) {
                    reject(err);
                }
            }
            setTimeout(_removeMultiple, 0);
        }
        setTimeout(_removeMultiple, 0);
    });
    if (!skipHooks) {
        await runMultipleHook(orama.afterRemoveMultiple, orama, docIdsForHooks);
    }
    return result;
}
function removeMultipleSync(orama, ids, batchSize, language, skipHooks) {
    let result = 0;
    if (!batchSize) {
        batchSize = 1000;
    }
    const docIdsForHooks = skipHooks
        ? []
        : ids.map((id) => getDocumentIdFromInternalId(orama.internalDocumentIDStore, getInternalDocumentId(orama.internalDocumentIDStore, id)));
    if (!skipHooks) {
        runMultipleHook(orama.beforeRemoveMultiple, orama, docIdsForHooks);
    }
    let i = 0;
    function _removeMultipleSync() {
        const batch = ids.slice(i * batchSize, ++i * batchSize);
        if (!batch.length)
            return;
        for (const doc of batch) {
            if (remove_remove(orama, doc, language, skipHooks)) {
                result++;
            }
        }
        setTimeout(_removeMultipleSync, 0);
    }
    _removeMultipleSync();
    if (!skipHooks) {
        runMultipleHook(orama.afterRemoveMultiple, orama, docIdsForHooks);
    }
    return result;
}
//# sourceMappingURL=remove.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/facets.js


function sortAsc(a, b) {
    return a[1] - b[1];
}
function sortDesc(a, b) {
    return b[1] - a[1];
}
function sortingPredicateBuilder(order = 'desc') {
    return order.toLowerCase() === 'asc' ? sortAsc : sortDesc;
}
function facets_getFacets(orama, results, facetsConfig) {
    const facets = {};
    const allIDs = results.map(([id]) => id);
    const allDocs = orama.documentsStore.getMultiple(orama.data.docs, allIDs);
    const facetKeys = Object.keys(facetsConfig);
    const properties = orama.index.getSearchablePropertiesWithTypes(orama.data.index);
    for (const facet of facetKeys) {
        let values;
        // Hack to guarantee the same order of ranges as specified by the user
        // TODO: Revisit this once components land
        if (properties[facet] === 'number') {
            const { ranges } = facetsConfig[facet];
            const rangesLength = ranges.length;
            const tmp = Array.from({ length: rangesLength });
            for (let i = 0; i < rangesLength; i++) {
                const range = ranges[i];
                tmp[i] = [`${range.from}-${range.to}`, 0];
            }
            values = Object.fromEntries(tmp);
        }
        facets[facet] = {
            count: 0,
            values: values ?? {}
        };
    }
    const allDocsLength = allDocs.length;
    for (let i = 0; i < allDocsLength; i++) {
        const doc = allDocs[i];
        for (const facet of facetKeys) {
            const facetValue = facet.includes('.') ? getNested(doc, facet) : doc[facet];
            const propertyType = properties[facet];
            const facetValues = facets[facet].values;
            switch (propertyType) {
                case 'number': {
                    const ranges = facetsConfig[facet].ranges;
                    calculateNumberFacetBuilder(ranges, facetValues)(facetValue);
                    break;
                }
                case 'number[]': {
                    const alreadyInsertedValues = new Set();
                    const ranges = facetsConfig[facet].ranges;
                    const calculateNumberFacet = calculateNumberFacetBuilder(ranges, facetValues, alreadyInsertedValues);
                    for (const v of facetValue) {
                        calculateNumberFacet(v);
                    }
                    break;
                }
                case 'boolean':
                case 'enum':
                case 'string': {
                    calculateBooleanStringOrEnumFacetBuilder(facetValues, propertyType)(facetValue);
                    break;
                }
                case 'boolean[]':
                case 'enum[]':
                case 'string[]': {
                    const alreadyInsertedValues = new Set();
                    const innerType = propertyType === 'boolean[]' ? 'boolean' : 'string';
                    const calculateBooleanStringOrEnumFacet = calculateBooleanStringOrEnumFacetBuilder(facetValues, innerType, alreadyInsertedValues);
                    for (const v of facetValue) {
                        calculateBooleanStringOrEnumFacet(v);
                    }
                    break;
                }
                default:
                    throw createError('FACET_NOT_SUPPORTED', propertyType);
            }
        }
    }
    // TODO: We are looping again with the same previous keys, should we creat a single loop instead?
    for (const facet of facetKeys) {
        const currentFacet = facets[facet];
        // Count the number of values for each facet
        currentFacet.count = Object.keys(currentFacet.values).length;
        // Sort only string-based facets
        if (properties[facet] === 'string') {
            const stringFacetDefinition = facetsConfig[facet];
            const sortingPredicate = sortingPredicateBuilder(stringFacetDefinition.sort);
            currentFacet.values = Object.fromEntries(Object.entries(currentFacet.values)
                .sort(sortingPredicate)
                .slice(stringFacetDefinition.offset ?? 0, stringFacetDefinition.limit ?? 10));
        }
    }
    return facets;
}
function calculateNumberFacetBuilder(ranges, values, alreadyInsertedValues) {
    return (facetValue) => {
        for (const range of ranges) {
            const value = `${range.from}-${range.to}`;
            if (alreadyInsertedValues?.has(value)) {
                continue;
            }
            if (facetValue >= range.from && facetValue <= range.to) {
                if (values[value] === undefined) {
                    values[value] = 1;
                }
                else {
                    values[value]++;
                    alreadyInsertedValues?.add(value);
                }
            }
        }
    };
}
function calculateBooleanStringOrEnumFacetBuilder(values, propertyType, alreadyInsertedValues) {
    const defaultValue = propertyType === 'boolean' ? 'false' : '';
    return (facetValue) => {
        // String or boolean based facets
        const value = facetValue?.toString() ?? defaultValue;
        if (alreadyInsertedValues?.has(value)) {
            return;
        }
        values[value] = (values[value] ?? 0) + 1;
        alreadyInsertedValues?.add(value);
    };
}
//# sourceMappingURL=facets.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/components/groups.js



const DEFAULT_REDUCE = (/* unused pure expression or super */ null && ({
    reducer: (_, acc, res, index) => {
        acc[index] = res;
        return acc;
    },
    getInitialValue: (length) => Array.from({ length })
}));
const ALLOWED_TYPES = (/* unused pure expression or super */ null && (['string', 'number', 'boolean']));
function groups_getGroups(orama, results, groupBy) {
    const properties = groupBy.properties;
    const propertiesLength = properties.length;
    const schemaProperties = orama.index.getSearchablePropertiesWithTypes(orama.data.index);
    for (let i = 0; i < propertiesLength; i++) {
        const property = properties[i];
        if (typeof schemaProperties[property] === 'undefined') {
            throw createError('UNKNOWN_GROUP_BY_PROPERTY', property);
        }
        if (!ALLOWED_TYPES.includes(schemaProperties[property])) {
            throw createError('INVALID_GROUP_BY_PROPERTY', property, ALLOWED_TYPES.join(', '), schemaProperties[property]);
        }
    }
    const allIDs = results.map(([id]) => getDocumentIdFromInternalId(orama.internalDocumentIDStore, id));
    // allDocs is already sorted by the sortBy algorithm
    // We leverage on that to limit the number of documents returned
    const allDocs = orama.documentsStore.getMultiple(orama.data.docs, allIDs);
    const allDocsLength = allDocs.length;
    const returnedCount = groupBy.maxResult || Number.MAX_SAFE_INTEGER;
    const listOfValues = [];
    // We want to understand which documents have which values
    // and group them by the property and values
    const g = {};
    for (let i = 0; i < propertiesLength; i++) {
        const groupByKey = properties[i];
        const group = {
            property: groupByKey,
            perValue: {}
        };
        const values = new Set();
        for (let j = 0; j < allDocsLength; j++) {
            const doc = allDocs[j];
            const value = getNested(doc, groupByKey);
            // we don't want to consider undefined values
            if (typeof value === 'undefined') {
                continue;
            }
            const keyValue = typeof value !== 'boolean' ? value : '' + value;
            const perValue = group.perValue[keyValue] ?? {
                indexes: [],
                count: 0
            };
            if (perValue.count >= returnedCount) {
                // We stop early because for this value we react the limit
                continue;
            }
            // We use the index to keep track of the original order
            perValue.indexes.push(j);
            perValue.count++;
            group.perValue[keyValue] = perValue;
            values.add(value);
        }
        listOfValues.push(Array.from(values));
        g[groupByKey] = group;
    }
    const combinations = calculateCombination(listOfValues);
    const combinationsLength = combinations.length;
    const groups = [];
    for (let i = 0; i < combinationsLength; i++) {
        const combination = combinations[i];
        const combinationLength = combination.length;
        const group = {
            values: [],
            indexes: []
        };
        const indexes = [];
        for (let j = 0; j < combinationLength; j++) {
            const value = combination[j];
            const property = properties[j];
            indexes.push(g[property].perValue[(typeof value !== 'boolean' ? value : '' + value)].indexes);
            group.values.push(value);
        }
        // We leverage on the index to sort the results by the original order
        group.indexes = intersect(indexes).sort((a, b) => a - b);
        // don't generate empty groups
        if (group.indexes.length === 0) {
            continue;
        }
        groups.push(group);
    }
    const groupsLength = groups.length;
    const res = Array.from({ length: groupsLength });
    for (let i = 0; i < groupsLength; i++) {
        const group = groups[i];
        const reduce = (groupBy.reduce || DEFAULT_REDUCE);
        const docs = group.indexes.map((index) => {
            return {
                id: allIDs[index],
                score: results[index][1],
                document: allDocs[index]
            };
        });
        const func = reduce.reducer.bind(null, group.values);
        const initialValue = reduce.getInitialValue(group.indexes.length);
        const aggregationValue = docs.reduce(func, initialValue);
        res[i] = {
            values: group.values,
            result: aggregationValue
        };
    }
    return res;
}
function calculateCombination(arrs, index = 0) {
    if (index + 1 === arrs.length)
        return arrs[index].map((item) => [item]);
    const head = arrs[index];
    const c = calculateCombination(arrs, index + 1);
    const combinations = [];
    for (const value of head) {
        for (const combination of c) {
            const result = [value];
            safeArrayPush(result, combination);
            combinations.push(result);
        }
    }
    return combinations;
}
//# sourceMappingURL=groups.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/methods/search-fulltext.js










function search_fulltext_innerFullTextSearch(orama, params, language) {
    const { term, properties } = params;
    const index = orama.data.index;
    // Get searchable string properties
    let propertiesToSearch = orama.caches['propertiesToSearch'];
    if (!propertiesToSearch) {
        const propertiesToSearchWithTypes = orama.index.getSearchablePropertiesWithTypes(index);
        propertiesToSearch = orama.index.getSearchableProperties(index);
        propertiesToSearch = propertiesToSearch.filter((prop) => propertiesToSearchWithTypes[prop].startsWith('string'));
        orama.caches['propertiesToSearch'] = propertiesToSearch;
    }
    if (properties && properties !== '*') {
        for (const prop of properties) {
            if (!propertiesToSearch.includes(prop)) {
                throw createError('UNKNOWN_INDEX', prop, propertiesToSearch.join(', '));
            }
        }
        propertiesToSearch = propertiesToSearch.filter((prop) => properties.includes(prop));
    }
    // If filters are enabled, we need to get the IDs of the documents that match the filters.
    const hasFilters = Object.keys(params.where ?? {}).length > 0;
    let whereFiltersIDs;
    if (hasFilters) {
        whereFiltersIDs = orama.index.searchByWhereClause(index, orama.tokenizer, params.where, language);
    }
    let uniqueDocsIDs;
    // We need to perform the search if:
    // - we have a search term
    // - or we have properties to search
    //   in this case, we need to return all the documents that contains at least one of the given properties
    const threshold = params.threshold !== undefined && params.threshold !== null ? params.threshold : 1;
    if (term || properties) {
        const docsCount = count(orama);
        uniqueDocsIDs = orama.index.search(index, term || '', orama.tokenizer, language, propertiesToSearch, params.exact || false, params.tolerance || 0, params.boost || {}, applyDefault(params.relevance), docsCount, whereFiltersIDs, threshold);
        // When exact is true and we have a term, filter results to only include documents
        // where the original text contains the exact search term (case-sensitive).
        // This is a highly requested feature and although Orama is not case-sensitive by design,
        // this is a reasonable compromise.
        if (params.exact && term) {
            const searchTerms = term.trim().split(/\s+/);
            uniqueDocsIDs = uniqueDocsIDs.filter(([docId]) => {
                const doc = orama.documentsStore.get(orama.data.docs, docId);
                if (!doc)
                    return false;
                // Check if any of the specified properties contain the exact search term
                for (const prop of propertiesToSearch) {
                    const propValue = getPropValue(doc, prop);
                    if (typeof propValue === 'string') {
                        // Check if all search terms appear as complete words in the property value
                        const hasAllTerms = searchTerms.every((searchTerm) => {
                            // Create a regex that matches the term as a complete word (case-sensitive)
                            const regex = new RegExp(`\\b${escapeRegex(searchTerm)}\\b`);
                            return regex.test(propValue);
                        });
                        if (hasAllTerms) {
                            return true;
                        }
                    }
                }
                return false;
            });
        }
    }
    else {
        // Check if this is a geosearch-only query first
        if (hasFilters) {
            const geoResults = searchByGeoWhereClause(index, params.where);
            if (geoResults) {
                // This is a geosearch-only query with distance scoring
                uniqueDocsIDs = geoResults;
            }
            else {
                // Regular filter query without search term
                const docIds = whereFiltersIDs ? Array.from(whereFiltersIDs) : [];
                uniqueDocsIDs = docIds.map((k) => [+k, 0]);
            }
        }
        else {
            // No search term and no filters - return all documents
            const docIds = Object.keys(orama.documentsStore.getAll(orama.data.docs));
            uniqueDocsIDs = docIds.map((k) => [+k, 0]);
        }
    }
    return uniqueDocsIDs;
}
// Helper function to escape regex special characters
function escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
// Helper function to get nested property value
function getPropValue(obj, path) {
    const keys = path.split('.');
    let value = obj;
    for (const key of keys) {
        if (value && typeof value === 'object' && key in value) {
            value = value[key];
        }
        else {
            return undefined;
        }
    }
    return value;
}
function search_fulltext_fullTextSearch(orama, params, language) {
    const timeStart = getNanosecondsTime();
    function performSearchLogic() {
        const vectorProperties = Object.keys(orama.data.index.vectorIndexes);
        const shouldCalculateFacets = params.facets && Object.keys(params.facets).length > 0;
        const { limit = 10, offset = 0, distinctOn, includeVectors = false } = params;
        const isPreflight = params.preflight === true;
        let uniqueDocsArray = search_fulltext_innerFullTextSearch(orama, params, language);
        if (params.sortBy) {
            if (typeof params.sortBy === 'function') {
                const ids = uniqueDocsArray.map(([id]) => id);
                const docs = orama.documentsStore.getMultiple(orama.data.docs, ids);
                const docsWithIdAndScore = docs.map((d, i) => [
                    uniqueDocsArray[i][0],
                    uniqueDocsArray[i][1],
                    d
                ]);
                docsWithIdAndScore.sort(params.sortBy);
                uniqueDocsArray = docsWithIdAndScore.map(([id, score]) => [id, score]);
            }
            else {
                uniqueDocsArray = orama.sorter
                    .sortBy(orama.data.sorting, uniqueDocsArray, params.sortBy)
                    .map(([id, score]) => [getInternalDocumentId(orama.internalDocumentIDStore, id), score]);
            }
        }
        else {
            uniqueDocsArray = uniqueDocsArray.sort(sortTokenScorePredicate);
        }
        // Apply pinning rules after sorting but before pagination
        uniqueDocsArray = applyPinningRules(orama, orama.data.pinning, uniqueDocsArray, params.term);
        let results;
        if (!isPreflight) {
            results = distinctOn
                ? fetchDocumentsWithDistinct(orama, uniqueDocsArray, offset, limit, distinctOn)
                : fetchDocuments(orama, uniqueDocsArray, offset, limit);
        }
        const searchResult = {
            elapsed: {
                formatted: '',
                raw: 0
            },
            hits: [],
            count: uniqueDocsArray.length
        };
        if (typeof results !== 'undefined') {
            searchResult.hits = results.filter(Boolean);
            if (!includeVectors) {
                removeVectorsFromHits(searchResult, vectorProperties);
            }
        }
        if (shouldCalculateFacets) {
            const facets = getFacets(orama, uniqueDocsArray, params.facets);
            searchResult.facets = facets;
        }
        if (params.groupBy) {
            searchResult.groups = getGroups(orama, uniqueDocsArray, params.groupBy);
        }
        searchResult.elapsed = orama.formatElapsedTime(getNanosecondsTime() - timeStart);
        return searchResult;
    }
    async function executeSearchAsync() {
        if (orama.beforeSearch) {
            await runBeforeSearch(orama.beforeSearch, orama, params, language);
        }
        const searchResult = performSearchLogic();
        if (orama.afterSearch) {
            await runAfterSearch(orama.afterSearch, orama, params, language, searchResult);
        }
        return searchResult;
    }
    const asyncNeeded = orama.beforeSearch?.length || orama.afterSearch?.length;
    if (asyncNeeded) {
        return executeSearchAsync();
    }
    return performSearchLogic();
}
const defaultBM25Params = (/* unused pure expression or super */ null && ({
    k: 1.2,
    b: 0.75,
    d: 0.5
}));
function applyDefault(bm25Relevance) {
    const r = bm25Relevance ?? {};
    r.k = r.k ?? defaultBM25Params.k;
    r.b = r.b ?? defaultBM25Params.b;
    r.d = r.d ?? defaultBM25Params.d;
    return r;
}
//# sourceMappingURL=search-fulltext.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/methods/search-vector.js








function search_vector_innerVectorSearch(orama, params, language) {
    const vector = params.vector;
    if (vector && (!('value' in vector) || !('property' in vector))) {
        throw createError('INVALID_VECTOR_INPUT', Object.keys(vector).join(', '));
    }
    const vectorIndex = orama.data.index.vectorIndexes[vector.property];
    if (!vectorIndex) {
        throw createError('UNKNOWN_VECTOR_PROPERTY', vector.property);
    }
    const vectorSize = vectorIndex.node.size;
    if (vector?.value.length !== vectorSize) {
        if (vector?.property === undefined || vector?.value.length === undefined) {
            throw createError('INVALID_INPUT_VECTOR', 'undefined', vectorSize, 'undefined');
        }
        throw createError('INVALID_INPUT_VECTOR', vector.property, vectorSize, vector.value.length);
    }
    const index = orama.data.index;
    let whereFiltersIDs;
    const hasFilters = Object.keys(params.where ?? {}).length > 0;
    if (hasFilters) {
        whereFiltersIDs = orama.index.searchByWhereClause(index, orama.tokenizer, params.where, language);
    }
    return vectorIndex.node.find(vector.value, params.similarity ?? DEFAULT_SIMILARITY, whereFiltersIDs);
}
function search_vector_searchVector(orama, params, language = 'english') {
    const timeStart = getNanosecondsTime();
    function performSearchLogic() {
        let results = search_vector_innerVectorSearch(orama, params, language)
            .sort(sortTokenScorePredicate);
        // Apply pinning rules after sorting but before pagination
        results = applyPinningRules(orama, orama.data.pinning, results, undefined);
        let facetsResults = [];
        const shouldCalculateFacets = params.facets && Object.keys(params.facets).length > 0;
        if (shouldCalculateFacets) {
            const facets = getFacets(orama, results, params.facets);
            facetsResults = facets;
        }
        const vectorProperty = params.vector.property;
        const includeVectors = params.includeVectors ?? false;
        const limit = params.limit ?? 10;
        const offset = params.offset ?? 0;
        const docs = Array.from({ length: limit });
        for (let i = 0; i < limit; i++) {
            const result = results[i + offset];
            if (!result) {
                break;
            }
            const doc = orama.data.docs.docs[result[0]];
            if (doc) {
                if (!includeVectors) {
                    doc[vectorProperty] = null;
                }
                const newDoc = {
                    id: getDocumentIdFromInternalId(orama.internalDocumentIDStore, result[0]),
                    score: result[1],
                    document: doc
                };
                docs[i] = newDoc;
            }
        }
        let groups = [];
        if (params.groupBy) {
            groups = getGroups(orama, results, params.groupBy);
        }
        const timeEnd = getNanosecondsTime();
        const elapsedTime = timeEnd - timeStart;
        return {
            count: results.length,
            hits: docs.filter(Boolean),
            elapsed: {
                raw: Number(elapsedTime),
                formatted: formatNanoseconds(elapsedTime)
            },
            ...(facetsResults ? { facets: facetsResults } : {}),
            ...(groups ? { groups } : {})
        };
    }
    async function executeSearchAsync() {
        if (orama.beforeSearch) {
            await runBeforeSearch(orama.beforeSearch, orama, params, language);
        }
        const results = performSearchLogic();
        if (orama.afterSearch) {
            await runAfterSearch(orama.afterSearch, orama, params, language, results);
        }
        return results;
    }
    const asyncNeeded = orama.beforeSearch?.length || orama.afterSearch?.length;
    if (asyncNeeded) {
        return executeSearchAsync();
    }
    // Sync path
    return performSearchLogic();
}
//# sourceMappingURL=search-vector.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/methods/search-hybrid.js








function innerHybridSearch(orama, params, language) {
    const fullTextIDs = minMaxScoreNormalization(innerFullTextSearch(orama, params, language));
    const vectorIDs = innerVectorSearch(orama, params, language);
    const hybridWeights = params.hybridWeights;
    return mergeAndRankResults(fullTextIDs, vectorIDs, params.term ?? '', hybridWeights);
}
function search_hybrid_hybridSearch(orama, params, language) {
    const timeStart = getNanosecondsTime();
    function performSearchLogic() {
        let uniqueTokenScores = innerHybridSearch(orama, params, language);
        // Apply pinning rules after merging results but before pagination
        uniqueTokenScores = applyPinningRules(orama, orama.data.pinning, uniqueTokenScores, params.term);
        let facetsResults;
        const shouldCalculateFacets = params.facets && Object.keys(params.facets).length > 0;
        if (shouldCalculateFacets) {
            facetsResults = getFacets(orama, uniqueTokenScores, params.facets);
        }
        let groups;
        if (params.groupBy) {
            groups = getGroups(orama, uniqueTokenScores, params.groupBy);
        }
        const offset = params.offset ?? 0;
        const limit = params.limit ?? 10;
        const results = fetchDocuments(orama, uniqueTokenScores, offset, limit).filter(Boolean);
        const timeEnd = getNanosecondsTime();
        const returningResults = {
            count: uniqueTokenScores.length,
            elapsed: {
                raw: Number(timeEnd - timeStart),
                formatted: formatNanoseconds(timeEnd - timeStart)
            },
            hits: results,
            ...(facetsResults ? { facets: facetsResults } : {}),
            ...(groups ? { groups } : {})
        };
        const includeVectors = params.includeVectors ?? false;
        if (!includeVectors) {
            const vectorProperties = Object.keys(orama.data.index.vectorIndexes);
            removeVectorsFromHits(returningResults, vectorProperties);
        }
        return returningResults;
    }
    async function executeSearchAsync() {
        if (orama.beforeSearch) {
            await runBeforeSearch(orama.beforeSearch, orama, params, language);
        }
        const results = performSearchLogic();
        if (orama.afterSearch) {
            await runAfterSearch(orama.afterSearch, orama, params, language, results);
        }
        return results;
    }
    const asyncNeeded = orama.beforeSearch?.length || orama.afterSearch?.length;
    if (asyncNeeded) {
        return executeSearchAsync();
    }
    return performSearchLogic();
}
function extractScore(token) {
    return token[1];
}
function minMaxScoreNormalization(results) {
    // In this case I disabled the `prefer-spread` rule because spread seems to be slower
    // eslint-disable-next-line prefer-spread
    const maxScore = Math.max.apply(Math, results.map(extractScore));
    return results.map(([id, score]) => [id, score / maxScore]);
}
function normalizeScore(score, maxScore) {
    return score / maxScore;
}
function hybridScoreBuilder(textWeight, vectorWeight) {
    return (textScore, vectorScore) => textScore * textWeight + vectorScore * vectorWeight;
}
function mergeAndRankResults(textResults, vectorResults, query, hybridWeights) {
    // eslint-disable-next-line prefer-spread
    const maxTextScore = Math.max.apply(Math, textResults.map(extractScore));
    // eslint-disable-next-line prefer-spread
    const maxVectorScore = Math.max.apply(Math, vectorResults.map(extractScore));
    const hasHybridWeights = hybridWeights && hybridWeights.text && hybridWeights.vector;
    const { text: textWeight, vector: vectorWeight } = hasHybridWeights ? hybridWeights : getQueryWeights(query);
    const mergedResults = new Map();
    const textResultsLength = textResults.length;
    const hybridScore = hybridScoreBuilder(textWeight, vectorWeight);
    for (let i = 0; i < textResultsLength; i++) {
        const [id, score] = textResults[i];
        const normalizedScore = normalizeScore(score, maxTextScore);
        const hybridScoreValue = hybridScore(normalizedScore, 0);
        mergedResults.set(id, hybridScoreValue);
    }
    const vectorResultsLength = vectorResults.length;
    for (let i = 0; i < vectorResultsLength; i++) {
        const [resultId, score] = vectorResults[i];
        const normalizedScore = normalizeScore(score, maxVectorScore);
        const existingRes = mergedResults.get(resultId) ?? 0;
        mergedResults.set(resultId, existingRes + hybridScore(0, normalizedScore));
    }
    return [...mergedResults].sort((a, b) => b[1] - a[1]);
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function getQueryWeights(query) {
    // In the next versions of Orama, we will ship a plugin containing a ML model to adjust the weights
    // based on whether the query is keyword-focused, conceptual, etc.
    // For now, we just return a fixed value.
    return {
        text: 0.5,
        vector: 0.5
    };
}
//# sourceMappingURL=search-hybrid.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/methods/search.js







function search_search(orama, params, language) {
    const mode = params.mode ?? MODE_FULLTEXT_SEARCH;
    if (mode === MODE_FULLTEXT_SEARCH) {
        return fullTextSearch(orama, params, language);
    }
    if (mode === MODE_VECTOR_SEARCH) {
        return searchVector(orama, params);
    }
    if (mode === MODE_HYBRID_SEARCH) {
        return hybridSearch(orama, params);
    }
    throw createError('INVALID_SEARCH_MODE', mode);
}
function search_fetchDocumentsWithDistinct(orama, uniqueDocsArray, offset, limit, distinctOn) {
    const docs = orama.data.docs;
    // Keep track which values we already seen
    const values = new Map();
    // We cannot know how many results we will have in the end,
    // so we need cannot pre-allocate the array.
    const results = [];
    const resultIDs = new Set();
    const uniqueDocsArrayLength = uniqueDocsArray.length;
    let count = 0;
    for (let i = 0; i < uniqueDocsArrayLength; i++) {
        const idAndScore = uniqueDocsArray[i];
        // If there are no more results, just break the loop
        if (typeof idAndScore === 'undefined') {
            continue;
        }
        const [id, score] = idAndScore;
        if (resultIDs.has(id)) {
            continue;
        }
        const doc = orama.documentsStore.get(docs, id);
        const value = getNested(doc, distinctOn);
        if (typeof value === 'undefined' || values.has(value)) {
            continue;
        }
        values.set(value, true);
        count++;
        // We shouldn't consider the document if it's not in the offset range
        if (count <= offset) {
            continue;
        }
        results.push({ id: getDocumentIdFromInternalId(orama.internalDocumentIDStore, id), score, document: doc });
        resultIDs.add(id);
        // reached the limit, break the loop
        if (count >= offset + limit) {
            break;
        }
    }
    return results;
}
function search_fetchDocuments(orama, uniqueDocsArray, offset, limit) {
    const docs = orama.data.docs;
    const results = Array.from({
        length: limit
    });
    const resultIDs = new Set();
    // We already have the list of ALL the document IDs containing the search terms.
    // We loop over them starting from a positional value "offset" and ending at "offset + limit"
    // to provide pagination capabilities to the search.
    for (let i = offset; i < limit + offset; i++) {
        const idAndScore = uniqueDocsArray[i];
        // If there are no more results, just break the loop
        if (typeof idAndScore === 'undefined') {
            break;
        }
        const [id, score] = idAndScore;
        if (!resultIDs.has(id)) {
            // We retrieve the full document only AFTER making sure that we really want it.
            // We never retrieve the full document preventively.
            const fullDoc = orama.documentsStore.get(docs, id);
            results[i] = { id: getDocumentIdFromInternalId(orama.internalDocumentIDStore, id), score, document: fullDoc };
            resultIDs.add(id);
        }
    }
    return results;
}
//# sourceMappingURL=search.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/methods/serialization.js
function serialization_load(orama, raw) {
    orama.internalDocumentIDStore.load(orama, raw.internalDocumentIDStore);
    orama.data.index = orama.index.load(orama.internalDocumentIDStore, raw.index);
    orama.data.docs = orama.documentsStore.load(orama.internalDocumentIDStore, raw.docs);
    orama.data.sorting = orama.sorter.load(orama.internalDocumentIDStore, raw.sorting);
    orama.data.pinning = orama.pinning.load(orama.internalDocumentIDStore, raw.pinning);
    orama.tokenizer.language = raw.language;
}
function serialization_save(orama) {
    return {
        internalDocumentIDStore: orama.internalDocumentIDStore.save(orama.internalDocumentIDStore),
        index: orama.index.save(orama.data.index),
        docs: orama.documentsStore.save(orama.data.docs),
        sorting: orama.sorter.save(orama.data.sorting),
        pinning: orama.pinning.save(orama.data.pinning),
        language: orama.tokenizer.language
    };
}
//# sourceMappingURL=serialization.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/methods/update.js





function update_update(orama, id, doc, language, skipHooks) {
    const asyncNeeded = isAsyncFunction(orama.afterInsert) ||
        isAsyncFunction(orama.beforeInsert) ||
        isAsyncFunction(orama.afterRemove) ||
        isAsyncFunction(orama.beforeRemove) ||
        isAsyncFunction(orama.beforeUpdate) ||
        isAsyncFunction(orama.afterUpdate);
    if (asyncNeeded) {
        return updateAsync(orama, id, doc, language, skipHooks);
    }
    return updateSync(orama, id, doc, language, skipHooks);
}
async function updateAsync(orama, id, doc, language, skipHooks) {
    if (!skipHooks && orama.beforeUpdate) {
        await runSingleHook(orama.beforeUpdate, orama, id);
    }
    await remove(orama, id, language, skipHooks);
    const newId = await insert(orama, doc, language, skipHooks);
    if (!skipHooks && orama.afterUpdate) {
        await runSingleHook(orama.afterUpdate, orama, newId);
    }
    return newId;
}
function updateSync(orama, id, doc, language, skipHooks) {
    if (!skipHooks && orama.beforeUpdate) {
        runSingleHook(orama.beforeUpdate, orama, id);
    }
    remove(orama, id, language, skipHooks);
    const newId = insert(orama, doc, language, skipHooks);
    if (!skipHooks && orama.afterUpdate) {
        runSingleHook(orama.afterUpdate, orama, newId);
    }
    return newId;
}
function update_updateMultiple(orama, ids, docs, batchSize, language, skipHooks) {
    const asyncNeeded = isAsyncFunction(orama.afterInsert) ||
        isAsyncFunction(orama.beforeInsert) ||
        isAsyncFunction(orama.afterRemove) ||
        isAsyncFunction(orama.beforeRemove) ||
        isAsyncFunction(orama.beforeUpdate) ||
        isAsyncFunction(orama.afterUpdate) ||
        isAsyncFunction(orama.beforeUpdateMultiple) ||
        isAsyncFunction(orama.afterUpdateMultiple) ||
        isAsyncFunction(orama.beforeRemoveMultiple) ||
        isAsyncFunction(orama.afterRemoveMultiple) ||
        isAsyncFunction(orama.beforeInsertMultiple) ||
        isAsyncFunction(orama.afterInsertMultiple);
    if (asyncNeeded) {
        return updateMultipleAsync(orama, ids, docs, batchSize, language, skipHooks);
    }
    return updateMultipleSync(orama, ids, docs, batchSize, language, skipHooks);
}
async function updateMultipleAsync(orama, ids, docs, batchSize, language, skipHooks) {
    if (!skipHooks) {
        await runMultipleHook(orama.beforeUpdateMultiple, orama, ids);
    }
    const docsLength = docs.length;
    for (let i = 0; i < docsLength; i++) {
        const errorProperty = orama.validateSchema(docs[i], orama.schema);
        if (errorProperty) {
            throw createError('SCHEMA_VALIDATION_FAILURE', errorProperty);
        }
    }
    await removeMultiple(orama, ids, batchSize, language, skipHooks);
    const newIds = await innerInsertMultiple(orama, docs, batchSize, language, skipHooks);
    if (!skipHooks) {
        await runMultipleHook(orama.afterUpdateMultiple, orama, newIds);
    }
    return newIds;
}
function updateMultipleSync(orama, ids, docs, batchSize, language, skipHooks) {
    if (!skipHooks) {
        runMultipleHook(orama.beforeUpdateMultiple, orama, ids);
    }
    const docsLength = docs.length;
    for (let i = 0; i < docsLength; i++) {
        const errorProperty = orama.validateSchema(docs[i], orama.schema);
        if (errorProperty) {
            throw createError('SCHEMA_VALIDATION_FAILURE', errorProperty);
        }
    }
    removeMultiple(orama, ids, batchSize, language, skipHooks);
    const newIds = innerInsertMultiple(orama, docs, batchSize, language, skipHooks);
    if (!skipHooks) {
        runMultipleHook(orama.afterUpdateMultiple, orama, newIds);
    }
    return newIds;
}
//# sourceMappingURL=update.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/methods/upsert.js





function upsert(orama, doc, language, skipHooks, options) {
    const asyncNeeded = isAsyncFunction(orama.afterInsert) ||
        isAsyncFunction(orama.beforeInsert) ||
        isAsyncFunction(orama.afterRemove) ||
        isAsyncFunction(orama.beforeRemove) ||
        isAsyncFunction(orama.beforeUpdate) ||
        isAsyncFunction(orama.afterUpdate) ||
        isAsyncFunction(orama.beforeUpsert) ||
        isAsyncFunction(orama.afterUpsert) ||
        isAsyncFunction(orama.index.beforeInsert) ||
        isAsyncFunction(orama.index.insert) ||
        isAsyncFunction(orama.index.afterInsert);
    if (asyncNeeded) {
        return upsertAsync(orama, doc, language, skipHooks, options);
    }
    return upsertSync(orama, doc, language, skipHooks, options);
}
async function upsertAsync(orama, doc, language, skipHooks, options) {
    const id = orama.getDocumentIndexId(doc);
    if (typeof id !== 'string') {
        throw createError('DOCUMENT_ID_MUST_BE_STRING', typeof id);
    }
    if (!skipHooks && orama.beforeUpsert) {
        await runSingleHook(orama.beforeUpsert, orama, id, doc);
    }
    // Check if document exists
    const existingDoc = orama.documentsStore.get(orama.data.docs, id);
    let resultId;
    if (existingDoc) {
        // Document exists, update it
        resultId = await update(orama, id, doc, language, skipHooks);
    }
    else {
        // Document doesn't exist, insert it
        resultId = await insert(orama, doc, language, skipHooks, options);
    }
    if (!skipHooks && orama.afterUpsert) {
        await runSingleHook(orama.afterUpsert, orama, resultId, doc);
    }
    return resultId;
}
function upsertSync(orama, doc, language, skipHooks, options) {
    const id = orama.getDocumentIndexId(doc);
    if (typeof id !== 'string') {
        throw createError('DOCUMENT_ID_MUST_BE_STRING', typeof id);
    }
    if (!skipHooks && orama.beforeUpsert) {
        runSingleHook(orama.beforeUpsert, orama, id, doc);
    }
    // Check if document exists
    const existingDoc = orama.documentsStore.get(orama.data.docs, id);
    let resultId;
    if (existingDoc) {
        // Document exists, update it
        resultId = update(orama, id, doc, language, skipHooks);
    }
    else {
        // Document doesn't exist, insert it
        resultId = insert(orama, doc, language, skipHooks, options);
    }
    if (!skipHooks && orama.afterUpsert) {
        runSingleHook(orama.afterUpsert, orama, resultId, doc);
    }
    return resultId;
}
function upsertMultiple(orama, docs, batchSize, language, skipHooks) {
    const asyncNeeded = isAsyncFunction(orama.afterInsert) ||
        isAsyncFunction(orama.beforeInsert) ||
        isAsyncFunction(orama.afterRemove) ||
        isAsyncFunction(orama.beforeRemove) ||
        isAsyncFunction(orama.beforeUpdate) ||
        isAsyncFunction(orama.afterUpdate) ||
        isAsyncFunction(orama.beforeUpsert) ||
        isAsyncFunction(orama.afterUpsert) ||
        isAsyncFunction(orama.beforeUpsertMultiple) ||
        isAsyncFunction(orama.afterUpsertMultiple) ||
        isAsyncFunction(orama.beforeInsertMultiple) ||
        isAsyncFunction(orama.afterInsertMultiple) ||
        isAsyncFunction(orama.beforeUpdateMultiple) ||
        isAsyncFunction(orama.afterUpdateMultiple) ||
        isAsyncFunction(orama.beforeRemoveMultiple) ||
        isAsyncFunction(orama.afterRemoveMultiple) ||
        isAsyncFunction(orama.index.beforeInsert) ||
        isAsyncFunction(orama.index.insert) ||
        isAsyncFunction(orama.index.afterInsert);
    if (asyncNeeded) {
        return upsertMultipleAsync(orama, docs, batchSize, language, skipHooks);
    }
    return upsertMultipleSync(orama, docs, batchSize, language, skipHooks);
}
async function upsertMultipleAsync(orama, docs, batchSize, language, skipHooks) {
    if (!skipHooks && orama.beforeUpsertMultiple) {
        await runMultipleHook(orama.beforeUpsertMultiple, orama, docs);
    }
    // Validate all documents first
    const docsLength = docs.length;
    for (let i = 0; i < docsLength; i++) {
        const errorProperty = orama.validateSchema(docs[i], orama.schema);
        if (errorProperty) {
            throw createError('SCHEMA_VALIDATION_FAILURE', errorProperty);
        }
    }
    // Separate documents into insert and update arrays
    const docsToInsert = [];
    const docsToUpdate = [];
    const idsToUpdate = [];
    for (const doc of docs) {
        const id = orama.getDocumentIndexId(doc);
        if (typeof id !== 'string') {
            throw createError('DOCUMENT_ID_MUST_BE_STRING', typeof id);
        }
        const existingDoc = orama.documentsStore.get(orama.data.docs, id);
        if (existingDoc) {
            docsToUpdate.push(doc);
            idsToUpdate.push(id);
        }
        else {
            docsToInsert.push(doc);
        }
    }
    // Perform bulk operations
    const results = [];
    if (docsToUpdate.length > 0) {
        const updateResults = await updateMultiple(orama, idsToUpdate, docsToUpdate, batchSize, language, skipHooks);
        results.push(...updateResults);
    }
    if (docsToInsert.length > 0) {
        const insertResults = await innerInsertMultiple(orama, docsToInsert, batchSize, language, skipHooks);
        results.push(...insertResults);
    }
    if (!skipHooks && orama.afterUpsertMultiple) {
        await runMultipleHook(orama.afterUpsertMultiple, orama, results);
    }
    return results;
}
function upsertMultipleSync(orama, docs, batchSize, language, skipHooks) {
    if (!skipHooks && orama.beforeUpsertMultiple) {
        runMultipleHook(orama.beforeUpsertMultiple, orama, docs);
    }
    // Validate all documents first
    const docsLength = docs.length;
    for (let i = 0; i < docsLength; i++) {
        const errorProperty = orama.validateSchema(docs[i], orama.schema);
        if (errorProperty) {
            throw createError('SCHEMA_VALIDATION_FAILURE', errorProperty);
        }
    }
    // Separate documents into insert and update arrays
    const docsToInsert = [];
    const docsToUpdate = [];
    const idsToUpdate = [];
    for (const doc of docs) {
        const id = orama.getDocumentIndexId(doc);
        if (typeof id !== 'string') {
            throw createError('DOCUMENT_ID_MUST_BE_STRING', typeof id);
        }
        const existingDoc = orama.documentsStore.get(orama.data.docs, id);
        if (existingDoc) {
            docsToUpdate.push(doc);
            idsToUpdate.push(id);
        }
        else {
            docsToInsert.push(doc);
        }
    }
    // Perform bulk operations
    const results = [];
    if (docsToUpdate.length > 0) {
        const updateResults = updateMultiple(orama, idsToUpdate, docsToUpdate, batchSize, language, skipHooks);
        results.push(...updateResults);
    }
    if (docsToInsert.length > 0) {
        const insertResults = innerInsertMultiple(orama, docsToInsert, batchSize, language, skipHooks);
        results.push(...insertResults);
    }
    if (!skipHooks && orama.afterUpsertMultiple) {
        runMultipleHook(orama.afterUpsertMultiple, orama, results);
    }
    return results;
}
//# sourceMappingURL=upsert.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/methods/answer-session.js


const ORAMA_SECURE_PROXY_PLUGIN_NAME = 'orama-secure-proxy';
class AnswerSession {
    db;
    proxy = null;
    config;
    abortController = null;
    lastInteractionParams = null;
    chatModel = null;
    conversationID;
    messages = [];
    events;
    initPromise;
    state = [];
    constructor(db, config) {
        this.db = db;
        this.config = config;
        this.init();
        this.messages = config.initialMessages || [];
        this.events = config.events || {};
        this.conversationID = config.conversationID || this.generateRandomID();
    }
    async ask(query) {
        await this.initPromise;
        let output = '';
        for await (const msg of await this.askStream(query)) {
            output += msg;
        }
        return output;
    }
    async askStream(query) {
        await this.initPromise;
        return this.fetchAnswer(query);
    }
    abortAnswer() {
        this.abortController?.abort();
        this.state[this.state.length - 1].aborted = true;
        this.triggerStateChange();
    }
    getMessages() {
        return this.messages;
    }
    clearSession() {
        this.messages = [];
        this.state = [];
    }
    regenerateLast({ stream = true }) {
        if (this.state.length === 0 || this.messages.length === 0) {
            throw new Error('No messages to regenerate');
        }
        const isLastMessageAssistant = this.messages.at(-1)?.role === 'assistant';
        if (!isLastMessageAssistant) {
            throw createError('ANSWER_SESSION_LAST_MESSAGE_IS_NOT_ASSISTANT');
        }
        this.messages.pop();
        this.state.pop();
        if (stream) {
            return this.askStream(this.lastInteractionParams);
        }
        return this.ask(this.lastInteractionParams);
    }
    async *fetchAnswer(params) {
        if (!this.chatModel) {
            throw createError('PLUGIN_SECURE_PROXY_MISSING_CHAT_MODEL');
        }
        this.abortController = new AbortController();
        this.lastInteractionParams = params;
        const interactionId = this.generateRandomID();
        this.messages.push({ role: 'user', content: params.term ?? '' });
        this.state.push({
            interactionId,
            aborted: false,
            loading: true,
            query: params.term ?? '',
            response: '',
            sources: null,
            translatedQuery: null,
            error: false,
            errorMessage: null
        });
        const stateIdx = this.state.length - 1;
        this.addEmptyAssistantMessage();
        this.triggerStateChange();
        try {
            const sources = await search(this.db, params);
            this.state[stateIdx].sources = sources;
            this.triggerStateChange();
            for await (const msg of this.proxy.chatStream({ model: this.chatModel, messages: this.messages })) {
                yield msg;
                this.state[stateIdx].response += msg;
                this.messages.findLast((msg) => msg.role === 'assistant').content += msg;
                this.triggerStateChange();
            }
        }
        catch (err) {
            if (err.name === 'AbortError') {
                this.state[stateIdx].aborted = true;
            }
            else {
                this.state[stateIdx].error = true;
                this.state[stateIdx].errorMessage = err.toString();
            }
            this.triggerStateChange();
        }
        this.state[stateIdx].loading = false;
        this.triggerStateChange();
        return this.state[stateIdx].response;
    }
    generateRandomID(length = 24) {
        return Array.from({ length }, () => Math.floor(Math.random() * 36).toString(36)).join('');
    }
    triggerStateChange() {
        if (this.events.onStateChange) {
            this.events.onStateChange(this.state);
        }
    }
    async init() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const self = this;
        async function getPlugin() {
            return await self.db.plugins.find((plugin) => plugin.name === ORAMA_SECURE_PROXY_PLUGIN_NAME);
        }
        const plugin = await getPlugin();
        if (!plugin) {
            throw createError('PLUGIN_SECURE_PROXY_NOT_FOUND');
        }
        const pluginExtras = plugin.extra;
        this.proxy = pluginExtras.proxy;
        if (this.config.systemPrompt) {
            this.messages.push({ role: 'system', content: this.config.systemPrompt });
        }
        if (pluginExtras?.pluginParams?.chat?.model) {
            this.chatModel = pluginExtras.pluginParams.chat.model;
        }
        else {
            throw createError('PLUGIN_SECURE_PROXY_MISSING_CHAT_MODEL');
        }
    }
    addEmptyAssistantMessage() {
        this.messages.push({ role: 'assistant', content: '' });
    }
}
//# sourceMappingURL=answer-session.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/types.js

const kInsertions = Symbol('orama.insertions');
const kRemovals = Symbol('orama.removals');
//# sourceMappingURL=types.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/internals.js



//# sourceMappingURL=internals.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/orama/dist/browser/index.js














//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/plugin-analytics/dist/index.js
function dist_l(t,e){if(typeof navigator<"u"&&typeof navigator.sendBeacon=="function"){navigator.sendBeacon(t,e);return}fetch(t,{method:"POST",body:e,headers:{"Content-Type":"application/json"}}).catch(n=>{console.error(n)})}var dist_d="https://telemetry.orama.run/oss_collect",u="-",dist_f="-",dist_p="oss-fe";var dist_r=class t{data;config;constructor(e){this.data=[],this.config=e}static create(e){let n=new t(e);return n.start(),n}add(e){this.data.push({rawSearchString:e.rawSearchString,query:e.query,resultsCount:e.resultsCount,roundTripTime:e.roundTripTime,searchedAt:e.searchedAt,results:e.results,referer:typeof location<"u"?location.toString():void 0}),this.data.length>=this.config.flushSize&&this.flush()}flush(){if(this.data.length===0)return;let e=this.data;this.data=[];let n={source:dist_p,deploymentID:this.config.deploymentId,index:this.config.indexId,oramaId:this.config.oramaId,oramaVersion:this.config.oramaVersion,userAgent:typeof navigator<"u"?navigator.userAgent:void 0,events:e};dist_l(this.config.endpoint+`?api-key=${this.config.apiKey}`,JSON.stringify(n))}start(){let e=setInterval(this.flush.bind(this),this.config.flushInterval);e.unref!=null&&e.unref()}};var dist_h="plugin-analytics";function O(t){if(t.enabled===!1)return{name:dist_h};if(!t.apiKey)throw new Error("Missing apiKey for plugin-analytics");if(!t.indexId)throw new Error("Missing indexId for plugin-analytics");let e=t.flushInterval||5e3,n=t.flushSize||25,g=t.endpoint||dist_d,A=t.deploymentId||u,a;return{name:dist_h,afterSearch:(o,s,T,i)=>{a?.add({query:s,resultsCount:i.count,roundTripTime:Math.round(i.elapsed.raw/1e6),searchedAt:new Date,cached:!1,rawSearchString:s.term,results:i.hits?.map(c=>({id:c.id,score:c.score}))})},afterCreate:o=>{a=dist_r.create({endpoint:g,indexId:t.indexId,deploymentId:A,oramaId:o.id,oramaVersion:o.version||dist_f,apiKey:t.apiKey,flushSize:n,flushInterval:e})}}}
//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/@orama/oramacore-events-parser/esm/main.js
const STATES_STEPS = (/* unused pure expression or super */ null && ([
    // Main answer flow states
    'initializing',
    'handle_gpu_overload',
    'get_llm_config',
    'determine_query_strategy',
    'simple_rag', // When simple RAG is selected
    'advanced_autoquery', // When advanced autoquery is selected
    'handle_system_prompt',
    'optimize_query',
    'execute_search',
    'execute_before_answer_hook',
    'generate_answer',
    'generate_related_queries',
    'completed',
    'error',
    // Advanced autoquery states (forwarded with prefix)
    'advanced_autoquery_initializing',
    'advanced_autoquery_analyzing_input',
    'advanced_autoquery_query_optimized',
    'advanced_autoquery_select_properties',
    'advanced_autoquery_properties_selected',
    'advanced_autoquery_combine_queries',
    'advanced_autoquery_queries_combined',
    'advanced_autoquery_generate_tracked_queries',
    'advanced_autoquery_tracked_queries_generated',
    'advanced_autoquery_execute_before_retrieval_hook',
    'advanced_autoquery_hooks_executed',
    'advanced_autoquery_execute_searches',
    'advanced_autoquery_search_results',
    'advanced_autoquery_completed',
]));
const PROGRESS_STEPS = (/* unused pure expression or super */ null && ([
    // Main answer flow progress steps (enum variant names)
    'Initialize',
    'HandleGPUOverload',
    'GetLLMConfig',
    'DetermineQueryStrategy',
    'HandleSystemPrompt',
    'OptimizeQuery',
    'ExecuteSearch',
    'ExecuteBeforeAnswerHook',
    'GenerateAnswer',
    'GenerateRelatedQueries',
    'Completed',
    'Error',
    // Advanced autoquery progress steps
    'AnalyzeInput',
    'QueryOptimized',
    'SelectProperties',
    'PropertiesSelected',
    'CombineQueriesAndProperties',
    'QueriesCombined',
    'GenerateTrackedQueries',
    'TrackedQueriesGenerated',
    'ExecuteBeforeRetrievalHook',
    'HooksExecuted',
    'ExecuteSearches',
    'SearchResults',
]));
class EventsStreamTransformer extends TransformStream {
    constructor() {
        const decoder = new TextDecoder('utf-8', { ignoreBOM: false });
        let buffer = '';
        super({
            start() {
                buffer = '';
            },
            transform(chunk, controller) {
                const chunkText = decoder.decode(chunk);
                buffer += chunkText;
                // Split on double newlines (end of SSE event)
                let eventEnd = buffer.indexOf('\n\n');
                while (eventEnd === -1 && buffer.indexOf('\r\n\r\n') !== -1) {
                    eventEnd = buffer.indexOf('\r\n\r\n');
                }
                while (eventEnd !== -1) {
                    // Support both \n\n and \r\n\r\n as event delimiters
                    let delimiterLength = 2;
                    if (buffer.slice(eventEnd, eventEnd + 4) === '\r\n\r\n') {
                        delimiterLength = 4;
                    }
                    const eventBlock = buffer.slice(0, eventEnd);
                    buffer = buffer.slice(eventEnd + delimiterLength);
                    // Find the data line(s)
                    const dataLines = eventBlock
                        .split(/\r?\n/)
                        .filter((line) => line.startsWith('data:'));
                    for (const dataLine of dataLines) {
                        const jsonStr = dataLine.replace(/^data:\s*/, '');
                        try {
                            // Handle string events like "acknowledged"
                            if (jsonStr.startsWith('"') && jsonStr.endsWith('"')) {
                                const stringEvent = JSON.parse(jsonStr);
                                controller.enqueue({ type: stringEvent });
                                continue;
                            }
                            let parsed = JSON.parse(jsonStr);
                            // Handle new nested structure
                            if (typeof parsed === 'object' &&
                                parsed !== null &&
                                !('type' in parsed)) {
                                // Convert nested format like {"state_changed": {...}} to {type: "state_changed", ...}
                                const keys = Object.keys(parsed);
                                if (keys.length === 1) {
                                    const [eventType] = keys;
                                    const eventData = parsed[eventType];
                                    if (typeof eventData === 'object' && eventData !== null) {
                                        parsed = { type: eventType, ...eventData };
                                    }
                                    else {
                                        parsed = { type: eventType, data: eventData };
                                    }
                                }
                            }
                            controller.enqueue(parsed);
                        }
                        catch (e) {
                            controller.enqueue({
                                type: 'error',
                                error: 'Invalid JSON in SSE data',
                                state: 'parse_error',
                            });
                        }
                    }
                    // Find the next event
                    eventEnd = buffer.indexOf('\n\n');
                    if (eventEnd === -1 && buffer.indexOf('\r\n\r\n') !== -1) {
                        eventEnd = buffer.indexOf('\r\n\r\n');
                    }
                }
            },
        });
    }
}
class OramaEventEmitter {
    constructor() {
        Object.defineProperty(this, "handlers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "endHandlers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "done", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "resolveDone", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => { }
        });
        this.done = new Promise((resolve) => {
            this.resolveDone = resolve;
        });
    }
    on(event, handler) {
        if (!this.handlers[event]) {
            this.handlers[event] = [];
        }
        this.handlers[event].push(handler);
        return this;
    }
    onStateChange(handler) {
        return this.on('state_changed', handler);
    }
    onProgress(handler) {
        return this.on('progress', handler);
    }
    onEnd(handler) {
        this.endHandlers.push(handler);
        return this;
    }
    emit(event) {
        const hs = this.handlers[event.type];
        if (hs) {
            for (const h of hs)
                h(event);
        }
        // Check for completion - updated for new event format
        const shouldEnd = 
        // Success completion
        (event.type === 'state_changed' &&
            'state' in event &&
            (event.state === 'completed' ||
                event.state === 'advanced_autoquery_completed')) ||
            // Terminal errors only
            (event.type === 'error' &&
                'is_terminal' in event &&
                event.is_terminal === true);
        if (shouldEnd) {
            this._triggerEnd();
        }
    }
    _triggerEnd() {
        for (const handler of this.endHandlers) {
            handler();
        }
    }
    _markDone() {
        this.resolveDone();
    }
}
function isAnswerEvent(event) {
    // First check for Answer-specific event types
    if (event.type === 'acknowledged' ||
        event.type === 'selected_llm' ||
        event.type === 'optimizing_query' ||
        event.type === 'answer_token' ||
        event.type === 'related_queries' ||
        event.type === 'result_action') {
        return true;
    }
    // For overlapping types, include all since AnswerEvent is a superset
    // The distinction is made at the parser level, not the type guard level
    if (event.type === 'state_changed' ||
        event.type === 'error' ||
        event.type === 'progress' ||
        event.type === 'search_results') {
        return true;
    }
    return false;
}
function isAdvancedAutoqueryEvent(event) {
    // Advanced autoquery events can have any state - the prefix logic only applies
    // when they're forwarded through the answer stream
    return (event.type === 'state_changed' ||
        event.type === 'error' ||
        event.type === 'progress' ||
        event.type === 'search_results');
}
function parseAnswerStream(stream) {
    const emitter = new OramaEventEmitter();
    const transformer = new EventsStreamTransformer();
    (async () => {
        const reader = stream.pipeThrough(transformer).getReader();
        while (true) {
            const { value, done } = await reader.read();
            if (done)
                break;
            if (isAnswerEvent(value))
                emitter.emit(value);
        }
        // Give a small delay to ensure all events are emitted
        await new Promise((resolve) => setTimeout(resolve, 0));
        emitter._markDone();
    })();
    return emitter;
}
function parseNLPQueryStream(stream) {
    const emitter = new OramaEventEmitter();
    const transformer = new EventsStreamTransformer();
    (async () => {
        const reader = stream.pipeThrough(transformer).getReader();
        while (true) {
            const { value, done } = await reader.read();
            if (done)
                break;
            if (isAdvancedAutoqueryEvent(value))
                emitter.emit(value);
        }
        // Give a small delay to ensure all events are emitted
        await new Promise((resolve) => setTimeout(resolve, 0));
        emitter._markDone();
    })();
    return emitter;
}
function isAnswerFlowState(state) {
    return !state.startsWith('advanced_autoquery_');
}
function isAdvancedAutoqueryState(state) {
    return state.startsWith('advanced_autoquery_');
}

// EXTERNAL MODULE: ./node_modules/@orama/cuid2/index.js
var cuid2 = __webpack_require__(96389);
;// CONCATENATED MODULE: ./node_modules/@orama/core/esm/_dnt.shims.js
const dntGlobals = {};
const dntGlobalThis = createMergeProxy(globalThis, dntGlobals);
function createMergeProxy(baseObj, extObj) {
    return new Proxy(baseObj, {
        get(_target, prop, _receiver) {
            if (prop in extObj) {
                return extObj[prop];
            }
            else {
                return baseObj[prop];
            }
        },
        set(_target, prop, value) {
            if (prop in extObj) {
                delete extObj[prop];
            }
            baseObj[prop] = value;
            return true;
        },
        deleteProperty(_target, prop) {
            let success = false;
            if (prop in extObj) {
                delete extObj[prop];
                success = true;
            }
            if (prop in baseObj) {
                delete baseObj[prop];
                success = true;
            }
            return success;
        },
        ownKeys(_target) {
            const baseKeys = Reflect.ownKeys(baseObj);
            const extKeys = Reflect.ownKeys(extObj);
            const extKeysSet = new Set(extKeys);
            return [...baseKeys.filter((k) => !extKeysSet.has(k)), ...extKeys];
        },
        defineProperty(_target, prop, desc) {
            if (prop in extObj) {
                delete extObj[prop];
            }
            Reflect.defineProperty(baseObj, prop, desc);
            return true;
        },
        getOwnPropertyDescriptor(_target, prop) {
            if (prop in extObj) {
                return Reflect.getOwnPropertyDescriptor(extObj, prop);
            }
            else {
                return Reflect.getOwnPropertyDescriptor(baseObj, prop);
            }
        },
        has(_target, prop) {
            return prop in extObj || prop in baseObj;
        },
    });
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/Options.js
const ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
const jsonDescription = (jsonSchema, def) => {
    if (def.description) {
        try {
            return {
                ...jsonSchema,
                ...JSON.parse(def.description),
            };
        }
        catch { }
    }
    return jsonSchema;
};
const defaultOptions = {
    name: undefined,
    $refStrategy: "root",
    basePath: ["#"],
    effectStrategy: "input",
    pipeStrategy: "all",
    dateStrategy: "format:date-time",
    mapStrategy: "entries",
    removeAdditionalStrategy: "passthrough",
    allowedAdditionalProperties: true,
    rejectedAdditionalProperties: false,
    definitionPath: "definitions",
    target: "jsonSchema7",
    strictUnions: false,
    definitions: {},
    errorMessages: false,
    markdownDescription: false,
    patternStrategy: "escape",
    applyRegexFlags: false,
    emailStrategy: "format:email",
    base64Strategy: "contentEncoding:base64",
    nameStrategy: "ref",
};
const getDefaultOptions = (options) => (typeof options === "string"
    ? {
        ...defaultOptions,
        name: options,
    }
    : {
        ...defaultOptions,
        ...options,
    });

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/Refs.js

const getRefs = (options) => {
    const _options = getDefaultOptions(options);
    const currentPath = _options.name !== undefined
        ? [..._options.basePath, _options.definitionPath, _options.name]
        : _options.basePath;
    return {
        ..._options,
        currentPath: currentPath,
        propertyPath: undefined,
        seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [
            def._def,
            {
                def: def._def,
                path: [..._options.basePath, _options.definitionPath, name],
                // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
                jsonSchema: undefined,
            },
        ])),
    };
};

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod/lib/index.mjs
var lib_util;
(function (util) {
    util.assertEqual = (val) => val;
    function assertIs(_arg) { }
    util.assertIs = assertIs;
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
            obj[item] = item;
        }
        return obj;
    };
    util.getValidEnumValues = (obj) => {
        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
            filtered[k] = obj[k];
        }
        return util.objectValues(filtered);
    };
    util.objectValues = (obj) => {
        return util.objectKeys(obj).map(function (e) {
            return obj[e];
        });
    };
    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban
        : (object) => {
            const keys = [];
            for (const key in object) {
                if (Object.prototype.hasOwnProperty.call(object, key)) {
                    keys.push(key);
                }
            }
            return keys;
        };
    util.find = (arr, checker) => {
        for (const item of arr) {
            if (checker(item))
                return item;
        }
        return undefined;
    };
    util.isInteger = typeof Number.isInteger === "function"
        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
        : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
        return array
            .map((val) => (typeof val === "string" ? `'${val}'` : val))
            .join(separator);
    }
    util.joinValues = joinValues;
    util.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
            return value.toString();
        }
        return value;
    };
})(lib_util || (lib_util = {}));
var lib_objectUtil;
(function (objectUtil) {
    objectUtil.mergeShapes = (first, second) => {
        return {
            ...first,
            ...second, // second overwrites first
        };
    };
})(lib_objectUtil || (lib_objectUtil = {}));
const ZodParsedType = lib_util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
]);
const getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
        case "undefined":
            return ZodParsedType.undefined;
        case "string":
            return ZodParsedType.string;
        case "number":
            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
            return ZodParsedType.boolean;
        case "function":
            return ZodParsedType.function;
        case "bigint":
            return ZodParsedType.bigint;
        case "symbol":
            return ZodParsedType.symbol;
        case "object":
            if (Array.isArray(data)) {
                return ZodParsedType.array;
            }
            if (data === null) {
                return ZodParsedType.null;
            }
            if (data.then &&
                typeof data.then === "function" &&
                data.catch &&
                typeof data.catch === "function") {
                return ZodParsedType.promise;
            }
            if (typeof Map !== "undefined" && data instanceof Map) {
                return ZodParsedType.map;
            }
            if (typeof Set !== "undefined" && data instanceof Set) {
                return ZodParsedType.set;
            }
            if (typeof Date !== "undefined" && data instanceof Date) {
                return ZodParsedType.date;
            }
            return ZodParsedType.object;
        default:
            return ZodParsedType.unknown;
    }
};

const ZodIssueCode = lib_util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
]);
const quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
    get errors() {
        return this.issues;
    }
    constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            // eslint-disable-next-line ban/ban
            Object.setPrototypeOf(this, actualProto);
        }
        else {
            this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
    }
    format(_mapper) {
        const mapper = _mapper ||
            function (issue) {
                return issue.message;
            };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
            for (const issue of error.issues) {
                if (issue.code === "invalid_union") {
                    issue.unionErrors.map(processError);
                }
                else if (issue.code === "invalid_return_type") {
                    processError(issue.returnTypeError);
                }
                else if (issue.code === "invalid_arguments") {
                    processError(issue.argumentsError);
                }
                else if (issue.path.length === 0) {
                    fieldErrors._errors.push(mapper(issue));
                }
                else {
                    let curr = fieldErrors;
                    let i = 0;
                    while (i < issue.path.length) {
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) {
                            curr[el] = curr[el] || { _errors: [] };
                            // if (typeof el === "string") {
                            //   curr[el] = curr[el] || { _errors: [] };
                            // } else if (typeof el === "number") {
                            //   const errorArray: any = [];
                            //   errorArray._errors = [];
                            //   curr[el] = curr[el] || errorArray;
                            // }
                        }
                        else {
                            curr[el] = curr[el] || { _errors: [] };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    static assert(value) {
        if (!(value instanceof ZodError)) {
            throw new Error(`Not a ZodError: ${value}`);
        }
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, lib_util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
            if (sub.path.length > 0) {
                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
                fieldErrors[sub.path[0]].push(mapper(sub));
            }
            else {
                formErrors.push(mapper(sub));
            }
        }
        return { formErrors, fieldErrors };
    }
    get formErrors() {
        return this.flatten();
    }
}
ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
};

const lib_errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
        case ZodIssueCode.invalid_type:
            if (issue.received === ZodParsedType.undefined) {
                message = "Required";
            }
            else {
                message = `Expected ${issue.expected}, received ${issue.received}`;
            }
            break;
        case ZodIssueCode.invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, lib_util.jsonStringifyReplacer)}`;
            break;
        case ZodIssueCode.unrecognized_keys:
            message = `Unrecognized key(s) in object: ${lib_util.joinValues(issue.keys, ", ")}`;
            break;
        case ZodIssueCode.invalid_union:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${lib_util.joinValues(issue.options)}`;
            break;
        case ZodIssueCode.invalid_enum_value:
            message = `Invalid enum value. Expected ${lib_util.joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case ZodIssueCode.invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case ZodIssueCode.invalid_return_type:
            message = `Invalid function return type`;
            break;
        case ZodIssueCode.invalid_date:
            message = `Invalid date`;
            break;
        case ZodIssueCode.invalid_string:
            if (typeof issue.validation === "object") {
                if ("includes" in issue.validation) {
                    message = `Invalid input: must include "${issue.validation.includes}"`;
                    if (typeof issue.validation.position === "number") {
                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                    }
                }
                else if ("startsWith" in issue.validation) {
                    message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                }
                else if ("endsWith" in issue.validation) {
                    message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                }
                else {
                    lib_util.assertNever(issue.validation);
                }
            }
            else if (issue.validation !== "regex") {
                message = `Invalid ${issue.validation}`;
            }
            else {
                message = "Invalid";
            }
            break;
        case ZodIssueCode.too_small:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${issue.minimum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact
                    ? `exactly equal to `
                    : issue.inclusive
                        ? `greater than or equal to `
                        : `greater than `}${new Date(Number(issue.minimum))}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.too_big:
            if (issue.type === "array")
                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string")
                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number")
                message = `Number must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint")
                message = `BigInt must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `less than or equal to`
                        : `less than`} ${issue.maximum}`;
            else if (issue.type === "date")
                message = `Date must be ${issue.exact
                    ? `exactly`
                    : issue.inclusive
                        ? `smaller than or equal to`
                        : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else
                message = "Invalid input";
            break;
        case ZodIssueCode.custom:
            message = `Invalid input`;
            break;
        case ZodIssueCode.invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case ZodIssueCode.not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        case ZodIssueCode.not_finite:
            message = "Number must be finite";
            break;
        default:
            message = _ctx.defaultError;
            lib_util.assertNever(issue);
    }
    return { message };
};

let overrideErrorMap = lib_errorMap;
function setErrorMap(map) {
    overrideErrorMap = map;
}
function getErrorMap() {
    return overrideErrorMap;
}

const makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...(issueData.path || [])];
    const fullIssue = {
        ...issueData,
        path: fullPath,
    };
    if (issueData.message !== undefined) {
        return {
            ...issueData,
            path: fullPath,
            message: issueData.message,
        };
    }
    let errorMessage = "";
    const maps = errorMaps
        .filter((m) => !!m)
        .slice()
        .reverse();
    for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
        ...issueData,
        path: fullPath,
        message: errorMessage,
    };
};
const EMPTY_PATH = (/* unused pure expression or super */ null && ([]));
function addIssueToContext(ctx, issueData) {
    const overrideMap = getErrorMap();
    const issue = makeIssue({
        issueData: issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
            ctx.common.contextualErrorMap, // contextual error map is first priority
            ctx.schemaErrorMap, // then schema-bound map if available
            overrideMap, // then global override map
            overrideMap === lib_errorMap ? undefined : lib_errorMap, // then global default map
        ].filter((x) => !!x),
    });
    ctx.common.issues.push(issue);
}
class ParseStatus {
    constructor() {
        this.value = "valid";
    }
    dirty() {
        if (this.value === "valid")
            this.value = "dirty";
    }
    abort() {
        if (this.value !== "aborted")
            this.value = "aborted";
    }
    static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
            if (s.status === "aborted")
                return INVALID;
            if (s.status === "dirty")
                status.dirty();
            arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
                key,
                value,
            });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
            const { key, value } = pair;
            if (key.status === "aborted")
                return INVALID;
            if (value.status === "aborted")
                return INVALID;
            if (key.status === "dirty")
                status.dirty();
            if (value.status === "dirty")
                status.dirty();
            if (key.value !== "__proto__" &&
                (typeof value.value !== "undefined" || pair.alwaysSet)) {
                finalObject[key.value] = value.value;
            }
        }
        return { status: status.value, value: finalObject };
    }
}
const INVALID = Object.freeze({
    status: "aborted",
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var lib_errorUtil;
(function (errorUtil) {
    errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(lib_errorUtil || (lib_errorUtil = {}));

var _ZodEnum_cache, _ZodNativeEnum_cache;
class ParseInputLazyPath {
    constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
    }
    get path() {
        if (!this._cachedPath.length) {
            if (this._key instanceof Array) {
                this._cachedPath.push(...this._path, ...this._key);
            }
            else {
                this._cachedPath.push(...this._path, this._key);
            }
        }
        return this._cachedPath;
    }
}
const handleResult = (ctx, result) => {
    if (isValid(result)) {
        return { success: true, data: result.value };
    }
    else {
        if (!ctx.common.issues.length) {
            throw new Error("Validation failed but no issues detected.");
        }
        return {
            success: false,
            get error() {
                if (this._error)
                    return this._error;
                const error = new ZodError(ctx.common.issues);
                this._error = error;
                return this._error;
            },
        };
    }
};
function processCreateParams(params) {
    if (!params)
        return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) {
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap)
        return { errorMap: errorMap, description };
    const customMap = (iss, ctx) => {
        var _a, _b;
        const { message } = params;
        if (iss.code === "invalid_enum_value") {
            return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
        }
        if (typeof ctx.data === "undefined") {
            return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
        }
        if (iss.code !== "invalid_type")
            return { message: ctx.defaultError };
        return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
    };
    return { errorMap: customMap, description };
}
class ZodType {
    get description() {
        return this._def.description;
    }
    _getType(input) {
        return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
        return (ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent,
        });
    }
    _processInputParams(input) {
        return {
            status: new ParseStatus(),
            ctx: {
                common: input.parent.common,
                data: input.data,
                parsedType: getParsedType(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent,
            },
        };
    }
    _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
            throw new Error("Synchronous parse encountered promise.");
        }
        return result;
    }
    _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
    }
    parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    safeParse(data, params) {
        var _a;
        const ctx = {
            common: {
                issues: [],
                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
    }
    "~validate"(data) {
        var _a, _b;
        const ctx = {
            common: {
                issues: [],
                async: !!this["~standard"].async,
            },
            path: [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        if (!this["~standard"].async) {
            try {
                const result = this._parseSync({ data, path: [], parent: ctx });
                return isValid(result)
                    ? {
                        value: result.value,
                    }
                    : {
                        issues: ctx.common.issues,
                    };
            }
            catch (err) {
                if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
                    this["~standard"].async = true;
                }
                ctx.common = {
                    issues: [],
                    async: true,
                };
            }
        }
        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result)
            ? {
                value: result.value,
            }
            : {
                issues: ctx.common.issues,
            });
    }
    async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
            return result.data;
        throw result.error;
    }
    async safeParseAsync(data, params) {
        const ctx = {
            common: {
                issues: [],
                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
                async: true,
            },
            path: (params === null || params === void 0 ? void 0 : params.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: getParsedType(data),
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult)
            ? maybeAsyncResult
            : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
    }
    refine(check, message) {
        const getIssueProperties = (val) => {
            if (typeof message === "string" || typeof message === "undefined") {
                return { message };
            }
            else if (typeof message === "function") {
                return message(val);
            }
            else {
                return message;
            }
        };
        return this._refinement((val, ctx) => {
            const result = check(val);
            const setError = () => ctx.addIssue({
                code: ZodIssueCode.custom,
                ...getIssueProperties(val),
            });
            if (typeof Promise !== "undefined" && result instanceof Promise) {
                return result.then((data) => {
                    if (!data) {
                        setError();
                        return false;
                    }
                    else {
                        return true;
                    }
                });
            }
            if (!result) {
                setError();
                return false;
            }
            else {
                return true;
            }
        });
    }
    refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
            if (!check(val)) {
                ctx.addIssue(typeof refinementData === "function"
                    ? refinementData(val, ctx)
                    : refinementData);
                return false;
            }
            else {
                return true;
            }
        });
    }
    _refinement(refinement) {
        return new ZodEffects({
            schema: this,
            typeName: lib_ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "refinement", refinement },
        });
    }
    superRefine(refinement) {
        return this._refinement(refinement);
    }
    constructor(def) {
        /** Alias of safeParseAsync */
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
            version: 1,
            vendor: "zod",
            validate: (data) => this["~validate"](data),
        };
    }
    optional() {
        return ZodOptional.create(this, this._def);
    }
    nullable() {
        return ZodNullable.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return ZodArray.create(this);
    }
    promise() {
        return ZodPromise.create(this, this._def);
    }
    or(option) {
        return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
        return new ZodEffects({
            ...processCreateParams(this._def),
            schema: this,
            typeName: lib_ZodFirstPartyTypeKind.ZodEffects,
            effect: { type: "transform", transform },
        });
    }
    default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
            ...processCreateParams(this._def),
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: lib_ZodFirstPartyTypeKind.ZodDefault,
        });
    }
    brand() {
        return new ZodBranded({
            typeName: lib_ZodFirstPartyTypeKind.ZodBranded,
            type: this,
            ...processCreateParams(this._def),
        });
    }
    catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
            ...processCreateParams(this._def),
            innerType: this,
            catchValue: catchValueFunc,
            typeName: lib_ZodFirstPartyTypeKind.ZodCatch,
        });
    }
    describe(description) {
        const This = this.constructor;
        return new This({
            ...this._def,
            description,
        });
    }
    pipe(target) {
        return ZodPipeline.create(this, target);
    }
    readonly() {
        return ZodReadonly.create(this);
    }
    isOptional() {
        return this.safeParse(undefined).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
// const uuidRegex =
//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
// from https://stackoverflow.com/a/46181/1550155
// old version: too slow, didn't support unicode
// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
//old email regex
// const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
// eslint-disable-next-line
// const emailRegex =
//   /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
// const emailRegex =
//   /^[a-zA-Z0-9\.\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
// const emailRegex =
//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
// const emailRegex =
//   /^[a-z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9\-]+)*$/i;
// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
// faster, simpler, safer
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
// const ipv6Regex =
// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
// https://base64.guru/standards/base64url
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
// simple
// const dateRegexSource = `\\d{4}-\\d{2}-\\d{2}`;
// no leap year validation
// const dateRegexSource = `\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\d|2\\d))`;
// with leap year validation
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
    // let regex = `\\d{2}:\\d{2}:\\d{2}`;
    let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
    if (args.precision) {
        regex = `${regex}\\.\\d{${args.precision}}`;
    }
    else if (args.precision == null) {
        regex = `${regex}(\\.\\d+)?`;
    }
    return regex;
}
function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
}
// Adapted from https://stackoverflow.com/a/3143231
function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
        opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
        return true;
    }
    return false;
}
function isValidJWT(jwt, alg) {
    if (!jwtRegex.test(jwt))
        return false;
    try {
        const [header] = jwt.split(".");
        // Convert base64url to base64
        const base64 = header
            .replace(/-/g, "+")
            .replace(/_/g, "/")
            .padEnd(header.length + ((4 - (header.length % 4)) % 4), "=");
        const decoded = JSON.parse(atob(base64));
        if (typeof decoded !== "object" || decoded === null)
            return false;
        if (!decoded.typ || !decoded.alg)
            return false;
        if (alg && decoded.alg !== alg)
            return false;
        return true;
    }
    catch (_a) {
        return false;
    }
}
function isValidCidr(ip, version) {
    if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
        return true;
    }
    if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
        return true;
    }
    return false;
}
class ZodString extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.string,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "length") {
                const tooBig = input.data.length > check.value;
                const tooSmall = input.data.length < check.value;
                if (tooBig || tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    if (tooBig) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_big,
                            maximum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    else if (tooSmall) {
                        addIssueToContext(ctx, {
                            code: ZodIssueCode.too_small,
                            minimum: check.value,
                            type: "string",
                            inclusive: true,
                            exact: true,
                            message: check.message,
                        });
                    }
                    status.dirty();
                }
            }
            else if (check.kind === "email") {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "email",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "emoji") {
                if (!emojiRegex) {
                    emojiRegex = new RegExp(_emojiRegex, "u");
                }
                if (!emojiRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "emoji",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "uuid") {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "uuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "nanoid") {
                if (!nanoidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "nanoid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid") {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cuid2") {
                if (!cuid2Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cuid2",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ulid") {
                if (!ulidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ulid",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "url") {
                try {
                    new URL(input.data);
                }
                catch (_a) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "regex") {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "regex",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "trim") {
                input.data = input.data.trim();
            }
            else if (check.kind === "includes") {
                if (!input.data.includes(check.value, check.position)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { includes: check.value, position: check.position },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "toLowerCase") {
                input.data = input.data.toLowerCase();
            }
            else if (check.kind === "toUpperCase") {
                input.data = input.data.toUpperCase();
            }
            else if (check.kind === "startsWith") {
                if (!input.data.startsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { startsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "endsWith") {
                if (!input.data.endsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: { endsWith: check.value },
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "datetime") {
                const regex = datetimeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "datetime",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "date") {
                const regex = dateRegex;
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "date",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "time") {
                const regex = timeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_string,
                        validation: "time",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "duration") {
                if (!durationRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "duration",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "ip") {
                if (!isValidIP(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "ip",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "jwt") {
                if (!isValidJWT(input.data, check.alg)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "jwt",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "cidr") {
                if (!isValidCidr(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "cidr",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "base64") {
                if (!base64Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "base64",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "base64url") {
                if (!base64urlRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        validation: "base64url",
                        code: ZodIssueCode.invalid_string,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                lib_util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
            validation,
            code: ZodIssueCode.invalid_string,
            ...lib_errorUtil.errToObj(message),
        });
    }
    _addCheck(check) {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    email(message) {
        return this._addCheck({ kind: "email", ...lib_errorUtil.errToObj(message) });
    }
    url(message) {
        return this._addCheck({ kind: "url", ...lib_errorUtil.errToObj(message) });
    }
    emoji(message) {
        return this._addCheck({ kind: "emoji", ...lib_errorUtil.errToObj(message) });
    }
    uuid(message) {
        return this._addCheck({ kind: "uuid", ...lib_errorUtil.errToObj(message) });
    }
    nanoid(message) {
        return this._addCheck({ kind: "nanoid", ...lib_errorUtil.errToObj(message) });
    }
    cuid(message) {
        return this._addCheck({ kind: "cuid", ...lib_errorUtil.errToObj(message) });
    }
    cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...lib_errorUtil.errToObj(message) });
    }
    ulid(message) {
        return this._addCheck({ kind: "ulid", ...lib_errorUtil.errToObj(message) });
    }
    base64(message) {
        return this._addCheck({ kind: "base64", ...lib_errorUtil.errToObj(message) });
    }
    base64url(message) {
        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
        return this._addCheck({
            kind: "base64url",
            ...lib_errorUtil.errToObj(message),
        });
    }
    jwt(options) {
        return this._addCheck({ kind: "jwt", ...lib_errorUtil.errToObj(options) });
    }
    ip(options) {
        return this._addCheck({ kind: "ip", ...lib_errorUtil.errToObj(options) });
    }
    cidr(options) {
        return this._addCheck({ kind: "cidr", ...lib_errorUtil.errToObj(options) });
    }
    datetime(options) {
        var _a, _b;
        if (typeof options === "string") {
            return this._addCheck({
                kind: "datetime",
                precision: null,
                offset: false,
                local: false,
                message: options,
            });
        }
        return this._addCheck({
            kind: "datetime",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
            local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
            ...lib_errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    date(message) {
        return this._addCheck({ kind: "date", message });
    }
    time(options) {
        if (typeof options === "string") {
            return this._addCheck({
                kind: "time",
                precision: null,
                message: options,
            });
        }
        return this._addCheck({
            kind: "time",
            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
            ...lib_errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    duration(message) {
        return this._addCheck({ kind: "duration", ...lib_errorUtil.errToObj(message) });
    }
    regex(regex, message) {
        return this._addCheck({
            kind: "regex",
            regex: regex,
            ...lib_errorUtil.errToObj(message),
        });
    }
    includes(value, options) {
        return this._addCheck({
            kind: "includes",
            value: value,
            position: options === null || options === void 0 ? void 0 : options.position,
            ...lib_errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),
        });
    }
    startsWith(value, message) {
        return this._addCheck({
            kind: "startsWith",
            value: value,
            ...lib_errorUtil.errToObj(message),
        });
    }
    endsWith(value, message) {
        return this._addCheck({
            kind: "endsWith",
            value: value,
            ...lib_errorUtil.errToObj(message),
        });
    }
    min(minLength, message) {
        return this._addCheck({
            kind: "min",
            value: minLength,
            ...lib_errorUtil.errToObj(message),
        });
    }
    max(maxLength, message) {
        return this._addCheck({
            kind: "max",
            value: maxLength,
            ...lib_errorUtil.errToObj(message),
        });
    }
    length(len, message) {
        return this._addCheck({
            kind: "length",
            value: len,
            ...lib_errorUtil.errToObj(message),
        });
    }
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(message) {
        return this.min(1, lib_errorUtil.errToObj(message));
    }
    trim() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "trim" }],
        });
    }
    toLowerCase() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toLowerCase" }],
        });
    }
    toUpperCase() {
        return new ZodString({
            ...this._def,
            checks: [...this._def.checks, { kind: "toUpperCase" }],
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
        return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
        return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
ZodString.create = (params) => {
    var _a;
    return new ZodString({
        checks: [],
        typeName: lib_ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params),
    });
};
// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return (valInt % stepInt) / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
    }
    _parse(input) {
        if (this._def.coerce) {
            input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.number,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "int") {
                if (!lib_util.isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (floatSafeRemainder(input.data, check.value) !== 0) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "finite") {
                if (!Number.isFinite(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_finite,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                lib_util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, lib_errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, lib_errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, lib_errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, lib_errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: lib_errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodNumber({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    int(message) {
        return this._addCheck({
            kind: "int",
            message: lib_errorUtil.toString(message),
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: lib_errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: lib_errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: lib_errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: lib_errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value: value,
            message: lib_errorUtil.toString(message),
        });
    }
    finite(message) {
        return this._addCheck({
            kind: "finite",
            message: lib_errorUtil.toString(message),
        });
    }
    safe(message) {
        return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: lib_errorUtil.toString(message),
        })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: lib_errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
    get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" ||
            (ch.kind === "multipleOf" && lib_util.isInteger(ch.value)));
    }
    get isFinite() {
        let max = null, min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "finite" ||
                ch.kind === "int" ||
                ch.kind === "multipleOf") {
                return true;
            }
            else if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
            else if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return Number.isFinite(min) && Number.isFinite(max);
    }
}
ZodNumber.create = (params) => {
    return new ZodNumber({
        checks: [],
        typeName: lib_ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params),
    });
};
class ZodBigInt extends ZodType {
    constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
    }
    _parse(input) {
        if (this._def.coerce) {
            try {
                input.data = BigInt(input.data);
            }
            catch (_a) {
                return this._getInvalidInput(input);
            }
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
            return this._getInvalidInput(input);
        }
        let ctx = undefined;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                const tooSmall = check.inclusive
                    ? input.data < check.value
                    : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        type: "bigint",
                        minimum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                const tooBig = check.inclusive
                    ? input.data > check.value
                    : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        type: "bigint",
                        maximum: check.value,
                        inclusive: check.inclusive,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "multipleOf") {
                if (input.data % check.value !== BigInt(0)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.not_multiple_of,
                        multipleOf: check.value,
                        message: check.message,
                    });
                    status.dirty();
                }
            }
            else {
                lib_util.assertNever(check);
            }
        }
        return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.bigint,
            received: ctx.parsedType,
        });
        return INVALID;
    }
    gte(value, message) {
        return this.setLimit("min", value, true, lib_errorUtil.toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, lib_errorUtil.toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, lib_errorUtil.toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, lib_errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: lib_errorUtil.toString(message),
                },
            ],
        });
    }
    _addCheck(check) {
        return new ZodBigInt({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: lib_errorUtil.toString(message),
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: lib_errorUtil.toString(message),
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: lib_errorUtil.toString(message),
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: lib_errorUtil.toString(message),
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value,
            message: lib_errorUtil.toString(message),
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max;
    }
}
ZodBigInt.create = (params) => {
    var _a;
    return new ZodBigInt({
        checks: [],
        typeName: lib_ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params),
    });
};
class ZodBoolean extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.boolean,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodBoolean.create = (params) => {
    return new ZodBoolean({
        typeName: lib_ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params),
    });
};
class ZodDate extends ZodType {
    _parse(input) {
        if (this._def.coerce) {
            input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.date,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (isNaN(input.data.getTime())) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_date,
            });
            return INVALID;
        }
        const status = new ParseStatus();
        let ctx = undefined;
        for (const check of this._def.checks) {
            if (check.kind === "min") {
                if (input.data.getTime() < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_small,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        minimum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else if (check.kind === "max") {
                if (input.data.getTime() > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.too_big,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        maximum: check.value,
                        type: "date",
                    });
                    status.dirty();
                }
            }
            else {
                lib_util.assertNever(check);
            }
        }
        return {
            status: status.value,
            value: new Date(input.data.getTime()),
        };
    }
    _addCheck(check) {
        return new ZodDate({
            ...this._def,
            checks: [...this._def.checks, check],
        });
    }
    min(minDate, message) {
        return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: lib_errorUtil.toString(message),
        });
    }
    max(maxDate, message) {
        return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: lib_errorUtil.toString(message),
        });
    }
    get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "min") {
                if (min === null || ch.value > min)
                    min = ch.value;
            }
        }
        return min != null ? new Date(min) : null;
    }
    get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
            if (ch.kind === "max") {
                if (max === null || ch.value < max)
                    max = ch.value;
            }
        }
        return max != null ? new Date(max) : null;
    }
}
ZodDate.create = (params) => {
    return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: lib_ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params),
    });
};
class ZodSymbol extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.symbol,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodSymbol.create = (params) => {
    return new ZodSymbol({
        typeName: lib_ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params),
    });
};
class ZodUndefined extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.undefined,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodUndefined.create = (params) => {
    return new ZodUndefined({
        typeName: lib_ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params),
    });
};
class ZodNull extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.null,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodNull.create = (params) => {
    return new ZodNull({
        typeName: lib_ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params),
    });
};
class ZodAny extends ZodType {
    constructor() {
        super(...arguments);
        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
        this._any = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodAny.create = (params) => {
    return new ZodAny({
        typeName: lib_ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params),
    });
};
class ZodUnknown extends ZodType {
    constructor() {
        super(...arguments);
        // required
        this._unknown = true;
    }
    _parse(input) {
        return OK(input.data);
    }
}
ZodUnknown.create = (params) => {
    return new ZodUnknown({
        typeName: lib_ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params),
    });
};
class ZodNever extends ZodType {
    _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.never,
            received: ctx.parsedType,
        });
        return INVALID;
    }
}
ZodNever.create = (params) => {
    return new ZodNever({
        typeName: lib_ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params),
    });
};
class ZodVoid extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.void,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return OK(input.data);
    }
}
ZodVoid.create = (params) => {
    return new ZodVoid({
        typeName: lib_ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params),
    });
};
class ZodArray extends ZodType {
    _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (def.exactLength !== null) {
            const tooBig = ctx.data.length > def.exactLength.value;
            const tooSmall = ctx.data.length < def.exactLength.value;
            if (tooBig || tooSmall) {
                addIssueToContext(ctx, {
                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
                    minimum: (tooSmall ? def.exactLength.value : undefined),
                    maximum: (tooBig ? def.exactLength.value : undefined),
                    type: "array",
                    inclusive: true,
                    exact: true,
                    message: def.exactLength.message,
                });
                status.dirty();
            }
        }
        if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.minLength.message,
                });
                status.dirty();
            }
        }
        if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.maxLength.message,
                });
                status.dirty();
            }
        }
        if (ctx.common.async) {
            return Promise.all([...ctx.data].map((item, i) => {
                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
            })).then((result) => {
                return ParseStatus.mergeArray(status, result);
            });
        }
        const result = [...ctx.data].map((item, i) => {
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
    }
    get element() {
        return this._def.type;
    }
    min(minLength, message) {
        return new ZodArray({
            ...this._def,
            minLength: { value: minLength, message: lib_errorUtil.toString(message) },
        });
    }
    max(maxLength, message) {
        return new ZodArray({
            ...this._def,
            maxLength: { value: maxLength, message: lib_errorUtil.toString(message) },
        });
    }
    length(len, message) {
        return new ZodArray({
            ...this._def,
            exactLength: { value: len, message: lib_errorUtil.toString(message) },
        });
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodArray.create = (schema, params) => {
    return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: lib_ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params),
    });
};
function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
        const newShape = {};
        for (const key in schema.shape) {
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
            ...schema._def,
            shape: () => newShape,
        });
    }
    else if (schema instanceof ZodArray) {
        return new ZodArray({
            ...schema._def,
            type: deepPartialify(schema.element),
        });
    }
    else if (schema instanceof ZodOptional) {
        return ZodOptional.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodNullable) {
        return ZodNullable.create(deepPartialify(schema.unwrap()));
    }
    else if (schema instanceof ZodTuple) {
        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    }
    else {
        return schema;
    }
}
class ZodObject extends ZodType {
    constructor() {
        super(...arguments);
        this._cached = null;
        /**
         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
         * If you want to pass through unknown properties, use `.passthrough()` instead.
         */
        this.nonstrict = this.passthrough;
        // extend<
        //   Augmentation extends ZodRawShape,
        //   NewOutput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
        //       ? Augmentation[k]["_output"]
        //       : k extends keyof Output
        //       ? Output[k]
        //       : never;
        //   }>,
        //   NewInput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
        //       ? Augmentation[k]["_input"]
        //       : k extends keyof Input
        //       ? Input[k]
        //       : never;
        //   }>
        // >(
        //   augmentation: Augmentation
        // ): ZodObject<
        //   extendShape<T, Augmentation>,
        //   UnknownKeys,
        //   Catchall,
        //   NewOutput,
        //   NewInput
        // > {
        //   return new ZodObject({
        //     ...this._def,
        //     shape: () => ({
        //       ...this._def.shape(),
        //       ...augmentation,
        //     }),
        //   }) as any;
        // }
        /**
         * @deprecated Use `.extend` instead
         *  */
        this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const shape = this._def.shape();
        const keys = lib_util.objectKeys(shape);
        return (this._cached = { shape, keys });
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever &&
            this._def.unknownKeys === "strip")) {
            for (const key in ctx.data) {
                if (!shapeKeys.includes(key)) {
                    extraKeys.push(key);
                }
            }
        }
        const pairs = [];
        for (const key of shapeKeys) {
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
                key: { status: "valid", value: key },
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") {
                for (const key of extraKeys) {
                    pairs.push({
                        key: { status: "valid", value: key },
                        value: { status: "valid", value: ctx.data[key] },
                    });
                }
            }
            else if (unknownKeys === "strict") {
                if (extraKeys.length > 0) {
                    addIssueToContext(ctx, {
                        code: ZodIssueCode.unrecognized_keys,
                        keys: extraKeys,
                    });
                    status.dirty();
                }
            }
            else if (unknownKeys === "strip") ;
            else {
                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
            }
        }
        else {
            // run catchall validation
            const catchall = this._def.catchall;
            for (const key of extraKeys) {
                const value = ctx.data[key];
                pairs.push({
                    key: { status: "valid", value: key },
                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
                    ),
                    alwaysSet: key in ctx.data,
                });
            }
        }
        if (ctx.common.async) {
            return Promise.resolve()
                .then(async () => {
                const syncPairs = [];
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    syncPairs.push({
                        key,
                        value,
                        alwaysSet: pair.alwaysSet,
                    });
                }
                return syncPairs;
            })
                .then((syncPairs) => {
                return ParseStatus.mergeObjectSync(status, syncPairs);
            });
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get shape() {
        return this._def.shape();
    }
    strict(message) {
        lib_errorUtil.errToObj;
        return new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...(message !== undefined
                ? {
                    errorMap: (issue, ctx) => {
                        var _a, _b, _c, _d;
                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
                        if (issue.code === "unrecognized_keys")
                            return {
                                message: (_d = lib_errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,
                            };
                        return {
                            message: defaultError,
                        };
                    },
                }
                : {}),
        });
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip",
        });
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough",
        });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
        return new ZodObject({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...augmentation,
            }),
        });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
        const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: () => ({
                ...this._def.shape(),
                ...merging._def.shape(),
            }),
            typeName: lib_ZodFirstPartyTypeKind.ZodObject,
        });
        return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
        return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
        return new ZodObject({
            ...this._def,
            catchall: index,
        });
    }
    pick(mask) {
        const shape = {};
        lib_util.objectKeys(mask).forEach((key) => {
            if (mask[key] && this.shape[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    omit(mask) {
        const shape = {};
        lib_util.objectKeys(this.shape).forEach((key) => {
            if (!mask[key]) {
                shape[key] = this.shape[key];
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => shape,
        });
    }
    /**
     * @deprecated
     */
    deepPartial() {
        return deepPartialify(this);
    }
    partial(mask) {
        const newShape = {};
        lib_util.objectKeys(this.shape).forEach((key) => {
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) {
                newShape[key] = fieldSchema;
            }
            else {
                newShape[key] = fieldSchema.optional();
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    required(mask) {
        const newShape = {};
        lib_util.objectKeys(this.shape).forEach((key) => {
            if (mask && !mask[key]) {
                newShape[key] = this.shape[key];
            }
            else {
                const fieldSchema = this.shape[key];
                let newField = fieldSchema;
                while (newField instanceof ZodOptional) {
                    newField = newField._def.innerType;
                }
                newShape[key] = newField;
            }
        });
        return new ZodObject({
            ...this._def,
            shape: () => newShape,
        });
    }
    keyof() {
        return createZodEnum(lib_util.objectKeys(this.shape));
    }
}
ZodObject.create = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: lib_ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: lib_ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: lib_ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params),
    });
};
class ZodUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
            // return first issue-free validation if it exists
            for (const result of results) {
                if (result.result.status === "valid") {
                    return result.result;
                }
            }
            for (const result of results) {
                if (result.result.status === "dirty") {
                    // add issues from dirty option
                    ctx.common.issues.push(...result.ctx.common.issues);
                    return result.result;
                }
            }
            // return invalid
            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return Promise.all(options.map(async (option) => {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                return {
                    result: await option._parseAsync({
                        data: ctx.data,
                        path: ctx.path,
                        parent: childCtx,
                    }),
                    ctx: childCtx,
                };
            })).then(handleResults);
        }
        else {
            let dirty = undefined;
            const issues = [];
            for (const option of options) {
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: [],
                    },
                    parent: null,
                };
                const result = option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx,
                });
                if (result.status === "valid") {
                    return result;
                }
                else if (result.status === "dirty" && !dirty) {
                    dirty = { result, ctx: childCtx };
                }
                if (childCtx.common.issues.length) {
                    issues.push(childCtx.common.issues);
                }
            }
            if (dirty) {
                ctx.common.issues.push(...dirty.ctx.common.issues);
                return dirty.result;
            }
            const unionErrors = issues.map((issues) => new ZodError(issues));
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union,
                unionErrors,
            });
            return INVALID;
        }
    }
    get options() {
        return this._def.options;
    }
}
ZodUnion.create = (types, params) => {
    return new ZodUnion({
        options: types,
        typeName: lib_ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params),
    });
};
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
//////////                                 //////////
//////////      ZodDiscriminatedUnion      //////////
//////////                                 //////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
const getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
    }
    else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
    }
    else if (type instanceof ZodLiteral) {
        return [type.value];
    }
    else if (type instanceof ZodEnum) {
        return type.options;
    }
    else if (type instanceof ZodNativeEnum) {
        // eslint-disable-next-line ban/ban
        return lib_util.objectValues(type.enum);
    }
    else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
    }
    else if (type instanceof ZodUndefined) {
        return [undefined];
    }
    else if (type instanceof ZodNull) {
        return [null];
    }
    else if (type instanceof ZodOptional) {
        return [undefined, ...getDiscriminator(type.unwrap())];
    }
    else if (type instanceof ZodNullable) {
        return [null, ...getDiscriminator(type.unwrap())];
    }
    else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
    }
    else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
    }
    else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
    }
    else {
        return [];
    }
};
class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [discriminator],
            });
            return INVALID;
        }
        if (ctx.common.async) {
            return option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
        else {
            return option._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
        }
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
        // Get all the valid discriminator values
        const optionsMap = new Map();
        // try {
        for (const type of options) {
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues.length) {
                throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            }
            for (const value of discriminatorValues) {
                if (optionsMap.has(value)) {
                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                }
                optionsMap.set(value, type);
            }
        }
        return new ZodDiscriminatedUnion({
            typeName: lib_ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap,
            ...processCreateParams(params),
        });
    }
}
function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
        return { valid: true, data: a };
    }
    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
        const bKeys = lib_util.objectKeys(b);
        const sharedKeys = lib_util
            .objectKeys(a)
            .filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
    }
    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
        if (a.length !== b.length) {
            return { valid: false };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
                return { valid: false };
            }
            newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
    }
    else if (aType === ZodParsedType.date &&
        bType === ZodParsedType.date &&
        +a === +b) {
        return { valid: true, data: a };
    }
    else {
        return { valid: false };
    }
}
class ZodIntersection extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
            if (isAborted(parsedLeft) || isAborted(parsedRight)) {
                return INVALID;
            }
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.invalid_intersection_types,
                });
                return INVALID;
            }
            if (isDirty(parsedLeft) || isDirty(parsedRight)) {
                status.dirty();
            }
            return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
            return Promise.all([
                this._def.left._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
                this._def.right._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                }),
            ]).then(([left, right]) => handleParsed(left, right));
        }
        else {
            return handleParsed(this._def.left._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }), this._def.right._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            }));
        }
    }
}
ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
        left: left,
        right: right,
        typeName: lib_ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params),
    });
};
class ZodTuple extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.array,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array",
            });
            status.dirty();
        }
        const items = [...ctx.data]
            .map((item, itemIndex) => {
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema)
                return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        })
            .filter((x) => !!x); // filter nulls
        if (ctx.common.async) {
            return Promise.all(items).then((results) => {
                return ParseStatus.mergeArray(status, results);
            });
        }
        else {
            return ParseStatus.mergeArray(status, items);
        }
    }
    get items() {
        return this._def.items;
    }
    rest(rest) {
        return new ZodTuple({
            ...this._def,
            rest,
        });
    }
}
ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
        items: schemas,
        typeName: lib_ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params),
    });
};
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.object,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
            pairs.push({
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
                alwaysSet: key in ctx.data,
            });
        }
        if (ctx.common.async) {
            return ParseStatus.mergeObjectAsync(status, pairs);
        }
        else {
            return ParseStatus.mergeObjectSync(status, pairs);
        }
    }
    get element() {
        return this._def.valueType;
    }
    static create(first, second, third) {
        if (second instanceof ZodType) {
            return new ZodRecord({
                keyType: first,
                valueType: second,
                typeName: lib_ZodFirstPartyTypeKind.ZodRecord,
                ...processCreateParams(third),
            });
        }
        return new ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: lib_ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(second),
        });
    }
}
class ZodMap extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.map,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
            return {
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
            };
        });
        if (ctx.common.async) {
            const finalMap = new Map();
            return Promise.resolve().then(async () => {
                for (const pair of pairs) {
                    const key = await pair.key;
                    const value = await pair.value;
                    if (key.status === "aborted" || value.status === "aborted") {
                        return INVALID;
                    }
                    if (key.status === "dirty" || value.status === "dirty") {
                        status.dirty();
                    }
                    finalMap.set(key.value, value.value);
                }
                return { status: status.value, value: finalMap };
            });
        }
        else {
            const finalMap = new Map();
            for (const pair of pairs) {
                const key = pair.key;
                const value = pair.value;
                if (key.status === "aborted" || value.status === "aborted") {
                    return INVALID;
                }
                if (key.status === "dirty" || value.status === "dirty") {
                    status.dirty();
                }
                finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
        }
    }
}
ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
        valueType,
        keyType,
        typeName: lib_ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params),
    });
};
class ZodSet extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.set,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_small,
                    minimum: def.minSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.minSize.message,
                });
                status.dirty();
            }
        }
        if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
                addIssueToContext(ctx, {
                    code: ZodIssueCode.too_big,
                    maximum: def.maxSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.maxSize.message,
                });
                status.dirty();
            }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements) {
            const parsedSet = new Set();
            for (const element of elements) {
                if (element.status === "aborted")
                    return INVALID;
                if (element.status === "dirty")
                    status.dirty();
                parsedSet.add(element.value);
            }
            return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
            return Promise.all(elements).then((elements) => finalizeSet(elements));
        }
        else {
            return finalizeSet(elements);
        }
    }
    min(minSize, message) {
        return new ZodSet({
            ...this._def,
            minSize: { value: minSize, message: lib_errorUtil.toString(message) },
        });
    }
    max(maxSize, message) {
        return new ZodSet({
            ...this._def,
            maxSize: { value: maxSize, message: lib_errorUtil.toString(message) },
        });
    }
    size(size, message) {
        return this.min(size, message).max(size, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodSet.create = (valueType, params) => {
    return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: lib_ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params),
    });
};
class ZodFunction extends ZodType {
    constructor() {
        super(...arguments);
        this.validate = this.implement;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.function,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        function makeArgsIssue(args, error) {
            return makeIssue({
                data: args,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    getErrorMap(),
                    lib_errorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_arguments,
                    argumentsError: error,
                },
            });
        }
        function makeReturnsIssue(returns, error) {
            return makeIssue({
                data: returns,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    getErrorMap(),
                    lib_errorMap,
                ].filter((x) => !!x),
                issueData: {
                    code: ZodIssueCode.invalid_return_type,
                    returnTypeError: error,
                },
            });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return OK(async function (...args) {
                const error = new ZodError([]);
                const parsedArgs = await me._def.args
                    .parseAsync(args, params)
                    .catch((e) => {
                    error.addIssue(makeArgsIssue(args, e));
                    throw error;
                });
                const result = await Reflect.apply(fn, this, parsedArgs);
                const parsedReturns = await me._def.returns._def.type
                    .parseAsync(result, params)
                    .catch((e) => {
                    error.addIssue(makeReturnsIssue(result, e));
                    throw error;
                });
                return parsedReturns;
            });
        }
        else {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return OK(function (...args) {
                const parsedArgs = me._def.args.safeParse(args, params);
                if (!parsedArgs.success) {
                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
                }
                const result = Reflect.apply(fn, this, parsedArgs.data);
                const parsedReturns = me._def.returns.safeParse(result, params);
                if (!parsedReturns.success) {
                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
                }
                return parsedReturns.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...items) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create()),
        });
    }
    returns(returnType) {
        return new ZodFunction({
            ...this._def,
            returns: returnType,
        });
    }
    implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    static create(args, returns, params) {
        return new ZodFunction({
            args: (args
                ? args
                : ZodTuple.create([]).rest(ZodUnknown.create())),
            returns: returns || ZodUnknown.create(),
            typeName: lib_ZodFirstPartyTypeKind.ZodFunction,
            ...processCreateParams(params),
        });
    }
}
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter();
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
}
ZodLazy.create = (getter, params) => {
    return new ZodLazy({
        getter: getter,
        typeName: lib_ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params),
    });
};
class ZodLiteral extends ZodType {
    _parse(input) {
        if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_literal,
                expected: this._def.value,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
    get value() {
        return this._def.value;
    }
}
ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
        value: value,
        typeName: lib_ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params),
    });
};
function createZodEnum(values, params) {
    return new ZodEnum({
        values,
        typeName: lib_ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params),
    });
}
class ZodEnum extends ZodType {
    constructor() {
        super(...arguments);
        _ZodEnum_cache.set(this, void 0);
    }
    _parse(input) {
        if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                expected: lib_util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
            __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
            enumValues[val] = val;
        }
        return enumValues;
    }
    extract(values, newDef = this._def) {
        return ZodEnum.create(values, {
            ...this._def,
            ...newDef,
        });
    }
    exclude(values, newDef = this._def) {
        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
            ...this._def,
            ...newDef,
        });
    }
}
_ZodEnum_cache = new WeakMap();
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    constructor() {
        super(...arguments);
        _ZodNativeEnum_cache.set(this, void 0);
    }
    _parse(input) {
        const nativeEnumValues = lib_util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string &&
            ctx.parsedType !== ZodParsedType.number) {
            const expectedValues = lib_util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                expected: lib_util.joinValues(expectedValues),
                received: ctx.parsedType,
                code: ZodIssueCode.invalid_type,
            });
            return INVALID;
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
            __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(lib_util.getValidEnumValues(this._def.values)), "f");
        }
        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
            const expectedValues = lib_util.objectValues(nativeEnumValues);
            addIssueToContext(ctx, {
                received: ctx.data,
                code: ZodIssueCode.invalid_enum_value,
                options: expectedValues,
            });
            return INVALID;
        }
        return OK(input.data);
    }
    get enum() {
        return this._def.values;
    }
}
_ZodNativeEnum_cache = new WeakMap();
ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
        values: values,
        typeName: lib_ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params),
    });
};
class ZodPromise extends ZodType {
    unwrap() {
        return this._def.type;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise &&
            ctx.common.async === false) {
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.promise,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise
            ? ctx.data
            : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
            return this._def.type.parseAsync(data, {
                path: ctx.path,
                errorMap: ctx.common.contextualErrorMap,
            });
        }));
    }
}
ZodPromise.create = (schema, params) => {
    return new ZodPromise({
        type: schema,
        typeName: lib_ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params),
    });
};
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === lib_ZodFirstPartyTypeKind.ZodEffects
            ? this._def.schema.sourceType()
            : this._def.schema;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
            addIssue: (arg) => {
                addIssueToContext(ctx, arg);
                if (arg.fatal) {
                    status.abort();
                }
                else {
                    status.dirty();
                }
            },
            get path() {
                return ctx.path;
            },
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data, checkCtx);
            if (ctx.common.async) {
                return Promise.resolve(processed).then(async (processed) => {
                    if (status.value === "aborted")
                        return INVALID;
                    const result = await this._def.schema._parseAsync({
                        data: processed,
                        path: ctx.path,
                        parent: ctx,
                    });
                    if (result.status === "aborted")
                        return INVALID;
                    if (result.status === "dirty")
                        return DIRTY(result.value);
                    if (status.value === "dirty")
                        return DIRTY(result.value);
                    return result;
                });
            }
            else {
                if (status.value === "aborted")
                    return INVALID;
                const result = this._def.schema._parseSync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx,
                });
                if (result.status === "aborted")
                    return INVALID;
                if (result.status === "dirty")
                    return DIRTY(result.value);
                if (status.value === "dirty")
                    return DIRTY(result.value);
                return result;
            }
        }
        if (effect.type === "refinement") {
            const executeRefinement = (acc) => {
                const result = effect.refinement(acc, checkCtx);
                if (ctx.common.async) {
                    return Promise.resolve(result);
                }
                if (result instanceof Promise) {
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                }
                return acc;
            };
            if (ctx.common.async === false) {
                const inner = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inner.status === "aborted")
                    return INVALID;
                if (inner.status === "dirty")
                    status.dirty();
                // return value is ignored
                executeRefinement(inner.value);
                return { status: status.value, value: inner.value };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((inner) => {
                    if (inner.status === "aborted")
                        return INVALID;
                    if (inner.status === "dirty")
                        status.dirty();
                    return executeRefinement(inner.value).then(() => {
                        return { status: status.value, value: inner.value };
                    });
                });
            }
        }
        if (effect.type === "transform") {
            if (ctx.common.async === false) {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (!isValid(base))
                    return base;
                const result = effect.transform(base.value, checkCtx);
                if (result instanceof Promise) {
                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                }
                return { status: status.value, value: result };
            }
            else {
                return this._def.schema
                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
                    .then((base) => {
                    if (!isValid(base))
                        return base;
                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
                });
            }
        }
        lib_util.assertNever(effect);
    }
}
ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
        schema,
        typeName: lib_ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params),
    });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: lib_ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params),
    });
};
class ZodOptional extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
            return OK(undefined);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodOptional.create = (type, params) => {
    return new ZodOptional({
        innerType: type,
        typeName: lib_ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params),
    });
};
class ZodNullable extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
            return OK(null);
        }
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodNullable.create = (type, params) => {
    return new ZodNullable({
        innerType: type,
        typeName: lib_ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params),
    });
};
class ZodDefault extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
            data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
ZodDefault.create = (type, params) => {
    return new ZodDefault({
        innerType: type,
        typeName: lib_ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function"
            ? params.default
            : () => params.default,
        ...processCreateParams(params),
    });
};
class ZodCatch extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        // newCtx is used to not collect issues from inner types in ctx
        const newCtx = {
            ...ctx,
            common: {
                ...ctx.common,
                issues: [],
            },
        };
        const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: {
                ...newCtx,
            },
        });
        if (isAsync(result)) {
            return result.then((result) => {
                return {
                    status: "valid",
                    value: result.status === "valid"
                        ? result.value
                        : this._def.catchValue({
                            get error() {
                                return new ZodError(newCtx.common.issues);
                            },
                            input: newCtx.data,
                        }),
                };
            });
        }
        else {
            return {
                status: "valid",
                value: result.status === "valid"
                    ? result.value
                    : this._def.catchValue({
                        get error() {
                            return new ZodError(newCtx.common.issues);
                        },
                        input: newCtx.data,
                    }),
            };
        }
    }
    removeCatch() {
        return this._def.innerType;
    }
}
ZodCatch.create = (type, params) => {
    return new ZodCatch({
        innerType: type,
        typeName: lib_ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params),
    });
};
class ZodNaN extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
            const ctx = this._getOrReturnCtx(input);
            addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: ZodParsedType.nan,
                received: ctx.parsedType,
            });
            return INVALID;
        }
        return { status: "valid", value: input.data };
    }
}
ZodNaN.create = (params) => {
    return new ZodNaN({
        typeName: lib_ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params),
    });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx,
        });
    }
    unwrap() {
        return this._def.type;
    }
}
class ZodPipeline extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
            const handleAsync = async () => {
                const inResult = await this._def.in._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx,
                });
                if (inResult.status === "aborted")
                    return INVALID;
                if (inResult.status === "dirty") {
                    status.dirty();
                    return DIRTY(inResult.value);
                }
                else {
                    return this._def.out._parseAsync({
                        data: inResult.value,
                        path: ctx.path,
                        parent: ctx,
                    });
                }
            };
            return handleAsync();
        }
        else {
            const inResult = this._def.in._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx,
            });
            if (inResult.status === "aborted")
                return INVALID;
            if (inResult.status === "dirty") {
                status.dirty();
                return {
                    status: "dirty",
                    value: inResult.value,
                };
            }
            else {
                return this._def.out._parseSync({
                    data: inResult.value,
                    path: ctx.path,
                    parent: ctx,
                });
            }
        }
    }
    static create(a, b) {
        return new ZodPipeline({
            in: a,
            out: b,
            typeName: lib_ZodFirstPartyTypeKind.ZodPipeline,
        });
    }
}
class ZodReadonly extends ZodType {
    _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = (data) => {
            if (isValid(data)) {
                data.value = Object.freeze(data.value);
            }
            return data;
        };
        return isAsync(result)
            ? result.then((data) => freeze(data))
            : freeze(result);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
        innerType: type,
        typeName: lib_ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params),
    });
};
////////////////////////////////////////
////////////////////////////////////////
//////////                    //////////
//////////      z.custom      //////////
//////////                    //////////
////////////////////////////////////////
////////////////////////////////////////
function cleanParams(params, data) {
    const p = typeof params === "function"
        ? params(data)
        : typeof params === "string"
            ? { message: params }
            : params;
    const p2 = typeof p === "string" ? { message: p } : p;
    return p2;
}
function custom(check, _params = {}, 
/**
 * @deprecated
 *
 * Pass `fatal` into the params object instead:
 *
 * ```ts
 * z.string().custom((val) => val.length > 5, { fatal: false })
 * ```
 *
 */
fatal) {
    if (check)
        return ZodAny.create().superRefine((data, ctx) => {
            var _a, _b;
            const r = check(data);
            if (r instanceof Promise) {
                return r.then((r) => {
                    var _a, _b;
                    if (!r) {
                        const params = cleanParams(_params, data);
                        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
                        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
                    }
                });
            }
            if (!r) {
                const params = cleanParams(_params, data);
                const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
                ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
            }
            return;
        });
    return ZodAny.create();
}
const late = {
    object: ZodObject.lazycreate,
};
var lib_ZodFirstPartyTypeKind;
(function (ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
})(lib_ZodFirstPartyTypeKind || (lib_ZodFirstPartyTypeKind = {}));
const instanceOfType = (
// const instanceOfType = <T extends new (...args: any[]) => any>(
cls, params = {
    message: `Input not instance of ${cls.name}`,
}) => custom((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = (/* unused pure expression or super */ null && ({
    string: ((arg) => ZodString.create({ ...arg, coerce: true })),
    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
    boolean: ((arg) => ZodBoolean.create({
        ...arg,
        coerce: true,
    })),
    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),
}));
const NEVER = (/* unused pure expression or super */ null && (INVALID));

var z = /*#__PURE__*/(/* unused pure expression or super */ null && (Object.freeze({
    __proto__: null,
    defaultErrorMap: lib_errorMap,
    setErrorMap: setErrorMap,
    getErrorMap: getErrorMap,
    makeIssue: makeIssue,
    EMPTY_PATH: EMPTY_PATH,
    addIssueToContext: addIssueToContext,
    ParseStatus: ParseStatus,
    INVALID: INVALID,
    DIRTY: DIRTY,
    OK: OK,
    isAborted: isAborted,
    isDirty: isDirty,
    isValid: isValid,
    isAsync: isAsync,
    get util () { return lib_util; },
    get objectUtil () { return lib_objectUtil; },
    ZodParsedType: ZodParsedType,
    getParsedType: getParsedType,
    ZodType: ZodType,
    datetimeRegex: datetimeRegex,
    ZodString: ZodString,
    ZodNumber: ZodNumber,
    ZodBigInt: ZodBigInt,
    ZodBoolean: ZodBoolean,
    ZodDate: ZodDate,
    ZodSymbol: ZodSymbol,
    ZodUndefined: ZodUndefined,
    ZodNull: ZodNull,
    ZodAny: ZodAny,
    ZodUnknown: ZodUnknown,
    ZodNever: ZodNever,
    ZodVoid: ZodVoid,
    ZodArray: ZodArray,
    ZodObject: ZodObject,
    ZodUnion: ZodUnion,
    ZodDiscriminatedUnion: ZodDiscriminatedUnion,
    ZodIntersection: ZodIntersection,
    ZodTuple: ZodTuple,
    ZodRecord: ZodRecord,
    ZodMap: ZodMap,
    ZodSet: ZodSet,
    ZodFunction: ZodFunction,
    ZodLazy: ZodLazy,
    ZodLiteral: ZodLiteral,
    ZodEnum: ZodEnum,
    ZodNativeEnum: ZodNativeEnum,
    ZodPromise: ZodPromise,
    ZodEffects: ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional: ZodOptional,
    ZodNullable: ZodNullable,
    ZodDefault: ZodDefault,
    ZodCatch: ZodCatch,
    ZodNaN: ZodNaN,
    BRAND: BRAND,
    ZodBranded: ZodBranded,
    ZodPipeline: ZodPipeline,
    ZodReadonly: ZodReadonly,
    custom: custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late: late,
    get ZodFirstPartyTypeKind () { return lib_ZodFirstPartyTypeKind; },
    coerce: coerce,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    'enum': enumType,
    'function': functionType,
    'instanceof': instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    'null': nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean: oboolean,
    onumber: onumber,
    optional: optionalType,
    ostring: ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    'undefined': undefinedType,
    union: unionType,
    unknown: unknownType,
    'void': voidType,
    NEVER: NEVER,
    ZodIssueCode: ZodIssueCode,
    quotelessJson: quotelessJson,
    ZodError: ZodError
})));



;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/any.js
function parseAnyDef() {
    return {};
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/errorMessages.js
function addErrorMessage(res, key, errorMessage, refs) {
    if (!refs?.errorMessages)
        return;
    if (errorMessage) {
        res.errorMessage = {
            ...res.errorMessage,
            [key]: errorMessage,
        };
    }
}
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
    res[key] = value;
    addErrorMessage(res, key, errorMessage, refs);
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/array.js



function parseArrayDef(def, refs) {
    const res = {
        type: "array",
    };
    if (def.type?._def &&
        def.type?._def?.typeName !== lib_ZodFirstPartyTypeKind.ZodAny) {
        res.items = parseDef(def.type._def, {
            ...refs,
            currentPath: [...refs.currentPath, "items"],
        });
    }
    if (def.minLength) {
        setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
    }
    if (def.maxLength) {
        setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
    }
    if (def.exactLength) {
        setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
        setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
    }
    return res;
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js

function parseBigintDef(def, refs) {
    const res = {
        type: "integer",
        format: "int64",
    };
    if (!def.checks)
        return res;
    for (const check of def.checks) {
        switch (check.kind) {
            case "min":
                if (refs.target === "jsonSchema7") {
                    if (check.inclusive) {
                        setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
                    }
                    else {
                        setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
                    }
                }
                else {
                    if (!check.inclusive) {
                        res.exclusiveMinimum = true;
                    }
                    setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
                }
                break;
            case "max":
                if (refs.target === "jsonSchema7") {
                    if (check.inclusive) {
                        setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
                    }
                    else {
                        setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
                    }
                }
                else {
                    if (!check.inclusive) {
                        res.exclusiveMaximum = true;
                    }
                    setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
                }
                break;
            case "multipleOf":
                setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
                break;
        }
    }
    return res;
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js
function parseBooleanDef() {
    return {
        type: "boolean",
    };
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/branded.js

function parseBrandedDef(_def, refs) {
    return parseDef(_def.type._def, refs);
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/catch.js

const parseCatchDef = (def, refs) => {
    return parseDef(def.innerType._def, refs);
};

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/date.js

function parseDateDef(def, refs, overrideDateStrategy) {
    const strategy = overrideDateStrategy ?? refs.dateStrategy;
    if (Array.isArray(strategy)) {
        return {
            anyOf: strategy.map((item, i) => parseDateDef(def, refs, item)),
        };
    }
    switch (strategy) {
        case "string":
        case "format:date-time":
            return {
                type: "string",
                format: "date-time",
            };
        case "format:date":
            return {
                type: "string",
                format: "date",
            };
        case "integer":
            return integerDateParser(def, refs);
    }
}
const integerDateParser = (def, refs) => {
    const res = {
        type: "integer",
        format: "unix-time",
    };
    if (refs.target === "openApi3") {
        return res;
    }
    for (const check of def.checks) {
        switch (check.kind) {
            case "min":
                setResponseValueAndErrors(res, "minimum", check.value, // This is in milliseconds
                check.message, refs);
                break;
            case "max":
                setResponseValueAndErrors(res, "maximum", check.value, // This is in milliseconds
                check.message, refs);
                break;
        }
    }
    return res;
};

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/default.js

function parseDefaultDef(_def, refs) {
    return {
        ...parseDef(_def.innerType._def, refs),
        default: _def.defaultValue(),
    };
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/effects.js

function parseEffectsDef(_def, refs) {
    return refs.effectStrategy === "input"
        ? parseDef(_def.schema._def, refs)
        : {};
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/enum.js
function parseEnumDef(def) {
    return {
        type: "string",
        enum: Array.from(def.values),
    };
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js

const isJsonSchema7AllOfType = (type) => {
    if ("type" in type && type.type === "string")
        return false;
    return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
    const allOf = [
        parseDef(def.left._def, {
            ...refs,
            currentPath: [...refs.currentPath, "allOf", "0"],
        }),
        parseDef(def.right._def, {
            ...refs,
            currentPath: [...refs.currentPath, "allOf", "1"],
        }),
    ].filter((x) => !!x);
    let unevaluatedProperties = refs.target === "jsonSchema2019-09"
        ? { unevaluatedProperties: false }
        : undefined;
    const mergedAllOf = [];
    // If either of the schemas is an allOf, merge them into a single allOf
    allOf.forEach((schema) => {
        if (isJsonSchema7AllOfType(schema)) {
            mergedAllOf.push(...schema.allOf);
            if (schema.unevaluatedProperties === undefined) {
                // If one of the schemas has no unevaluatedProperties set,
                // the merged schema should also have no unevaluatedProperties set
                unevaluatedProperties = undefined;
            }
        }
        else {
            let nestedSchema = schema;
            if ("additionalProperties" in schema &&
                schema.additionalProperties === false) {
                const { additionalProperties, ...rest } = schema;
                nestedSchema = rest;
            }
            else {
                // As soon as one of the schemas has additionalProperties set not to false, we allow unevaluatedProperties
                unevaluatedProperties = undefined;
            }
            mergedAllOf.push(nestedSchema);
        }
    });
    return mergedAllOf.length
        ? {
            allOf: mergedAllOf,
            ...unevaluatedProperties,
        }
        : undefined;
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/literal.js
function parseLiteralDef(def, refs) {
    const parsedType = typeof def.value;
    if (parsedType !== "bigint" &&
        parsedType !== "number" &&
        parsedType !== "boolean" &&
        parsedType !== "string") {
        return {
            type: Array.isArray(def.value) ? "array" : "object",
        };
    }
    if (refs.target === "openApi3") {
        return {
            type: parsedType === "bigint" ? "integer" : parsedType,
            enum: [def.value],
        };
    }
    return {
        type: parsedType === "bigint" ? "integer" : parsedType,
        const: def.value,
    };
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/string.js

let string_emojiRegex = undefined;
/**
 * Generated from the regular expressions found here as of 2024-05-22:
 * https://github.com/colinhacks/zod/blob/master/src/types.ts.
 *
 * Expressions with /i flag have been changed accordingly.
 */
const zodPatterns = {
    /**
     * `c` was changed to `[cC]` to replicate /i flag
     */
    cuid: /^[cC][^\s-]{8,}$/,
    cuid2: /^[0-9a-z]+$/,
    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
    /**
     * `a-z` was added to replicate /i flag
     */
    email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
    /**
     * Constructed a valid Unicode RegExp
     *
     * Lazily instantiate since this type of regex isn't supported
     * in all envs (e.g. React Native).
     *
     * See:
     * https://github.com/colinhacks/zod/issues/2433
     * Fix in Zod:
     * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
     */
    emoji: () => {
        if (string_emojiRegex === undefined) {
            string_emojiRegex = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
        }
        return string_emojiRegex;
    },
    /**
     * Unused
     */
    uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
    /**
     * Unused
     */
    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
    /**
     * Unused
     */
    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
    nanoid: /^[a-zA-Z0-9_-]{21}$/,
    jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
};
function parseStringDef(def, refs) {
    const res = {
        type: "string",
    };
    if (def.checks) {
        for (const check of def.checks) {
            switch (check.kind) {
                case "min":
                    setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number"
                        ? Math.max(res.minLength, check.value)
                        : check.value, check.message, refs);
                    break;
                case "max":
                    setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number"
                        ? Math.min(res.maxLength, check.value)
                        : check.value, check.message, refs);
                    break;
                case "email":
                    switch (refs.emailStrategy) {
                        case "format:email":
                            addFormat(res, "email", check.message, refs);
                            break;
                        case "format:idn-email":
                            addFormat(res, "idn-email", check.message, refs);
                            break;
                        case "pattern:zod":
                            addPattern(res, zodPatterns.email, check.message, refs);
                            break;
                    }
                    break;
                case "url":
                    addFormat(res, "uri", check.message, refs);
                    break;
                case "uuid":
                    addFormat(res, "uuid", check.message, refs);
                    break;
                case "regex":
                    addPattern(res, check.regex, check.message, refs);
                    break;
                case "cuid":
                    addPattern(res, zodPatterns.cuid, check.message, refs);
                    break;
                case "cuid2":
                    addPattern(res, zodPatterns.cuid2, check.message, refs);
                    break;
                case "startsWith":
                    addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);
                    break;
                case "endsWith":
                    addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);
                    break;
                case "datetime":
                    addFormat(res, "date-time", check.message, refs);
                    break;
                case "date":
                    addFormat(res, "date", check.message, refs);
                    break;
                case "time":
                    addFormat(res, "time", check.message, refs);
                    break;
                case "duration":
                    addFormat(res, "duration", check.message, refs);
                    break;
                case "length":
                    setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number"
                        ? Math.max(res.minLength, check.value)
                        : check.value, check.message, refs);
                    setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number"
                        ? Math.min(res.maxLength, check.value)
                        : check.value, check.message, refs);
                    break;
                case "includes": {
                    addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);
                    break;
                }
                case "ip": {
                    if (check.version !== "v6") {
                        addFormat(res, "ipv4", check.message, refs);
                    }
                    if (check.version !== "v4") {
                        addFormat(res, "ipv6", check.message, refs);
                    }
                    break;
                }
                case "base64url":
                    addPattern(res, zodPatterns.base64url, check.message, refs);
                    break;
                case "jwt":
                    addPattern(res, zodPatterns.jwt, check.message, refs);
                    break;
                case "cidr": {
                    if (check.version !== "v6") {
                        addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
                    }
                    if (check.version !== "v4") {
                        addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
                    }
                    break;
                }
                case "emoji":
                    addPattern(res, zodPatterns.emoji(), check.message, refs);
                    break;
                case "ulid": {
                    addPattern(res, zodPatterns.ulid, check.message, refs);
                    break;
                }
                case "base64": {
                    switch (refs.base64Strategy) {
                        case "format:binary": {
                            addFormat(res, "binary", check.message, refs);
                            break;
                        }
                        case "contentEncoding:base64": {
                            setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
                            break;
                        }
                        case "pattern:zod": {
                            addPattern(res, zodPatterns.base64, check.message, refs);
                            break;
                        }
                    }
                    break;
                }
                case "nanoid": {
                    addPattern(res, zodPatterns.nanoid, check.message, refs);
                }
                case "toLowerCase":
                case "toUpperCase":
                case "trim":
                    break;
                default:
                    /* c8 ignore next */
                    ((_) => { })(check);
            }
        }
    }
    return res;
}
function escapeLiteralCheckValue(literal, refs) {
    return refs.patternStrategy === "escape"
        ? escapeNonAlphaNumeric(literal)
        : literal;
}
const ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric(source) {
    let result = "";
    for (let i = 0; i < source.length; i++) {
        if (!ALPHA_NUMERIC.has(source[i])) {
            result += "\\";
        }
        result += source[i];
    }
    return result;
}
// Adds a "format" keyword to the schema. If a format exists, both formats will be joined in an allOf-node, along with subsequent ones.
function addFormat(schema, value, message, refs) {
    if (schema.format || schema.anyOf?.some((x) => x.format)) {
        if (!schema.anyOf) {
            schema.anyOf = [];
        }
        if (schema.format) {
            schema.anyOf.push({
                format: schema.format,
                ...(schema.errorMessage &&
                    refs.errorMessages && {
                    errorMessage: { format: schema.errorMessage.format },
                }),
            });
            delete schema.format;
            if (schema.errorMessage) {
                delete schema.errorMessage.format;
                if (Object.keys(schema.errorMessage).length === 0) {
                    delete schema.errorMessage;
                }
            }
        }
        schema.anyOf.push({
            format: value,
            ...(message &&
                refs.errorMessages && { errorMessage: { format: message } }),
        });
    }
    else {
        setResponseValueAndErrors(schema, "format", value, message, refs);
    }
}
// Adds a "pattern" keyword to the schema. If a pattern exists, both patterns will be joined in an allOf-node, along with subsequent ones.
function addPattern(schema, regex, message, refs) {
    if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {
        if (!schema.allOf) {
            schema.allOf = [];
        }
        if (schema.pattern) {
            schema.allOf.push({
                pattern: schema.pattern,
                ...(schema.errorMessage &&
                    refs.errorMessages && {
                    errorMessage: { pattern: schema.errorMessage.pattern },
                }),
            });
            delete schema.pattern;
            if (schema.errorMessage) {
                delete schema.errorMessage.pattern;
                if (Object.keys(schema.errorMessage).length === 0) {
                    delete schema.errorMessage;
                }
            }
        }
        schema.allOf.push({
            pattern: stringifyRegExpWithFlags(regex, refs),
            ...(message &&
                refs.errorMessages && { errorMessage: { pattern: message } }),
        });
    }
    else {
        setResponseValueAndErrors(schema, "pattern", stringifyRegExpWithFlags(regex, refs), message, refs);
    }
}
// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true
function stringifyRegExpWithFlags(regex, refs) {
    if (!refs.applyRegexFlags || !regex.flags) {
        return regex.source;
    }
    // Currently handled flags
    const flags = {
        i: regex.flags.includes("i"),
        m: regex.flags.includes("m"),
        s: regex.flags.includes("s"), // `.` matches newlines
    };
    // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!
    const source = flags.i ? regex.source.toLowerCase() : regex.source;
    let pattern = "";
    let isEscaped = false;
    let inCharGroup = false;
    let inCharRange = false;
    for (let i = 0; i < source.length; i++) {
        if (isEscaped) {
            pattern += source[i];
            isEscaped = false;
            continue;
        }
        if (flags.i) {
            if (inCharGroup) {
                if (source[i].match(/[a-z]/)) {
                    if (inCharRange) {
                        pattern += source[i];
                        pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
                        inCharRange = false;
                    }
                    else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/)) {
                        pattern += source[i];
                        inCharRange = true;
                    }
                    else {
                        pattern += `${source[i]}${source[i].toUpperCase()}`;
                    }
                    continue;
                }
            }
            else if (source[i].match(/[a-z]/)) {
                pattern += `[${source[i]}${source[i].toUpperCase()}]`;
                continue;
            }
        }
        if (flags.m) {
            if (source[i] === "^") {
                pattern += `(^|(?<=[\r\n]))`;
                continue;
            }
            else if (source[i] === "$") {
                pattern += `($|(?=[\r\n]))`;
                continue;
            }
        }
        if (flags.s && source[i] === ".") {
            pattern += inCharGroup ? `${source[i]}\r\n` : `[${source[i]}\r\n]`;
            continue;
        }
        pattern += source[i];
        if (source[i] === "\\") {
            isEscaped = true;
        }
        else if (inCharGroup && source[i] === "]") {
            inCharGroup = false;
        }
        else if (!inCharGroup && source[i] === "[") {
            inCharGroup = true;
        }
    }
    try {
        new RegExp(pattern);
    }
    catch {
        console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
        return regex.source;
    }
    return pattern;
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/record.js




function parseRecordDef(def, refs) {
    if (refs.target === "openAi") {
        console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
    }
    if (refs.target === "openApi3" &&
        def.keyType?._def.typeName === lib_ZodFirstPartyTypeKind.ZodEnum) {
        return {
            type: "object",
            required: def.keyType._def.values,
            properties: def.keyType._def.values.reduce((acc, key) => ({
                ...acc,
                [key]: parseDef(def.valueType._def, {
                    ...refs,
                    currentPath: [...refs.currentPath, "properties", key],
                }) ?? {},
            }), {}),
            additionalProperties: refs.rejectedAdditionalProperties,
        };
    }
    const schema = {
        type: "object",
        additionalProperties: parseDef(def.valueType._def, {
            ...refs,
            currentPath: [...refs.currentPath, "additionalProperties"],
        }) ?? refs.allowedAdditionalProperties,
    };
    if (refs.target === "openApi3") {
        return schema;
    }
    if (def.keyType?._def.typeName === lib_ZodFirstPartyTypeKind.ZodString &&
        def.keyType._def.checks?.length) {
        const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
        return {
            ...schema,
            propertyNames: keyType,
        };
    }
    else if (def.keyType?._def.typeName === lib_ZodFirstPartyTypeKind.ZodEnum) {
        return {
            ...schema,
            propertyNames: {
                enum: def.keyType._def.values,
            },
        };
    }
    else if (def.keyType?._def.typeName === lib_ZodFirstPartyTypeKind.ZodBranded &&
        def.keyType._def.type._def.typeName === lib_ZodFirstPartyTypeKind.ZodString &&
        def.keyType._def.type._def.checks?.length) {
        const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
        return {
            ...schema,
            propertyNames: keyType,
        };
    }
    return schema;
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/map.js


function parseMapDef(def, refs) {
    if (refs.mapStrategy === "record") {
        return parseRecordDef(def, refs);
    }
    const keys = parseDef(def.keyType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", "items", "0"],
    }) || {};
    const values = parseDef(def.valueType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", "items", "1"],
    }) || {};
    return {
        type: "array",
        maxItems: 125,
        items: {
            type: "array",
            items: [keys, values],
            minItems: 2,
            maxItems: 2,
        },
    };
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js
function parseNativeEnumDef(def) {
    const object = def.values;
    const actualKeys = Object.keys(def.values).filter((key) => {
        return typeof object[object[key]] !== "number";
    });
    const actualValues = actualKeys.map((key) => object[key]);
    const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
    return {
        type: parsedTypes.length === 1
            ? parsedTypes[0] === "string"
                ? "string"
                : "number"
            : ["string", "number"],
        enum: actualValues,
    };
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/never.js
function parseNeverDef() {
    return {
        not: {},
    };
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/null.js
function parseNullDef(refs) {
    return refs.target === "openApi3"
        ? {
            enum: ["null"],
            nullable: true,
        }
        : {
            type: "null",
        };
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/union.js

const primitiveMappings = {
    ZodString: "string",
    ZodNumber: "number",
    ZodBigInt: "integer",
    ZodBoolean: "boolean",
    ZodNull: "null",
};
function parseUnionDef(def, refs) {
    if (refs.target === "openApi3")
        return asAnyOf(def, refs);
    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
    // This blocks tries to look ahead a bit to produce nicer looking schemas with type array instead of anyOf.
    if (options.every((x) => x._def.typeName in primitiveMappings &&
        (!x._def.checks || !x._def.checks.length))) {
        // all types in union are primitive and lack checks, so might as well squash into {type: [...]}
        const types = options.reduce((types, x) => {
            const type = primitiveMappings[x._def.typeName]; //Can be safely casted due to row 43
            return type && !types.includes(type) ? [...types, type] : types;
        }, []);
        return {
            type: types.length > 1 ? types : types[0],
        };
    }
    else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
        // all options literals
        const types = options.reduce((acc, x) => {
            const type = typeof x._def.value;
            switch (type) {
                case "string":
                case "number":
                case "boolean":
                    return [...acc, type];
                case "bigint":
                    return [...acc, "integer"];
                case "object":
                    if (x._def.value === null)
                        return [...acc, "null"];
                case "symbol":
                case "undefined":
                case "function":
                default:
                    return acc;
            }
        }, []);
        if (types.length === options.length) {
            // all the literals are primitive, as far as null can be considered primitive
            const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
            return {
                type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
                enum: options.reduce((acc, x) => {
                    return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
                }, []),
            };
        }
    }
    else if (options.every((x) => x._def.typeName === "ZodEnum")) {
        return {
            type: "string",
            enum: options.reduce((acc, x) => [
                ...acc,
                ...x._def.values.filter((x) => !acc.includes(x)),
            ], []),
        };
    }
    return asAnyOf(def, refs);
}
const asAnyOf = (def, refs) => {
    const anyOf = (def.options instanceof Map
        ? Array.from(def.options.values())
        : def.options)
        .map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", `${i}`],
    }))
        .filter((x) => !!x &&
        (!refs.strictUnions ||
            (typeof x === "object" && Object.keys(x).length > 0)));
    return anyOf.length ? { anyOf } : undefined;
};

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js


function parseNullableDef(def, refs) {
    if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) &&
        (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
        if (refs.target === "openApi3") {
            return {
                type: primitiveMappings[def.innerType._def.typeName],
                nullable: true,
            };
        }
        return {
            type: [
                primitiveMappings[def.innerType._def.typeName],
                "null",
            ],
        };
    }
    if (refs.target === "openApi3") {
        const base = parseDef(def.innerType._def, {
            ...refs,
            currentPath: [...refs.currentPath],
        });
        if (base && "$ref" in base)
            return { allOf: [base], nullable: true };
        return base && { ...base, nullable: true };
    }
    const base = parseDef(def.innerType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", "0"],
    });
    return base && { anyOf: [base, { type: "null" }] };
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/number.js

function parseNumberDef(def, refs) {
    const res = {
        type: "number",
    };
    if (!def.checks)
        return res;
    for (const check of def.checks) {
        switch (check.kind) {
            case "int":
                res.type = "integer";
                addErrorMessage(res, "type", check.message, refs);
                break;
            case "min":
                if (refs.target === "jsonSchema7") {
                    if (check.inclusive) {
                        setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
                    }
                    else {
                        setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
                    }
                }
                else {
                    if (!check.inclusive) {
                        res.exclusiveMinimum = true;
                    }
                    setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
                }
                break;
            case "max":
                if (refs.target === "jsonSchema7") {
                    if (check.inclusive) {
                        setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
                    }
                    else {
                        setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
                    }
                }
                else {
                    if (!check.inclusive) {
                        res.exclusiveMaximum = true;
                    }
                    setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
                }
                break;
            case "multipleOf":
                setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
                break;
        }
    }
    return res;
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/object.js


function parseObjectDef(def, refs) {
    const forceOptionalIntoNullable = refs.target === "openAi";
    const result = {
        type: "object",
        properties: {},
    };
    const required = [];
    const shape = def.shape();
    for (const propName in shape) {
        let propDef = shape[propName];
        if (propDef === undefined || propDef._def === undefined) {
            continue;
        }
        let propOptional = safeIsOptional(propDef);
        if (propOptional && forceOptionalIntoNullable) {
            if (propDef instanceof ZodOptional) {
                propDef = propDef._def.innerType;
            }
            if (!propDef.isNullable()) {
                propDef = propDef.nullable();
            }
            propOptional = false;
        }
        const parsedDef = parseDef(propDef._def, {
            ...refs,
            currentPath: [...refs.currentPath, "properties", propName],
            propertyPath: [...refs.currentPath, "properties", propName],
        });
        if (parsedDef === undefined) {
            continue;
        }
        result.properties[propName] = parsedDef;
        if (!propOptional) {
            required.push(propName);
        }
    }
    if (required.length) {
        result.required = required;
    }
    const additionalProperties = decideAdditionalProperties(def, refs);
    if (additionalProperties !== undefined) {
        result.additionalProperties = additionalProperties;
    }
    return result;
}
function decideAdditionalProperties(def, refs) {
    if (def.catchall._def.typeName !== "ZodNever") {
        return parseDef(def.catchall._def, {
            ...refs,
            currentPath: [...refs.currentPath, "additionalProperties"],
        });
    }
    switch (def.unknownKeys) {
        case "passthrough":
            return refs.allowedAdditionalProperties;
        case "strict":
            return refs.rejectedAdditionalProperties;
        case "strip":
            return refs.removeAdditionalStrategy === "strict"
                ? refs.allowedAdditionalProperties
                : refs.rejectedAdditionalProperties;
    }
}
function safeIsOptional(schema) {
    try {
        return schema.isOptional();
    }
    catch {
        return true;
    }
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/optional.js

const parseOptionalDef = (def, refs) => {
    if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
        return parseDef(def.innerType._def, refs);
    }
    const innerSchema = parseDef(def.innerType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "anyOf", "1"],
    });
    return innerSchema
        ? {
            anyOf: [
                {
                    not: {},
                },
                innerSchema,
            ],
        }
        : {};
};

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js

const parsePipelineDef = (def, refs) => {
    if (refs.pipeStrategy === "input") {
        return parseDef(def.in._def, refs);
    }
    else if (refs.pipeStrategy === "output") {
        return parseDef(def.out._def, refs);
    }
    const a = parseDef(def.in._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", "0"],
    });
    const b = parseDef(def.out._def, {
        ...refs,
        currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"],
    });
    return {
        allOf: [a, b].filter((x) => x !== undefined),
    };
};

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/promise.js

function parsePromiseDef(def, refs) {
    return parseDef(def.type._def, refs);
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/set.js


function parseSetDef(def, refs) {
    const items = parseDef(def.valueType._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items"],
    });
    const schema = {
        type: "array",
        uniqueItems: true,
        items,
    };
    if (def.minSize) {
        setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
    }
    if (def.maxSize) {
        setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
    }
    return schema;
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js

function parseTupleDef(def, refs) {
    if (def.rest) {
        return {
            type: "array",
            minItems: def.items.length,
            items: def.items
                .map((x, i) => parseDef(x._def, {
                ...refs,
                currentPath: [...refs.currentPath, "items", `${i}`],
            }))
                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),
            additionalItems: parseDef(def.rest._def, {
                ...refs,
                currentPath: [...refs.currentPath, "additionalItems"],
            }),
        };
    }
    else {
        return {
            type: "array",
            minItems: def.items.length,
            maxItems: def.items.length,
            items: def.items
                .map((x, i) => parseDef(x._def, {
                ...refs,
                currentPath: [...refs.currentPath, "items", `${i}`],
            }))
                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),
        };
    }
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js
function parseUndefinedDef() {
    return {
        not: {},
    };
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js
function parseUnknownDef() {
    return {};
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js

const parseReadonlyDef = (def, refs) => {
    return parseDef(def.innerType._def, refs);
};

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/selectParser.js































const selectParser = (def, typeName, refs) => {
    switch (typeName) {
        case lib_ZodFirstPartyTypeKind.ZodString:
            return parseStringDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodNumber:
            return parseNumberDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodObject:
            return parseObjectDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodBigInt:
            return parseBigintDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodBoolean:
            return parseBooleanDef();
        case lib_ZodFirstPartyTypeKind.ZodDate:
            return parseDateDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodUndefined:
            return parseUndefinedDef();
        case lib_ZodFirstPartyTypeKind.ZodNull:
            return parseNullDef(refs);
        case lib_ZodFirstPartyTypeKind.ZodArray:
            return parseArrayDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodUnion:
        case lib_ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
            return parseUnionDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodIntersection:
            return parseIntersectionDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodTuple:
            return parseTupleDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodRecord:
            return parseRecordDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodLiteral:
            return parseLiteralDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodEnum:
            return parseEnumDef(def);
        case lib_ZodFirstPartyTypeKind.ZodNativeEnum:
            return parseNativeEnumDef(def);
        case lib_ZodFirstPartyTypeKind.ZodNullable:
            return parseNullableDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodOptional:
            return parseOptionalDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodMap:
            return parseMapDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodSet:
            return parseSetDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodLazy:
            return () => def.getter()._def;
        case lib_ZodFirstPartyTypeKind.ZodPromise:
            return parsePromiseDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodNaN:
        case lib_ZodFirstPartyTypeKind.ZodNever:
            return parseNeverDef();
        case lib_ZodFirstPartyTypeKind.ZodEffects:
            return parseEffectsDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodAny:
            return parseAnyDef();
        case lib_ZodFirstPartyTypeKind.ZodUnknown:
            return parseUnknownDef();
        case lib_ZodFirstPartyTypeKind.ZodDefault:
            return parseDefaultDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodBranded:
            return parseBrandedDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodReadonly:
            return parseReadonlyDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodCatch:
            return parseCatchDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodPipeline:
            return parsePipelineDef(def, refs);
        case lib_ZodFirstPartyTypeKind.ZodFunction:
        case lib_ZodFirstPartyTypeKind.ZodVoid:
        case lib_ZodFirstPartyTypeKind.ZodSymbol:
            return undefined;
        default:
            /* c8 ignore next */
            return ((_) => undefined)(typeName);
    }
};

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/parseDef.js


function parseDef(def, refs, forceResolution = false) {
    const seenItem = refs.seen.get(def);
    if (refs.override) {
        const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
        if (overrideResult !== ignoreOverride) {
            return overrideResult;
        }
    }
    if (seenItem && !forceResolution) {
        const seenSchema = get$ref(seenItem, refs);
        if (seenSchema !== undefined) {
            return seenSchema;
        }
    }
    const newItem = { def, path: refs.currentPath, jsonSchema: undefined };
    refs.seen.set(def, newItem);
    const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
    // If the return was a function, then the inner definition needs to be extracted before a call to parseDef (recursive)
    const jsonSchema = typeof jsonSchemaOrGetter === "function"
        ? parseDef(jsonSchemaOrGetter(), refs)
        : jsonSchemaOrGetter;
    if (jsonSchema) {
        addMeta(def, refs, jsonSchema);
    }
    if (refs.postProcess) {
        const postProcessResult = refs.postProcess(jsonSchema, def, refs);
        newItem.jsonSchema = jsonSchema;
        return postProcessResult;
    }
    newItem.jsonSchema = jsonSchema;
    return jsonSchema;
}
const get$ref = (item, refs) => {
    switch (refs.$refStrategy) {
        case "root":
            return { $ref: item.path.join("/") };
        case "relative":
            return { $ref: getRelativePath(refs.currentPath, item.path) };
        case "none":
        case "seen": {
            if (item.path.length < refs.currentPath.length &&
                item.path.every((value, index) => refs.currentPath[index] === value)) {
                console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
                return {};
            }
            return refs.$refStrategy === "seen" ? {} : undefined;
        }
    }
};
const getRelativePath = (pathA, pathB) => {
    let i = 0;
    for (; i < pathA.length && i < pathB.length; i++) {
        if (pathA[i] !== pathB[i])
            break;
    }
    return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};
const addMeta = (def, refs, jsonSchema) => {
    if (def.description) {
        jsonSchema.description = def.description;
        if (refs.markdownDescription) {
            jsonSchema.markdownDescription = def.description;
        }
    }
    return jsonSchema;
};

;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js


const zodToJsonSchema_zodToJsonSchema = (schema, options) => {
    const refs = getRefs(options);
    const definitions = typeof options === "object" && options.definitions
        ? Object.entries(options.definitions).reduce((acc, [name, schema]) => ({
            ...acc,
            [name]: parseDef(schema._def, {
                ...refs,
                currentPath: [...refs.basePath, refs.definitionPath, name],
            }, true) ?? {},
        }), {})
        : undefined;
    const name = typeof options === "string"
        ? options
        : options?.nameStrategy === "title"
            ? undefined
            : options?.name;
    const main = parseDef(schema._def, name === undefined
        ? refs
        : {
            ...refs,
            currentPath: [...refs.basePath, refs.definitionPath, name],
        }, false) ?? {};
    const title = typeof options === "object" &&
        options.name !== undefined &&
        options.nameStrategy === "title"
        ? options.name
        : undefined;
    if (title !== undefined) {
        main.title = title;
    }
    const combined = name === undefined
        ? definitions
            ? {
                ...main,
                [refs.definitionPath]: definitions,
            }
            : main
        : {
            $ref: [
                ...(refs.$refStrategy === "relative" ? [] : refs.basePath),
                refs.definitionPath,
                name,
            ].join("/"),
            [refs.definitionPath]: {
                ...definitions,
                [name]: main,
            },
        };
    if (refs.target === "jsonSchema7") {
        combined.$schema = "http://json-schema.org/draft-07/schema#";
    }
    else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
        combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
    }
    if (refs.target === "openAi" &&
        ("anyOf" in combined ||
            "oneOf" in combined ||
            "allOf" in combined ||
            ("type" in combined && Array.isArray(combined.type)))) {
        console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
    }
    return combined;
};


;// CONCATENATED MODULE: ./node_modules/@orama/core/node_modules/zod-to-json-schema/dist/esm/index.js






































/* export default */ const esm = ((/* unused pure expression or super */ null && (zodToJsonSchema)));

;// CONCATENATED MODULE: ./node_modules/@orama/core/esm/lib/utils.js


const LOCAL_STORAGE_USER_ID_KEY = '___orama_anonymous_user_id';
const LOCAL_STORAGE_SERVER_SIDE_SESSION_KEY = '___orama_server_side_session';
function utils_createRandomString(length) {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-$';
    let result = '';
    for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * characters.length));
    }
    return result;
}
function formatDuration(duration) {
    if (duration < 1000) {
        return `${duration}ms`;
    }
    else {
        const seconds = duration / 1000;
        if (Number.isInteger(seconds)) {
            return `${seconds}s`;
        }
        return `${seconds.toFixed(1)}s`;
    }
}
function sendBeacon(endpoint, body) {
    if (typeof navigator !== 'undefined') {
        if (typeof navigator.sendBeacon !== 'undefined') {
            navigator.sendBeacon(endpoint, body);
        }
        return;
    }
    fetch(endpoint, {
        method: 'POST',
        body,
        headers: {
            'Content-Type': 'application/json',
        },
    }).then(() => { }, (e) => console.log(e));
}
const hasLocalStorage = typeof localStorage !== 'undefined';
function throttle(func, limit) {
    let inThrottle;
    return function (...args) {
        if (!inThrottle) {
            // @ts-ignore - 'this' has implicitly any, yes
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => (inThrottle = false), limit);
        }
    };
}
function debounce(func, delay) {
    let debounceTimer;
    return function (...args) {
        clearTimeout(debounceTimer);
        // @ts-ignore - 'this' has implicitly any, yes
        debounceTimer = setTimeout(() => func.apply(this, args), delay);
    };
}
function isServerRuntime() {
    // Browser detection: if window or document exists, you're definitely in a browser
    if (typeof dntGlobalThis !== 'undefined' || typeof document !== 'undefined') {
        return false;
    }
    // Node.js
    // @ts-ignore - process is not defined
    if (typeof process !== 'undefined' && "24.10.0") {
        return true;
    }
    // Deno
    // @ts-ignore - Deno is not defined
    if (typeof Deno !== 'undefined' && typeof Deno.version !== 'undefined') {
        return true;
    }
    // Bun
    // @ts-ignore - Bun is not defined
    if (typeof Bun !== 'undefined' && typeof Bun.version !== 'undefined') {
        return true;
    }
    // Cloudflare Workers, Vercel Edge, and other serverless environments often run in a V8 isolate
    if (typeof dntGlobalThis !== 'undefined' &&
        typeof globalThis.Response === 'function' &&
        typeof globalThis.fetch === 'function' &&
        typeof globalThis.navigator === 'undefined' // real browser usually has navigator
    ) {
        return true;
    }
    // AWS Lambda or generic serverless
    // @ts-ignore - process is not defined
    if (typeof process !== 'undefined' && {}.AWS_LAMBDA_FUNCTION_NAME) {
        return true;
    }
    // Default to false if it looks like a browser
    return false;
}
function flattenZodSchema(schema) {
    const raw = zodToJsonSchema_zodToJsonSchema(schema, 'Tool');
    if (raw.$ref && raw.definitions) {
        const defName = raw.$ref.replace('#/definitions/', '');
        const flattened = raw.definitions[defName];
        if (!flattened) {
            throw new Error(`Could not resolve definition: ${defName}`);
        }
        return flattened;
    }
    return raw;
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/esm/constants.js
const constants_LOCAL_STORAGE_USER_ID_KEY = '___$orama_user_id$___';
const DEFAULT_SERVER_USER_ID = 'ssid';

;// CONCATENATED MODULE: ./node_modules/@orama/core/esm/lib/event-stream.js
class event_stream_EventsStreamTransformer extends TransformStream {
    constructor() {
        const decoder = new TextDecoder('utf-8', { ignoreBOM: false });
        let buffer;
        let currentEvent;
        super({
            start() {
                buffer = '';
                currentEvent = { data: '' };
            },
            transform(chunk, controller) {
                const chunkText = decoder.decode(chunk);
                buffer += chunkText;
                let lineEnd;
                while ((lineEnd = /\r\n|\n|\r/.exec(buffer)) !== null) {
                    const line = buffer.substring(0, lineEnd.index);
                    buffer = buffer.substring(lineEnd.index + lineEnd[0].length);
                    if (line.length === 0) {
                        controller.enqueue(currentEvent);
                        currentEvent = { data: '' };
                    }
                    else if (!line.startsWith(':')) {
                        const firstColonMatch = /:/.exec(line);
                        if (!firstColonMatch) {
                            // @ts-expect-error - Temporary fix
                            currentEvent[line] = '';
                            continue;
                        }
                        const key = line.substring(0, firstColonMatch.index);
                        const value = line.substring(firstColonMatch.index + 1);
                        // @ts-expect-error - Temporary fix
                        currentEvent[key] = value?.replace(/^\u0020/, '');
                    }
                }
            },
        });
    }
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/esm/common.js

class common_Auth {
    constructor(config) {
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.config = config;
    }
    async getRef(target, init) {
        let bearer;
        let baseURL;
        switch (this.config.type) {
            case 'apiKey': {
                bearer = this.config.apiKey;
                if (target == 'writer' && !this.config.writerURL) {
                    throw new Error('Cannot perform a request to a writer without the writerURL. Use `cluster.writerURL` to configure it');
                }
                if (target == 'reader' && !this.config.readerURL) {
                    throw new Error('Cannot perform a request to a writer without the writerURL. Use `cluster.readerURL` to configure it');
                }
                baseURL = target == 'writer' ? this.config.writerURL : this.config.readerURL;
                break;
            }
            case 'jwt': {
                const ret = await getJwtToken(this.config.authJwtURL, this.config.collectionID, this.config.privateApiKey, 'write', init);
                // NB: This allow us to support at *client side* a way invocation to reader with private api key!!
                if (target == 'reader') {
                    baseURL = this.config.readerURL ?? ret.readerURL;
                    bearer = ret.readerApiKey;
                }
                else {
                    bearer = ret.jwt;
                    baseURL = this.config.writerURL ?? ret.writerURL;
                }
                break;
            }
        }
        return {
            bearer,
            baseURL,
        };
    }
}
class common_Client {
    constructor(config) {
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.config = config;
    }
    async request(req) {
        const response = await this.getResponse(req);
        if (!response.ok) {
            let text;
            try {
                text = await response.text();
            }
            catch (e) {
                text = `Unable to got response body ${e}`;
            }
            throw new Error(`Request to "${req.path}?${new URLSearchParams(req.params ?? {}).toString()}" failed with status ${response.status}: ${text}`);
        }
        return response.json();
    }
    async requestStream(req) {
        const response = await this.getResponse(req);
        if (response.body === null) {
            throw new Error(`Response body is null for "${req.path}"`);
        }
        return response.body?.pipeThrough(new event_stream_EventsStreamTransformer());
    }
    async eventSource(req) {
        if (req.apiKeyPosition !== 'query-params') {
            throw new Error(`EventSource only supports apiKeyPosition as 'query-params', but got ${req.apiKeyPosition}`);
        }
        if (req.method !== 'GET') {
            throw new Error(`EventSource only supports GET requests, but got ${req.method}`);
        }
        const { baseURL, bearer, } = await this.config.auth.getRef(req.target, req.init);
        const remoteURL = new URL(req.path, baseURL);
        req.params = req.params ?? {};
        req.params['api-key'] = bearer;
        if (req.params) {
            remoteURL.search = new URLSearchParams(req.params).toString();
        }
        return new EventSource(remoteURL);
    }
    async getResponse({ method, path, body, params, apiKeyPosition, init, target, }) {
        const { baseURL, bearer, } = await this.config.auth.getRef(target, init);
        const remoteURL = new URL(path, baseURL);
        const headers = new Headers();
        headers.append('Content-Type', 'application/json');
        if (apiKeyPosition === 'header') {
            headers.append('Authorization', `Bearer ${bearer}`);
        }
        if (apiKeyPosition === 'query-params') {
            params = params ?? {};
            params['api-key'] = bearer;
        }
        const requestObject = {
            method: method,
            headers,
            ...init,
        };
        if (body && (method === 'POST' || method === 'PUT')) {
            requestObject.body = JSON.stringify(body);
        }
        if (params) {
            remoteURL.search = new URLSearchParams(params).toString();
        }
        const response = await fetch(remoteURL, requestObject);
        if (response.status === 401) {
            throw new Error(`Unauthorized: are you using the correct Api Key?`);
        }
        if (response.status === 400) {
            const errorText = await response.text();
            throw new Error(`Bad Request: ${errorText} (path: ${remoteURL.toString()})`);
        }
        return response;
    }
}
async function getJwtToken(authJwtUrl, collectionId, privateApiKey, scope, init) {
    const payload = {
        collectionId,
        privateApiKey,
        scope,
    };
    const request = await fetch(authJwtUrl, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
        ...init,
    });
    if (!request.ok) {
        throw new Error(`JWT request to ${request.url} failed with status ${request.status}: ${await request.text()}`);
    }
    return request.json();
}
function safeJSONParse(data, silent = true) {
    try {
        return JSON.parse(data);
    }
    catch (error) {
        if (!silent) {
            console.warn('Recovered from failed JSON parsing with error:', error);
        }
        return data;
    }
}
const TRAINING_SETS = (/* unused pure expression or super */ null && (['query_optimizer', 'query_planner', 'query_filtering']));

;// CONCATENATED MODULE: ./node_modules/@orama/core/esm/stream-manager.js






class OramaCoreStream {
    constructor(config) {
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "oramaInterface", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "abortController", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "events", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "LLMConfig", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sessionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "lastInteractionParams", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "messages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "state", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        this.collectionID = config.collectionID;
        this.oramaInterface = config.common;
        this.LLMConfig = config.LLMConfig;
        this.messages = config.initialMessages || [];
        this.events = config.events;
        this.sessionID = config.sessionID || (0,cuid2.createId)();
    }
    async answer(data, init) {
        const stream = this.answerStream(data, init);
        let result = '';
        for await (const chunk of stream) {
            result = chunk;
        }
        return result;
    }
    async *answerStream(data, init) {
        this.lastInteractionParams = { ...data };
        data = this._enrichConfig(data);
        this.abortController = new AbortController();
        // Connect the abort signal to the request
        const requestInit = init ?? {};
        requestInit.signal = this.abortController.signal;
        this.messages.push({ role: 'user', content: data.query });
        this.messages.push({ role: 'assistant', content: '' });
        const interactionID = data.interactionID || (0,cuid2.createId)();
        this.state.push({
            id: interactionID,
            query: data.query,
            optimizedQuery: null,
            response: '',
            sources: null,
            loading: true,
            error: false,
            aborted: false,
            errorMessage: null,
            related: data.related?.enabled ? '' : null,
            currentStep: 'starting',
            currentStepVerbose: null,
            selectedLLM: null,
            advancedAutoquery: null,
        });
        this._pushState();
        const currentStateIndex = this.state.length - 1;
        const currentMessageIndex = this.messages.length - 1;
        try {
            const body = {
                interaction_id: interactionID,
                query: data.query,
                visitor_id: data.visitorID,
                conversation_id: data.sessionID,
                messages: this.messages.slice(0, -1), // Send conversation history excluding the empty assistant message
                llm_config: null,
                related: data.related,
                min_similarity: data.min_similarity,
                max_documents: data.max_documents,
                ragat_notation: data.ragat_notation,
            };
            if (this.LLMConfig) {
                body.llm_config = this.LLMConfig;
            }
            const reqStream = await this.oramaInterface.getResponse({
                method: 'POST',
                path: `/v1/collections/${this.collectionID}/generate/answer`,
                body,
                init: requestInit,
                apiKeyPosition: 'query-params',
                target: 'reader',
            });
            if (!reqStream.body) {
                throw new Error('No response body');
            }
            const emitter = parseAnswerStream(reqStream.body);
            let finished = false;
            let lastYielded = '';
            emitter.on('answer_token', (event) => {
                this.state[currentStateIndex].response += event.token;
                this.messages[currentMessageIndex].content = this.state[currentStateIndex].response;
                this._pushState();
            });
            emitter.on('selected_llm', (event) => {
                this.state[currentStateIndex].selectedLLM = {
                    provider: event.provider,
                    model: event.model,
                };
                this._pushState();
            });
            emitter.on('optimizing_query', (event) => {
                this.state[currentStateIndex].optimizedQuery = safeJSONParse(event.optimized_query);
                this._pushState();
            });
            emitter.on('search_results', (event) => {
                this.state[currentStateIndex].sources = event.results;
                this._pushState();
            });
            emitter.on('related_queries', (event) => {
                this.state[currentStateIndex].related = event.queries;
                this._pushState();
            });
            emitter.onStateChange((event) => {
                this.state[currentStateIndex].currentStep = event.state;
                this._pushState();
            });
            emitter.on('state_changed', (event) => {
                this.events?.onIncomingEvent?.(event);
                const eventData = event.data;
                // Handle advanced autoquery state updates
                if (event.state === 'advanced_autoquery_query_optimized' && eventData?.optimized_queries) {
                    if (!this.state[currentStateIndex].advancedAutoquery) {
                        this.state[currentStateIndex].advancedAutoquery = {};
                    }
                    this.state[currentStateIndex].advancedAutoquery.optimizedQueries = eventData.optimized_queries;
                    const verboseMessage = this.state[currentStateIndex].advancedAutoquery.optimizedQueries?.join('\nAlso, ');
                    const deduped = dedupe(verboseMessage);
                    if (deduped) {
                        this.state[currentStateIndex].currentStepVerbose = verboseMessage;
                        this._pushState();
                    }
                }
                if (event.state === 'advanced_autoquery_properties_selected' && eventData?.selected_properties) {
                    if (!this.state[currentStateIndex].advancedAutoquery) {
                        this.state[currentStateIndex].advancedAutoquery = {};
                    }
                    this.state[currentStateIndex].advancedAutoquery.selectedProperties = eventData.selected_properties;
                    const filters = this.state[currentStateIndex].advancedAutoquery.selectedProperties?.map(Object.values).flat()
                        .map((x) => x.selected_properties).flat().map((x) => `${x.property}`).join(', ');
                    const verboseMessage = `Filtering by ${filters}`;
                    const deduped = dedupe(verboseMessage);
                    if (deduped) {
                        this.state[currentStateIndex].currentStepVerbose = verboseMessage;
                        this._pushState();
                    }
                }
                if (event.state === 'advanced_autoquery_combine_queries' && eventData?.queries_and_properties) {
                    if (!this.state[currentStateIndex].advancedAutoquery) {
                        this.state[currentStateIndex].advancedAutoquery = {};
                    }
                    this.state[currentStateIndex].advancedAutoquery.queriesAndProperties = eventData.queries_and_properties;
                    this._pushState();
                }
                if (event.state === 'advanced_autoquery_tracked_queries_generated' && eventData?.tracked_queries) {
                    if (!this.state[currentStateIndex].advancedAutoquery) {
                        this.state[currentStateIndex].advancedAutoquery = {};
                    }
                    this.state[currentStateIndex].advancedAutoquery.trackedQueries = eventData.tracked_queries;
                    this._pushState();
                }
                if (event.state === 'advanced_autoquery_search_results' && eventData?.search_results) {
                    if (!this.state[currentStateIndex].advancedAutoquery) {
                        this.state[currentStateIndex].advancedAutoquery = {};
                    }
                    this.state[currentStateIndex].advancedAutoquery.searchResults = eventData.search_results;
                    const resultsCount = eventData.search_results.reduce((acc, curr) => acc + curr.results[0].count, 0);
                    const resultText = eventData.search_results.map((x) => JSON.parse(x.generated_query).term).join(', ');
                    const verboseMessage = `Found ${resultsCount} result${resultsCount === 1 ? '' : 's'} for "${resultText}"`;
                    const deduped = dedupe(verboseMessage);
                    if (deduped) {
                        this.state[currentStateIndex].currentStepVerbose = verboseMessage;
                        this._pushState();
                    }
                }
                if (event.state === 'advanced_autoquery_completed' && eventData?.results) {
                    if (!this.state[currentStateIndex].advancedAutoquery) {
                        this.state[currentStateIndex].advancedAutoquery = {};
                    }
                    this.state[currentStateIndex].advancedAutoquery.results = eventData.results;
                    this.state[currentStateIndex].currentStepVerbose = null;
                    this._pushState();
                }
                if (event.state === 'completed') {
                    finished = true;
                    this.state[currentStateIndex].loading = false;
                    this._pushState();
                }
                if (this.events?.onEnd) {
                    this.events.onEnd(this.state);
                }
            });
            while (!finished) {
                const response = this.state[currentStateIndex].response;
                if (response !== lastYielded) {
                    lastYielded = response;
                    yield response;
                }
                else if (!finished) {
                    await new Promise((resolve) => setTimeout(resolve, 0));
                }
            }
        }
        catch (error) {
            // Handle AbortError gracefully
            if (error instanceof Error && error.name === 'AbortError') {
                // Stream was aborted - this is expected behavior, don't throw
                this.state[currentStateIndex].loading = false;
                this.state[currentStateIndex].aborted = true;
                this._pushState();
                return; // Exit the generator gracefully
            }
            // Handle other errors
            this.state[currentStateIndex].loading = false;
            this.state[currentStateIndex].error = true;
            this.state[currentStateIndex].errorMessage = error instanceof Error ? error.message : 'Unknown error';
            this._pushState();
            throw error; // Re-throw non-abort errors
        }
    }
    regenerateLast({ stream = true } = {}, init) {
        if (this.state.length === 0 || this.messages.length === 0) {
            throw new Error('No messages to regenerate');
        }
        const isLastMessageAssistant = this.messages.at(-1)?.role === 'assistant';
        if (!isLastMessageAssistant) {
            throw new Error('Last message is not an assistant message');
        }
        // Remove the last assistant message and state
        this.messages.pop();
        this.state.pop();
        if (!this.lastInteractionParams) {
            throw new Error('No last interaction parameters available');
        }
        if (stream) {
            return this.answerStream(this.lastInteractionParams, init);
        }
        return this.answer(this.lastInteractionParams, init);
    }
    abort() {
        if (!this.abortController) {
            throw new Error('AbortController is not available.');
        }
        if (this.state.length === 0) {
            throw new Error('There is no active request to abort.');
        }
        this.abortController.abort();
        this.abortController = undefined;
        const lastState = this.state[this.state.length - 1];
        lastState.aborted = true;
        lastState.loading = false;
        this._pushState();
    }
    clearSession() {
        this.messages = [];
        this.state = [];
        this._pushState();
    }
    _pushState() {
        this.events?.onStateChange?.(this.state);
    }
    _enrichConfig(config) {
        if (!config.visitorID) {
            config.visitorID = getUserID();
        }
        if (!config.interactionID) {
            config.interactionID = (0,cuid2.createId)();
        }
        if (!config.sessionID) {
            config.sessionID = this.sessionID;
        }
        return config;
    }
}
function getUserID() {
    if (isServerRuntime()) {
        return DEFAULT_SERVER_USER_ID;
    }
    if (hasLocalStorage) {
        const id = localStorage.getItem(constants_LOCAL_STORAGE_USER_ID_KEY);
        if (id) {
            return id;
        }
    }
    return (0,cuid2.createId)();
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/esm/manager.js


class OramaCoreManager {
    constructor(config) {
        Object.defineProperty(this, "collection", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        const client = new Client({
            auth: new Auth({
                type: 'apiKey',
                apiKey: config.masterAPIKey,
                writerURL: config.url,
                readerURL: undefined,
            }),
        });
        this.collection = new CollectionNamespace(client);
    }
}
class CollectionNamespace {
    constructor(client) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
    }
    async create(config, init) {
        const body = {
            id: config.id,
            description: config.description,
            write_api_key: config.writeAPIKey ?? createRandomString(32),
            read_api_key: config.readAPIKey ?? createRandomString(32),
        };
        if (config.embeddingsModel) {
            body.embeddings_model = config.embeddingsModel;
        }
        await this.client.request({
            path: '/v1/collections/create',
            body,
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
        return {
            id: body.id,
            description: body.description,
            writeAPIKey: body.write_api_key,
            readonlyAPIKey: body.read_api_key,
        };
    }
    list(init) {
        return this.client.request({
            path: '/v1/collections',
            method: 'GET',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    get(collectionID, init) {
        return this.client.request({
            path: `/v1/collections/${collectionID}`,
            method: 'GET',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    delete(collectionID, init) {
        return this.client.request({
            path: `/v1/collections/delete`,
            method: 'POST',
            body: {
                collection_id_to_delete: collectionID,
            },
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/esm/send-beacon.js
function send_beacon_sendBeacon(endpoint, body) {
    if (typeof navigator !== 'undefined') {
        if (typeof navigator.sendBeacon !== 'undefined') {
            navigator.sendBeacon(endpoint, body);
        }
        return;
    }
    fetch(endpoint, {
        method: 'POST',
        body,
        headers: {
            'Content-Type': 'application/json',
        },
    }).then(() => { }, (e) => console.log(e));
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/esm/profile.js



class Profile {
    constructor({ endpoint, apiKey }) {
        Object.defineProperty(this, "endpoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "apiKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "userId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "identity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "userAlias", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (!endpoint || !apiKey) {
            throw new Error('Endpoint and API Key are required to create a Profile');
        }
        if (typeof endpoint !== 'string' || typeof apiKey !== 'string') {
            throw new Error('Endpoint and API Key must be strings');
        }
        if (typeof localStorage !== 'undefined') {
            // Browser side
            const userId = localStorage.getItem(constants_LOCAL_STORAGE_USER_ID_KEY);
            if (userId) {
                this.userId = userId;
            }
            else {
                this.userId = (0,cuid2.createId)();
                localStorage.setItem(constants_LOCAL_STORAGE_USER_ID_KEY, this.userId);
            }
        }
        else {
            // Server side
            this.userId = (0,cuid2.createId)();
        }
        this.endpoint = endpoint;
        this.apiKey = apiKey;
    }
    setParams(params) {
        const { protocol, host } = new URL(params.identifyUrl);
        const telemetryDomain = `${protocol}//${host}/identify`;
        this.params = {
            identifyUrl: telemetryDomain,
            index: params.index,
        };
    }
    getIdentity() {
        return this.identity;
    }
    getUserId() {
        return this.userId;
    }
    getAlias() {
        return this.userAlias;
    }
    async sendProfileData(data) {
        if (!this.params) {
            throw new Error('Orama Profile is not initialized');
        }
        const body = JSON.stringify({
            ...data,
            visitorId: this.getUserId(),
            index: this.params.index,
        });
        await send_beacon_sendBeacon(`${this.params?.identifyUrl}?api-key=${this.apiKey}`, body);
    }
    async identify(identity) {
        if (typeof identity !== 'string') {
            throw new Error('Identity must be a string');
        }
        await this.sendProfileData({
            entity: 'identity',
            id: identity,
        });
        this.identity = identity;
    }
    async alias(alias) {
        if (typeof alias !== 'string') {
            throw new Error('Identity must be a string');
        }
        await this.sendProfileData({
            entity: 'alias',
            id: alias,
        });
        this.userAlias = alias;
    }
    reset() {
        this.userId = (0,cuid2.createId)();
        this.identity = undefined;
        this.userAlias = undefined;
    }
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/esm/collection.js







const DEFAULT_READER_URL = 'https://collections.orama.com';
const DEAFULT_JWT_URL = 'https://app.orama.com/api/user/jwt';
class collection_CollectionManager {
    constructor(config) {
        // private url: string
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "apiKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // private writeAPIKey?: string
        // private readAPIKey?: string
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "profile", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "ai", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collections", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "hooks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "logs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "systemPrompts", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tools", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "identity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "trainingSets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "mcp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        let auth;
        if (config.apiKey.startsWith('p_')) {
            // OramaCore Cloud Private Api Key (JWT flow)
            auth = new common_Auth({
                type: 'jwt',
                authJwtURL: config.authJwtURL ?? DEAFULT_JWT_URL,
                collectionID: config.collectionID,
                privateApiKey: config.apiKey,
                readerURL: config.cluster?.readURL ?? DEFAULT_READER_URL,
                writerURL: config.cluster?.writerURL,
            });
        }
        else {
            auth = new common_Auth({
                type: 'apiKey',
                readerURL: config.cluster?.readURL ?? DEFAULT_READER_URL,
                writerURL: config.cluster?.writerURL,
                apiKey: config.apiKey,
            });
            this.profile = new Profile({
                endpoint: config.cluster?.readURL ?? DEFAULT_READER_URL,
                apiKey: config.apiKey,
            });
        }
        const commonConfig = {
            auth,
        };
        this.collectionID = config.collectionID;
        this.client = new common_Client(commonConfig);
        this.apiKey = config.apiKey;
        // Initialize namespaces
        this.ai = new AINamespace(this.client, this.collectionID, this.profile);
        this.collections = new CollectionsNamespace(this.client, this.collectionID);
        this.index = new IndexNamespace(this.client, this.collectionID);
        this.hooks = new HooksNamespace(this.client, this.collectionID);
        this.logs = new LogsNamespace(this.client, this.collectionID);
        this.systemPrompts = new SystemPromptsNamespace(this.client, this.collectionID);
        this.tools = new ToolsNamespace(this.client, this.collectionID);
        this.identity = new IdentityNamespace(this.profile);
        this.trainingSets = new TrainingSetsNamespace(this.client, this.collectionID);
        this.mcp = new MCPNamespace(this.client, this.collectionID);
    }
    async search(query, init) {
        const start = Date.now();
        const { datasourceIDs, indexes, ...restQuery } = query;
        const result = await this.client.request({
            path: `/v1/collections/${this.collectionID}/search`,
            body: {
                userID: this.profile?.getUserId() || undefined,
                ...restQuery, // restQuery can override `userID`
                indexes: datasourceIDs || indexes,
            },
            method: 'POST',
            params: undefined,
            init,
            apiKeyPosition: 'query-params',
            target: 'reader',
        });
        const elapsed = Date.now() - start;
        return {
            ...result,
            elapsed: {
                raw: elapsed,
                formatted: formatDuration(elapsed),
            },
        };
    }
}
class AINamespace {
    constructor(client, collectionID, profile) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "profile", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.collectionID = collectionID;
        this.profile = profile;
    }
    async NLPSearch(params, init) {
        const body = {
            llm_config: params.LLMConfig ? { ...params.LLMConfig } : undefined,
            userID: this.profile?.getUserId() || undefined,
            messages: [
                {
                    role: 'user',
                    content: params.query,
                },
            ],
        };
        const response = await this.client.getResponse({
            method: 'POST',
            path: `/v1/collections/${this.collectionID}/generate/nlp_query`,
            body: body,
            init,
            apiKeyPosition: 'query-params',
            target: 'reader',
        });
        if (!response.body) {
            throw new Error('No response body');
        }
        const emitter = parseNLPQueryStream(response.body);
        let finished = false;
        let results = [];
        emitter.on('search_results', (event) => {
            results = event.results;
            finished = true;
        });
        emitter.on('error', (e) => {
            if (e.is_terminal) {
                finished = true;
            }
            throw new Error(e.error);
        });
        while (!finished) {
            await new Promise((resolve) => setTimeout(resolve, 10));
        }
        return results;
    }
    async *NLPSearchStream(params, init) {
        const body = {
            llm_config: params.LLMConfig ? { ...params.LLMConfig } : undefined,
            userID: this.profile?.getUserId() || undefined,
            messages: [
                {
                    role: 'user',
                    content: params.query,
                },
            ],
        };
        const response = await this.client.getResponse({
            method: 'POST',
            path: `/v1/collections/${this.collectionID}/generate/nlp_query`,
            body: body,
            init,
            apiKeyPosition: 'query-params',
            target: 'reader',
        });
        if (!response.body) {
            throw new Error('No response body');
        }
        let finished = false;
        let currentResult = null;
        const emitter = parseNLPQueryStream(response.body);
        emitter.on('error', (e) => {
            if (e.is_terminal) {
                finished = true;
            }
            throw new Error(e.error);
        });
        emitter.on('state_changed', (event) => {
            currentResult = {
                status: event.state,
                data: (event.data || []),
            };
        });
        emitter.on('search_results', (event) => {
            currentResult = {
                status: 'SEARCH_RESULTS',
                data: event.results,
            };
            finished = true;
        });
        // Yield results until we get search results
        while (!finished) {
            if (currentResult !== null) {
                const deduped = dedupe(currentResult.status);
                if (deduped) {
                    yield currentResult;
                }
            }
            // Small delay to prevent busy waiting
            await new Promise((resolve) => setTimeout(resolve, 10));
        }
        // Yield the final search results
        if (currentResult !== null) {
            const deduped = dedupe(currentResult.status);
            if (deduped) {
                yield currentResult;
            }
        }
    }
    createAISession(config) {
        return new OramaCoreStream({
            collectionID: this.collectionID,
            common: this.client,
            ...config,
        });
    }
}
class CollectionsNamespace {
    constructor(client, collectionID) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.collectionID = collectionID;
    }
    getStats(collectionID, init) {
        return this.client.request({
            path: `/v1/collections/${collectionID}/stats`,
            method: 'GET',
            init,
            apiKeyPosition: 'query-params',
            target: 'reader',
        });
    }
    getAllDocs(id, init) {
        return this.client.request({
            path: `/v1/collections/list`,
            method: 'POST',
            body: { id },
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
}
class IndexNamespace {
    constructor(client, collectionID) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.collectionID = collectionID;
    }
    async create(config, init) {
        const body = {
            id: config.id,
            embedding: config.embeddings,
        };
        if (config?.typeStrategy?.enum) {
            const enumStrategy = config.typeStrategy.enum;
            if (enumStrategy === 'explicit') {
                body.type_strategy = {
                    enum_strategy: 'Explicit',
                };
            }
            else {
                const match = enumStrategy.match(/^string\((\d+)\)$/);
                if (match) {
                    const length = parseInt(match[1], 10);
                    body.type_strategy = {
                        enum_strategy: {
                            StringLength: length,
                        },
                    };
                }
                else {
                    throw new Error('Invalid enum strategy format. Use "explicit" or "string(N)" where N is a number.');
                }
            }
        }
        await this.client.request({
            path: `/v1/collections/${this.collectionID}/indexes/create`,
            body,
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    async delete(indexID, init) {
        await this.client.request({
            path: `/v1/collections/${this.collectionID}/indexes/delete`,
            body: { index_id_to_delete: indexID },
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    set(id) {
        return new Index(this.client, this.collectionID, id);
    }
}
class HooksNamespace {
    constructor(client, collectionID) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.collectionID = collectionID;
    }
    async insert(config, init) {
        const body = {
            name: config.name,
            code: config.code,
        };
        await this.client.request({
            path: `/v1/collections/${this.collectionID}/hooks/set`,
            body,
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
        return {
            hookID: body.name,
            code: body.code,
        };
    }
    async list(init) {
        const res = await this.client.request({
            path: `/v1/collections/${this.collectionID}/hooks/list`,
            method: 'GET',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
        return res.hooks || {};
    }
    async delete(hook, init) {
        const body = {
            name_to_delete: hook,
        };
        await this.client.request({
            path: `/v1/collections/${this.collectionID}/hooks/delete`,
            body,
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
}
class PinningRulesNamespace {
    constructor(client, collectionID, indexID) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "indexID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.collectionID = collectionID;
        this.indexID = indexID;
    }
    insert(rule) {
        if (!rule.id) {
            rule.id = utils_createRandomString(32);
        }
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/indexes/${this.indexID}/pin_rules/insert`,
            body: rule,
            method: 'POST',
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    update(rule) {
        if (!rule.id) {
            rule.id = utils_createRandomString(32);
        }
        return this.insert(rule);
    }
    async list() {
        const results = await this.client.request({
            path: `/v1/collections/${this.collectionID}/indexes/${this.indexID}/pin_rules/list`,
            method: 'GET',
            apiKeyPosition: 'header',
            target: 'writer',
        });
        return results.data;
    }
    listIDs() {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/indexes/${this.indexID}/pin_rules/ids`,
            method: 'GET',
            apiKeyPosition: 'query-params',
            target: 'reader',
        });
    }
    delete(id) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/indexes/${this.indexID}/pin_rules/delete`,
            method: 'POST',
            body: {
                pin_rule_id_to_delete: id,
            },
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
}
class LogsNamespace {
    constructor(client, collectionID) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.collectionID = collectionID;
    }
    stream(init) {
        return this.client.eventSource({
            path: `/v1/collections/${this.collectionID}/logs`,
            method: 'GET',
            init,
            apiKeyPosition: 'query-params',
            target: 'reader',
        });
    }
}
class SystemPromptsNamespace {
    constructor(client, collectionID) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.collectionID = collectionID;
    }
    insert(systemPrompt, init) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/system_prompts/insert`,
            body: systemPrompt,
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    get(id, init) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/system_prompts/get`,
            params: { system_prompt_id: id },
            method: 'GET',
            init,
            apiKeyPosition: 'query-params',
            target: 'reader',
        });
    }
    getAll(init) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/system_prompts/all`,
            method: 'GET',
            init,
            apiKeyPosition: 'query-params',
            target: 'reader',
        });
    }
    delete(id, init) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/system_prompts/delete`,
            body: { id },
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    update(systemPrompt, init) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/system_prompts/update`,
            body: systemPrompt,
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    validate(systemPrompt, init) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/system_prompts/validate`,
            body: systemPrompt,
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
}
class ToolsNamespace {
    constructor(client, collectionID) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.collectionID = collectionID;
    }
    insert(tool, init) {
        let parameters;
        switch (true) {
            case typeof tool.parameters === 'string': {
                parameters = tool.parameters;
                break;
            }
            case tool.parameters instanceof ZodType: {
                const flattenedSchema = flattenZodSchema(tool.parameters);
                parameters = JSON.stringify(flattenedSchema);
                break;
            }
            case typeof tool.parameters === 'object': {
                parameters = JSON.stringify(tool.parameters);
                break;
            }
            default:
                throw new Error('Invalid parameters type. Must be string, object or ZodType');
        }
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/tools/insert`,
            body: {
                ...tool,
                parameters,
            },
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    get(id, init) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/tools/get`,
            params: { tool_id: id },
            method: 'GET',
            init,
            apiKeyPosition: 'query-params',
            target: 'reader',
        });
    }
    getAll(init) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/tools/all`,
            method: 'GET',
            init,
            apiKeyPosition: 'query-params',
            target: 'reader',
        });
    }
    delete(id, init) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/tools/delete`,
            body: { id },
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    update(tool, init) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/tools/update`,
            body: tool,
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    async execute(tools, init) {
        const response = await this.client.request({
            path: `/v1/collections/${this.collectionID}/tools/run`,
            body: tools,
            method: 'POST',
            init,
            apiKeyPosition: 'query-params',
            target: 'reader',
        });
        if (response.results) {
            return {
                results: response.results.map((result) => {
                    if ('functionResult' in result) {
                        return {
                            functionResult: {
                                tool_id: result.functionResult.tool_id,
                                result: JSON.parse(result.functionResult.result),
                            },
                        };
                    }
                    if ('functionParameters' in result) {
                        return {
                            functionParameters: {
                                tool_id: result.functionParameters.tool_id,
                                result: JSON.parse(result.functionParameters.result),
                            },
                        };
                    }
                    return result;
                }),
            };
        }
        return {
            results: null,
        };
    }
}
class IdentityNamespace {
    constructor(profile) {
        Object.defineProperty(this, "profile", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.profile = profile;
    }
    get() {
        if (!this.profile) {
            throw new Error('Profile is not defined');
        }
        return this.profile.getIdentity();
    }
    getUserId() {
        if (!this.profile) {
            throw new Error('Profile is not defined');
        }
        return this.profile.getUserId();
    }
    getAlias() {
        if (!this.profile) {
            throw new Error('Profile is not defined');
        }
        return this.profile.getAlias();
    }
    async identify(identity) {
        if (!this.profile) {
            throw new Error('Profile is not defined');
        }
        await this.profile.identify(identity);
    }
    async alias(alias) {
        if (!this.profile) {
            throw new Error('Profile is not defined');
        }
        await this.profile.alias(alias);
    }
    reset() {
        if (!this.profile) {
            throw new Error('Profile is not defined');
        }
        this.profile.reset();
    }
}
class TrainingSetsNamespace {
    constructor(client, collectionID) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.collectionID = collectionID;
    }
    async get(trainingSetId, init) {
        const response = await this.client.request({
            path: `/v1/collections/${this.collectionID}/training_sets/${trainingSetId}/get`,
            method: 'GET',
            init,
            apiKeyPosition: 'query-params',
            target: 'reader',
        });
        const trainingSets = response.training_sets && JSON.parse(response.training_sets);
        return { training_sets: trainingSets };
    }
    generate(trainingSetId, LLMConfig, init) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/training_sets/${trainingSetId}/generate`,
            method: 'POST',
            body: {
                llm_config: LLMConfig ? { ...LLMConfig } : undefined,
            },
            init,
            apiKeyPosition: 'query-params',
            target: 'reader',
        });
    }
    insert(trainingSetId, trainingSet, init) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/training_sets/${trainingSetId}/insert`,
            method: 'POST',
            body: {
                training_set: trainingSet,
            },
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    delete(trainingSetId, init) {
        return this.client.request({
            path: `/v1/collections/${this.collectionID}/training_sets/${trainingSetId}/delete`,
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
}
class Index {
    constructor(oramaInterface, collectionID, indexID) {
        Object.defineProperty(this, "indexID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "oramaInterface", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "transaction", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "pinningRules", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.indexID = indexID;
        this.collectionID = collectionID;
        this.oramaInterface = oramaInterface;
        this.transaction = new Transaction(oramaInterface, collectionID, indexID);
        this.pinningRules = new PinningRulesNamespace(oramaInterface, collectionID, indexID);
    }
    async reindex(init) {
        await this.oramaInterface.request({
            path: `/v1/collections/${this.collectionID}/indexes/${this.indexID}/reindex`,
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    async insertDocuments(documents, init) {
        await this.oramaInterface.request({
            path: `/v1/collections/${this.collectionID}/indexes/${this.indexID}/insert`,
            body: Array.isArray(documents) ? documents : [documents],
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    async deleteDocuments(documentIDs, init) {
        await this.oramaInterface.request({
            path: `/v1/collections/${this.collectionID}/indexes/${this.indexID}/delete`,
            body: Array.isArray(documentIDs) ? documentIDs : [documentIDs],
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    async upsertDocuments(documents, init) {
        await this.oramaInterface.request({
            path: `/v1/collections/${this.collectionID}/indexes/${this.indexID}/documents/upsert`,
            body: {
                strategy: "merge",
                documents: documents
            },
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
}
class Transaction {
    constructor(oramaInterface, collectionID, indexID, tempIndexID = utils_createRandomString(16)) {
        Object.defineProperty(this, "indexID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tempIndexID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "oramaInterface", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.oramaInterface = oramaInterface;
        this.collectionID = collectionID;
        this.indexID = indexID;
        this.tempIndexID = tempIndexID;
    }
    open(init) {
        return this.oramaInterface.request({
            path: `/v1/collections/${this.collectionID}/indexes/${this.indexID}/create-temporary-index`,
            method: 'POST',
            body: {
                id: this.tempIndexID,
            },
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    insertDocuments(documents, init) {
        return this.oramaInterface.request({
            path: `/v1/collections/${this.collectionID}/indexes/${this.tempIndexID}/insert`,
            body: Array.isArray(documents) ? documents : [documents],
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    commit(init) {
        return this.oramaInterface.request({
            path: `/v1/collections/${this.collectionID}/replace-index`,
            method: 'POST',
            body: {
                target_index_id: this.indexID,
                temp_index_id: this.tempIndexID,
            },
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
    rollback(init) {
        return this.oramaInterface.request({
            path: `/v1/collections/${this.collectionID}/indexes/${this.tempIndexID}/delete`,
            method: 'POST',
            init,
            apiKeyPosition: 'header',
            target: 'writer',
        });
    }
}
class MCPNamespace {
    constructor(client, collectionID) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collectionID", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.collectionID = collectionID;
    }
    updateDescription(newDescription, init) {
        return this.client.request({
            method: 'PUT',
            target: 'writer',
            apiKeyPosition: 'header',
            init,
            path: `/v1/collections/${this.collectionID}/mcp/update`,
            body: {
                mcp_description: newDescription,
            },
        });
    }
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/esm/cloud.js

class OramaCloud {
    constructor(config) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        // Expose all namespaces from CollectionManager
        Object.defineProperty(this, "identity", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "ai", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "collections", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "hooks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "logs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "systemPrompts", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tools", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = new CollectionManager({
            ...config,
            collectionID: config.projectId,
        });
        // Delegate to CollectionManager namespaces
        this.identity = this.client.identity;
        this.ai = this.client.ai;
        this.collections = this.client.collections;
        this.index = this.client.index;
        this.hooks = this.client.hooks;
        this.logs = this.client.logs;
        this.systemPrompts = this.client.systemPrompts;
        this.tools = this.client.tools;
    }
    search(params) {
        const { datasources, ...rest } = params;
        return this.client.search({ ...rest, indexes: datasources });
    }
    dataSource(id) {
        const index = this.client.index.set(id);
        return new DataSourceNamespace(index);
    }
}
class DataSourceNamespace {
    constructor(index) {
        Object.defineProperty(this, "index", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.index = index;
    }
    reindex() {
        return this.index.reindex();
    }
    insertDocuments(documents) {
        return this.index.insertDocuments(documents);
    }
    deleteDocuments(documentIDs) {
        return this.index.deleteDocuments(documentIDs);
    }
    upsertDocuments(documents) {
        return this.index.upsertDocuments(documents);
    }
}

;// CONCATENATED MODULE: ./node_modules/@orama/core/esm/index.js







const dedupe = (() => {
    const seenMessages = new Set();
    return function (message) {
        if (!message)
            return '';
        if (seenMessages.has(message)) {
            return '';
        }
        seenMessages.add(message);
        return message;
    };
})();

;// CONCATENATED MODULE: ./node_modules/@orama/plugin-docusaurus-v3/dist/constants.js
const DOCS_PRESET_SCHEMA = {
    title: 'string',
    content: 'string',
    path: 'string',
    section: 'string',
    category: 'enum',
    version: 'enum'
};

;// CONCATENATED MODULE: ./node_modules/@orama/plugin-docusaurus-v3/dist/utils.js


const restFetcher = async (url, options)=>{
    const response = await fetch(url, options);
    if (response.status === 0) {
        throw new Error(`Request failed (network error): ${await response.text()}`);
    } else if (response.status >= 400) {
        const error = new Error(`Request failed (HTTP error ${response.status})}`);
        error.response = response;
        throw error;
    }
    return await response.json();
};
async function loggedOperation(preMessage, fn, postMessage) {
    if (preMessage != null) {
        console.debug(preMessage);
    }
    try {
        const response = await fn();
        if (postMessage != null) {
            console.debug(postMessage);
        }
        return response;
    } catch (error) {
        throw new Error(`Error: ${error.message}`);
    }
}
async function fetchEndpointConfig(baseUrl, APIKey, indexId) {
    const result = await loggedOperation('Orama: Fetch index endpoint config', async ()=>await restFetcher(`${baseUrl}/indexes/get-index?id=${indexId}`, {
            headers: {
                Authorization: `Bearer ${APIKey}`
            }
        }), 'Orama: Fetch index endpoint config (success)');
    return {
        endpoint: result === null || result === void 0 ? void 0 : result.api_endpoint,
        api_key: result === null || result === void 0 ? void 0 : result.api_key,
        collection_id: ''
    };
}
async function createOramaInstance(oramaDocs) {
    console.debug('Orama: Creating instance.');
    const db = create_create({
        schema: {
            ...DOCS_PRESET_SCHEMA,
            version: 'enum'
        }
    });
    await insertMultiple(db, oramaDocs);
    console.debug('Orama: Instance created.');
    return db;
}

;// CONCATENATED MODULE: ./node_modules/@orama/plugin-docusaurus-v3/dist/theme/SearchBar/useOrama.js










function getOramaPlugins(plugins) {
    const pluginsArray = [];
    if (plugins === null || plugins === void 0 ? void 0 : plugins.analytics) {
        pluginsArray.push(O({
            apiKey: plugins.analytics.apiKey,
            indexId: plugins.analytics.indexId,
            enabled: plugins.analytics.enabled
        }));
    }
    return pluginsArray;
}
async function getOramaLocalData(indexGzipURL, plugins) {
    try {
        const searchResponse = await fetch(indexGzipURL);
        if (!searchResponse.ok) {
            const errorText = await searchResponse.text();
            throw new Error(`HTTP error ${searchResponse.status}: ${errorText}`);
        }
        const buffer = await searchResponse.arrayBuffer();
        const deflatedString = ungzip_1(buffer, {
            to: 'string'
        });
        const parsedData = JSON.parse(deflatedString);
        const db = create_create({
            schema: {
                ...DOCS_PRESET_SCHEMA,
                version: 'enum'
            },
            plugins: getOramaPlugins(plugins)
        });
        serialization_load(db, parsedData);
        return db;
    } catch (error) {
        console.error('Error loading search index:', error);
        throw error;
    }
}
function isCloudData(data) {
    return data.oramaMode === 'cloud';
}
function useOrama() {
    const [searchBoxConfig, setSearchBoxConfig] = (0,react.useState)({
        basic: {},
        custom: {}
    });
    const oramaData = (0,useGlobalData/* .usePluginData */.P_)('@orama/plugin-docusaurus-v3');
    const indexGzipURL = (0,useBaseUrl/* ["default"] */.Ay)('orama-search-index-current.json.gz');
    const isBrowser = (0,useIsBrowser/* ["default"] */.A)();
    (0,react.useEffect)(()=>{
        async function loadOrama() {
            var _a;
            let oramaInstance;
            let searchBoxBasicConfig = {};
            if (isCloudData(oramaData)) {
                const collectionId = oramaData.indexConfig.collection_id;
                const apiKey = oramaData.indexConfig.api_key;
                let collectionManager;
                if (collectionId) {
                    // Note: collectionId is ONLY available in OramaCore
                    collectionManager = new collection_CollectionManager({
                        collectionID: collectionId,
                        apiKey
                    });
                }
                searchBoxBasicConfig = {
                    index: {
                        endpoint: oramaData.indexConfig.endpoint,
                        api_key: oramaData.indexConfig.api_key
                    },
                    collectionManager: collectionManager
                };
            } else if (oramaData.oramaDocs) {
                oramaInstance = await createOramaInstance(oramaData.oramaDocs);
                searchBoxBasicConfig = {
                    clientInstance: oramaInstance
                };
            } else {
                oramaInstance = await getOramaLocalData(indexGzipURL, oramaData.plugins);
                searchBoxBasicConfig = {
                    clientInstance: oramaInstance
                };
            }
            setSearchBoxConfig({
                basic: {
                    ...searchBoxBasicConfig,
                    facetProperty: 'category',
                    disableChat: !isCloudData(oramaData)
                },
                custom: (_a = oramaData.searchbox) !== null && _a !== void 0 ? _a : {}
            });
        }
        if (!isBrowser) {
            return;
        }
        loadOrama().catch((error)=>{
            console.error('Cannot load search index.', error);
        });
    }, [
        isBrowser
    ]);
    return {
        searchBoxConfig,
        searchBtnConfig: oramaData.searchButton
    };
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

// TODO Docusaurus v4: remove these workarounds as a breaking change
//  and remove docs plugin peerDeps in theme-common/package.json
//  This is public API surface that we need to keep for v3
//  See https://github.com/facebook/docusaurus/pull/10316
function useCurrentSidebarCategory(...args) {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    return (__webpack_require__(88209)/* .useCurrentSidebarCategory */.$S)(...args);
}
function filterDocCardListItems(...args) {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    return (__webpack_require__(88209)/* .filterDocCardListItems */.d1)(...args);
}
function useDocsPreferredVersion(...args) {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    return (__webpack_require__(88209)/* .useDocsPreferredVersion */.g1)(...args);
}
function useContextualSearchFilters() {
    const { i18n } = useDocusaurusContext();
    const docsTags = // eslint-disable-next-line @typescript-eslint/no-var-requires, react-compiler/react-compiler
    (__webpack_require__(88209)/* .useDocsContextualSearchTags */.vF)();
    const tags = [
        DEFAULT_SEARCH_TAG,
        ...docsTags
    ];
    return {
        locale: i18n.currentLocale,
        tags
    };
}
/*
 * APIs to document
 */ 











/*
 * APIs kept undocumented, on purpose
 * Note: we still guarantee retro-compatibility on those
 */ 










 //# sourceMappingURL=index.js.map

;// CONCATENATED MODULE: ./node_modules/@orama/plugin-docusaurus-v3/dist/theme/SearchBar/utils.js


function getColorMode() {
    if (typeof document === 'undefined') {
        return 'light';
    }
    const html = document.querySelector("html");
    return html === null || html === void 0 ? void 0 : html.dataset.theme;
}
function getPreferredVersion(index) {
    var _a;
    const activePlugin = (0,lib_client/* .useActivePlugin */.vT)();
    try {
        const { preferredVersion } = useDocsPreferredVersion((_a = activePlugin === null || activePlugin === void 0 ? void 0 : activePlugin.pluginId) !== null && _a !== void 0 ? _a : "default");
        if (!preferredVersion) {
            throw new reactUtils/* .ReactContextError */.dV("Not using versioned docs");
        }
        return preferredVersion.name;
    } catch (e) {
        if (index) {
            if (e instanceof reactUtils/* .ReactContextError */.dV) {
                return "current";
            } else {
                throw e;
            }
        }
        return null;
    }
}

;// CONCATENATED MODULE: ./node_modules/@orama/plugin-docusaurus-v3/dist/theme/SearchBar/index.js







const OramaSearchButton = /*#__PURE__*/ (0,react.lazy)(()=>__webpack_require__.e(/* import() */ "1359").then(__webpack_require__.bind(__webpack_require__, 19042)).then((module)=>({
            default: module.OramaSearchButton
        })));
const OramaSearchBox = /*#__PURE__*/ (0,react.lazy)(()=>__webpack_require__.e(/* import() */ "1359").then(__webpack_require__.bind(__webpack_require__, 19042)).then((module)=>({
            default: module.OramaSearchBox
        })));
// Add `where` when collectionManager is provided
// Handles different query APIs
function formatSearchParams(versionName, collectionManager) {
    if (collectionManager) {
        return {
            version: versionName
        };
    }
    return {
        version: {
            eq: versionName
        }
    };
}
function OramaSearchNoDocs() {
    var _a;
    const colorMode = getColorMode();
    const { searchBoxConfig, searchBtnConfig = {
        text: 'Search'
    } } = useOrama();
    const collectionManager = (_a = searchBoxConfig.basic) === null || _a === void 0 ? void 0 : _a.collectionManager;
    return /*#__PURE__*/ react.createElement(react.Fragment, null, /*#__PURE__*/ react.createElement(OramaSearchButton, {
        colorScheme: colorMode,
        className: "DocSearch-Button",
        ...searchBtnConfig
    }, searchBtnConfig === null || searchBtnConfig === void 0 ? void 0 : searchBtnConfig.text), /*#__PURE__*/ react.createElement(OramaSearchBox, {
        ...collectionManager ? {} : searchBoxConfig.basic,
        ...searchBoxConfig.custom,
        oramaCoreClientInstance: collectionManager,
        colorScheme: colorMode,
        searchParams: {
            where: formatSearchParams('current', collectionManager)
        }
    }));
}
function OramaSearchWithDocs({ pluginId }) {
    var _a;
    const colorMode = getColorMode();
    const { searchBoxConfig, searchBtnConfig } = useOrama();
    const collectionManager = (_a = searchBoxConfig.basic) === null || _a === void 0 ? void 0 : _a.collectionManager;
    const versions = (0,lib_client/* .useVersions */.jh)(pluginId);
    const activeVersion = (0,lib_client/* .useActiveVersion */.ir)(pluginId);
    const preferredVersion = getPreferredVersion(searchBoxConfig.basic.clientInstance);
    const currentVersion = activeVersion || preferredVersion || versions[0];
    const searchParams = {
        ...currentVersion && {
            ...formatSearchParams(currentVersion, collectionManager)
        }
    };
    return /*#__PURE__*/ react.createElement(react.Fragment, null, /*#__PURE__*/ react.createElement(OramaSearchButton, {
        colorScheme: colorMode,
        className: "DocSearch-Button",
        ...searchBtnConfig
    }, (searchBtnConfig === null || searchBtnConfig === void 0 ? void 0 : searchBtnConfig.text) || 'Search'), /*#__PURE__*/ react.createElement(OramaSearchBox, {
        ...collectionManager ? {} : searchBoxConfig.basic,
        ...searchBoxConfig.custom,
        oramaCoreClientInstance: collectionManager,
        colorScheme: colorMode,
        searchParams: {
            where: searchParams
        }
    }));
}
function OramaSearchWrapper() {
    const { pathname } = (0,react_router/* .useLocation */.zy)();
    const { docsInstances } = (0,useGlobalData/* .usePluginData */.P_)('@orama/plugin-docusaurus-v3');
    let pluginId = undefined;
    if (docsInstances) {
        pluginId = docsInstances.find((id)=>pathname.includes(id)) || (docsInstances === null || docsInstances === void 0 ? void 0 : docsInstances[0]);
    }
    return /*#__PURE__*/ react.createElement(BrowserOnly/* ["default"] */.A, {
        fallback: /*#__PURE__*/ react.createElement("div", null, "Loading Search...")
    }, ()=>{
        if (pluginId) {
            return /*#__PURE__*/ react.createElement(OramaSearchWithDocs, {
                pluginId: pluginId
            });
        } else {
            return /*#__PURE__*/ react.createElement(OramaSearchNoDocs, null);
        }
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/Search/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const Search_styles_module = ({"navbarSearchContainer":"navbarSearchContainer_Bca1"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/Search/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



function NavbarSearch({ children, className }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
        className: (0,clsx/* ["default"] */.A)(className, Search_styles_module.navbarSearchContainer),
        children: children
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/SearchNavbarItem.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



function SearchNavbarItem({ mobile, className }) {
    if (mobile) {
        return null;
    }
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarSearch, {
        className: className,
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(OramaSearchWrapper, {})
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/HtmlNavbarItem.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


function HtmlNavbarItem({ value, className, mobile = false, isDropdownItem = false }) {
    const Comp = isDropdownItem ? 'li' : 'div';
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(Comp, {
        className: (0,clsx/* ["default"] */.A)({
            navbar__item: !mobile && !isDropdownItem,
            'menu__list-item': mobile
        }, className),
        dangerouslySetInnerHTML: {
            __html: value
        }
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/plugin-content-docs/lib/client/docsUtils.js
var docsUtils = __webpack_require__(88260);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/DocNavbarItem.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



function DocNavbarItem({ docId, label: staticLabel, docsPluginId, ...props }) {
    const { activeDoc } = (0,lib_client/* .useActiveDocContext */.zK)(docsPluginId);
    const doc = (0,docsUtils/* .useLayoutDoc */.QB)(docId, docsPluginId);
    const pageActive = activeDoc?.path === doc?.path;
    // Draft and unlisted items are not displayed in the navbar.
    if (doc === null || doc.unlisted && !pageActive) {
        return null;
    }
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(DefaultNavbarItem, {
        exact: true,
        ...props,
        isActive: ()=>pageActive || !!activeDoc?.sidebar && activeDoc.sidebar === doc.sidebar,
        label: staticLabel ?? doc.id,
        to: doc.path
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/DocSidebarNavbarItem.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



function DocSidebarNavbarItem({ sidebarId, label, docsPluginId, ...props }) {
    const { activeDoc } = (0,lib_client/* .useActiveDocContext */.zK)(docsPluginId);
    const sidebarLink = (0,docsUtils/* .useLayoutDocsSidebar */.fW)(sidebarId, docsPluginId).link;
    if (!sidebarLink) {
        throw new Error(`DocSidebarNavbarItem: Sidebar with ID "${sidebarId}" doesn't have anything to be linked to.`);
    }
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(DefaultNavbarItem, {
        exact: true,
        ...props,
        isActive: ()=>activeDoc?.sidebar === sidebarId,
        label: label ?? sidebarLink.label,
        to: sidebarLink.path
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/DocsVersionNavbarItem.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



const getVersionMainDoc = (version)=>version.docs.find((doc)=>doc.id === version.mainDocId);
function DocsVersionNavbarItem({ label: staticLabel, to: staticTo, docsPluginId, ...props }) {
    const version = (0,docsUtils/* .useDocsVersionCandidates */.Vd)(docsPluginId)[0];
    const label = staticLabel ?? version.label;
    const path = staticTo ?? getVersionMainDoc(version).path;
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(DefaultNavbarItem, {
        ...props,
        label: label,
        to: path
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/plugin-content-docs/lib/client/docsPreferredVersion.js
var docsPreferredVersion = __webpack_require__(42086);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/DocsVersionDropdownNavbarItem.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 






function getVersionItems(versions, configs) {
    if (configs) {
        // Collect all the versions we have
        const versionMap = new Map(versions.map((version)=>[
                version.name,
                version
            ]));
        const toVersionItem = (name, config)=>{
            const version = versionMap.get(name);
            if (!version) {
                throw new Error(`No docs version exist for name '${name}', please verify your 'docsVersionDropdown' navbar item versions config.
Available version names:\n- ${versions.map((v)=>`${v.name}`).join('\n- ')}`);
            }
            return {
                version,
                label: config?.label ?? version.label
            };
        };
        if (Array.isArray(configs)) {
            return configs.map((name)=>toVersionItem(name, undefined));
        } else {
            return Object.entries(configs).map(([name, config])=>toVersionItem(name, config));
        }
    } else {
        return versions.map((version)=>({
                version,
                label: version.label
            }));
    }
}
function useVersionItems({ docsPluginId, configs }) {
    const versions = (0,lib_client/* .useVersions */.jh)(docsPluginId);
    return getVersionItems(versions, configs);
}
function DocsVersionDropdownNavbarItem_getVersionMainDoc(version) {
    return version.docs.find((doc)=>doc.id === version.mainDocId);
}
function getVersionTargetDoc(version, activeDocContext) {
    // We try to link to the same doc, in another version
    // When not possible, fallback to the "main doc" of the version
    return activeDocContext.alternateDocVersions[version.name] ?? DocsVersionDropdownNavbarItem_getVersionMainDoc(version);
}
// The version item to use for the "dropdown button"
function useDisplayedVersionItem({ docsPluginId, versionItems }) {
    // The order of the candidates matters!
    const candidates = (0,docsUtils/* .useDocsVersionCandidates */.Vd)(docsPluginId);
    const candidateItems = candidates.map((candidate)=>versionItems.find((vi)=>vi.version === candidate)).filter((vi)=>vi !== undefined);
    return candidateItems[0] ?? versionItems[0];
}
function DocsVersionDropdownNavbarItem({ mobile, docsPluginId, dropdownActiveClassDisabled, dropdownItemsBefore, dropdownItemsAfter, versions: configs, ...props }) {
    const search = (0,historyUtils/* .useHistorySelector */.Hl)((history)=>history.location.search);
    const hash = (0,historyUtils/* .useHistorySelector */.Hl)((history)=>history.location.hash);
    const activeDocContext = (0,lib_client/* .useActiveDocContext */.zK)(docsPluginId);
    const { savePreferredVersionName } = (0,docsPreferredVersion/* .useDocsPreferredVersion */.g1)(docsPluginId);
    const versionItems = useVersionItems({
        docsPluginId,
        configs
    });
    const displayedVersionItem = useDisplayedVersionItem({
        docsPluginId,
        versionItems
    });
    function versionItemToLink({ version, label }) {
        const targetDoc = getVersionTargetDoc(version, activeDocContext);
        return {
            label,
            // preserve ?search#hash suffix on version switches
            to: `${targetDoc.path}${search}${hash}`,
            isActive: ()=>version === activeDocContext.activeVersion,
            onClick: ()=>savePreferredVersionName(version.name)
        };
    }
    const items = [
        ...dropdownItemsBefore,
        ...versionItems.map(versionItemToLink),
        ...dropdownItemsAfter
    ];
    // Mobile dropdown is handled a bit differently
    const dropdownLabel = mobile && items.length > 1 ? (0,Translate/* .translate */.T)({
        id: 'theme.navbar.mobileVersionsDropdown.label',
        message: 'Versions',
        description: 'The label for the navbar versions dropdown on mobile view'
    }) : displayedVersionItem.label;
    const dropdownTo = mobile && items.length > 1 ? undefined : getVersionTargetDoc(displayedVersionItem.version, activeDocContext).path;
    // We don't want to render a version dropdown with 0 or 1 item. If we build
    // the site with a single docs version (onlyIncludeVersions: ['1.0.0']),
    // We'd rather render a button instead of a dropdown
    if (items.length <= 1) {
        return /*#__PURE__*/ (0,jsx_runtime.jsx)(DefaultNavbarItem, {
            ...props,
            mobile: mobile,
            label: dropdownLabel,
            to: dropdownTo,
            isActive: dropdownActiveClassDisabled ? ()=>false : undefined
        });
    }
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(DropdownNavbarItem, {
        ...props,
        mobile: mobile,
        label: dropdownLabel,
        to: dropdownTo,
        items: items,
        isActive: dropdownActiveClassDisabled ? ()=>false : undefined
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/ComponentTypes.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 








const ComponentTypes = {
    default: DefaultNavbarItem,
    localeDropdown: LocaleDropdownNavbarItem,
    search: SearchNavbarItem,
    dropdown: DropdownNavbarItem,
    html: HtmlNavbarItem,
    doc: DocNavbarItem,
    docSidebar: DocSidebarNavbarItem,
    docsVersion: DocsVersionNavbarItem,
    docsVersionDropdown: DocsVersionDropdownNavbarItem
};
/* export default */ const NavbarItem_ComponentTypes = (ComponentTypes);

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/NavbarItem/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


function normalizeComponentType(type, props) {
    // Backward compatibility: navbar item with no type set
    // but containing dropdown items should use the type "dropdown"
    if (!type || type === 'default') {
        return 'items' in props ? 'dropdown' : 'default';
    }
    return type;
}
function NavbarItem({ type, ...props }) {
    const componentType = normalizeComponentType(type, props);
    const NavbarItemComponent = NavbarItem_ComponentTypes[componentType];
    if (!NavbarItemComponent) {
        throw new Error(`No NavbarItem component found for type "${type}".`);
    }
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarItemComponent, {
        ...props
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/MobileSidebar/PrimaryMenu/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 





function useNavbarItems() {
    // TODO temporary casting until ThemeConfig type is improved
    return (0,useThemeConfig/* .useThemeConfig */.p)().navbar.items;
}
// The primary menu displays the navbar items
function NavbarMobilePrimaryMenu() {
    const mobileSidebar = (0,navbarMobileSidebar/* .useNavbarMobileSidebar */.M)();
    // TODO how can the order be defined for mobile?
    // Should we allow providing a different list of items?
    const items = useNavbarItems();
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("ul", {
        className: "menu__list",
        children: items.map((item, i)=>/*#__PURE__*/ (0,react.createElement)(NavbarItem, {
                mobile: true,
                ...item,
                onClick: ()=>mobileSidebar.toggle(),
                key: i
            }))
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/MobileSidebar/SecondaryMenu/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




function SecondaryMenuBackButton(props) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("button", {
        ...props,
        type: "button",
        className: "clean-btn navbar-sidebar__back",
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(Translate/* ["default"] */.A, {
            id: "theme.navbar.mobileSidebarSecondaryMenu.backButtonLabel",
            description: "The label of the back button to return to main menu, inside the mobile navbar sidebar secondary menu (notably used to display the docs sidebar)",
            children: "← Back to main menu"
        })
    });
}
// The secondary menu slides from the right and shows contextual information
// such as the docs sidebar
function NavbarMobileSidebarSecondaryMenu() {
    const isPrimaryMenuEmpty = (0,useThemeConfig/* .useThemeConfig */.p)().navbar.items.length === 0;
    const secondaryMenu = useNavbarSecondaryMenu();
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
        children: [
            !isPrimaryMenuEmpty && /*#__PURE__*/ (0,jsx_runtime.jsx)(SecondaryMenuBackButton, {
                onClick: ()=>secondaryMenu.hide()
            }),
            secondaryMenu.content
        ]
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/MobileSidebar/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 






function NavbarMobileSidebar() {
    const mobileSidebar = (0,navbarMobileSidebar/* .useNavbarMobileSidebar */.M)();
    useLockBodyScroll(mobileSidebar.shown);
    if (!mobileSidebar.shouldRender) {
        return null;
    }
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarMobileSidebarLayout, {
        header: /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarMobileSidebarHeader, {}),
        primaryMenu: /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarMobilePrimaryMenu, {}),
        secondaryMenu: /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarMobileSidebarSecondaryMenu, {})
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/Layout/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const Layout_styles_module = ({"navbarHideable":"navbarHideable_m1mJ","navbarHidden":"navbarHidden_jGov"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/Layout/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 







function NavbarBackdrop(props) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
        role: "presentation",
        ...props,
        className: (0,clsx/* ["default"] */.A)('navbar-sidebar__backdrop', props.className)
    });
}
function NavbarLayout({ children }) {
    const { navbar: { hideOnScroll, style } } = (0,useThemeConfig/* .useThemeConfig */.p)();
    const mobileSidebar = (0,navbarMobileSidebar/* .useNavbarMobileSidebar */.M)();
    const { navbarRef, isNavbarVisible } = useHideableNavbar(hideOnScroll);
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)("nav", {
        ref: navbarRef,
        "aria-label": (0,Translate/* .translate */.T)({
            id: 'theme.NavBar.navAriaLabel',
            message: 'Main',
            description: 'The ARIA label for the main navigation'
        }),
        className: (0,clsx/* ["default"] */.A)(ThemeClassNames/* .ThemeClassNames.layout.navbar.container */.G.layout.navbar.container, 'navbar', 'navbar--fixed-top', hideOnScroll && [
            Layout_styles_module.navbarHideable,
            !isNavbarVisible && Layout_styles_module.navbarHidden
        ], {
            'navbar--dark': style === 'dark',
            'navbar--primary': style === 'primary',
            'navbar-sidebar--show': mobileSidebar.shown
        }),
        children: [
            children,
            /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarBackdrop, {
                onClick: mobileSidebar.toggle
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarMobileSidebar, {})
        ]
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/utils-common/lib/index.js
var lib = __webpack_require__(5248);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/errorBoundaryUtils.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const errorBoundaryUtils_module = ({"errorBoundaryError":"errorBoundaryError_a6uf","errorBoundaryFallback":"errorBoundaryFallback_VBag"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/errorBoundaryUtils.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




function ErrorBoundaryTryAgainButton(props) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("button", {
        type: "button",
        ...props,
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(Translate/* ["default"] */.A, {
            id: "theme.ErrorPageContent.tryAgain",
            description: "The label of the button to try again rendering when the React error boundary captures an error",
            children: "Try again"
        })
    });
}
// A very simple reusable ErrorBoundary fallback component
function ErrorBoundaryErrorMessageFallback({ error, tryAgain }) {
    return /*#__PURE__*/ _jsxs("div", {
        className: styles.errorBoundaryFallback,
        children: [
            /*#__PURE__*/ _jsx("p", {
                children: error.message
            }),
            /*#__PURE__*/ _jsx(ErrorBoundaryTryAgainButton, {
                onClick: tryAgain
            })
        ]
    });
}
function ErrorBoundaryError({ error }) {
    const causalChain = (0,lib.getErrorCausalChain)(error);
    const fullMessage = causalChain.map((e)=>e.message).join('\n\nCause:\n');
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("p", {
        className: errorBoundaryUtils_module.errorBoundaryError,
        children: fullMessage
    });
}
/**
 * This component is useful to wrap a low-level error into a more meaningful
 * error with extra context, using the ES error-cause feature.
 *
 * <ErrorCauseBoundary
 *   onError={(error) => new Error("extra context message",{cause: error})}
 * >
 *   <RiskyComponent>
 * </ErrorCauseBoundary>
 */ class ErrorCauseBoundary extends react.Component {
    componentDidCatch(error, errorInfo) {
        throw this.props.onError(error, errorInfo);
    }
    render() {
        return this.props.children;
    }
} //# sourceMappingURL=errorBoundaryUtils.js.map

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/navbarUtils.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




const DefaultNavItemPosition = 'right';
/**
 * Split links by left/right. If position is unspecified, fallback to right.
 */ function splitNavbarItems(items) {
    function isLeft(item) {
        return (item.position ?? DefaultNavItemPosition) === 'left';
    }
    const leftItems = items.filter(isLeft);
    const rightItems = items.filter((item)=>!isLeft(item));
    return [
        leftItems,
        rightItems
    ];
}
/**
 * Composes multiple navbar state providers that are mutually dependent and
 * hence can't be re-ordered.
 */ function NavbarProvider({ children }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(navbarSecondaryMenu_content/* .NavbarSecondaryMenuContentProvider */.y_, {
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(navbarMobileSidebar/* .NavbarMobileSidebarProvider */.e, {
            children: /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarSecondaryMenuDisplayProvider, {
                children: children
            })
        })
    });
} //# sourceMappingURL=navbarUtils.js.map

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Icon/Menu/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

function IconMenu({ width = 30, height = 30, className, ...restProps }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("svg", {
        className: className,
        width: width,
        height: height,
        viewBox: "0 0 30 30",
        "aria-hidden": "true",
        ...restProps,
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)("path", {
            stroke: "currentColor",
            strokeLinecap: "round",
            strokeMiterlimit: "10",
            strokeWidth: "2",
            d: "M4 7h22M4 15h22M4 23h22"
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/MobileSidebar/Toggle/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




function MobileSidebarToggle() {
    const { toggle, shown } = (0,navbarMobileSidebar/* .useNavbarMobileSidebar */.M)();
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("button", {
        onClick: toggle,
        "aria-label": (0,Translate/* .translate */.T)({
            id: 'theme.docs.sidebar.toggleSidebarButtonAriaLabel',
            message: 'Toggle navigation bar',
            description: 'The ARIA label for hamburger menu button of mobile navigation'
        }),
        "aria-expanded": shown,
        className: "navbar__toggle clean-btn",
        type: "button",
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(IconMenu, {})
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/Content/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const Navbar_Content_styles_module = ({"colorModeToggle":"colorModeToggle_DEke"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/Content/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 











function Content_useNavbarItems() {
    // TODO temporary casting until ThemeConfig type is improved
    return (0,useThemeConfig/* .useThemeConfig */.p)().navbar.items;
}
function NavbarItems({ items }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
        children: items.map((item, i)=>/*#__PURE__*/ (0,jsx_runtime.jsx)(ErrorCauseBoundary, {
                onError: (error)=>new Error(`A theme navbar item failed to render.
Please double-check the following navbar item (themeConfig.navbar.items) of your Docusaurus config:
${JSON.stringify(item, null, 2)}`, {
                        cause: error
                    }),
                children: /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarItem, {
                    ...item
                })
            }, i))
    });
}
function NavbarContentLayout({ left, right }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
        className: "navbar__inner",
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
                className: (0,clsx/* ["default"] */.A)(ThemeClassNames/* .ThemeClassNames.layout.navbar.containerLeft */.G.layout.navbar.containerLeft, 'navbar__items'),
                children: left
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
                className: (0,clsx/* ["default"] */.A)(ThemeClassNames/* .ThemeClassNames.layout.navbar.containerRight */.G.layout.navbar.containerRight, 'navbar__items navbar__items--right'),
                children: right
            })
        ]
    });
}
function NavbarContent() {
    const mobileSidebar = (0,navbarMobileSidebar/* .useNavbarMobileSidebar */.M)();
    const items = Content_useNavbarItems();
    const [leftItems, rightItems] = splitNavbarItems(items);
    const searchBarItem = items.find((item)=>item.type === 'search');
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarContentLayout, {
        left: // TODO stop hardcoding items?
        /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
            children: [
                !mobileSidebar.disabled && /*#__PURE__*/ (0,jsx_runtime.jsx)(MobileSidebarToggle, {}),
                /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarLogo, {}),
                /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarItems, {
                    items: leftItems
                })
            ]
        }),
        right: // TODO stop hardcoding items?
        // Ask the user to add the respective navbar items => more flexible
        /*#__PURE__*/ (0,jsx_runtime.jsxs)(jsx_runtime.Fragment, {
            children: [
                /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarItems, {
                    items: rightItems
                }),
                /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarColorModeToggle, {
                    className: Navbar_Content_styles_module.colorModeToggle
                }),
                !searchBarItem && /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarSearch, {
                    children: /*#__PURE__*/ (0,jsx_runtime.jsx)(OramaSearchWrapper, {})
                })
            ]
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Navbar/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



function Navbar() {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarLayout, {
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(NavbarContent, {})
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/footerUtils.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ /**
 * A rough duck-typing about whether the `footer.links` is intended to be multi-
 * column.
 */ function isMultiColumnFooterLinks(links) {
    return 'title' in links[0];
} //# sourceMappingURL=footerUtils.js.map

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Footer/LinkItem/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 






function FooterLinkItem({ item }) {
    const { to, href, label, prependBaseUrlToHref, className, ...props } = item;
    const toUrl = (0,useBaseUrl/* ["default"] */.Ay)(to);
    const normalizedHref = (0,useBaseUrl/* ["default"] */.Ay)(href, {
        forcePrependBaseUrl: true
    });
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)(Link/* ["default"] */.A, {
        className: (0,clsx/* ["default"] */.A)('footer__link-item', className),
        ...href ? {
            href: prependBaseUrlToHref ? normalizedHref : href
        } : {
            to: toUrl
        },
        ...props,
        children: [
            label,
            href && !(0,isInternalUrl/* ["default"] */.A)(href) && /*#__PURE__*/ (0,jsx_runtime.jsx)(ExternalLink/* ["default"] */.A, {})
        ]
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Footer/Links/MultiColumn/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




function ColumnLinkItem({ item }) {
    return item.html ? /*#__PURE__*/ (0,jsx_runtime.jsx)("li", {
        className: (0,clsx/* ["default"] */.A)('footer__item', item.className),
        // Developer provided the HTML, so assume it's safe.
        // eslint-disable-next-line react/no-danger
        dangerouslySetInnerHTML: {
            __html: item.html
        }
    }) : /*#__PURE__*/ (0,jsx_runtime.jsx)("li", {
        className: "footer__item",
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(FooterLinkItem, {
            item: item
        })
    }, item.href ?? item.to);
}
function Column({ column }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
        className: (0,clsx/* ["default"] */.A)(ThemeClassNames/* .ThemeClassNames.layout.footer.column */.G.layout.footer.column, 'col footer__col', column.className),
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
                className: "footer__title",
                children: column.title
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)("ul", {
                className: "footer__items clean-list",
                children: column.items.map((item, i)=>/*#__PURE__*/ (0,jsx_runtime.jsx)(ColumnLinkItem, {
                        item: item
                    }, i))
            })
        ]
    });
}
function FooterLinksMultiColumn({ columns }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
        className: "row footer__links",
        children: columns.map((column, i)=>/*#__PURE__*/ (0,jsx_runtime.jsx)(Column, {
                column: column
            }, i))
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Footer/Links/Simple/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



function Separator() {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("span", {
        className: "footer__link-separator",
        children: "\xb7"
    });
}
function SimpleLinkItem({ item }) {
    return item.html ? /*#__PURE__*/ (0,jsx_runtime.jsx)("span", {
        className: (0,clsx/* ["default"] */.A)('footer__link-item', item.className),
        // Developer provided the HTML, so assume it's safe.
        // eslint-disable-next-line react/no-danger
        dangerouslySetInnerHTML: {
            __html: item.html
        }
    }) : /*#__PURE__*/ (0,jsx_runtime.jsx)(FooterLinkItem, {
        item: item
    });
}
function FooterLinksSimple({ links }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
        className: "footer__links text--center",
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
            className: "footer__links",
            children: links.map((item, i)=>/*#__PURE__*/ (0,jsx_runtime.jsxs)(react.Fragment, {
                    children: [
                        /*#__PURE__*/ (0,jsx_runtime.jsx)(SimpleLinkItem, {
                            item: item
                        }),
                        links.length !== i + 1 && /*#__PURE__*/ (0,jsx_runtime.jsx)(Separator, {})
                    ]
                }, i))
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Footer/Links/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




function FooterLinks({ links }) {
    return isMultiColumnFooterLinks(links) ? /*#__PURE__*/ (0,jsx_runtime.jsx)(FooterLinksMultiColumn, {
        columns: links
    }) : /*#__PURE__*/ (0,jsx_runtime.jsx)(FooterLinksSimple, {
        links: links
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/ThemedImage/index.js + 2 modules
var ThemedImage = __webpack_require__(38586);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Footer/Logo/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const Logo_styles_module = ({"footerLogoLink":"footerLogoLink_BH7S"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Footer/Logo/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 






function LogoImage({ logo }) {
    const { withBaseUrl } = (0,useBaseUrl/* .useBaseUrlUtils */.hH)();
    const sources = {
        light: withBaseUrl(logo.src),
        dark: withBaseUrl(logo.srcDark ?? logo.src)
    };
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(ThemedImage/* ["default"] */.A, {
        className: (0,clsx/* ["default"] */.A)('footer__logo', logo.className),
        alt: logo.alt,
        sources: sources,
        width: logo.width,
        height: logo.height,
        style: logo.style
    });
}
function FooterLogo({ logo }) {
    return logo.href ? /*#__PURE__*/ (0,jsx_runtime.jsx)(Link/* ["default"] */.A, {
        href: logo.href,
        className: Logo_styles_module.footerLogoLink,
        target: logo.target,
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(LogoImage, {
            logo: logo
        })
    }) : /*#__PURE__*/ (0,jsx_runtime.jsx)(LogoImage, {
        logo: logo
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Footer/Copyright/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

function FooterCopyright({ copyright }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
        className: "footer__copyright",
        // Developer provided the HTML, so assume it's safe.
        // eslint-disable-next-line react/no-danger
        dangerouslySetInnerHTML: {
            __html: copyright
        }
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Footer/Layout/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



function FooterLayout({ style, links, logo, copyright }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("footer", {
        className: (0,clsx/* ["default"] */.A)(ThemeClassNames/* .ThemeClassNames.layout.footer.container */.G.layout.footer.container, 'footer', {
            'footer--dark': style === 'dark'
        }),
        children: /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
            className: "container container-fluid",
            children: [
                links,
                (logo || copyright) && /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
                    className: "footer__bottom text--center",
                    children: [
                        logo && /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
                            className: "margin-bottom--sm",
                            children: logo
                        }),
                        copyright
                    ]
                })
            ]
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Footer/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 






function Footer() {
    const { footer } = (0,useThemeConfig/* .useThemeConfig */.p)();
    if (!footer) {
        return null;
    }
    const { copyright, links, logo, style } = footer;
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(FooterLayout, {
        style: style,
        links: links && links.length > 0 && /*#__PURE__*/ (0,jsx_runtime.jsx)(FooterLinks, {
            links: links
        }),
        logo: logo && /*#__PURE__*/ (0,jsx_runtime.jsx)(FooterLogo, {
            logo: logo
        }),
        copyright: copyright && /*#__PURE__*/ (0,jsx_runtime.jsx)(FooterCopyright, {
            copyright: copyright
        })
    });
}
/* export default */ const theme_Footer = (/*#__PURE__*/react.memo(Footer));

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Layout/Provider/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




const Provider = (0,reactUtils/* .composeProviders */.fM)([
    contexts_colorMode/* .ColorModeProvider */.a,
    contexts_announcementBar/* .AnnouncementBarProvider */.o,
    scrollUtils/* .ScrollControllerProvider */.Tv,
    docsPreferredVersion/* .DocsPreferredVersionContextProvider */.VQ,
    metadataUtils/* .PluginHtmlClassNameProvider */.Jx,
    NavbarProvider
]);
function LayoutProvider({ children }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(Provider, {
        children: children
    });
}

// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Heading/index.js
var Heading = __webpack_require__(72072);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/ErrorPageContent.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




function ErrorPageContent({ error, tryAgain }) {
    return /*#__PURE__*/ (0,jsx_runtime.jsx)("main", {
        className: "container margin-vert--xl",
        children: /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
            className: "row",
            children: /*#__PURE__*/ (0,jsx_runtime.jsxs)("div", {
                className: "col col--6 col--offset-3",
                children: [
                    /*#__PURE__*/ (0,jsx_runtime.jsx)(Heading/* ["default"] */.A, {
                        as: "h1",
                        className: "hero__title",
                        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(Translate/* ["default"] */.A, {
                            id: "theme.ErrorPageContent.title",
                            description: "The title of the fallback page when the page crashed",
                            children: "This page crashed."
                        })
                    }),
                    /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
                        className: "margin-vert--lg",
                        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(ErrorBoundaryTryAgainButton, {
                            onClick: tryAgain,
                            className: "button button--primary shadow--lw"
                        })
                    }),
                    /*#__PURE__*/ (0,jsx_runtime.jsx)("hr", {}),
                    /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
                        className: "margin-vert--md",
                        children: /*#__PURE__*/ (0,jsx_runtime.jsx)(ErrorBoundaryError, {
                            error: error
                        })
                    })
                ]
            })
        })
    });
}

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Layout/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const theme_Layout_styles_module = ({"mainWrapper":"mainWrapper_z2l0"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Layout/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 












function Layout(props) {
    const { children, noFooter, wrapperClassName, // Not really layout-related, but kept for convenience/retro-compatibility
    title, description } = props;
    (0,useKeyboardNavigation/* .useKeyboardNavigation */.J)();
    return /*#__PURE__*/ (0,jsx_runtime.jsxs)(LayoutProvider, {
        children: [
            /*#__PURE__*/ (0,jsx_runtime.jsx)(metadataUtils/* .PageMetadata */.be, {
                title: title,
                description: description
            }),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(SkipToContent, {}),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(AnnouncementBar, {}),
            /*#__PURE__*/ (0,jsx_runtime.jsx)(Navbar, {}),
            /*#__PURE__*/ (0,jsx_runtime.jsx)("div", {
                id: SkipToContentFallbackId,
                className: (0,clsx/* ["default"] */.A)(ThemeClassNames/* .ThemeClassNames.layout.main.container */.G.layout.main.container, ThemeClassNames/* .ThemeClassNames.wrapper.main */.G.wrapper.main, theme_Layout_styles_module.mainWrapper, wrapperClassName),
                children: /*#__PURE__*/ (0,jsx_runtime.jsx)(ErrorBoundary/* ["default"] */.A, {
                    fallback: (params)=>/*#__PURE__*/ (0,jsx_runtime.jsx)(ErrorPageContent, {
                            ...params
                        }),
                    children: children
                })
            }),
            !noFooter && /*#__PURE__*/ (0,jsx_runtime.jsx)(theme_Footer, {})
        ]
    });
}


}),
85153: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (Logo)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _docusaurus_Link__rspack_import_2 = __webpack_require__(95310);
/* import */ var _docusaurus_useBaseUrl__rspack_import_3 = __webpack_require__(66497);
/* import */ var _docusaurus_useDocusaurusContext__rspack_import_4 = __webpack_require__(10898);
/* import */ var _docusaurus_theme_common__rspack_import_6 = __webpack_require__(61022);
/* import */ var _theme_ThemedImage__rspack_import_5 = __webpack_require__(38586);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 






function LogoThemedImage({ logo, alt, imageClassName }) {
    const sources = {
        light: (0,_docusaurus_useBaseUrl__rspack_import_3/* ["default"] */.Ay)(logo.src),
        dark: (0,_docusaurus_useBaseUrl__rspack_import_3/* ["default"] */.Ay)(logo.srcDark || logo.src)
    };
    const themedImage = /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(_theme_ThemedImage__rspack_import_5/* ["default"] */.A, {
        className: logo.className,
        sources: sources,
        height: logo.height,
        width: logo.width,
        alt: alt,
        style: logo.style
    });
    // Is this extra div really necessary?
    // introduced in https://github.com/facebook/docusaurus/pull/5666
    return imageClassName ? /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("div", {
        className: imageClassName,
        children: themedImage
    }) : themedImage;
}
function Logo(props) {
    const { siteConfig: { title } } = (0,_docusaurus_useDocusaurusContext__rspack_import_4/* ["default"] */.A)();
    const { navbar: { title: navbarTitle, logo } } = (0,_docusaurus_theme_common__rspack_import_6/* .useThemeConfig */.p)();
    const { imageClassName, titleClassName, ...propsRest } = props;
    const logoLink = (0,_docusaurus_useBaseUrl__rspack_import_3/* ["default"] */.Ay)(logo?.href || '/');
    // If visible title is shown, fallback alt text should be
    // an empty string to mark the logo as decorative.
    const fallbackAlt = navbarTitle ? '' : title;
    // Use logo alt text if provided (including empty string),
    // and provide a sensible fallback otherwise.
    const alt = logo?.alt ?? fallbackAlt;
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsxs)(_docusaurus_Link__rspack_import_2/* ["default"] */.A, {
        to: logoLink,
        ...propsRest,
        ...logo?.target && {
            target: logo.target
        },
        children: [
            logo && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(LogoThemedImage, {
                logo: logo,
                alt: alt,
                imageClassName: imageClassName
            }),
            navbarTitle != null && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("b", {
                className: titleClassName,
                children: navbarTitle
            })
        ]
    });
}


}),
54175: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (SearchMetadata)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _docusaurus_Head__rspack_import_2 = __webpack_require__(53572);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


// Note: we bias toward using Algolia metadata on purpose
// Not doing so leads to confusion in the community,
// as it requires to first crawl the site with the Algolia plugin enabled first
// - https://github.com/facebook/docusaurus/issues/6693
// - https://github.com/facebook/docusaurus/issues/4555
function SearchMetadata({ locale, version, tag }) {
    // Seems safe to consider here the locale is the language, as the existing
    // docsearch:language filter is afaik a regular string-based filter
    const language = locale;
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsxs)(_docusaurus_Head__rspack_import_2/* ["default"] */.A, {
        children: [
            locale && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("meta", {
                name: "docusaurus_locale",
                content: locale
            }),
            version && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("meta", {
                name: "docusaurus_version",
                content: version
            }),
            tag && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("meta", {
                name: "docusaurus_tag",
                content: tag
            }),
            language && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("meta", {
                name: "docsearch:language",
                content: language
            }),
            version && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("meta", {
                name: "docsearch:version",
                content: version
            }),
            tag && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("meta", {
                name: "docsearch:docusaurus_tag",
                content: tag
            })
        ]
    });
}


}),
38586: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ ThemedImage)
});

// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
var jsx_runtime = __webpack_require__(74848);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
// EXTERNAL MODULE: ./node_modules/clsx/dist/clsx.mjs
var clsx = __webpack_require__(34164);
// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/useIsBrowser.js
var useIsBrowser = __webpack_require__(19863);
// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/contexts/colorMode.js
var contexts_colorMode = __webpack_require__(83941);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/components/ThemedComponent/styles.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const styles_module = ({"themedComponent":"themedComponent_mlkZ","themedComponent--light":"themedComponent--light_NVdE","themedComponent--dark":"themedComponent--dark_xIcU"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/components/ThemedComponent/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 





const AllThemes = (/* unused pure expression or super */ null && ([
    'light',
    'dark'
]));
/**
 * Generic component to render anything themed in light/dark
 * Note: it's preferable to use CSS for theming because this component
 * will need to render all the variants during SSR to avoid a theme flash.
 *
 * Use this only when CSS customizations are not convenient or impossible.
 * For example, rendering themed images or SVGs...
 *
 * @param className applied to all the variants
 * @param children function to render a theme variant
 * @constructor
 */ function ThemedComponent({ className, children }) {
    const isBrowser = (0,useIsBrowser/* ["default"] */.A)();
    const { colorMode } = (0,contexts_colorMode/* .useColorMode */.G)();
    function getThemesToRender() {
        if (isBrowser) {
            return colorMode === 'dark' ? [
                'dark'
            ] : [
                'light'
            ];
        }
        // We need to render both components on the server / hydration to avoid:
        // - a flash of wrong theme before hydration
        // - React hydration mismatches
        // See https://github.com/facebook/docusaurus/pull/3730
        return [
            'light',
            'dark'
        ];
    }
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(jsx_runtime.Fragment, {
        children: getThemesToRender().map((theme)=>{
            const themedElement = children({
                theme,
                className: (0,clsx/* ["default"] */.A)(className, styles_module.themedComponent, styles_module[`themedComponent--${theme}`])
            });
            return /*#__PURE__*/ (0,jsx_runtime.jsx)(react.Fragment, {
                children: themedElement
            }, theme);
        })
    });
} //# sourceMappingURL=index.js.map

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/ThemedImage/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


function ThemedImage(props) {
    const { sources, className: parentClassName, alt, ...propsRest } = props;
    return /*#__PURE__*/ (0,jsx_runtime.jsx)(ThemedComponent, {
        className: parentClassName,
        children: ({ theme, className })=>/*#__PURE__*/ (0,jsx_runtime.jsx)("img", {
                src: sources[theme],
                alt: alt,
                className: className,
                ...propsRest
            })
    });
}


}),
39510: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  N: () => (Collapsible),
  u: () => (useCollapsible)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _docusaurus_useIsomorphicLayoutEffect__rspack_import_2 = __webpack_require__(99989);
/* import */ var _utils_accessibilityUtils__rspack_import_3 = __webpack_require__(269);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 



const DefaultAnimationEasing = 'ease-in-out';
/**
 * This hook is a very thin wrapper around a `useState`.
 */ function useCollapsible({ initialState }) {
    const [collapsed, setCollapsed] = (0,react__rspack_import_1.useState)(initialState ?? false);
    const toggleCollapsed = (0,react__rspack_import_1.useCallback)(()=>{
        setCollapsed((expanded)=>!expanded);
    }, []);
    return {
        collapsed,
        setCollapsed,
        toggleCollapsed
    };
}
const CollapsedStyles = {
    display: 'none',
    overflow: 'hidden',
    height: '0px'
};
const ExpandedStyles = {
    display: 'block',
    overflow: 'visible',
    height: 'auto'
};
function applyCollapsedStyle(el, collapsed) {
    const collapsedStyles = collapsed ? CollapsedStyles : ExpandedStyles;
    el.style.display = collapsedStyles.display;
    el.style.overflow = collapsedStyles.overflow;
    el.style.height = collapsedStyles.height;
}
/*
Lex111: Dynamic transition duration is used in Material design, this technique
is good for a large number of items.
https://material.io/archive/guidelines/motion/duration-easing.html#duration-easing-dynamic-durations
https://github.com/mui-org/material-ui/blob/e724d98eba018e55e1a684236a2037e24bcf050c/packages/material-ui/src/styles/createTransitions.js#L40-L43
 */ function getAutoHeightDuration(height) {
    if ((0,_utils_accessibilityUtils__rspack_import_3/* .prefersReducedMotion */.O)()) {
        // Not using 0 because it prevents onTransitionEnd to fire and bubble up :/
        // See https://github.com/facebook/docusaurus/pull/8906
        return 1;
    }
    const constant = height / 36;
    return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
}
function useCollapseAnimation({ collapsibleRef, collapsed, animation }) {
    const mounted = (0,react__rspack_import_1.useRef)(false);
    (0,react__rspack_import_1.useEffect)(()=>{
        const el = collapsibleRef.current;
        function getTransitionStyles() {
            const height = el.scrollHeight;
            const duration = animation?.duration ?? getAutoHeightDuration(height);
            const easing = animation?.easing ?? DefaultAnimationEasing;
            return {
                transition: `height ${duration}ms ${easing}`,
                height: `${height}px`
            };
        }
        function applyTransitionStyles() {
            const transitionStyles = getTransitionStyles();
            el.style.transition = transitionStyles.transition;
            el.style.height = transitionStyles.height;
        }
        // On mount, we just apply styles, no animated transition
        if (!mounted.current) {
            applyCollapsedStyle(el, collapsed);
            mounted.current = true;
            return undefined;
        }
        // eslint-disable-next-line react-compiler/react-compiler
        el.style.willChange = 'height';
        function startAnimation() {
            const animationFrame = requestAnimationFrame(()=>{
                // When collapsing
                if (collapsed) {
                    applyTransitionStyles();
                    requestAnimationFrame(()=>{
                        el.style.height = CollapsedStyles.height;
                        el.style.overflow = CollapsedStyles.overflow;
                    });
                } else {
                    el.style.display = 'block';
                    requestAnimationFrame(()=>{
                        applyTransitionStyles();
                    });
                }
            });
            return ()=>cancelAnimationFrame(animationFrame);
        }
        return startAnimation();
    }, [
        collapsibleRef,
        collapsed,
        animation
    ]);
}
function CollapsibleBase({ as: As = 'div', collapsed, children, animation, onCollapseTransitionEnd, className }) {
    const collapsibleRef = (0,react__rspack_import_1.useRef)(null);
    useCollapseAnimation({
        collapsibleRef,
        collapsed,
        animation
    });
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(As, {
        // @ts-expect-error: the "too complicated type" is produced from
        // "CollapsibleElementType" being a huge union
        ref: collapsibleRef,
        onTransitionEnd: (e)=>{
            if (e.propertyName !== 'height') {
                return;
            }
            applyCollapsedStyle(collapsibleRef.current, collapsed);
            onCollapseTransitionEnd?.(collapsed);
        },
        className: className,
        children: children
    });
}
function CollapsibleLazy({ collapsed, ...props }) {
    const [mounted, setMounted] = (0,react__rspack_import_1.useState)(!collapsed);
    // Updated in effect so that first expansion transition can work
    const [lazyCollapsed, setLazyCollapsed] = (0,react__rspack_import_1.useState)(collapsed);
    (0,_docusaurus_useIsomorphicLayoutEffect__rspack_import_2/* ["default"] */.A)(()=>{
        if (!collapsed) {
            setMounted(true);
        }
    }, [
        collapsed
    ]);
    (0,_docusaurus_useIsomorphicLayoutEffect__rspack_import_2/* ["default"] */.A)(()=>{
        if (mounted) {
            setLazyCollapsed(collapsed);
        }
    }, [
        mounted,
        collapsed
    ]);
    return mounted ? /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(CollapsibleBase, {
        ...props,
        collapsed: lazyCollapsed
    }) : null;
}
/**
 * A headless component providing smooth and uniform collapsing behavior. The
 * component will be invisible (zero height) when collapsed. Doesn't provide
 * interactivity by itself: collapse state is toggled through props.
 */ function Collapsible({ lazy, ...props }) {
    const Comp = lazy ? CollapsibleLazy : CollapsibleBase;
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(Comp, {
        ...props
    });
} //# sourceMappingURL=index.js.map


}),
63337: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  M: () => (useAnnouncementBar),
  o: () => (AnnouncementBarProvider)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _docusaurus_useIsBrowser__rspack_import_2 = __webpack_require__(19863);
/* import */ var _utils_storageUtils__rspack_import_3 = __webpack_require__(41367);
/* import */ var _utils_reactUtils__rspack_import_5 = __webpack_require__(52260);
/* import */ var _utils_useThemeConfig__rspack_import_4 = __webpack_require__(61022);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 





// Keep these keys in sync with the inlined script
// See packages/docusaurus-theme-classic/src/inlineScripts.ts
const AnnouncementBarDismissStorage = (0,_utils_storageUtils__rspack_import_3/* .createStorageSlot */.Wf)('docusaurus.announcement.dismiss');
const IdStorage = (0,_utils_storageUtils__rspack_import_3/* .createStorageSlot */.Wf)('docusaurus.announcement.id');
const isDismissedInStorage = ()=>AnnouncementBarDismissStorage.get() === 'true';
const setDismissedInStorage = (bool)=>AnnouncementBarDismissStorage.set(String(bool));
const Context = /*#__PURE__*/ react__rspack_import_1.createContext(null);
function useContextValue() {
    const { announcementBar } = (0,_utils_useThemeConfig__rspack_import_4/* .useThemeConfig */.p)();
    const isBrowser = (0,_docusaurus_useIsBrowser__rspack_import_2/* ["default"] */.A)();
    const [isClosed, setClosed] = (0,react__rspack_import_1.useState)(()=>isBrowser ? isDismissedInStorage() : false);
    // Update state after hydration
    (0,react__rspack_import_1.useEffect)(()=>{
        setClosed(isDismissedInStorage());
    }, []);
    const handleClose = (0,react__rspack_import_1.useCallback)(()=>{
        setDismissedInStorage(true);
        setClosed(true);
    }, []);
    (0,react__rspack_import_1.useEffect)(()=>{
        if (!announcementBar) {
            return;
        }
        const { id } = announcementBar;
        let viewedId = IdStorage.get();
        // Retrocompatibility due to spelling mistake of default id
        // see https://github.com/facebook/docusaurus/issues/3338
        // cSpell:ignore annoucement
        if (viewedId === 'annoucement-bar') {
            viewedId = 'announcement-bar';
        }
        const isNewAnnouncement = id !== viewedId;
        IdStorage.set(id);
        if (isNewAnnouncement) {
            setDismissedInStorage(false);
        }
        if (isNewAnnouncement || !isDismissedInStorage()) {
            setClosed(false);
        }
    }, [
        announcementBar
    ]);
    return (0,react__rspack_import_1.useMemo)(()=>({
            isActive: !!announcementBar && !isClosed,
            close: handleClose
        }), [
        announcementBar,
        isClosed,
        handleClose
    ]);
}
function AnnouncementBarProvider({ children }) {
    const value = useContextValue();
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(Context.Provider, {
        value: value,
        children: children
    });
}
function useAnnouncementBar() {
    const api = (0,react__rspack_import_1.useContext)(Context);
    if (!api) {
        throw new _utils_reactUtils__rspack_import_5/* .ReactContextError */.dV('AnnouncementBarProvider');
    }
    return api;
} //# sourceMappingURL=announcementBar.js.map


}),
83941: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  G: () => (useColorMode),
  a: () => (ColorModeProvider)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _docusaurus_useIsBrowser__rspack_import_2 = __webpack_require__(19863);
/* import */ var _utils_reactUtils__rspack_import_5 = __webpack_require__(52260);
/* import */ var _utils_storageUtils__rspack_import_3 = __webpack_require__(41367);
/* import */ var _utils_useThemeConfig__rspack_import_4 = __webpack_require__(61022);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 





function getSystemColorMode() {
    return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
}
function subscribeToMedia(query, listener) {
    const mql = window.matchMedia(query);
    mql.addEventListener('change', listener);
    return ()=>mql.removeEventListener('change', listener);
}
function subscribeToSystemColorModeChange(onChange) {
    return subscribeToMedia('(prefers-color-scheme: dark)', ()=>onChange(getSystemColorMode()));
}
const Context = /*#__PURE__*/ react__rspack_import_1.createContext(undefined);
const ColorModeStorageKey = 'theme';
const ColorModeStorage = (0,_utils_storageUtils__rspack_import_3/* .createStorageSlot */.Wf)(ColorModeStorageKey);
// We use data-theme-choice="system", not an absent attribute
// This is easier to handle for users with CSS
const SystemAttribute = 'system';
// Ensure to always return a valid colorMode even if input is invalid
const coerceToColorMode = (colorMode)=>colorMode === 'dark' ? 'dark' : 'light';
const coerceToColorModeChoice = (colorMode)=>colorMode === null || colorMode === SystemAttribute ? null : coerceToColorMode(colorMode);
const ColorModeAttribute = {
    get: ()=>{
        return coerceToColorMode(document.documentElement.getAttribute('data-theme'));
    },
    set: (colorMode)=>{
        document.documentElement.setAttribute('data-theme', coerceToColorMode(colorMode));
    }
};
const ColorModeChoiceAttribute = {
    get: ()=>{
        return coerceToColorModeChoice(document.documentElement.getAttribute('data-theme-choice'));
    },
    set: (colorMode)=>{
        document.documentElement.setAttribute('data-theme-choice', coerceToColorModeChoice(colorMode) ?? SystemAttribute);
    }
};
const persistColorModeChoice = (newColorMode)=>{
    if (newColorMode === null) {
        ColorModeStorage.del();
    } else {
        ColorModeStorage.set(coerceToColorMode(newColorMode));
    }
};
// The color mode state is initialized in useEffect on purpose
// to avoid a React hydration mismatch errors
// The useColorMode() hook value lags behind on purpose
// This helps users avoid hydration mismatch errors in their code
// See also https://github.com/facebook/docusaurus/issues/7986
function useColorModeState() {
    const { colorMode: { defaultMode } } = (0,_utils_useThemeConfig__rspack_import_4/* .useThemeConfig */.p)();
    const isBrowser = (0,_docusaurus_useIsBrowser__rspack_import_2/* ["default"] */.A)();
    // Since the provider may unmount/remount on client navigation, we need to
    // reinitialize the state with the correct values to avoid visual glitches.
    // See also https://github.com/facebook/docusaurus/issues/11399#issuecomment-3279181314
    const [colorMode, setColorModeState] = (0,react__rspack_import_1.useState)(isBrowser ? ColorModeAttribute.get() : defaultMode);
    const [colorModeChoice, setColorModeChoiceState] = (0,react__rspack_import_1.useState)(isBrowser ? ColorModeChoiceAttribute.get() : null);
    (0,react__rspack_import_1.useEffect)(()=>{
        setColorModeState(ColorModeAttribute.get());
        setColorModeChoiceState(ColorModeChoiceAttribute.get());
    }, []);
    return {
        colorMode,
        setColorModeState,
        colorModeChoice,
        setColorModeChoiceState
    };
}
function useContextValue() {
    const { colorMode: { defaultMode, disableSwitch, respectPrefersColorScheme } } = (0,_utils_useThemeConfig__rspack_import_4/* .useThemeConfig */.p)();
    const { colorMode, setColorModeState, colorModeChoice, setColorModeChoiceState } = useColorModeState();
    (0,react__rspack_import_1.useEffect)(()=>{
        // A site is deployed without disableSwitch
        // => User visits the site and has a persisted value
        // => Site later enabled disableSwitch
        // => Clear the previously stored value to apply the site's setting
        if (disableSwitch) {
            ColorModeStorage.del();
        }
    }, [
        disableSwitch
    ]);
    const setColorMode = (0,react__rspack_import_1.useCallback)((newColorModeChoice, options = {})=>{
        const { persist = true } = options;
        // Reset to system/default color mode
        if (newColorModeChoice === null) {
            // Set the effective color
            const newColorMode = respectPrefersColorScheme ? getSystemColorMode() : defaultMode;
            ColorModeAttribute.set(newColorMode);
            setColorModeState(newColorMode);
            // Set the chosen color
            ColorModeChoiceAttribute.set(null);
            setColorModeChoiceState(null);
        } else {
            ColorModeAttribute.set(newColorModeChoice);
            ColorModeChoiceAttribute.set(newColorModeChoice);
            setColorModeState(newColorModeChoice);
            setColorModeChoiceState(newColorModeChoice);
        }
        if (persist) {
            persistColorModeChoice(newColorModeChoice);
        }
    }, [
        setColorModeState,
        setColorModeChoiceState,
        respectPrefersColorScheme,
        defaultMode
    ]);
    // Synchronize theme color/choice mode with browser storage
    (0,react__rspack_import_1.useEffect)(()=>{
        return ColorModeStorage.listen((e)=>{
            setColorMode(coerceToColorModeChoice(e.newValue));
        });
    }, [
        setColorMode
    ]);
    // Synchronize theme color with system color
    (0,react__rspack_import_1.useEffect)(()=>{
        if (colorModeChoice !== null || !respectPrefersColorScheme) {
            return undefined;
        }
        return subscribeToSystemColorModeChange((newSystemColorMode)=>{
            // Note: we don't use "setColorMode" on purpose
            // The system changes should never be considered an explicit theme choice
            // They only affect the "effective" color, and should never be persisted
            // Note: this listener also fire when printing, see https://github.com/facebook/docusaurus/pull/6490
            setColorModeState(newSystemColorMode);
            ColorModeAttribute.set(newSystemColorMode);
        });
    }, [
        respectPrefersColorScheme,
        colorModeChoice,
        setColorModeState
    ]);
    return (0,react__rspack_import_1.useMemo)(()=>({
            colorMode,
            colorModeChoice,
            setColorMode,
            get isDarkTheme () {
                if (false) {}
                return colorMode === 'dark';
            },
            setLightTheme () {
                if (false) {}
                setColorMode('light');
            },
            setDarkTheme () {
                if (false) {}
                setColorMode('dark');
            }
        }), [
        colorMode,
        colorModeChoice,
        setColorMode
    ]);
}
function ColorModeProvider({ children }) {
    const value = useContextValue();
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(Context.Provider, {
        value: value,
        children: children
    });
}
function useColorMode() {
    const context = (0,react__rspack_import_1.useContext)(Context);
    if (context == null) {
        throw new _utils_reactUtils__rspack_import_5/* .ReactContextError */.dV('ColorModeProvider', 'Please see https://docusaurus.io/docs/api/themes/configuration#use-color-mode.');
    }
    return context;
} //# sourceMappingURL=colorMode.js.map


}),
29965: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  M: () => (useNavbarMobileSidebar),
  e: () => (NavbarMobileSidebarProvider)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _navbarSecondaryMenu_content__rspack_import_2 = __webpack_require__(17000);
/* import */ var _hooks_useWindowSize__rspack_import_4 = __webpack_require__(53741);
/* import */ var _utils_historyUtils__rspack_import_5 = __webpack_require__(96629);
/* import */ var _utils_useThemeConfig__rspack_import_3 = __webpack_require__(61022);
/* import */ var _utils_reactUtils__rspack_import_6 = __webpack_require__(52260);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 






const Context = /*#__PURE__*/ react__rspack_import_1.createContext(undefined);
function useIsNavbarMobileSidebarDisabled() {
    const secondaryMenuContent = (0,_navbarSecondaryMenu_content__rspack_import_2/* .useNavbarSecondaryMenuContent */.YL)();
    const { items } = (0,_utils_useThemeConfig__rspack_import_3/* .useThemeConfig */.p)().navbar;
    return items.length === 0 && !secondaryMenuContent.component;
}
function useContextValue() {
    const disabled = useIsNavbarMobileSidebarDisabled();
    const windowSize = (0,_hooks_useWindowSize__rspack_import_4/* .useWindowSize */.l)();
    const shouldRender = !disabled && windowSize === 'mobile';
    const [shown, setShown] = (0,react__rspack_import_1.useState)(false);
    const toggle = (0,react__rspack_import_1.useCallback)(()=>{
        setShown((s)=>!s);
    }, []);
    (0,react__rspack_import_1.useEffect)(()=>{
        if (windowSize === 'desktop') {
            setShown(false);
        }
    }, [
        windowSize
    ]);
    return (0,react__rspack_import_1.useMemo)(()=>({
            disabled,
            shouldRender,
            toggle,
            shown
        }), [
        disabled,
        shouldRender,
        toggle,
        shown
    ]);
}
// A component hook wrapper enables conditional rendering
// See reason here: https://github.com/facebook/docusaurus/issues/10988
function OnHistoryPop({ handler }) {
    (0,_utils_historyUtils__rspack_import_5/* .useHistoryPopHandler */.$Z)(handler);
    return null;
}
function NavbarMobileSidebarProvider({ children }) {
    const value = useContextValue();
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsxs)(react_jsx_runtime__rspack_import_0.Fragment, {
        children: [
            // Close mobile sidebar on navigation pop
            // Most likely firing when using the Android back button (but not only)
            // Important: we can only have a single history blocker at a time
            // That's why this needs to be rendered conditionally
            // See bug report https://github.com/facebook/docusaurus/issues/10988
            value.shown && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(OnHistoryPop, {
                handler: ()=>{
                    value.toggle();
                    // Prevent pop navigation; seems desirable enough
                    // See https://github.com/facebook/docusaurus/pull/5462#issuecomment-911699846
                    return false;
                }
            }),
            /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(Context.Provider, {
                value: value,
                children: children
            })
        ]
    });
}
function useNavbarMobileSidebar() {
    const context = react__rspack_import_1.useContext(Context);
    if (context === undefined) {
        throw new _utils_reactUtils__rspack_import_6/* .ReactContextError */.dV('NavbarMobileSidebarProvider');
    }
    return context;
} //# sourceMappingURL=navbarMobileSidebar.js.map


}),
17000: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  GX: () => (NavbarSecondaryMenuFiller),
  YL: () => (useNavbarSecondaryMenuContent),
  y_: () => (NavbarSecondaryMenuContentProvider)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _utils_reactUtils__rspack_import_2 = __webpack_require__(52260);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


const Context = /*#__PURE__*/ react__rspack_import_1.createContext(null);
/** @internal */ function NavbarSecondaryMenuContentProvider({ children }) {
    const value = (0,react__rspack_import_1.useState)({
        component: null,
        props: null
    });
    return(// @ts-expect-error: this context is hard to type
    /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(Context.Provider, {
        value: value,
        children: children
    }));
}
/** @internal */ function useNavbarSecondaryMenuContent() {
    const value = (0,react__rspack_import_1.useContext)(Context);
    if (!value) {
        throw new _utils_reactUtils__rspack_import_2/* .ReactContextError */.dV('NavbarSecondaryMenuContentProvider');
    }
    return value[0];
}
/**
 * This component renders nothing by itself, but it fills the placeholder in the
 * generic secondary menu layout. This reduces coupling between the main layout
 * and the specific page.
 *
 * This kind of feature is often called portal/teleport/gateway/outlet...
 * Various unmaintained React libs exist. Most up-to-date one:
 * https://github.com/gregberge/react-teleporter
 * Not sure any of those is safe regarding concurrent mode.
 */ function NavbarSecondaryMenuFiller({ component, props }) {
    const context = (0,react__rspack_import_1.useContext)(Context);
    if (!context) {
        throw new _utils_reactUtils__rspack_import_2/* .ReactContextError */.dV('NavbarSecondaryMenuContentProvider');
    }
    const [, setContent] = context;
    // To avoid useless context re-renders, props are memoized shallowly
    const memoizedProps = (0,_utils_reactUtils__rspack_import_2/* .useShallowMemoObject */.Be)(props);
    (0,react__rspack_import_1.useEffect)(()=>{
        // @ts-expect-error: this context is hard to type
        setContent({
            component,
            props: memoizedProps
        });
    }, [
        setContent,
        component,
        memoizedProps
    ]);
    (0,react__rspack_import_1.useEffect)(()=>()=>setContent({
                component: null,
                props: null
            }), [
        setContent
    ]);
    return null;
} //# sourceMappingURL=content.js.map


}),
23433: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  w: () => (/* binding */ keyboardFocusedClassName),
  J: () => (/* binding */ useKeyboardNavigation)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/hooks/styles.css
// extracted by css-extract-rspack-plugin

;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/hooks/useKeyboardNavigation.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

const keyboardFocusedClassName = 'navigation-with-keyboard';
/**
 * Side-effect that adds the `keyboardFocusedClassName` to the body element when
 * the keyboard has been pressed, or removes it when the mouse is clicked.
 *
 * The presence of this class name signals that the user may be using keyboard
 * for navigation, and the theme **must** add focus outline when this class name
 * is present. (And optionally not if it's absent, for design purposes)
 *
 * Inspired by https://hackernoon.com/removing-that-ugly-focus-ring-and-keeping-it-too-6c8727fefcd2
 */ function useKeyboardNavigation() {
    (0,react.useEffect)(()=>{
        function handleOutlineStyles(e) {
            if (e.type === 'keydown' && e.key === 'Tab') {
                document.body.classList.add(keyboardFocusedClassName);
            }
            if (e.type === 'mousedown') {
                document.body.classList.remove(keyboardFocusedClassName);
            }
        }
        document.addEventListener('keydown', handleOutlineStyles);
        document.addEventListener('mousedown', handleOutlineStyles);
        return ()=>{
            document.body.classList.remove(keyboardFocusedClassName);
            document.removeEventListener('keydown', handleOutlineStyles);
            document.removeEventListener('mousedown', handleOutlineStyles);
        };
    }, []);
} //# sourceMappingURL=useKeyboardNavigation.js.map


}),
53741: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  l: () => (useWindowSize)
});
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var _docusaurus_ExecutionEnvironment__rspack_import_1 = __webpack_require__(91289);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

const windowSizes = {
    desktop: 'desktop',
    mobile: 'mobile',
    ssr: 'ssr'
};
// Note: this value is also hardcoded in Infima
// Both JS and CSS must have the same value
// Updating this JS value alone is not enough
// See https://github.com/facebook/docusaurus/issues/9603
const DesktopBreakpoint = 996;
function getWindowSize(desktopBreakpoint) {
    if (!_docusaurus_ExecutionEnvironment__rspack_import_1["default"].canUseDOM) {
        throw new Error('getWindowSize() should only be called after React hydration');
    }
    return window.innerWidth > desktopBreakpoint ? windowSizes.desktop : windowSizes.mobile;
}
/**
 * Gets the current window size as an enum value. We don't want it to return the
 * actual width value, so that it only re-renders once a breakpoint is crossed.
 *
 * It may return `"ssr"`, which is very important to handle hydration FOUC or
 * layout shifts. You have to handle it explicitly upfront. On the server, you
 * may need to render BOTH the mobile/desktop elements (and hide one of them
 * with mediaquery). We don't return `undefined` on purpose, to make it more
 * explicit.
 */ function useWindowSize({ desktopBreakpoint = DesktopBreakpoint } = {}) {
    const [windowSize, setWindowSize] = (0,react__rspack_import_0.useState)(()=>// super important to return a constant value to avoid hydration mismatch
        // see https://github.com/facebook/docusaurus/issues/9379
        'ssr');
    (0,react__rspack_import_0.useEffect)(()=>{
        function updateWindowSize() {
            setWindowSize(getWindowSize(desktopBreakpoint));
        }
        updateWindowSize();
        window.addEventListener('resize', updateWindowSize);
        return ()=>{
            window.removeEventListener('resize', updateWindowSize);
        };
    }, [
        desktopBreakpoint
    ]);
    return windowSize;
} //# sourceMappingURL=useWindowSize.js.map


}),
88287: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  G: () => (ThemeClassNames)
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ // Please do not modify the classnames! This is a breaking change, and annoying
// for users!
/**
 * These class names are used to style page layouts in Docusaurus, meant to be
 * targeted by user-provided custom CSS selectors.
 */ const ThemeClassNames = {
    page: {
        blogListPage: 'blog-list-page',
        blogPostPage: 'blog-post-page',
        blogTagsListPage: 'blog-tags-list-page',
        blogTagPostListPage: 'blog-tags-post-list-page',
        blogAuthorsListPage: 'blog-authors-list-page',
        blogAuthorsPostsPage: 'blog-authors-posts-page',
        docsDocPage: 'docs-doc-page',
        docsTagsListPage: 'docs-tags-list-page',
        docsTagDocListPage: 'docs-tags-doc-list-page',
        mdxPage: 'mdx-page'
    },
    // TODO Docusaurus v4: remove old classes?
    wrapper: {
        main: 'main-wrapper',
        // TODO these wrapper class names are now quite useless
        // TODO do breaking change later in 3.0
        // we already add plugin name/id class on <html>: that's enough
        blogPages: 'blog-wrapper',
        docsPages: 'docs-wrapper',
        mdxPages: 'mdx-wrapper'
    },
    common: {
        editThisPage: 'theme-edit-this-page',
        lastUpdated: 'theme-last-updated',
        backToTopButton: 'theme-back-to-top-button',
        codeBlock: 'theme-code-block',
        admonition: 'theme-admonition',
        unlistedBanner: 'theme-unlisted-banner',
        draftBanner: 'theme-draft-banner',
        admonitionType: (type)=>`theme-admonition-${type}`
    },
    announcementBar: {
        container: 'theme-announcement-bar'
    },
    tabs: {
        container: 'theme-tabs-container'
    },
    layout: {
        navbar: {
            container: 'theme-layout-navbar',
            containerLeft: 'theme-layout-navbar-left',
            containerRight: 'theme-layout-navbar-right',
            mobileSidebar: {
                container: 'theme-layout-navbar-sidebar',
                panel: 'theme-layout-navbar-sidebar-panel'
            }
        },
        main: {
            container: 'theme-layout-main'
        },
        footer: {
            container: 'theme-layout-footer',
            column: 'theme-layout-footer-column'
        }
    },
    /**
     * Follows the naming convention "theme-{blog,doc,version,page}?-<suffix>"
     */ docs: {
        docVersionBanner: 'theme-doc-version-banner',
        docVersionBadge: 'theme-doc-version-badge',
        docBreadcrumbs: 'theme-doc-breadcrumbs',
        docMarkdown: 'theme-doc-markdown',
        docTocMobile: 'theme-doc-toc-mobile',
        docTocDesktop: 'theme-doc-toc-desktop',
        docFooter: 'theme-doc-footer',
        docFooterTagsRow: 'theme-doc-footer-tags-row',
        docFooterEditMetaRow: 'theme-doc-footer-edit-meta-row',
        docSidebarContainer: 'theme-doc-sidebar-container',
        docSidebarMenu: 'theme-doc-sidebar-menu',
        docSidebarItemCategory: 'theme-doc-sidebar-item-category',
        docSidebarItemLink: 'theme-doc-sidebar-item-link',
        docSidebarItemCategoryLevel: (level)=>`theme-doc-sidebar-item-category-level-${level}`,
        docSidebarItemLinkLevel: (level)=>`theme-doc-sidebar-item-link-level-${level}`
    },
    blog: {
        // TODO add other stable classNames here
        blogFooterTagsRow: 'theme-blog-footer-tags-row',
        blogFooterEditMetaRow: 'theme-blog-footer-edit-meta-row'
    },
    pages: {
        pageFooterEditMetaRow: 'theme-pages-footer-edit-meta-row'
    }
}; //# sourceMappingURL=ThemeClassNames.js.map


}),
269: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  O: () => (prefersReducedMotion)
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ function prefersReducedMotion() {
    return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
} //# sourceMappingURL=accessibilityUtils.js.map


}),
34727: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  v: () => (/* binding */ useAnchorTargetClassName)
});

// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/useThemeConfig.js
var useThemeConfig = __webpack_require__(61022);
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/anchorUtils.module.css
// extracted by css-extract-rspack-plugin
/* export default */ const anchorUtils_module = ({"anchorTargetStickyNavbar":"anchorTargetStickyNavbar_Vzrq","anchorTargetHideOnScrollNavbar":"anchorTargetHideOnScrollNavbar_vjPI"});
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/anchorUtils.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

/**
 * When the navbar is sticky, this ensures that when clicking a hash link,
 * we do not navigate to an anchor that will appear below the navbar.
 * This happens in particular for MDX headings and footnotes.
 *
 * See https://github.com/facebook/docusaurus/issues/11232
 * See also headings case https://x.com/JoshWComeau/status/1332015868725891076
 */ function useAnchorTargetClassName(id) {
    const { navbar: { hideOnScroll } } = (0,useThemeConfig/* .useThemeConfig */.p)();
    if (typeof id === 'undefined') {
        return undefined;
    }
    return hideOnScroll ? anchorUtils_module.anchorTargetHideOnScrollNavbar : anchorUtils_module.anchorTargetStickyNavbar;
} //# sourceMappingURL=anchorUtils.js.map


}),
96629: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  $Z: () => (useHistoryPopHandler),
  Hl: () => (useHistorySelector),
  jy: () => (mergeSearchStrings)
});
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var _docusaurus_router__rspack_import_1 = __webpack_require__(56347);
/* import */ var _reactUtils__rspack_import_2 = __webpack_require__(52260);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


/**
 * Permits to register a handler that will be called on history actions (pop,
 * push, replace). If the handler returns `false`, the navigation transition
 * will be blocked/cancelled.
 */ function useHistoryActionHandler(handler) {
    const history = (0,_docusaurus_router__rspack_import_1/* .useHistory */.W6)();
    const stableHandler = (0,_reactUtils__rspack_import_2/* .useEvent */._q)(handler);
    (0,react__rspack_import_0.useEffect)(// See https://github.com/remix-run/history/blob/main/docs/blocking-transitions.md
    ()=>history.block((location, action)=>stableHandler(location, action)), [
        history,
        stableHandler
    ]);
}
/**
 * Permits to register a handler that will be called on history pop navigation
 * (backward/forward). If the handler returns `false`, the backward/forward
 * transition will be blocked. Unfortunately there's no good way to detect the
 * "direction" (backward/forward) of the POP event.
 */ function useHistoryPopHandler(handler) {
    useHistoryActionHandler((location, action)=>{
        if (action === 'POP') {
            // Maybe block navigation if handler returns false
            return handler(location, action);
        }
        // Don't block other navigation actions
        return undefined;
    });
}
/**
 * Permits to efficiently subscribe to a slice of the history
 * See https://thisweekinreact.com/articles/useSyncExternalStore-the-underrated-react-api
 * @param selector
 */ function useHistorySelector(selector) {
    const history = (0,_docusaurus_router__rspack_import_1/* .useHistory */.W6)();
    return (0,react__rspack_import_0.useSyncExternalStore)(history.listen, ()=>selector(history), ()=>selector({
            ...history,
            location: {
                ...history.location,
                // On the server/hydration, these attributes should always be empty
                // Forcing empty state makes this hook safe from hydration errors
                search: '',
                hash: '',
                state: undefined
            }
        }));
}
/**
 * Permits to efficiently subscribe to a specific querystring value
 * @param key
 */ function useQueryStringValue(key) {
    return useHistorySelector((history)=>{
        if (key === null) {
            return null;
        }
        return new URLSearchParams(history.location.search).get(key);
    });
}
function useQueryStringUpdater(key) {
    const history = useHistory();
    return useCallback((newValue, options)=>{
        const searchParams = new URLSearchParams(history.location.search);
        if (newValue) {
            searchParams.set(key, newValue);
        } else {
            searchParams.delete(key);
        }
        const updateHistory = options?.push ? history.push : history.replace;
        updateHistory({
            search: searchParams.toString()
        });
    }, [
        key,
        history
    ]);
}
function useQueryString(key) {
    const value = useQueryStringValue(key) ?? '';
    const update = useQueryStringUpdater(key);
    return [
        value,
        update
    ];
}
function useQueryStringListValues(key) {
    // Unfortunately we can't just use searchParams.getAll(key) in the selector
    // It would create a new array every time and lead to an infinite loop...
    // The selector has to return a primitive/string value to avoid that...
    const arrayJsonString = useHistorySelector((history)=>{
        const values = new URLSearchParams(history.location.search).getAll(key);
        return JSON.stringify(values);
    });
    return useMemo(()=>JSON.parse(arrayJsonString), [
        arrayJsonString
    ]);
}
function useQueryStringListUpdater(key) {
    const history = useHistory();
    const setValues = useCallback((update, options)=>{
        const searchParams = new URLSearchParams(history.location.search);
        const newValues = Array.isArray(update) ? update : update(searchParams.getAll(key));
        searchParams.delete(key);
        newValues.forEach((v)=>searchParams.append(key, v));
        const updateHistory = options?.push ? history.push : history.replace;
        updateHistory({
            search: searchParams.toString()
        });
    }, [
        history,
        key
    ]);
    return setValues;
}
function useQueryStringList(key) {
    const values = useQueryStringListValues(key);
    const setValues = useQueryStringListUpdater(key);
    return [
        values,
        setValues
    ];
}
function useClearQueryString() {
    const history = useHistory();
    return useCallback(()=>{
        history.replace({
            search: undefined
        });
    }, [
        history
    ]);
}
function mergeSearchParams(params, strategy) {
    const result = new URLSearchParams();
    for (const item of params){
        for (const [key, value] of item.entries()){
            if (strategy === 'append') {
                result.append(key, value);
            } else {
                result.set(key, value);
            }
        }
    }
    return result;
}
function mergeSearchStrings(searchStrings, strategy) {
    const params = mergeSearchParams(searchStrings.map((s)=>new URLSearchParams(s ?? '')), strategy);
    const str = params.toString();
    return str ? `?${str}` : str;
} //# sourceMappingURL=historyUtils.js.map


}),
80618: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  $z: () => (groupBy),
  sb: () => (uniq)
});
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ // A replacement of lodash in client code
/**
 * Gets the duplicate values in an array.
 * @param arr The array.
 * @param comparator Compares two values and returns `true` if they are equal
 * (duplicated).
 * @returns Value of the elements `v` that have a preceding element `u` where
 * `comparator(u, v) === true`. Values within the returned array are not
 * guaranteed to be unique.
 */ function duplicates(arr, comparator = (a, b)=>a === b) {
    return arr.filter((v, vIndex)=>arr.findIndex((u)=>comparator(u, v)) !== vIndex);
}
/**
 * Remove duplicate array items (similar to `_.uniq`)
 * @param arr The array.
 * @returns An array with duplicate elements removed by reference comparison.
 */ function uniq(arr) {
    // Note: had problems with [...new Set()]: https://github.com/facebook/docusaurus/issues/4972#issuecomment-863895061
    return Array.from(new Set(arr));
}
// TODO 2025: replace by std Object.groupBy ?
// This is a local polyfill with exact same TS signature
// see https://github.com/microsoft/TypeScript/blob/main/src/lib/esnext.object.d.ts
function groupBy(items, keySelector) {
    const result = {};
    let index = 0;
    for (const item of items){
        const key = keySelector(item, index);
        result[key] ??= [];
        result[key].push(item);
        index += 1;
    }
    return result;
} //# sourceMappingURL=jsUtils.js.map


}),
34308: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  Jx: () => (PluginHtmlClassNameProvider),
  be: () => (PageMetadata),
  e3: () => (HtmlClassNameProvider)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var clsx__rspack_import_6 = __webpack_require__(34164);
/* import */ var _docusaurus_Head__rspack_import_2 = __webpack_require__(53572);
/* import */ var _docusaurus_useRouteContext__rspack_import_3 = __webpack_require__(78491);
/* import */ var _docusaurus_useBaseUrl__rspack_import_4 = __webpack_require__(66497);
/* import */ var _titleFormatterUtils__rspack_import_5 = __webpack_require__(3899);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 






function TitleMetadata({ title }) {
    const titleFormatter = (0,_titleFormatterUtils__rspack_import_5/* .useTitleFormatter */.s$)();
    const formattedTitle = titleFormatter.format(title);
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsxs)(_docusaurus_Head__rspack_import_2/* ["default"] */.A, {
        children: [
            /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("title", {
                children: formattedTitle
            }),
            /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("meta", {
                property: "og:title",
                content: formattedTitle
            })
        ]
    });
}
function DescriptionMetadata({ description }) {
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsxs)(_docusaurus_Head__rspack_import_2/* ["default"] */.A, {
        children: [
            /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("meta", {
                name: "description",
                content: description
            }),
            /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("meta", {
                property: "og:description",
                content: description
            })
        ]
    });
}
function ImageMetadata({ image }) {
    const { withBaseUrl } = (0,_docusaurus_useBaseUrl__rspack_import_4/* .useBaseUrlUtils */.hH)();
    const pageImage = withBaseUrl(image, {
        absolute: true
    });
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsxs)(_docusaurus_Head__rspack_import_2/* ["default"] */.A, {
        children: [
            /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("meta", {
                property: "og:image",
                content: pageImage
            }),
            /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("meta", {
                name: "twitter:image",
                content: pageImage
            })
        ]
    });
}
function KeywordsMetadata({ keywords }) {
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(_docusaurus_Head__rspack_import_2/* ["default"] */.A, {
        children: /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("meta", {
            name: "keywords",
            content: // https://github.com/microsoft/TypeScript/issues/17002
            Array.isArray(keywords) ? keywords.join(',') : keywords
        })
    });
}
/**
 * Helper component to manipulate page metadata and override site defaults.
 * Works in the same way as Helmet.
 */ function PageMetadata({ title, description, keywords, image, children }) {
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsxs)(react_jsx_runtime__rspack_import_0.Fragment, {
        children: [
            title && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(TitleMetadata, {
                title: title
            }),
            description && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(DescriptionMetadata, {
                description: description
            }),
            keywords && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(KeywordsMetadata, {
                keywords: keywords
            }),
            image && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(ImageMetadata, {
                image: image
            }),
            children && /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(_docusaurus_Head__rspack_import_2/* ["default"] */.A, {
                children: children
            })
        ]
    });
}
const HtmlClassNameContext = /*#__PURE__*/ react__rspack_import_1.createContext(undefined);
/**
 * Every layer of this provider will append a class name to the HTML element.
 * There's no consumer for this hook: it's side-effect-only. This wrapper is
 * necessary because Helmet does not "merge" classes.
 * @see https://github.com/staylor/react-helmet-async/issues/161
 */ function HtmlClassNameProvider({ className: classNameProp, children }) {
    const classNameContext = react__rspack_import_1.useContext(HtmlClassNameContext);
    const className = (0,clsx__rspack_import_6/* ["default"] */.A)(classNameContext, classNameProp);
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsxs)(HtmlClassNameContext.Provider, {
        value: className,
        children: [
            /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(_docusaurus_Head__rspack_import_2/* ["default"] */.A, {
                children: /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)("html", {
                    className: className
                })
            }),
            children
        ]
    });
}
function pluginNameToClassName(pluginName) {
    return `plugin-${pluginName.replace(/docusaurus-(?:plugin|theme)-(?:content-)?/gi, '')}`;
}
/**
 * A very thin wrapper around `HtmlClassNameProvider` that adds the plugin ID +
 * name to the HTML class name.
 */ function PluginHtmlClassNameProvider({ children }) {
    const routeContext = (0,_docusaurus_useRouteContext__rspack_import_3/* ["default"] */.A)();
    const nameClass = pluginNameToClassName(routeContext.plugin.name);
    const idClass = `plugin-id-${routeContext.plugin.id}`;
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(HtmlClassNameProvider, {
        className: (0,clsx__rspack_import_6/* ["default"] */.A)(nameClass, idClass),
        children: children
    });
} //# sourceMappingURL=metadataUtils.js.map


}),
52260: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  Be: () => (useShallowMemoObject),
  ZC: () => (usePrevious),
  _q: () => (useEvent),
  dV: () => (ReactContextError),
  fM: () => (composeProviders)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _docusaurus_useIsomorphicLayoutEffect__rspack_import_2 = __webpack_require__(99989);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


/**
 * Temporary userland implementation until an official hook is implemented
 * See RFC: https://github.com/reactjs/rfcs/pull/220
 *
 * Permits to transform an unstable callback (like an arrow function provided as
 * props) to a "stable" callback that is safe to use in a `useEffect` dependency
 * array. Useful to avoid React stale closure problems + avoid useless effect
 * re-executions.
 *
 * This generally works but has some potential drawbacks, such as
 * https://github.com/facebook/react/issues/16956#issuecomment-536636418
 */ function useEvent(callback) {
    const ref = (0,react__rspack_import_1.useRef)(callback);
    (0,_docusaurus_useIsomorphicLayoutEffect__rspack_import_2/* ["default"] */.A)(()=>{
        ref.current = callback;
    }, [
        callback
    ]);
    // @ts-expect-error: TS is right that this callback may be a supertype of T,
    // but good enough for our use
    return (0,react__rspack_import_1.useCallback)((...args)=>ref.current(...args), []);
}
/**
 * Gets `value` from the last render.
 */ function usePrevious(value) {
    const ref = (0,react__rspack_import_1.useRef)();
    (0,_docusaurus_useIsomorphicLayoutEffect__rspack_import_2/* ["default"] */.A)(()=>{
        ref.current = value;
    });
    // TODO need to fix this React Compiler lint error
    //  probably requires changing the API though
    // eslint-disable-next-line react-compiler/react-compiler
    return ref.current;
}
/**
 * This error is thrown when a context is consumed outside its provider. Allows
 * reusing a generic error message format and reduces bundle size. The hook's
 * name will be extracted from its stack, so only the provider's name is needed.
 */ class ReactContextError extends Error {
    constructor(providerName, additionalInfo){
        super();
        this.name = 'ReactContextError';
        this.message = `Hook ${this.stack?.split('\n')[1]?.match(/at (?:\w+\.)?(?<name>\w+)/)?.groups.name ?? ''} is called outside the <${providerName}>. ${additionalInfo ?? ''}`;
    }
}
/**
 * Shallow-memoize an object. This means the returned object will be the same as
 * the previous render if the property keys and values did not change. This
 * works for simple cases: when property values are primitives or stable
 * objects.
 *
 * @param obj
 */ function useShallowMemoObject(obj) {
    const deps = Object.entries(obj);
    // Sort by keys to make it order-insensitive
    deps.sort((a, b)=>a[0].localeCompare(b[0]));
    // eslint-disable-next-line react-compiler/react-compiler,react-hooks/exhaustive-deps
    return (0,react__rspack_import_1.useMemo)(()=>obj, deps.flat());
}
/**
 * Creates a single React provider from an array of existing providers
 * assuming providers only take "children" as props.
 *
 * Prevents the annoying React element nesting
 * Example here: https://getfrontend.tips/compose-multiple-react-providers/
 *
 * The order matters:
 * - The first provider is at the top of the tree.
 * - The last provider is the most nested one
 *
 * @param providers array of providers to compose
 */ function composeProviders(providers) {
    // Creates a single React component: it's cheaper to compose JSX elements
    return ({ children })=>/*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(react_jsx_runtime__rspack_import_0.Fragment, {
            children: providers.reduceRight((element, CurrentProvider)=>/*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(CurrentProvider, {
                    children: element
                }), children)
        });
} //# sourceMappingURL=reactUtils.js.map


}),
19209: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  Dt: () => (useHomePageRoute),
  ys: () => (isSamePath)
});
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var _generated_routes__rspack_import_1 = __webpack_require__(58460);
/* import */ var _docusaurus_useDocusaurusContext__rspack_import_2 = __webpack_require__(10898);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


/**
 * Compare the 2 paths, case insensitive and ignoring trailing slash
 */ function isSamePath(path1, path2) {
    const normalize = (pathname)=>(!pathname || pathname.endsWith('/') ? pathname : `${pathname}/`)?.toLowerCase();
    return normalize(path1) === normalize(path2);
}
/**
 * Note that sites don't always have a homepage in practice, so we can't assume
 * that linking to '/' is always safe.
 * @see https://github.com/facebook/docusaurus/pull/6517#issuecomment-1048709116
 */ function findHomePageRoute({ baseUrl, routes: initialRoutes }) {
    function isHomePageRoute(route) {
        return route.path === baseUrl && route.exact === true;
    }
    function isHomeParentRoute(route) {
        return route.path === baseUrl && !route.exact;
    }
    function doFindHomePageRoute(routes) {
        if (routes.length === 0) {
            return undefined;
        }
        const homePage = routes.find(isHomePageRoute);
        if (homePage) {
            return homePage;
        }
        const indexSubRoutes = routes.filter(isHomeParentRoute).flatMap((route)=>route.routes ?? []);
        return doFindHomePageRoute(indexSubRoutes);
    }
    return doFindHomePageRoute(initialRoutes);
}
/**
 * Fetches the route that points to "/". Use this instead of the naive "/",
 * because the homepage may not exist.
 */ function useHomePageRoute() {
    const { baseUrl } = (0,_docusaurus_useDocusaurusContext__rspack_import_2/* ["default"] */.A)().siteConfig;
    return (0,react__rspack_import_0.useMemo)(()=>findHomePageRoute({
            routes: _generated_routes__rspack_import_1/* ["default"] */.A,
            baseUrl
        }), [
        baseUrl
    ]);
} //# sourceMappingURL=routesUtils.js.map


}),
28584: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  Mq: () => (useScrollPosition),
  Tv: () => (ScrollControllerProvider),
  gk: () => (useSmoothScrollTo)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _docusaurus_ExecutionEnvironment__rspack_import_2 = __webpack_require__(91289);
/* import */ var _docusaurus_useIsBrowser__rspack_import_3 = __webpack_require__(19863);
/* import */ var _docusaurus_useIsomorphicLayoutEffect__rspack_import_4 = __webpack_require__(99989);
/* import */ var _reactUtils__rspack_import_5 = __webpack_require__(52260);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 





function useScrollControllerContextValue() {
    const scrollEventsEnabledRef = (0,react__rspack_import_1.useRef)(true);
    return (0,react__rspack_import_1.useMemo)(()=>({
            scrollEventsEnabledRef,
            enableScrollEvents: ()=>{
                scrollEventsEnabledRef.current = true;
            },
            disableScrollEvents: ()=>{
                scrollEventsEnabledRef.current = false;
            }
        }), []);
}
const ScrollMonitorContext = /*#__PURE__*/ react__rspack_import_1.createContext(undefined);
function ScrollControllerProvider({ children }) {
    const value = useScrollControllerContextValue();
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(ScrollMonitorContext.Provider, {
        value: value,
        children: children
    });
}
/**
 * We need a way to update the scroll position while ignoring scroll events
 * so as not to toggle Navbar/BackToTop visibility.
 *
 * This API permits to temporarily disable/ignore scroll events. Motivated by
 * https://github.com/facebook/docusaurus/pull/5618
 */ function useScrollController() {
    const context = (0,react__rspack_import_1.useContext)(ScrollMonitorContext);
    if (context == null) {
        throw new _reactUtils__rspack_import_5/* .ReactContextError */.dV('ScrollControllerProvider');
    }
    return context;
}
const getScrollPosition = ()=>_docusaurus_ExecutionEnvironment__rspack_import_2["default"].canUseDOM ? {
        scrollX: window.pageXOffset,
        scrollY: window.pageYOffset
    } : null;
/**
 * This hook fires an effect when the scroll position changes. The effect will
 * be provided with the before/after scroll positions. Note that the effect may
 * not be always run: if scrolling is disabled through `useScrollController`, it
 * will be a no-op.
 *
 * @see {@link useScrollController}
 */ function useScrollPosition(effect, deps = []) {
    const { scrollEventsEnabledRef } = useScrollController();
    const lastPositionRef = (0,react__rspack_import_1.useRef)(getScrollPosition());
    const dynamicEffect = (0,_reactUtils__rspack_import_5/* .useEvent */._q)(effect);
    (0,react__rspack_import_1.useEffect)(()=>{
        const handleScroll = ()=>{
            if (!scrollEventsEnabledRef.current) {
                return;
            }
            const currentPosition = getScrollPosition();
            dynamicEffect(currentPosition, lastPositionRef.current);
            lastPositionRef.current = currentPosition;
        };
        const opts = {
            passive: true
        };
        handleScroll();
        window.addEventListener('scroll', handleScroll, opts);
        return ()=>window.removeEventListener('scroll', handleScroll, opts);
    // eslint-disable-next-line react-compiler/react-compiler
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        dynamicEffect,
        scrollEventsEnabledRef,
        ...deps
    ]);
}
function useScrollPositionSaver() {
    const lastElementRef = useRef({
        elem: null,
        top: 0
    });
    const save = useCallback((elem)=>{
        lastElementRef.current = {
            elem,
            top: elem.getBoundingClientRect().top
        };
    }, []);
    const restore = useCallback(()=>{
        const { current: { elem, top } } = lastElementRef;
        if (!elem) {
            return {
                restored: false
            };
        }
        const newTop = elem.getBoundingClientRect().top;
        const heightDiff = newTop - top;
        if (heightDiff) {
            window.scrollBy({
                left: 0,
                top: heightDiff
            });
        }
        lastElementRef.current = {
            elem: null,
            top: 0
        };
        return {
            restored: heightDiff !== 0
        };
    }, []);
    return useMemo(()=>({
            save,
            restore
        }), [
        restore,
        save
    ]);
}
/**
 * This hook permits to "block" the scroll position of a DOM element.
 * The idea is that we should be able to update DOM content above this element
 * but the screen position of this element should not change.
 *
 * Feature motivated by the Tabs groups: clicking on a tab may affect tabs of
 * the same group upper in the tree, yet to avoid a bad UX, the clicked tab must
 * remain under the user mouse.
 *
 * @see https://github.com/facebook/docusaurus/pull/5618
 */ function useScrollPositionBlocker() {
    const scrollController = useScrollController();
    const scrollPositionSaver = useScrollPositionSaver();
    const nextLayoutEffectCallbackRef = useRef(undefined);
    const blockElementScrollPositionUntilNextRender = useCallback((el)=>{
        scrollPositionSaver.save(el);
        scrollController.disableScrollEvents();
        nextLayoutEffectCallbackRef.current = ()=>{
            const { restored } = scrollPositionSaver.restore();
            nextLayoutEffectCallbackRef.current = undefined;
            // Restoring the former scroll position will trigger a scroll event. We
            // need to wait for next scroll event to happen before enabling the
            // scrollController events again.
            if (restored) {
                const handleScrollRestoreEvent = ()=>{
                    scrollController.enableScrollEvents();
                    window.removeEventListener('scroll', handleScrollRestoreEvent);
                };
                window.addEventListener('scroll', handleScrollRestoreEvent);
            } else {
                scrollController.enableScrollEvents();
            }
        };
    }, [
        scrollController,
        scrollPositionSaver
    ]);
    useIsomorphicLayoutEffect(()=>{
        // Queuing permits to restore scroll position after all useLayoutEffect
        // have run, and yet preserve the sync nature of the scroll restoration
        // See https://github.com/facebook/docusaurus/issues/8625
        queueMicrotask(()=>nextLayoutEffectCallbackRef.current?.());
    });
    return {
        blockElementScrollPositionUntilNextRender
    };
}
function smoothScrollNative(top) {
    window.scrollTo({
        top,
        behavior: 'smooth'
    });
    return ()=>{
    // Nothing to cancel, it's natively cancelled if user tries to scroll down
    };
}
function smoothScrollPolyfill(top) {
    let raf = null;
    const isUpScroll = document.documentElement.scrollTop > top;
    function rafRecursion() {
        const currentScroll = document.documentElement.scrollTop;
        if (isUpScroll && currentScroll > top || !isUpScroll && currentScroll < top) {
            raf = requestAnimationFrame(rafRecursion);
            window.scrollTo(0, Math.floor((currentScroll - top) * 0.85) + top);
        }
    }
    rafRecursion();
    // Break the recursion. Prevents the user from "fighting" against that
    // recursion producing a weird UX
    return ()=>raf && cancelAnimationFrame(raf);
}
/**
 * A "smart polyfill" of `window.scrollTo({ top, behavior: "smooth" })`.
 * This currently always uses a polyfilled implementation unless
 * `scroll-behavior: smooth` has been set in CSS, because native support
 * detection for scroll behavior seems unreliable.
 *
 * This hook does not do anything by itself: it returns a start and a stop
 * handle. You can execute either handle at any time.
 */ function useSmoothScrollTo() {
    const cancelRef = (0,react__rspack_import_1.useRef)(null);
    const isBrowser = (0,_docusaurus_useIsBrowser__rspack_import_3/* ["default"] */.A)();
    // Not all have support for smooth scrolling (particularly Safari mobile iOS)
    // TODO proper detection is currently unreliable!
    // see https://github.com/wessberg/scroll-behavior-polyfill/issues/16
    // For now, we only use native scroll behavior if smooth is already set,
    // because otherwise the polyfill produces a weird UX when both CSS and JS try
    // to scroll a page, and they cancel each other.
    const supportsNativeSmoothScrolling = isBrowser && getComputedStyle(document.documentElement).scrollBehavior === 'smooth';
    return {
        startScroll: (top)=>{
            cancelRef.current = supportsNativeSmoothScrolling ? smoothScrollNative(top) : smoothScrollPolyfill(top);
        },
        cancelScroll: ()=>cancelRef.current?.()
    };
} //# sourceMappingURL=scrollUtils.js.map


}),
41367: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Wf: () => (/* binding */ createStorageSlot)
});

// UNUSED EXPORTS: listStorageKeys, useStorageSlot

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(96540);
;// CONCATENATED MODULE: ./.docusaurus/site-storage.json
var site_storage_namespaceObject = JSON.parse('{"N":"localStorage","M":""}')
;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/storageUtils.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 

const DefaultStorageType = site_storage_namespaceObject.N;
function applyNamespace(storageKey) {
    return `${storageKey}${site_storage_namespaceObject.M}`;
}
// window.addEventListener('storage') only works for different windows...
// so for current window we have to dispatch the event manually
// Now we can listen for both cross-window / current-window storage changes!
// see https://stackoverflow.com/a/71177640/82609
// see https://stackoverflow.com/questions/26974084/listen-for-changes-with-localstorage-on-the-same-window
function dispatchChangeEvent({ key, oldValue, newValue, storage }) {
    // If we set multiple times the same storage value, events should not be fired
    // The native events behave this way, so our manual event dispatch should
    // rather behave exactly the same. Not doing so might create infinite loops.
    // See https://github.com/facebook/docusaurus/issues/8594
    if (oldValue === newValue) {
        return;
    }
    const event = document.createEvent('StorageEvent');
    event.initStorageEvent('storage', false, false, key, oldValue, newValue, window.location.href, storage);
    window.dispatchEvent(event);
}
/**
 * Will return `null` if browser storage is unavailable (like running Docusaurus
 * in an iframe). This should NOT be called in SSR.
 *
 * @see https://github.com/facebook/docusaurus/pull/4501
 */ function getBrowserStorage(storageType = DefaultStorageType) {
    if (typeof window === 'undefined') {
        throw new Error('Browser storage is not available on Node.js/Docusaurus SSR process.');
    }
    if (storageType === 'none') {
        return null;
    }
    try {
        return window[storageType];
    } catch (err) {
        logOnceBrowserStorageNotAvailableWarning(err);
        return null;
    }
}
let hasLoggedBrowserStorageNotAvailableWarning = false;
/**
 * Poor man's memoization to avoid logging multiple times the same warning.
 * Sometimes, `localStorage`/`sessionStorage` is unavailable due to browser
 * policies.
 */ function logOnceBrowserStorageNotAvailableWarning(error) {
    if (!hasLoggedBrowserStorageNotAvailableWarning) {
        console.warn(`Docusaurus browser storage is not available.
Possible reasons: running Docusaurus in an iframe, in an incognito browser session, or using too strict browser privacy settings.`, error);
        hasLoggedBrowserStorageNotAvailableWarning = true;
    }
}
const NoopStorageSlot = {
    get: ()=>null,
    set: ()=>{},
    del: ()=>{},
    listen: ()=>()=>{}
};
// Fail-fast, as storage APIs should not be used during the SSR process
function createServerStorageSlot(key) {
    function throwError() {
        throw new Error(`Illegal storage API usage for storage key "${key}".
Docusaurus storage APIs are not supposed to be called on the server-rendering process.
Please only call storage APIs in effects and event handlers.`);
    }
    return {
        get: throwError,
        set: throwError,
        del: throwError,
        listen: throwError
    };
}
/**
 * Creates an interface to work on a particular key in the storage model.
 * Note that this function only initializes the interface, but doesn't allocate
 * anything by itself (i.e. no side-effects).
 *
 * The API is fail-safe, since usage of browser storage should be considered
 * unreliable. Local storage might simply be unavailable (iframe + browser
 * security) or operations might fail individually. Please assume that using
 * this API can be a no-op. See also https://github.com/facebook/docusaurus/issues/6036
 */ function createStorageSlot(keyInput, options) {
    const key = applyNamespace(keyInput);
    if (typeof window === 'undefined') {
        return createServerStorageSlot(key);
    }
    const storage = getBrowserStorage(options?.persistence);
    if (storage === null) {
        return NoopStorageSlot;
    }
    return {
        get: ()=>{
            try {
                return storage.getItem(key);
            } catch (err) {
                console.error(`Docusaurus storage error, can't get key=${key}`, err);
                return null;
            }
        },
        set: (newValue)=>{
            try {
                const oldValue = storage.getItem(key);
                storage.setItem(key, newValue);
                dispatchChangeEvent({
                    key,
                    oldValue,
                    newValue,
                    storage
                });
            } catch (err) {
                console.error(`Docusaurus storage error, can't set ${key}=${newValue}`, err);
            }
        },
        del: ()=>{
            try {
                const oldValue = storage.getItem(key);
                storage.removeItem(key);
                dispatchChangeEvent({
                    key,
                    oldValue,
                    newValue: null,
                    storage
                });
            } catch (err) {
                console.error(`Docusaurus storage error, can't delete key=${key}`, err);
            }
        },
        listen: (onChange)=>{
            try {
                const listener = (event)=>{
                    if (event.storageArea === storage && event.key === key) {
                        onChange(event);
                    }
                };
                window.addEventListener('storage', listener);
                return ()=>window.removeEventListener('storage', listener);
            } catch (err) {
                console.error(`Docusaurus storage error, can't listen for changes of key=${key}`, err);
                return ()=>{};
            }
        }
    };
}
function useStorageSlot(key, options) {
    // Not ideal but good enough: assumes storage slot config is constant
    const [storageSlot] = useState(()=>{
        if (key === null) {
            return NoopStorageSlot;
        }
        return createStorageSlot(key, options);
    });
    const listen = useCallback((onChange)=>{
        // Do not try to add a listener during SSR
        if (typeof window === 'undefined') {
            return ()=>{};
        }
        return storageSlot.listen(onChange);
    }, [
        storageSlot
    ]);
    const currentValue = useSyncExternalStore(listen, ()=>{
        // react-test-renderer (deprecated) never call getServerSnapshot() :/
        if (false) {}
        return storageSlot.get();
    }, ()=>null);
    return [
        currentValue,
        storageSlot
    ];
}
/**
 * Returns a list of all the keys currently stored in browser storage,
 * or an empty list if browser storage can't be accessed.
 */ function listStorageKeys(storageType = DefaultStorageType) {
    const browserStorage = getBrowserStorage(storageType);
    if (!browserStorage) {
        return [];
    }
    const keys = [];
    for(let i = 0; i < browserStorage.length; i += 1){
        const key = browserStorage.key(i);
        if (key !== null) {
            keys.push(key);
        }
    }
    return keys;
} //# sourceMappingURL=storageUtils.js.map


}),
3899: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  AL: () => (TitleFormatterProvider),
  s$: () => (useTitleFormatter)
});
/* import */ var react_jsx_runtime__rspack_import_0 = __webpack_require__(74848);
/* import */ var react__rspack_import_1 = __webpack_require__(96540);
/* import */ var _docusaurus_useDocusaurusContext__rspack_import_2 = __webpack_require__(10898);
/* import */ var _docusaurus_useRouteContext__rspack_import_3 = __webpack_require__(78491);
/* import */ var _reactUtils__rspack_import_4 = __webpack_require__(52260);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 




const TitleFormatterFnDefault = ({ title, siteTitle, titleDelimiter })=>{
    const trimmedTitle = title?.trim();
    if (!trimmedTitle || trimmedTitle === siteTitle) {
        return siteTitle;
    }
    return `${trimmedTitle} ${titleDelimiter} ${siteTitle}`;
};
const TitleFormatterContext = /*#__PURE__*/ (0,react__rspack_import_1.createContext)(null);
function TitleFormatterProvider({ formatter, children }) {
    return /*#__PURE__*/ (0,react_jsx_runtime__rspack_import_0.jsx)(TitleFormatterContext.Provider, {
        value: formatter,
        children: children
    });
}
function useTitleFormatterContext() {
    const value = (0,react__rspack_import_1.useContext)(TitleFormatterContext);
    if (value === null) {
        throw new _reactUtils__rspack_import_4/* .ReactContextError */.dV('TitleFormatterProvider');
    }
    return value;
}
/**
 * Returns a function to format the page title
 */ function useTitleFormatter() {
    const formatter = useTitleFormatterContext();
    const { siteConfig } = (0,_docusaurus_useDocusaurusContext__rspack_import_2/* ["default"] */.A)();
    const { title: siteTitle, titleDelimiter } = siteConfig;
    // Unfortunately we can only call this hook here, not in the provider
    // Route context can't be accessed in any provider applied above the router
    const { plugin } = (0,_docusaurus_useRouteContext__rspack_import_3/* ["default"] */.A)();
    return {
        format: (title)=>formatter({
                title,
                siteTitle,
                titleDelimiter,
                plugin,
                defaultFormatter: TitleFormatterFnDefault
            })
    };
} //# sourceMappingURL=titleFormatterUtils.js.map


}),
5243: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  o: () => (useAlternatePageUtils)
});
/* import */ var _docusaurus_useDocusaurusContext__rspack_import_0 = __webpack_require__(10898);
/* import */ var _docusaurus_router__rspack_import_1 = __webpack_require__(56347);
/* import */ var _docusaurus_utils_common__rspack_import_2 = __webpack_require__(5248);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


/**
 * Permits to obtain the url of the current page in another locale, useful to
 * generate hreflang meta headers etc...
 *
 * @see https://developers.google.com/search/docs/advanced/crawling/localized-versions
 */ function useAlternatePageUtils() {
    const { siteConfig: { baseUrl, trailingSlash }, i18n: { localeConfigs } } = (0,_docusaurus_useDocusaurusContext__rspack_import_0/* ["default"] */.A)();
    // TODO using useLocation().pathname is not a super idea
    // See https://github.com/facebook/docusaurus/issues/9170
    const { pathname } = (0,_docusaurus_router__rspack_import_1/* .useLocation */.zy)();
    const canonicalPathname = (0,_docusaurus_utils_common__rspack_import_2.applyTrailingSlash)(pathname, {
        trailingSlash,
        baseUrl
    });
    // Canonical pathname, without the baseUrl of the current locale
    const pathnameSuffix = canonicalPathname.replace(baseUrl, '');
    function getLocaleConfig(locale) {
        const localeConfig = localeConfigs[locale];
        if (!localeConfig) {
            throw new Error(`Unexpected Docusaurus bug, no locale config found for locale=${locale}`);
        }
        return localeConfig;
    }
    function createUrl({ locale, fullyQualified }) {
        const localeConfig = getLocaleConfig(locale);
        const newUrl = `${fullyQualified ? localeConfig.url : ''}`;
        const newBaseUrl = localeConfig.baseUrl;
        return `${newUrl}${newBaseUrl}${pathnameSuffix}`;
    }
    return {
        createUrl
    };
} //# sourceMappingURL=useAlternatePageUtils.js.map


}),
98398: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  $: () => (useLocationChange)
});
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var _docusaurus_router__rspack_import_1 = __webpack_require__(56347);
/* import */ var _reactUtils__rspack_import_2 = __webpack_require__(52260);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 


/**
 * Fires an effect when the location changes (which includes hash, query, etc.).
 * Importantly, doesn't fire when there's no previous location: see
 * https://github.com/facebook/docusaurus/pull/6696
 */ function useLocationChange(onLocationChange) {
    const location = (0,_docusaurus_router__rspack_import_1/* .useLocation */.zy)();
    const previousLocation = (0,_reactUtils__rspack_import_2/* .usePrevious */.ZC)(location);
    const onLocationChangeDynamic = (0,_reactUtils__rspack_import_2/* .useEvent */._q)(onLocationChange);
    (0,react__rspack_import_0.useEffect)(()=>{
        if (!previousLocation) {
            return;
        }
        if (location !== previousLocation) {
            onLocationChangeDynamic({
                location,
                previousLocation
            });
        }
    }, [
        onLocationChangeDynamic,
        location,
        previousLocation
    ]);
} //# sourceMappingURL=useLocationChange.js.map


}),
61022: (function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  p: () => (useThemeConfig)
});
/* import */ var _docusaurus_useDocusaurusContext__rspack_import_0 = __webpack_require__(10898);
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 
/**
 * A convenient/more semantic way to get theme config from context.
 */ function useThemeConfig() {
    return (0,_docusaurus_useDocusaurusContext__rspack_import_0/* ["default"] */.A)().siteConfig.themeConfig;
} //# sourceMappingURL=useThemeConfig.js.map


}),
84207: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.addTrailingSlash = addTrailingSlash;
exports["default"] = applyTrailingSlash;
exports.addLeadingSlash = addLeadingSlash;
exports.removeTrailingSlash = removeTrailingSlash;
const stringUtils_1 = __webpack_require__(89262);
function addTrailingSlash(str) {
    return str.endsWith('/') ? str : `${str}/`;
}
// Trailing slash handling depends in some site configuration options
function applyTrailingSlash(path, options) {
    const { trailingSlash, baseUrl } = options;
    if (path.startsWith('#')) {
        // Never apply trailing slash to an anchor link
        return path;
    }
    function handleTrailingSlash(str, trailing) {
        return trailing ? addTrailingSlash(str) : removeTrailingSlash(str);
    }
    // undefined = legacy retrocompatible behavior
    if (typeof trailingSlash === 'undefined') {
        return path;
    }
    // The trailing slash should be handled before the ?search#hash !
    const [pathname] = path.split(/[#?]/);
    // Never transform '/' to ''
    // Never remove the baseUrl trailing slash!
    // If baseUrl = /myBase/, we want to emit /myBase/index.html and not
    // /myBase.html! See https://github.com/facebook/docusaurus/issues/5077
    const shouldNotApply = pathname === '/' || pathname === baseUrl;
    const newPathname = shouldNotApply ? pathname : handleTrailingSlash(pathname, trailingSlash);
    return path.replace(pathname, newPathname);
}
/** Appends a leading slash to `str`, if one doesn't exist. */ function addLeadingSlash(str) {
    return (0, stringUtils_1.addPrefix)(str, '/');
}
/** Removes the trailing slash from `str`. */ function removeTrailingSlash(str) {
    return (0, stringUtils_1.removeSuffix)(str, '/');
} //# sourceMappingURL=applyTrailingSlash.js.map


}),
17541: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getErrorCausalChain = getErrorCausalChain;
function getErrorCausalChain(error) {
    if (error.cause) {
        return [
            error,
            ...getErrorCausalChain(error.cause)
        ];
    }
    return [
        error
    ];
} //# sourceMappingURL=errorUtils.js.map


}),
5248: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";
var __webpack_unused_export__;

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ __webpack_unused_export__ = ({
    value: true
});
exports.getErrorCausalChain = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = __webpack_unused_export__ = exports.applyTrailingSlash = exports.blogPostContainerID = void 0;
const tslib_1 = __webpack_require__(31635);
// __ prefix allows search crawlers (Algolia/DocSearch) to ignore anchors
// https://github.com/facebook/docusaurus/issues/8883#issuecomment-1516328368
exports.blogPostContainerID = '__blog-post-container';
var applyTrailingSlash_1 = __webpack_require__(84207);
Object.defineProperty(exports, "applyTrailingSlash", ({
    enumerable: true,
    get: function() {
        return tslib_1.__importDefault(applyTrailingSlash_1).default;
    }
}));
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return applyTrailingSlash_1.addTrailingSlash;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return applyTrailingSlash_1.addLeadingSlash;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return applyTrailingSlash_1.removeTrailingSlash;
    }
});
var stringUtils_1 = __webpack_require__(89262);
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return stringUtils_1.addPrefix;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return stringUtils_1.removeSuffix;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return stringUtils_1.addSuffix;
    }
});
__webpack_unused_export__ = ({
    enumerable: true,
    get: function() {
        return stringUtils_1.removePrefix;
    }
});
var errorUtils_1 = __webpack_require__(17541);
Object.defineProperty(exports, "getErrorCausalChain", ({
    enumerable: true,
    get: function() {
        return errorUtils_1.getErrorCausalChain;
    }
})); //# sourceMappingURL=index.js.map


}),
89262: (function (__unused_webpack_module, exports) {
"use strict";

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.addPrefix = addPrefix;
exports.removeSuffix = removeSuffix;
exports.addSuffix = addSuffix;
exports.removePrefix = removePrefix;
/** Adds a given string prefix to `str`. */ function addPrefix(str, prefix) {
    return str.startsWith(prefix) ? str : `${prefix}${str}`;
}
/** Removes a given string suffix from `str`. */ function removeSuffix(str, suffix) {
    if (suffix === '') {
        // str.slice(0, 0) is ""
        return str;
    }
    return str.endsWith(suffix) ? str.slice(0, -suffix.length) : str;
}
/** Adds a given string suffix to `str`. */ function addSuffix(str, suffix) {
    return str.endsWith(suffix) ? str : `${str}${suffix}`;
}
/** Removes a given string prefix from `str`. */ function removePrefix(str, prefix) {
    return str.startsWith(prefix) ? str.slice(prefix.length) : str;
} //# sourceMappingURL=stringUtils.js.map


}),
70630: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const ExecutionEnvironment_1 = __importDefault(__webpack_require__(91289));
if (ExecutionEnvironment_1.default.canUseDOM) {
    window.Prism = window.Prism || {};
    window.Prism.manual = true;
} //# sourceMappingURL=global.js.map


}),
4784: (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (__rspack_default_export)
});
/*
 * AUTOGENERATED - DON'T EDIT
 * Your edits in this file will be overwritten in the next build!
 * Modify the docusaurus.config.js file at your site's root instead.
 */
/* export default */ const __rspack_default_export = ({
  "title": "Fintesk - documentación para usuarios",
  "tagline": "Obtén todos los consejos y tips que necesitas para customizar nuestra aplicación con estos tutoriales",
  "favicon": "img/fintesk.ico",
  "url": "https://docs.fintesk.com",
  "baseUrl": "/es/",
  "projectName": "fabouru1985.github.io",
  "organizationName": "fabouru1985",
  "deploymentBranch": "main",
  "onBrokenLinks": "warn",
  "trailingSlash": false,
  "i18n": {
    "defaultLocale": "en",
    "locales": [
      "en",
      "es"
    ],
    "path": "i18n",
    "localeConfigs": {}
  },
  "presets": [
    [
      "classic",
      {
        "docs": {
          "sidebarPath": "./sidebars.js",
          "routeBasePath": "/",
          "exclude": [
            "**_api/**"
          ],
          "showLastUpdateAuthor": true,
          "showLastUpdateTime": true
        },
        "blog": {
          "showReadingTime": true,
          "blogSidebarTitle": "All posts",
          "blogSidebarCount": "ALL",
          "feedOptions": {
            "type": null
          }
        },
        "theme": {
          "customCss": "./src/css/custom.css"
        }
      }
    ],
    [
      "redocusaurus",
      {
        "specs": [
          {
            "id": "fintesk-v1",
            "spec": "docs/_api/fintesk/fintesk_api.yaml",
            "route": "docs/fintesk-v1/"
          }
        ],
        "theme": {
          "primaryColor": "#1890ff"
        }
      }
    ]
  ],
  "plugins": [
    [
      "@docusaurus/plugin-google-tag-manager",
      {
        "containerId": "GTM-MFMP7WDH"
      }
    ],
    [
      "@orama/plugin-docusaurus-v3",
      {
        "plugins": {
          "analytics": {
            "enabled": true
          }
        }
      }
    ]
  ],
  "themeConfig": {
    "navbar": {
      "title": "Fintesk Docs",
      "logo": {
        "alt": "Fintesk Logo",
        "src": "img/Fintesk-V2023-06-09.svg"
      },
      "items": [
        {
          "type": "docSidebar",
          "sidebarId": "tutorialSidebar",
          "position": "left",
          "label": "Tutorial"
        },
        {
          "to": "/blog",
          "label": "Blog",
          "position": "left"
        },
        {
          "type": "localeDropdown",
          "position": "right",
          "dropdownItemsBefore": [],
          "dropdownItemsAfter": []
        }
      ],
      "hideOnScroll": false
    },
    "footer": {
      "style": "dark",
      "links": [],
      "copyright": "<div>Copyright © 2020 - 2025 <a href=\"https://fintesk.com?utm_source=fintesk-docs\">www.fintesk.com<a><div>"
    },
    "prism": {
      "theme": {
        "plain": {
          "color": "#393A34",
          "backgroundColor": "#f6f8fa"
        },
        "styles": [
          {
            "types": [
              "comment",
              "prolog",
              "doctype",
              "cdata"
            ],
            "style": {
              "color": "#999988",
              "fontStyle": "italic"
            }
          },
          {
            "types": [
              "namespace"
            ],
            "style": {
              "opacity": 0.7
            }
          },
          {
            "types": [
              "string",
              "attr-value"
            ],
            "style": {
              "color": "#e3116c"
            }
          },
          {
            "types": [
              "punctuation",
              "operator"
            ],
            "style": {
              "color": "#393A34"
            }
          },
          {
            "types": [
              "entity",
              "url",
              "symbol",
              "number",
              "boolean",
              "variable",
              "constant",
              "property",
              "regex",
              "inserted"
            ],
            "style": {
              "color": "#36acaa"
            }
          },
          {
            "types": [
              "atrule",
              "keyword",
              "attr-name",
              "selector"
            ],
            "style": {
              "color": "#00a4db"
            }
          },
          {
            "types": [
              "function",
              "deleted",
              "tag"
            ],
            "style": {
              "color": "#d73a49"
            }
          },
          {
            "types": [
              "function-variable"
            ],
            "style": {
              "color": "#6f42c1"
            }
          },
          {
            "types": [
              "tag",
              "selector",
              "keyword"
            ],
            "style": {
              "color": "#00009f"
            }
          }
        ]
      },
      "darkTheme": {
        "plain": {
          "color": "#F8F8F2",
          "backgroundColor": "#282A36"
        },
        "styles": [
          {
            "types": [
              "prolog",
              "constant",
              "builtin"
            ],
            "style": {
              "color": "rgb(189, 147, 249)"
            }
          },
          {
            "types": [
              "inserted",
              "function"
            ],
            "style": {
              "color": "rgb(80, 250, 123)"
            }
          },
          {
            "types": [
              "deleted"
            ],
            "style": {
              "color": "rgb(255, 85, 85)"
            }
          },
          {
            "types": [
              "changed"
            ],
            "style": {
              "color": "rgb(255, 184, 108)"
            }
          },
          {
            "types": [
              "punctuation",
              "symbol"
            ],
            "style": {
              "color": "rgb(248, 248, 242)"
            }
          },
          {
            "types": [
              "string",
              "char",
              "tag",
              "selector"
            ],
            "style": {
              "color": "rgb(255, 121, 198)"
            }
          },
          {
            "types": [
              "keyword",
              "variable"
            ],
            "style": {
              "color": "rgb(189, 147, 249)",
              "fontStyle": "italic"
            }
          },
          {
            "types": [
              "comment"
            ],
            "style": {
              "color": "rgb(98, 114, 164)"
            }
          },
          {
            "types": [
              "attr-name"
            ],
            "style": {
              "color": "rgb(241, 250, 140)"
            }
          }
        ]
      },
      "additionalLanguages": [
        "powershell",
        "php",
        "python"
      ],
      "magicComments": [
        {
          "className": "theme-code-block-highlighted-line",
          "line": "highlight-next-line",
          "block": {
            "start": "highlight-start",
            "end": "highlight-end"
          }
        }
      ]
    },
    "tableOfContents": {
      "minHeadingLevel": 2,
      "maxHeadingLevel": 3
    },
    "colorMode": {
      "defaultMode": "light",
      "disableSwitch": false,
      "respectPrefersColorScheme": false
    },
    "docs": {
      "versionPersistence": "localStorage",
      "sidebar": {
        "hideable": false,
        "autoCollapseCategories": false
      }
    },
    "blog": {
      "sidebar": {
        "groupByYear": true
      }
    },
    "metadata": []
  },
  "future": {
    "v4": {
      "removeLegacyPostBuildHeadAttribute": true,
      "useCssCascadeLayers": true
    },
    "experimental_faster": {
      "swcJsLoader": true,
      "swcJsMinimizer": true,
      "swcHtmlMinimizer": true,
      "lightningCssMinimizer": true,
      "rspackBundler": true,
      "rspackPersistentCache": true,
      "ssgWorkerThreads": true,
      "mdxCrossCompilerCache": true
    },
    "experimental_storage": {
      "type": "localStorage",
      "namespace": false
    },
    "experimental_router": "browser"
  },
  "markdown": {
    "hooks": {
      "onBrokenMarkdownImages": "warn",
      "onBrokenMarkdownLinks": "warn"
    },
    "format": "mdx",
    "mermaid": false,
    "emoji": true,
    "mdx1Compat": {
      "comments": true,
      "admonitions": true,
      "headingIds": true
    },
    "anchors": {
      "maintainCase": false
    }
  },
  "baseUrlIssueBanner": true,
  "onBrokenAnchors": "warn",
  "onDuplicateRoutes": "warn",
  "staticDirectories": [
    "static"
  ],
  "customFields": {},
  "themes": [],
  "scripts": [],
  "headTags": [],
  "stylesheets": [],
  "clientModules": [],
  "titleDelimiter": "|",
  "noIndex": false
});


}),
58168: (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (_extends)
});
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}


}),
77387: (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (_inheritsLoose)
});
/* import */ var _setPrototypeOf_js__rspack_import_0 = __webpack_require__(63662);

function _inheritsLoose(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, (0,_setPrototypeOf_js__rspack_import_0/* ["default"] */.A)(t, o);
}


}),
98587: (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (_objectWithoutPropertiesLoose)
});
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}


}),
63662: (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (_setPrototypeOf)
});
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}


}),
34164: (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (__rspack_default_export)
});
function r(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=" "),n+=f)}else for(f in e)e[f]&&(n&&(n+=" "),n+=f);return n}function clsx(){for(var e,t,f=0,n="",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=" "),n+=t);return n}/* export default */ const __rspack_default_export = (clsx);

}),
71765: (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  My: () => (Prism),
  f4: () => (Highlight2)
});
/* import */ var react__rspack_import_0 = __webpack_require__(96540);
/* import */ var clsx__rspack_import_1 = __webpack_require__(34164);
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/.pnpm/prismjs@1.29.0_patch_hash=vrxx3pzkik6jpmgpayxfjunetu/node_modules/prismjs/prism.js
var require_prism = __commonJS({
  "../../node_modules/.pnpm/prismjs@1.29.0_patch_hash=vrxx3pzkik6jpmgpayxfjunetu/node_modules/prismjs/prism.js"(exports, module) {
    var Prism2 = function() {
      var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
      var uniqueId = 0;
      var plainTextGrammar = {};
      var _ = {
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function encode(tokens) {
            if (tokens instanceof Token) {
              return new Token(tokens.type, encode(tokens.content), tokens.alias);
            } else if (Array.isArray(tokens)) {
              return tokens.map(encode);
            } else {
              return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            }
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(o) {
            return Object.prototype.toString.call(o).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(obj) {
            if (!obj["__id"]) {
              Object.defineProperty(obj, "__id", { value: ++uniqueId });
            }
            return obj["__id"];
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function deepClone(o, visited) {
            visited = visited || {};
            var clone;
            var id;
            switch (_.util.type(o)) {
              case "Object":
                id = _.util.objId(o);
                if (visited[id]) {
                  return visited[id];
                }
                clone = /** @type {Record<string, any>} */
                {};
                visited[id] = clone;
                for (var key in o) {
                  if (o.hasOwnProperty(key)) {
                    clone[key] = deepClone(o[key], visited);
                  }
                }
                return (
                  /** @type {any} */
                  clone
                );
              case "Array":
                id = _.util.objId(o);
                if (visited[id]) {
                  return visited[id];
                }
                clone = [];
                visited[id] = clone;
                /** @type {Array} */
                /** @type {any} */
                o.forEach(function(v, i) {
                  clone[i] = deepClone(v, visited);
                });
                return (
                  /** @type {any} */
                  clone
                );
              default:
                return o;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(element) {
            while (element) {
              var m = lang.exec(element.className);
              if (m) {
                return m[1].toLowerCase();
              }
              element = element.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(element, language) {
            element.className = element.className.replace(RegExp(lang, "gi"), "");
            element.classList.add("language-" + language);
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(element, className, defaultActivation) {
            var no = "no-" + className;
            while (element) {
              var classList = element.classList;
              if (classList.contains(className)) {
                return true;
              }
              if (classList.contains(no)) {
                return false;
              }
              element = element.parentElement;
            }
            return !!defaultActivation;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: plainTextGrammar,
          plaintext: plainTextGrammar,
          text: plainTextGrammar,
          txt: plainTextGrammar,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(id, redef) {
            var lang2 = _.util.clone(_.languages[id]);
            for (var key in redef) {
              lang2[key] = redef[key];
            }
            return lang2;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(inside, before, insert, root) {
            root = root || /** @type {any} */
            _.languages;
            var grammar = root[inside];
            var ret = {};
            for (var token in grammar) {
              if (grammar.hasOwnProperty(token)) {
                if (token == before) {
                  for (var newToken in insert) {
                    if (insert.hasOwnProperty(newToken)) {
                      ret[newToken] = insert[newToken];
                    }
                  }
                }
                if (!insert.hasOwnProperty(token)) {
                  ret[token] = grammar[token];
                }
              }
            }
            var old = root[inside];
            root[inside] = ret;
            _.languages.DFS(_.languages, function(key, value) {
              if (value === old && key != inside) {
                this[key] = ret;
              }
            });
            return ret;
          },
          // Traverse a language definition with Depth First Search
          DFS: function DFS(o, callback, type, visited) {
            visited = visited || {};
            var objId = _.util.objId;
            for (var i in o) {
              if (o.hasOwnProperty(i)) {
                callback.call(o, i, o[i], type || i);
                var property = o[i];
                var propertyType = _.util.type(property);
                if (propertyType === "Object" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, null, visited);
                } else if (propertyType === "Array" && !visited[objId(property)]) {
                  visited[objId(property)] = true;
                  DFS(property, callback, i, visited);
                }
              }
            }
          }
        },
        plugins: {},
        /**
         * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(text, grammar, language) {
          var env = {
            code: text,
            grammar,
            language
          };
          _.hooks.run("before-tokenize", env);
          if (!env.grammar) {
            throw new Error('The language "' + env.language + '" has no grammar.');
          }
          env.tokens = _.tokenize(env.code, env.grammar);
          _.hooks.run("after-tokenize", env);
          return Token.stringify(_.util.encode(env.tokens), env.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(text, grammar) {
          var rest = grammar.rest;
          if (rest) {
            for (var token in rest) {
              grammar[token] = rest[token];
            }
            delete grammar.rest;
          }
          var tokenList = new LinkedList();
          addAfter(tokenList, tokenList.head, text);
          matchGrammar(text, tokenList, grammar, tokenList.head, 0);
          return toArray(tokenList);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(name, callback) {
            var hooks2 = _.hooks.all;
            hooks2[name] = hooks2[name] || [];
            hooks2[name].push(callback);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(name, env) {
            var callbacks = _.hooks.all[name];
            if (!callbacks || !callbacks.length) {
              return;
            }
            for (var i = 0, callback; callback = callbacks[i++]; ) {
              callback(env);
            }
          }
        },
        Token
      };
      function Token(type, content, alias, matchedStr) {
        this.type = type;
        this.content = content;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
      }
      Token.stringify = function stringify(o, language) {
        if (typeof o == "string") {
          return o;
        }
        if (Array.isArray(o)) {
          var s = "";
          o.forEach(function(e) {
            s += stringify(e, language);
          });
          return s;
        }
        var env = {
          type: o.type,
          content: stringify(o.content, language),
          tag: "span",
          classes: ["token", o.type],
          attributes: {},
          language
        };
        var aliases = o.alias;
        if (aliases) {
          if (Array.isArray(aliases)) {
            Array.prototype.push.apply(env.classes, aliases);
          } else {
            env.classes.push(aliases);
          }
        }
        _.hooks.run("wrap", env);
        var attributes = "";
        for (var name in env.attributes) {
          attributes += " " + name + '="' + (env.attributes[name] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
      };
      function matchPattern(pattern, pos, text, lookbehind) {
        pattern.lastIndex = pos;
        var match = pattern.exec(text);
        if (match && lookbehind && match[1]) {
          var lookbehindLength = match[1].length;
          match.index += lookbehindLength;
          match[0] = match[0].slice(lookbehindLength);
        }
        return match;
      }
      function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
        for (var token in grammar) {
          if (!grammar.hasOwnProperty(token) || !grammar[token]) {
            continue;
          }
          var patterns = grammar[token];
          patterns = Array.isArray(patterns) ? patterns : [patterns];
          for (var j = 0; j < patterns.length; ++j) {
            if (rematch && rematch.cause == token + "," + j) {
              return;
            }
            var patternObj = patterns[j];
            var inside = patternObj.inside;
            var lookbehind = !!patternObj.lookbehind;
            var greedy = !!patternObj.greedy;
            var alias = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            var pattern = patternObj.pattern || patternObj;
            for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
              if (rematch && pos >= rematch.reach) {
                break;
              }
              var str = currentNode.value;
              if (tokenList.length > text.length) {
                return;
              }
              if (str instanceof Token) {
                continue;
              }
              var removeCount = 1;
              var match;
              if (greedy) {
                match = matchPattern(pattern, pos, text, lookbehind);
                if (!match || match.index >= text.length) {
                  break;
                }
                var from = match.index;
                var to = match.index + match[0].length;
                var p = pos;
                p += currentNode.value.length;
                while (from >= p) {
                  currentNode = currentNode.next;
                  p += currentNode.value.length;
                }
                p -= currentNode.value.length;
                pos = p;
                if (currentNode.value instanceof Token) {
                  continue;
                }
                for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === "string"); k = k.next) {
                  removeCount++;
                  p += k.value.length;
                }
                removeCount--;
                str = text.slice(pos, p);
                match.index -= pos;
              } else {
                match = matchPattern(pattern, 0, str, lookbehind);
                if (!match) {
                  continue;
                }
              }
              var from = match.index;
              var matchStr = match[0];
              var before = str.slice(0, from);
              var after = str.slice(from + matchStr.length);
              var reach = pos + str.length;
              if (rematch && reach > rematch.reach) {
                rematch.reach = reach;
              }
              var removeFrom = currentNode.prev;
              if (before) {
                removeFrom = addAfter(tokenList, removeFrom, before);
                pos += before.length;
              }
              removeRange(tokenList, removeFrom, removeCount);
              var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
              currentNode = addAfter(tokenList, removeFrom, wrapped);
              if (after) {
                addAfter(tokenList, currentNode, after);
              }
              if (removeCount > 1) {
                var nestedRematch = {
                  cause: token + "," + j,
                  reach
                };
                matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                if (rematch && nestedRematch.reach > rematch.reach) {
                  rematch.reach = nestedRematch.reach;
                }
              }
            }
          }
        }
      }
      function LinkedList() {
        var head = { value: null, prev: null, next: null };
        var tail = { value: null, prev: head, next: null };
        head.next = tail;
        this.head = head;
        this.tail = tail;
        this.length = 0;
      }
      function addAfter(list, node, value) {
        var next = node.next;
        var newNode = { value, prev: node, next };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
      }
      function removeRange(list, node, count) {
        var next = node.next;
        for (var i = 0; i < count && next !== list.tail; i++) {
          next = next.next;
        }
        node.next = next;
        next.prev = node;
        list.length -= i;
      }
      function toArray(list) {
        var array = [];
        var node = list.head.next;
        while (node !== list.tail) {
          array.push(node.value);
          node = node.next;
        }
        return array;
      }
      return _;
    }();
    module.exports = Prism2;
    Prism2.default = Prism2;
  }
});

// src/prism-langs.ts
var Prism = __toESM(require_prism());
Prism.languages.markup = { comment: { pattern: /<!--(?:(?!<!--)[\s\S])*?-->/, greedy: true }, prolog: { pattern: /<\?[\s\S]+?\?>/, greedy: true }, doctype: { pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i, greedy: true, inside: { "internal-subset": { pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/, lookbehind: true, greedy: true, inside: null }, string: { pattern: /"[^"]*"|'[^']*'/, greedy: true }, punctuation: /^<!|>$|[[\]]/, "doctype-tag": /^DOCTYPE/i, name: /[^\s<>'"]+/ } }, cdata: { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, greedy: true }, tag: { pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/, greedy: true, inside: { tag: { pattern: /^<\/?[^\s>\/]+/, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } }, "special-attr": [], "attr-value": { pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/, inside: { punctuation: [{ pattern: /^=/, alias: "attr-equals" }, { pattern: /^(\s*)["']|["']$/, lookbehind: true }] } }, punctuation: /\/?>/, "attr-name": { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } } } }, entity: [{ pattern: /&[\da-z]{1,8};/i, alias: "named-entity" }, /&#x?[\da-f]{1,8};/i] }, Prism.languages.markup.tag.inside["attr-value"].inside.entity = Prism.languages.markup.entity, Prism.languages.markup.doctype.inside["internal-subset"].inside = Prism.languages.markup, Prism.hooks.add("wrap", function(e) {
  "entity" === e.type && (e.attributes.title = e.content.replace(/&amp;/, "&"));
}), Object.defineProperty(Prism.languages.markup.tag, "addInlined", { value: function(e, n) {
  var t = {}, t = (t["language-" + n] = { pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i, lookbehind: true, inside: Prism.languages[n] }, t.cdata = /^<!\[CDATA\[|\]\]>$/i, { "included-cdata": { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, inside: t } }), n = (t["language-" + n] = { pattern: /[\s\S]+/, inside: Prism.languages[n] }, {});
  n[e] = { pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
    return e;
  }), "i"), lookbehind: true, greedy: true, inside: t }, Prism.languages.insertBefore("markup", "cdata", n);
} }), Object.defineProperty(Prism.languages.markup.tag, "addAttribute", { value: function(e, n) {
  Prism.languages.markup.tag.inside["special-attr"].push({ pattern: RegExp(/(^|["'\s])/.source + "(?:" + e + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"), lookbehind: true, inside: { "attr-name": /^[^\s=]+/, "attr-value": { pattern: /=[\s\S]+/, inside: { value: { pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/, lookbehind: true, alias: [n, "language-" + n], inside: Prism.languages[n] }, punctuation: [{ pattern: /^=/, alias: "attr-equals" }, /"|'/] } } } });
} }), Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.xml = Prism.languages.extend("markup", {}), Prism.languages.ssml = Prism.languages.xml, Prism.languages.atom = Prism.languages.xml, Prism.languages.rss = Prism.languages.xml, function(e) {
  var n = { pattern: /\\[\\(){}[\]^$+*?|.]/, alias: "escape" }, t = /\\(?:x[\da-fA-F]{2}|u[\da-fA-F]{4}|u\{[\da-fA-F]+\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/, a = "(?:[^\\\\-]|" + t.source + ")", a = RegExp(a + "-" + a), r = { pattern: /(<|')[^<>']+(?=[>']$)/, lookbehind: true, alias: "variable" };
  e.languages.regex = { "char-class": { pattern: /((?:^|[^\\])(?:\\\\)*)\[(?:[^\\\]]|\\[\s\S])*\]/, lookbehind: true, inside: { "char-class-negation": { pattern: /(^\[)\^/, lookbehind: true, alias: "operator" }, "char-class-punctuation": { pattern: /^\[|\]$/, alias: "punctuation" }, range: { pattern: a, inside: { escape: t, "range-punctuation": { pattern: /-/, alias: "operator" } } }, "special-escape": n, "char-set": { pattern: /\\[wsd]|\\p\{[^{}]+\}/i, alias: "class-name" }, escape: t } }, "special-escape": n, "char-set": { pattern: /\.|\\[wsd]|\\p\{[^{}]+\}/i, alias: "class-name" }, backreference: [{ pattern: /\\(?![123][0-7]{2})[1-9]/, alias: "keyword" }, { pattern: /\\k<[^<>']+>/, alias: "keyword", inside: { "group-name": r } }], anchor: { pattern: /[$^]|\\[ABbGZz]/, alias: "function" }, escape: t, group: [{ pattern: /\((?:\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/, alias: "punctuation", inside: { "group-name": r } }, { pattern: /\)/, alias: "punctuation" }], quantifier: { pattern: /(?:[+*?]|\{\d+(?:,\d*)?\})[?+]?/, alias: "number" }, alternation: { pattern: /\|/, alias: "keyword" } };
}(Prism), Prism.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true, greedy: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/, boolean: /\b(?:false|true)\b/, function: /\b\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/, punctuation: /[{}[\];(),.:]/ }, Prism.languages.javascript = Prism.languages.extend("clike", { "class-name": [Prism.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/, lookbehind: true }], keyword: [{ pattern: /((?:^|\})\s*)catch\b/, lookbehind: true }, { pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, number: { pattern: RegExp(/(^|[^\w$])/.source + "(?:" + /NaN|Infinity/.source + "|" + /0[bB][01]+(?:_[01]+)*n?/.source + "|" + /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + /\d+(?:_\d+)*n/.source + "|" + /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source + ")" + /(?![\w$])/.source), lookbehind: true }, operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/ }), Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, Prism.languages.insertBefore("javascript", "keyword", { regex: { pattern: RegExp(/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source), lookbehind: true, greedy: true, inside: { "regex-source": { pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/, lookbehind: true, alias: "language-regex", inside: Prism.languages.regex }, "regex-delimiter": /^\/|\/$/, "regex-flags": /^[a-z]+$/ } }, "function-variable": { pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/, lookbehind: true, inside: Prism.languages.javascript }, { pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i, lookbehind: true, inside: Prism.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/, lookbehind: true, inside: Prism.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/, lookbehind: true, inside: Prism.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ }), Prism.languages.insertBefore("javascript", "string", { hashbang: { pattern: /^#!.*/, greedy: true, alias: "comment" }, "template-string": { pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/, greedy: true, inside: { "template-punctuation": { pattern: /^`|`$/, alias: "string" }, interpolation: { pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/, lookbehind: true, inside: { "interpolation-punctuation": { pattern: /^\$\{|\}$/, alias: "punctuation" }, rest: Prism.languages.javascript } }, string: /[\s\S]+/ } }, "string-property": { pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m, lookbehind: true, greedy: true, alias: "property" } }), Prism.languages.insertBefore("javascript", "operator", { "literal-property": { pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m, lookbehind: true, alias: "property" } }), Prism.languages.markup && (Prism.languages.markup.tag.addInlined("script", "javascript"), Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript")), Prism.languages.js = Prism.languages.javascript, Prism.languages.actionscript = Prism.languages.extend("javascript", { keyword: /\b(?:as|break|case|catch|class|const|default|delete|do|dynamic|each|else|extends|final|finally|for|function|get|if|implements|import|in|include|instanceof|interface|internal|is|namespace|native|new|null|override|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|use|var|void|while|with)\b/, operator: /\+\+|--|(?:[+\-*\/%^]|&&?|\|\|?|<<?|>>?>?|[!=]=?)=?|[~?@]/ }), Prism.languages.actionscript["class-name"].alias = "function", delete Prism.languages.actionscript.parameter, delete Prism.languages.actionscript["literal-property"], Prism.languages.markup && Prism.languages.insertBefore("actionscript", "string", { xml: { pattern: /(^|[^.])<\/?\w+(?:\s+[^\s>\/=]+=("|')(?:\\[\s\S]|(?!\2)[^\\])*\2)*\s*\/?>/, lookbehind: true, inside: Prism.languages.markup } }), function(e) {
  var n = /#(?!\{).+/, t = { pattern: /#\{[^}]+\}/, alias: "variable" };
  e.languages.coffeescript = e.languages.extend("javascript", { comment: n, string: [{ pattern: /'(?:\\[\s\S]|[^\\'])*'/, greedy: true }, { pattern: /"(?:\\[\s\S]|[^\\"])*"/, greedy: true, inside: { interpolation: t } }], keyword: /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/, "class-member": { pattern: /@(?!\d)\w+/, alias: "variable" } }), e.languages.insertBefore("coffeescript", "comment", { "multiline-comment": { pattern: /###[\s\S]+?###/, alias: "comment" }, "block-regex": { pattern: /\/{3}[\s\S]*?\/{3}/, alias: "regex", inside: { comment: n, interpolation: t } } }), e.languages.insertBefore("coffeescript", "string", { "inline-javascript": { pattern: /`(?:\\[\s\S]|[^\\`])*`/, inside: { delimiter: { pattern: /^`|`$/, alias: "punctuation" }, script: { pattern: /[\s\S]+/, alias: "language-javascript", inside: e.languages.javascript } } }, "multiline-string": [{ pattern: /'''[\s\S]*?'''/, greedy: true, alias: "string" }, { pattern: /"""[\s\S]*?"""/, greedy: true, alias: "string", inside: { interpolation: t } }] }), e.languages.insertBefore("coffeescript", "keyword", { property: /(?!\d)\w+(?=\s*:(?!:))/ }), delete e.languages.coffeescript["template-string"], e.languages.coffee = e.languages.coffeescript;
}(Prism), function(l) {
  var e = l.languages.javadoclike = { parameter: { pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*@(?:arg|arguments|param)\s+)\w+/m, lookbehind: true }, keyword: { pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*|\{)@[a-z][a-zA-Z-]+\b/m, lookbehind: true }, punctuation: /[{}]/ };
  Object.defineProperty(e, "addSupport", { value: function(e2, o) {
    (e2 = "string" == typeof e2 ? [e2] : e2).forEach(function(e3) {
      var n = function(e4) {
        e4.inside || (e4.inside = {}), e4.inside.rest = o;
      }, t = "doc-comment";
      if (a = l.languages[e3]) {
        var a, r = a[t];
        if ((r = r ? r : (a = l.languages.insertBefore(e3, "comment", { "doc-comment": { pattern: /(^|[^\\])\/\*\*[^/][\s\S]*?(?:\*\/|$)/, lookbehind: true, alias: "comment" } }))[t]) instanceof RegExp && (r = a[t] = { pattern: r }), Array.isArray(r))
          for (var s = 0, i = r.length; s < i; s++)
            r[s] instanceof RegExp && (r[s] = { pattern: r[s] }), n(r[s]);
        else
          n(r);
      }
    });
  } }), e.addSupport(["java", "javascript", "php"], e);
}(Prism), function(e) {
  var n = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/, n = (e.languages.css = { comment: /\/\*[\s\S]*?\*\//, atrule: { pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + n.source + ")*?" + /(?:;|(?=\s*\{))/.source), inside: { rule: /^@[\w-]+/, "selector-function-argument": { pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/, lookbehind: true, alias: "selector" }, keyword: { pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/, lookbehind: true } } }, url: { pattern: RegExp("\\burl\\((?:" + n.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"), greedy: true, inside: { function: /^url/i, punctuation: /^\(|\)$/, string: { pattern: RegExp("^" + n.source + "$"), alias: "url" } } }, selector: { pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + n.source + ")*(?=\\s*\\{)"), lookbehind: true }, string: { pattern: n, greedy: true }, property: { pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i, lookbehind: true }, important: /!important\b/i, function: { pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i, lookbehind: true }, punctuation: /[(){};:,]/ }, e.languages.css.atrule.inside.rest = e.languages.css, e.languages.markup);
  n && (n.tag.addInlined("style", "css"), n.tag.addAttribute("style", "css"));
}(Prism), function(e) {
  var n = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, n = (e.languages.css.selector = { pattern: e.languages.css.selector.pattern, lookbehind: true, inside: n = { "pseudo-element": /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/, "pseudo-class": /:[-\w]+/, class: /\.[-\w]+/, id: /#[-\w]+/, attribute: { pattern: RegExp(`\\[(?:[^[\\]"']|` + n.source + ")*\\]"), greedy: true, inside: { punctuation: /^\[|\]$/, "case-sensitivity": { pattern: /(\s)[si]$/i, lookbehind: true, alias: "keyword" }, namespace: { pattern: /^(\s*)(?:(?!\s)[-*\w\xA0-\uFFFF])*\|(?!=)/, lookbehind: true, inside: { punctuation: /\|$/ } }, "attr-name": { pattern: /^(\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+/, lookbehind: true }, "attr-value": [n, { pattern: /(=\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+(?=\s*$)/, lookbehind: true }], operator: /[|~*^$]?=/ } }, "n-th": [{ pattern: /(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/, lookbehind: true, inside: { number: /[\dn]+/, operator: /[+-]/ } }, { pattern: /(\(\s*)(?:even|odd)(?=\s*\))/i, lookbehind: true }], combinator: />|\+|~|\|\|/, punctuation: /[(),]/ } }, e.languages.css.atrule.inside["selector-function-argument"].inside = n, e.languages.insertBefore("css", "property", { variable: { pattern: /(^|[^-\w\xA0-\uFFFF])--(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*/i, lookbehind: true } }), { pattern: /(\b\d+)(?:%|[a-z]+(?![\w-]))/, lookbehind: true }), t = { pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/, lookbehind: true };
  e.languages.insertBefore("css", "function", { operator: { pattern: /(\s)[+\-*\/](?=\s)/, lookbehind: true }, hexcode: { pattern: /\B#[\da-f]{3,8}\b/i, alias: "color" }, color: [{ pattern: /(^|[^\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|RebeccaPurple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\w-])/i, lookbehind: true }, { pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i, inside: { unit: n, number: t, function: /[\w-]+(?=\()/, punctuation: /[(),]/ } }], entity: /\\[\da-f]{1,8}/i, unit: n, number: t });
}(Prism), function(e) {
  var n = /[*&][^\s[\]{},]+/, t = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/, a = "(?:" + t.source + "(?:[ 	]+" + n.source + ")?|" + n.source + "(?:[ 	]+" + t.source + ")?)", r = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
    return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
  }), s = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
  function i(e2, n2) {
    n2 = (n2 || "").replace(/m/g, "") + "m";
    var t2 = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
      return a;
    }).replace(/<<value>>/g, function() {
      return e2;
    });
    return RegExp(t2, n2);
  }
  e.languages.yaml = { scalar: { pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
    return a;
  })), lookbehind: true, alias: "string" }, comment: /#.*/, key: { pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
    return a;
  }).replace(/<<key>>/g, function() {
    return "(?:" + r + "|" + s + ")";
  })), lookbehind: true, greedy: true, alias: "atrule" }, directive: { pattern: /(^[ \t]*)%.+/m, lookbehind: true, alias: "important" }, datetime: { pattern: i(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source), lookbehind: true, alias: "number" }, boolean: { pattern: i(/false|true/.source, "i"), lookbehind: true, alias: "important" }, null: { pattern: i(/null|~/.source, "i"), lookbehind: true, alias: "important" }, string: { pattern: i(s), lookbehind: true, greedy: true }, number: { pattern: i(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"), lookbehind: true }, tag: t, important: n, punctuation: /---|[:[\]{}\-,|>?]|\.\.\./ }, e.languages.yml = e.languages.yaml;
}(Prism), function(o) {
  var n = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
  function e(e2) {
    return e2 = e2.replace(/<inner>/g, function() {
      return n;
    }), RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + e2 + ")");
  }
  var t = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source, a = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
    return t;
  }), r = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source, l = (o.languages.markdown = o.languages.extend("markup", {}), o.languages.insertBefore("markdown", "prolog", { "front-matter-block": { pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/, lookbehind: true, greedy: true, inside: { punctuation: /^---|---$/, "front-matter": { pattern: /\S+(?:\s+\S+)*/, alias: ["yaml", "language-yaml"], inside: o.languages.yaml } } }, blockquote: { pattern: /^>(?:[\t ]*>)*/m, alias: "punctuation" }, table: { pattern: RegExp("^" + a + r + "(?:" + a + ")*", "m"), inside: { "table-data-rows": { pattern: RegExp("^(" + a + r + ")(?:" + a + ")*$"), lookbehind: true, inside: { "table-data": { pattern: RegExp(t), inside: o.languages.markdown }, punctuation: /\|/ } }, "table-line": { pattern: RegExp("^(" + a + ")" + r + "$"), lookbehind: true, inside: { punctuation: /\||:?-{3,}:?/ } }, "table-header-row": { pattern: RegExp("^" + a + "$"), inside: { "table-header": { pattern: RegExp(t), alias: "important", inside: o.languages.markdown }, punctuation: /\|/ } } } }, code: [{ pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/, lookbehind: true, alias: "keyword" }, { pattern: /^```[\s\S]*?^```$/m, greedy: true, inside: { "code-block": { pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m, lookbehind: true }, "code-language": { pattern: /^(```).+/, lookbehind: true }, punctuation: /```/ } }], title: [{ pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m, alias: "important", inside: { punctuation: /==+$|--+$/ } }, { pattern: /(^\s*)#.+/m, lookbehind: true, alias: "important", inside: { punctuation: /^#+|#+$/ } }], hr: { pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m, lookbehind: true, alias: "punctuation" }, list: { pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m, lookbehind: true, alias: "punctuation" }, "url-reference": { pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/, inside: { variable: { pattern: /^(!?\[)[^\]]+/, lookbehind: true }, string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/, punctuation: /^[\[\]!:]|[<>]/ }, alias: "url" }, bold: { pattern: e(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source), lookbehind: true, greedy: true, inside: { content: { pattern: /(^..)[\s\S]+(?=..$)/, lookbehind: true, inside: {} }, punctuation: /\*\*|__/ } }, italic: { pattern: e(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source), lookbehind: true, greedy: true, inside: { content: { pattern: /(^.)[\s\S]+(?=.$)/, lookbehind: true, inside: {} }, punctuation: /[*_]/ } }, strike: { pattern: e(/(~~?)(?:(?!~)<inner>)+\2/.source), lookbehind: true, greedy: true, inside: { content: { pattern: /(^~~?)[\s\S]+(?=\1$)/, lookbehind: true, inside: {} }, punctuation: /~~?/ } }, "code-snippet": { pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/, lookbehind: true, greedy: true, alias: ["code", "keyword"] }, url: { pattern: e(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source), lookbehind: true, greedy: true, inside: { operator: /^!/, content: { pattern: /(^\[)[^\]]+(?=\])/, lookbehind: true, inside: {} }, variable: { pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/, lookbehind: true }, url: { pattern: /(^\]\()[^\s)]+/, lookbehind: true }, string: { pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/, lookbehind: true } } } }), ["url", "bold", "italic", "strike"].forEach(function(n2) {
    ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(e2) {
      n2 !== e2 && (o.languages.markdown[n2].inside.content.inside[e2] = o.languages.markdown[e2]);
    });
  }), o.hooks.add("after-tokenize", function(e2) {
    "markdown" !== e2.language && "md" !== e2.language || !function e3(n2) {
      if (n2 && "string" != typeof n2)
        for (var t2 = 0, a2 = n2.length; t2 < a2; t2++) {
          var r2, s = n2[t2];
          "code" !== s.type ? e3(s.content) : (r2 = s.content[1], s = s.content[3], r2 && s && "code-language" === r2.type && "code-block" === s.type && "string" == typeof r2.content && (r2 = r2.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp"), r2 = "language-" + (r2 = (/[a-z][\w-]*/i.exec(r2) || [""])[0].toLowerCase()), s.alias ? "string" == typeof s.alias ? s.alias = [s.alias, r2] : s.alias.push(r2) : s.alias = [r2]));
        }
    }(e2.tokens);
  }), o.hooks.add("wrap", function(e2) {
    if ("code-block" === e2.type) {
      for (var n2 = "", t2 = 0, a2 = e2.classes.length; t2 < a2; t2++) {
        var r2 = e2.classes[t2], r2 = /language-(.+)/.exec(r2);
        if (r2) {
          n2 = r2[1];
          break;
        }
      }
      var s, i = o.languages[n2];
      i ? e2.content = o.highlight(function(e3) {
        e3 = e3.replace(l, "");
        return e3 = e3.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(e4, n3) {
          var t3;
          return "#" === (n3 = n3.toLowerCase())[0] ? (t3 = "x" === n3[1] ? parseInt(n3.slice(2), 16) : Number(n3.slice(1)), c(t3)) : u[n3] || e4;
        });
      }(e2.content), i, n2) : n2 && "none" !== n2 && o.plugins.autoloader && (s = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(1e16 * Math.random()), e2.attributes.id = s, o.plugins.autoloader.loadLanguages(n2, function() {
        var e3 = document.getElementById(s);
        e3 && (e3.innerHTML = o.highlight(e3.textContent, o.languages[n2], n2));
      }));
    }
  }), RegExp(o.languages.markup.tag.pattern.source, "gi")), u = { amp: "&", lt: "<", gt: ">", quot: '"' }, c = String.fromCodePoint || String.fromCharCode;
  o.languages.md = o.languages.markdown;
}(Prism), Prism.languages.graphql = { comment: /#.*/, description: { pattern: /(?:"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*")(?=\s*[a-z_])/i, greedy: true, alias: "string", inside: { "language-markdown": { pattern: /(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/, lookbehind: true, inside: Prism.languages.markdown } } }, string: { pattern: /"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*"/, greedy: true }, number: /(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i, boolean: /\b(?:false|true)\b/, variable: /\$[a-z_]\w*/i, directive: { pattern: /@[a-z_]\w*/i, alias: "function" }, "attr-name": { pattern: /\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\"\r\n])*")*\))?:)/i, greedy: true }, "atom-input": { pattern: /\b[A-Z]\w*Input\b/, alias: "class-name" }, scalar: /\b(?:Boolean|Float|ID|Int|String)\b/, constant: /\b[A-Z][A-Z_\d]*\b/, "class-name": { pattern: /(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/, lookbehind: true }, fragment: { pattern: /(\bfragment\s+|\.{3}\s*(?!on\b))[a-zA-Z_]\w*/, lookbehind: true, alias: "function" }, "definition-mutation": { pattern: /(\bmutation\s+)[a-zA-Z_]\w*/, lookbehind: true, alias: "function" }, "definition-query": { pattern: /(\bquery\s+)[a-zA-Z_]\w*/, lookbehind: true, alias: "function" }, keyword: /\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/, operator: /[!=|&]|\.{3}/, "property-query": /\w+(?=\s*\()/, object: /\w+(?=\s*\{)/, punctuation: /[!(){}\[\]:=,]/, property: /\w+/ }, Prism.hooks.add("after-tokenize", function(e) {
  if ("graphql" === e.language)
    for (var i = e.tokens.filter(function(e2) {
      return "string" != typeof e2 && "comment" !== e2.type && "scalar" !== e2.type;
    }), o = 0; o < i.length; ) {
      var n = i[o++];
      if ("keyword" === n.type && "mutation" === n.content) {
        var t = [];
        if (p(["definition-mutation", "punctuation"]) && "(" === c(1).content) {
          o += 2;
          var a = d(/^\($/, /^\)$/);
          if (-1 === a)
            continue;
          for (; o < a; o++) {
            var r = c(0);
            "variable" === r.type && (g(r, "variable-input"), t.push(r.content));
          }
          o = a + 1;
        }
        if (p(["punctuation", "property-query"]) && "{" === c(0).content && (o++, g(c(0), "property-mutation"), 0 < t.length)) {
          var s = d(/^\{$/, /^\}$/);
          if (-1 !== s)
            for (var l = o; l < s; l++) {
              var u = i[l];
              "variable" === u.type && 0 <= t.indexOf(u.content) && g(u, "variable-input");
            }
        }
      }
    }
  function c(e2) {
    return i[o + e2];
  }
  function p(e2, n2) {
    n2 = n2 || 0;
    for (var t2 = 0; t2 < e2.length; t2++) {
      var a2 = c(t2 + n2);
      if (!a2 || a2.type !== e2[t2])
        return;
    }
    return 1;
  }
  function d(e2, n2) {
    for (var t2 = 1, a2 = o; a2 < i.length; a2++) {
      var r2 = i[a2], s2 = r2.content;
      if ("punctuation" === r2.type && "string" == typeof s2) {
        if (e2.test(s2))
          t2++;
        else if (n2.test(s2) && 0 === --t2)
          return a2;
      }
    }
    return -1;
  }
  function g(e2, n2) {
    var t2 = e2.alias;
    t2 ? Array.isArray(t2) || (e2.alias = t2 = [t2]) : e2.alias = t2 = [], t2.push(n2);
  }
}), Prism.languages.sql = { comment: { pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/, lookbehind: true }, variable: [{ pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/, greedy: true }, /@[\w.$]+/], string: { pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/, greedy: true, lookbehind: true }, identifier: { pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/, greedy: true, lookbehind: true, inside: { punctuation: /^`|`$/ } }, function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i, keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i, boolean: /\b(?:FALSE|NULL|TRUE)\b/i, number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i, operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i, punctuation: /[;[\]()`,.]/ }, function(b) {
  var e = b.languages.javascript["template-string"], t = e.pattern.source, m = e.inside.interpolation, f = m.inside["interpolation-punctuation"], s = m.pattern.source;
  function n(e2, n2) {
    if (b.languages[e2])
      return { pattern: RegExp("((?:" + n2 + ")\\s*)" + t), lookbehind: true, greedy: true, inside: { "template-punctuation": { pattern: /^`|`$/, alias: "string" }, "embedded-code": { pattern: /[\s\S]+/, alias: e2 } } };
  }
  function h(e2, n2, t2) {
    e2 = { code: e2, grammar: n2, language: t2 };
    return b.hooks.run("before-tokenize", e2), e2.tokens = b.tokenize(e2.code, e2.grammar), b.hooks.run("after-tokenize", e2), e2.tokens;
  }
  function l(a2, e2, r) {
    var n2 = b.tokenize(a2, { interpolation: { pattern: RegExp(s), lookbehind: true } }), p = 0, d = {}, n2 = h(n2.map(function(e3) {
      if ("string" == typeof e3)
        return e3;
      for (var n3, t2, e3 = e3.content; -1 !== a2.indexOf((t2 = p++, n3 = "___" + r.toUpperCase() + "_" + t2 + "___")); )
        ;
      return d[n3] = e3, n3;
    }).join(""), e2, r), g = Object.keys(d);
    return p = 0, function e3(n3) {
      for (var t2 = 0; t2 < n3.length; t2++) {
        if (p >= g.length)
          return;
        var a3, r2, s2, i, o, l2, u2, c = n3[t2];
        "string" == typeof c || "string" == typeof c.content ? (a3 = g[p], -1 !== (u2 = (l2 = "string" == typeof c ? c : c.content).indexOf(a3)) && (++p, r2 = l2.substring(0, u2), o = d[a3], s2 = void 0, (i = {})["interpolation-punctuation"] = f, 3 === (i = b.tokenize(o, i)).length && ((s2 = [1, 1]).push.apply(s2, h(i[1], b.languages.javascript, "javascript")), i.splice.apply(i, s2)), s2 = new b.Token("interpolation", i, m.alias, o), i = l2.substring(u2 + a3.length), o = [], r2 && o.push(r2), o.push(s2), i && (e3(l2 = [i]), o.push.apply(o, l2)), "string" == typeof c ? (n3.splice.apply(n3, [t2, 1].concat(o)), t2 += o.length - 1) : c.content = o)) : (u2 = c.content, Array.isArray(u2) ? e3(u2) : e3([u2]));
      }
    }(n2), new b.Token(r, n2, "language-" + r, a2);
  }
  b.languages.javascript["template-string"] = [n("css", /\b(?:styled(?:\([^)]*\))?(?:\s*\.\s*\w+(?:\([^)]*\))*)*|css(?:\s*\.\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source), n("html", /\bhtml|\.\s*(?:inner|outer)HTML\s*\+?=/.source), n("svg", /\bsvg/.source), n("markdown", /\b(?:markdown|md)/.source), n("graphql", /\b(?:gql|graphql(?:\s*\.\s*experimental)?)/.source), n("sql", /\bsql/.source), e].filter(Boolean);
  var a = { javascript: true, js: true, typescript: true, ts: true, jsx: true, tsx: true };
  function u(e2) {
    return "string" == typeof e2 ? e2 : Array.isArray(e2) ? e2.map(u).join("") : u(e2.content);
  }
  b.hooks.add("after-tokenize", function(e2) {
    e2.language in a && !function e3(n2) {
      for (var t2 = 0, a2 = n2.length; t2 < a2; t2++) {
        var r, s2, i, o = n2[t2];
        "string" != typeof o && (r = o.content, Array.isArray(r) ? "template-string" === o.type ? (o = r[1], 3 === r.length && "string" != typeof o && "embedded-code" === o.type && (s2 = u(o), o = o.alias, o = Array.isArray(o) ? o[0] : o, i = b.languages[o]) && (r[1] = l(s2, i, o))) : e3(r) : "string" != typeof r && e3([r]));
      }
    }(e2.tokens);
  });
}(Prism), function(e) {
  e.languages.typescript = e.languages.extend("javascript", { "class-name": { pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/, lookbehind: true, greedy: true, inside: null }, builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/ }), e.languages.typescript.keyword.push(/\b(?:abstract|declare|is|keyof|readonly|require)\b/, /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/, /\btype\b(?=\s*(?:[\{*]|$))/), delete e.languages.typescript.parameter, delete e.languages.typescript["literal-property"];
  var n = e.languages.extend("typescript", {});
  delete n["class-name"], e.languages.typescript["class-name"].inside = n, e.languages.insertBefore("typescript", "function", { decorator: { pattern: /@[$\w\xA0-\uFFFF]+/, inside: { at: { pattern: /^@/, alias: "operator" }, function: /^[\s\S]+/ } }, "generic-function": { pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/, greedy: true, inside: { function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/, generic: { pattern: /<[\s\S]+/, alias: "class-name", inside: n } } } }), e.languages.ts = e.languages.typescript;
}(Prism), function(e) {
  var n = e.languages.javascript, t = /\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})+\}/.source, a = "(@(?:arg|argument|param|property)\\s+(?:" + t + "\\s+)?)";
  e.languages.jsdoc = e.languages.extend("javadoclike", { parameter: { pattern: RegExp(a + /(?:(?!\s)[$\w\xA0-\uFFFF.])+(?=\s|$)/.source), lookbehind: true, inside: { punctuation: /\./ } } }), e.languages.insertBefore("jsdoc", "keyword", { "optional-parameter": { pattern: RegExp(a + /\[(?:(?!\s)[$\w\xA0-\uFFFF.])+(?:=[^[\]]+)?\](?=\s|$)/.source), lookbehind: true, inside: { parameter: { pattern: /(^\[)[$\w\xA0-\uFFFF\.]+/, lookbehind: true, inside: { punctuation: /\./ } }, code: { pattern: /(=)[\s\S]*(?=\]$)/, lookbehind: true, inside: n, alias: "language-javascript" }, punctuation: /[=[\]]/ } }, "class-name": [{ pattern: RegExp(/(@(?:augments|class|extends|interface|memberof!?|template|this|typedef)\s+(?:<TYPE>\s+)?)[A-Z]\w*(?:\.[A-Z]\w*)*/.source.replace(/<TYPE>/g, function() {
    return t;
  })), lookbehind: true, inside: { punctuation: /\./ } }, { pattern: RegExp("(@[a-z]+\\s+)" + t), lookbehind: true, inside: { string: n.string, number: n.number, boolean: n.boolean, keyword: e.languages.typescript.keyword, operator: /=>|\.\.\.|[&|?:*]/, punctuation: /[.,;=<>{}()[\]]/ } }], example: { pattern: /(@example\s+(?!\s))(?:[^@\s]|\s+(?!\s))+?(?=\s*(?:\*\s*)?(?:@\w|\*\/))/, lookbehind: true, inside: { code: { pattern: /^([\t ]*(?:\*\s*)?)\S.*$/m, lookbehind: true, inside: n, alias: "language-javascript" } } } }), e.languages.javadoclike.addSupport("javascript", e.languages.jsdoc);
}(Prism), function(e) {
  e.languages.flow = e.languages.extend("javascript", {}), e.languages.insertBefore("flow", "keyword", { type: [{ pattern: /\b(?:[Bb]oolean|Function|[Nn]umber|[Ss]tring|[Ss]ymbol|any|mixed|null|void)\b/, alias: "class-name" }] }), e.languages.flow["function-variable"].pattern = /(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=\s*(?:function\b|(?:\([^()]*\)(?:\s*:\s*\w+)?|(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/i, delete e.languages.flow.parameter, e.languages.insertBefore("flow", "operator", { "flow-punctuation": { pattern: /\{\||\|\}/, alias: "punctuation" } }), Array.isArray(e.languages.flow.keyword) || (e.languages.flow.keyword = [e.languages.flow.keyword]), e.languages.flow.keyword.unshift({ pattern: /(^|[^$]\b)(?:Class|declare|opaque|type)\b(?!\$)/, lookbehind: true }, { pattern: /(^|[^$]\B)\$(?:Diff|Enum|Exact|Keys|ObjMap|PropertyType|Record|Shape|Subtype|Supertype|await)\b(?!\$)/, lookbehind: true });
}(Prism), Prism.languages.n4js = Prism.languages.extend("javascript", { keyword: /\b(?:Array|any|boolean|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|module|new|null|number|package|private|protected|public|return|set|static|string|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/ }), Prism.languages.insertBefore("n4js", "constant", { annotation: { pattern: /@+\w+/, alias: "operator" } }), Prism.languages.n4jsd = Prism.languages.n4js, function(e) {
  function n(e2, n2) {
    return RegExp(e2.replace(/<ID>/g, function() {
      return /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/.source;
    }), n2);
  }
  e.languages.insertBefore("javascript", "function-variable", { "method-variable": { pattern: RegExp("(\\.\\s*)" + e.languages.javascript["function-variable"].pattern.source), lookbehind: true, alias: ["function-variable", "method", "function", "property-access"] } }), e.languages.insertBefore("javascript", "function", { method: { pattern: RegExp("(\\.\\s*)" + e.languages.javascript.function.source), lookbehind: true, alias: ["function", "property-access"] } }), e.languages.insertBefore("javascript", "constant", { "known-class-name": [{ pattern: /\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\b/, alias: "class-name" }, { pattern: /\b(?:[A-Z]\w*)Error\b/, alias: "class-name" }] }), e.languages.insertBefore("javascript", "keyword", { imports: { pattern: n(/(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/.source), lookbehind: true, inside: e.languages.javascript }, exports: { pattern: n(/(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/.source), lookbehind: true, inside: e.languages.javascript } }), e.languages.javascript.keyword.unshift({ pattern: /\b(?:as|default|export|from|import)\b/, alias: "module" }, { pattern: /\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/, alias: "control-flow" }, { pattern: /\bnull\b/, alias: ["null", "nil"] }, { pattern: /\bundefined\b/, alias: "nil" }), e.languages.insertBefore("javascript", "operator", { spread: { pattern: /\.{3}/, alias: "operator" }, arrow: { pattern: /=>/, alias: "operator" } }), e.languages.insertBefore("javascript", "punctuation", { "property-access": { pattern: n(/(\.\s*)#?<ID>/.source), lookbehind: true }, "maybe-class-name": { pattern: /(^|[^$\w\xA0-\uFFFF])[A-Z][$\w\xA0-\uFFFF]+/, lookbehind: true }, dom: { pattern: /\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\b/, alias: "variable" }, console: { pattern: /\bconsole(?=\s*\.)/, alias: "class-name" } });
  for (var t = ["function", "function-variable", "method", "method-variable", "property-access"], a = 0; a < t.length; a++) {
    var r = t[a], s = e.languages.javascript[r], r = (s = "RegExp" === e.util.type(s) ? e.languages.javascript[r] = { pattern: s } : s).inside || {};
    (s.inside = r)["maybe-class-name"] = /^[A-Z][\s\S]*/;
  }
}(Prism), function(s) {
  var e = s.util.clone(s.languages.javascript), t = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source, a = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source, r = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
  function n(e2, n2) {
    return e2 = e2.replace(/<S>/g, function() {
      return t;
    }).replace(/<BRACES>/g, function() {
      return a;
    }).replace(/<SPREAD>/g, function() {
      return r;
    }), RegExp(e2, n2);
  }
  r = n(r).source, s.languages.jsx = s.languages.extend("markup", e), s.languages.jsx.tag.pattern = n(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source), s.languages.jsx.tag.inside.tag.pattern = /^<\/?[^\s>\/]*/, s.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/, s.languages.jsx.tag.inside.tag.inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/, s.languages.jsx.tag.inside.comment = e.comment, s.languages.insertBefore("inside", "attr-name", { spread: { pattern: n(/<SPREAD>/.source), inside: s.languages.jsx } }, s.languages.jsx.tag), s.languages.insertBefore("inside", "special-attr", { script: { pattern: n(/=<BRACES>/.source), alias: "language-javascript", inside: { "script-punctuation": { pattern: /^=(?=\{)/, alias: "punctuation" }, rest: s.languages.jsx } } }, s.languages.jsx.tag);
  function i(e2) {
    for (var n2 = [], t2 = 0; t2 < e2.length; t2++) {
      var a2 = e2[t2], r2 = false;
      "string" != typeof a2 && ("tag" === a2.type && a2.content[0] && "tag" === a2.content[0].type ? "</" === a2.content[0].content[0].content ? 0 < n2.length && n2[n2.length - 1].tagName === o(a2.content[0].content[1]) && n2.pop() : "/>" !== a2.content[a2.content.length - 1].content && n2.push({ tagName: o(a2.content[0].content[1]), openedBraces: 0 }) : 0 < n2.length && "punctuation" === a2.type && "{" === a2.content ? n2[n2.length - 1].openedBraces++ : 0 < n2.length && 0 < n2[n2.length - 1].openedBraces && "punctuation" === a2.type && "}" === a2.content ? n2[n2.length - 1].openedBraces-- : r2 = true), (r2 || "string" == typeof a2) && 0 < n2.length && 0 === n2[n2.length - 1].openedBraces && (r2 = o(a2), t2 < e2.length - 1 && ("string" == typeof e2[t2 + 1] || "plain-text" === e2[t2 + 1].type) && (r2 += o(e2[t2 + 1]), e2.splice(t2 + 1, 1)), 0 < t2 && ("string" == typeof e2[t2 - 1] || "plain-text" === e2[t2 - 1].type) && (r2 = o(e2[t2 - 1]) + r2, e2.splice(t2 - 1, 1), t2--), e2[t2] = new s.Token("plain-text", r2, null, r2)), a2.content && "string" != typeof a2.content && i(a2.content);
    }
  }
  var o = function(e2) {
    return e2 ? "string" == typeof e2 ? e2 : "string" == typeof e2.content ? e2.content : e2.content.map(o).join("") : "";
  };
  s.hooks.add("after-tokenize", function(e2) {
    "jsx" !== e2.language && "tsx" !== e2.language || i(e2.tokens);
  });
}(Prism), function(e) {
  var n = e.util.clone(e.languages.typescript), n = (e.languages.tsx = e.languages.extend("jsx", n), delete e.languages.tsx.parameter, delete e.languages.tsx["literal-property"], e.languages.tsx.tag);
  n.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + "(?:" + n.pattern.source + ")", n.pattern.flags), n.lookbehind = true;
}(Prism), Prism.languages.swift = { comment: { pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/, lookbehind: true, greedy: true }, "string-literal": [{ pattern: RegExp(/(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source), lookbehind: true, greedy: true, inside: { interpolation: { pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/, lookbehind: true, inside: null }, "interpolation-punctuation": { pattern: /^\)|\\\($/, alias: "punctuation" }, punctuation: /\\(?=[\r\n])/, string: /[\s\S]+/ } }, { pattern: RegExp(/(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"), lookbehind: true, greedy: true, inside: { interpolation: { pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/, lookbehind: true, inside: null }, "interpolation-punctuation": { pattern: /^\)|\\#+\($/, alias: "punctuation" }, string: /[\s\S]+/ } }], directive: { pattern: RegExp(/#/.source + "(?:" + /(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+|" + /(?:else|endif)\b/.source + ")"), alias: "property", inside: { "directive-name": /^#\w+/, boolean: /\b(?:false|true)\b/, number: /\b\d+(?:\.\d+)*\b/, operator: /!|&&|\|\||[<>]=?/, punctuation: /[(),]/ } }, literal: { pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/, alias: "constant" }, "other-directive": { pattern: /#\w+\b/, alias: "property" }, attribute: { pattern: /@\w+/, alias: "atrule" }, "function-definition": { pattern: /(\bfunc\s+)\w+/, lookbehind: true, alias: "function" }, label: { pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/, lookbehind: true, alias: "important" }, keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/, boolean: /\b(?:false|true)\b/, nil: { pattern: /\bnil\b/, alias: "constant" }, "short-argument": /\$\d+\b/, omit: { pattern: /\b_\b/, alias: "keyword" }, number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i, "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/, function: /\b[a-z_]\w*(?=\s*\()/i, constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/, operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/, punctuation: /[{}[\]();,.:\\]/ }, Prism.languages.swift["string-literal"].forEach(function(e) {
  e.inside.interpolation.inside = Prism.languages.swift;
}), function(e) {
  e.languages.kotlin = e.languages.extend("clike", { keyword: { pattern: /(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/, lookbehind: true }, function: [{ pattern: /(?:`[^\r\n`]+`|\b\w+)(?=\s*\()/, greedy: true }, { pattern: /(\.)(?:`[^\r\n`]+`|\w+)(?=\s*\{)/, lookbehind: true, greedy: true }], number: /\b(?:0[xX][\da-fA-F]+(?:_[\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/, operator: /\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/ }), delete e.languages.kotlin["class-name"];
  var n = { "interpolation-punctuation": { pattern: /^\$\{?|\}$/, alias: "punctuation" }, expression: { pattern: /[\s\S]+/, inside: e.languages.kotlin } };
  e.languages.insertBefore("kotlin", "string", { "string-literal": [{ pattern: /"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/, alias: "multiline", inside: { interpolation: { pattern: /\$(?:[a-z_]\w*|\{[^{}]*\})/i, inside: n }, string: /[\s\S]+/ } }, { pattern: /"(?:[^"\\\r\n$]|\\.|\$(?:(?!\{)|\{[^{}]*\}))*"/, alias: "singleline", inside: { interpolation: { pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:[a-z_]\w*|\{[^{}]*\})/i, lookbehind: true, inside: n }, string: /[\s\S]+/ } }], char: { pattern: /'(?:[^'\\\r\n]|\\(?:.|u[a-fA-F0-9]{0,4}))'/, greedy: true } }), delete e.languages.kotlin.string, e.languages.insertBefore("kotlin", "keyword", { annotation: { pattern: /\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/, alias: "builtin" } }), e.languages.insertBefore("kotlin", "function", { label: { pattern: /\b\w+@|@\w+\b/, alias: "symbol" } }), e.languages.kt = e.languages.kotlin, e.languages.kts = e.languages.kotlin;
}(Prism), Prism.languages.c = Prism.languages.extend("clike", { comment: { pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/, greedy: true }, string: { pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/, greedy: true }, "class-name": { pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/, lookbehind: true }, keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/, function: /\b[a-z_]\w*(?=\s*\()/i, number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i, operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/ }), Prism.languages.insertBefore("c", "string", { char: { pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/, greedy: true } }), Prism.languages.insertBefore("c", "string", { macro: { pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im, lookbehind: true, greedy: true, alias: "property", inside: { string: [{ pattern: /^(#\s*include\s*)<[^>]+>/, lookbehind: true }, Prism.languages.c.string], char: Prism.languages.c.char, comment: Prism.languages.c.comment, "macro-name": [{ pattern: /(^#\s*define\s+)\w+\b(?!\()/i, lookbehind: true }, { pattern: /(^#\s*define\s+)\w+\b(?=\()/i, lookbehind: true, alias: "function" }], directive: { pattern: /^(#\s*)[a-z]+/, lookbehind: true, alias: "keyword" }, "directive-hash": /^#/, punctuation: /##|\\(?=[\r\n])/, expression: { pattern: /\S[\s\S]*/, inside: Prism.languages.c } } } }), Prism.languages.insertBefore("c", "function", { constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/ }), delete Prism.languages.c.boolean, Prism.languages.objectivec = Prism.languages.extend("c", { string: { pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/, greedy: true }, keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/, operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/ }), delete Prism.languages.objectivec["class-name"], Prism.languages.objc = Prism.languages.objectivec, Prism.languages.reason = Prism.languages.extend("clike", { string: { pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/, greedy: true }, "class-name": /\b[A-Z]\w*/, keyword: /\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\b/, operator: /\.{3}|:[:=]|\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\-*\/]\.?|\b(?:asr|land|lor|lsl|lsr|lxor|mod)\b/ }), Prism.languages.insertBefore("reason", "class-name", { char: { pattern: /'(?:\\x[\da-f]{2}|\\o[0-3][0-7][0-7]|\\\d{3}|\\.|[^'\\\r\n])'/, greedy: true }, constructor: /\b[A-Z]\w*\b(?!\s*\.)/, label: { pattern: /\b[a-z]\w*(?=::)/, alias: "symbol" } }), delete Prism.languages.reason.function, function(e) {
  for (var n = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source, t = 0; t < 2; t++)
    n = n.replace(/<self>/g, function() {
      return n;
    });
  n = n.replace(/<self>/g, function() {
    return /[^\s\S]/.source;
  }), e.languages.rust = { comment: [{ pattern: RegExp(/(^|[^\\])/.source + n), lookbehind: true, greedy: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/, greedy: true }, char: { pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/, greedy: true }, attribute: { pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/, greedy: true, alias: "attr-name", inside: { string: null } }, "closure-params": { pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/, lookbehind: true, greedy: true, inside: { "closure-punctuation": { pattern: /^\||\|$/, alias: "punctuation" }, rest: null } }, "lifetime-annotation": { pattern: /'\w+/, alias: "symbol" }, "fragment-specifier": { pattern: /(\$\w+:)[a-z]+/, lookbehind: true, alias: "punctuation" }, variable: /\$\w+/, "function-definition": { pattern: /(\bfn\s+)\w+/, lookbehind: true, alias: "function" }, "type-definition": { pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/, lookbehind: true, alias: "class-name" }, "module-declaration": [{ pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/, lookbehind: true, alias: "namespace" }, { pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/, lookbehind: true, alias: "namespace", inside: { punctuation: /::/ } }], keyword: [/\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/, /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/], function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/, macro: { pattern: /\b\w+!/, alias: "property" }, constant: /\b[A-Z_][A-Z_\d]+\b/, "class-name": /\b[A-Z]\w*\b/, namespace: { pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/, inside: { punctuation: /::/ } }, number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/, boolean: /\b(?:false|true)\b/, punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/, operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/ }, e.languages.rust["closure-params"].inside.rest = e.languages.rust, e.languages.rust.attribute.inside.string = e.languages.rust.string;
}(Prism), Prism.languages.go = Prism.languages.extend("clike", { string: { pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/, lookbehind: true, greedy: true }, keyword: /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/, boolean: /\b(?:_|false|iota|nil|true)\b/, number: [/\b0(?:b[01_]+|o[0-7_]+)i?\b/i, /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i, /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i], operator: /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./, builtin: /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/ }), Prism.languages.insertBefore("go", "string", { char: { pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/, greedy: true } }), delete Prism.languages.go["class-name"], function(e) {
  var n = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, t = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
    return n.source;
  });
  e.languages.cpp = e.languages.extend("c", { "class-name": [{ pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
    return n.source;
  })), lookbehind: true }, /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/, /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i, /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/], keyword: n, number: { pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i, greedy: true }, operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/, boolean: /\b(?:false|true)\b/ }), e.languages.insertBefore("cpp", "string", { module: { pattern: RegExp(/(\b(?:import|module)\s+)/.source + "(?:" + /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
    return t;
  }) + ")"), lookbehind: true, greedy: true, inside: { string: /^[<"][\s\S]+/, operator: /:/, punctuation: /\./ } }, "raw-string": { pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/, alias: "string", greedy: true } }), e.languages.insertBefore("cpp", "keyword", { "generic-function": { pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i, inside: { function: /^\w+/, generic: { pattern: /<[\s\S]+/, alias: "class-name", inside: e.languages.cpp } } } }), e.languages.insertBefore("cpp", "operator", { "double-colon": { pattern: /::/, alias: "punctuation" } }), e.languages.insertBefore("cpp", "class-name", { "base-clause": { pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/, lookbehind: true, greedy: true, inside: e.languages.extend("cpp", {}) } }), e.languages.insertBefore("inside", "double-colon", { "class-name": /\b[a-z_]\w*\b(?!\s*::)/i }, e.languages.cpp["base-clause"]);
}(Prism), Prism.languages.python = { comment: { pattern: /(^|[^\\])#.*/, lookbehind: true, greedy: true }, "string-interpolation": { pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i, greedy: true, inside: { interpolation: { pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/, lookbehind: true, inside: { "format-spec": { pattern: /(:)[^:(){}]+(?=\}$)/, lookbehind: true }, "conversion-option": { pattern: /![sra](?=[:}]$)/, alias: "punctuation" }, rest: null } }, string: /[\s\S]+/ } }, "triple-quoted-string": { pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i, greedy: true, alias: "string" }, string: { pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i, greedy: true }, function: { pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g, lookbehind: true }, "class-name": { pattern: /(\bclass\s+)\w+/i, lookbehind: true }, decorator: { pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m, lookbehind: true, alias: ["annotation", "punctuation"], inside: { punctuation: /\./ } }, keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/, builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/, boolean: /\b(?:False|None|True)\b/, number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i, operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/, punctuation: /[{}[\];(),.:]/ }, Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest = Prism.languages.python, Prism.languages.py = Prism.languages.python, Prism.languages.json = { property: { pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/, lookbehind: true, greedy: true }, string: { pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/, lookbehind: true, greedy: true }, comment: { pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/, greedy: true }, number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i, punctuation: /[{}[\],]/, operator: /:/, boolean: /\b(?:false|true)\b/, null: { pattern: /\bnull\b/, alias: "keyword" } }, Prism.languages.webmanifest = Prism.languages.json;

// src/themes/index.ts
var themes_exports = {};
__export(themes_exports, {
  dracula: () => dracula_default,
  duotoneDark: () => duotoneDark_default,
  duotoneLight: () => duotoneLight_default,
  github: () => github_default,
  gruvboxMaterialDark: () => gruvboxMaterialDark_default,
  gruvboxMaterialLight: () => gruvboxMaterialLight_default,
  jettwaveDark: () => jettwaveDark_default,
  jettwaveLight: () => jettwaveLight_default,
  nightOwl: () => nightOwl_default,
  nightOwlLight: () => nightOwlLight_default,
  oceanicNext: () => oceanicNext_default,
  okaidia: () => okaidia_default,
  oneDark: () => oneDark_default,
  oneLight: () => oneLight_default,
  palenight: () => palenight_default,
  shadesOfPurple: () => shadesOfPurple_default,
  synthwave84: () => synthwave84_default,
  ultramin: () => ultramin_default,
  vsDark: () => vsDark_default,
  vsLight: () => vsLight_default
});

// src/themes/dracula.ts
var theme = {
  plain: {
    color: "#F8F8F2",
    backgroundColor: "#282A36"
  },
  styles: [
    {
      types: ["prolog", "constant", "builtin"],
      style: {
        color: "rgb(189, 147, 249)"
      }
    },
    {
      types: ["inserted", "function"],
      style: {
        color: "rgb(80, 250, 123)"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "rgb(255, 85, 85)"
      }
    },
    {
      types: ["changed"],
      style: {
        color: "rgb(255, 184, 108)"
      }
    },
    {
      types: ["punctuation", "symbol"],
      style: {
        color: "rgb(248, 248, 242)"
      }
    },
    {
      types: ["string", "char", "tag", "selector"],
      style: {
        color: "rgb(255, 121, 198)"
      }
    },
    {
      types: ["keyword", "variable"],
      style: {
        color: "rgb(189, 147, 249)",
        fontStyle: "italic"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(98, 114, 164)"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "rgb(241, 250, 140)"
      }
    }
  ]
};
var dracula_default = theme;

// src/themes/duotoneDark.ts
var theme2 = {
  plain: {
    backgroundColor: "#2a2734",
    color: "#9a86fd"
  },
  styles: [
    {
      types: ["comment", "prolog", "doctype", "cdata", "punctuation"],
      style: {
        color: "#6c6783"
      }
    },
    {
      types: ["namespace"],
      style: {
        opacity: 0.7
      }
    },
    {
      types: ["tag", "operator", "number"],
      style: {
        color: "#e09142"
      }
    },
    {
      types: ["property", "function"],
      style: {
        color: "#9a86fd"
      }
    },
    {
      types: ["tag-id", "selector", "atrule-id"],
      style: {
        color: "#eeebff"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "#c4b9fe"
      }
    },
    {
      types: [
        "boolean",
        "string",
        "entity",
        "url",
        "attr-value",
        "keyword",
        "control",
        "directive",
        "unit",
        "statement",
        "regex",
        "atrule",
        "placeholder",
        "variable"
      ],
      style: {
        color: "#ffcc99"
      }
    },
    {
      types: ["deleted"],
      style: {
        textDecorationLine: "line-through"
      }
    },
    {
      types: ["inserted"],
      style: {
        textDecorationLine: "underline"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["important"],
      style: {
        color: "#c4b9fe"
      }
    }
  ]
};
var duotoneDark_default = theme2;

// src/themes/duotoneLight.ts
var theme3 = {
  plain: {
    backgroundColor: "#faf8f5",
    color: "#728fcb"
  },
  styles: [
    {
      types: ["comment", "prolog", "doctype", "cdata", "punctuation"],
      style: {
        color: "#b6ad9a"
      }
    },
    {
      types: ["namespace"],
      style: {
        opacity: 0.7
      }
    },
    {
      types: ["tag", "operator", "number"],
      style: {
        color: "#063289"
      }
    },
    {
      types: ["property", "function"],
      style: {
        color: "#b29762"
      }
    },
    {
      types: ["tag-id", "selector", "atrule-id"],
      style: {
        color: "#2d2006"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "#896724"
      }
    },
    {
      types: [
        "boolean",
        "string",
        "entity",
        "url",
        "attr-value",
        "keyword",
        "control",
        "directive",
        "unit",
        "statement",
        "regex",
        "atrule"
      ],
      style: {
        color: "#728fcb"
      }
    },
    {
      types: ["placeholder", "variable"],
      style: {
        color: "#93abdc"
      }
    },
    {
      types: ["deleted"],
      style: {
        textDecorationLine: "line-through"
      }
    },
    {
      types: ["inserted"],
      style: {
        textDecorationLine: "underline"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["important"],
      style: {
        color: "#896724"
      }
    }
  ]
};
var duotoneLight_default = theme3;

// src/themes/github.ts
var theme4 = {
  plain: {
    color: "#393A34",
    backgroundColor: "#f6f8fa"
  },
  styles: [
    {
      types: ["comment", "prolog", "doctype", "cdata"],
      style: {
        color: "#999988",
        fontStyle: "italic"
      }
    },
    {
      types: ["namespace"],
      style: {
        opacity: 0.7
      }
    },
    {
      types: ["string", "attr-value"],
      style: {
        color: "#e3116c"
      }
    },
    {
      types: ["punctuation", "operator"],
      style: {
        color: "#393A34"
      }
    },
    {
      types: [
        "entity",
        "url",
        "symbol",
        "number",
        "boolean",
        "variable",
        "constant",
        "property",
        "regex",
        "inserted"
      ],
      style: {
        color: "#36acaa"
      }
    },
    {
      types: ["atrule", "keyword", "attr-name", "selector"],
      style: {
        color: "#00a4db"
      }
    },
    {
      types: ["function", "deleted", "tag"],
      style: {
        color: "#d73a49"
      }
    },
    {
      types: ["function-variable"],
      style: {
        color: "#6f42c1"
      }
    },
    {
      types: ["tag", "selector", "keyword"],
      style: {
        color: "#00009f"
      }
    }
  ]
};
var github_default = theme4;

// src/themes/nightOwl.ts
var theme5 = {
  plain: {
    color: "#d6deeb",
    backgroundColor: "#011627"
  },
  styles: [
    {
      types: ["changed"],
      style: {
        color: "rgb(162, 191, 252)",
        fontStyle: "italic"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "rgba(239, 83, 80, 0.56)",
        fontStyle: "italic"
      }
    },
    {
      types: ["inserted", "attr-name"],
      style: {
        color: "rgb(173, 219, 103)",
        fontStyle: "italic"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(99, 119, 119)",
        fontStyle: "italic"
      }
    },
    {
      types: ["string", "url"],
      style: {
        color: "rgb(173, 219, 103)"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "rgb(214, 222, 235)"
      }
    },
    {
      types: ["number"],
      style: {
        color: "rgb(247, 140, 108)"
      }
    },
    {
      types: ["builtin", "char", "constant", "function"],
      style: {
        color: "rgb(130, 170, 255)"
      }
    },
    {
      // This was manually added after the auto-generation
      // so that punctuations are not italicised
      types: ["punctuation"],
      style: {
        color: "rgb(199, 146, 234)"
      }
    },
    {
      types: ["selector", "doctype"],
      style: {
        color: "rgb(199, 146, 234)",
        fontStyle: "italic"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "rgb(255, 203, 139)"
      }
    },
    {
      types: ["tag", "operator", "keyword"],
      style: {
        color: "rgb(127, 219, 202)"
      }
    },
    {
      types: ["boolean"],
      style: {
        color: "rgb(255, 88, 116)"
      }
    },
    {
      types: ["property"],
      style: {
        color: "rgb(128, 203, 196)"
      }
    },
    {
      types: ["namespace"],
      style: {
        color: "rgb(178, 204, 214)"
      }
    }
  ]
};
var nightOwl_default = theme5;

// src/themes/nightOwlLight.ts
var theme6 = {
  plain: {
    color: "#403f53",
    backgroundColor: "#FBFBFB"
  },
  styles: [
    {
      types: ["changed"],
      style: {
        color: "rgb(162, 191, 252)",
        fontStyle: "italic"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "rgba(239, 83, 80, 0.56)",
        fontStyle: "italic"
      }
    },
    {
      types: ["inserted", "attr-name"],
      style: {
        color: "rgb(72, 118, 214)",
        fontStyle: "italic"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(152, 159, 177)",
        fontStyle: "italic"
      }
    },
    {
      types: ["string", "builtin", "char", "constant", "url"],
      style: {
        color: "rgb(72, 118, 214)"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "rgb(201, 103, 101)"
      }
    },
    {
      types: ["number"],
      style: {
        color: "rgb(170, 9, 130)"
      }
    },
    {
      // This was manually added after the auto-generation
      // so that punctuations are not italicised
      types: ["punctuation"],
      style: {
        color: "rgb(153, 76, 195)"
      }
    },
    {
      types: ["function", "selector", "doctype"],
      style: {
        color: "rgb(153, 76, 195)",
        fontStyle: "italic"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "rgb(17, 17, 17)"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "rgb(153, 76, 195)"
      }
    },
    {
      types: ["operator", "property", "keyword", "namespace"],
      style: {
        color: "rgb(12, 150, 155)"
      }
    },
    {
      types: ["boolean"],
      style: {
        color: "rgb(188, 84, 84)"
      }
    }
  ]
};
var nightOwlLight_default = theme6;

// src/themes/oceanicNext.ts
var colors = {
  char: "#D8DEE9",
  comment: "#999999",
  keyword: "#c5a5c5",
  primitive: "#5a9bcf",
  string: "#8dc891",
  variable: "#d7deea",
  boolean: "#ff8b50",
  punctuation: "#5FB3B3",
  tag: "#fc929e",
  function: "#79b6f2",
  className: "#FAC863",
  method: "#6699CC",
  operator: "#fc929e"
};
var theme7 = {
  plain: {
    backgroundColor: "#282c34",
    color: "#ffffff"
  },
  styles: [
    {
      types: ["attr-name"],
      style: {
        color: colors.keyword
      }
    },
    {
      types: ["attr-value"],
      style: {
        color: colors.string
      }
    },
    {
      types: [
        "comment",
        "block-comment",
        "prolog",
        "doctype",
        "cdata",
        "shebang"
      ],
      style: {
        color: colors.comment
      }
    },
    {
      types: [
        "property",
        "number",
        "function-name",
        "constant",
        "symbol",
        "deleted"
      ],
      style: {
        color: colors.primitive
      }
    },
    {
      types: ["boolean"],
      style: {
        color: colors.boolean
      }
    },
    {
      types: ["tag"],
      style: {
        color: colors.tag
      }
    },
    {
      types: ["string"],
      style: {
        color: colors.string
      }
    },
    {
      types: ["punctuation"],
      style: {
        color: colors.string
      }
    },
    {
      types: ["selector", "char", "builtin", "inserted"],
      style: {
        color: colors.char
      }
    },
    {
      types: ["function"],
      style: {
        color: colors.function
      }
    },
    {
      types: ["operator", "entity", "url", "variable"],
      style: {
        color: colors.variable
      }
    },
    {
      types: ["keyword"],
      style: {
        color: colors.keyword
      }
    },
    {
      types: ["atrule", "class-name"],
      style: {
        color: colors.className
      }
    },
    {
      types: ["important"],
      style: {
        fontWeight: "400"
      }
    },
    {
      types: ["bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["namespace"],
      style: {
        opacity: 0.7
      }
    }
  ]
};
var oceanicNext_default = theme7;

// src/themes/okaidia.ts
var theme8 = {
  plain: {
    color: "#f8f8f2",
    backgroundColor: "#272822"
  },
  styles: [
    {
      types: ["changed"],
      style: {
        color: "rgb(162, 191, 252)",
        fontStyle: "italic"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "#f92672",
        fontStyle: "italic"
      }
    },
    {
      types: ["inserted"],
      style: {
        color: "rgb(173, 219, 103)",
        fontStyle: "italic"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "#8292a2",
        fontStyle: "italic"
      }
    },
    {
      types: ["string", "url"],
      style: {
        color: "#a6e22e"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "#f8f8f2"
      }
    },
    {
      types: ["number"],
      style: {
        color: "#ae81ff"
      }
    },
    {
      types: ["builtin", "char", "constant", "function", "class-name"],
      style: {
        color: "#e6db74"
      }
    },
    {
      types: ["punctuation"],
      style: {
        color: "#f8f8f2"
      }
    },
    {
      types: ["selector", "doctype"],
      style: {
        color: "#a6e22e",
        fontStyle: "italic"
      }
    },
    {
      types: ["tag", "operator", "keyword"],
      style: {
        color: "#66d9ef"
      }
    },
    {
      types: ["boolean"],
      style: {
        color: "#ae81ff"
      }
    },
    {
      types: ["namespace"],
      style: {
        color: "rgb(178, 204, 214)",
        opacity: 0.7
      }
    },
    {
      types: ["tag", "property"],
      style: {
        color: "#f92672"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "#a6e22e !important"
      }
    },
    {
      types: ["doctype"],
      style: {
        color: "#8292a2"
      }
    },
    {
      types: ["rule"],
      style: {
        color: "#e6db74"
      }
    }
  ]
};
var okaidia_default = theme8;

// src/themes/palenight.ts
var theme9 = {
  plain: {
    color: "#bfc7d5",
    backgroundColor: "#292d3e"
  },
  styles: [
    {
      types: ["comment"],
      style: {
        color: "rgb(105, 112, 152)",
        fontStyle: "italic"
      }
    },
    {
      types: ["string", "inserted"],
      style: {
        color: "rgb(195, 232, 141)"
      }
    },
    {
      types: ["number"],
      style: {
        color: "rgb(247, 140, 108)"
      }
    },
    {
      types: ["builtin", "char", "constant", "function"],
      style: {
        color: "rgb(130, 170, 255)"
      }
    },
    {
      types: ["punctuation", "selector"],
      style: {
        color: "rgb(199, 146, 234)"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "rgb(191, 199, 213)"
      }
    },
    {
      types: ["class-name", "attr-name"],
      style: {
        color: "rgb(255, 203, 107)"
      }
    },
    {
      types: ["tag", "deleted"],
      style: {
        color: "rgb(255, 85, 114)"
      }
    },
    {
      types: ["operator"],
      style: {
        color: "rgb(137, 221, 255)"
      }
    },
    {
      types: ["boolean"],
      style: {
        color: "rgb(255, 88, 116)"
      }
    },
    {
      types: ["keyword"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["doctype"],
      style: {
        color: "rgb(199, 146, 234)",
        fontStyle: "italic"
      }
    },
    {
      types: ["namespace"],
      style: {
        color: "rgb(178, 204, 214)"
      }
    },
    {
      types: ["url"],
      style: {
        color: "rgb(221, 221, 221)"
      }
    }
  ]
};
var palenight_default = theme9;

// src/themes/shadesOfPurple.ts
var theme10 = {
  plain: {
    color: "#9EFEFF",
    backgroundColor: "#2D2A55"
  },
  styles: [
    {
      types: ["changed"],
      style: {
        color: "rgb(255, 238, 128)"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "rgba(239, 83, 80, 0.56)"
      }
    },
    {
      types: ["inserted"],
      style: {
        color: "rgb(173, 219, 103)"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(179, 98, 255)",
        fontStyle: "italic"
      }
    },
    {
      types: ["punctuation"],
      style: {
        color: "rgb(255, 255, 255)"
      }
    },
    {
      types: ["constant"],
      style: {
        color: "rgb(255, 98, 140)"
      }
    },
    {
      types: ["string", "url"],
      style: {
        color: "rgb(165, 255, 144)"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "rgb(255, 238, 128)"
      }
    },
    {
      types: ["number", "boolean"],
      style: {
        color: "rgb(255, 98, 140)"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "rgb(255, 180, 84)"
      }
    },
    {
      types: [
        "keyword",
        "operator",
        "property",
        "namespace",
        "tag",
        "selector",
        "doctype"
      ],
      style: {
        color: "rgb(255, 157, 0)"
      }
    },
    {
      types: ["builtin", "char", "constant", "function", "class-name"],
      style: {
        color: "rgb(250, 208, 0)"
      }
    }
  ]
};
var shadesOfPurple_default = theme10;

// src/themes/synthwave84.ts
var theme11 = {
  plain: {
    backgroundColor: "linear-gradient(to bottom, #2a2139 75%, #34294f)",
    backgroundImage: "#34294f",
    color: "#f92aad",
    textShadow: "0 0 2px #100c0f, 0 0 5px #dc078e33, 0 0 10px #fff3"
  },
  styles: [
    {
      types: ["comment", "block-comment", "prolog", "doctype", "cdata"],
      style: {
        color: "#495495",
        fontStyle: "italic"
      }
    },
    {
      types: ["punctuation"],
      style: {
        color: "#ccc"
      }
    },
    {
      types: [
        "tag",
        "attr-name",
        "namespace",
        "number",
        "unit",
        "hexcode",
        "deleted"
      ],
      style: {
        color: "#e2777a"
      }
    },
    {
      types: ["property", "selector"],
      style: {
        color: "#72f1b8",
        textShadow: "0 0 2px #100c0f, 0 0 10px #257c5575, 0 0 35px #21272475"
      }
    },
    {
      types: ["function-name"],
      style: {
        color: "#6196cc"
      }
    },
    {
      types: ["boolean", "selector-id", "function"],
      style: {
        color: "#fdfdfd",
        textShadow: "0 0 2px #001716, 0 0 3px #03edf975, 0 0 5px #03edf975, 0 0 8px #03edf975"
      }
    },
    {
      types: ["class-name", "maybe-class-name", "builtin"],
      style: {
        color: "#fff5f6",
        textShadow: "0 0 2px #000, 0 0 10px #fc1f2c75, 0 0 5px #fc1f2c75, 0 0 25px #fc1f2c75"
      }
    },
    {
      types: ["constant", "symbol"],
      style: {
        color: "#f92aad",
        textShadow: "0 0 2px #100c0f, 0 0 5px #dc078e33, 0 0 10px #fff3"
      }
    },
    {
      types: ["important", "atrule", "keyword", "selector-class"],
      style: {
        color: "#f4eee4",
        textShadow: "0 0 2px #393a33, 0 0 8px #f39f0575, 0 0 2px #f39f0575"
      }
    },
    {
      types: ["string", "char", "attr-value", "regex", "variable"],
      style: {
        color: "#f87c32"
      }
    },
    {
      types: ["parameter"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["entity", "url"],
      style: {
        color: "#67cdcc"
      }
    },
    {
      types: ["operator"],
      style: {
        color: "ffffffee"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["entity"],
      style: {
        cursor: "help"
      }
    },
    {
      types: ["inserted"],
      style: {
        color: "green"
      }
    }
  ]
};
var synthwave84_default = theme11;

// src/themes/ultramin.ts
var theme12 = {
  plain: {
    color: "#282a2e",
    backgroundColor: "#ffffff"
  },
  styles: [
    {
      types: ["comment"],
      style: {
        color: "rgb(197, 200, 198)"
      }
    },
    {
      types: ["string", "number", "builtin", "variable"],
      style: {
        color: "rgb(150, 152, 150)"
      }
    },
    {
      types: ["class-name", "function", "tag", "attr-name"],
      style: {
        color: "rgb(40, 42, 46)"
      }
    }
  ]
};
var ultramin_default = theme12;

// src/themes/vsDark.ts
var theme13 = {
  plain: {
    color: "#9CDCFE",
    backgroundColor: "#1E1E1E"
  },
  styles: [
    {
      types: ["prolog"],
      style: {
        color: "rgb(0, 0, 128)"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(106, 153, 85)"
      }
    },
    {
      types: ["builtin", "changed", "keyword", "interpolation-punctuation"],
      style: {
        color: "rgb(86, 156, 214)"
      }
    },
    {
      types: ["number", "inserted"],
      style: {
        color: "rgb(181, 206, 168)"
      }
    },
    {
      types: ["constant"],
      style: {
        color: "rgb(100, 102, 149)"
      }
    },
    {
      types: ["attr-name", "variable"],
      style: {
        color: "rgb(156, 220, 254)"
      }
    },
    {
      types: ["deleted", "string", "attr-value", "template-punctuation"],
      style: {
        color: "rgb(206, 145, 120)"
      }
    },
    {
      types: ["selector"],
      style: {
        color: "rgb(215, 186, 125)"
      }
    },
    {
      // Fix tag color
      types: ["tag"],
      style: {
        color: "rgb(78, 201, 176)"
      }
    },
    {
      // Fix tag color for HTML
      types: ["tag"],
      languages: ["markup"],
      style: {
        color: "rgb(86, 156, 214)"
      }
    },
    {
      types: ["punctuation", "operator"],
      style: {
        color: "rgb(212, 212, 212)"
      }
    },
    {
      // Fix punctuation color for HTML
      types: ["punctuation"],
      languages: ["markup"],
      style: {
        color: "#808080"
      }
    },
    {
      types: ["function"],
      style: {
        color: "rgb(220, 220, 170)"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "rgb(78, 201, 176)"
      }
    },
    {
      types: ["char"],
      style: {
        color: "rgb(209, 105, 105)"
      }
    }
  ]
};
var vsDark_default = theme13;

// src/themes/vsLight.ts
var theme14 = {
  plain: {
    color: "#000000",
    backgroundColor: "#ffffff"
  },
  styles: [
    {
      types: ["comment"],
      style: {
        color: "rgb(0, 128, 0)"
      }
    },
    {
      types: ["builtin"],
      style: {
        color: "rgb(0, 112, 193)"
      }
    },
    {
      types: ["number", "variable", "inserted"],
      style: {
        color: "rgb(9, 134, 88)"
      }
    },
    {
      types: ["operator"],
      style: {
        color: "rgb(0, 0, 0)"
      }
    },
    {
      types: ["constant", "char"],
      style: {
        color: "rgb(129, 31, 63)"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "rgb(128, 0, 0)"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "rgb(255, 0, 0)"
      }
    },
    {
      types: ["deleted", "string"],
      style: {
        color: "rgb(163, 21, 21)"
      }
    },
    {
      types: ["changed", "punctuation"],
      style: {
        color: "rgb(4, 81, 165)"
      }
    },
    {
      types: ["function", "keyword"],
      style: {
        color: "rgb(0, 0, 255)"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "rgb(38, 127, 153)"
      }
    }
  ]
};
var vsLight_default = theme14;

// src/themes/jettwaveDark.ts
var theme15 = {
  plain: {
    color: "#f8fafc",
    backgroundColor: "#011627"
  },
  styles: [
    {
      types: ["prolog"],
      style: {
        color: "#000080"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "#6A9955"
      }
    },
    {
      types: ["builtin", "changed", "keyword", "interpolation-punctuation"],
      style: {
        color: "#569CD6"
      }
    },
    {
      types: ["number", "inserted"],
      style: {
        color: "#B5CEA8"
      }
    },
    {
      types: ["constant"],
      style: {
        color: "#f8fafc"
      }
    },
    {
      types: ["attr-name", "variable"],
      style: {
        color: "#9CDCFE"
      }
    },
    {
      types: ["deleted", "string", "attr-value", "template-punctuation"],
      style: {
        color: "#cbd5e1"
      }
    },
    {
      types: ["selector"],
      style: {
        color: "#D7BA7D"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["tag"],
      languages: ["markup"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["punctuation", "operator"],
      style: {
        color: "#D4D4D4"
      }
    },
    {
      types: ["punctuation"],
      languages: ["markup"],
      style: {
        color: "#808080"
      }
    },
    {
      types: ["function"],
      style: {
        color: "#7dd3fc"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["char"],
      style: {
        color: "#D16969"
      }
    }
  ]
};
var jettwaveDark_default = theme15;

// src/themes/jettwaveLight.ts
var theme16 = {
  plain: {
    color: "#0f172a",
    backgroundColor: "#f1f5f9"
  },
  styles: [
    {
      types: ["prolog"],
      style: {
        color: "#000080"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "#6A9955"
      }
    },
    {
      types: ["builtin", "changed", "keyword", "interpolation-punctuation"],
      style: {
        color: "#0c4a6e"
      }
    },
    {
      types: ["number", "inserted"],
      style: {
        color: "#B5CEA8"
      }
    },
    {
      types: ["constant"],
      style: {
        color: "#0f172a"
      }
    },
    {
      types: ["attr-name", "variable"],
      style: {
        color: "#0c4a6e"
      }
    },
    {
      types: ["deleted", "string", "attr-value", "template-punctuation"],
      style: {
        color: "#64748b"
      }
    },
    {
      types: ["selector"],
      style: {
        color: "#D7BA7D"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["tag"],
      languages: ["markup"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["punctuation", "operator"],
      style: {
        color: "#475569"
      }
    },
    {
      types: ["punctuation"],
      languages: ["markup"],
      style: {
        color: "#808080"
      }
    },
    {
      types: ["function"],
      style: {
        color: "#0e7490"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["char"],
      style: {
        color: "#D16969"
      }
    }
  ]
};
var jettwaveLight_default = theme16;

// src/themes/oneDark.ts
var theme17 = {
  plain: {
    backgroundColor: "hsl(220, 13%, 18%)",
    color: "hsl(220, 14%, 71%)",
    textShadow: "0 1px rgba(0, 0, 0, 0.3)"
  },
  styles: [
    {
      types: ["comment", "prolog", "cdata"],
      style: {
        color: "hsl(220, 10%, 40%)"
      }
    },
    {
      types: ["doctype", "punctuation", "entity"],
      style: {
        color: "hsl(220, 14%, 71%)"
      }
    },
    {
      types: [
        "attr-name",
        "class-name",
        "maybe-class-name",
        "boolean",
        "constant",
        "number",
        "atrule"
      ],
      style: { color: "hsl(29, 54%, 61%)" }
    },
    {
      types: ["keyword"],
      style: { color: "hsl(286, 60%, 67%)" }
    },
    {
      types: ["property", "tag", "symbol", "deleted", "important"],
      style: {
        color: "hsl(355, 65%, 65%)"
      }
    },
    {
      types: [
        "selector",
        "string",
        "char",
        "builtin",
        "inserted",
        "regex",
        "attr-value"
      ],
      style: {
        color: "hsl(95, 38%, 62%)"
      }
    },
    {
      types: ["variable", "operator", "function"],
      style: {
        color: "hsl(207, 82%, 66%)"
      }
    },
    {
      types: ["url"],
      style: {
        color: "hsl(187, 47%, 55%)"
      }
    },
    {
      types: ["deleted"],
      style: {
        textDecorationLine: "line-through"
      }
    },
    {
      types: ["inserted"],
      style: {
        textDecorationLine: "underline"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["important"],
      style: {
        color: "hsl(220, 14%, 71%)"
      }
    }
  ]
};
var oneDark_default = theme17;

// src/themes/oneLight.ts
var theme18 = {
  plain: {
    backgroundColor: "hsl(230, 1%, 98%)",
    color: "hsl(230, 8%, 24%)"
  },
  styles: [
    {
      types: ["comment", "prolog", "cdata"],
      style: {
        color: "hsl(230, 4%, 64%)"
      }
    },
    {
      types: ["doctype", "punctuation", "entity"],
      style: {
        color: "hsl(230, 8%, 24%)"
      }
    },
    {
      types: [
        "attr-name",
        "class-name",
        "boolean",
        "constant",
        "number",
        "atrule"
      ],
      style: {
        color: "hsl(35, 99%, 36%)"
      }
    },
    {
      types: ["keyword"],
      style: {
        color: "hsl(301, 63%, 40%)"
      }
    },
    {
      types: ["property", "tag", "symbol", "deleted", "important"],
      style: {
        color: "hsl(5, 74%, 59%)"
      }
    },
    {
      types: [
        "selector",
        "string",
        "char",
        "builtin",
        "inserted",
        "regex",
        "attr-value",
        "punctuation"
      ],
      style: {
        color: "hsl(119, 34%, 47%)"
      }
    },
    {
      types: ["variable", "operator", "function"],
      style: {
        color: "hsl(221, 87%, 60%)"
      }
    },
    {
      types: ["url"],
      style: {
        color: "hsl(198, 99%, 37%)"
      }
    },
    {
      types: ["deleted"],
      style: {
        textDecorationLine: "line-through"
      }
    },
    {
      types: ["inserted"],
      style: {
        textDecorationLine: "underline"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["important"],
      style: {
        color: "hsl(230, 8%, 24%)"
      }
    }
  ]
};
var oneLight_default = theme18;

// src/themes/gruvboxMaterialDark.ts
var theme19 = {
  plain: {
    color: "#ebdbb2",
    backgroundColor: "#292828"
  },
  styles: [
    {
      types: [
        "imports",
        "class-name",
        "maybe-class-name",
        "constant",
        "doctype",
        "builtin",
        "function"
      ],
      style: {
        color: "#d8a657"
      }
    },
    {
      types: ["property-access"],
      style: {
        color: "#7daea3"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "#e78a4e"
      }
    },
    {
      types: ["attr-name", "char", "url", "regex"],
      style: {
        color: "#a9b665"
      }
    },
    {
      types: ["attr-value", "string"],
      style: {
        color: "#89b482"
      }
    },
    {
      types: ["comment", "prolog", "cdata", "operator", "inserted"],
      style: {
        color: "#a89984"
      }
    },
    {
      types: [
        "delimiter",
        "boolean",
        "keyword",
        "selector",
        "important",
        "atrule",
        "property",
        "variable",
        "deleted"
      ],
      style: {
        color: "#ea6962"
      }
    },
    {
      types: ["entity", "number", "symbol"],
      style: {
        color: "#d3869b"
      }
    }
  ]
};
var gruvboxMaterialDark_default = theme19;

// src/themes/gruvboxMaterialLight.ts
var theme20 = {
  plain: {
    color: "#654735",
    backgroundColor: "#f9f5d7"
  },
  styles: [
    {
      types: [
        "delimiter",
        "boolean",
        "keyword",
        "selector",
        "important",
        "atrule",
        "property",
        "variable",
        "deleted"
      ],
      style: {
        color: "#af2528"
      }
    },
    {
      types: [
        "imports",
        "class-name",
        "maybe-class-name",
        "constant",
        "doctype",
        "builtin"
      ],
      style: {
        color: "#b4730e"
      }
    },
    {
      types: ["string", "attr-value"],
      style: {
        color: "#477a5b"
      }
    },
    {
      types: ["property-access"],
      style: {
        color: "#266b79"
      }
    },
    {
      types: ["function", "attr-name", "char", "url"],
      style: {
        color: "#72761e"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "#b94c07"
      }
    },
    {
      types: ["comment", "prolog", "cdata", "operator", "inserted"],
      style: {
        color: "#a89984"
      }
    },
    {
      types: ["entity", "number", "symbol"],
      style: {
        color: "#924f79"
      }
    }
  ]
};
var gruvboxMaterialLight_default = theme20;

// src/index.ts


// src/components/useGetLineProps.ts


var useGetLineProps = (themeDictionary) => (0,react__rspack_import_0.useCallback)(
  (_a) => {
    var _b = _a, { className, style, line } = _b, rest = __objRest(_b, ["className", "style", "line"]);
    const output = __spreadProps(__spreadValues({}, rest), {
      className: (0,clsx__rspack_import_1/* ["default"] */.A)("token-line", className)
    });
    if (typeof themeDictionary === "object" && "plain" in themeDictionary)
      output.style = themeDictionary.plain;
    if (typeof style === "object")
      output.style = __spreadValues(__spreadValues({}, output.style || {}), style);
    return output;
  },
  [themeDictionary]
);

// src/components/useGetTokenProps.ts


var useGetTokenProps = (themeDictionary) => {
  const styleForToken = (0,react__rspack_import_0.useCallback)(
    ({ types, empty }) => {
      if (themeDictionary == null)
        return void 0;
      else if (types.length === 1 && types[0] === "plain") {
        return empty != null ? { display: "inline-block" } : void 0;
      } else if (types.length === 1 && empty != null) {
        return themeDictionary[types[0]];
      }
      return Object.assign(
        empty != null ? { display: "inline-block" } : {},
        ...types.map((type) => themeDictionary[type])
      );
    },
    [themeDictionary]
  );
  return (0,react__rspack_import_0.useCallback)(
    (_a) => {
      var _b = _a, { token, className, style } = _b, rest = __objRest(_b, ["token", "className", "style"]);
      const output = __spreadProps(__spreadValues({}, rest), {
        className: (0,clsx__rspack_import_1/* ["default"] */.A)("token", ...token.types, className),
        children: token.content,
        style: styleForToken(token)
      });
      if (style != null) {
        output.style = __spreadValues(__spreadValues({}, output.style || {}), style);
      }
      return output;
    },
    [styleForToken]
  );
};

// src/utils/normalizeTokens.ts
var newlineRe = /\r\n|\r|\n/;
var normalizeEmptyLines = (line) => {
  if (line.length === 0) {
    line.push({
      types: ["plain"],
      content: "\n",
      empty: true
    });
  } else if (line.length === 1 && line[0].content === "") {
    line[0].content = "\n";
    line[0].empty = true;
  }
};
var appendTypes = (types, add) => {
  const typesSize = types.length;
  if (typesSize > 0 && types[typesSize - 1] === add) {
    return types;
  }
  return types.concat(add);
};
var normalizeTokens = (tokens) => {
  const typeArrStack = [[]];
  const tokenArrStack = [tokens];
  const tokenArrIndexStack = [0];
  const tokenArrSizeStack = [tokens.length];
  let i = 0;
  let stackIndex = 0;
  let currentLine = [];
  const acc = [currentLine];
  while (stackIndex > -1) {
    while ((i = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]) {
      let content;
      let types = typeArrStack[stackIndex];
      const tokenArr = tokenArrStack[stackIndex];
      const token = tokenArr[i];
      if (typeof token === "string") {
        types = stackIndex > 0 ? types : ["plain"];
        content = token;
      } else {
        types = appendTypes(types, token.type);
        if (token.alias) {
          types = appendTypes(types, token.alias);
        }
        content = token.content;
      }
      if (typeof content !== "string") {
        stackIndex++;
        typeArrStack.push(types);
        tokenArrStack.push(content);
        tokenArrIndexStack.push(0);
        tokenArrSizeStack.push(content.length);
        continue;
      }
      const splitByNewlines = content.split(newlineRe);
      const newlineCount = splitByNewlines.length;
      currentLine.push({
        types,
        content: splitByNewlines[0]
      });
      for (let i2 = 1; i2 < newlineCount; i2++) {
        normalizeEmptyLines(currentLine);
        acc.push(currentLine = []);
        currentLine.push({
          types,
          content: splitByNewlines[i2]
        });
      }
    }
    stackIndex--;
    typeArrStack.pop();
    tokenArrStack.pop();
    tokenArrIndexStack.pop();
    tokenArrSizeStack.pop();
  }
  normalizeEmptyLines(currentLine);
  return acc;
};
var normalizeTokens_default = normalizeTokens;

// src/components/useTokenize.ts

var useTokenize = ({ prism, code, grammar, language }) => {
  return (0,react__rspack_import_0.useMemo)(() => {
    if (grammar == null)
      return normalizeTokens_default([code]);
    const prismConfig = {
      code,
      grammar,
      language,
      tokens: []
    };
    prism.hooks.run("before-tokenize", prismConfig);
    prismConfig.tokens = prism.tokenize(code, grammar);
    prism.hooks.run("after-tokenize", prismConfig);
    return normalizeTokens_default(prismConfig.tokens);
  }, [
    code,
    grammar,
    language,
    // prism is a stable import
    prism
  ]);
};

// src/utils/themeToDict.ts
var themeToDict = (theme21, language) => {
  const { plain } = theme21;
  const themeDict = theme21.styles.reduce((acc, themeEntry) => {
    const { languages: languages2, style } = themeEntry;
    if (languages2 && !languages2.includes(language)) {
      return acc;
    }
    themeEntry.types.forEach((type) => {
      const accStyle = __spreadValues(__spreadValues({}, acc[type]), style);
      acc[type] = accStyle;
    });
    return acc;
  }, {});
  themeDict.root = plain;
  themeDict.plain = __spreadProps(__spreadValues({}, plain), { backgroundColor: void 0 });
  return themeDict;
};
var themeToDict_default = themeToDict;

// src/components/highlight.ts
var Highlight = ({
  children,
  language: _language,
  code,
  theme: theme21,
  prism
}) => {
  const language = _language.toLowerCase();
  const themeDictionary = themeToDict_default(theme21, language);
  const getLineProps = useGetLineProps(themeDictionary);
  const getTokenProps = useGetTokenProps(themeDictionary);
  const grammar = prism.languages[language];
  const tokens = useTokenize({ prism, language, code, grammar });
  return children({
    tokens,
    className: `prism-code language-${language}`,
    style: themeDictionary != null ? themeDictionary.root : {},
    getLineProps,
    getTokenProps
  });
};

// src/index.ts
var Highlight2 = (props) => (0,react__rspack_import_0.createElement)(Highlight, __spreadProps(__spreadValues({}, props), {
  prism: props.prism || Prism,
  theme: props.theme || vsDark_default,
  code: props.code,
  language: props.language
}));

/*! Bundled license information:

prismjs/prism.js:
  (**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   *)
*/
//# sourceMappingURL=index.mjs.map

}),
11561: (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.d(__webpack_exports__, {
  A: () => (invariant)
});
var isProduction = "production" === 'production';
var prefix = 'Invariant failed';
function invariant(condition, message) {
    if (condition) {
        return;
    }
    if (isProduction) {
        throw new Error(prefix);
    }
    var provided = typeof message === 'function' ? message() : message;
    var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
    throw new Error(value);
}




}),
31635: (function (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
"use strict";
__webpack_require__.r(__webpack_exports__);
__webpack_require__.d(__webpack_exports__, {
  __addDisposableResource: () => (__addDisposableResource),
  __assign: () => (__assign),
  __asyncDelegator: () => (__asyncDelegator),
  __asyncGenerator: () => (__asyncGenerator),
  __asyncValues: () => (__asyncValues),
  __await: () => (__await),
  __awaiter: () => (__awaiter),
  __classPrivateFieldGet: () => (__classPrivateFieldGet),
  __classPrivateFieldIn: () => (__classPrivateFieldIn),
  __classPrivateFieldSet: () => (__classPrivateFieldSet),
  __createBinding: () => (__createBinding),
  __decorate: () => (__decorate),
  __disposeResources: () => (__disposeResources),
  __esDecorate: () => (__esDecorate),
  __exportStar: () => (__exportStar),
  __extends: () => (__extends),
  __generator: () => (__generator),
  __importDefault: () => (__importDefault),
  __importStar: () => (__importStar),
  __makeTemplateObject: () => (__makeTemplateObject),
  __metadata: () => (__metadata),
  __param: () => (__param),
  __propKey: () => (__propKey),
  __read: () => (__read),
  __rest: () => (__rest),
  __rewriteRelativeImportExtension: () => (__rewriteRelativeImportExtension),
  __runInitializers: () => (__runInitializers),
  __setFunctionName: () => (__setFunctionName),
  __spread: () => (__spread),
  __spreadArray: () => (__spreadArray),
  __spreadArrays: () => (__spreadArrays),
  __values: () => (__values),
  "default": () => (__rspack_default_export)
});
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  }
  return __assign.apply(this, arguments);
}

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};

function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};

function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};

var ownKeys = function(o) {
  ownKeys = Object.getOwnPropertyNames || function (o) {
    var ar = [];
    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
    return ar;
  };
  return ownKeys(o);
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  __setModuleDefault(result, mod);
  return result;
}

function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
    env.stack.push({ value: value, dispose: dispose, async: async });
  }
  else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
        }
        else s |= 1;
      }
      catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}

function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
      return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : (d + ext + "." + cm.toLowerCase() + "js");
      });
  }
  return path;
}

/* export default */ const __rspack_default_export = ({
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension,
});


}),
22654: (function (module) {
"use strict";
module.exports = JSON.parse('{"theme.AnnouncementBar.closeButtonAriaLabel":"Cerrar","theme.BackToTopButton.buttonAriaLabel":"Volver al principio","theme.CodeBlock.copied":"Copiado","theme.CodeBlock.copy":"Copiar","theme.CodeBlock.copyButtonAriaLabel":"Copiar código","theme.CodeBlock.wordWrapToggle":"Alternar ajuste de palabras","theme.DocSidebarItem.collapseCategoryAriaLabel":"Colapsar categoría \'{label}\' de la barra lateral","theme.DocSidebarItem.expandCategoryAriaLabel":"Ampliar la categoría \'{label}\' de la barra lateral","theme.ErrorPageContent.title":"Esta página ha fallado.","theme.ErrorPageContent.tryAgain":"Intente de nuevo","theme.IconExternalLink.ariaLabel":"(opens in new tab)","theme.NavBar.navAriaLabel":"Principal","theme.NotFound.p1":"No pudimos encontrar lo que buscaba.","theme.NotFound.p2":"Comuníquese con el dueño del sitio que le proporcionó la URL original y hágale saber que su vínculo está roto.","theme.NotFound.title":"Página No Encontrada","theme.TOCCollapsible.toggleButtonLabel":"En esta página","theme.admonition.caution":"precaución","theme.admonition.danger":"peligro","theme.admonition.info":"info","theme.admonition.note":"nota","theme.admonition.tip":"tip","theme.admonition.warning":"aviso","theme.blog.archive.description":"Archivo","theme.blog.archive.title":"Archivo","theme.blog.author.noPosts":"This author has not written any posts yet.","theme.blog.author.pageTitle":"{authorName} - {nPosts}","theme.blog.authorsList.pageTitle":"Authors","theme.blog.authorsList.viewAll":"View All Authors","theme.blog.paginator.navAriaLabel":"Navegación por la página de la lista de blogs ","theme.blog.paginator.newerEntries":"Entradas más recientes","theme.blog.paginator.olderEntries":"Entradas más antiguas","theme.blog.post.paginator.navAriaLabel":"Barra de paginación de publicaciones del blog","theme.blog.post.paginator.newerPost":"Publicación más reciente","theme.blog.post.paginator.olderPost":"Publicación más antigua","theme.blog.post.plurals":"Una publicación|{count} publicaciones","theme.blog.post.readMore":"Leer Más","theme.blog.post.readMoreLabel":"Leer más acerca de {title}","theme.blog.post.readingTime.plurals":"Lectura de un minuto|{readingTime} min de lectura","theme.blog.sidebar.navAriaLabel":"Navegación de publicaciones recientes","theme.blog.tagTitle":"{nPosts} etiquetados con \\"{tagName}\\"","theme.colorToggle.ariaLabel":"Cambiar entre modo oscuro y claro (actualmente {mode})","theme.colorToggle.ariaLabel.mode.dark":"modo oscuro","theme.colorToggle.ariaLabel.mode.light":"modo claro","theme.colorToggle.ariaLabel.mode.system":"system mode","theme.common.editThisPage":"Editar esta página","theme.common.headingLinkTitle":"Enlace directo al {heading}","theme.common.skipToMainContent":"Saltar al contenido principal","theme.contentVisibility.draftBanner.message":"This page is a draft. It will only be visible in dev and be excluded from the production build.","theme.contentVisibility.draftBanner.title":"Draft page","theme.contentVisibility.unlistedBanner.message":"Esta página está sin clasificar. Los motores de búsqueda no la indexaran, y solo los usuarios con el enlace directo podrán acceder a esta.","theme.contentVisibility.unlistedBanner.title":"Página sin clasificar","theme.docs.DocCard.categoryDescription.plurals":"1 artículo|{count} artículos","theme.docs.breadcrumbs.home":"Página de Inicio","theme.docs.breadcrumbs.navAriaLabel":"Rastro de navegación","theme.docs.paginator.navAriaLabel":"Página del documento","theme.docs.paginator.next":"Siguiente","theme.docs.paginator.previous":"Anterior","theme.docs.sidebar.closeSidebarButtonAriaLabel":"Cerrar barra de lateral","theme.docs.sidebar.collapseButtonAriaLabel":"Colapsar barra lateral","theme.docs.sidebar.collapseButtonTitle":"Colapsar barra lateral","theme.docs.sidebar.expandButtonAriaLabel":"Expandir barra lateral","theme.docs.sidebar.expandButtonTitle":"Expandir barra lateral","theme.docs.sidebar.navAriaLabel":"Barra lateral de Documentos","theme.docs.sidebar.toggleSidebarButtonAriaLabel":"Alternar barra lateral","theme.docs.tagDocListPageTitle":"{nDocsTagged} con \\"{tagName}\\"","theme.docs.tagDocListPageTitle.nDocsTagged":"Un documento etiquetado|{count} documentos etiquetados","theme.docs.versionBadge.label":"Version: {versionLabel}","theme.docs.versions.latestVersionLinkLabel":"última versión","theme.docs.versions.latestVersionSuggestionLabel":"Para la documentación actualizada, vea {latestVersionLink} ({versionLabel}).","theme.docs.versions.unmaintainedVersionLabel":"Esta es la documentación para {siteTitle} {versionLabel}, que ya no se mantiene activamente.","theme.docs.versions.unreleasedVersionLabel":"Esta es la documentación sin publicar para {siteTitle}, versión {versionLabel}.","theme.lastUpdated.atDate":" en {date}","theme.lastUpdated.byUser":" por {user}","theme.lastUpdated.lastUpdatedAtBy":"Última actualización{atDate}{byUser}","theme.navbar.mobileDropdown.collapseButton.collapseAriaLabel":"Collapse the dropdown","theme.navbar.mobileDropdown.collapseButton.expandAriaLabel":"Expand the dropdown","theme.navbar.mobileLanguageDropdown.label":"Idiomas","theme.navbar.mobileSidebarSecondaryMenu.backButtonLabel":"← Volver al menú principal","theme.navbar.mobileVersionsDropdown.label":"Versiones","theme.tags.tagsListLabel":"Etiquetas:","theme.tags.tagsPageLink":"Ver Todas las Etiquetas","theme.tags.tagsPageTitle":"Etiquetas"}')

}),
84054: (function (module) {
"use strict";
module.exports = JSON.parse('{"/es/blog-c84":{"__comp":"a6aa9e1f","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"3e0612ca"},{"content":"71b694a8"},{"content":"908f8316"},{"content":"6114d855"},{"content":"9373caed"},{"content":"01fb8007"},{"content":"59423c55"},{"content":"d8a6de9e"},{"content":"0cab6d25"},{"content":"6de61594"}],"__props":"8b20138e"},"/es/blog/alineando-marketing-y-ventas-para-una-conversion-optima-d5b":{"__comp":"ccc49370","__context":{"data":{"blogMetadata":"acecf23e"},"plugin":"36994c47"},"sidebar":"814f3328","content":"42702193"},"/es/blog/archive-c1d":{"__comp":"9e4087bc","__context":{"plugin":"36994c47"},"__props":"dfed01cf"},"/es/blog/authors-e39":{"__comp":"621db11d","__context":{"data":{"blogMetadata":"acecf23e"},"plugin":"36994c47"},"sidebar":"814f3328","__props":"f601d5af"},"/es/blog/como-elegir-el-crm-o-software-de-gestion-de-ventas-adecuado-para-su-empresa-04d":{"__comp":"ccc49370","__context":{"data":{"blogMetadata":"acecf23e"},"plugin":"36994c47"},"sidebar":"814f3328","content":"d4adaca3"},"/es/blog/comparacion-de-la-eficacia-y-la-eficiencia-de-crm-versus-excel-018":{"__comp":"ccc49370","__context":{"data":{"blogMetadata":"acecf23e"},"plugin":"36994c47"},"sidebar":"814f3328","content":"cf1e8ef5"},"/es/blog/crm-vs-excel-un-analisis-comparativo-843":{"__comp":"ccc49370","__context":{"data":{"blogMetadata":"acecf23e"},"plugin":"36994c47"},"sidebar":"814f3328","content":"20e4b877"},"/es/blog/estrategias-para-atraer-leads-de-alta-calidad-072":{"__comp":"ccc49370","__context":{"data":{"blogMetadata":"acecf23e"},"plugin":"36994c47"},"sidebar":"814f3328","content":"42dbfab1"},"/es/blog/estrategias-para-mejorar-las-tasas-de-conversion-en-cada-etapa-del-embudo-615":{"__comp":"ccc49370","__context":{"data":{"blogMetadata":"acecf23e"},"plugin":"36994c47"},"sidebar":"814f3328","content":"68d382cf"},"/es/blog/indicadores-clave-de-rendimiento-kpi-para-medir-el-exito-4d9":{"__comp":"ccc49370","__context":{"data":{"blogMetadata":"acecf23e"},"plugin":"36994c47"},"sidebar":"814f3328","content":"b3361e2b"},"/es/blog/las-desventajas-de-usar-excel-para-la-nutricion-y-el-seguimiento-de-leads-fd2":{"__comp":"ccc49370","__context":{"data":{"blogMetadata":"acecf23e"},"plugin":"36994c47"},"sidebar":"814f3328","content":"e0fede9b"},"/es/blog/las-ventajas-de-usar-un-sistema-crm-para-la-nutricion-y-el-seguimiento-de-leads-444":{"__comp":"ccc49370","__context":{"data":{"blogMetadata":"acecf23e"},"plugin":"36994c47"},"sidebar":"814f3328","content":"b2d6b5e2"},"/es/blog/mejora-de-las-tasas-de-conversion-a-traves-del-embudo-de-marketing-y-ventas-440":{"__comp":"ccc49370","__context":{"data":{"blogMetadata":"acecf23e"},"plugin":"36994c47"},"sidebar":"814f3328","content":"57886a6f"},"/es/blog/page/2-e2d":{"__comp":"a6aa9e1f","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"6a26327e"}],"__props":"bddaa4da"},"/es/blog/software-crm-popular-en-el-mercado-estadounidense-303":{"__comp":"ccc49370","__context":{"data":{"blogMetadata":"acecf23e"},"plugin":"36994c47"},"sidebar":"814f3328","content":"e4ebf854"},"/es/blog/tags-b1d":{"__comp":"01a85c17","__context":{"plugin":"36994c47"},"sidebar":"814f3328","__props":"0c69ec8d"},"/es/blog/tags/como-elegir-crm-0ca":{"__comp":"6875c492","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"71b694a8"},{"content":"908f8316"}],"__props":"1d432d14"},"/es/blog/tags/crm-897":{"__comp":"6875c492","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"3e0612ca"},{"content":"71b694a8"},{"content":"908f8316"},{"content":"6114d855"},{"content":"9373caed"},{"content":"01fb8007"},{"content":"59423c55"},{"content":"d8a6de9e"},{"content":"0cab6d25"},{"content":"6de61594"}],"__props":"9eac8549"},"/es/blog/tags/crm/page/2-7d1":{"__comp":"6875c492","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"6a26327e"}],"__props":"e663daef"},"/es/blog/tags/embudo-marketing-297":{"__comp":"6875c492","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"0cab6d25"},{"content":"6de61594"},{"content":"6a26327e"}],"__props":"e4884af1"},"/es/blog/tags/embudo-ventas-38d":{"__comp":"6875c492","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"0cab6d25"},{"content":"6de61594"},{"content":"6a26327e"}],"__props":"f5d11d20"},"/es/blog/tags/excel-cb6":{"__comp":"6875c492","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"6114d855"},{"content":"9373caed"},{"content":"01fb8007"},{"content":"59423c55"},{"content":"d8a6de9e"}],"__props":"63bbb5f6"},"/es/blog/tags/excel-vs-crm-620":{"__comp":"6875c492","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"6114d855"},{"content":"9373caed"},{"content":"01fb8007"},{"content":"59423c55"},{"content":"d8a6de9e"}],"__props":"ebfe9078"},"/es/blog/tags/leads-82f":{"__comp":"6875c492","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"3e0612ca"}],"__props":"1e83810f"},"/es/blog/tags/leads-alta-calidad-8c8":{"__comp":"6875c492","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"3e0612ca"}],"__props":"17977e16"},"/es/blog/tags/tasa-de-conversion-08c":{"__comp":"6875c492","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"0cab6d25"},{"content":"6de61594"},{"content":"6a26327e"}],"__props":"7061144e"},"/es/blog/tags/ventas-310":{"__comp":"6875c492","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"3e0612ca"},{"content":"71b694a8"},{"content":"908f8316"},{"content":"6114d855"},{"content":"9373caed"},{"content":"01fb8007"},{"content":"59423c55"},{"content":"d8a6de9e"},{"content":"0cab6d25"},{"content":"6de61594"}],"__props":"351c1b1f"},"/es/blog/tags/ventas/page/2-488":{"__comp":"6875c492","__context":{"plugin":"36994c47"},"sidebar":"814f3328","items":[{"content":"6a26327e"}],"__props":"a65d8cc7"},"/es/docs/fintesk-v1-479":{"__comp":"f0ad3fbb","__context":{"plugin":"b8387ec1"},"specProps":"348d668f","layoutProps":"7711c30d"},"/es/markdown-page-724":{"__comp":"1f391b9e","__context":{"plugin":"a7456010"},"content":"393be207"},"/es/-c69":{"__comp":"5e95c892","__context":{"plugin":"aba21aa0"}},"/es/-a81":{"__comp":"a7bd4aaa","__props":"96eb2e13"},"/es/tags-bf6":{"__comp":"3720c009","__props":"1e936633"},"/es/tags/account-settings-164":{"__comp":"df203c0f","__props":"01f3df1d"},"/es/tags/activities-8a6":{"__comp":"df203c0f","__props":"066309a2"},"/es/tags/basic-concepts-7fd":{"__comp":"df203c0f","__props":"aaa3b165"},"/es/tags/billing-beb":{"__comp":"df203c0f","__props":"3344bb77"},"/es/tags/billing-information-a59":{"__comp":"df203c0f","__props":"526b8dd9"},"/es/tags/browser-71b":{"__comp":"df203c0f","__props":"16b98190"},"/es/tags/changelog-a47":{"__comp":"df203c0f","__props":"8b36d413"},"/es/tags/company-settings-b37":{"__comp":"df203c0f","__props":"1192796a"},"/es/tags/contact-support-52a":{"__comp":"df203c0f","__props":"5db51138"},"/es/tags/contacts-247":{"__comp":"df203c0f","__props":"05e71aeb"},"/es/tags/core-api-concepts-dfc":{"__comp":"df203c0f","__props":"80e033a9"},"/es/tags/data-fields-ec4":{"__comp":"df203c0f","__props":"84f8754a"},"/es/tags/deals-415":{"__comp":"df203c0f","__props":"d9ce5890"},"/es/tags/detail-view-5ab":{"__comp":"df203c0f","__props":"ead47cb0"},"/es/tags/developers-e5c":{"__comp":"df203c0f","__props":"e4905158"},"/es/tags/features-69f":{"__comp":"df203c0f","__props":"e1173dc6"},"/es/tags/filtering-488":{"__comp":"df203c0f","__props":"0cd9735e"},"/es/tags/fintesk-api-d3b":{"__comp":"df203c0f","__props":"311c2599"},"/es/tags/getting-started-751":{"__comp":"df203c0f","__props":"8b0b5d87"},"/es/tags/importing-data-7f2":{"__comp":"df203c0f","__props":"f7552a49"},"/es/tags/list-view-d6c":{"__comp":"df203c0f","__props":"e8f4a039"},"/es/tags/list-view-reporting-ecc":{"__comp":"df203c0f","__props":"9165223e"},"/es/tags/manage-users-a54":{"__comp":"df203c0f","__props":"ce08bd4c"},"/es/tags/organizing-your-data-ffc":{"__comp":"df203c0f","__props":"9837289d"},"/es/tags/personal-settings-3f5":{"__comp":"df203c0f","__props":"aee47763"},"/es/tags/pipeline-view-e8c":{"__comp":"df203c0f","__props":"1a12e3f7"},"/es/tags/pipelines-9b1":{"__comp":"df203c0f","__props":"38cdae4e"},"/es/tags/privacy-92a":{"__comp":"df203c0f","__props":"1fc72748"},"/es/tags/products-7f3":{"__comp":"df203c0f","__props":"b0bc9003"},"/es/tags/progress-c98":{"__comp":"df203c0f","__props":"fe269359"},"/es/tags/tos-556":{"__comp":"df203c0f","__props":"d9320b6b"},"/es/tags/troubleshooting-441":{"__comp":"df203c0f","__props":"192c9132"},"/es/tags/troubleshooting-the-web-app-a93":{"__comp":"df203c0f","__props":"828ae484"},"/es/tags/users-and-permissions-a9b":{"__comp":"df203c0f","__props":"ddd73e7e"},"/es/tags/your-fintesk-subscription-plan-e83":{"__comp":"df203c0f","__props":"39f5392f"},"/es/-547":{"__comp":"a94703ab"},"/es/billing/billing-information/what-happens-to-my-billing-when-i-add-a-user-in-fintesk-5ec":{"__comp":"17896441","content":"add6720e"},"/es/billing/billing-information/what-happens-to-my-billing-when-i-change-my-billing-frequency-6ec":{"__comp":"17896441","content":"0896d7e9"},"/es/billing/billing-information/what-happens-to-my-billing-when-i-change-my-fintesk-subscription-plan-0af":{"__comp":"17896441","content":"57fa3476"},"/es/billing/billing-information/what-happens-to-my-billing-when-i-deactivate-a-user-in-fintesk-25f":{"__comp":"17896441","content":"b8a74deb"},"/es/billing/your-fintesk-subscription-plan/how-can-i-switch-to-a-different-fintesk-plan-or-change-my-billing-frequency-76f":{"__comp":"17896441","content":"88f67a13"},"/es/billing/your-fintesk-subscription-plan/what-features-do-the-fintesk-plans-have-3d4":{"__comp":"17896441","content":"6a4af112"},"/es/category/activities-818":{"__comp":"14eb3368","__props":"e12988e0"},"/es/category/billing-ce5":{"__comp":"14eb3368","__props":"e29280ac"},"/es/category/billing-information-0cb":{"__comp":"14eb3368","__props":"480bbaae"},"/es/category/company-settings-21e":{"__comp":"14eb3368","__props":"306e4764"},"/es/category/contacts-81c":{"__comp":"14eb3368","__props":"0b34a5b0"},"/es/category/core-api-concepts-a2c":{"__comp":"14eb3368","__props":"34b54ed9"},"/es/category/data-fields-238":{"__comp":"14eb3368","__props":"05bbc94d"},"/es/category/deals-277":{"__comp":"14eb3368","__props":"d24de678"},"/es/category/detail-view-a34":{"__comp":"14eb3368","__props":"1143fd4d"},"/es/category/developers-d03":{"__comp":"14eb3368","__props":"80f99bf8"},"/es/category/exporting-data-a0b":{"__comp":"14eb3368","__props":"7bf6386c"},"/es/category/filtering-1a1":{"__comp":"14eb3368","__props":"5fabbca8"},"/es/category/fintesk-api-594":{"__comp":"14eb3368","__props":"7c6c2975"},"/es/category/getting-started-111":{"__comp":"14eb3368","__props":"e76bb3ad"},"/es/category/importing-data-c88":{"__comp":"14eb3368","__props":"cb625aae"},"/es/category/knowledge-base-05d":{"__comp":"14eb3368","__props":"c438431a"},"/es/category/list-view-25c":{"__comp":"14eb3368","__props":"e86ce71c"},"/es/category/overview-c8b":{"__comp":"14eb3368","__props":"99d4904e"},"/es/category/personal-settings-808":{"__comp":"14eb3368","__props":"c9857b17"},"/es/category/pipeline-view-428":{"__comp":"14eb3368","__props":"3c72dbd0"},"/es/category/pipelines-b3f":{"__comp":"14eb3368","__props":"5f61064d"},"/es/category/privacy-748":{"__comp":"14eb3368","__props":"3df48dd7"},"/es/category/products-3cf":{"__comp":"14eb3368","__props":"cddaf021"},"/es/category/terms-of-service-4f2":{"__comp":"14eb3368","__props":"c5cdb8f8"},"/es/category/troubleshooting-417":{"__comp":"14eb3368","__props":"f3dc583f"},"/es/category/users-and-permissions-598":{"__comp":"14eb3368","__props":"94fb5502"},"/es/category/your-fintesk-subscription-plan-9de":{"__comp":"14eb3368","__props":"9b4f3099"},"/es/developers/core-api-concepts/changes-to-the-api-0e4":{"__comp":"17896441","content":"57536add"},"/es/developers/core-api-concepts/core-api-concepts-about-fintesk-api-c9b":{"__comp":"17896441","content":"497e7b2b"},"/es/developers/core-api-concepts/core-api-concepts-custom-fields-ea4":{"__comp":"17896441","content":"7e188a67"},"/es/developers/core-api-concepts/core-api-concepts-date-format-9b2":{"__comp":"17896441","content":"ec4249a1"},"/es/developers/core-api-concepts/core-api-concepts-http-status-codes-634":{"__comp":"17896441","content":"4f5dbec8"},"/es/developers/core-api-concepts/core-api-concepts-pagination-43b":{"__comp":"17896441","content":"8bea8cac"},"/es/developers/core-api-concepts/core-api-concepts-requests-1c6":{"__comp":"17896441","content":"9f82584d"},"/es/developers/overview/getting-started-95b":{"__comp":"17896441","content":"eda2513a"},"/es/fintesk/api-v1-f8c":{"__comp":"17896441","content":"0df994e7"},"/es/fintesk/changelog-b8a":{"__comp":"17896441","content":"dd6f6a38"},"/es/kb/activities-06c":{"__comp":"17896441","content":"71e5d3ca"},"/es/kb/activities/activity-marked-as-done-logic-fa4":{"__comp":"17896441","content":"8a90ab5e"},"/es/kb/activities/creating-custom-activity-types-34d":{"__comp":"17896441","content":"de1495e0"},"/es/kb/activities/how-can-i-create-activities-in-bulk-85a":{"__comp":"17896441","content":"d217ec42"},"/es/kb/activities/how-can-i-filter-my-activities-in-the-list-view-6c8":{"__comp":"17896441","content":"89afde3e"},"/es/kb/activities/how-can-i-link-my-activities-with-multiple-contact-persons-d9c":{"__comp":"17896441","content":"6e372507"},"/es/kb/activities/how-can-i-see-done-activities-d1a":{"__comp":"17896441","content":"be1b61f6"},"/es/kb/company-settings/how-can-i-create-a-custom-currency-13f":{"__comp":"17896441","content":"49653484"},"/es/kb/company-settings/how-can-i-enable-predefined-lost-reasons-e2f":{"__comp":"17896441","content":"64c3b18e"},"/es/kb/company-settings/lost-reasons-30c":{"__comp":"17896441","content":"6bb703b2"},"/es/kb/contacts/contact-detail-view-26e":{"__comp":"17896441","content":"42c3d2c2"},"/es/kb/contacts/contacts-persons-and-organizations-dfc":{"__comp":"17896441","content":"b1c21d6c"},"/es/kb/contacts/how-can-i-add-related-persons-or-organizations-to-a-deal-eb3":{"__comp":"17896441","content":"75e617f2"},"/es/kb/contacts/linking-persons-and-organizations-847":{"__comp":"17896441","content":"85de7318"},"/es/kb/data-fields/custom-fields-531":{"__comp":"17896441","content":"65a663a3"},"/es/kb/data-fields/data-fields-in-fintesk-eeb":{"__comp":"17896441","content":"cdd26b62"},"/es/kb/data-fields/how-can-i-add-data-fields-to-an-add-deal-contact-or-product-modal-96a":{"__comp":"17896441","content":"5e0a7532"},"/es/kb/data-fields/what-types-of-custom-fields-are-there-231":{"__comp":"17896441","content":"c17ac11c"},"/es/kb/deals/adding-deals-in-bulk-cb5":{"__comp":"17896441","content":"9f23735e"},"/es/kb/deals/deals-what-they-are-and-how-to-add-them-1ba":{"__comp":"17896441","content":"cab78a59"},"/es/kb/deals/editing-the-contact-linked-to-a-deal-db0":{"__comp":"17896441","content":"3379c1c0"},"/es/kb/deals/filtering-for-my-won-lost-or-deleted-deals-7cb":{"__comp":"17896441","content":"08f7d8b0"},"/es/kb/deals/how-can-i-move-a-deal-to-another-pipeline-f5b":{"__comp":"17896441","content":"b2a5f17d"},"/es/kb/deals/how-can-i-restore-deleted-deals-c42":{"__comp":"17896441","content":"8296a943"},"/es/kb/detail-view-998":{"__comp":"17896441","content":"66e3fb8b"},"/es/kb/detail-view/deal-detail-view-658":{"__comp":"17896441","content":"904aa57c"},"/es/kb/detail-view/how-can-i-add-notes-to-a-deal-or-contact-32e":{"__comp":"17896441","content":"a08363ee"},"/es/kb/detail-view/updating-items-in-the-detail-view-7a3":{"__comp":"17896441","content":"fd9df2c6"},"/es/kb/exporting-data/exporting-data-from-fintesk-bf0":{"__comp":"17896441","content":"5ced9c79"},"/es/kb/filtering-bcf":{"__comp":"17896441","content":"597d3170"},"/es/kb/filtering/filters-common-uses-db5":{"__comp":"17896441","content":"faaef88a"},"/es/kb/getting-started/fintesk-glossary-cee":{"__comp":"17896441","content":"26a0f5a1"},"/es/kb/getting-started/fintesk-user-vs-company-account-caf":{"__comp":"17896441","content":"19280e3f"},"/es/kb/getting-started/how-can-i-delete-items-in-fintesk-46e":{"__comp":"17896441","content":"de1c1b0d"},"/es/kb/getting-started/interface-in-fintesk-1e6":{"__comp":"17896441","content":"ddeeebad"},"/es/kb/getting-started/organization-vs-company-account-d1d":{"__comp":"17896441","content":"4c41c86d"},"/es/kb/getting-started/search-finding-what-you-need-9ce":{"__comp":"17896441","content":"e5fc8ef8"},"/es/kb/getting-started/what-is-the-difference-between-a-user-and-a-seat-a1e":{"__comp":"17896441","content":"bc525906"},"/es/kb/importing-data/changing-the-field-type-of-a-custom-field-15f":{"__comp":"17896441","content":"6f7c36fa"},"/es/kb/importing-data/how-can-i-format-dates-to-import-into-fintesk-027":{"__comp":"17896441","content":"ce72740e"},"/es/kb/importing-data/import-fields-1d6":{"__comp":"17896441","content":"82ac4542"},"/es/kb/importing-data/importing-advanced-mapping-a82":{"__comp":"17896441","content":"3c864e55"},"/es/kb/importing-data/importing-data-into-fintesk-with-spreadsheets-fb8":{"__comp":"17896441","content":"18c45cef"},"/es/kb/importing-data/importing-mandatory-fields-fbd":{"__comp":"17896441","content":"1a0d2f85"},"/es/kb/importing-data/importing-mapping-your-fields-818":{"__comp":"17896441","content":"94739f67"},"/es/kb/importing-data/importing-sample-import-spreadsheets-f13":{"__comp":"17896441","content":"fae417d8"},"/es/kb/importing-data/transferring-data-to-a-different-fintesk-company-account-8c6":{"__comp":"17896441","content":"a723be2d"},"/es/kb/importing-data/updating-fintesk-data-with-a-spreadsheet-e3e":{"__comp":"17896441","content":"03b5480e"},"/es/kb/importing-data/why-do-my-imported-currency-values-appear-as-0-cb5":{"__comp":"17896441","content":"427f9635"},"/es/kb/list-view-324":{"__comp":"17896441","content":"02e16c96"},"/es/kb/list-view/customizing-the-columns-in-the-list-view-b67":{"__comp":"17896441","content":"2e4f5518"},"/es/kb/list-view/fintesk-system-ids-bdd":{"__comp":"17896441","content":"564fb8f7"},"/es/kb/list-view/how-can-i-add-or-remove-columns-in-the-list-view-a65":{"__comp":"17896441","content":"7c522049"},"/es/kb/list-view/how-can-i-edit-a-field-in-the-list-view-297":{"__comp":"17896441","content":"1aa09a11"},"/es/kb/list-view/how-can-i-set-default-columns-for-all-my-users-in-the-list-view-f13":{"__comp":"17896441","content":"f902ee87"},"/es/kb/personal-settings/fintesk-settings-e58":{"__comp":"17896441","content":"347e304f"},"/es/kb/personal-settings/how-can-i-change-or-reset-my-password-9fc":{"__comp":"17896441","content":"9bf80d53"},"/es/kb/personal-settings/how-can-i-free-up-space-556":{"__comp":"17896441","content":"0cd7de29"},"/es/kb/personal-settings/usage-limits-in-fintesk-81b":{"__comp":"17896441","content":"a5b7cc07"},"/es/kb/pipeline-view-abe":{"__comp":"17896441","content":"59b710f0"},"/es/kb/pipeline-view/how-can-i-delete-a-deal-in-the-pipeline-view-e3e":{"__comp":"17896441","content":"ac075ab0"},"/es/kb/pipeline-view/how-can-i-see-deals-in-a-different-pipeline-6bb":{"__comp":"17896441","content":"514ed3f9"},"/es/kb/pipeline-view/the-rotting-feature-2e9":{"__comp":"17896441","content":"fbb6c010"},"/es/kb/pipelines/how-can-i-add-a-stage-to-my-pipeline-6bf":{"__comp":"17896441","content":"22641f6c"},"/es/kb/pipelines/how-can-i-customize-my-pipeline-stages-d30":{"__comp":"17896441","content":"08067cb9"},"/es/kb/pipelines/how-can-i-have-multiple-pipelines-d47":{"__comp":"17896441","content":"5624265d"},"/es/kb/products-d71":{"__comp":"17896441","content":"8b261a88"},"/es/kb/products/can-i-add-extra-fields-to-the-add-new-product-modal-e57":{"__comp":"17896441","content":"09ccb4b0"},"/es/kb/products/can-i-have-one-product-in-different-price-variations-0e2":{"__comp":"17896441","content":"34ed2666"},"/es/kb/products/can-i-import-products-and-automatically-link-them-to-deals-179":{"__comp":"17896441","content":"e67eab86"},"/es/kb/products/how-can-i-link-products-to-a-deal-d65":{"__comp":"17896441","content":"c5b25b1f"},"/es/kb/products/where-do-i-activate-or-deactivate-individual-products-83e":{"__comp":"17896441","content":"e7f529da"},"/es/kb/troubleshooting/can-fintesk-be-used-offline-0e4":{"__comp":"17896441","content":"c238e8e5"},"/es/kb/troubleshooting/how-can-i-take-a-screenshot-dbf":{"__comp":"17896441","content":"6ed99495"},"/es/kb/troubleshooting/how-do-i-clear-my-browser-s-cache-and-cookies-5af":{"__comp":"17896441","content":"d3d9c1cc"},"/es/kb/troubleshooting/how-do-i-open-my-browser-console-f1c":{"__comp":"17896441","content":"82f61879"},"/es/kb/troubleshooting/troubleshooting-fintesk-web-app-265":{"__comp":"17896441","content":"05a627cd"},"/es/kb/troubleshooting/which-browser-is-best-for-fintesk-e99":{"__comp":"17896441","content":"67b951d4"},"/es/kb/users-and-permissions/global-user-management-9fb":{"__comp":"17896441","content":"bcb7ac82"},"/es/kb/users-and-permissions/how-can-i-add-a-user-8f6":{"__comp":"17896441","content":"4b3a3f77"},"/es/kb/users-and-permissions/how-can-i-deactivate-or-reactivate-a-user-619":{"__comp":"17896441","content":"fc8c514c"},"/es/kb/users-and-permissions/how-can-i-replace-users-in-my-fintesk-company-account-67a":{"__comp":"17896441","content":"40d927e6"},"/es/kb/users-and-permissions/updating-user-information-ca7":{"__comp":"17896441","content":"d01a6831"},"/es/kb/users-and-permissions/users-f34":{"__comp":"17896441","content":"dcdbbd91"},"/es/kb/users-and-permissions/what-is-a-regular-user-e9e":{"__comp":"17896441","content":"335b9b91"},"/es/kb/users-and-permissions/who-is-the-admin-user-of-my-account-4fd":{"__comp":"17896441","content":"e50797ea"},"/es/privacy-5b2":{"__comp":"17896441","content":"2743f5c7"},"/es/privacy/dpa-1fb":{"__comp":"17896441","content":"8a97b6a3"},"/es/privacy/fintesk-data-sub-processors-810":{"__comp":"17896441","content":"fd988e86"},"/es/tos/terms-of-service-ead":{"__comp":"17896441","content":"43a94161"},"/es/-c45":{"__comp":"17896441","content":"de5288b6"}}')

}),

},function(__webpack_require__) {
var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId) }
__webpack_require__.O(0, ["4014",], function() {
        return __webpack_exec__(10354);
      });
var __webpack_exports__ = __webpack_require__.O();

}
]);